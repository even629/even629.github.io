<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>常想一二，不思八九</title>
  <icon>https://even629.com/icon.png</icon>
  <subtitle>blog</subtitle>
  <link href="https://even629.com/atom.xml" rel="self"/>
  
  <link href="https://even629.com/"/>
  <updated>2026-01-26T06:25:13.000Z</updated>
  <id>https://even629.com/</id>
  
  <author>
    <name>even629</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>io_uring</title>
    <link href="https://even629.com/posts/2601261/"/>
    <id>https://even629.com/posts/2601261/</id>
    <published>2026-01-26T07:25:13.000Z</published>
    <updated>2026-01-26T06:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2026-01-26</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p><code>io_uring</code> 是 2019 年 <strong>Linux 5.1</strong> 内核首次引入的高性能 <strong>异步 I&#x2F;O 框架</strong>，能显著加速 I&#x2F;O 密集型应用的性能。 但如果你的应用<strong>已经在使用</strong> 传统 Linux AIO 了，<strong>并且使用方式恰当</strong>， 那 <code>io_uring</code> <strong>并不会带来太大的性能提升</strong>， 根据原文测试，即便打开高级特性，也只有 5%。除非你真的需要这 5% 的额外性能，否则 <strong>切换</strong>成 <code>io_uring</code> <strong>代价可能也挺大</strong>，因为要 <strong>重写应用</strong>来适配 <code>io_uring</code>（或者让依赖的平台或框架去适配，总之需要改代码）。</p><p>既然性能跟传统 AIO 差不多，那为什么还称 <code>io_uring</code> 为革命性技术呢？</p><ol><li>它首先和最大的贡献在于：<strong>统一了 Linux 异步 I&#x2F;O 框架</strong>，<ul><li>Linux AIO <strong>只支持 direct I&#x2F;O</strong> 模式的<strong>存储文件</strong> （storage file），而且主要用在<strong>数据库这一细分领域</strong>；</li><li><code>io_uring</code> 支持存储文件和网络文件（network sockets），也支持更多的异步系统调用 （<code>accept/openat/stat/...</code>），而非仅限于 <code>read/write</code> 系统调用。</li></ul></li><li>在<strong>设计上是真正的异步 I&#x2F;O</strong>，作为对比，Linux AIO 虽然也 是异步的，但仍然可能会阻塞，某些情况下的行为也无法预测；</li><li><strong>灵活性和可扩展性</strong>非常好，甚至能基于 <code>io_uring</code> 重写所有系统调用，而 Linux AIO 设计时就没考虑扩展性。</li></ol><p>eBPF 也算是异步框架（事件驱动），但与 <code>io_uring</code> 没有本质联系，二者属于不同子系统， 并且在模型上有一个本质区别：</p><ol><li><strong>eBPF 对用户是透明的</strong>，只需升级内核（到合适的版本），<strong>应用程序无需任何改造</strong>；</li><li><code>io_uring</code> 提供了<strong>新的系统调用和用户空间 API</strong>，因此<strong>需要应用程序做改造</strong>。</li></ol><p>本文介绍 Linux 异步 I&#x2F;O 的发展历史，<code>io_uring</code> 的原理和功能， 并给出了一些<strong>程序示例</strong>和<strong>性能压测</strong>结果。</p><h1 id="Linux-I-O-系统调用演进"><a href="#Linux-I-O-系统调用演进" class="headerlink" title="Linux I&#x2F;O 系统调用演进"></a>Linux I&#x2F;O 系统调用演进</h1><h2 id="基于-fd-的阻塞式-I-O：read-write"><a href="#基于-fd-的阻塞式-I-O：read-write" class="headerlink" title="基于 fd 的阻塞式 I&#x2F;O：read()/write()"></a>基于 fd 的阻塞式 I&#x2F;O：<code>read()/write()</code></h2><p>作为大家最熟悉的读写方式，Linux 内核提供了<strong>基于文件描述符的系统调用</strong>， 这些描述符指向的可能是<strong>存储文件</strong>（storage file），也可能是 <strong>network sockets</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>二者称为<strong>阻塞式系统调用</strong>（blocking system calls），因为程序调用 这些函数时会进入 sleep 状态，然后被调度出去（让出处理器），直到 I&#x2F;O 操作完成：</p><ul><li>如果数据在文件中，并且文件内容<strong>已经缓存在 page cache 中</strong>，调用会<strong>立即返回</strong>；</li><li>如果数据在另一台机器上，就需要通过网络（例如 TCP）获取，会阻塞一段时间；</li><li>如果数据在硬盘上，也会阻塞一段时间。</li></ul><p>但很容易想到，随着存储<strong>设备越来越快，程序越来越复杂</strong>， 阻塞式（blocking）已经这种最简单的方式已经不适用了。</p><h2 id="非阻塞式-I-O：select-poll-epoll"><a href="#非阻塞式-I-O：select-poll-epoll" class="headerlink" title="非阻塞式 I&#x2F;O：select()/poll()/epoll()"></a>非阻塞式 I&#x2F;O：<code>select()/poll()/epoll()</code></h2><p>阻塞式之后，出现了一些新的、非阻塞的系统调用，例如 <code>select()</code>、<code>poll()</code> 以及更新的 <code>epoll()</code>。 应用程序在调用这些函数读写时不会阻塞，而是<strong>立即返回</strong>，返回的是一个 <strong>已经 ready 的文件描述符列表</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260127125426494.png" alt="epoll" loading="lazy"></p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">select</button><button type="button" class="tab">poll</button><button type="button" class="tab">epoll</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>select()</strong></p><ul><li><strong>跨平台</strong>（Linux、Windows、macOS 都支持）</li><li><strong>最大 fd 数受限</strong>：通常为 <code>FD_SETSIZE = 1024</code></li><li><strong>使用位图（fd_set）</strong> 表示要监听的 fd 集合</li><li>每次调用需：<ul><li>将用户空间的 fd_set 拷贝到内核；</li><li>内核遍历所有 fd 检查状态；</li><li>返回时再将整个 fd_set 拷回用户空间；</li><li>用户需遍历全部 fd 判断哪些就绪。</li></ul></li><li><strong>仅支持水平触发（LT）</strong></li><li><strong>缺点</strong>：<ul><li>fd 数量上限低；</li><li>每次调用都要全量拷贝 + 全量轮询 → O(n) 时间复杂度；</li><li>编程繁琐（需维护三个 fd_set：读、写、异常）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">           fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-item-content"><p><strong>poll()</strong></p><ul><li><strong>Linux&#x2F;Unix 支持</strong>，<strong>Windows 不支持</strong></li><li>使用 <code>struct pollfd</code> 数组替代位图，突破 1024 限制（仅受系统 ulimit 限制）</li><li>仍需每次将整个数组传入内核，内核遍历检查，返回后用户仍需遍历找就绪 fd</li><li><strong>仍为 O(n) 轮询模型</strong></li><li><strong>仅支持 LT 模式</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;       <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 关注的事件（POLLIN, POLLOUT）</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件（由内核填写）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>✅ 优点：无 1024 限制<br>❌ 缺点：性能仍差于 epoll（大规模连接下）</p></div><div class="tab-item-content"><p><strong>epoll()</strong></p><ul><li><p><strong>Linux 特有</strong>，不跨平台</p></li><li><p><strong>基于事件驱动 + 内核回调机制</strong></p></li><li><p><strong>三个核心函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;          <span class="comment">// 创建 epoll 实例（现多用 epoll_create1）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>; <span class="comment">// 注册/修改/删除 fd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>; <span class="comment">// 等待事件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>内核数据结构</strong>：</p><ul><li><strong>红黑树</strong>：存储所有注册的 fd（增删改 O(log n)）</li><li><strong>就绪双向链表</strong>：当 fd 就绪，内核自动将其加入链表</li></ul></li><li><p><code>epoll_wait()</code> <strong>直接返回就绪事件列表</strong>，无需遍历全部 fd → <strong>O(1) 获取就绪事件</strong></p></li><li><p><strong>支持两种触发模式</strong>：</p><ul><li><strong>LT（Level Triggered）</strong>：默认模式，只要缓冲区有数据就持续通知（类似 poll）</li><li><strong>ET（Edge Triggered）</strong>：仅在状态变化时通知一次（如从不可读→可读），需配合非阻塞 I&#x2F;O，一次性读完数据</li></ul></li></ul><p>✅ 优点：</p><ul><li>高效处理 <strong>万级甚至百万级并发连接</strong>（如 Nginx、Redis、Kafka）</li><li>无 fd 数量硬限制</li><li>内存拷贝少（只在注册时传一次，事件发生时只返回就绪项）</li></ul><p>❌ 缺点：</p><ul><li>仅限 Linux</li><li>ET 模式编程复杂（易漏读数据）</li></ul><blockquote><p><code>epoll</code> 监控一个普通文件 fd <strong>没有意义</strong>——它会不断触发事件，但无法实现“异步通知数据到来”的目的。</p></blockquote></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><div class="tip error"><p>但这种方式存在一个致命缺点：<strong>只支持 network sockets 和 pipes</strong> —— epoll() 甚至连 storage files 都不支持。 </p></div><h2 id="线程池方式"><a href="#线程池方式" class="headerlink" title="线程池方式"></a>线程池方式</h2><p>对于 storage I&#x2F;O，经典的解决思路是 <strong>thread pool</strong>： 主线程将 I&#x2F;O 分发给 worker 线程，后者代替主线程进行阻塞式读写，主线程不会阻塞。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260127125517755.png" alt="thread pool" loading="lazy"></p><p>这种方式的问题是<strong>线程上下文切换开销可能非常大</strong>，后面性能压测会看到。</p><h2 id="Direct-I-O（数据库软件）：绕过-page-cache"><a href="#Direct-I-O（数据库软件）：绕过-page-cache" class="headerlink" title="Direct I&#x2F;O（数据库软件）：绕过 page cache"></a>Direct I&#x2F;O（数据库软件）：绕过 page cache</h2><p>随后出现了更加灵活和强大的方式：<strong>数据库软件</strong>（database software） 有时 并不想使用操作系统的 page cache， 而是希望打开一个文件后，<strong>直接从设备读写这个文件</strong>（direct access to the device）。 这种方式称为<strong>直接访问</strong>（direct access）或<strong>直接 I&#x2F;O</strong>（direct I&#x2F;O），</p><ul><li>需要指定 <strong><code>O_DIRECT</code></strong> flag；</li><li>需要<strong>应用自己管理自己的缓存</strong> —— 这正是数据库软件所希望的；</li><li>是 <strong>zero-copy I&#x2F;O</strong>，因为应用的缓冲数据直接发送到设备，或者直接从设备读取。</li></ul><h2 id="异步-IO（AIO）"><a href="#异步-IO（AIO）" class="headerlink" title="异步 IO（AIO）"></a>异步 IO（AIO）</h2><p>前面提到，随着存储设备越来越快，主线程和 worker 线性之间的上下文切换开销占比越来越高。 现在市场上的一些设备，例如 Intel Optane，<strong>延迟已经低到和上下文切换一个量级</strong>（微秒 <code>us</code>）。换个方式描述， 更能让我们感受到这种开销： <strong>上下文每切换一次，我们就少一次 dispatch I&#x2F;O 的机会</strong>。</p><blockquote><p>dispatch I&#x2F;O 指<strong>提交（发起）一个 I&#x2F;O 请求</strong>给存储设备的动作。</p><p>在高性能系统中（如数据库、KV 存储），目标是<strong>尽可能多地并发 dispatch I&#x2F;O</strong>，让设备满负荷工作（因为设备支持高队列深度，比如 NVMe 支持数千个并发命令）。</p></blockquote><p>因此，Linux <strong>2.6</strong> 内核引入了异步 I&#x2F;O（asynchronous I&#x2F;O）接口， 方便起见，本文简写为 <code>linux-aio</code>。AIO <strong>原理</strong>是很简单的：</p><ul><li>用户通过 <code>io_submit()</code> 提交 I&#x2F;O 请求，</li><li>过一会再调用 <code>io_getevents()</code> 来检查哪些 events 已经 ready 了。</li><li>使程序员<strong>能编写完全异步的代码</strong>。</li></ul><p>近期，Linux AIO 甚至支持了 <code>epoll()</code>：也就是说 不仅能提交 storage I&#x2F;O 请求，还能提交网络 I&#x2F;O 请求。照这样发展下去，linux-aio <strong>似乎能成为一个王者</strong>。但由于它糟糕的演进之路，这个愿望几乎不可能实现了。 我们从 <strong>Linus 标志性的激烈言辞中就能略窥一斑</strong>：</p><blockquote><p>Reply to: <a href="https://lwn.net/Articles/671657/">to support opening files asynchronously</a></p><p><em>So I think this is ridiculously ugly.</em></p><p><em>AIO is a horrible ad-hoc design, with the main excuse being “other, less gifted people, made that design, and we are implementing it for compatibility because database people — who seldom have any shred of taste — actually use it”.</em></p><p>— Linus Torvalds (on lwn.net)</p></blockquote><p>Linux AIO 确实问题缠身:</p><ol><li><strong>只支持 <code>O_DIRECT</code> 文件</strong>，因此<strong>对常规的非数据库应用</strong> （normal, non-database applications）<strong>几乎是无用的</strong>；</li><li>接口在<strong>设计时并未考虑扩展性</strong>。虽然可以扩展 —— 确实这么做了 —— 但每加一个东西都相当复杂；</li><li>虽然从<strong>技术上说接口是非阻塞的</strong>，但实际上有 很多可能的原因都会导致它阻塞，而且引发的方式难以预料。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上可以清晰地看出 Linux I&#x2F;O 的演进：</p><ul><li>最开始是同步（阻塞式）系统调用；</li><li>然后随着<strong>实际需求和具体场景</strong>，不断加入新的异步接口，还要保持与老接口的兼容和协同工作。</li></ul><p>另外也看到，在非阻塞式读写的问题上<strong>并没有形成统一方案</strong>：</p><ol><li>Network socket 领域：添加一个异步接口，然后去轮询（poll）请求是否完成（readiness）；</li><li>Storage I&#x2F;O 领域：<strong>只针对某一细分领域</strong>（数据库）在某一特定时期的需求，添加了一个定制版的异步接口。</li></ol><p><strong>这就是 Linux I&#x2F;O 的演进历史</strong> —— 只着眼当前，出现一个问题就引入一种设计，而并没有多少前瞻性 —— 直到 <code>io_uring</code> 的出现。</p><h1 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h1><p>io_uring 来自资深内核开发者 Jens Axboe 的想法，他在 Linux I&#x2F;O stack 领域颇有研究。 从最早的 <code>patch aio: support for IO polling</code> 可以看出，这项工作始于一个很简单的观察：随着设备越来越快， <strong>中断驱动（interrupt-driven）模式效率已经低于轮询模式</strong> （<code>polling for completions</code>） —— 这也是高性能领域最常见的主题之一。</p><ul><li><code>io_uring</code> 的<strong>基本逻辑与 linux-aio 是类似的</strong>：提供两个接口，一个将 I&#x2F;O 请求提交到内核，一个从内核接收完成事件。</li><li>但随着开发深入，它逐渐变成了一个完全不同的接口：设计者开始从源头思考 <strong>如何支持完全异步的操作</strong>。</li></ul><h2 id="与-Linux-AIO-的不同"><a href="#与-Linux-AIO-的不同" class="headerlink" title="与 Linux AIO 的不同"></a>与 Linux AIO 的不同</h2><p><code>io_uring</code> 与 <code>linux-aio</code> 有着本质的不同：</p><ol><li><p><strong>在设计上是真正异步的</strong>（truly asynchronous）。只要 设置了合适的 flag，它在<strong>系统调用上下文中就只是将请求放入队列</strong>， 不会做其他任何额外的事情，<strong>保证了应用永远不会阻塞</strong>。</p></li><li><p><strong>支持任何类型的 I&#x2F;O</strong>：cached files、direct-access files 甚至 blocking sockets。</p><p>由于设计上就是异步的（async-by-design nature），因此<strong>无需 poll+read&#x2F;write 来处理 sockets</strong>。 只需提交一个阻塞式读（blocking read），请求完成之后，就会出现在 completion ring。</p></li><li><p><strong>灵活、可扩展</strong>：基于 <code>io_uring</code> 甚至能重写（re-implement）Linux 的每个系统调用。</p></li></ol><h2 id="原理及核心数据结构：SQ-CQ-SQE-CQE"><a href="#原理及核心数据结构：SQ-CQ-SQE-CQE" class="headerlink" title="原理及核心数据结构：SQ&#x2F;CQ&#x2F;SQE&#x2F;CQE"></a>原理及核心数据结构：SQ&#x2F;CQ&#x2F;SQE&#x2F;CQE</h2><p>每个 io_uring 实例都有<strong>两个环形队列</strong>（ring），在内核和应用程序之间共享：</p><ul><li><strong>提交队列</strong>：submission queue (SQ)</li><li><strong>完成队列</strong>：completion queue (CQ)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260127125604724.png" alt="io_uring" loading="lazy"></p><p>这两个队列：</p><ul><li>都是<strong>单生产者、单消费者</strong>，size 是 2 的幂次；</li><li>提供<strong>无锁接口</strong>（lock-less access interface），内部使用 <strong>内存屏障</strong>做同步（coordinated with memory barriers）。</li></ul><p><strong>使用方式</strong>：</p><ul><li>请求<ul><li>应用创建 SQ entries (SQE)，更新 SQ tail；</li><li>内核消费 SQE，更新 SQ head。</li></ul></li><li>完成<ul><li>内核为完成的一个或多个请求创建 CQ entries (CQE)，更新 CQ tail；</li><li>应用消费 CQE，更新 CQ head。</li><li>完成事件（completion events）可能以任意顺序到达，到总是与特定的 SQE 相关联的。</li><li>消费 CQE 过程无需切换到内核态。</li></ul></li></ul><h2 id="带来的好处"><a href="#带来的好处" class="headerlink" title="带来的好处"></a>带来的好处</h2><p><code>io_uring</code> 这种请求方式还有一个好处是：原来需要多次系统调用（读或写），现在变成批处理一次提交。<code>io_uring</code> <strong>将这种批处理能力带给了</strong> storage I&#x2F;O 系统调用之外的 <strong>其他一些系统调用</strong>，包括：</p><ul><li><code>read</code></li><li><code>write</code></li><li><code>send</code></li><li><code>recv</code></li><li><code>accept</code></li><li><code>openat</code></li><li><code>stat</code></li><li>专用的一些系统调用，例如 <code>fallocate</code></li></ul><p>此外，<code>io_uring</code> 使异步 I&#x2F;O 的使用场景也不再仅限于数据库应用，<strong>普通的 非数据库应用也能用</strong>。这一点值得重复一遍：</p><blockquote><p>虽然 <code>io_uring</code> 与 <code>aio</code> 有一些相似之处，但它的<strong>扩展性和架构是革命性的</strong>： 它<strong>将异步操作的强大能力带给了所有应用</strong>（及其开发者），而 <strong>不再仅限于是数据库应用这一细分领域</strong>。</p></blockquote><p>Avi Kivity 在 the Core C++ 2019 event 上 <a href="https://www.scylladb.com/2020/03/26/avi-kivity-at-core-c-2019">有一次关于 async 的分享</a>。 核心点包括：<strong>从延迟上来说</strong>，</p><ol><li>现代多核、多 CPU 设备，其内部本身就是一个基础网络；</li><li><strong>CPU 之间</strong>是另一个网络；</li><li><strong>CPU 和磁盘 I&#x2F;O 之间</strong>又是一个网络。</li></ol><p>因此网络编程采用异步是明智的，而现在开发自己的应用也应该考虑异步。 这<strong>从根本上改变了 Linux 应用的设计方式</strong>：</p><ul><li>之前都是一段顺序代码流，需要系统调用时才执行系统调用，</li><li>现在需要思考一个文件是否 ready，因而自然地引入 event-loop，不断通过共享 buffer 提交请求和接收结果。</li></ul><h2 id="三种工作模式"><a href="#三种工作模式" class="headerlink" title="三种工作模式"></a>三种工作模式</h2><p>io_uring 实例可工作在三种模式：</p><ol><li><p><strong>中断驱动模式</strong>（interrupt driven）</p><p><strong>默认模式</strong>。可通过 io_uring_enter() 提交 I&#x2F;O 请求，然后直接检查 CQ 状态判断是否完成。</p></li><li><p><strong>轮询模式</strong>（polled）</p><p>Busy-waiting for an I&#x2F;O completion，而不是通过异步 IRQ（Interrupt Request）接收通知。</p><p>这种模式需要文件系统（如果有）和块设备（block device）支持轮询功能。 相比中断驱动方式，这种方式延迟更低（连系统调用都省了）， 但可能会消耗更多 CPU 资源。</p><p>目前，只有指定了 <code>O_DIRECT</code> flag 打开的文件描述符，才能使用这种模式。当一个读 或写请求提交给轮询上下文（polled context）之后，应用（application）必须调用 <code>io_uring_enter()</code> 来轮询 CQ 队列，判断请求是否已经完成。</p><p>对一个 io_uring 实例来说，<strong>不支持混合使用轮询和非轮询模式</strong>。</p></li><li><p><strong>内核轮询模式</strong>（kernel polled）</p><p>这种模式中，会 <strong>创建一个内核线程</strong>（kernel thread）来执行 SQ 的轮询工作。</p><p>使用这种模式的 io_uring 实例， <strong>应用无需切到到内核态</strong> 就能触发（issue）I&#x2F;O 操作。 通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I&#x2F;O（submit and reap I&#x2F;Os）。</p><p>如果内核线程的空闲时间超过了用户的配置值，它会通知应用，然后进入 idle 状态。 这种情况下，应用必须调用 <code>io_uring_enter()</code> 来唤醒内核线程。如果 I&#x2F;O 一直很繁忙，内核线性是不会 sleep 的。</p></li></ol><h2 id="io-uring-系统调用-API"><a href="#io-uring-系统调用-API" class="headerlink" title="io_uring 系统调用 API"></a>io_uring 系统调用 API</h2><p>有三个：</p><ul><li><code>io_uring_setup(2)</code></li><li><code>io_uring_register(2)</code></li><li><code>io_uring_enter(2)</code></li></ul><p>下面展开介绍。完整文档见 <a href="https://github.com/axboe/liburing/tree/master/man">manpage</a>。</p><h3 id="io-uring-setup"><a href="#io-uring-setup" class="headerlink" title="io_uring_setup()"></a>io_uring_setup()</h3><p>执行异步 I&#x2F;O 需要先<strong>设置上下文</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_setup</span><span class="params">(u32 entries, <span class="keyword">struct</span> io_uring_params *p)</span>;</span><br></pre></td></tr></table></figure><p>这个系统调用</p><ul><li><strong>创建一个 SQ 和一个 CQ</strong>，</li><li>queue size 至少 <code>entries</code> 个元素，</li><li>返回一个文件描述符，随后用于在这个 io_uring 实例上执行操作。</li></ul><p>SQ 和 CQ 在应用和内核之间共享，避免了在初始化和完成 I&#x2F;O 时（initiating and completing I&#x2F;O）拷贝数据。</p><p>对于参数 p：</p><ul><li>对于应用来讲是用来配置 io_uring，</li><li>内核返回的 SQ&#x2F;CQ 配置信息也通过它带回来。</li></ul><p><code>io_uring_setup()</code> 成功时返回一个文件描述符（fd）。应用随后可以将这个 fd 传给 mmap(2) 系统调用，来 map the submission and completion queues 或者传给 <code>io_uring_register()</code> 或者<code>io_uring_enter()</code>system calls.</p><h3 id="io-uring-register"><a href="#io-uring-register" class="headerlink" title="io_uring_register()"></a>io_uring_register()</h3><p>注册用于异步 I&#x2F;O 的<strong>文件或用户缓冲区</strong>（files or user buffers）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_register</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> opcode, <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">int</span> nr_args)</span>;</span><br></pre></td></tr></table></figure><p>注册文件或用户缓冲区，使内核能<strong>长时间持有对该文件在内核内部的数据结构引用</strong>（internal kernel data structures associated with the files）， 或创建<strong>应用内存的长期映射</strong>（long term mappings of application memory associated with the buffers）， 这个操作只会在注册时执行一次，而不是每个 I&#x2F;O 请求都会处理，因此减少了 per-I&#x2F;O overhead。</p><h4 id="注册的缓冲区（buffer）性质"><a href="#注册的缓冲区（buffer）性质" class="headerlink" title="注册的缓冲区（buffer）性质"></a>注册的缓冲区（buffer）性质</h4><ul><li>Registered buffers 将会<strong>被锁定在内存中</strong>（be locked in memory），并<strong>计入用户的 RLIMIT_MEMLOCK</strong> 资源限制。</li><li>此外，每个 buffer 有 <strong>1GB 的大小限制</strong>。</li><li>当前，buffers 必须是<strong>匿名、非文件后端的内存</strong>（anonymous, non-file-backed memory），例如 malloc(3) or mmap(2) with the MAP_ANONYMOUS flag set 返回的内存。</li><li>Huge pages 也是支持的。整个 huge page 都会被 pin 到内核，即使只用到了其中一部分。</li><li>已经注册的 buffer 无法调整大小，想调整只能先 unregister，再重新 register 一个新的。</li></ul><h4 id="通过-eventfd-订阅-completion-事件"><a href="#通过-eventfd-订阅-completion-事件" class="headerlink" title="通过 eventfd() 订阅 completion 事件"></a>通过 <code>eventfd()</code> 订阅 completion 事件</h4><p>可以用 <code>eventfd(2)</code> 订阅 io_uring 实例的 completion events。 将 eventfd 描述符通过这个系统调用注册就行了。</p><blockquote><p>The credentials of the running application can be registered with io_uring which returns an id associated with those credentials. Applications wishing to share a ring between separate users&#x2F;processes can pass in this credential id in the SQE personality field. If set, that particular SQE will be issued with these credentials.</p></blockquote><h3 id="io-uring-enter"><a href="#io-uring-enter" class="headerlink" title="io_uring_enter()"></a>io_uring_enter()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_enter</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> to_submit, <span class="type">unsigned</span> <span class="type">int</span> min_complete, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="type">sigset_t</span> *sig)</span>;</span><br></pre></td></tr></table></figure><p>这个系统调用用于初始化和完成（initiate and complete）I&#x2F;O，使用共享的 SQ 和 CQ。 单次调用同时执行：</p><ol><li>提交新的 I&#x2F;O 请求</li><li>等待 I&#x2F;O 完成</li></ol><p>参数：</p><ol><li><code>fd</code> 是 <code>io_uring_setup()</code> 返回的文件描述符；</li><li><code>to_submit</code> 指定了 SQ 中提交的 I&#x2F;O 数量；</li><li>依据不同模式：<ul><li>默认模式，如果指定了 <code>min_complete</code>，会等待这个数量的 I&#x2F;O 事件完成再返回；</li><li>如果 io_uring 是 polling 模式，这个参数表示：<ul><li>0：要求内核返回当前以及完成的所有 events，无阻塞；</li><li>非零：如果有事件完成，内核仍然立即返回；如果没有完成事件，内核会 poll，等待指定的次数完成，或者这个进程的时间片用完。</li></ul></li></ul></li></ol><p>注意：对于 interrupt driven I&#x2F;O，<strong>应用无需进入内核就能检查 CQ 的 event completions</strong>。</p><p><code>io_uring_enter()</code> 支持很多操作，包括：</p><ul><li>Open, close, and stat files</li><li>Read and write into multiple buffers or pre-mapped buffers</li><li>Socket I&#x2F;O operations</li><li>Synchronize file state</li><li>Asynchronously monitor a set of file descriptors</li><li>Create a timeout linked to a specific operation in the ring</li><li>Attempt to cancel an operation that is currently in flight</li><li>Create I&#x2F;O chains</li><li>Ordered execution within a chain</li><li>Parallel execution of multiple chains</li></ul><p>当这个系统调用返回时，表示一定数量的 SEQ 已经被消费和提交了，此时可以安全的重用队列中的 SEQ。 此时 IO 提交有可能还停留在异步上下文中，即实际上 SQE 可能还没有被提交 —— 不过 用户不用关心这些细节 —— 当随后内核需要使用某个特定的 SQE 时，它已经复制了一份。</p><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><p><code>io_uring</code> 提供了一些用于特殊场景的高级特性：</p><ol><li><strong>File registration</strong>（文件注册）：每次发起一个指定文件描述的操 作，内核都需要<strong>花费一些时钟周期</strong>（cycles）<strong>将文件描述符映射到内部表示</strong>。 对于那些<strong>针对同一文件进行重复操作</strong>的场景，<code>io_uring</code> 支持<strong>提前注册这些文件</strong>，后面直接查找就行了。</li><li><strong>Buffer registration</strong>（缓冲区注册）：与 file registration 类 似，direct I&#x2F;O 场景中，内核需要 map&#x2F;unmap memory areas。<code>io_uring</code> 支持提前 注册这些缓冲区（buffers）。</li><li><strong>Poll ring</strong>（轮询环形缓冲区）：对于非常快是设备，处理中断的开 销是比较大的。<code>io_uring</code> 允许用户关闭中断，使用轮询模式。前面“三种工作模式”小节 也介绍到了这一点。</li><li><strong>Linked operations</strong>（链接操作）：允许用户发送串联的请求。这两 个请求同时提交，但后面的会等前面的处理完才开始执行。</li></ol><h2 id="用户空间库-liburing"><a href="#用户空间库-liburing" class="headerlink" title="用户空间库 liburing"></a>用户空间库 <code>liburing</code></h2><p><a href="https://github.com/axboe/liburing/"><code>liburing</code></a> 提供了一个简单的高层 API， 可用于一些基本场景，应用程序避免了直接使用更底层的系统调用。 此外，这个 API 还避免了一些重复操作的代码，如设置 io_uring 实例。</p><p>举个例子，在 <code>io_uring_setup()</code> 的 manpage 描述中，调用这个系统调用获得一个 ring 文 件描述符之后，应用必须调用 <code>mmap()</code> 来这样的逻辑需要一段略长的代码，而用 <code>liburing</code> 的话，下面的函数已经将上述流程封装好了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_queue_init</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> flags)</span>;</span><br></pre></td></tr></table></figure><p>下一节来看两个例子基于 liburing 的例子。</p><h1 id="基于-liburing-的示例应用"><a href="#基于-liburing-的示例应用" class="headerlink" title="基于 liburing 的示例应用"></a>基于 liburing 的示例应用</h1><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/axboe/liburing.git</span><br><span class="line">$ git checkout -b liburing-2.0 tags/liburing-2.0</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> liburing</span><br><span class="line">$ <span class="built_in">ls</span> examples/</span><br><span class="line">io_uring-cp  io_uring-cp.c  io_uring-test  io_uring-test.c  link-cp  link-cp.c  Makefile  ucontext-cp  ucontext-cp.c</span><br><span class="line"></span><br><span class="line">$ make -j4</span><br><span class="line"></span><br><span class="line">$ ./examples/io_uring-test &lt;file&gt;</span><br><span class="line">Submitted=4, completed=4, bytes=16384</span><br><span class="line"></span><br><span class="line">$ ./examples/link-cp &lt;in-file&gt; &lt;out-file&gt;</span><br></pre></td></tr></table></figure><h2 id="io-uring-test"><a href="#io-uring-test" class="headerlink" title="io_uring-test"></a>io_uring-test</h2><p>这个程序使用 4 个 SQE，从输入文件中<strong>读取最多 16KB 数据</strong>。</p><h3 id="源码及注释"><a href="#源码及注释" class="headerlink" title="源码及注释"></a>源码及注释</h3><p>为方便看清主要逻辑，忽略了一些错误处理代码，完整代码见 <a href="https://github.com/axboe/liburing/blob/liburing-2.0/examples/io_uring-test.c">io_uring-test.c</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: MIT */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Simple app that demonstrates how to setup an io_uring interface,</span></span><br><span class="line"><span class="comment"> * submit and complete IO against it, and then tear it down.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * gcc -Wall -O2 -D_GNU_SOURCE -o io_uring-test io_uring-test.c -luring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;liburing.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QD    4 <span class="comment">// io_uring 队列长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, fd, pending, done;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化一个 io_uring 实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    ret = io_uring_queue_init(QD,    <span class="comment">// 队列长度</span></span><br><span class="line">                              &amp;ring, <span class="comment">// io_uring 实例</span></span><br><span class="line">                              <span class="number">0</span>);    <span class="comment">// flags，0 表示默认配置，例如使用中断驱动模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 打开输入文件，注意这里指定了 O_DIRECT flag，内核轮询模式需要这个 flag，见前面介绍</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY | O_DIRECT);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    fstat(fd, &amp;sb); <span class="comment">// 获取文件信息，例如文件长度，后面会用到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 初始化 4 个读缓冲区</span></span><br><span class="line">    <span class="type">ssize_t</span> fsize = <span class="number">0</span>;             <span class="comment">// 程序的最大读取长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iovecs</span> =</span> <span class="built_in">calloc</span>(QD, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iovec));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; QD; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (posix_memalign(&amp;buf, <span class="number">4096</span>, <span class="number">4096</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        iovecs[i].iov_base = buf;  <span class="comment">// 起始地址</span></span><br><span class="line">        iovecs[i].iov_len = <span class="number">4096</span>;  <span class="comment">// 缓冲区大小</span></span><br><span class="line">        fsize += <span class="number">4096</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 依次准备 4 个 SQE 读请求，指定将随后读入的数据写入 iovecs </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        sqe = io_uring_get_sqe(&amp;ring);  <span class="comment">// 获取可用 SQE</span></span><br><span class="line">        io_uring_prep_readv(sqe,        <span class="comment">// 用这个 SQE 准备一个待提交的 read 操作</span></span><br><span class="line">                            fd,         <span class="comment">// 从 fd 打开的文件中读取数据</span></span><br><span class="line">                            &amp;iovecs[i], <span class="comment">// iovec 地址，读到的数据写入 iovec 缓冲区</span></span><br><span class="line">                            <span class="number">1</span>,          <span class="comment">// iovec 数量</span></span><br><span class="line">                            offset);    <span class="comment">// 读取操作的起始地址偏移量</span></span><br><span class="line">        offset += iovecs[i].iov_len;    <span class="comment">// 更新偏移量，下次使用</span></span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offset &gt; sb.st_size)        <span class="comment">// 如果超出了文件大小，停止准备后面的 SQE</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 提交 SQE 读请求</span></span><br><span class="line">    ret = io_uring_submit(&amp;ring);       <span class="comment">// 4 个 SQE 一次提交，返回提交成功的 SQE 数量</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;io_uring_submit: %s\n&quot;</span>, strerror(-ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret != i) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;io_uring_submit submitted less %d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 等待读请求完成（CQE）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    done = <span class="number">0</span>;</span><br><span class="line">    pending = ret;</span><br><span class="line">    fsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pending; i++) &#123;</span><br><span class="line">        io_uring_wait_cqe(&amp;ring, &amp;cqe);  <span class="comment">// 等待系统返回一个读完成事件</span></span><br><span class="line">        done++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res != <span class="number">4096</span> &amp;&amp; cqe-&gt;res + fsize != sb.st_size) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ret=%d, wanted 4096\n&quot;</span>, cqe-&gt;res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fsize += cqe-&gt;res;</span><br><span class="line">        io_uring_cqe_seen(&amp;ring, cqe);   <span class="comment">// 更新 io_uring 实例的完成队列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 打印统计信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Submitted=%d, completed=%d, bytes=%lu\n&quot;</span>, pending, done, (<span class="type">unsigned</span> <span class="type">long</span>) fsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 清理工作</span></span><br><span class="line">    close(fd);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>代码中已经添加了注释，这里再解释几点：</p><ul><li>每个 SQE 都执行一个 allocated buffer，后者是用 <code>iovec</code> 结构描述的；</li><li>第 3 &amp; 4 步：初始化所有 SQE，用于接下来的 <code>IORING_OP_READV</code> 操作，后者 <strong>提供了 <code>readv(2)</code> 系统调用的异步接口</strong>。</li><li>操作完成之后，这个 SQE iovec buffer 中存放的是相关 <code>readv</code> 操作的结果；</li><li>接下来调用 <code>io_uring_wait_cqe()</code> 来 reap CQE，并通过 <code>cqe-&gt;res</code> 字段验证读取的字节数；</li><li><code>io_uring_cqe_seen()</code> 通知内核这个 CQE 已经被消费了。</li></ul><h2 id="link-cp"><a href="#link-cp" class="headerlink" title="link-cp"></a>link-cp</h2><p>link-cp 使用 io_uring 高级特性 SQE chaining 特性来复制文件。</p><h3 id="I-O-chain"><a href="#I-O-chain" class="headerlink" title="I&#x2F;O chain"></a>I&#x2F;O chain</h3><p>io_uring 支持创建 I&#x2F;O chain。一个 chain 内的 I&#x2F;O 是顺序执行的，多个 I&#x2F;O chain 可以并行执行。</p><p><code>io_uring_enter()</code> manpage 中对 <code>IOSQE_IO_LINK</code> 有 <a href="https://www.mankier.com/2/io_uring_enter#Description-IOSQE_IO_LINK">详细解释</a>：</p><blockquote><p>When this flag is specified, it forms a link with the next SQE in the submission ring. That next SQE will not be started before this one completes. This, in effect, forms a chain of SQEs, which can be arbitrarily long. The tail of the chain is denoted by the first SQE that does not have this flag set. This flag has no effect on previous SQE submissions, nor does it impact SQEs that are outside of the chain tail. This means that multiple chains can be executing in parallel, or chains and individual SQEs. Only members inside the chain are serialized. A chain of SQEs will be broken, if any request in that chain ends in error. io_uring considers any unexpected result an error. This means that, eg, a short read will also terminate the remainder of the chain. If a chain of SQE links is broken, the remaining unstarted part of the chain will be terminated and completed with -ECANCELED as the error code. Available since 5.3.</p></blockquote><p>为实现复制文件功能，link-cp 创建一个长度为 2 的 SQE chain。</p><ul><li>第一个 SQE 是一个读请求，将数据从输入文件读到 buffer；</li><li>第二个请求，与第一个请求是 linked，是一个写请求，将数据从 buffer 写入输出文件。</li></ul><h3 id="源码及注释-1"><a href="#源码及注释-1" class="headerlink" title="源码及注释"></a>源码及注释</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: MIT */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Very basic proof-of-concept for doing a copy with linked SQEs. Needs a</span></span><br><span class="line"><span class="comment"> * bit of error handling and short read love.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;liburing.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QD    64         <span class="comment">// io_uring 队列长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BS    (32*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> infd, outfd;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> inflight;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 read-&gt;write SQE chain</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">queue_rw_pair</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">off_t</span> size, <span class="type">off_t</span> offset)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(size + <span class="keyword">sizeof</span>(*data));</span><br><span class="line">    data = ptr + size;</span><br><span class="line">    data-&gt;index = <span class="number">0</span>;</span><br><span class="line">    data-&gt;offset = offset;</span><br><span class="line">    data-&gt;iov.iov_base = ptr;</span><br><span class="line">    data-&gt;iov.iov_len = size;</span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);                            <span class="comment">// 获取可用 SQE</span></span><br><span class="line">    io_uring_prep_readv(sqe, infd, &amp;data-&gt;iov, <span class="number">1</span>, offset);   <span class="comment">// 准备 read 请求</span></span><br><span class="line">    sqe-&gt;flags |= IOSQE_IO_LINK;                             <span class="comment">// 设置为 LINK 模式</span></span><br><span class="line">    io_uring_sqe_set_data(sqe, data);                        <span class="comment">// 设置 data</span></span><br><span class="line"></span><br><span class="line">    sqe = io_uring_get_sqe(ring);                            <span class="comment">// 获取另一个可用 SQE</span></span><br><span class="line">    io_uring_prep_writev(sqe, outfd, &amp;data-&gt;iov, <span class="number">1</span>, offset); <span class="comment">// 准备 write 请求</span></span><br><span class="line">    io_uring_sqe_set_data(sqe, data);                        <span class="comment">// 设置 data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完成（completion）事件：释放 SQE 的内存缓冲区，通知内核已经消费了 CQE。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_cqe</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="keyword">struct</span> io_uring_cqe *cqe)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> io_uring_cqe_get_data(cqe);       <span class="comment">// 获取 CQE</span></span><br><span class="line">    data-&gt;index++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cqe-&gt;res == -ECANCELED) &#123;</span><br><span class="line">            queue_rw_pair(ring, BS, data-&gt;offset);</span><br><span class="line">            inflight += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;cqe error: %s\n&quot;</span>, strerror(cqe-&gt;res));</span><br><span class="line">            ret = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;index == <span class="number">2</span>) &#123;        <span class="comment">// read-&gt;write chain 完成，释放缓冲区内存</span></span><br><span class="line">        <span class="type">void</span> *ptr = (<span class="type">void</span> *) data - data-&gt;iov.iov_len;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io_uring_cqe_seen(ring, cqe);  <span class="comment">// 通知内核已经消费了 CQE 事件</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_file</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">off_t</span> insize)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_cqe</span> *<span class="title">cqe</span>;</span></span><br><span class="line">    <span class="type">size_t</span> this_size;</span><br><span class="line">    <span class="type">off_t</span> offset;</span><br><span class="line"></span><br><span class="line">    offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (insize) &#123;                      <span class="comment">// 数据还没处理完</span></span><br><span class="line">        <span class="type">int</span> has_inflight = inflight;      <span class="comment">// 当前正在进行中的 SQE 数量</span></span><br><span class="line">        <span class="type">int</span> depth;  <span class="comment">// SQE 阈值，当前进行中的 SQE 数量（inflight）超过这个值之后，需要阻塞等待 CQE 完成</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (insize &amp;&amp; inflight &lt; QD) &#123; <span class="comment">// 数据还没处理完，io_uring 队列也还没用完</span></span><br><span class="line">            this_size = BS;</span><br><span class="line">            <span class="keyword">if</span> (this_size &gt; insize)       <span class="comment">// 最后一段数据不足 BS 大小</span></span><br><span class="line">                this_size = insize;</span><br><span class="line"></span><br><span class="line">            queue_rw_pair(ring, this_size, offset); <span class="comment">// 创建一个 read-&gt;write chain，占用两个 SQE</span></span><br><span class="line">            offset += this_size;</span><br><span class="line">            insize -= this_size;</span><br><span class="line">            inflight += <span class="number">2</span>;                <span class="comment">// 正在进行中的 SQE 数量 +2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (has_inflight != inflight)     <span class="comment">// 如果有新创建的 SQE，</span></span><br><span class="line">            io_uring_submit(ring);        <span class="comment">// 就提交给内核</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (insize)                       <span class="comment">// 如果还有 data 等待处理，</span></span><br><span class="line">            depth = QD;                   <span class="comment">// 阈值设置 SQ 的队列长度，即 SQ 队列用完才开始阻塞等待 CQE；</span></span><br><span class="line">        <span class="keyword">else</span>                              <span class="comment">// data 处理已经全部提交，</span></span><br><span class="line">            depth = <span class="number">1</span>;                    <span class="comment">// 阈值设置为 1，即只要还有 SQE 未完成，就阻塞等待 CQE</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这个 while 只有 SQ 队列用完或 data 全部提交之后才会执行到</span></span><br><span class="line">        <span class="keyword">while</span> (inflight &gt;= depth) &#123;       <span class="comment">// 如果所有 SQE 都已经用完，或者所有 data read-&gt;write 请求都已经提交</span></span><br><span class="line">            io_uring_wait_cqe(ring, &amp;cqe);<span class="comment">// 等待内核 completion 事件</span></span><br><span class="line">            handle_cqe(ring, cqe);        <span class="comment">// 处理 completion 事件：释放 SQE 内存缓冲区，通知内核 CQE 已消费</span></span><br><span class="line">            inflight--;                   <span class="comment">// 正在进行中的 SQE 数量 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setup_context</span><span class="params">(<span class="type">unsigned</span> entries, <span class="keyword">struct</span> io_uring *ring)</span> &#123;</span><br><span class="line">    io_uring_queue_init(entries, ring, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_file_size</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> *size)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(st.st_mode)) &#123;</span><br><span class="line">        *size = st.st_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(st.st_mode)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> bytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ioctl(fd, BLKGETSIZE64, &amp;bytes) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        *size = bytes;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_uring</span> <span class="title">ring</span>;</span></span><br><span class="line">    <span class="type">off_t</span> insize;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    infd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    outfd = open(argv[<span class="number">2</span>], O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_context(QD, &amp;ring))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (get_file_size(infd, &amp;insize))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ret = copy_file(&amp;ring, insize);</span><br><span class="line"></span><br><span class="line">    close(infd);</span><br><span class="line">    close(outfd);</span><br><span class="line">    io_uring_queue_exit(&amp;ring);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他说明-1"><a href="#其他说明-1" class="headerlink" title="其他说明"></a>其他说明</h3><p>代码中实现了三个函数：</p><ol><li><p><code>copy_file()</code>：高层复制循环逻辑；它会调用 <code>queue_rw_pair(ring, this_size, offset)</code> 来构造 SQE pair； 并通过一次 <code>io_uring_submit()</code> 调用将所有构建的 SQE pair 提交。</p><p>这个函数维护了一个最大 DQ 数量的 inflight SQE，只要数据 copy 还在进行中；否则，即数据已经全部读取完成，就开始等待和收割所有的 CQE。</p></li><li><p><code>queue_rw_pair()</code> 构造一个 read-write SQE pair.</p><p>read SQE 的 <code>IOSQE_IO_LINK</code> flag 表示开始一个 chain，write SQE 不用设置这个 flag，标志着这个 chain 的结束。 用户 data 字段设置为同一个 data 描述符，并且在随后的 completion 处理中会用到。</p></li><li><p><code>handle_cqe()</code> 从 CQE 中提取之前由 <code>queue_rw_pair()</code> 保存的 data 描述符，并在描述符中记录处理进展（index）。</p><p>如果之前请求被取消，它还会重新提交 read-write pair。</p><p>一个 CQE pair 的两个 member 都处理完成之后（<code>index==2</code>），释放共享的 data descriptor。 最后通知内核这个 CQE 已经被消费。</p></li></ol><h1 id="io-uring-性能压测（基于-fio）"><a href="#io-uring-性能压测（基于-fio）" class="headerlink" title="io_uring 性能压测（基于 fio）"></a>io_uring 性能压测（基于 fio）</h1><p><strong>对于已经在使用 linux-aio 的应用</strong>，例如 ScyllaDB， <strong>不要期望换成 io_uring 之后能获得大幅的性能提升</strong>，这是因为： <code>io_uring</code> 性能相关的底层机制与 <code>linux-aio</code> 并无本质不同（都是异步提交，轮询结果）。</p><p>在此，本文也希望使读者明白：<code>io_uring</code> <strong>首先和最重要的贡献</strong>在于： <strong>将 linux-aio 的所有优良特性带给了普罗大众</strong>（而非局限于数据库这样的细分领域）。</p><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><p>本节使用 <code>fio</code> 测试 4 种模式：</p><ol><li><code>synchronous reads</code></li><li><code>posix-aio</code> (implemented as a thread pool)</li><li><code>linux-aio</code></li><li><code>io_uring</code></li></ol><p>硬件：</p><ul><li>NVMe 存储设备，物理极限能打到 <strong>3.5M IOPS</strong>。</li><li>8 核处理器</li></ul><h2 id="场景一：direct-I-O-1KB-随机读（绕过-page-cache）"><a href="#场景一：direct-I-O-1KB-随机读（绕过-page-cache）" class="headerlink" title="场景一：direct I&#x2F;O 1KB 随机读（绕过 page cache）"></a>场景一：direct I&#x2F;O <code>1KB</code> 随机读（绕过 page cache）</h2><p>第一组测试中，我们希望所有的读请求都能<strong>命中存储设备</strong>（all reads to hit the storage），<strong>完全绕开操作系统的页缓存</strong>（page cache）。</p><p>测试配置：</p><ul><li>8 个 CPU 执行 72 <code>fio</code> job，</li><li>每个 job 随机读取 4 个文件，</li><li><code>iodepth=8</code>（number of I&#x2F;O units to keep in flight against the file.）。</li></ul><p>这种配置<strong>保证了 CPU 处于饱和状态</strong>，便于观察 I&#x2F;O 性能。 如果 CPU 数量足够多，那每组测试都可能会打满设备带宽，结果对 I&#x2F;O 压测就没意义了。</p><p>表 1. Direct I&#x2F;O（绕过系统页缓存）：1KB 随机读，CPU 100% 下的 I&#x2F;O 性能</p><table><thead><tr><th><strong>backend</strong></th><th><strong>IOPS</strong></th><th><strong>context switches</strong></th><th><strong>IOPS ±% vs io_uring</strong></th></tr></thead><tbody><tr><td>sync</td><td>814,000</td><td>27,625,004</td><td><strong>-42.6%</strong></td></tr><tr><td>posix-aio (thread pool)</td><td>433,000</td><td>64,112,335</td><td><strong>-69.4%</strong></td></tr><tr><td>linux-aio</td><td>1,322,000</td><td>10,114,149</td><td><strong>-6.7%</strong></td></tr><tr><td>io_uring (basic)</td><td>1,417,000</td><td>11,309,574</td><td><strong>—</strong></td></tr><tr><td>io_uring (enhanced)</td><td>1,486,000</td><td>11,483,468</td><td><strong>4.9%</strong></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260127125632385.png" alt="benchmark1" loading="lazy"></p><p>几点分析：</p><ol><li><code>io_uring</code> 相比 <code>linux-aio</code> 确实有一定提升，但并非革命性的。</li><li>开启高级特性，例如 buffer &amp; file registration 之后性能有进一步提升 —— 但也还 没有到为了这些性能而重写整个应用的地步，除非你是搞数据库研发，想榨取硬件的最后一分性能。</li><li><code>io_uring</code> and <code>linux-aio</code> <strong>都比同步 read 接口快 2 倍，而后者又比 posix-aio 快 2 倍</strong> —— 初看有点差异。但看看<strong>上下文切换次数</strong>，就不难理解为什么 posix-aio 这么慢了。<ul><li>同步 read 性能差是因为：在这种没有 page cache 的情况下， <strong>每次 read 系统调用都会阻塞，因此就会涉及一次上下文切换</strong>。</li><li><code>posix-aio</code> 性能更差是因为：不仅内核和应用程序之间要频繁上下文切换，线程池的<strong>多个线程之间也在频繁切换</strong>。</li></ul></li></ol><h2 id="场景二：buffered-I-O-1KB-随机读（数据提前加载到内存，100-hot-cache）"><a href="#场景二：buffered-I-O-1KB-随机读（数据提前加载到内存，100-hot-cache）" class="headerlink" title="场景二：buffered I&#x2F;O 1KB 随机读（数据提前加载到内存，100% hot cache）"></a>场景二：buffered I&#x2F;O <code>1KB</code> 随机读（数据提前加载到内存，100% hot cache）</h2><p>第二组测试 buffered I&#x2F;O：</p><ol><li>将文件数据提前加载到内存，然后再测随机读。<ul><li>由于<strong>数据全部在 page cache</strong>，因此<strong>同步 read 永远不会阻塞</strong>。</li><li>这种场景下，我们预期<strong>同步读和 io_uring 的性能差距不大（都是最好的）</strong>。</li></ul></li><li>其他测试条件不变。</li></ol><p>表 2. Buffered I&#x2F;O（数据全部来自 page cache，100% hot cache）：1KB 随机读，100% CPU 下的 I&#x2F;O 性能</p><table><thead><tr><th><strong>Backend</strong></th><th><strong>IOPS</strong></th><th><strong>context switches</strong></th><th><strong>IOPS ±% vs io_uring</strong></th></tr></thead><tbody><tr><td>sync</td><td>4,906,000</td><td>105,797</td><td><strong>-2.3%</strong></td></tr><tr><td>posix-aio (thread pool)</td><td>1,070,000</td><td>114,791,187</td><td><strong>-78.7%</strong></td></tr><tr><td>linux-aio</td><td>4,127,000</td><td>105,052</td><td><strong>-17.9%</strong></td></tr><tr><td>io_uring</td><td>5,024,000</td><td>106,683</td><td><strong>—</strong></td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260127125651661.png" alt="benchmark2" loading="lazy"></p><p>结果分析：</p><ol><li><p>同步读和 <code>io_uring</code> 性能差距确实很小，二者都是最好的。</p><p>但注意，<strong>实际的应用</strong>不可能一直 100% 时间执行 IO 操作，因此 基于同步读的真实应用性能<strong>还是要比基于 io_uring 要差的</strong>，因为 io_uring 会将多个系统调用批处理化。</p></li><li><p><code>posix-aio</code> 性能最差，直接原因是<strong>上下文切换次数太多</strong>，这也和场景相关： 在这种 <strong>CPU 饱和的情况下</strong>，它的线程池反而是累赘，会完全拖慢性能。</p></li><li><p><code>linux-aio</code> 并<strong>不是针对 buffered I&#x2F;O 设计的</strong>，在这种 page cache 直接返回的场景， 它的<strong>异步接口反而会造成性能损失</strong> —— 将操作分 为 dispatch 和 consume 两步不但没有性能收益，反而有额外开销。</p></li></ol><h2 id="性能测试小结"><a href="#性能测试小结" class="headerlink" title="性能测试小结"></a>性能测试小结</h2><p>最后再次提醒，本节是极端应用&#x2F;场景（<strong>100% CPU + 100% cache miss&#x2F;hit</strong>）测试， 真实应用的行为通常处于同步读和异步读之间：时而一些阻塞操作，时而一些非阻塞操作。 但不管怎么说，用了 io_uring 之后，用户就无需担心同步和异步各占多少比例了，因为它<strong>在任何场景下都表现良好</strong>。</p><ol><li>如果操作是非阻塞的，<code>io_uring</code> 不会有额外开销；</li><li>如果操作是阻塞式的，也没关系，<code>io_uring</code> 是完全异步的，并且不依赖线程池或昂贵的上下文切换来实现这种异步能力；</li></ol><p>本文测试的都是随机读，但对<strong>其他类型的操作</strong>，<code>io_uring</code> 表现也是非常良好的。例如：</p><ol><li>打开&#x2F;关闭文件</li><li>设置定时器</li><li>通过 network sockets 传输数据</li></ol><p>而且<strong>使用的是同一套 io_uring 接口</strong>。</p><h2 id="ScyllaDB-与-io-uring"><a href="#ScyllaDB-与-io-uring" class="headerlink" title="ScyllaDB 与 io_uring"></a>ScyllaDB 与 io_uring</h2><p>Scylla 重度依赖 direct I&#x2F;O，从一开始就使用 <code>linux-aio</code>。 在我们转向 <code>io_uring</code> 的过程中，最开始测试显示对某些 workloads，能取得 50% 以上的性能提升。 但<strong>深入研究之后发现</strong>，这是因为我们<strong>之前的 linux-aio 用的不够好</strong>。 这也揭示了一个<strong>经常被忽视的事实</strong>：获得高性能没有那么难（前提是你得弄对了）。 在对比 <code>io_uring</code> 和 <code>linux-aio</code> 应用之后，我们<strong>很快改进了一版，二者的性能差距就消失了</strong>。 但坦率地说，解决这个问题<strong>需要一些工作量</strong>，因为要改动一个已经使用 了很多年的基于 <code>linux-aio</code> 的接口。而对 <code>io_uring</code> 应用来说，做类似的改动是轻而 易举的。</p><p>以上只是一个场景，<code>io_uring</code> 相比 <code>linux-aio</code> 的<strong>优势</strong>是能应用于 file I&#x2F;O 之外的场景。 此外，它还自带了特殊的 <a href="https://www.p99conf.io/">高性能</a> 接口，例如 buffer registration、file registration、轮询模式等等。</p><p>启用 <code>io_uring</code> 高级特性之后，我们看到性能确实有提升：Intel Optane 设备，单个 CPU 读取 512 字节，观察到 5% 的性能提升。与 表 1 &amp; 2 对得上。虽然 5% 的提升 看上去不是太大，但对于希望压榨出硬件所有性能的数据库来说，还是非常宝贵的。</p><table><thead><tr><th>指标</th><th>Linux AIO</th><th>io_uring（带 buffer&#x2F;file registration + poll）</th></tr></thead><tbody><tr><td>吞吐量 (Throughput)</td><td>330 MB&#x2F;s</td><td>346 MB&#x2F;s</td></tr><tr><td>平均延迟 (Avg Latency)</td><td>1549 μs</td><td>1470 μs</td></tr><tr><td>P50 延迟 (中位数)</td><td>1547 μs</td><td>1468 μs</td></tr><tr><td>P95 延迟</td><td>1694 μs</td><td>1558 μs</td></tr><tr><td>P99 延迟</td><td>1703 μs</td><td>1613 μs</td></tr><tr><td>P99.9 延迟</td><td>1950 μs</td><td>1674 μs</td></tr><tr><td>最大延迟 (Max Latency)</td><td>2177 μs</td><td>1829 μs</td></tr></tbody></table><p>使用 1 个 CPU 从 Intel Optane 设备读取 512 字节。1000 并发请求。linux-aio 和 io_uring basic interface 性能差异很小。 但启用 io_uring 高级特性后，有 5% 的性能差距。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://arthurchiao.art/blog/intro-to-io-uring-zh/">Linux 异步 I/O 框架 io_uring</a></div>]]></content>
    
    
    <summary type="html">io_uring</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 网络设备</title>
    <link href="https://even629.com/posts/2601133/"/>
    <id>https://even629.com/posts/2601133/</id>
    <published>2026-01-13T14:00:00.000Z</published>
    <updated>2026-01-13T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2026-01-13</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="网络通信基础"><a href="#网络通信基础" class="headerlink" title="网络通信基础"></a>网络通信基础</h1><p><strong>发展历史</strong></p><p>1969 年，ARPAnet 最初连接了美国四所大学的计算机，采用分组交换技术，实现计算机间数据传输 。</p><p>1972 年，首次实现与英国、挪威计算机的跨大西洋连接。</p><p>1973 年开始研究传输控制协议（TCP）和网际协议（IP）。</p><p>1984 年，TCP&#x2F;IP 协议成为计算机网络通信标准。</p><p>1986 年，美国国家科学基金会 NSF 建立了广域网（因特网的前身）。</p><p>1994 年，中国的 NCFC 网络正式接入 NSFnet, 中国加入到了因特网。</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议是网络中设备进行通信的规则和约定，常见的网络协议有：</p><h3 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP&#x2F;IP 协议"></a>TCP&#x2F;IP 协议</h3><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol）协议，即传输控制协议&#x2F;网际协议，是用于互联网通信的基础协议族。</p><p><strong>特点</strong></p><ul><li><strong>面向连接</strong>：在传输数据前，TCP 协议会通过“三次握手”建立连接，以此确保通信双方的可靠性以及数据传输的有序性。</li><li><strong>可靠性强</strong>：TCP 借助序号、确认应答、重传机制以及流量控制等机制，保障数据的可靠性与完整性。若数据包在传输过程中丢失或损坏，TCP 会要求重新发送，直至数据准确无误地到达。</li><li><strong>基于字节流</strong>：TCP 将应用层数据视作无结构的字节流，不保留消息边界。这表明 TCP 并不关注应用层数据的具体内容，仅将其当作一系列字节进行传输。</li></ul><p><strong>作用</strong></p><ul><li>TCP&#x2F;IP 协议采用分层工作方式，每个层级承担特定功能，提供了从网络硬件到应用程序的完整通信解决方案。让不同计算机和网络之间的数据交换得以实现。</li></ul><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP（User Datagram Protocol）即用户数据报协议。与 TCP 不同，UDP 不提供面向连接的通信方式，也不确保数据的可靠性与完整性。</p><p><strong>特点</strong></p><ul><li><p><strong>无连接性</strong>：UDP 在发送数据前无需建立连接，每个数据包都独立发送，接收方也无需发送确认应答。这种特性使 UDP 具备较低的延迟和较高的传输效率。</p></li><li><p><strong>不可靠性</strong>：UDP 无法保证数据包的顺序性、完整性以及可靠性。若数据包在传输过程中出现丢失或损坏的情况，UDP 不会要求重新发送。</p></li><li><p><strong>基于数据报</strong>：UDP 会将应用层的数据封装成一个个独立的数据报进行传输，每个数据报都包含完整的目的地址和源地址信息。</p></li></ul><p><strong>作用</strong></p><p>UDP 适用于对实时性要求较高的场景，如视频流、音频流以及在线游戏等。在这些应用中，即便少量数据包丢失，也不会对整体体验造成严重影响。</p><h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a>DNS 协议</h3><p>DNS（Domain Name System，域名系统）是一种分布式数据库系统，主要功能是将域名转换为对应的 IP 地址（例如 192.0.2.1）。借助 DNS，用户能够通过易于记忆的域名访问网站，而不必牢记复杂的 IP 地址。</p><h3 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h3><p>DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一种网络协议，其作用是自动为局域网内的客户端设备分配 IP 地址、子网掩码、默认网关以及 DNS 服务器地址等网络参数。</p><h3 id="FTP-协议"><a href="#FTP-协议" class="headerlink" title="FTP 协议"></a>FTP 协议</h3><p>FTP（File Transfer Protocol，文件传输协议）是用于网络文件传输的协议，可以用于在不同计算机之间实现文件共享，是互联网上进行文件传输的重要工具之一。</p><h3 id="HTTP-HTTPS-协议"><a href="#HTTP-HTTPS-协议" class="headerlink" title="HTTP&#x2F;HTTPS 协议"></a>HTTP&#x2F;HTTPS 协议</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于分布式、协作式、超媒体信息系统的应用层协议，是万维网（WWW）数据通信的基础。</p><p>HTTPS（HyperText Transfer Protocol Secure，超文本传输安全协议）是 HTTP 的安全版本，它通过 SSL&#x2F;TLS 协议对数据进行加密，从而保障数据传输的安全性。</p><p><strong>作用</strong></p><p>HTTP 协议使用户能够通过浏览器访问互联网上的各类资源，如网页、图片、视频等。HTTPS 协议则致力于保护用户的数据安全，防止数据在传输过程中被窃取或篡改，广泛应用于网上银行、网上支付、电子商务等对数据安全要求较高的场景</p><h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>包括网线，电缆，光纤</p><ul><li><strong>网线</strong></li></ul><p>网线一般由几根导线组成，常见的是 8 根铜导线，两两相互缠绕，形成 4 对双绞线。外部包裹绝缘层和护套，起到保护内部导线，防止信息泄露和外界电磁干扰的作用。</p><ul><li><strong>电缆</strong></li></ul><p>电缆是一种电能或信号传输装置，通常是由几根或几组导线组成。电缆由导体，绝缘层，护套层组成。</p><ul><li><strong>光纤</strong></li></ul><p>光纤是一种以光为信息载体，利用光在玻璃或塑料制成的纤维中全反射原理进行数据传输的线缆。它主要分为单模光纤和多模光纤。</p><h3 id="网线种类"><a href="#网线种类" class="headerlink" title="网线种类"></a>网线种类</h3><p><strong>1 类线和 2 类线</strong></p><p>1 类线与 2 类线主要应用于早期的电话通信系统，并不支持数据传输或现代意义上的网络应用。随着网络技术的不断进步，这两类线已被淘汰，不再用于网络布线。</p><p><strong>3 类线（Category 3, Cat 3）</strong></p><p>3 类线是早期以太网电缆标准之一，主要用于传输速率为 10Mbps 的传统以太网。在现代网络环境中，3 类网线已很少被使用。</p><p><strong>4 类网线（Category 4, Cat 4）</strong></p><p>相较于 3 类线，4 类线虽有所提升，但在实际应用中，因其性价比不高，未能得到广泛推广，很快便被更为先进的 5 类线所取代。</p><p><strong>5 类线（Category 5, Cat 5）</strong></p><emp>5 类线是计算机网络中常用的双绞式电缆，支持最高 100Mbps 的数据传输速率（FastEthernet）。</emp><p><strong>超 5 类线（Category 5e, Cat 5e）</strong></p><emp>超 5 类线是 5 类线的增强版本，主要用于千兆以太网（1000Mbps），同时向下兼容百兆以太网。</emp><p><strong>6 类线（Category 6，Cat 6）</strong></p><emp>相较于之前的线缆，6 类线在内部结构、材质以及外部保护等方面均有所改进，以此确保更高的传输质量和稳定性。6 类线也是用于千兆以太网（1000Mbps）的传输介质</emp><p><strong>超 6 类线（Category 6A, Cat 6a）</strong></p><u>超 6 类线是 6 类线的进一步升级版本，支持 10Gbps 的传输速率（万兆以太网）。</u><p><strong>7 类线（Category 7，Cat 7）</strong></p><u>7 类线属于屏蔽双绞线（STP），支持 10Gbps 的传输速率，具有更高的带宽和更低的信号衰减率。</u><h3 id="网线制作标准"><a href="#网线制作标准" class="headerlink" title="网线制作标准"></a>网线制作标准</h3><p>网线制作有俩种标准，即 T568A 和 T568B。</p><blockquote><p>如果网线两端采用相同的线序标准，称为直连线，用于连接不同类型的设备，如电脑与路由器；</p><p>若两端线序不同，如一端为 T568A，另一端为 T568B，则称为交叉线，常用于连接相同类型的设备，如电脑与电脑、交换机与交换机。</p></blockquote><h4 id="T568A"><a href="#T568A" class="headerlink" title="T568A"></a>T568A</h4><p>T568A 标准线序：绿白、绿、橙白、蓝、蓝白、橙、棕白、棕。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302228.png" alt="T568A" loading="lazy"></p><h4 id="T568B"><a href="#T568B" class="headerlink" title="T568B"></a>T568B</h4><p>T568B 标准线序：橙白、橙、绿白、蓝、蓝白、绿、棕白、棕</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302274.png" alt="T568B" loading="lazy"></p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI 七层网络模型是国际标准化组织（ISO）专门为实现不同系统之间的互连互通而制定的网络体系结构标准。</p><p>OSI 七层模型由底层至高层依次为：物理层、数据链路层、网络层、传输层、会话层、表示层以及应用层，具体如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302311.png" alt="OSI七层网络模型" loading="lazy"></p><ul><li><strong>物理层</strong></li></ul><p>物理层只需要考虑如何发送 0 和 1，以及接收端如何识别从而完成比特流的传输，并不需要关心比特流的具体含义。除此以外还规定了网络中的一些电气特性。</p><ul><li><strong>数据链路层</strong></li></ul><p>单纯的 0 和 1 没有意义，数据链路层要将物理层传来的原始比特流转化为一个个独立的帧。并负责链路连接的建立、维护以及终止，同时还具备帧同步、差错控制和流量控制等功能。</p><ul><li><strong>网络层</strong></li></ul><p>网络层主要处理数据包从源节点到目标节点的传输与路由问题。也就是建立主机到主机之间的通信。</p><ul><li><strong>传输层</strong></li></ul><p>传输层负责提供可靠的端口到端口的数据传输服务。确保数据能够准确无误地从发送端传输到接收端。</p><ul><li><strong>会话层</strong></li></ul><p>主要负责管理用户会话，对应用程序之间的对话进行控制，包括对话的开始、结束以及数据交换过程。</p><ul><li><strong>表示层</strong></li></ul><p>表示层负责数据格式的转换，如设备固有格式与网络标准格式之间的转换，可以理解是充当“翻译官”的作用。</p><ul><li><strong>应用层</strong></li></ul><p>应用层是直接面向用户的一层，通过应用程序之间的交互完成特定的网络应用。</p><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h3><p>TCP&#x2F;IP 四层模型是对 OSI 七层模型的简化，它将网络功能划分为网络接口层、网际层、传输层和应用层，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302347.png" alt="TCP&#x2F;IP四层模型" loading="lazy"></p><ul><li><strong>应用层</strong></li></ul><p>应用层直接与应用程序交互。常见的应用层协议有 HTTP、FTP、SMTP、DNS 等，不同种类的应用程序会根据自己的需要来选择应用层中不同的协议，如邮件传输应用可以选择 SMTP 协议。</p><ul><li><strong>传输层</strong></li></ul><p>提供可靠的端口到端口的数据传输服务，传输层中最重要的是 TCP 和 UDP 协议，TCP 提供面向连接的，可靠的服务。UDP 提供无连接的，不可靠但速度快的服务。</p><ul><li><strong>网络层</strong></li></ul><p>提供主机到主机之间的通信。网络层中最重要的是 IP 协议，IP 协议会给每个数据包加上 IP地址。</p><ul><li><strong>网络接口层</strong></li></ul><p>网络接口层包含了物理层和数据链路层，所以网络接口层既包括物理传输又包括链路的建立。</p><blockquote><p>OSI（Open System Interconnection）是国际标准化组织（ISO）制定的七层模型。</p><p>TCP&#x2F;IP 四层模型参考 OSI 七层模型，简化为了四个层次。如下图所示。因此在应用中效率更高，成本更低。所以迅速发展起来并成为事实上的标准。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302395.png" alt="两个模型的区别" loading="lazy"></p><h2 id="网络数据的封装和解封装"><a href="#网络数据的封装和解封装" class="headerlink" title="网络数据的封装和解封装"></a>网络数据的封装和解封装</h2><p>在网络通信中，封装是指将上层协议的数据加上本层的协议头和协议尾，形成一个新的数据单元，然后再传递给下一层进行处理。</p><p>而解封装则是封装的逆过程，即接收方将接收到的数据单元去掉本层的协议头和协议尾，提取出上层协议的数据，然后传递给上层进行处理。</p><p>封装和解封装的过程是在不同的网络层次中依次进行的</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302437.png" alt="封装过程" loading="lazy"></p><p><strong>应用层封装</strong>：应用程序生成的数据，如 HTTP 协议传输的网页数据、SMTP 协议传输的邮件数据等，此时数据被称为应用数据。应用层协议会根据自身需求对数据进行格式化，比如HTTP 会添加请求头或响应头，包含如请求方法、URL、响应状态码等信息。</p><p><strong>传输层封装</strong>：应用数据到达传输层（如 TCP 或 UDP）。以 TCP 为例，TCP 会为数据添加TCP 头部，包含源端口号、目的端口号、序列号、确认号、控制位等信息。端口号用于标识应用程序，使接收端能将数据正确交付给对应的应用。UDP 头部相对简单，同样有源端口号和目的端口号，用于多路复用和分用。此时数据加上 TCP 或 UDP 头部后称为段（Segment）。</p><p><strong>网络层封装</strong>：传输层的段到达网络层（如 IPv4 或 IPv6），网络层添加 IP 头部。IP 头部包含源 IP 地址、目的 IP 地址等关键信息，用于在不同网络间进行路由选择。添加 IP 头部后的数据称为数据包（Packet）。例如，当你访问网站时，你的设备会将 TCP 段封装在 IP 数据包中，目的 IP 地址为网站服务器的 IP。</p><p><strong>数据链路层封装</strong>：网络层的数据包到达数据链路层（如以太网），数据链路层添加帧头和帧尾。以太网帧头包含源 MAC 地址、目的 MAC 地址等，帧尾包含循环冗余校验（CRC）值用于差错检测。此时的数据称为数据帧（Frame）。数据帧通过物理层转化为电信号或光信号在物理介质上传输。</p><p>解封装是封装的逆过程，在接收端，数据从物理层开始，依次向上经过各网络层次，每一层去除相应头部信息，将数据还原为应用层能处理的形式，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302482.png" alt="解封装过程" loading="lazy"></p><p><strong>数据链路层解封装</strong>：物理层接收到电信号或光信号，转换为数据帧交给数据链路层。数据链路层检查帧头和帧尾，通过 CRC 校验确保数据传输无误后，去除帧头和帧尾，将数据包交给网络层。</p><p><strong>网络层解封装</strong>：网络层接收到数据包，检查 IP 头部，根据目的 IP 地址判断是否是发给本机的。如果是，去除 IP 头部，将段交给传输层。</p><p><strong>传输层解封装</strong>：传输层接收到段，根据 TCP 或 UDP 头部中的端口号，将数据交付给对应的应用程序，并去除 TCP 或 UDP 头部。此时数据还原为应用层数据，应用层程序即可处理这些数据。</p><h1 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h1><h2 id="RJ45接口"><a href="#RJ45接口" class="headerlink" title="RJ45接口"></a>RJ45接口</h2><p><strong>RJ45</strong> 是 <strong>Registered Jack 45</strong> 的缩写，在计算机网络中 RJ45 是标准 8 芯模块接口的简称，RJ45由插头和插座组成，这两种元器件之间用网线相连。RJ45 插头如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302543.png" alt="RJ45插头" loading="lazy"></p><p>从外观上看，<strong>RJ45 插头</strong>呈矩形，外部是塑料外壳，<strong>内部中有 8 个金属触点，金属触点用于与 RJ45 插座进行电气连接</strong>。</p><p>与 RJ45 插头对应在 <strong>RJ45 插座</strong>中同样有 <strong>8 个金属接触片，用于与 RJ45 插头相连</strong>。RJ45 插头前端的 8 个金属触点在插入插座时会与插座内的金属片紧密接触，从而实现信号的传输。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302598.png" alt="RJ45插座" loading="lazy"></p><p>百兆网口和千兆网口都采用 RJ45 接口进行物理连接，不过，尽管外观看起来一模一样，但它们的传输能力却大不相同。对应的引脚使用情况也大不相同。</p><p><strong>百兆 RJ45 接口</strong>有 8 个引脚，这 8 个引脚分别是</p><table><thead><tr><th align="center">引脚号</th><th align="center">标识</th><th align="center">中文名称</th><th align="center">功能说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">TX+</td><td align="center">发送数据 +</td><td align="center">以太网差分发送信号的正端</td></tr><tr><td align="center">2</td><td align="center">TX-</td><td align="center">发送数据 -</td><td align="center">以太网差分发送信号的负端</td></tr><tr><td align="center">3</td><td align="center">RX+</td><td align="center">接收数据 +</td><td align="center">以太网差分接收信号的正端</td></tr><tr><td align="center">4</td><td align="center">NC</td><td align="center">空脚</td><td align="center">无电气连接，未使用</td></tr><tr><td align="center">5</td><td align="center">NC</td><td align="center">空脚</td><td align="center">无电气连接，未使用</td></tr><tr><td align="center">6</td><td align="center">RX-</td><td align="center">接收数据 -</td><td align="center">以太网差分接收信号的负端</td></tr><tr><td align="center">7</td><td align="center">NC</td><td align="center">空脚</td><td align="center">无电气连接，未使用</td></tr><tr><td align="center">8</td><td align="center">NC</td><td align="center">空脚</td><td align="center">无电气连接，未使用</td></tr></tbody></table><blockquote><p><strong>差分信号</strong>：TX+&#x2F;-、RX+&#x2F;- 为成对的差分信号线，通过差分传输抗干扰，提升以太网数据传输的稳定性，这是 RJ45 网口的核心设计。</p><p><strong>标准匹配</strong>：该定义符合<strong>T568B</strong>布线标准（民用 &#x2F; 工业场景最常用），与 T568A 标准仅线序排列不同，引脚功能一致。</p><p><strong>空脚作用</strong>：4、5、7、8 脚为预留脚，部分工业级网口会将其用于供电（如 POE 供电），但常规以太网应用中均为 NC（空脚）。</p></blockquote><p><strong>千兆 RJ45 接口</strong>也有 8 个引脚，相比百兆以太网，千兆网口启用了全部 8 个引脚，分为 4 对差分线实现全双工高速传输</p><table><thead><tr><th align="center">引脚编号</th><th align="center">名称</th><th align="center">功能说明</th><th align="center">传输方向</th><th align="center">差分对分组</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">TX_D1+</td><td align="center">Tranceive Data1+(发信号 +)</td><td align="center">发送</td><td align="center">第一对</td></tr><tr><td align="center">2</td><td align="center">TX_D1-</td><td align="center">Tranceive Data1-(发信号 -)</td><td align="center">发送</td><td align="center">第一对</td></tr><tr><td align="center">3</td><td align="center">RX_D2+</td><td align="center">Receive Data2+(收信号 +)</td><td align="center">接收</td><td align="center">第二对</td></tr><tr><td align="center">4</td><td align="center">BI_D3+</td><td align="center">Bi-directional Data3+(双向信号)</td><td align="center">双向</td><td align="center">第三对</td></tr><tr><td align="center">5</td><td align="center">BI_D3-</td><td align="center">Bi-directional Data3-(双向信号)</td><td align="center">双向</td><td align="center">第三对</td></tr><tr><td align="center">6</td><td align="center">RX_D2-</td><td align="center">Receive Data2-(收信号 -)</td><td align="center">接收</td><td align="center">第二对</td></tr><tr><td align="center">7</td><td align="center">BI_D4+</td><td align="center">Bi-directional Data4+(双向信号)</td><td align="center">双向</td><td align="center">第四对</td></tr><tr><td align="center">8</td><td align="center">BI_D4-</td><td align="center">Bi-directional Data4-(双向信号)</td><td align="center">双向</td><td align="center">第四对</td></tr></tbody></table><blockquote><p><strong>传输速率与引脚利用</strong>：百兆以太网（100BASE-TX）仅使用 1&#x2F;2（TX）、3&#x2F;6（RX）4 个引脚，而<strong>千兆以太网（1000BASE-T）启用全部 8 个引脚</strong>，通过 4 对差分线同时进行收发，实现 1Gbps 的传输速率。</p><p><strong>双向引脚（BI）的作用</strong>：4&#x2F;5、7&#x2F;8 引脚为双向传输设计，在千兆模式下，这两对线会根据通信需求动态切换收发方向，配合数字信号处理（DSP）技术实现全双工通信。</p><p><strong>差分传输特性</strong>：每对引脚（如 TX_D1+&#x2F;TX_D1-）均为差分信号线，通过两根线的电压差值传递信号，能有效抑制共模干扰，提升高速数据传输的稳定性，这是以太网物理层的核心设计。</p><p><strong>布线标准兼容</strong>：该引脚定义仍遵循 T568A&#x2F;T568B 布线标准，线序排列与百兆网口一致，因此千兆网线可向下兼容百兆网口使用。</p></blockquote><h2 id="MAC-控制器"><a href="#MAC-控制器" class="headerlink" title="MAC 控制器"></a>MAC 控制器</h2><p>MAC 控制器全称为 Media Access Control(介质访问控制)。属于 <strong>OSI 第二层（数据链路层）</strong> 的一部分。</p><blockquote><p>MAC 控制器的主要功能是控制与 PHY 芯片的连接，它就像是一个“桥梁管理员”，负责管理数据在数据链路层和物理层之间的传输，确保数据能够顺利地在两个层次之间流动。</p></blockquote><p>MAC 控制器的主要功能包括：</p><ol><li><strong>以太网帧的封装与解析</strong><ul><li>负责添加&#x2F;解析以太网帧头（目标 MAC、源 MAC、类型字段）</li><li>校验并生成 CRC（FCS）</li></ul></li><li><strong>数据收发控制</strong><ul><li>从系统内存（DMA）读取数据，封装成以太网帧并发送</li><li>接收来自 PHY 的数据并写入内存</li></ul></li><li><strong>流量与缓冲管理</strong><ul><li>发送&#x2F;接收 FIFO</li><li>中断或轮询方式通知 CPU</li><li>DMA 描述符管理（驱动层重点）</li></ul></li><li><strong>链路层控制</strong><ul><li>支持全双工 &#x2F; 半双工</li><li>支持流控（PAUSE 帧）</li><li>统计信息（丢包、冲突、错误计数等）</li></ul></li><li><strong>与 PHY 的接口</strong><ul><li>通过 <strong>MII &#x2F; RMII &#x2F; RGMII &#x2F; SGMII</strong> 等接口与 PHY 通信</li><li>通过 <strong>MDIO&#x2F;MDC</strong> 配置和管理 PHY 芯片</li></ul></li></ol><h2 id="PHY-芯片"><a href="#PHY-芯片" class="headerlink" title="PHY 芯片"></a>PHY 芯片</h2><p>PHY 芯片全称为物理层芯片（Physical Layer chip）。PHY 芯片的主要任务就是<strong>将数字信号转换为适合在物理介质（如网线）中传输的模拟信号</strong>，然后<strong>将接收到的模拟信号再转换回数字信号</strong>，以便计算机能够识别和处理。</p><p>PHY 的核心功能包括：</p><ol><li><strong>信号编码与解码</strong><ul><li>100M：MLT-3、4B&#x2F;5B</li><li>1000M：PAM-5</li><li>自适应均衡、回波消除</li></ul></li><li><strong>自动协商（Auto-Negotiation）</strong><ul><li>协商速率（10M &#x2F; 100M &#x2F; 1000M）</li><li>协商双工模式（半双工 &#x2F; 全双工）</li></ul></li><li><strong>链路检测</strong><ul><li>网线插拔检测</li><li>Link Up &#x2F; Link Down 状态上报给 MAC</li></ul></li><li><strong>时钟恢复与同步</strong><ul><li>从接收到的信号中恢复时钟</li><li>保证数据采样准确</li></ul></li><li><strong>与 MAC 的管理接口</strong><ul><li>使用 <strong>MDIO&#x2F;MDC</strong> 寄存器接口</li><li>Linux 驱动中常见 <code>phy_read()</code> &#x2F; <code>phy_write()</code></li></ul></li></ol><h2 id="网络变压器"><a href="#网络变压器" class="headerlink" title="网络变压器"></a>网络变压器</h2><p>网络变压器又称网络隔离变压器，以太网变压器等，网络变压器主要起到信号耦合，电气隔离和阻抗匹配的作用。位于 <strong>PHY 与 RJ45 接口之间</strong>，属于被动器件。</p><p>网络变压器的主要作用包括：</p><ol><li><strong>电气隔离</strong><ul><li>提供 1500V 以上的隔离能力</li><li>防止浪涌、电位差损坏芯片</li><li>满足以太网安规标准（如 IEEE 802.3）</li></ul></li><li><strong>信号耦合</strong><ul><li>将 PHY 输出的差分信号耦合到双绞线</li><li>阻断直流分量，只传输交流信号</li></ul></li><li><strong>阻抗匹配</strong><ul><li>匹配 PHY 输出阻抗与网线（100Ω）</li><li>减少反射，提高信号质量</li></ul></li><li><strong>EMI 抑制</strong><ul><li>配合共模电感降低电磁干扰</li><li>提升抗干扰能力</li></ul></li></ol><blockquote><p>很多 RJ45 接口内部 <strong>集成了网络变压器和共模电感</strong>，工程中常称为 <strong>“带灯网口”</strong>。</p></blockquote><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p>根据 CPU、MAC 和 PHY 的集成情况，又可以进一步细分为以下三种方式：</p><p><strong>方式 1：CPU 内部集成了 MAC 和 PHY</strong></p><p>在这种方式中，CPU 将 MAC 和 PHY 集成于自身内部。这种方式虽然可以减少外围硬件数量，但是 CPU 成本会显著提高，并且由于全部集成在 CPU 内部，灵活性较差。所以这种方式在实际应用中并不多见。</p><p><strong>方式 2：CPU 内部集成 MAC，PHY 采用独立芯片</strong></p><p>CPU 内部只集成 MAC 控制器，PHY 采用独立的芯片，这种方式的优势是可以根据适应场景灵活选择 PHY 芯片，也是<strong>目前主流的方式</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302643.png" alt="CPU 内部集成 MAC，PHY 采用独立芯片" loading="lazy"></p><blockquote><p>iTOP-RK3568 也是使用的这种方式，需要注意的是 iTOP-RK3568 开发板上的 RJ45 插座内部集成了网络变压器，如果使用的<br>RJ45 插座内部没有集成网络变压器，则需要使用单独网络变压器芯片。</p></blockquote><p><strong>方式 3：CPU 不集成 MAC 和 PHY，MAC 和 PHY 采用独立芯片或者集成芯片</strong></p><p>在这种连接方式下，CPU 没有 MAC 和 PHY 的功能，也就是我们常说的 CPU 本身不支持网络功能。如果使用网络功能就需要通过其他接口转接。所以这种方式成本较高。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302704.png" alt="CPU 不集成 MAC 和 PHY，MAC 和 PHY 采用独立芯片或者集成芯片" loading="lazy"></p><h2 id="PHY-接口"><a href="#PHY-接口" class="headerlink" title="PHY 接口"></a>PHY 接口</h2><p>在嵌入式网络开发中，最主流的方案如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302643.png" alt="CPU 内部集成 MAC，PHY 采用独立芯片" loading="lazy"></p><p>通过框图可知，PHY 芯片的左侧连接了 MAC，右侧连接了 RJ45 插座。尤其可见 PHY 芯片起到了一个桥梁作用。</p><p><strong>PHY 芯片与 MAC 控制器相连可以通过 MII，RMII，GMII，RGMII 和 MIDO 接口。</strong></p><h3 id="MII-接口"><a href="#MII-接口" class="headerlink" title="MII 接口"></a>MII 接口</h3><p>MII 接口全称为 <strong>Media Independent Interface</strong>，即“介质独立接口”。</p><p>MII 接口的传输速率为10Mbps 或 100Mbps，在 100Mbps 下时钟为 25M，在 10Mbps 下钟为 2.5M。硬件连接如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302758.png" alt="MII接口" loading="lazy"></p><p>MII 接口一共需要 16 根信号线，含义如下</p><table><thead><tr><th align="center">信号线类型</th><th align="center">信号线名称</th><th align="center">数量</th><th align="center">描述</th><th align="center">方向（MAC←→PHY）</th><th align="center">核心作用</th></tr></thead><tbody><tr><td align="center"><strong>发送通道</strong></td><td align="center">TX_CLK</td><td align="center">1</td><td align="center">发送时钟，由 PHY 产生</td><td align="center">MAC ← PHY</td><td align="center">发送数据的同步时钟（百兆下为 25MHz）</td></tr><tr><td align="center"></td><td align="center">TX_EN</td><td align="center">1</td><td align="center">发送使能，高电平有效</td><td align="center">MAC → PHY</td><td align="center">指示 TXD [3:0] 上的数据有效</td></tr><tr><td align="center"></td><td align="center">TXD[3:0]</td><td align="center">4</td><td align="center">发送数据总线</td><td align="center">MAC → PHY</td><td align="center">并行传输发送的以太网数据（4 位宽）</td></tr><tr><td align="center"></td><td align="center">TX_ER</td><td align="center">1</td><td align="center">发送错误，高电平有效</td><td align="center">MAC → PHY</td><td align="center">指示发送过程中出现错误（如帧格式错误）</td></tr><tr><td align="center"><strong>接收通道</strong></td><td align="center">RX_CLK</td><td align="center">1</td><td align="center">接收时钟，由 PHY 产生</td><td align="center">MAC ← PHY</td><td align="center">接收数据的同步时钟（百兆下为 25MHz）</td></tr><tr><td align="center"></td><td align="center">RX_DV</td><td align="center">1</td><td align="center">接收数据有效，高电平有效</td><td align="center">MAC ← PHY</td><td align="center">指示 RXD [3:0] 上的数据有效（替代 RX_EN）</td></tr><tr><td align="center"></td><td align="center">RXD[3:0]</td><td align="center">4</td><td align="center">接收数据总线</td><td align="center">MAC ← PHY</td><td align="center">并行传输接收的以太网数据（4 位宽）</td></tr><tr><td align="center"></td><td align="center">RX_ER</td><td align="center">1</td><td align="center">接收错误，高电平有效</td><td align="center">MAC ← PHY</td><td align="center">指示接收过程中出现错误（如 CRC 错误、帧过长）</td></tr><tr><td align="center"><strong>冲突 &#x2F; 载波检测</strong></td><td align="center">COL</td><td align="center">1</td><td align="center">冲突检测，高电平有效</td><td align="center">MAC ← PHY</td><td align="center">半双工模式下，指示总线上发生数据冲突</td></tr><tr><td align="center"></td><td align="center">CRS</td><td align="center">1</td><td align="center">载波侦听，高电平有效</td><td align="center">MAC ← PHY</td><td align="center">半双工模式下，指示总线处于忙状态</td></tr></tbody></table><h3 id="RMII-接口"><a href="#RMII-接口" class="headerlink" title="RMII 接口"></a>RMII 接口</h3><p>RMII 接口全称为 <strong>Reduced Media Independent Interface</strong>，即“简化媒体独立接口”，它是 MII 接口的简化版本。所以相较于 MII 接口，RMII 接口在数据的发送与接收方面减少了一半的信号线。硬件连接如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302795.png" alt="RMII接口" loading="lazy"></p><p>RMII 接口一共需要 7 根信号线，含义如下：</p><table><thead><tr><th align="center">信号线名称</th><th align="center">数量</th><th align="center">方向（MAC ↔ PHY）</th><th align="center">核心描述 &amp; 开发关键要点</th></tr></thead><tbody><tr><td align="center">REF_CLK</td><td align="center">1 根</td><td align="center">外部 → MAC + PHY</td><td align="center">50MHz 固定参考时钟，<strong>收发数据唯一同步时钟</strong>（替代 MII 的 TX_CLK&#x2F;RX_CLK）；需同时供给 MAC 和 PHY，时钟源可选 PHY 内置晶振或外部晶振</td></tr><tr><td align="center">TX_EN</td><td align="center">1 根</td><td align="center">MAC → PHY</td><td align="center">发送使能，高电平有效；PHY 仅在该信号高电平时采样 TXD [1:0] 数据</td></tr><tr><td align="center">TXD[1:0]</td><td align="center">2 根</td><td align="center">MAC → PHY</td><td align="center">2 位并行发送数据总线；通过「2 位宽 × 50MHz」实现 100Mbps 速率，是 RMII 精简的核心设计</td></tr><tr><td align="center">CRS_DV</td><td align="center">1 根</td><td align="center">PHY → MAC</td><td align="center"><strong>复用信号</strong>：<br />全双工模式：仅作「RX_DV（接收数据有效）」<br />半双工模式：同时指示「CRS（载波侦听）」和「DV（数据有效）」</td></tr><tr><td align="center">RXD[1:0]</td><td align="center">2 根</td><td align="center">PHY → MAC</td><td align="center">2 位并行接收数据总线；MAC 仅在 CRS_DV 高电平时采样数据</td></tr></tbody></table><h3 id="GMII-接口"><a href="#GMII-接口" class="headerlink" title="GMII 接口"></a>GMII 接口</h3><p>GMII 接口全称为 <strong>Gigabit Media Independent Interface</strong>，即“千兆介质无关接口”，它是为了满足千兆以太网的高速数据传输需求而设计的接口。在 10M&#x2F;100M&#x2F;1000M 下时钟分别是 2.5M，25M 和 125M。硬件连接如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302845.png" alt="GMII" loading="lazy"></p><p>GMII 接口一共需要 25 根信号线，含义如下</p><table><thead><tr><th align="center">信号名称</th><th align="center">位宽 &#x2F; 数量</th><th align="center">中文描述</th><th align="center">信号方向</th><th align="center">功能详解（开发核心）</th><th align="center">速率适配说明</th></tr></thead><tbody><tr><td align="center">GTX_CLK</td><td align="center">1 根</td><td align="center">千兆发送时钟</td><td align="center">MAC → PHY</td><td align="center">千兆模式专属发送同步时钟，固定<strong>125MHz</strong>，MAC 基于此时钟发送数据，PHY 同步采样 TXD 数据</td><td align="center">仅千兆 (1000M) 使用，核心时钟</td></tr><tr><td align="center">TX_CLK</td><td align="center">1 根</td><td align="center">百兆发送时钟</td><td align="center">MAC → PHY</td><td align="center">兼容 10&#x2F;100M 速率的发送时钟，10M&#x3D;2.5MHz、100M&#x3D;25MHz</td><td align="center">仅 10&#x2F;100M 模式使用，千兆模式无效（悬空）</td></tr><tr><td align="center">TXD[7:0]</td><td align="center">8 根</td><td align="center">发送数据总线</td><td align="center">MAC → PHY</td><td align="center">8 位并行发送数据，GMII 的核心宽位宽设计</td><td align="center">千兆 &#x2F; 百兆 &#x2F; 十兆全兼容，速率不同时钟不同</td></tr><tr><td align="center">TX_EN</td><td align="center">1 根</td><td align="center">发送使能</td><td align="center">MAC → PHY</td><td align="center">高电平有效，指示 TXD [7:0] 上的数据有效，PHY 仅此时采样数据</td><td align="center">全速率通用</td></tr><tr><td align="center">TX_ER</td><td align="center">1 根</td><td align="center">发送错误指示</td><td align="center">MAC → PHY</td><td align="center">高电平有效，指示当前发送的数据帧存在格式错误</td><td align="center">全速率通用</td></tr><tr><td align="center">RX_CLK</td><td align="center">1 根</td><td align="center">接收时钟</td><td align="center">PHY → MAC</td><td align="center">接收同步时钟，千兆模式 &#x3D; 125MHz，百兆 &#x3D; 25MHz，十兆 &#x3D; 2.5MHz，<strong>由 PHY 从接收数据中提取并提供</strong>，MAC 同步采样 RXD 数据</td><td align="center">全速率通用，核心接收时钟</td></tr><tr><td align="center">RXD[7:0]</td><td align="center">8 根</td><td align="center">接收数据总线</td><td align="center">PHY → MAC</td><td align="center">8 位并行接收数据，GMII 的核心宽位宽设计</td><td align="center">千兆 &#x2F; 百兆 &#x2F; 十兆全兼容</td></tr><tr><td align="center">RX_DV</td><td align="center">1 根</td><td align="center">接收数据有效</td><td align="center">PHY → MAC</td><td align="center">高电平有效，指示 RXD [7:0] 上的数据有效，MAC 仅此时采样数据</td><td align="center">全速率通用，替代 MII 的 RX_EN 命名</td></tr><tr><td align="center">RX_ER</td><td align="center">1 根</td><td align="center">接收错误指示</td><td align="center">PHY → MAC</td><td align="center">高电平有效，指示当前接收的数据帧存在错误（CRC&#x2F;FCS 错误、帧长错误等）</td><td align="center">全速率通用</td></tr><tr><td align="center">CRS</td><td align="center">1 根</td><td align="center">载波侦听信号</td><td align="center">PHY → MAC</td><td align="center">仅<strong>半双工模式</strong>有效，高电平表示以太网总线忙，禁止 MAC 发送数据</td><td align="center">全速率通用，全双工模式下该信号无效（拉低）</td></tr><tr><td align="center">COL</td><td align="center">1 根</td><td align="center">冲突检测信号</td><td align="center">PHY → MAC</td><td align="center">仅<strong>半双工模式</strong>有效，高电平表示总线上发生数据碰撞，MAC 触发帧重传</td><td align="center">全速率通用，全双工模式下无冲突，该信号无效</td></tr></tbody></table><h3 id="RGMII-接口"><a href="#RGMII-接口" class="headerlink" title="RGMII 接口"></a>RGMII 接口</h3><p>RGMII 是 GMII 的简化版本。将引脚数量从 GMII 的 25 个减少至 RGMII 的 14 个。在10M&#x2F;100M&#x2F;1000M 下时钟分别是 2.5M，25M 和 125M。硬件连接如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302889.png" alt="RGMII" loading="lazy"></p><p>RGMII 接口一共需要 14 根信号线，含义如下</p><table><thead><tr><th align="center">信号名称</th><th align="center">数量</th><th align="center">方向（MAC ↔ PHY）</th><th align="center">核心描述 &amp; 开发关键要点</th><th align="center">速率适配</th></tr></thead><tbody><tr><td align="center">TXC</td><td align="center">1 根</td><td align="center">MAC → PHY</td><td align="center">发送时钟，千兆模式固定<strong>125MHz</strong>；<strong>双边沿采样</strong>（上升沿 + 下降沿）是 RGMII 精简的核心</td><td align="center">1000M&#x3D;125MHz100M&#x3D;25MHz10M&#x3D;2.5MHz</td></tr><tr><td align="center">TX_CTL</td><td align="center">1 根</td><td align="center">MAC → PHY</td><td align="center">发送控制信号，<strong>复用 TX_EN（发送使能）和 TX_ER（发送错误）</strong>；与 TXC 双边沿同步</td><td align="center">全速率通用</td></tr><tr><td align="center">TXD[3:0]</td><td align="center">4 根</td><td align="center">MAC → PHY</td><td align="center">发送数据总线，4 位并行；<strong>双边沿采样</strong>，时钟每个沿都传输 1 位数据，等效 8 位带宽</td><td align="center">全速率通用</td></tr><tr><td align="center">RXC</td><td align="center">1 根</td><td align="center">PHY → MAC</td><td align="center">接收时钟，千兆模式固定<strong>125MHz</strong>；由 PHY 提供，同样支持<strong>双边沿采样</strong></td><td align="center">1000M&#x3D;125MHz100M&#x3D;25MHz10M&#x3D;2.5MHz</td></tr><tr><td align="center">RX_CTL</td><td align="center">1 根</td><td align="center">PHY → MAC</td><td align="center">接收控制信号，<strong>复用 RX_DV（接收有效）和 RX_ER（接收错误）</strong>；与 RXC 双边沿同步</td><td align="center">全速率通用</td></tr><tr><td align="center">RXD[3:0]</td><td align="center">4 根</td><td align="center">MAC → PHY</td><td align="center">接收数据总线，4 位并行；<strong>双边沿采样</strong>，等效 8 位带宽</td><td align="center">全速率通用</td></tr></tbody></table><h3 id="MDIO-接口"><a href="#MDIO-接口" class="headerlink" title="MDIO 接口"></a>MDIO 接口</h3><p>MDIO 接口全称为 <strong>Management Data Input&#x2F;Output</strong>，即管理数据输入输出接口。</p><p>主要功能是<strong>实现 MAC 控制器对 PHY 芯片的管理与控制</strong>，例如通过 MDIO 接口对 PHY 寄存器进行设置来配置工作速率；也能够通过读取 PHY 芯片的状态寄存器从而获取网口的状态。</p><p>MDIO 接口属于<strong>同步串行半双工接口</strong>，由两根信号线构成，分别是：</p><ul><li>MDIO: 作为数据线，用于在 MAC 层和 PHY 层之间传输配置和管理数据。</li><li>MDC：作为时钟线，为数据传输提供时钟同步。</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="RTL8211-PHY芯片"><a href="#RTL8211-PHY芯片" class="headerlink" title="RTL8211 PHY芯片"></a>RTL8211 PHY芯片</h3><p>在 iTOP-RK3568 开发板采用的是 RTL8211 这款 PHY 芯片。RTL8211 支持 10Mbps、100Mbps和 1000Mbps 的传输速率，并且具备自动协商功能，能够根据网络环境自动调整工作模式。</p><p>通过 RTL8211 芯片数据手册中电路连接示意图可知，RTL8211 芯片通过 MDI 接口与 RJ45 接口。MAC 控制器通过 RGMII 接口和 MDIO 接口与 PHY 芯片连接。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302950.png" alt="RTL8211" loading="lazy"></p><p>对数据手册中的框图进行简化：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220302984.png" alt="RTL8211" loading="lazy"></p><p>iTOP-RK3568 核心板有引出 RGMII 接口。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303031.png" alt="RK3568核心板引出RGMII0" loading="lazy"></p><p>iTOP-RK3568 核心板通过 RGMII 接口和 MDIO 接口与 RTL8211 芯片相连。原理图如下</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303086.png" alt="通过 RGMII 接口和 MDIO 接口与 RTL8211 芯片相连" loading="lazy"></p><ul><li>第 15，16，17，18 引脚分别对应 TXD3，TXD2，TXD1，TXD0。是发送引脚，方向从MAC 到 PHY。</li><li>第 22，23，24，25，26 分别对应 RXD3，RXD2，RXD1，RXD0。是接收引脚，方向从PHY 到 MAC。</li><li>第 20 脚为 TXC 引脚，发送时钟信号引脚。</li><li>第 27 脚为 RXC 引脚，接收时钟信号引脚。</li><li>第 26 脚为 RXCTL 引脚，接收控制信号引脚。</li><li>第 13 和 14 脚为 MDIO 引脚。</li><li>第 31 引脚为 INTB&#x2F;PMEB 引脚，如果不使用这样俩个功能，此引脚悬空。如果把 Page 0xd40，REG.22 bit[5]寄存器设置成 1，则为 PMEB 功能，如果设置成 0，为中断功能。</li></ul><p>RTL8211 通过 MDI 接口与 RJ45 插座相连，原理图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303142.png" alt="RTL8211 通过 MDI 接口与 RJ45 插座相连" loading="lazy"></p><p>其中第 1 到 10 脚是分别对应 MDI 接口的 MDIP0，MDIN0，MDIP1，MDIN1，MDIP2，MDIN2，MDIP3，MDIN3 引脚。</p><p>MDI 接口是用于 PHY 芯片与网络变压器或者说是与 RJ45 插座相连的接口。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303199.png" alt="RJ45插座" loading="lazy"></p><h1 id="PHY-寄存器"><a href="#PHY-寄存器" class="headerlink" title="PHY 寄存器"></a>PHY 寄存器</h1><p>在 802.3 规范中，对 PHY 芯片的前 16 个寄存器进行了规定。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303258.png" alt="PHY 芯片的前 16 个寄存器" loading="lazy"></p><p>在开发中和我们打交道最多是寄存器 0，寄存器 1。</p><p><strong>寄存器 0 是控制寄存器</strong>：用于配置 PHY 芯片的工作模式和参数。可以通过控制寄存器设置芯片的传输速率（10Mbps、100Mbps 或 1000Mbps）、双工模式（全双工或半双工）以及自动协商功能的开启或关闭等。</p><p><strong>寄存器 1 是状态寄存器</strong>：用于表示 PHY 芯片当前的工作状态。比如，通过状态寄存器可以查看是否已经成功连接到网络、是否检测到链路故障、当前的传输速率和双工模式等信息等。</p><p><strong>寄存器 16 到 31 是扩展寄存器</strong>：寄存器 0 到 15 是 IEEE 802.3 规定的寄存器，不论使用哪个厂家的 PHY 芯片，寄存器 0 到 15 是一摸一样的，所以一般情况下，使用 Linux 中通用的 PHY 驱动即可驱动 PHY 芯片。但是不同厂家的 PHY 芯片可能有额外特性的功能，所以扩展寄存器就是给 PHY 厂家自由发挥的寄存器。也就是说只有用到这些特性功能时，才会涉及到扩展寄存器。</p><h2 id="PHY-地址"><a href="#PHY-地址" class="headerlink" title="PHY 地址"></a>PHY 地址</h2><p>每个 PHY 寄存器都有唯一的地址，通过这些地址，我们可以准确的访问和操作相应的寄存器。iTOP-RK3568 开发板中 RTL8211 PHY 芯片的地址可以通过 22，27，26 脚来设置。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303305.png" alt="PHY Address Config" loading="lazy"></p><p><strong>物理地址（MAC 地址）</strong></p><p>物理地址，也称为 MAC 地址，是网络设备的唯一标识符。它由 48 位二进制数组成，通常用 12 位十六进制数表示，如 00:11:22:33:44:55。</p><p><strong>IP 地址</strong></p><p>IP 地址是网络层的地址，用于在网络中标识设备的逻辑位置。它分为 IPv4 和 IPv6 两种版本：</p><ul><li>IPv4 地址由 32 位二进制数组成，通常用点分十进制表示，如 192.168.1.1；</li><li>IPv6 地址由 128 位二进制数组成。IP 地址的主要作用是实现不同网络之间的通信，通过 IP 地址可以将数据包从源网络路由到目标网络。</li></ul><p><strong>PHY 地址</strong></p><p>PHY 地址是用于在一个网络中唯一标识 PHY 芯片的地址。在一个系统中，可能会有多个 PHY 芯片同时存在，通过 PHY 地址可以区分不同的 PHY 芯片，以便对它们进行单独的配置和管理。</p><h2 id="PHY-芯片地址的确定"><a href="#PHY-芯片地址的确定" class="headerlink" title="PHY 芯片地址的确定"></a>PHY 芯片地址的确定</h2><p>以迅为 iTOP-RK3568 开发板为例，其采用的 RTL8211 PHY 芯片地址通过以下方式进行确定。</p><p>打开 RTL8211 PHY 芯片的数据手册，如下图所示，22 26 27 引脚是配置 PHY 芯片的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303372.png" alt="RTL8211 PHY" loading="lazy"></p><p>又RK3568 底板原理图上 PHY 芯片这三个引脚是连接的如下：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303305.png" alt="PHY Address Config" loading="lazy"></p><p>由上图可知，PHY 芯片的地址是 001，也就是 1。PHY 芯片通过硬件引脚来设置地址</p><h2 id="操作-PHY-寄存器"><a href="#操作-PHY-寄存器" class="headerlink" title="操作 PHY 寄存器"></a>操作 PHY 寄存器</h2><p>首先，打开 iTOP-RK3568 开发板的调试串口，接着为开发板上电。待进入终端后，通过执行命令<code>cd /sys/bus/mdio_bus/devices</code>，进入开发板的<code>mdio_bus</code>总线设备目录。</p><p>随后，再执行命令<code>cd stmmac-0:00/</code>，即可进入网卡 0 的设备，具体操作过程如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/bus/mdio_bus/devices</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> stmmac-0:00/</span><br><span class="line"><span class="comment"># 查看各个寄存器的值</span></span><br><span class="line"><span class="built_in">cat</span> phy_registers</span><br><span class="line"><span class="comment"># 对 0 号寄存器的值进行修改，设置为0x40</span></span><br><span class="line"><span class="built_in">echo</span> 0x00 0x40 &gt; phy_registers</span><br></pre></td></tr></table></figure><h1 id="网络应用编程基础"><a href="#网络应用编程基础" class="headerlink" title="网络应用编程基础"></a>网络应用编程基础</h1><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>小端模式：低位字节存在低地址，高位字节存在高地址。</p><p>大端模式：高位字节存在低地址，低位字节存在高地址。</p><h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><p>常见的字节序转换函数有四个，分别为 htonl、htons、ntohl、ntohs，每个函数的简要介绍如下表所示：</p><blockquote><p>它们的核心作用是解决不同主机与网络之间的字节序不兼容问题。</p></blockquote><table><thead><tr><th align="center">函数名称</th><th align="center">功能描述</th><th align="center">数据类型</th><th align="center">转换方向</th></tr></thead><tbody><tr><td align="center"><code>htonl</code></td><td align="center">将 32 位主机字节序转换为网络字节序</td><td align="center"><code>uint32_t</code></td><td align="center">主机 → 网络</td></tr><tr><td align="center"><code>htons</code></td><td align="center">将 16 位主机字节序转换为网络字节序</td><td align="center"><code>uint16_t</code></td><td align="center">主机 → 网络</td></tr><tr><td align="center"><code>ntohl</code></td><td align="center">将 32 位网络字节序转换为主机字节序</td><td align="center"><code>uint32_t</code></td><td align="center">网络 → 主机</td></tr><tr><td align="center"><code>ntohs</code></td><td align="center">将 16 位网络字节序转换为主机字节序</td><td align="center"><code>uint16_t</code></td><td align="center">网络 → 主机</td></tr></tbody></table><p><code>uint32_t htonl(uint32_t hostlong)</code></p><ul><li>功能：用于将本地存储的 32 位整数转换为适合在网络上传输的格式（大端模式）。</li><li>参数：32 位主机字节序整数。</li><li>返回值：返回一个 32 位网络字节序整数。</li></ul><p><code>uint16_t htons(uint16_t hostshort)</code></p><ul><li>功能：用于将本地存储的 16 位整数（如端口号）转换为适合在网络上传输的格式。</li><li>参数：16 位主机字节序整数。</li><li>返回值：返回一个 16 位网络字节序整数。</li></ul><p><code>uint32_t ntohl(uint32_t netlong)</code></p><ul><li>功能：用于将从网络接收到的 32 位数据（如 IPv4 地址）转换为本地系统可以处理的格式。</li><li>参数：32 位网络字节序整数。</li><li>返回值：返回一个 32 位主机字节序整数。</li></ul><p><code>uint16_t ntohs(uint16_t netshort)</code></p><ul><li>功能：用于将从网络接收到的 16 位数据（如端口号）转换为本地系统可以处理的格式。</li><li>参数：16 位网络字节序整数。</li><li>返回值：返回一个 16 位主机字节序整数。</li></ul><p>例如在编写 TCP 和 UDP 代码的时候，需要用到端口号，例如 8080，这时候就要用到字节序的转换了，需要通过 htons 将 8080 从主机字节序转换为网络字节序，一个简单的示例程序如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> host_port = <span class="number">8080</span>; <span class="comment">// 主机端口号</span></span><br><span class="line"><span class="type">uint16_t</span> net_port = htons(host_port); <span class="comment">// 转换为网络字节序</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Host Port: 0x%04X\n&quot;</span>, host_port);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Network Port: 0x%04X\n&quot;</span>, net_port);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="地址转换函数"><a href="#地址转换函数" class="headerlink" title="地址转换函数"></a>地址转换函数</h2><blockquote><p>除了字节序需要转换之外 IP 地址也需要转换，IP 地址通常是以点分十进制（如 192.168.1.1）这一人类可读的形式下展示的，而在程序内部则需要以二进制形式进行存储和处理。</p></blockquote><p>在网络编程中，IP 地址转换函数有两个，分别是 <code>inet_pton</code> 和 <code>inet_ntop</code>，它们支持 IPv4 和IPv6 地址的转换，两个函数的简单介绍如下所示：</p><p>这张表格展示了网络编程中用于 IP 地址格式转换的两个核心函数，它们同时支持 IPv4 和 IPv6 地址的转换。</p><table><thead><tr><th align="center">函数名称</th><th align="center">功能描述</th><th align="center">转换方向</th></tr></thead><tbody><tr><td align="center"><code>inet_pton</code></td><td align="center">将点分十进制（IPv4）或冒号十六进制（IPv6）的字符串格式 IP 地址，转换为网络字节序的二进制数据</td><td align="center">字符串 → 二进制</td></tr><tr><td align="center"><code>inet_ntop</code></td><td align="center">将网络字节序的二进制 IP 地址，转换为点分十进制（IPv4）或冒号十六进制（IPv6）的字符串格式</td><td align="center">二进制 → 字符串</td></tr></tbody></table><h3 id="inet-pton"><a href="#inet-pton" class="headerlink" title="inet_pton()"></a>inet_pton()</h3><ul><li>将字符串地址转换为二进制数据</li><li>将点分十进制（IPv4）或冒号十六进制（IPv6）的 IP 地址字符串转换为网络字节序的二进制数据。</li></ul><p><code>inet_pton</code> 函数原型如下所示，成功时返回 1，如果 src 格式无效，返回 0，如果 af 不支持，返回-1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br></pre></td></tr></table></figure><p>具体的参数介绍如下所示：</p><table><thead><tr><th align="center">参数名称</th><th align="center">描述</th><th align="center">数据类型 &#x2F; 值范围</th><th align="center">示例值</th></tr></thead><tbody><tr><td align="center"><code>af</code></td><td align="center">指定地址族，用于区分 IPv4 或 IPv6 地址</td><td align="center"><code>AF_INET</code>：IPv4<code>AF_INET6</code>：IPv6</td><td align="center"><code>AF_INET</code>（IPv4）</td></tr><tr><td align="center"><code>src</code></td><td align="center">指向要转换的 IP 地址字符串的指针</td><td align="center">字符串</td><td align="center"><code>&quot;192.168.1.1&quot;</code></td></tr><tr><td align="center"><code>dst</code></td><td align="center">指向存储转换后二进制数据的缓冲区</td><td align="center">二进制数据</td><td align="center"><code>struct in_addr</code></td></tr></tbody></table><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *ipv4 = <span class="string">&quot;192.168.1.1&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="keyword">if</span> (inet_pton(AF_INET, ipv4, &amp;addr) &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Invalid IPv4 address\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Network byte order: 0x%x\n&quot;</span>, addr.s_addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop()"></a>inet_ntop()</h3><ul><li>将二进制数据转换为字符串地址</li><li><code>inet_ntop</code> 函数用于将网络字节序的二进制 IP 地址转换为人类可读的字符串形式（点分十进制或冒号十六进制）。</li></ul><p><code>inet_ntop</code> 的函数原型如下所示，运行成功时返回指向 dst 的指针，失败时返回 NULL 并设置 errno。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>参数如下：</p><table><thead><tr><th align="center">参数名称</th><th align="center">描述</th><th align="center">数据类型 &#x2F; 值范围</th><th align="center">示例值</th></tr></thead><tbody><tr><td align="center"><code>af</code></td><td align="center">指定地址族，用于区分 IPv4 或 IPv6 地址</td><td align="center"><code>AF_INET</code>：IPv4<code>AF_INET6</code>：IPv6</td><td align="center"><code>AF_INET</code>（IPv4）</td></tr><tr><td align="center"><code>src</code></td><td align="center">指向存储二进制 IP 地址的缓冲区</td><td align="center">二进制数据</td><td align="center"><code>struct in_addr</code></td></tr><tr><td align="center"><code>dst</code></td><td align="center">指向存储转换后字符串形式 IP 地址的缓冲区</td><td align="center">字符串</td><td align="center"><code>char ip[INET_ADDRSTRLEN]</code></td></tr><tr><td align="center"><code>size</code></td><td align="center"><code>dst</code> 缓冲区的大小，确保足够容纳结果字符串</td><td align="center"><code>socklen_t</code></td><td align="center"><code>INET_ADDRSTRLEN</code> 或 <code>INET6_ADDRSTRLEN</code></td></tr></tbody></table><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.s_addr = <span class="number">0xC0A80101</span>; <span class="comment">// 网络字节序的 192.168.1.1</span></span><br><span class="line"><span class="type">char</span> ip[INET_ADDRSTRLEN];</span><br><span class="line"><span class="keyword">if</span> (inet_ntop(AF_INET, &amp;addr, ip, <span class="keyword">sizeof</span>(ip)) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;inet_ntop&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Dotted decimal: %s\n&quot;</span>, ip);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 的英文全称为 <strong>User Datagram Protocol</strong>，意为用户数据报协议，它是一种<strong>无连接</strong>的传输层协议，属于 TCP&#x2F;IP 协议栈的一部分。它提供了一种简单、轻量的数据传输方式，适用于对速度要求高但对可靠性要求较低的场景，例如如视频会议、在线游戏、语音通话等，这些场景对延迟敏感且能容忍偶尔的丢包。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303419.png" alt="UDP通信框架" loading="lazy"></p><h3 id="UDP-函数"><a href="#UDP-函数" class="headerlink" title="UDP 函数"></a>UDP 函数</h3><table><thead><tr><th align="center">函数名</th><th align="center">功能描述</th><th align="center">使用场景</th></tr></thead><tbody><tr><td align="center"><code>socket()</code></td><td align="center">创建一个套接字（socket），作为网络通信的端点。</td><td align="center">服务器和客户端都需要调用此函数，创建一个用于后续通信的句柄。</td></tr><tr><td align="center"><code>bind()</code></td><td align="center">将套接字绑定到指定的 IP 地址和端口号，使系统能将发送到该地址的数据交付给此套接字。</td><td align="center">服务器必须调用，以绑定一个固定的监听端口，让客户端能找到它；客户端通常不需要显式调用。</td></tr><tr><td align="center"><code>sendto()</code></td><td align="center">向指定的目标 IP 地址和端口发送数据报，是 UDP 协议的核心发送接口。</td><td align="center">客户端用它向服务器发送请求；服务器用它向客户端发送响应。</td></tr><tr><td align="center"><code>recvfrom()</code></td><td align="center">从网络接收数据报，并获取发送方的 IP 地址和端口信息。</td><td align="center">服务器用它接收客户端的请求；客户端用它接收服务器的响应。</td></tr></tbody></table><h4 id="sendto"><a href="#sendto" class="headerlink" title="sendto()"></a>sendto()</h4><p><code>sendto()</code> 是一个用于发送数据的系统调用，主要用于无连接的 UDP 协议。它允许程序将数据发送到指定的目标地址（即目标 IP 和端口）。与 <code>send()</code>不同，<code>sendto()</code>需要显式指定目标地址，因此非常适合无连接的通信。它的函数原型如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><table><thead><tr><th align="center">参数名</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>sockfd</code></td><td align="center"><code>int</code></td><td align="center">套接字文件描述符，由 <code>socket()</code> 函数创建，是后续所有网络操作的句柄。</td></tr><tr><td align="center"><code>buf</code></td><td align="center"><code>const void *</code></td><td align="center">指向要发送的数据缓冲区的指针，它是 <code>const</code> 类型，表示函数不会修改该缓冲区的内容。</td></tr><tr><td align="center"><code>len</code></td><td align="center"><code>size_t</code></td><td align="center">数据缓冲区的长度，以字节为单位，告诉函数需要发送多少字节的数据。</td></tr><tr><td align="center"><code>flags</code></td><td align="center"><code>int</code></td><td align="center">发送标志，通常设为 <code>0</code>。可以设置特殊标志（如 <code>MSG_DONTROUTE</code> 表示不查路由表，<code>MSG_CONFIRM</code> 用于链路层确认），但在常规 UDP 通信中很少使用。</td></tr><tr><td align="center"><code>dest_addr</code></td><td align="center"><code>struct sockaddr *</code></td><td align="center">指向目标地址结构体的指针，通常是 <code>struct sockaddr_in</code>（IPv4）或 <code>struct sockaddr_in6</code>（IPv6），包含了目标 IP 和端口信息。</td></tr><tr><td align="center"><code>addrlen</code></td><td align="center"><code>socklen_t</code></td><td align="center">目标地址结构体的大小，以字节为单位，用于告诉函数 <code>dest_addr</code> 指向的结构体有多大。</td></tr></tbody></table><p>成功会返回实际发送的字节数</p><h4 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom()"></a>recvfrom()</h4><p><code>recvfrom()</code>是一个用于接收数据的系统调用，主要用于无连接的 UDP 协议。它允许程序从指定的源地址（即发送方的 IP 和端口）接收数据包。与 <code>recv()</code>不同，<code>recvfrom()</code>可以获取发送方的地址信息，因此非常适合无连接的通信。它的函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>该函数的各个参数介绍如下所示：</p><table><thead><tr><th align="center">参数名</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>sockfd</code></td><td align="center"><code>int</code></td><td align="center">套接字文件描述符，由 <code>socket()</code> 函数创建，是网络操作的句柄。</td></tr><tr><td align="center"><code>buf</code></td><td align="center"><code>void *</code></td><td align="center">指向存储接收数据的缓冲区的指针，函数会将收到的数据写入此缓冲区。</td></tr><tr><td align="center"><code>len</code></td><td align="center"><code>size_t</code></td><td align="center">缓冲区的最大长度（字节）。若接收的数据超过此长度，多余部分会被截断。</td></tr><tr><td align="center"><code>flags</code></td><td align="center"><code>int</code></td><td align="center">接收标志，通常设为 <code>0</code>。可设置特殊标志（如 <code>MSG_PEEK</code> 仅查看数据不取出、<code>MSG_DONTWAIT</code> 非阻塞接收），常规 UDP 通信中较少使用。</td></tr><tr><td align="center"><code>src_addr</code></td><td align="center"><code>struct sockaddr *</code></td><td align="center">指向存储发送方地址结构体的指针，通常为 <code>struct sockaddr_in</code>（IPv4）或 <code>struct sockaddr_in6</code>（IPv6），用于获取发送方的 IP 和端口。</td></tr><tr><td align="center"><code>addrlen</code></td><td align="center"><code>socklen_t *</code></td><td align="center">指向发送方地址结构体大小的指针。调用前需初始化为结构体的预期大小，调用后会更新为实际的地址长度。</td></tr></tbody></table><p>成功之后会返回实际接收到的字节数</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>udp_client.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量port用于存储端口号</span></span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="comment">// 定义变量fd用于存储套接字描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 定义字符数组buf作为发送数据的缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数个数是否为3</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果参数个数不正确，输出使用示例提示信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;for example: ./app ip port\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1 表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令行参数中的端口号字符串转换为整数</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个UDP套接字</span></span><br><span class="line">    <span class="comment">// AF_INET 表示使用IPv4协议</span></span><br><span class="line">    <span class="comment">// SOCK_DGRAM 表示这是一个UDP套接字</span></span><br><span class="line">    <span class="comment">// 0 表示使用默认协议</span></span><br><span class="line">    fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查套接字是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果创建失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket fd error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1 表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个sockaddr_in结构体，用于存储目标服务器地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 将端口号从主机字节序转换为网络字节序并赋值给addr.sin_port</span></span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    <span class="comment">// 将命令行参数中的IP地址字符串转换为网络字节序的IP地址并赋值给addr.sin_addr.s_addr</span></span><br><span class="line">    <span class="comment">// 这里也可以使用inet_pton(AF_INET, argv[1], &amp;addr.sin_addr); ，但当前代码使用的inet_addr也是可行的</span></span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区buf清零，为后续接收数据做准备</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">// 进入无限循环，实现持续向服务器发送数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从标准输入读取字符串到buf缓冲区</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">        <span class="comment">// 通过UDP套接字向服务器发送buf中的数据</span></span><br><span class="line">        <span class="comment">// fd为套接字描述符</span></span><br><span class="line">        <span class="comment">// buf为要发送的数据</span></span><br><span class="line">        <span class="comment">// strlen(buf)为数据长度</span></span><br><span class="line">        <span class="comment">// 0表示默认的发送标志</span></span><br><span class="line">        <span class="comment">// (struct sockaddr*)&amp;addr为服务器地址</span></span><br><span class="line">        <span class="comment">// sizeof(addr)为服务器地址结构体的大小</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">        <span class="comment">// 将buf缓冲区清零，为下一次接收数据做准备</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>udp_server.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量port用于存储端口号</span></span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="comment">// 定义变量fd用于存储套接字描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 定义字符数组buf作为接收数据的缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 定义变量ret用于存储函数返回值</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 定义变量len用于存储地址结构体的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数个数是否为3</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果参数个数不正确，输出使用示例提示</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;for example: ./app ip port\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1 表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令行参数中的端口号字符串转换为整数</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个UDP套接字</span></span><br><span class="line">    <span class="comment">// AF_INET表示使用IPv4协议</span></span><br><span class="line">    <span class="comment">// SOCK_DGRAM表示这是一个UDP套接字</span></span><br><span class="line">    <span class="comment">// 0表示使用默认协议</span></span><br><span class="line">    fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查套接字是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果创建失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket fd error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1 表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化本地地址结构体local_addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 初始化源地址结构体src_addr</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">src_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置本地地址的地址族为IPv4</span></span><br><span class="line">    local_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 将端口号从主机字节序转换为网络字节序并赋值给local_addr.sin_port</span></span><br><span class="line">    local_addr.sin_port = htons(port);</span><br><span class="line">    <span class="comment">// 将命令行参数中的IP地址字符串转换为网络字节序的IP地址并赋值给local_addr.sin_addr.s_addr</span></span><br><span class="line">    local_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字fd绑定到local_addr</span></span><br><span class="line">    ret = bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;local_addr, <span class="keyword">sizeof</span>(local_addr));</span><br><span class="line">    <span class="comment">// 检查绑定是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果绑定失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1 表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置src_addr结构体的长度</span></span><br><span class="line">    len = <span class="keyword">sizeof</span>(src_addr);</span><br><span class="line">    <span class="comment">// 将缓冲区buf清零，为接收数据做准备</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入无限循环，持续接收数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从UDP套接字fd接收数据</span></span><br><span class="line">        <span class="comment">// buf是接收数据的缓冲区</span></span><br><span class="line">        <span class="comment">// sizeof(buf)是缓冲区大小</span></span><br><span class="line">        <span class="comment">// 0是接收标志</span></span><br><span class="line">        <span class="comment">// (struct sockaddr *)&amp;src_addr是源地址结构体指针</span></span><br><span class="line">        <span class="comment">// &amp;len用于返回源地址结构体的实际长度</span></span><br><span class="line">        recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;src_addr, &amp;len);</span><br><span class="line">        <span class="comment">// 将源地址的IP地址转换为点分十进制格式并输出</span></span><br><span class="line">        <span class="comment">// inet_ntoa函数将网络字节序的IP地址转换为点分十进制字符串</span></span><br><span class="line">        <span class="comment">// ntohs函数将网络字节序的端口号转换为主机字节序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ip:%s port:%d\n&quot;</span>, inet_ntoa(src_addr.sin_addr), ntohs(src_addr.sin_port));</span><br><span class="line">        <span class="comment">// 输出接收到的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf is %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="comment">// 将缓冲区buf清零，为下一次接收做准备</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP 的英文全称为 <strong>Transmission Control Protocol</strong>，意为传输控制协议，它是一种<strong>面向连接</strong>的传输层协议，与 UDP 一样，都属于TCP&#x2F;IP 协议栈的核心部分。</p><p>TCP 通过建立可靠的端到端连接，确保数据在传输过程中的完整性、顺序性和无丢失性。它使用三次握手建立连接，并通过确认机制、重传机制以及流量控制等功能来保障数据传输的可靠性。</p><p>因此，TCP 适用于对数据准确性要求较高的场景，例如文件传输、电子邮件、网页浏览等，这些场景中数据的完整性和顺序性至关重要，而对延迟的容忍度相对较高。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260113220303465.png" alt="TCP通信框架图" loading="lazy"></p><ul><li>TCP 客户端与 UDP 客户端相比，中间多了调用 connect 发起连接请求的这一步骤</li><li>TCP服务器端与 UDP 服务器端相比，中间多了调用 listen 启动监听模式以及调用 accept 阻塞并等待客户端的请求这两个步骤<ul><li>listen 会将套接字设置为被动模式以等待客户端的连接请求</li><li>当客户端发起连接时，accept 会阻塞并等待，直到接收到请求后返回一个新的套接字文件描述符，该描述符专门用于与该客户端进行通信。</li></ul></li></ul><p>当客户端通过 connect 发起连接请求后，会与服务器进行 TCP 三次握手建立连接，连接建立后，客户端和服务器可以通过 write()和 read()进行数据的发送和接收。</p><p>数据传输完成后，客户端和服务器分别通过 close()关闭连接。</p><h3 id="TCP-函数"><a href="#TCP-函数" class="headerlink" title="TCP 函数"></a>TCP 函数</h3><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>connect()是一个用于建立连接的系统调用，主要用于客户端。它通过指定服务器的地址（IP 地址和端口号），向服务器发起连接请求。对于 TCP 协议，connect()会触发 TCP 的三次握手过程；需要注意的是对于 UDP 协议，connect 同样可以使用，但是并不会真正建立连接，而是将目标地址绑定到套接字上，以便后续的通信过程。 它的函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p>成功返回 0，失败则返回-1</p><table><thead><tr><th align="center">参数名</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>sockfd</code></td><td align="center"><code>int</code></td><td align="center">套接字文件描述符，由 <code>socket()</code> 函数创建，是后续所有网络操作的句柄。</td></tr><tr><td align="center"><code>addr</code></td><td align="center"><code>struct sockaddr *</code></td><td align="center">指向目标地址结构体的指针，通常是 <code>struct sockaddr_in</code>（IPv4）或 <code>struct sockaddr_in6</code>（IPv6），包含了要绑定的 IP 地址和端口号。</td></tr><tr><td align="center"><code>addrlen</code></td><td align="center"><code>socklen_t</code></td><td align="center">目标地址结构体的大小，以字节为单位，例如 <code>sizeof(struct sockaddr_in)</code>。</td></tr></tbody></table><h4 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h4><p><code>listen()</code> 是一个用于将套接字设置为监听模式的系统调用，主要用于 TCP 服务器。它将套接字从主动模式（用于发起连接）转换为被动模式（用于接收连接请求）。调用 <code>listen()</code> 后，套接字会开始监听来自客户端的连接请求，并维护一个等待队列以管理这些请求。它的函数原型如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure><p>函数长度</p><table><thead><tr><th align="center">参数名</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>sockfd</code></td><td align="center"><code>int</code></td><td align="center">套接字文件描述符，由 <code>socket()</code> 创建并通过 <code>bind()</code> 绑定到特定地址和端口。</td></tr><tr><td align="center"><code>backlog</code></td><td align="center"><code>int</code></td><td align="center">等待连接队列的最大长度，代表可以同时排队等待处理的 TCP 连接请求数量。</td></tr></tbody></table><p>成功后返回 0，失败则返回-1，</p><h4 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h4><p><code>accept()</code> 是一个用于接收客户端连接请求的系统调用，主要用于 TCP 服务器。它从监听套接字的等待队列中取出一个连接请求，并创建一个新的套接字专门用于与该客户端通信。通过<code>accept()</code>，服务器能够处理多个客户端的连接请求。它的函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p>该函数的各个参数介绍如下所示:</p><table><thead><tr><th align="center">参数名</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>sockfd</code></td><td align="center"><code>int</code></td><td align="center">监听套接字文件描述符，由 <code>socket()</code> 创建并通过 <code>listen()</code> 设置为监听模式。</td></tr><tr><td align="center"><code>addr</code></td><td align="center"><code>struct sockaddr *</code></td><td align="center">指向存储客户端地址结构体的指针（如 <code>struct sockaddr_in</code> 表示 IPv4 地址）。可以为 <code>NULL</code>，表示不需要获取客户端地址。</td></tr><tr><td align="center"><code>addrlen</code></td><td align="center"><code>socklen_t *</code></td><td align="center">指向客户端地址结构体大小的指针。调用前需初始化为目标地址结构体的大小，调用后会更新为实际的地址长度。</td></tr></tbody></table><p>成功后返回 0，失败则返回-1，</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><code>tcp_client.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量port，用于存储从命令行获取的端口号</span></span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="comment">// 定义变量fd，用于存储套接字描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 定义字符数组buf，作为数据缓冲区，用于存储从标准输入读取的数据以及接收的数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 定义变量ret，用于存储函数的返回值</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数个数是否为3</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果参数个数不正确，输出使用示例提示信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;for example: ./app ip port\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1，表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令行参数中的端口号字符串转换为整数</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个TCP套接字</span></span><br><span class="line">    <span class="comment">// AF_INET 表示使用IPv4协议</span></span><br><span class="line">    <span class="comment">// SOCK_STREAM 表示这是一个面向连接的字节流套接字，适用于TCP协议</span></span><br><span class="line">    <span class="comment">// 0 表示使用默认协议</span></span><br><span class="line">    fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查套接字是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果创建失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket fd error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1，表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个sockaddr_in结构体，用于存储服务器的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 将端口号从主机字节序转换为网络字节序并赋值给addr.sin_port</span></span><br><span class="line">    addr.sin_port = htons(port);</span><br><span class="line">    <span class="comment">// 将命令行参数中的IP地址字符串转换为网络字节序的IP地址并赋值给addr.sin_addr.s_addr</span></span><br><span class="line">    <span class="comment">// 这里也可以使用inet_pton(AF_INET, argv[1], &amp;addr.sin_addr); ，但当前代码使用的inet_addr也是可行的</span></span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用connect函数连接到服务器</span></span><br><span class="line">    <span class="comment">// fd为套接字描述符</span></span><br><span class="line">    <span class="comment">// (struct sockaddr*)&amp;addr为服务器地址结构体指针</span></span><br><span class="line">    <span class="comment">// sizeof(addr)为服务器地址结构体的大小</span></span><br><span class="line">    ret = connect(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="comment">// 检查连接是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果连接失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1，表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区buf清零，为后续操作做准备</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入无限循环，实现持续向服务器发送数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从标准输入读取字符串到buf缓冲区</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">        <span class="comment">// 通过TCP套接字向服务器发送buf中的数据</span></span><br><span class="line">        <span class="comment">// 注意：这里使用sendto函数对于TCP套接字不太合适，通常TCP使用send函数</span></span><br><span class="line">        <span class="comment">// 正确的应该是send(fd, buf, strlen(buf), 0);</span></span><br><span class="line">        <span class="comment">// 但原代码使用sendto，这里按照原代码逻辑注释</span></span><br><span class="line">        sendto(fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">        <span class="comment">// 将buf缓冲区清零，为下一次接收数据做准备</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcp_server.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// 定义变量port，用于存储从命令行获取的端口号</span></span><br><span class="line">    <span class="type">int</span> port;</span><br><span class="line">    <span class="comment">// 定义变量fd，用于存储套接字描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 定义字符数组buf，作为接收数据的缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 定义变量ret，用于存储函数的返回值</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 定义变量len，用于存储地址结构体的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 定义变量acc_fd，用于存储接受连接后的新套接字描述符</span></span><br><span class="line">    <span class="type">int</span> acc_fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数个数是否为3</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果参数个数不正确，输出使用示例提示信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;for example: ./app ip port\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1，表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令行参数中的端口号字符串转换为整数</span></span><br><span class="line">    port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个TCP套接字</span></span><br><span class="line">    <span class="comment">// AF_INET 表示使用IPv4协议</span></span><br><span class="line">    <span class="comment">// SOCK_STREAM 表示这是一个面向连接的字节流套接字，适用于TCP协议</span></span><br><span class="line">    <span class="comment">// 0 表示使用默认协议</span></span><br><span class="line">    fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查套接字是否创建成功</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果创建失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket fd error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1，表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个sockaddr_in结构体，用于存储本地地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    local_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// 将端口号从主机字节序转换为网络字节序并赋值给local_addr.sin_port</span></span><br><span class="line">    local_addr.sin_port = htons(port);</span><br><span class="line">    <span class="comment">// 将命令行参数中的IP地址字符串转换为网络字节序的IP地址并赋值给local_addr.sin_addr.s_addr</span></span><br><span class="line">    <span class="comment">// 这里也可以使用inet_pton(AF_INET, argv[1], &amp;local_addr.sin_addr); ，但当前代码使用的inet_addr也是可行的</span></span><br><span class="line">    local_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将套接字fd绑定到local_addr</span></span><br><span class="line">    ret = bind(fd, (<span class="keyword">struct</span> sockaddr*)&amp;local_addr, <span class="keyword">sizeof</span>(local_addr));</span><br><span class="line">    <span class="comment">// 检查绑定是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果绑定失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1，表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置套接字为监听状态，等待客户端连接</span></span><br><span class="line">    <span class="comment">// 第二个参数10表示等待连接队列的最大长度</span></span><br><span class="line">    listen(fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个sockaddr_in结构体，用于存储客户端地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">src_addr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 定义变量src_len，用于存储客户端地址结构体的长度</span></span><br><span class="line">    <span class="type">socklen_t</span> src_len = <span class="keyword">sizeof</span>(src_addr);</span><br><span class="line">    <span class="comment">// 接受客户端的连接请求，返回一个新的套接字描述符acc_fd用于与客户端通信</span></span><br><span class="line">    acc_fd = accept(fd, (<span class="keyword">struct</span> sockaddr*)&amp;src_addr, &amp;src_len);</span><br><span class="line">    <span class="comment">// 检查接受连接是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (acc_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果接受连接失败，输出错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回 -1，表示程序异常结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区buf清零，为后续接收数据做准备</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入无限循环，持续接收客户端发送的数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 从新套接字acc_fd接收数据到buf缓冲区</span></span><br><span class="line">        <span class="type">int</span> byte = recvfrom(acc_fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;src_addr, &amp;len);</span><br><span class="line">        <span class="comment">// 检查接收数据的字节数</span></span><br><span class="line">        <span class="keyword">if</span> (byte &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果接收到的数据字节数大于0，打印客户端的IP地址、端口号以及接收到的数据</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ip:%s port:%d\n&quot;</span>, inet_ntoa(src_addr.sin_addr), ntohs(src_addr.sin_port));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;buf is %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果接收到的数据字节数为0，表示客户端关闭了连接</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (byte == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;close\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 跳出循环，结束数据接收</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果接收数据时发生错误</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recvfrom error\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 返回 -1，表示程序异常结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将buf缓冲区清零，为下一次接收数据做准备</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭与客户端通信的套接字acc_fd</span></span><br><span class="line">    close(acc_fd);</span><br><span class="line">    <span class="comment">// 关闭监听套接字fd</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回0，表示程序正常结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小网络设备驱动"><a href="#最小网络设备驱动" class="headerlink" title="最小网络设备驱动"></a>最小网络设备驱动</h1><p>可借助 Linux 源码中现有的驱动作为模板，该驱动路径为 <code>drivers/net/loopback.c</code>。先将这个文件备份为 <code>loopback.c.bak</code>，随后新建一个 <code>loopback.c</code> 文件，在其中编写我们的最小网络设备驱动。</p><p>驱动程序内容如下所示, 代码实现了一个简单的回环网络设备驱动程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含与内核相关的基础定义和函数，如内核数据类型、内核打印函数等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="comment">// 提供与系统时间相关的jiffies变量和函数，jiffies记录系统启动以来的时钟滴答数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于构建可加载内核模块的相关定义和宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含与中断处理相关的函数和数据结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="comment">// 文件系统相关的定义和函数，例如inode、file_operations等结构体的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义了各种内核数据类型，如 kuid_t、kgid_t等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="comment">// 提供字符串处理函数，如strcpy、strlen等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含套接字相关的定义和函数，用于网络编程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义了各种错误码，用于错误处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含文件控制相关的定义，如文件打开标志（O_RDONLY、O_WRONLY等）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/in.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义了与Internet地址相关的数据结构和常量，如sockaddr_in等</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="comment">// 提供用户空间和内核空间数据交互的函数，如copy_from_user、copy_to_user等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于执行I/O操作，如ioread、iowrite等函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含与Internet协议相关的函数和数据结构，如IP地址处理等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netdevice.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义了网络设备相关的结构体和函数，是网络设备驱动开发的核心头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/etherdevice.h&gt;</span></span></span><br><span class="line"><span class="comment">// 提供以太网设备相关的辅助函数，如以太网地址操作等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含套接字缓冲区（sk_buff）相关的定义和函数，用于网络数据的处理和传输</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ethtool.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于操作网络设备的ethtool功能，如获取和设置网络设备的各种参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义了套接字相关的数据结构和函数，是网络编程中套接字操作的基础</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/checksum.h&gt;</span></span></span><br><span class="line"><span class="comment">// 提供计算校验和的函数，用于网络数据的校验</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span><span class="comment">// For the statistics structure.</span></span></span><br><span class="line"><span class="comment">// 包含以太网相关的定义，如以太网帧格式、统计信息结构体等</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_arp.h&gt;</span><span class="comment">// For ARPHRD_ETHER</span></span></span><br><span class="line"><span class="comment">// 包含地址解析协议（ARP）相关的定义，如ARP硬件类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义了IP协议相关的数据结构，如iphdr结构体用于表示IP头部</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tcp.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含TCP协议相关的数据结构和定义，如tcphdr结构体用于表示TCP头部</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/percpu.h&gt;</span></span></span><br><span class="line"><span class="comment">// 提供了与每个CPU变量相关的功能，允许为每个CPU分配独立的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/net_tstamp.h&gt;</span></span></span><br><span class="line"><span class="comment">// 与网络时间戳相关的定义和函数，用于记录网络数据包的时间信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/net_namespace.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含网络命名空间相关的定义和函数，用于实现网络资源的隔离</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/u64_stats_sync.h&gt;</span></span></span><br><span class="line"><span class="comment">// 提供了用于同步64位统计数据的机制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局变量，指向网络设备结构体，用于表示回环网络设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">virnet_netdevice</span>;</span></span><br><span class="line"><span class="comment">// 定义一个全局变量，用于记录传输的字节数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> bytes = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 定义一个全局变量，用于记录传输的数据包数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> packets = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义网络设备的发送函数，负责处理网络设备的数据发送</span></span><br><span class="line"><span class="type">netdev_tx_t</span> <span class="title function_">loopback_netdevice_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev)</span> &#123;</span><br><span class="line">    <span class="comment">// 停止网络设备的发送队列，防止新的数据被发送</span></span><br><span class="line">    netif_stop_queue(dev);</span><br><span class="line">    <span class="comment">// 更新发送的字节数，增加当前skb的长度</span></span><br><span class="line">    bytes += skb-&gt;len;</span><br><span class="line">    <span class="comment">// 更新发送的数据包数，增加1</span></span><br><span class="line">    packets++;</span><br><span class="line">    <span class="comment">// 根据设备类型设置skb的协议类型</span></span><br><span class="line">    skb-&gt;protocol = eth_type_trans(skb, dev);</span><br><span class="line">    <span class="comment">// 将接收到的skb传递给网络设备的接收函数处理</span></span><br><span class="line">    <span class="keyword">if</span> (netif_rx(skb) == NET_RX_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">// 如果接收成功，打印成功信息</span></span><br><span class="line">        printk(<span class="string">&quot;NET_RX_SUCCESS\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒网络设备的发送队列，允许继续发送数据</span></span><br><span class="line">    netif_wake_queue(dev);</span><br><span class="line">    <span class="comment">// 返回发送成功的标志</span></span><br><span class="line">    <span class="keyword">return</span> NETDEV_TX_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义获取网络设备统计信息的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loopback_get_stats64</span><span class="params">(<span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> rtnl_link_stats64 *stats)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置发送的字节数统计信息</span></span><br><span class="line">    stats-&gt;tx_bytes = bytes;</span><br><span class="line">    <span class="comment">// 设置接收的字节数统计信息，这里回环设备发送和接收字节数相同</span></span><br><span class="line">    stats-&gt;rx_bytes = bytes;</span><br><span class="line">    <span class="comment">// 设置发送的数据包数统计信息</span></span><br><span class="line">    stats-&gt;tx_packets = packets;</span><br><span class="line">    <span class="comment">// 设置接收的数据包数统计信息，这里回环设备发送和接收数据包数相同</span></span><br><span class="line">    stats-&gt;rx_packets = packets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义网络设备操作集结构体，包含网络设备的各种操作函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device_ops</span> <span class="title">loopback_ops</span> =</span> &#123;</span><br><span class="line">   .ndo_start_xmit = loopback_netdevice_xmit,</span><br><span class="line">    <span class="comment">// 指向数据发送函数</span></span><br><span class="line">   .ndo_get_stats64 = loopback_get_stats64,</span><br><span class="line">    <span class="comment">// 指向获取统计信息函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义网络设备头部操作集结构体，包含创建网络头部的函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">header_ops</span> <span class="title">loopback_header_ops</span> =</span> &#123;</span><br><span class="line">   .create = eth_header,</span><br><span class="line">    <span class="comment">// 指向创建以太网头部的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义网络设备的设置函数，用于初始化网络设备的属性</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loopback_setup</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置网络设备的最大传输单元（MTU）为64KB</span></span><br><span class="line">    dev-&gt;mtu = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">// 设置网络设备的类型为回环设备</span></span><br><span class="line">    dev-&gt;type = ARPHRD_LOOPBACK;</span><br><span class="line">    <span class="comment">// 设置网络设备的标志，添加回环设备标志</span></span><br><span class="line">    dev-&gt;flags |= IFF_LOOPBACK;</span><br><span class="line">    <span class="comment">// 清除一些特定的私有标志</span></span><br><span class="line">    dev-&gt;priv_flags &amp;= ~(IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM);</span><br><span class="line">    <span class="comment">// 设置网络设备的特性，添加回环特性</span></span><br><span class="line">    dev-&gt;features = NETIF_F_LOOPBACK;</span><br><span class="line">    <span class="comment">// 设置网络设备的头部操作集</span></span><br><span class="line">    dev-&gt;header_ops = &amp;loopback_header_ops;</span><br><span class="line">    <span class="comment">// 设置网络设备的操作集</span></span><br><span class="line">    dev-&gt;netdev_ops = &amp;loopback_ops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义网络设备初始化函数，在网络命名空间初始化时被调用</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">loopback_net_init</span><span class="params">(<span class="keyword">struct</span> net *net)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 分配一个网络设备结构体，指定设备名称格式和初始化函数</span></span><br><span class="line">    virnet_netdevice = alloc_netdev(<span class="number">0</span>, <span class="string">&quot;loopback%d&quot;</span>, NET_NAME_UNKNOWN, loopback_setup);</span><br><span class="line">    <span class="comment">// 将分配的网络设备设置为网络命名空间的回环设备</span></span><br><span class="line">    net-&gt;loopback_dev = virnet_netdevice;</span><br><span class="line">    <span class="comment">// 注册网络设备</span></span><br><span class="line">    ret = register_netdev(virnet_netdevice);</span><br><span class="line">    <span class="comment">// 如果注册失败</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印注册错误信息</span></span><br><span class="line">        printk(<span class="string">&quot;register_netdev error\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 释放分配的网络设备结构体</span></span><br><span class="line">        free_netdev(virnet_netdevice);</span><br><span class="line">        <span class="comment">// 返回错误码</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化成功，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义网络设备退出函数，在网络命名空间退出时被调用</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loopback_net_exit</span><span class="params">(<span class="keyword">struct</span> net *net)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取网络命名空间中的回环设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> net-&gt;loopback_dev;</span><br><span class="line">    <span class="comment">// 注销网络设备</span></span><br><span class="line">    unregister_netdev(dev);</span><br><span class="line">    <span class="comment">// 释放分配的网络设备结构体</span></span><br><span class="line">    free_netdev(virnet_netdevice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义网络命名空间操作结构体，包含网络命名空间初始化和退出函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> <span class="title">loopback_net_ops</span> =</span> &#123;</span><br><span class="line">   .init = loopback_net_init,</span><br><span class="line">    <span class="comment">// 指向网络命名空间初始化函数</span></span><br><span class="line">   .<span class="built_in">exit</span> = loopback_net_exit,</span><br><span class="line">    <span class="comment">// 指向网络命名空间退出函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="移植-RTL8723DU-wifi-驱动"><a href="#移植-RTL8723DU-wifi-驱动" class="headerlink" title="移植 RTL8723DU(wifi)驱动"></a>移植 RTL8723DU(wifi)驱动</h1><p>将厂家提供的代码解压后，解压后修改Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_MULTIDRV = n</span><br><span class="line">CONFIG_RTL8188E = n</span><br><span class="line">CONFIG_RTL8812A = n</span><br><span class="line">CONFIG_RTL8821A = n</span><br><span class="line">CONFIG_RTL8192E = n</span><br><span class="line">CONFIG_RTL8723B = n</span><br><span class="line">CONFIG_RTL8814A = n</span><br><span class="line">CONFIG_RTL8723C = n</span><br><span class="line">CONFIG_RTL8188F = n</span><br><span class="line">CONFIG_RTL8188GTV = n</span><br><span class="line">CONFIG_RTL8822B = n</span><br><span class="line">CONFIG_RTL8723D = y //因为适配的模块是 RTL8723du，所以此选项为 y</span><br><span class="line">CONFIG_RTL8821C = n</span><br><span class="line">CONFIG_RTL8710B = n</span><br><span class="line">CONFIG_RTL8192F = n</span><br><span class="line">CONFIG_RTL8822C = n</span><br><span class="line">CONFIG_RTL8814B = n</span><br><span class="line">CONFIG_RTL8723F = n</span><br><span class="line"><span class="comment">######################### Interface ###########################</span></span><br><span class="line">CONFIG_USB_HCI = y//模块为 usb 接口 设置为 y</span><br><span class="line">CONFIG_PCI_HCI = n</span><br><span class="line">CONFIG_SDIO_HCI = n</span><br><span class="line">CONFIG_GSPI_HCI = n</span><br><span class="line">CONFIG_PLATFORM_I386_PC = n//此选项修改为 n</span><br><span class="line">CONFIG_PLATFORM_ANDROID_X86 = n</span><br><span class="line">CONFIG_PLATFORM_ANDROID_INTEL_X86 = n</span><br><span class="line">CONFIG_PLATFORM_JB_X86 = n</span><br><span class="line">CONFIG_PLATFORM_ARM_S3C2K4 = n</span><br><span class="line">CONFIG_PLATFORM_ARM_PXA2XX = n</span><br><span class="line">CONFIG_PLATFORM_ARM_S3C6K4 = n</span><br><span class="line">CONFIG_PLATFORM_MIPS_RMI = n</span><br><span class="line">CONFIG_PLATFORM_RTD2880B = n</span><br><span class="line">CONFIG_PLATFORM_MIPS_AR9132 = n</span><br><span class="line">CONFIG_PLATFORM_RTK_DMP = n</span><br><span class="line">CONFIG_PLATFORM_MIPS_PLM = n</span><br><span class="line">CONFIG_PLATFORM_MSTAR389 = n</span><br><span class="line">CONFIG_PLATFORM_MT53XX = n</span><br><span class="line">CONFIG_PLATFORM_ARM_MX51_241H = n</span><br><span class="line">CONFIG_PLATFORM_FS_MX61 = n</span><br><span class="line">CONFIG_PLATFORM_ACTIONS_ATJ227X = n</span><br><span class="line">CONFIG_PLATFORM_TEGRA3_CARDHU = n</span><br><span class="line">CONFIG_PLATFORM_TEGRA4_DALMORE = n</span><br><span class="line">CONFIG_PLATFORM_ARM_TCC8900 = n</span><br><span class="line">CONFIG_PLATFORM_ARM_TCC8920 = n</span><br><span class="line">CONFIG_PLATFORM_ARM_TCC8920_JB42 = n</span><br><span class="line">CONFIG_PLATFORM_ARM_TCC8930_JB42 = n</span><br><span class="line">CONFIG_PLATFORM_ARM_RK2818 = n</span><br><span class="line">CONFIG_PLATFORM_ARM_RK3066 = n</span><br><span class="line">CONFIG_PLATFORM_ARM_RK3568 = y //新增此选项设置为 y</span><br><span class="line"></span><br><span class="line">//将下面的 3188 改成 3568</span><br><span class="line">CONFIG_PLATFORM_ARM_RK3188 = nifeq (<span class="variable">$(CONFIG_PLATFORM_ARM_RK3568)</span>, y)</span><br><span class="line">EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN -DCONFIG_PLATFORM_ANDROID</span><br><span class="line">-DCONFIG_PLATFORM_ROCKCHIPS</span><br><span class="line"><span class="comment"># default setting for Power control</span></span><br><span class="line"><span class="comment">#EXTRA_CFLAGS += -DRTW_ENABLE_WIFI_CONTROL_FUNC</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_SDIO_HCI)</span>, y)</span><br><span class="line">EXTRA_CFLAGS += -DRTW_SUPPORT_PLATFORM_SHUTDOWN</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment"># default setting for Special function</span></span><br><span class="line">ARCH := arm64 //修改为 arm64</span><br><span class="line">CROSS_COMPILE :=</span><br><span class="line">/home/topeet/rk356x_linux/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-</span><br><span class="line">gnu/bin/aarch64-linux-gnu-</span><br><span class="line">KSRC := /home/topeet/rk356x_linux/kernel</span><br><span class="line">MODULE_NAME := wlan //模块名称</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p><code>make</code>命令生成<code>wlan.ko</code>文件</p>]]></content>
    
    
    <summary type="html">Linux 网络设备</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Linux ADC</title>
    <link href="https://even629.com/posts/2601143/"/>
    <id>https://even629.com/posts/2601143/</id>
    <published>2026-01-13T13:18:00.000Z</published>
    <updated>2026-01-14T13:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2026-01-14</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="ADC-基础"><a href="#ADC-基础" class="headerlink" title="ADC 基础"></a>ADC 基础</h1><h2 id="模拟信号与数字信号"><a href="#模拟信号与数字信号" class="headerlink" title="模拟信号与数字信号"></a>模拟信号与数字信号</h2><p><strong>模拟信号</strong>是一种连续变化的信号，其值可以在一定范围内取任意值。它在时间上和幅度上都是连续的，能够精确地反映自然界中的物理量变化。例如，温度传感器输出的电压信号、麦克风拾取的声音信号以及光敏电阻检测到的光强信号等，都属于模拟信号的范畴。</p><p><strong>数字信号</strong>是一种离散的信号，其值只能在有限的范围内取特定的数值，通常以二进制形式表示。它的特点是时间上是离散的（采样点之间有固定的时间间隔），幅度上也是离散的（经过量化后的值）。例如，计算机中存储和处理的数据、MP3 文件中的音频数据以及 JPEG 图像文件中的像素值等，都是数字信号的具体体现。</p><table><thead><tr><th align="center">维度</th><th align="center">模拟信号特点</th><th align="center">数字信号特点</th></tr></thead><tbody><tr><td align="center">本质</td><td align="center">连续变化、取值任意</td><td align="center">离散取值、常以二进制表示</td></tr><tr><td align="center">特性</td><td align="center">时间 + 幅度均连续</td><td align="center">时间（采样间隔）+ 幅度（量化值）均离散</td></tr><tr><td align="center">优势</td><td align="center">精准反映自然物理量变化</td><td align="center">易存储 &#x2F; 传输 &#x2F; 处理、抗干扰能力强</td></tr><tr><td align="center">典型场景</td><td align="center">传感器原始信号、自然声光电信号</td><td align="center">计算机数据、数字音视频文件</td></tr></tbody></table><h2 id="ADC-概念"><a href="#ADC-概念" class="headerlink" title="ADC 概念"></a>ADC 概念</h2><p>ADC 是 <strong>Analog-to-Digital Converter</strong> 的缩写，可以翻译为<strong>模数转换器</strong>。它是一种电子设备或电路模块，用于<strong>将连续变化的模拟信号（如电压、电流等）转换为离散的数字信号</strong>。这些数字信号可以被计算机、微控制器或其他数字系统处理和存储。</p><p>ADC 将模拟信号转换为数字信号通常分为<strong>采样</strong>、<strong>保持</strong>、<strong>量化</strong>以及<strong>编码</strong>四个步骤，每个步骤的定义以及作用如下表所示：</p><table><thead><tr><th align="center">步骤</th><th align="center">定义</th><th align="center">作用</th><th align="center">关键参数或特点</th></tr></thead><tbody><tr><td align="center">采样（Sampling）</td><td align="center">以固定的时间间隔对模拟信号进行测量的过程。</td><td align="center">将时间上连续的模拟信号离散化，为后续数字化处理奠定基础。</td><td align="center">采样频率（Sampling Rate），即每秒采样的次数。根据奈奎斯特采样定理，采样频率至少是信号最高频率的两倍。</td></tr><tr><td align="center">保持（Holding）</td><td align="center">在采样完成后，将信号的瞬时值保持一段时间以便后续处理。</td><td align="center">确保信号在量化过程中不会因快速变化而失真，提高转换的精度和稳定性。</td><td align="center">无明确参数，主要目的是稳定信号。</td></tr><tr><td align="center">量化（Quantization）</td><td align="center">将采样得到的连续幅值映射到一组离散数值上的过程。</td><td align="center">将幅度上连续的信号离散化，使其能够被数字系统表示。</td><td align="center">分辨率（Resolution），通常用位数表示（如 8 位、10 位、12 位等）。分辨率越高，信号越精确。</td></tr><tr><td align="center">编码（Encoding）</td><td align="center">将量化后的数值转换为二进制代码的过程。</td><td align="center">将离散的数值以数字系统可识别的形式表示出来，便于存储、传输和处理，使模拟信号能被计算机或其他数字设备使用。</td><td align="center">无明确参数，重点是生成适合数字系统使用的二进制代码。</td></tr></tbody></table><p>ADC 广泛应用于传感器信号采集、音频处理、图像处理、工业自动化以及医疗设备中：</p><ol><li>传感器信号采集：许多传感器输出的是模拟信号。例如，温度传感器、压力传感器、光敏传感器等采集到的环境数据通常以模拟信号形式存在。</li><li>音频处理：麦克风拾取的声音信号是模拟信号。</li><li>图像处理：摄像头捕捉的光信号本质上是模拟信号。</li><li>工业自动化：各种物理量（如速度、位置、压力等）的测量通常依赖于传感器输出的模拟信号。</li><li>医疗设备：许多生物信号（如心电图、脑电图等）是以模拟信号形式采集的。</li></ol><h2 id="ADC分辨率"><a href="#ADC分辨率" class="headerlink" title="ADC分辨率"></a>ADC分辨率</h2><p>ADC 的分辨率是指模数转换器能够区分的最小信号变化的能力。换句话说，它是 ADC 将模拟信号量化为离散数字值时的精细程度。在 ADC 中，分辨率越高，意味着它可以更精确地表示输入的模拟信号。当我们将数字信号通过 DAC（数模转换器）还原为模拟信号时，高分辨率的 ADC 能够生成更接近原始模拟信号的结果。</p><p>ADC 的分辨率通常用位数来表示，例如 8 位、10 位、12 位等。位数决定了 ADC 能够输出的离散数值的数量，n 位 ADC 可以表示 2^n 个不同的数值。例如，8 位 ADC 可以表示 2^8&#x3D;256 个不同的数值；10 位 ADC 可以表示 2^10&#x3D; 1024 个不同的数值；12 位 ADC 可以表示 2^12&#x3D; 4096 个不同的数值。位数越高，分辨率越高，能够区分的信号变化越小。</p><p>分辨率可以通过以下公式计算：<br>$$<br>\text{分辨率} &#x3D; \dfrac{\text{量程}}{2^n}<br>$$</p><p>其中：</p><ol><li>量程是指 ADC 输入信号的最大范围（即参考电压范围）；</li><li>n 是 ADC 的位数；</li><li>2^n 表示 ADC 能够区分的离散数值总数。</li></ol><p>例子：假设一个 3 位 ADC 的参考电压（量程）为 2V，计算他的分辨率：</p><ol><li>量程 &#x3D; 2V</li><li>位数为 3，2^n &#x3D; 2^3 &#x3D; 8；</li></ol><p>代入分辨率计算公式可得 2V&#x2F;8&#x3D; 0.25V。这意味着该 ADC 能够将输入信号分成 8 个离散的等级，每个等级之间的步长为 0.25V。</p><p>除了分辨率，ADC的其他参数如下</p><table><thead><tr><th align="center">参数</th><th align="center">定义</th><th align="center">作用或意义</th></tr></thead><tbody><tr><td align="center"><strong>采样时间（Sampling Time）</strong></td><td align="center">完成一次采样所需的时间。</td><td align="center">决定了 ADC 能够以多快的速度捕获输入信号的变化。如果采样时间过长，可能会导致信号失真或丢失细节。</td></tr><tr><td align="center"><strong>转换时间（Conversion Time）</strong></td><td align="center">将模拟信号转换为数字信号所需的时间。</td><td align="center">直接影响 ADC 的速度和效率。较短的转换时间意味着 ADC 可以更快地处理信号。</td></tr><tr><td align="center"><strong>采样频率（Sampling Frequency）</strong></td><td align="center">每秒采集样本的次数，常用单位为 ksps（千次 &#x2F; 秒）或 Msps（百万次 &#x2F; 秒）。</td><td align="center">决定了 ADC 对信号变化的捕捉能力。根据奈奎斯特采样定理，采样频率必须至少是信号最高频率的两倍，才能准确还原信号。</td></tr><tr><td align="center"><strong>精度（Accuracy）</strong></td><td align="center">ADC 输出的数字值与实际模拟输入值之间的误差。</td><td align="center">反映了 ADC 的可靠性和测量质量，是衡量其性能的重要指标。</td></tr></tbody></table><h2 id="RK3568-ADC"><a href="#RK3568-ADC" class="headerlink" title="RK3568 ADC"></a>RK3568 ADC</h2><p>在 RK3568 数据手册中的外设资源框图中可以找到，RK3568 这颗 SOC 总共有 <strong>8 路 SARADC</strong>。</p><p><strong>SARADC</strong> （<strong>Successive Approximation Register Analog-to-Digital Converter</strong>）的中文名称为<strong>逐次逼近型 ADC</strong>；</p><p>除了 SAR ADC 之外，还有两路 TS-ADC（Temperature Sensor ADC），他们分别用来检测 CPU 和 GPU 的温度，如果在一段时间内检测到温度过高，则会向处理器发出中断信号以采取降温措施；如果温度持续过高，将复位整个芯片，达到重启的效果。TS-ADC 只负责检测 CPU 和 GPU 的温度所以并未在底板引出。</p><h3 id="ADC-按键"><a href="#ADC-按键" class="headerlink" title="ADC 按键"></a>ADC 按键</h3><p>ADC 按键 是 SARADC 外设，ADC 按键的工作原理是<strong>将多个按键连接到同一个 ADC 引脚上，并通过不同的分压电阻产生不同的电压，通过 ADC 测量该电压，并与预设的电压范围进行比对，从而判断哪个按键被按下</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114211859056.png" alt="Key Array" loading="lazy"></p><blockquote><p>有两路 ADC 分别被用在了 HW_ID 和 BOM_ID 上，用于不同电子设备的硬件识别，但由于topeet的外设都是通用的，所以这两路 ADC 并没有被用到。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114211859110.png" alt="HW_ID" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114211859171.png" alt="BOM_ID" loading="lazy"></p><p>有 4 路 ADC 被连接到了 6pin 的座子上，原理图如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114211859223.png" alt="SARADC" loading="lazy"></p><p>总结如下</p><table><thead><tr><th align="center">ADC 接口</th><th align="center">复用功能</th></tr></thead><tbody><tr><td align="center">SARADC VIN0</td><td align="center">用作按键引脚（音量 +，音量 -，HOME，BACK）</td></tr><tr><td align="center">SARADC VIN1</td><td align="center">用作 HW ID 引脚</td></tr><tr><td align="center">SARADC VIN2</td><td align="center">未使用</td></tr><tr><td align="center">SARADC VIN3</td><td align="center">用作 BOM ID 引脚</td></tr><tr><td align="center">SARADC VIN4</td><td align="center">未使用</td></tr><tr><td align="center">SARADC VIN5</td><td align="center">未使用</td></tr><tr><td align="center">SARADC VIN6</td><td align="center">未使用</td></tr><tr><td align="center">SARADC VIN7</td><td align="center">未使用</td></tr></tbody></table><h3 id="逐次逼近型-ADC"><a href="#逐次逼近型-ADC" class="headerlink" title="逐次逼近型 ADC"></a>逐次逼近型 ADC</h3><p>逐次逼近型 ADC（<strong>Successive Approximation Register ADC</strong>，简称 SAR ADC）是一种常见的模数转换器，其工作原理基于逐次逼近算法。它通过逐步比较输入模拟信号与内部生成的参考电压，最终确定一个接近输入信号的数字值。SAR ADC 工作原理示意图如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114211859277.png" alt="SAR ADC" loading="lazy"></p><p>由上图可知逼近寄存器型模数转换器（SAR ADC）主要由以下几个部分组成：</p><ol><li><strong>比较器（Comparator）</strong>：用于比较输入模拟信号 U1 和 D&#x2F;A 转换器（DAC）输出的参考电压 U0，并产生反馈信号。</li><li><strong>N 位 D&#x2F;A 转换器（DAC）</strong>：将数字值转换为模拟电压，与输入信号进行比较，以逐步逼近目标值。</li><li><strong>N 位逐次逼近寄存器（SAR）</strong>：用于存储当前的比较结果，并根据比较器的反馈调整数值，最终确定数字输出。</li><li><strong>置数选择逻辑</strong>：控制逐次逼近寄存器的位选择过程，按二分法调整 DAC 的输出电压。</li></ol><p>工作过程：</p><ol><li>首先，模拟输入信号 U1 进入 ADC，并由采样电路暂存，以便进行后续处理。</li><li>随后，逐次逼近寄存器（SAR）初始化，并通过置数选择逻辑电路的控制，按照二分法逐步确定最终的数字输出值。</li></ol><blockquote><p>在转换过程中，SAR 从最高位开始假设为 1，并将当前的 N 位数字值传递给 D&#x2F;A 转换器。DAC 将其转换为模拟电压 U0，然后送入比较器，与输入信号 U1 进行比较。如果 U0 小于 U1，当前位保持 1；否则，当前位改为 0。这个过程不断重复，每次确定一位，直到所有 N 位都完成，形成最终的数字输出。</p></blockquote><ol start="3"><li>最终，SAR 将确定的 N 位数字值输出，完成一次模数转换。</li></ol><p>举例如下：</p><p><strong>5 位逐次逼近型 ADC 在参考电压为 32mV、待测电压为 21.5mV 的情况</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114211859311.png" alt="5 位逐次逼近型 ADC 在参考电压为 32mV、待测电压为 21.5mV 的情况" loading="lazy"></p><ol><li>设置最高位：SAR 寄存器将最高位（第 5 位）设置为“1”，其余位为“0”，当前 SAR 值为 10000（二进制），即 16（十进制）。DAC 根据 SAR 值生成参考电压 U0&#x3D;16×1mV&#x3D;16 mV。比较器比较 U1&#x3D;21.5 mV,V_0 &#x3D;16，由于 U1&gt;U0，因此保留当前位为“1”。</li><li>设置次高位：SAR 寄存器保持最高位为“1”，并将次高位（第 4 位）设置为“1”，此时 SAR 值为 11000（二进制），即 24（十进制）。DAC 生成参考电压 U0&#x3D;24×1 mV&#x3D;24 mV。比较器比较 U1&#x3D;21.5 m 和 U0&#x3D;24 mV，由于 U1&lt;U0，因此将当前位重置为“0”。</li><li>设置第三位：SAR 寄存器保持前两位为“10”，并将第三位（第 3 位）设置为“1”，此时 SAR 值为 10100（二进制），即 20（十进制）。DAC 生成参考电压 U0&#x3D;20×1 mV&#x3D;20 mV。比较器比较 U1&#x3D;21.5 mV 和 U0&#x3D;20 mV，由于 U1&gt;U0，因此保留当前位为“1”。</li><li>设置第四位：SAR 寄存器保持前三位为“101”，并将第四位（第 2 位）设置为“1”，此时 SAR 值为 10110（二进制），即 22（十进制）。DAC 生成参考电压 U0&#x3D;22×1 mV&#x3D;22 mV。比较器比较 U1&#x3D;21.5 mV 和 U0&#x3D;22 mV，由于 U1&lt;U0，因此将当前位重置为“0”。</li><li>设置最低位：SAR 寄存器保持前四位为“1010”，并将最低位（第 1 位）设置为“1”，此时 SAR 值为 10101（二进制），即 21（十进制）。DAC 生成参考电压 U0&#x3D;21×1 mV&#x3D;21 mV。比较器比较 U1&#x3D;21.5 mV 和 U0&#x3D;21 mV，由于 U1&gt;U0，因此保留当前位为“1”。</li><li>结果：经过逐次逼近后，SAR 寄存器的值为 10101（二进制），即 21（十进制）。</li></ol><h1 id="操作-ADC"><a href="#操作-ADC" class="headerlink" title="操作 ADC"></a>操作 ADC</h1><p>进入到<code>/sys/bus/iio/devices/iio:device0</code> 目录下</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114211859380.png" alt="&#x2F;sys&#x2F;bus&#x2F;iio&#x2F;devices&#x2F;iio:device0" loading="lazy"></p><p>需要注意的是 <code>in_voltageX_raw</code> 和 <code>in_voltage_scale</code>。</p><ul><li><code>in_voltageX_raw</code> <strong>表示 ADC 某个通道的原始采样值</strong>，其中 X 是通道编号（如 0, 1, 2, …, 7）。它以整数形式存储 ADC 转换后的数字代码，用户可以通过读取该文件获取对应通道的未经缩放的原始数据。需要注意的是，这些值并未经过量程缩放，必须结合<code>in_voltage_scale</code> 进行计算才能得到实际电压值。</li><li><code>in_voltage_scale</code> 是用于<strong>将 ADC 原始采样值转换为实际电压值的缩放因子</strong>，通常定义为 1.8&#x2F;1024。它以浮点数形式表示，单位可以是毫伏（mV）或伏特（V），具体取决于硬件实现。通过<strong>将 <code>in_voltageX_raw</code> 的原始值乘以<code>in_voltage_scale</code>，即可得到对应通道的实际电压值</strong>，从而实现从数字代码到物理量的转换</li></ul><p>这里以 ADC 的通道 7 为例进行演示，对应的硬件为底板的 J24 的第 5 脚，具体如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114211859223.png" alt="SARADC" loading="lazy"></p><p>DC 的通道 7 对应的原始采样值为 <code>in_voltage7_raw</code>，使用 cat 命令进行读取，读取到的值如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> involtage7_raw</span><br><span class="line">1017</span><br></pre></td></tr></table></figure><p>这里读取到的是未经缩放的原始数据，然后继续使用cat命令读取缩放因子 <code>in_voltage_scale</code> 的值，具体如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> in_voltage_scale</span><br><span class="line">1.757812500</span><br></pre></td></tr></table></figure><p>然后将获取到的原始采样值与缩放因子相乘即可得到实际电压值 1017x1.757812500&#x3D;1787.6953125 mv&#x3D;1.787 V</p><p>而除了上面的 SAR ADC 之外，还有着两路 TSADC，他们分别用来查询 CPU 和 GPU 的温度，</p><p>查看 CPU 的温度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/thermal/thermal_zone0/temp</span><br></pre></td></tr></table></figure><p>查看 GPU 的温度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/thermal/thermal_zone1/temp</span><br></pre></td></tr></table></figure><h1 id="ADC-驱动程序"><a href="#ADC-驱动程序" class="headerlink" title="ADC 驱动程序"></a>ADC 驱动程序</h1><p>编写一个 ADC 驱动程序，通过杂项设备创建一个 ADC 设备节点，通过该节点来读取对应通道的 ADC 值。</p><h2 id="API-函数"><a href="#API-函数" class="headerlink" title="API 函数"></a>API 函数</h2><h3 id="iio-channel-get"><a href="#iio-channel-get" class="headerlink" title="iio_channel_get()"></a>iio_channel_get()</h3><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> iio_channel *<span class="title function_">iio_channel_get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *channel_name)</span>;</span><br></pre></td></tr></table></figure><p><strong>核心作用</strong></p><p>从 Linux IIO 子系统中，根据「IIO 设备名」和「通道名」，获取一个对应的 <code>struct iio_channel</code> 通道结构体指针，后续所有对该 ADC 通道的操作都依赖这个指针。</p><p><strong>参数说明</strong></p><ul><li><code>name</code>：指定要操作的 <strong>IIO 设备名称 &#x2F; ID</strong>，如果传 <code>NULL</code> 表示使用系统默认的 IIO 设备；SARADC 场景常用 <code>NULL</code> </li><li><code>channel_name</code>：指定要打开的 ADC 通道名称，具体名称要和内核驱动匹配。</li></ul><p><strong>返回值</strong></p><ul><li>✅ 成功：返回有效的 <code>struct iio_channel *</code> 结构体指针（通道句柄）；</li><li>❌ 失败：返回内核错误指针 <code>ERR_PTR(错误码)</code>，不能直接作为正常指针使用。</li></ul><h3 id="iio-channel-release"><a href="#iio-channel-release" class="headerlink" title="iio_channel_release()"></a>iio_channel_release()</h3><p>获取的通道句柄<strong>用完必须释放</strong>，否则造成内核资源泄漏，释放函数固定搭配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">iio_channel_release</span><span class="params">(<span class="keyword">struct</span> iio_channel *channel)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：就是 <code>iio_channel_get</code> 获取到的通道指针</li><li>特性：无返回值，安全调用即可。</li></ul><h3 id="struct-iio-channel"><a href="#struct-iio-channel" class="headerlink" title="struct iio_channel"></a>struct iio_channel</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">iio_channel</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iio_device</span> *indio_dev;  <span class="comment">// 当前通道绑定的IIO设备（如SARADC设备）</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *channel_name;      <span class="comment">// 通道名称，和入参channel_name一致</span></span><br><span class="line">    <span class="type">int</span> channel_index;             <span class="comment">// 通道索引，比如VIN0对应0，VIN3对应3</span></span><br><span class="line">    <span class="type">bool</span> is_output;                <span class="comment">// 是否为输出通道，ADC是「输入通道」固定为false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="iio-read-channel-raw"><a href="#iio-read-channel-raw" class="headerlink" title="iio_read_channel_raw()"></a>iio_read_channel_raw()</h3><p><strong>函数原型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">iio_read_channel_raw</span><span class="params">(<span class="keyword">struct</span> iio_channel *channel, <span class="type">int</span> *val)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>核心作用</strong></p><p>从已经打开的 IIO 通道（ADC 通道）中，读取<strong>未经任何校准 &#x2F; 换算的原始整型数据</strong>，是 ADC 数据读取的核心函数。</p><blockquote><p>✔️ 你的 SARADC 场景：读取到的 <code>val</code> 就是 ADC 引脚采集到的电压对应的<strong>原始数字量</strong>（比如 10 位 ADC 就是 0~1023 的数值）。</p></blockquote><p><strong>参数说明</strong></p><ul><li><code>channel</code>：输入参数，<code>iio_channel_get</code> 成功返回的通道句柄，<strong>必须是有效指针</strong>；</li><li><code>val</code>：输出参数，一个整型指针，函数执行成功后，采集到的 ADC 原始数据会被写入该地址指向的变量中。</li></ul><p><strong>返回值</strong></p><ul><li>✅ 成功：返回 <code>0</code>；</li><li>❌ 失败：返回<strong>负数的内核错误码</strong>（如 -EINVAL 无效参数、-ENODEV 设备不存在等）。</li></ul><p><strong>关键注意点</strong></p><p>读取到的 <code>val</code> 是 <strong>原始裸数据</strong>：</p><ul><li>无单位、无校准、无换算，只是 ADC 模数转换后的纯数字值；</li><li>数值范围由 ADC 位数决定（比如 8 位 ADC：0<del>255；10 位 ADC：0</del>1023；12 位 ADC：0~4095）；</li><li>如果需要换算成实际的电压值，需要自己写公式：<code>实际电压 = (原始值 / ADC最大量程) * ADC参考电压</code>。</li></ul><hr><p><strong>内核驱动中标准写法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：定义变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_channel</span> *<span class="title">adc_channel</span>;</span></span><br><span class="line"><span class="type">int</span> adc_raw_data;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：获取ADC通道句柄 (示例：打开SARADC的VIN0通道)</span></span><br><span class="line">adc_channel = iio_channel_get(<span class="literal">NULL</span>, <span class="string">&quot;vin0&quot;</span>);</span><br><span class="line"><span class="comment">// 步骤3：判断通道获取是否成功</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(adc_channel)) &#123;</span><br><span class="line">    ret = PTR_ERR(adc_channel); <span class="comment">// 提取错误码</span></span><br><span class="line">    printk(<span class="string">&quot;获取ADC通道失败: %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤4：读取ADC原始数据</span></span><br><span class="line">ret = iio_read_channel_raw(adc_channel, &amp;adc_raw_data);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    printk(<span class="string">&quot;读取ADC数据失败: %d\n&quot;</span>, ret);</span><br><span class="line">    iio_channel_release(adc_channel); <span class="comment">// 失败也要释放资源！</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;ADC原始采集值：%d\n&quot;</span>, adc_raw_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤5：使用完通道，必须释放资源</span></span><br><span class="line">iio_channel_release(adc_channel);</span><br></pre></td></tr></table></figure><h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><p>添加设备节点：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">adc7:</span> <span class="title class_">adc-test</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;myadc&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">io-channels</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;saradc</span> <span class="number">7</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>重点在 io-channels，意味要使用的是 ADC 的第 7 个通道</p><h2 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/iio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span>  <span class="comment">// 添加对设备树的支持</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_READ_SCALE _IOR(<span class="string">&#x27;A&#x27;</span>, 0x1, int)  <span class="comment">// 定义 ioctl 命令</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_channel</span> *<span class="title">adc_chan</span>;</span>  <span class="comment">// IIO 通道指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件操作：ioctl 实现</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">adc_dev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> scale = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> CMD_READ_SCALE:</span><br><span class="line">            <span class="comment">// 从 ADC 通道读取原始值</span></span><br><span class="line">            <span class="keyword">if</span> (iio_read_channel_raw(adc_chan, &amp;scale) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;Failed to read ADC channel raw value\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EIO;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将数据复制到用户空间</span></span><br><span class="line">            <span class="keyword">if</span> (copy_to_user((<span class="type">int</span> *)arg, &amp;scale, <span class="keyword">sizeof</span>(scale))) &#123;</span><br><span class="line">                pr_err(<span class="string">&quot;Failed to copy data to user space\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            pr_err(<span class="string">&quot;Invalid ioctl command\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件操作结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">adc_dev_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .unlocked_ioctl = adc_dev_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 杂项设备结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">adc_dev</span> =</span> &#123;</span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,  <span class="comment">// 动态分配次设备号</span></span><br><span class="line">    .name = <span class="string">&quot;adc&quot;</span>,                <span class="comment">// 设备名称</span></span><br><span class="line">    .fops = &amp;adc_dev_fops,        <span class="comment">// 文件操作接口</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备树匹配表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">adc_driver_match</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;myadc&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, adc_driver_match);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备探测函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adc_driver_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 IIO 通道</span></span><br><span class="line">    adc_chan = iio_channel_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(adc_chan)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to get IIO channel\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(adc_chan);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册杂项设备</span></span><br><span class="line">    <span class="keyword">if</span> (misc_register(&amp;adc_dev)) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to register misc device\n&quot;</span>);</span><br><span class="line">        iio_channel_release(adc_chan);  <span class="comment">// 释放 IIO 通道</span></span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;ADC driver probed successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adc_driver_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="comment">// 注销杂项设备</span></span><br><span class="line">    misc_deregister(&amp;adc_dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 IIO 通道</span></span><br><span class="line">    iio_channel_release(adc_chan);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;ADC driver removed successfully\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">adc_driver</span> =</span> &#123;</span><br><span class="line">    .probe = adc_driver_probe,</span><br><span class="line">    .remove = adc_driver_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;myadc&quot;</span>,  <span class="comment">// 驱动名称</span></span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .of_match_table = adc_driver_match,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">adc_driver_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台设备驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;adc_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Failed to register platform driver\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;ADC driver module loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">adc_driver_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注销平台设备驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;adc_driver);</span><br><span class="line"></span><br><span class="line">    pr_info(<span class="string">&quot;ADC driver module unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(adc_driver_init);</span><br><span class="line">module_exit(adc_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/ioctl.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define CMD_READ_SCALE _IOR(&#x27;A&#x27;, 1, int)</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    int scale = 0;</span><br><span class="line">    int fd;</span><br><span class="line"><span class="built_in">float</span> value = 0.0;      // 用于存储计算后的实际电压值</span><br><span class="line"></span><br><span class="line">    // 打开设备文件</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/adc&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 使用 ioctl 读取 scale 值</span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, CMD_READ_SCALE, &amp;scale) &lt; 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl error\n&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">value = (1.8 / 1024) * (<span class="built_in">float</span>)scale;</span><br><span class="line"></span><br><span class="line">    // 打印读取到的 scale 值</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;val is %lf\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    // 关闭设备文件</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux ADC</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Linux CAN</title>
    <link href="https://even629.com/posts/2601093/"/>
    <id>https://even629.com/posts/2601093/</id>
    <published>2026-01-09T07:56:00.000Z</published>
    <updated>2026-01-09T07:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2026-01-09</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="CAN-总线介绍"><a href="#CAN-总线介绍" class="headerlink" title="CAN 总线介绍"></a>CAN 总线介绍</h1><p><strong>CAN</strong>（Controller Area Network）是由博世（Bosch）公司于 1986 年推出的串行通信协议，专为汽车电子系统设计，旨在减少车辆中线束数量，实现多个电子控制单元（ECU）之间的高效通信。</p><p><strong>核心特点</strong></p><ul><li>CAN 总线支持多主通信，所有节点（ECU）均可主动发送数据，无需依赖中心控制器。</li><li>其采用非破坏性仲裁机制，通过 ID 优先级解决总线冲突，确保高优先级数据优先传输。</li><li>总线具备高可靠性，内置 CRC 校验、错误检测与恢复机制，同时采用差分信号增强抗电磁干扰能力。</li><li>CAN 总线通过简化布线和降低系统复杂度，实现了低成本的优势。</li></ul><p><strong>应用领域</strong></p><ul><li>汽车电子：发动机控制、车身模块（灯光&#x2F;门窗）、诊断系统（OBD-II）等。</li><li>工业自动化：PLC、传感器网络、机器人控制。</li><li>其他领域：医疗设备、航空航天、智能楼宇。</li></ul><p><strong>发展历程</strong></p><ul><li>1983 年：Bosch 启动汽车网络技术研究。</li><li>1986 年：正式发布 CAN 协议。</li><li>1987 年：英特尔与飞利浦推出首款 CAN 控制器芯片。</li><li>1991 年：CAN 2.0 规范发布，首次应用于奔驰 S 级轿车。</li><li>1993 年：成为国际标准（ISO 11898）。</li><li>2015 年：CAN FD（Flexible Data Rate）标准化（支持更高速率与 64 字节数据）</li><li>2020 年：下一代 CAN XL 发布，带宽进一步提升。</li></ul><h2 id="CAN-硬件连接"><a href="#CAN-硬件连接" class="headerlink" title="CAN 硬件连接"></a>CAN 硬件连接</h2><p>在 CAN 硬件连接中，有 CPU 自带 CAN 控制器和 CPU 没有 CAN 控制器需外设转接（如 SPI转 CAN）这两种情况</p><h3 id="CPU-自带-CAN-控制器"><a href="#CPU-自带-CAN-控制器" class="headerlink" title="CPU 自带 CAN 控制器"></a>CPU 自带 CAN 控制器</h3><p>CPU 自带 CAN 控制器连接图如下所示，CPU 通过集成的 CAN 控制器直接与 CAN 收发器进行通信，CAN 收发器负责将数字信号转换为适合 CAN 总线传输的差分信号（CAN_H 和 CAN_L）。<strong>CPU 可以直接与 CAN 总线进行通信</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155708706.png" alt="CPU自带CAN控制器" loading="lazy"></p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td><strong>CPU与CAN控制器</strong></td><td>每个CPU都通过CAN控制器与CAN总线通信。CPU负责处理控制逻辑和数据处理任务，而CAN控制器则负责管理CAN协议的通信细节。</td></tr><tr><td><strong>CAN Tx</strong></td><td>发送数据的信号线。CPU通过CAN控制器将数据发送到CAN总线上，该信号线用于传输发送的数据。</td></tr><tr><td><strong>CAN Rx</strong></td><td>接收数据的信号线。CPU通过CAN控制器从CAN总线接收数据，该信号线用于接收来自总线的数据。</td></tr><tr><td><strong>CAN收发器</strong></td><td>CAN收发器连接在CPU的CAN控制器和CAN总线之间，其主要作用是：<br />将CPU输出的数字信号转换为适合在CAN总线上传输的差分电平信号（电平转换）；<br />同时将总线上的差分信号转换回CPU可识别的数字信号。</td></tr><tr><td><strong>CAN H 和 CAN L</strong></td><td>这是CAN总线的两条主要物理信号线：<br />CAN H：用于传输高电平信号； <br />CAN L：用于传输低电平信号。 <br />通过这两条线之间的电压差来实现数据传输（差分信号），提高了抗干扰能力。</td></tr><tr><td><strong>120Ω 电阻</strong></td><td>在CAN总线的两端各接一个120Ω的终端电阻，目的是： • 防止信号在总线末端发生反射（阻抗匹配）； • 保证信号完整性，提高通信稳定性。 尤其在长距离或多个设备连接的情况下，这些终端电阻非常重要。</td></tr></tbody></table><h3 id="CPU-没有-CAN-控制器"><a href="#CPU-没有-CAN-控制器" class="headerlink" title="CPU 没有 CAN 控制器"></a>CPU 没有 CAN 控制器</h3><p>CPU 没有 CAN 控制器的连接示意图如下所示，<strong>CPU 通过 SPI 控制器与 SPI 转 CAN 模块进行通信</strong>，后者将 SPI 数据转换为 CAN 总线所需的格式。</p><p>通过这种结构，CPU 可以通过 SPI 协议与CAN 总线进行通信，适用于需要在没有直接 CAN 控制器的情况下与 CAN 网络连接的应用场景。总线两端的终端电阻确保了 CAN 通信的稳定性。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155709501.png" alt="CPU内部没有CAN控制器" loading="lazy"></p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td><strong>CPU与SPI控制器</strong></td><td>CPU 通过 SPI 控制器与 SPI 接口的外围设备通信。SPI（Serial Peripheral Interface）是一种同步串行通信协议，常用于微控制器与传感器、存储器等外设之间的高速数据交换。</td></tr><tr><td><strong>SPI到CAN转换器</strong></td><td>这是一个关键的桥接模块，连接在 SPI 控制器和 CAN 总线之间。 它的作用是：将 SPI 协议的数据格式转换为 CAN 协议格式，使得原本只能使用 SPI 通信的设备能够通过 CAN 总线与其他节点通信。</td></tr><tr><td><strong>CAN Tx</strong></td><td>发送数据的信号线，用于将从 SPI 转 CAN 模块接收到的数据发送到 CAN 总线上。</td></tr><tr><td><strong>CAN Rx</strong></td><td>接收数据的信号线，用于从 CAN 总线接收数据，并将其传送给 SPI 转 CAN 模块进行处理。</td></tr><tr><td><strong>CAN收发器</strong></td><td>连接在 CAN 总线和 SPI 转 CAN 模块之间，负责：<br />将逻辑电平信号（来自转换器）转换为适合 CAN 总线传输的差分信号； <br />同时将总线上的差分信号还原为逻辑电平信号传回模块。</td></tr><tr><td><strong>CAN H 和 CAN L</strong></td><td>CAN 总线的两条差分信号线： <br />CAN H：高电平信号线； <br />CAN L：低电平信号线。 通过两者之间的电压差来传输数据，具有较强的抗干扰能力。</td></tr><tr><td><strong>120Ω 电阻</strong></td><td>在 CAN 总线两端各接入一个 120Ω 的终端电阻，目的是： <br />阻抗匹配，防止信号反射； <br />提高通信稳定性，尤其是在长距离或多个节点连接的情况下。</td></tr></tbody></table><h2 id="CAN-电器属性"><a href="#CAN-电器属性" class="headerlink" title="CAN 电器属性"></a>CAN 电器属性</h2><p><strong>CAN 总线使用差分信号传输数据。</strong></p><ol><li><strong>CAN 信号电平</strong></li></ol><p>CAN 总线使用两条信号线进行数据传输：CAN_H（高电平）和 CAN_L（低电平）。</p><p>CAN_H和 CAN_L 之间的电压差异决定了逻辑信号的状态。这使得 CAN 总线具有更好的抗干扰能力，尤其适合在噪声较大的环境中工作。</p><ul><li><strong>CAN_H：高电平信号线，通常电压范围为 2.5V 至 3.5V。</strong></li><li><strong>CAN_L：低电平信号线，通常电压范围为 1.5V 至 2.5V。</strong></li></ul><ol start="2"><li><strong>差分信号和抗干扰</strong></li></ol><p>CAN 总线通过差分信号进行数据传输，这意味着信息的传输依赖于 CAN_H 与 CAN_L 之间的电压差，而不是单独的电压值。差分信号的特性使得 CAN 总线在噪声环境中具有极强的抗干扰能力。</p><p><strong>差分信号的优点</strong>：</p><ol><li>噪声通常同时影响 CAN_H 和 CAN_L，但由于差分信号依赖于两者的电压差，<strong>噪声对两者的影响会相互抵消</strong>，从而保持信号的完整性。</li><li>这种特性使得 CAN 总线在汽车、工业控制等噪声较大的环境中表现出色。</li></ol><h3 id="电气属性和工作状态"><a href="#电气属性和工作状态" class="headerlink" title="电气属性和工作状态"></a>电气属性和工作状态</h3><p>CAN 总线的电气属性决定了其工作状态，具体表现为隐性状态和显性状态。</p><ul><li><strong>隐性状态（逻辑”1”）</strong>：<u>当 CAN_H 与 CAN_L 的电压相等（通常为 2.5V）</u>，表示<strong>总线处于空闲状态</strong>。此时，总线没有数据传输，所有设备都在等待通信。隐性状态也被称为“空闲电平”或“逻辑 1”。</li><li><strong>显性状态（逻辑”0”）</strong>：<u>当 CAN_H 与 CAN_L 的电压差为 2V 时</u>，表示<strong>数据正在传输</strong>。具体来说，CAN_H 为 3.5V，CAN_L 为 1.5V，表示逻辑“0”。显性状态表示总线正在传输数据，且<strong>具有较高的优先级</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155713825.png" alt="隐性电平与显性电平" loading="lazy"></p><h2 id="iTOP-RK3568-开发板-can-接口"><a href="#iTOP-RK3568-开发板-can-接口" class="headerlink" title="iTOP-RK3568 开发板 can 接口"></a>iTOP-RK3568 开发板 can 接口</h2><p>RK3568 这颗 SOC 至多可以使用 3 个 CAN 接口</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155716182.png" alt="CAN1" loading="lazy"></p><p>其中 <strong>TJA1040T</strong> 是一款由恩智浦（NXP）公司生产的高速 CAN 收发器芯片。负责将 CPU 的数字信号转换为适合 CAN 总线传输的信号并且接收总线上的数据，而根据网络标号可以得到开发板使用的是 CAN1</p><table><thead><tr><th>CAN接口</th><th>pinctrl function</th><th>网络标号</th><th>对应的GPIO</th><th>功能</th></tr></thead><tbody><tr><td>CAN0</td><td>CAN0_TX_M0</td><td>I2C1_SCL_TP</td><td>GPIO0_B3_u</td><td>MIPI屏幕触摸I2C</td></tr><tr><td></td><td>CAN0_RX_M0</td><td>I2C1_SDA_TP</td><td>GPIO0_B4_u</td><td>MIPI屏幕触摸I2C</td></tr><tr><td></td><td>CAN0_TX_M1</td><td>SDMMC0_CMD</td><td>GPIO2_A1</td><td>TF卡 CMD引脚</td></tr><tr><td></td><td>CAN0_RX_M1</td><td>SDMMC0_CLK</td><td>GPIO2_A2</td><td>TF卡时钟引脚</td></tr><tr><td>CAN1</td><td>CAN1_TX_M0</td><td>I2C3_SCL_M0</td><td>GPIO1_A1_u</td><td>底板背面20pinGPIO</td></tr><tr><td></td><td>CAN1_RX_M0</td><td>I2C3_SDA_M0</td><td>GPIO1_A0_u</td><td>底板背面20pinGPIO</td></tr><tr><td></td><td>CAN1_TX_M1</td><td>HDMI_RX_INT_L_GPIO4_C3</td><td>GPIO4_C3_d</td><td>CAN TX</td></tr><tr><td></td><td>CAN1_RX_M1</td><td>4G_DISABLE_GPIO4_C2</td><td>GPIO4_C2_d</td><td>CAN RX</td></tr><tr><td>CAN2</td><td>CAN2_TX_M0</td><td>I2C2_SCL_M1</td><td>GPIO4_B5_d</td><td>MIPI屏幕触摸I2C</td></tr><tr><td></td><td>CAN2_RX_M0</td><td>I2C2_SDA_M1</td><td>GPIO4_B4_d</td><td>MIPI屏幕触摸I2C</td></tr><tr><td></td><td>CAN2_TX_M1</td><td>WIFI_WAKE_HOST_H_GPIO2_B2</td><td>GPIO2_B2_u</td><td>底板引出未使用</td></tr><tr><td></td><td>CAN2_RX_M1</td><td>WIFI_REG_ON_H_GPIO2_B1</td><td>GPIO2_B1_u</td><td>底板引出未使用</td></tr></tbody></table><h1 id="CAN-协议帧结构"><a href="#CAN-协议帧结构" class="headerlink" title="CAN 协议帧结构"></a>CAN 协议帧结构</h1><h2 id="帧的种类"><a href="#帧的种类" class="headerlink" title="帧的种类"></a>帧的种类</h2><p>帧是 CAN 通信中数据传输的基本单位，在 CAN 通信中使用了五种不同类型的帧来实现不同的功能。以下是每种帧的简要说明及其用途：</p><ul><li><strong>数据帧（Data Frame）</strong>：数据帧是 CAN 通信中最常用的帧类型，用于发送单元向接收单元传递数据。数据帧有两种格式：<ul><li>标准格式（11 位标识符）适用于较简单的网络</li><li>扩展格式（29 位标识符）适用于更复杂的网络。</li></ul></li><li><strong>遥控帧（Remote Frame）</strong>：遥控帧用于接收单元向发送单元请求数据。它不包含数据段，而是通过标识符（ID）告诉发送单元“我需要这个 ID 对应的数据”。遥控帧也有标准格式和扩展格式两种，其结构与数据帧类似，但缺少数据段。</li><li><strong>错误帧（Error Frame）</strong>：错误帧用于当节点检测到错误时，向其他节点通知错误的发生。它是一种特殊的帧，用于中断当前通信并重新启动。错误帧由错误标志（6 个连续显性或隐性位）和错误界定符组成，触发条件包括位错误、填充错误、CRC 错误等。</li><li><strong>过载帧（Overload Frame）</strong>：过载帧用于接收单元通知发送单元其尚未做好接收准备。它通常出现在接收节点需要更多时间处理前一帧的情况下。过载帧只能在帧间隔期间发送，其结构类似于错误帧，由过载标志和过载界定符组成。</li><li><strong>帧间隔（Interframe Space）</strong>：帧间隔用于将数据帧或遥控帧与前面的帧分离开来。它是一个时间间隔，确保网络中的节点能够正确识别下一帧的开始。对于数据帧和遥控帧，帧间隔通常为 3 个位时间；对于错误帧和过载帧，帧间隔可能有所不同。</li></ul><table><thead><tr><th>帧类型</th><th>用途</th></tr></thead><tbody><tr><td>数据帧</td><td>发送单元向接收单元传送数据的帧。</td></tr><tr><td>遥控帧</td><td>接收单元向具有相同ID的发送单元请求数据的帧。</td></tr><tr><td>错误帧</td><td>当检测出错误时，向其他单元通知错误的帧。</td></tr><tr><td>过载帧</td><td>接收单元通知其尚未做好接收准备的帧。</td></tr><tr><td>帧间隔</td><td>将数据帧及遥控帧与前面的帧分离开来的帧。</td></tr></tbody></table><h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><p>数据帧是最核心的帧类型，负责承载实际的数据内容，并在发送单元和接收单元之间实现高效的信息传递。</p><p>在早期的 CAN 通信中，<strong>标准数据帧采用 11 位标识符</strong>，能够满足当时较为简单的网络架构需求。然而，随着车辆功能的复杂化（如高级驾驶辅助系统、动力总成控制、车身电子等），11 位标识符的地址空间逐渐显得不足，难以支持更大规模的节点和更精细的通信需求。为此，CAN 协议引入了<strong>扩展数据帧</strong>，通过 <strong>29 位标识符</strong>提供了更大的地址空间，显著提升了网络的灵活性和扩展性。</p><p><strong>标准数据帧</strong></p><p>标准数据帧是 CAN 通信协议中用于传输数据的基本结构。它包含多个字段，字段的作用各有不同，确保了数据能够高效、安全地传输。数据帧的组成框图如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155740655.png" alt="标准数据帧" loading="lazy"></p><p>从上图可以得到标准数据帧由以下 7 个主要字段组成</p><ul><li><p><strong>帧起始（Start of Frame）</strong></p><ul><li><u>帧起始由一个固定的显性位（逻辑 0）组成，用于标识数据帧的开始</u>。</li></ul><blockquote><p>它不仅通知接收设备准备接收数据，还起到同步发送端和接收端时钟的作用，确保后续数据的正确解析。</p></blockquote></li><li><p><strong>仲裁字段</strong>（Arbitration Field）</p><ul><li><strong>ID</strong>（11位标识符）主要用于区分报文类型、优先级以及确定发送顺序。标识符值越小，优先级越高；</li><li><strong>RTR 位</strong>（1位，远程传输请求）则用于区分数据帧（显性 0）和远程帧（隐性 1）。此外，仲裁字段中禁止高 7位全为隐性，以避免仲裁错误。</li></ul></li><li><p><strong>控制字段</strong>（Control Field）</p><ul><li><strong>IDE 位</strong>（1位）用于区分标准帧（显性 0）和扩展格式</li><li><strong>RO 位</strong>（1位保留位），保留位固定为显性 0 以备未来扩展</li><li><strong>DLC 位</strong>（4位）则指示数据字段中包含的字节数（范围为 0 到 8 字节）。</li></ul></li><li><p><strong>数据字段</strong>（Data Field）</p><ul><li>数据字段<strong>最多包含 8 字节（64 位）</strong>，是数据帧的核心部分，用于承载实际通信数据内容。</li><li>其<strong>长度由控制字段中的 DLC 位指定</strong>，范围从 0 字节（无数据）到8 字节（最大数据量）。该字段的内容是通信的实际信息，可能包括传感器数据、控制指令等。</li></ul></li><li><p><strong>CRC 校验字段</strong>（CRC Field）</p><ul><li><strong>CRC 校验码（15位）</strong></li><li><strong>CRC 界定符组成（1位）</strong>，固定为隐性 1，用于明确 CRC 字段的结束位置。</li><li>接收设备通过重新计算 CRC 并与接收到的 CRC校验码进行比对，验证数据完整性。</li></ul></li><li><p><strong>ACK 字段</strong>（Acknowledgment Field）</p><ul><li><strong>ACK 槽（1位）</strong>，当接收设备成功接收到数据帧后，会在 ACK 槽中返回一个显性位作为确认信号，表示数据帧已正确接收</li><li><strong>ACK 界定符（1位）</strong>，ACK 界定符固定为隐性 1，用于标识 ACK 字段的结束。</li></ul></li><li><p><strong>帧结束</strong>（End of Frame）</p><ul><li><strong>由 7 位连续的隐性位（逻辑 1）组成</strong>，用于明确标识数据帧的结束。</li><li>它不仅告诉接收设备数据帧已经传输完毕，还提供了额外的时间用于信号同步，确保下一帧的正确接收。</li></ul></li></ul><table><thead><tr><th>字段名称</th><th>组成</th><th>作用</th></tr></thead><tbody><tr><td><strong>帧起始</strong></td><td>1位显性0</td><td>标识数据帧的开始，并用于同步发送端和接收端时钟，确保后续数据的正确解析。</td></tr><tr><td><strong>仲裁字段</strong></td><td>11位标识 + 1位RTR位</td><td>区分报文类型（数据帧或远程帧）、优先级及发送顺序；标识符值越小优先级越高；RTR位区分数据帧（显性0）和远程帧（隐性1）；禁止高7位全为隐性。</td></tr><tr><td><strong>控制字段</strong></td><td>1位IDE位 + 1位RO保留位 + 4位DLC位</td><td>IDE位区分标准帧（显性0）和扩展帧（隐性1）；保留位固定为显性0以备未来扩展；DLC位指示数据字段长度（0-8字节）。</td></tr><tr><td><strong>数据字段</strong></td><td>最多8字节（64位）</td><td>承载实际通信数据内容，长度由DLC位指定；数据字段是通信的核心部分，可能包含传感器数据、控制指令等实际信息。</td></tr><tr><td><strong>CRC校验字段</strong></td><td>15位CRC校验码 + 1位CRC界定符</td><td>检测数据传输过程中的错误，接收设备通过重新计算CRC与接收到的CRC校验码比对验证数据完整性；CRC界定符固定为隐性1，标识CRC字段的结束。</td></tr><tr><td><strong>ACK字段</strong></td><td>1位ACK槽 + 1位ACK界定符</td><td>接收设备在ACK槽中返回显性位确认数据帧成功接收；ACK界定符固定为隐性1，标识ACK字段的结束。</td></tr><tr><td><strong>帧结束</strong></td><td>7位隐性1</td><td>明确标识数据帧的结束，通知接收设备数据帧已传输完毕，并提供额外时间用于信号同步，确保下一帧的正确接收。</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155719592.png" alt="标准格式和扩展格式" loading="lazy"></p><p><strong>SRR 位作用</strong></p><p>SRR 位在 CAN 协议中用于替代标准帧的 RTR 位，位于扩展帧仲裁段中原 RTR 位的位置。</p><p>其作用是强制设置为隐性电平（1），以确保在标准帧与扩展帧同时竞争总线时，标准帧因 RTR 位显性（0）而具有更高的优先级。当标准帧和扩展帧同时发送时，总线通过仲裁逻辑检测到显性电平（0），从而使标准帧胜出。</p><p><strong>IDE 位</strong><br>IDE 位是标识符扩展标志，用于区分帧类型：<strong>显性（0）表示当前帧为标准帧，隐性（1）表示扩展帧</strong>。</p><p>在扩展帧中，IDE 位不仅存在于仲裁段以标识帧类型，还出现在控制段中，进一步明确帧结构并实现对扩展帧与标准帧的区分。</p><h3 id="遥控帧"><a href="#遥控帧" class="headerlink" title="遥控帧"></a>遥控帧</h3><p><strong>遥控帧（Remote Frame）<strong>是 CAN 协议中</strong>用于主动请求数据的特殊帧类型</strong>。</p><blockquote><p>当一个节点需要获取其他节点的数据时，可通过发送遥控帧向总线发起请求，目标节点收到请求后返回对应的数据帧。</p></blockquote><p><strong>数据帧去掉数据段就是遥控帧</strong>，当然和遥控帧一样，遥控帧也分标准遥控帧和扩展遥控帧，他们各自的构成如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155719691.png" alt="遥控帧" loading="lazy"></p><ul><li><strong>帧起始（Start of Frame）</strong><ul><li>帧起始由 1 位显性 0 组成，与数据帧相同，用于标识遥控帧的开始。</li><li>它不仅通知接收设备准备接收数据，还起到同步发送端和接收端时钟的作用，确保后续数据解析的准确性。</li></ul></li><li><strong>仲裁字段（Arbitration Field）</strong>：<ul><li>11 位标识符（ID）</li><li>1位 RTR 位（隐性 1）组成，</li><li>用于指定请求的数据帧类型，同时通过 RTR 位隐性 1 与数据帧（显性 0）区分，确保优先级低于同 ID 的数据帧。在扩展遥控帧中，仲裁字段扩展为 29 位标识符（ID）、SRR 位（隐性 1）、IDE 位（隐性 1）和 RTR 位（隐性 1）。其中，SRR 位替代标准帧的 RTR 位，确保扩展帧在仲裁时优先级低于标准数据帧；IDE 位隐性 1 则用于标识该帧为扩展帧。</li></ul></li><li><strong>控制字段（Control Field）</strong>：与标准数据帧和扩展数据帧中的控制字段相同。</li><li><strong>数据字段（Data Field）</strong>：遥控帧<strong>无数据字段</strong>，这是其与数据帧的核心区别。通过省略数据字段，明确表示该帧为请求而非数据传输，从而触发目标节点发送对应 ID 的数据帧。</li><li><strong>CRC 校验字段（CRC Field）</strong>：<ul><li>15 位 CRC 校验码</li><li>1 位隐性 CRC 界定符</li><li>用于验证遥控帧在传输过程中是否发生错误。接收设备通过重新计算 CRC 并与接收到的 CRC 校验码进行比对，确保请求的可靠性。</li></ul></li><li>**ACK 字段（Acknowledgment Field）**ACK 字段由 1 位 ACK 槽和 1 位隐性 ACK 界定符组成。当接收节点成功接收到遥控帧后，会在 ACK 槽中返回一个显性位作为确认信号，表明遥控帧已被正确接收，而 ACK 界定符固定为隐性 1 以标识 ACK 字段的结束。</li><li><strong>帧结束（End of Frame）</strong><ul><li>帧结束由 7 位连续的隐性 1 组成，与数据帧相同，用于明确标识遥控帧的结束。它不仅告诉接收设备遥控帧已经传输完毕，还提供了额外的时间用于信号同步，确保下一帧的正确接收。</li></ul></li></ul><table><thead><tr><th align="center">字段名称</th><th align="center">组成</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">帧起始</td><td align="center">1 位显性 0</td><td align="center">标识遥控帧的开始，同步发送端与接收端时钟，保障后续数据解析的准确性。</td></tr><tr><td align="center">仲裁字段</td><td align="center">标准帧：11 位 ID + RTR（隐性 1）扩展帧：29 位 ID + SRR（隐性 1）+ IDE（隐性 1）+ RTR（隐性 1）</td><td align="center">指定请求的数据帧类型，RTR 隐性 1 区分于数据帧；扩展帧通过 SRR、IDE 位兼容标准帧，优先级低于同 ID 的数据帧。</td></tr><tr><td align="center">控制字段</td><td align="center">标准帧：IDE+R0+4 位 DLC 位扩展帧：R1+R0+4 位 DLC 位</td><td align="center">DLC 位指示目标数据帧的字节数（0-8 字节），但遥控帧本身不携带数据；IDE 位区分扩展帧与标准帧。</td></tr><tr><td align="center">数据字段</td><td align="center">无</td><td align="center">明确遥控帧为请求帧，不进行数据传输。</td></tr><tr><td align="center">CRC 校验字段</td><td align="center">15 位 CRC 校验码 + 1 位隐性 CRC 界定符</td><td align="center">验证遥控帧传输过程的正确性，保障请求的可靠性。</td></tr><tr><td align="center">ACK 字段</td><td align="center">1 位 ACK 槽（接收节点填显性位） + 1 位隐性 ACK 界定符</td><td align="center">接收节点通过 ACK 槽确认遥控帧已正确接收，ACK 界定符标识该字段结束。</td></tr><tr><td align="center">帧结束</td><td align="center">7 位隐性 1</td><td align="center">标识遥控帧结束，提供信号同步时间，确保下一帧的正确接收。</td></tr></tbody></table><h3 id="错误帧"><a href="#错误帧" class="headerlink" title="错误帧"></a>错误帧</h3><p>错误帧是 CAN 总线中用于标识通信过程中发生错误的特殊帧，其结构与其他帧（如数据帧或遥控帧）不同，主要用于通知网络中的所有节点当前传输存在错误。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155720858.png" alt="错误帧组成" loading="lazy"></p><ul><li><strong>错误标志（Error Flag）</strong><ul><li><strong>6 位连续的显性位（逻辑 0）或隐性位（逻辑 1）</strong>，分为主动错误标志和被动错误标志。</li><li><strong>主动错误标志</strong>由检测到错误的节点发送，强制中断当前帧的传输，通知网络中所有节点错误的发生；</li><li><strong>被动错误标志</strong>则由处于被动错误状态的节点发送，避免干扰其他节点的正常通信。</li></ul></li><li><strong>错误界定符（Error Delimiter）</strong><ul><li>8 位连续的隐性位（逻辑 1）组成，用于标识错误帧的结束。它确保所有节点能够明确识别错误帧的边界，并在错误处理完成后恢复正常的通信流程。</li></ul></li></ul><table><thead><tr><th align="center">字段名称</th><th align="center">组成</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">错误标志</td><td align="center">主动错误标志：6 位显性位被动错误标志：6 位隐性位</td><td align="center">主动错误标志强制中断当前帧传输，通知网络节点错误；被动错误标志避免干扰其他节点通信。</td></tr><tr><td align="center">错误界定符</td><td align="center">8 位隐性位</td><td align="center">标识错误帧结束，帮助所有节点识别错误帧边界并恢复正常通信。</td></tr></tbody></table><h3 id="过载帧"><a href="#过载帧" class="headerlink" title="过载帧"></a>过载帧</h3><p>过载帧是 CAN 总线中用于通知网络中的其他节点当前接收设备需要更多时间来处理数据的特殊帧。它通常在接收节点无法及时处理接收到的数据时发送，以请求发送节点延迟下一帧的传输。过载帧的组成如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155755317.png" alt="过载帧" loading="lazy"></p><ul><li><strong>过载标志（Overload Flag）</strong><ul><li><strong>6 位连续的显性位（逻辑 0）组成</strong>，由接收节点发送，用于通知网络中的其他节点当前接收设备需要更多时间来处理数据，从而请求延迟下一帧的传输。</li><li>多个节点可以同时发送过载标志，这些标志会叠加在一起，形成一个更长的显性位序列。</li></ul></li><li><strong>过载界定符（Overload Delimiter）</strong><ul><li><strong>8 位连续的隐性位（逻辑 1）组成</strong>，用于标识过载帧的结束。</li><li>它确保所有节点能够明确识别过载帧的边界，并在过载处理完成后恢复正常的通信流程。</li></ul></li></ul><table><thead><tr><th align="center">字段名称</th><th align="center">组成</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">过载标志</td><td align="center">6 位连续显性位</td><td align="center">由接收节点发送，告知网络其他节点自身需更多时间处理数据，请求延迟下一帧传输。</td></tr><tr><td align="center">过载界定符</td><td align="center">8 位连续隐性位</td><td align="center">标识过载帧的结束，帮助所有节点识别其边界，从而恢复正常通信流程。</td></tr></tbody></table><blockquote><p>过载帧通过<strong>过载标志</strong>和<strong>过载界定符</strong>两个字段实现对接收节点处理能力不足的标识和处理。</p><p>当接收节点无法及时处理数据时，会发送过载标志（6 位显性位），通知网络中其他节点延迟下一帧的传输；随后通过过载界定符（8 位隐性位）明确标识过载帧的结束。</p><p>过载帧的设计确保了网络中的节点能够在高负载情况下协调通信，避免数据丢失或错误。</p></blockquote><h2 id="位填充"><a href="#位填充" class="headerlink" title="位填充"></a>位填充</h2><p>位填充是 CAN 协议中用于确保数据传输过程中信号同步的重要机制。</p><p>位填充通过在连续 5 个相同极性位后插入一个反向极性的填充位，确保总线上始终有电平变化，从而维持发送端和接收端的同步。</p><p>填充仅在帧起始到 CRC 字段之间进行，避免对其他部分造成干扰。接收方在检测到填充位后会自动移除填充位，还原出原始数据。这种机制对于防止信号同步问题、提高 CAN 总线通信的可靠性至关重要。</p><p><strong>核心目的</strong></p><p>通过在连续 5 个相同极性位后插入一个反向极性的填充位，避免长时间的“0”或“1”电平导致总线同步问题，从而提高通信的可靠性。</p><p><strong>位填充规则</strong></p><p>当数据中出现 5 个连续的相同极性位时，在第 6 位插入一个与这些位极性相反的填充位。</p><p>这一机制通过打破可能出现的长串相同电平，确保总线上始终有电平变化，从而维持发送端和接收端的同步。</p><p><strong>填充范围</strong></p><p><strong>从帧起始部分到 CRC 字段之间进行</strong>，<emp>CRC 字段之后的数据（如 ACK 字段和帧结束）不进行填充</emp>。这种设计限制了填充范围，避免对不需要同步的部分造成干扰，同时保证关键数据段的同步性。</p><ul><li>示例 1：<ul><li>原始数据：110000011</li><li>分析：未出现 5 个连续的相同极性位，因此无需填充。</li><li>实际发送数据：1100000111</li><li>接收方直接恢复原始数据：110000011</li></ul></li><li>示例 2：<ul><li>原始数据：0111111</li><li>分析：出现 5 个连续的“1”，在第 6 位插入一个“0”。</li><li>实际发送数据：01111101</li><li>接收方检测并移除填充位，恢复原始数据：0111111</li></ul></li><li>示例 3：<ul><li>原始数据：1000001111</li><li>分析：出现 5 个连续的“0”，在第 6 位插入一个“1”，插入 1 之后，又出现了五个连续的“1”，所以在最后一位需要补 0。</li><li>实际发送数据：100000111110</li><li>接收方检测并移除填充位，恢复原始数据：1000001111</li></ul></li></ul><h2 id="CAN-波形实例分析"><a href="#CAN-波形实例分析" class="headerlink" title="CAN 波形实例分析"></a>CAN 波形实例分析</h2><h3 id="标准数据帧"><a href="#标准数据帧" class="headerlink" title="标准数据帧"></a>标准数据帧</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155723352.png" alt="实例1" loading="lazy"></p><blockquote><p>CAN 通信是由一对差分信号线决定的，但上面的 CAN 波形就只有一个，这是因为上述波形是由逻辑分析仪采集得到的，逻辑分析仪会自动将差分信号转换为逻辑信号。然后来对波形进行分析。</p></blockquote><p><strong>帧起始</strong></p><p>首先是帧起始，帧起始由一个固定的显性位（逻辑 0）组成，用于标识数据帧的开始</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155723875.png" alt="帧起始" loading="lazy"></p><p><strong>仲裁字段</strong></p><p>接下来是 12 位的仲裁字段，其中前 11 位为标识符（ID）最后一位是远程传输请求 RTR 位，标识图如下所示，其中红色×的位表示填充位，所以在实际分析的时候需要忽略对应的位，最后一位的 RTR 位为显性位（逻辑 0），所以当前传输的帧为数据帧</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155726119.png" alt="仲裁字段" loading="lazy"></p><p><strong>控制字段</strong></p><p>仲裁字段后面是六位的控制字段（Control Field），包括 1 位 IDE 位、1 位保留位（R0）和4 位数据长度码（DLC），标识图如下所示，IDE 位为显性位（逻辑 0），所以当前帧为标准帧，保留位 R0 默认为显性位（逻辑 0），后四位的 DLC 位为 0001,表示后面会发送 8 位的数据</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155629400.png" alt="控制字段" loading="lazy"></p><p><strong>数据字段</strong></p><p>接下来是 8 位的数据字段，它用于承载实际通信数据内容，标识图如下所示，要发送的数据为 00000001，然后继续向下分析</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155629243.png" alt="数据字段" loading="lazy"></p><p><strong>CRC校验字段</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155628956.png" alt="CRC校验字段" loading="lazy"></p><p><strong>ACK字段</strong></p><p>接下来的两位是 ACK 字段（Acknowledgment Field），ACK 字段由 2 位组成，包括 1 位 ACK槽和 1 位 ACK 界定符。当接收设备成功接收到数据帧后，会在 ACK 槽中返回一个显性位作为确认信号，表示数据帧已正确接收，ACK 界定符固定为隐性 1，用于标识 ACK 字段的结束，标识图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155629172.png" alt="ACK字段" loading="lazy"></p><p>最后是由 7 位连续的隐性位（逻辑 1）组成的帧结束，用于明确标识数据帧的结束。</p><h3 id="标准遥控帧"><a href="#标准遥控帧" class="headerlink" title="标准遥控帧"></a>标准遥控帧</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155629352.png" alt="遥控帧" loading="lazy"></p><p><strong>帧起始</strong></p><p>首先是帧起始，帧起始由一个固定的显性位（逻辑 0）组成，用于标识数据帧的开始，在下图中已经标出</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155629443.png" alt="帧起始" loading="lazy"></p><p><strong>仲裁字段</strong></p><p>接下来是 12 位的仲裁字段，其中前 11 位为标识符（ID）最后一位是远程传输请求 RTR 位组成，标识图如下所示，其中红色×的位表示填充位，所以在实际分析的时候需要忽略对应的位，最后一位的 RTR 位为隐性位（逻辑 1），并且通过观察可以得到后面没有要传输的数据位，所以当前传输的帧为遥控帧</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155635391.png" alt="image-20260109104015402" loading="lazy"></p><p><strong>控制字段</strong></p><p>仲裁字段后面是六位的控制字段（Control Field），包括 1 位 IDE 位、1 位保留位（R0）和4 位数据长度码（DLC），标识图如下所示，IDE 位为隐性位（逻辑 1），所以当前帧为标准遥控帧，保留位 R0 默认为显性位（逻辑 0），后四位的 DLC 位为 0001,但当前帧是遥控帧，并不会发送数据</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155636065.png" alt="控制字段" loading="lazy"></p><p><strong>CRC 校验字段</strong></p><p>CRC 校验字段由 15 位 CRC 校验码和 1 位 CRC 界定符组成，用于检测数据传输过程中是否发生错误，标识图如下所示，最后一位的 CRC 界定符固定为隐性 1，用于明确 CRC 字段的结束位置。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155640560.png" alt="CRC校验字段" loading="lazy"></p><p><strong>ACK字段</strong></p><p>接下来的两位是 ACK 字段（Acknowledgment Field），ACK 字段由 2 位组成，包括 1 位 ACK槽和 1 位 ACK 界定符。当接收设备成功接收到数据帧后，会在 ACK 槽中返回一个显性位作为确认信号，表示数据帧已正确接收，ACK 界定符固定为隐性 1，用于标识 ACK 字段的结束，标识图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155641428.png" alt="ACK字段" loading="lazy"></p><p>最后是由 7 位连续的隐性位（逻辑 1）组成的帧结束</p><h3 id="扩展数据帧"><a href="#扩展数据帧" class="headerlink" title="扩展数据帧"></a>扩展数据帧</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155643912.png" alt="扩展数据帧" loading="lazy"></p><p><strong>帧起始</strong></p><p>首先是帧起始，帧起始由一个固定的显性位（逻辑 0）组成，用于标识数据帧的开始，在下图中已经标出</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155644331.png" alt="帧起始" loading="lazy"></p><p><strong>扩展帧</strong></p><p>根据波形长度以及上方黄色标识可以得到，该帧为扩展帧，所以在接下来的 12 位中，前11 位为标识符（ID），最后一位是 SRR 位，标识图如下所示，其中红色×的位表示填充位，所以在实际分析的时候需要忽略对应的位，SRR 位为隐形位(逻辑 1)</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155811068.png" alt="扩展帧" loading="lazy"></p><p>接下来的后面是 1 位 IDE 位，IDE 位为隐性位（逻辑 1），所以当前帧为扩展帧，但具体是扩展遥控帧还是扩展数据帧，还需要继续向下分析</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155649206.png" alt="扩展帧" loading="lazy"></p><p>接下来 19 位中的前 18 位也是 ID 位，最后一位为 RTR 位，标识图如下所示，最后一位的RTR 位为显性位（逻辑 0），所以当前传输的帧为扩展数据帧，然后继续向下分析：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155649698.png" alt="扩展帧" loading="lazy"></p><p><strong>控制字段</strong></p><p>接下来的六位是控制字段（Control Field），包括 2 位保留位（R1 和 R0）和 4 位数据长度码（DLC），标识图如下所示，后四位的 DLC 位为 0001,表示后面会发送 8 位的数据</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155652326.png" alt="控制字段" loading="lazy"></p><p><strong>数据字段</strong></p><p>接下来是 8 位的数据字段，它用于承载实际通信数据内容，标识图如下所示，要发送的数据为 00000001</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155652870.png" alt="数据字段" loading="lazy"></p><p><strong>CRC 校验字段</strong></p><p>CRC 校验字段由 15 位 CRC 校验码和 1 位 CRC 界定符组成，用于检测数据传输过程中是否发生错误，标识图如下所示，最后一位的 CRC 界定符固定为隐性 1，用于明确 CRC 字段的结束位置</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155653873.png" alt="CRC校验字段" loading="lazy"></p><p><strong>ACK 字段</strong></p><p>接下来的两位是 ACK 字段（Acknowledgment Field），ACK 字段由 2 位组成，包括 1 位 ACK 槽和 1 位 ACK 界定符。当接收设备成功接收到数据帧后，会在 ACK 槽中返回一个显性位作为确认信号，表示数据帧已正确接收，ACK 界定符固定为隐性 1，用于标识 ACK 字段的结束，标识图如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155654030.png" alt="ACK字段" loading="lazy"></p><p>最后是由 7 位连续的隐性位（逻辑 1）组成的帧结束，用于明确标识数据帧的结束。</p><h1 id="CAN总线核心机制与通信原理"><a href="#CAN总线核心机制与通信原理" class="headerlink" title="CAN总线核心机制与通信原理"></a>CAN总线核心机制与通信原理</h1><h2 id="位时间"><a href="#位时间" class="headerlink" title="位时间"></a>位时间</h2><p>在 CAN 总线通讯中，**位时间是指传输一个逻辑位所需的时间，**是 CAN 协议实现可靠数据传输的核心概念之一，直接影响通讯的波特率和信号同步精度。作为异步通讯的基础，所有节点通过约定好的位时间来保持同步。</p><p>CAN 协议将位时间划分为多个时间段，这些时间段共同决定了信号的采样和同步机制。具体包括以下几个部分：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155657017.png" alt="位时间划分" loading="lazy"></p><ul><li><strong>同步段（Sync Segment）</strong></li></ul><p>同步段是位时间的第一个部分，<strong>固定为 1 个时间量子</strong>（<strong>TQ 时间量子是位时间的基本单位，所有时间段都以时间量子为基准进行划分</strong>），主要用于检测信号边沿并实现硬同步。</p><p>在帧起始（SOF，Start of Frame）阶段，接收节点会根据总线信号的下降沿强制调整自己的时钟，与总线信号对齐，从而确保所有节点在通讯初始阶段保持同步。</p><ul><li><strong>传播段（Propagation Segment）</strong></li></ul><p>传播段用于补偿信号在总线上的传播延迟以及输入比较器的响应时间，其长度通常为 1 到 8 个时间量子（TQ），具体值由配置决定。这</p><p>段时间允许信号在物理介质上传播，并确保所有节点能够接收到稳定的信号，从而避免因传播延迟导致的采样误差。</p><ul><li><strong>相位缓冲段 1（Phase Segment 1）</strong></li></ul><p>相位缓冲段 1 是位时间中可配置的部分，通常为 1到 8 个时间量子（TQ），<strong>主要用于调整采样点的位置，确保采样点位于信号稳定区域</strong>。</p><u>如果检测到信号边沿提前到达，可以通过缩短相位缓冲段 1 实现重同步，从而动态补偿时钟偏差或信号抖动带来的影响。</u><ul><li><strong>相位缓冲段 2（Phase Segment 2）</strong></li></ul><p>相位缓冲段 2 类似于相位缓冲段 1，也是位时间中可配置的部分，通常为 1 到 8 个时间量子（TQ）。</p><u>它主要用于处理信号边沿延迟到达的情况。如果信号边沿延迟，可以通过延长相位缓冲段 2 实现重同步，从而确保接收节点能够在正确的时间采样信号，提高数据传输的可靠性。</u><p><strong>位时间的作用</strong></p><ol><li>保证同步：通过划分时间段，CAN 节点能够在信号边沿出现时动态调整采样点，补偿时钟偏差和信号延迟，从而实现多节点间的同步。</li><li>提高抗干扰能力：将采样点设置在信号稳定区域（如位时间的 87.5% 处），避免因信号边沿抖动或干扰导致的误判。</li><li>支持灵活配置：通过调整各时间段的长度（如传播段、相位缓冲段等），可以适应不同的波特率和网络环境。</li></ol><h2 id="硬同步和再同步"><a href="#硬同步和再同步" class="headerlink" title="硬同步和再同步"></a>硬同步和再同步</h2><p>在 CAN 通信中，由于采用异步通信方式且没有独立时钟线，各节点依赖本地晶振进行数据传输，但晶振的时钟漂移会导致节点间时序逐渐偏移，最终引发采样错误。为解决这一问题，CAN 协议通过硬同步和再同步两大机制实现动态时序调整：</p><ol><li><strong>硬同步在帧起始阶段强制对齐所有节点的时钟，消除初始相位偏差</strong>；</li><li><strong>再同步则在数据传输过程中根据信号边沿的实时检测，动态调整相位缓冲段长度以补偿时钟漂移</strong>。</li></ol><p>这两种机制协同工作，结合位时间划分（同步段、传播段、相位段 I&#x2F;II）和时间量子（Tq）的量化管理，确保所有节点在采样点时刻准确读取总线电平，从而在无独立时钟线的异步通信中实现高可靠性的数据传输。在本小节将对硬同步和再同步进行详细的讲解。</p><h3 id="硬同步"><a href="#硬同步" class="headerlink" title="硬同步"></a>硬同步</h3><p>在 CAN 通信中，硬同步是确保所有节点初始时序一致的重要机制。它的核心作用是<strong>在帧起始（SOF）阶段强制对齐各节点的时序，从而消除因本地晶振差异导致的初始相位差</strong>。</p><p>硬同步的触发条件是<strong>当总线从空闲状态检测到显性电平（逻辑 0）的下降沿时（即 SOF 位的边沿），节点会立即调整自身时序，将当前位的同步段对齐到该边沿</strong>。</p><p>这一过程可以分为以下几个步骤：</p><ul><li>节点在<strong>总线空闲期间持续监测电平变化</strong>；</li><li>当<strong>检测到 SOF 下降沿且该边沿落在同步段内时，硬同步被触发</strong>；</li><li><strong>节点强制调整时序，将当前位的同步段起点对齐到该边沿，并重新开始后续位时间的计数</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155700355.png" alt="硬同步" loading="lazy"></p><p>然而，<strong>硬同步的作用范围有限，它仅在消息帧的起始阶段生效，且只能解决初始相位偏差问题</strong>。</p><emp>对于通信过程中由于时钟漂移或信号干扰引发的动态相位误差，硬同步无能为力，这些问题需要依赖后续的重同步机制来处理</emp><h3 id="再同步"><a href="#再同步" class="headerlink" title="再同步"></a>再同步</h3><p>在 CAN 通信中，<strong>再同步是解决通信过程中因时钟漂移或信号干扰导致的动态相位误差的关键机制</strong>。</p><p>与硬同步不同，再同步并非仅限于帧起始阶段，而是<strong>在整个数据传输过程中持续发挥作用</strong>。<u>它的核心作用是通过动态调整采样点的位置，确保接收节点能够在正确的时间读取总线电平，从而维持通讯的可靠性</u>。</p><p>具体来说，<strong>再同步的触发条件是当检测到信号边沿（如显性电平到隐性电平的变化）与预期位置存在偏差时</strong>。</p><ul><li><strong>如果信号边沿提前到达，说明发送节点的时钟快于接收节点，此时接收节点会通过缩短相位缓冲段 1 来提前采样点；</strong></li><li><strong>反之，如果信号边沿延迟到达，则说明发送节点的时钟慢于接收节点，接收节点会通过延长相位缓冲段 2 来推迟采样点。</strong></li></ul><p>这种动态调整的过程依赖于<strong>同步跳转宽度（SJW, Synchronization Jump Width）</strong>，它定义了<emp>每次再同步调整的最大范围</emp>，以防止过度调整引发新的误差。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155819841.png" alt="隐形电平到显性电平的边沿出现在PTS和PBS1之间" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155703141.png" alt="隐形电平到显性电平的边沿出现在PBS2中时" loading="lazy"></p><p>再同步的优势在于其灵活性和实时性，能够有效应对通信过程中因时钟漂移或信号传播延迟带来的挑战。</p><p>然而，<u>再同步的调整范围受限于 SJW 的配置，若相位误差超出 SJW 的限制，则可能导致采样错误，进而影响通讯的可靠性</u>。</p><p>因此，再同步与硬同步协同工作，共同构成了CAN 协议中完整的同步机制：硬同步为通讯提供初始对齐，而再同步则在后续传输中动态补偿误差，确保数据传输的准确性和稳定性。</p><h2 id="仲裁规则"><a href="#仲裁规则" class="headerlink" title="仲裁规则"></a>仲裁规则</h2><p>在 CAN 总线通信中，由于多个节点共享同一条总线，同一时刻只能传输一个数据帧，因此需要一套高效的仲裁机制来保证数据的有序传输。</p><p>CAN 协议通过载波侦听、非破坏性仲裁和回读机制共同协作，实现了多节点间的高效、无冲突通信。</p><h3 id="载波侦听"><a href="#载波侦听" class="headerlink" title="载波侦听"></a>载波侦听</h3><p>在<strong>发送数据之前，每个节点会首先侦听总线的状态</strong>，只有当总线处于空闲状态（即没有其他节点正在发送数据）时，节点才允许开始发送数据。</p><p>这种机制类似于以太网中的“载波侦听多路访问（CSMA）”，可以有效避免多个节点同时抢占总线的情况。</p><u>如果两个或多个节点几乎同时检测到总线空闲并开始发送数据，则进入非破坏性仲裁阶段。</u><h3 id="非破坏性仲裁"><a href="#非破坏性仲裁" class="headerlink" title="非破坏性仲裁"></a>非破坏性仲裁</h3><p>非破坏性仲裁是 CAN 总线仲裁机制的核心，其核心原则是<strong>基于线与机制</strong></p><ul><li>当所有节点都发送隐性电平（逻辑 1）时，总线表现为隐性；</li><li>只要有一个节点发送显性电平（逻辑 0），总线就表现为显性。</li></ul><p>这种机制确保了即使多个节点同时发送数据，总线上的信号也不会被破坏，而是由显性电平主导，仲裁过程如下所示：</p><ul><li>每个数据帧的标识符（ID）字段用于仲裁优先级，<strong>ID 越小，优先级越高</strong>。</li><li>当多个节点同时发送数据时，它们会逐位比较自己发送的 ID 与总线上的实际电平，<ul><li>如果某个节点发送的是隐性电平（1），但检测到总线上为显性电平（0），说明有更高优先级的节点正在发送数据，该节点会立即停止发送并进入监听模式，等待下一次总线空闲时重新尝试发送。</li><li>如果某个节点发送的是显性电平（0），且总线上也为显性电平（0），则该节点继续发送，表明它当前具有最高优先级。</li></ul></li></ul><h3 id="回读机制"><a href="#回读机制" class="headerlink" title="回读机制"></a>回读机制</h3><p>为了确保仲裁的正确性和数据传输的可靠性，CAN 节点<strong>在发送数据的同时会不断回读总线上的信号</strong>，<strong>并将其与自身发送的数据进行比较</strong></p><emp>如果发送节点发现回读到的数据与自身发送的数据不一致（例如发送隐性电平但回读到显性电平）</emp>，则说明发生了仲裁冲突，该节点会立即**停止发送并切换到监听模式**。<p>这种机制确保了低优先级节点能够及时退出发送，避免干扰高优先级节点的通信</p><h2 id="错误状态"><a href="#错误状态" class="headerlink" title="错误状态"></a>错误状态</h2><p>在 CAN 协议中，节点的错误状态是根据**发送错误计数器（TEC）<strong>和</strong>接收错误计数器（REC）**的值动态调整的。</p><p>通过三种不同的错误状态主动错误状态 、被动错误状态 和总线关闭态 ，</p><p>CAN 协议实现了对故障节点的有效管理和隔离，同时确保了通信的可靠性和稳定性。</p><h3 id="主动错误状态"><a href="#主动错误状态" class="headerlink" title="主动错误状态"></a>主动错误状态</h3><p><strong>当节点的发送错误计数器（TEC）和接收错误计数器（REC）均小于或等于 127 时，节点处于主动错误状态 。</strong></p><p>在此状态下，节点能够正常参与总线通信，并在检测到错误时主动发送主动错误标志（显性位）。这种显性标志会强制覆盖总线信号，通知其他节点当前存在错误。</p><p>由于显性位具有更高的优先级，这种机制能够快速传播错误信息，从而确保错误被及时处理，维护总线通信的可靠性。</p><h3 id="被动错误状态"><a href="#被动错误状态" class="headerlink" title="被动错误状态"></a>被动错误状态</h3><p><strong>如果节点的发送错误计数器（TEC）或接收错误计数器（REC）超过 127（通常由 TEC 触发），节点将进入被动错误状态。</strong></p><p>在这一状态下，节点仍可参与通信，但其行为受到限制：它不能主动发送显性错误标志，而是发送被动错误标志（隐性位），以避免对总线造成干扰。此外，每次发送后需插入 8 个隐性位的延迟才能再次尝试通信。</p><p>值得注意的是，如果仅被动错误状态的节点检测到错误，而其他主动节点未检测到，则总线被视为无错误，通信继续进行。</p><p>这种设计既限制了低可靠性节点对总线的影响，又保证了高可靠性节点的通信效率。</p><h3 id="总线关闭态"><a href="#总线关闭态" class="headerlink" title="总线关闭态"></a>总线关闭态</h3><p><strong>当节点的发送错误计数器（TEC）超过 255 时，节点进入总线关闭态 。</strong></p><p>在这种状态下，节点完全禁止通信，既不能发送也不能接收数据，以防止其对总线造成进一步干扰。</p><p>要恢复通信，节点需要检测到 128 次连续的 11 个隐性位（即总线空闲足够长时间），随后重置 TEC 和REC 为 0，从而恢复为主动错误状态并重新加入总线通信。</p><p>这种机制旨在隔离严重故障节点，同时为其提供重新加入总线的机会。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155703719.png" alt="错误状态状态机" loading="lazy"></p><p>更具体的接收错误计数值（REC）和发送错误计数值（TEC)的变动条件如下表所示：</p><table><thead><tr><th align="center">序号</th><th align="center">接受和发送错误计数值的变动条件</th><th align="center">发送错误计数值（TEC）</th><th align="center">接收错误计数值（REC）</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">接收单元检测出错错误时。例外：接收单元在发送错误标志或过载标志中检测出 “位错误” 时，接收错误计数值不增加。</td><td align="center">—</td><td align="center">+1</td></tr><tr><td align="center">2</td><td align="center">接收单元在发送完错误标志后检测到的第一个位为显性电平时。</td><td align="center">—</td><td align="center">+8</td></tr><tr><td align="center">3</td><td align="center">发送单元在输出错误标志时。</td><td align="center">+8</td><td align="center">—</td></tr><tr><td align="center">4</td><td align="center">发送单元在发送主动错误标志或过载标志时，检测出位错误。</td><td align="center">+8</td><td align="center">—</td></tr><tr><td align="center">5</td><td align="center">接收单元在发送主动错误标志或过载标志时，检测出位错误。</td><td align="center">—</td><td align="center">+8</td></tr><tr><td align="center">6</td><td align="center">各单元从主动错误标志、过载标志的最开始检测出连续 14 个位的显性位时。之后，每检测出连续的 8 个位的显性位时。</td><td align="center">发送时 + 8</td><td align="center">接收时 + 8</td></tr><tr><td align="center">7</td><td align="center">检测出在被动错误标志后追加的连续 8 个位的显性位时。</td><td align="center">发送时 + 8</td><td align="center">接收时 + 8</td></tr><tr><td align="center">8</td><td align="center">发送单元正常发送数据结束时（返回 ACK 且到帧结束也未检测出错误时）。</td><td align="center">TEC&#x3D;0 时 ±0否则 - 1</td><td align="center">—</td></tr><tr><td align="center">9</td><td align="center">接收单元正常接收数据结束时（到 CRC 未检测出错误且正常返回 ACK 时）。</td><td align="center">—</td><td align="center">1≤REC≤127 时 - 1REC&#x3D;0 时 ±0REC&gt;127 时设 REC&#x3D;127</td></tr><tr><td align="center">10</td><td align="center">处于总线关闭态的单元，检测到 128 次连续 11 个位的隐性位。</td><td align="center">TEC&#x3D;0</td><td align="center">REC&#x3D;0</td></tr></tbody></table><h2 id="错误检测机制"><a href="#错误检测机制" class="headerlink" title="错误检测机制"></a>错误检测机制</h2><p>CAN（Controller Area Network）协议通过多种错误检测手段，有效提升了通信的可靠性。</p><p>错误检测机制可以分为以下五种：位错误、填充错误、CRC 错误、格式错误和 ACK 错误。</p><h3 id="位错误"><a href="#位错误" class="headerlink" title="位错误"></a>位错误</h3><p>位错误是指<strong>发送单元在通信过程中比较自身输出电平与总线电平（不包括填充位）时，发现两者不一致所检测到的错误</strong>。</p><p>这种错误通常表明发送节点与总线上的信号存在冲突或干扰。</p><u>位错误可以发生在数据帧、遥控帧、错误帧以及过载帧的任意段内（从 SOF 到 EOF）。</u><p>由于位错误是由发送单元自身检测到的，因此其检测单元为发送单元。</p><h3 id="填充错误"><a href="#填充错误" class="headerlink" title="填充错误"></a>填充错误</h3><p>填充错误是指<strong>在需要位填充的段内，接收单元连续检测到 6 位相同电平时所触发的错误</strong>。</p><p>CAN 协议规定，在位填充段中，每连续 5 个相同电平后必须插入一个相反电平的填充位，以确保信号的直流平衡。</p><p>如果接收单元检测到连续 6 位相同的电平，则认为发生了填充错误。</p><u>填充错误主要发生在数据帧和遥控帧的任意段内（从 SOF 到 EOF），其检测单元为接收单元。</u><h3 id="CRC-错误"><a href="#CRC-错误" class="headerlink" title="CRC 错误"></a>CRC 错误</h3><p>CRC 错误是指<strong>接收单元根据接收到的数据计算出的 CRC 校验值与帧中实际接收到的 CRC顺序不一致</strong>时所检测到的错误。</p><p>CRC 校验是 CAN 协议中用于验证数据完整性的关键机制，若校验失败，则表明数据在传输过程中可能发生了损坏或丢失。</p><u>CRC 错误通常发生在数据帧和遥控帧的 CRC 段内，其检测单元为接收单元。</u><h3 id="格式错误"><a href="#格式错误" class="headerlink" title="格式错误"></a>格式错误</h3><p>格式错误是指<strong>接收单元在解析帧时检测到与固定格式的位段相反的格式时所触发的错误</strong>。例如，CRC 界定符、ACK 界定符或 EOF 的非法值均可能导致格式错误。</p><p>这种错误通常表明帧结构不符合 CAN 协议的规范。</p><u>格式错误可以发生在数据帧和遥控帧的 CRC 界定符、ACK 界定符、EOF 段，以及错误界定符和过载界定符中，其检测单元为接收单元。</u><h3 id="ACK-错误"><a href="#ACK-错误" class="headerlink" title="ACK 错误"></a>ACK 错误</h3><p>ACK 错误是指<strong>发送单元在 ACK 槽（ACK Slot）中检测到隐性电平时所触发的错误</strong>。</p><p>在 CAN 协议中，<strong>当发送单元完成数据帧或遥控帧的发送后，会在 ACK 槽等待其他节点的确认信号（显性电平）</strong>。</p><p>如果发送单元未检测到显性电平，则认为未收到确认信号，从而触发 ACK 错误。</p><u>ACK 错误主要发生在数据帧和遥控帧的 ACK 槽段内，其检测单元为发送单元。</u><h2 id="CAN-总线协议和标准规格"><a href="#CAN-总线协议和标准规格" class="headerlink" title="CAN 总线协议和标准规格"></a>CAN 总线协议和标准规格</h2><p>在现代通信系统中，ISO 七层网络模型是描述和标准化网络通信过程的经典框架。它将网络通信划分为七个层次，从底层的物理信号传输到高层的应用服务，每一层都具有特定的功能和作用。</p><p>CAN 协议的设计虽然并未完全遵循 ISO 七层网络模型，但其功能可以映射到该模型的部分层次 。</p><p>CAN 协议主要集中在<strong>物理层</strong>、<strong>数据链路层</strong>和<strong>传输层</strong>的部分功能。</p><h3 id="ISO-七层网络模型"><a href="#ISO-七层网络模型" class="headerlink" title="ISO 七层网络模型"></a>ISO 七层网络模型</h3><ol><li><p><strong>物理层（Physical Layer）</strong><br>物理层负责设备间的物理信号传输，定义了通信所需的电气信号、硬件规格和通信介质。它涵盖了通信方式（如单工、半双工、全双工）、信号电平（如高低电平表示逻辑 0 和 1）、硬件规格（如电缆、连接器、收发器）以及位时序条件（如位同步、采样点），从而确保数据能够在物理媒介上可靠传输。</p></li><li><p><strong>数据链路层（Data Link Layer）</strong><br>数据链路层将物理层接收到的位序列组织成有意义的数据帧，并提供错误检测与控制功能。其具体项目包括数据帧的格式（如帧起始、标识符、数据字段、CRC 校验）、访问控制方法（如 CSMA&#x2F;CD、CSMA&#x2F;CA）以及错误检测与纠正机制（如 CRC 校验、ACK 应答），以确保数据在链路上传输的准确性和完整性。</p></li><li><p><strong>网络层（Network Layer）</strong><br>网络层负责数据包的路由选择和中继，确保数据能够从源设备高效传输到目标设备。它通过路由选择（如静态路由、动态路由）、地址管理（如 IP 地址分配）以及数据包的分段与重组等功能，实现跨网络的数据传输，为复杂网络环境中的通信提供支持。</p></li><li><p><strong>传输层（Transport Layer）</strong><br>传输层确保数据传输的可靠性，控制数据顺序、错误恢复和流量控制。它通过数据传输顺序控制（如序列号、确认机制）、错误恢复（如重传机制）以及流量控制（如滑动窗口协议）等机制，保障数据在端到端传输过程中的一致性、完整性和高效性。</p></li><li><p><strong>会话层（Session Layer）</strong><br>会话层管理通信会话的建立、维护和终止，确保数据能够在会话期间正确传输。它通过会话建立与终止（如握手协议）、会话同步（如检查点机制）以及会话恢复（如断点续传）等功能，协调应用程序之间的交互，提高通信的稳定性和效率。</p></li><li><p><strong>表示层（Presentation Layer）</strong><br>表示层负责数据的表现形式转换，确保不同系统间的数据兼容性。它通过数据格式转换（如文本编码、图像格式）、数据加密与解密以及数据压缩与解压缩等功能，使数据能够在不同平台和应用之间进行无缝交换和处理。</p></li><li><p><strong>应用层（Application Layer）</strong><br>应用层为应用程序提供网络服务接口，实现具体的应用功能。它通过应用程序协议（如 HTTP、FTP、SMTP）、用户接口（如浏览器、邮件客户端）以及数据服务（如文件传输、电子邮件）等功能，直接服务于最终用户，满足多样化的网络应用需求。</p></li></ol><h3 id="CAN-协议物理层和数据链路层"><a href="#CAN-协议物理层和数据链路层" class="headerlink" title="CAN 协议物理层和数据链路层"></a>CAN 协议物理层和数据链路层</h3><p>CAN 协议主要集中在重物理层和数据链路层</p><ul><li><strong>can 协议中的物理层</strong></li></ul><p>物理层负责定义信号的实际发送方式，采用 NRZ（非归零）编码，并在每 6 个位后插入填充位。</p><p>它还规定了位时序和采样数，用户可以根据需求进行选择。</p><p>同步通过同步段（SS）实现，并具备再同步功能。然而，信号电平、通信速度、采样点、驱动器和总线的电气特性以及连接器的形态等具体细节未在协议中定义，需要用户根据系统需求自行确定。</p><ul><li><strong>can 协议中的数据链路层</strong><ul><li>**MAC 子层（介质访问控制子层）**负责将数据组织成帧，包括数据帧、遥控帧、错误帧和过载帧。它还处理数据冲突时的仲裁，根据优先级决定哪个消息继续发送，并通过 ACK（确认）和 NACK（否定确认）进行应答。此外，MAC 子层检测并报告 CRC 错误、填充位错误、位错误、ACK 错误和格式错误，同时具备故障扩散抑制功能，能够自动区分暂时错误和持续错误，并排除故障节点。</li><li>**LLC 子层（逻辑链路控制子层）**则负责接收消息的选择，支持点到点连接、广播和组播它还提供错误恢复功能，在检测到错误时进行重发控制，确保数据的可靠传输</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155805985.png" alt="CAN" loading="lazy"></p><p>CAN 协议经过 ISO 标准化后，分为 ISO11898 和 ISO11519-2 两种标准。</p><p>这两个标准在数据链路层的定义是相同的，但在物理层有所不同：</p><ul><li>ISO11898 是通信速度为 125kbps-1Mbps的 CAN 高速通信标准</li><li>ISO11519-2 则是通信速度为 125kbps 以下的 CAN 低速通信标准。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155704268.png" alt=" ISO11898 和 ISO11519-2 两种标准" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155708078.png" alt="两种标准的对比" loading="lazy"></p><h1 id="启用-CAN"><a href="#启用-CAN" class="headerlink" title="启用 CAN"></a>启用 CAN</h1><h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">can0:</span> <span class="title class_">can@fe570000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-can-2.0&quot;</span><span class="punctuation">;</span> <span class="comment">// 指定设备兼容性字符串，用于匹配驱动程序</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe570000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 定义寄存器地址范围：基地址为 0xfe570000，长度为 0x1000 字节</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">1</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span> <span class="comment">// 定义中断信息：使用 GIC 的 SPI 中断，中断号为 1，触发类型为高电平</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> CLK_CAN0&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_CAN0&gt;</span><span class="punctuation">;</span> <span class="comment">// 定义时钟源：引用 CRU 节点中的 CLK_CAN0（波特率时钟）和 PCLK_CAN0（APB 总线时钟）</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;baudclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span> <span class="comment">// 为时钟信号命名：分别为波特率时钟和 APB 总线时钟</span></span><br><span class="line"><span class="attr">resets</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> SRST_CAN0&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> SRST_P_CAN0&gt;</span><span class="punctuation">;</span><span class="comment">// 定义复位信号：引用 CRU 节点中的 SRST_CAN0（主复位）和 SRST_P_CAN0（APB 复位）</span></span><br><span class="line"><span class="attr">reset-names</span> <span class="operator">=</span> <span class="string">&quot;can&quot;</span>, <span class="string">&quot;can-apb&quot;</span><span class="punctuation">;</span> <span class="comment">// 为复位信号命名：分别为 CAN 主复位和 APB 复位</span></span><br><span class="line"><span class="attr">tx-fifo-depth</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 定义发送 FIFO 深度：深度为 1，即一次只能存储一个待发送的消息</span></span><br><span class="line"><span class="attr">rx-fifo-depth</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">6</span>&gt;</span><span class="punctuation">;</span> <span class="comment">// 定义接收 FIFO 深度：深度为 6，即可以同时存储 6 个接收到的消息</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span> <span class="comment">// 定义设备初始状态：默认禁用，启动时不会启用该设备</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">can1:</span> <span class="title class_">can@fe580000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-can-2.0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe580000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">2</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> CLK_CAN1&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_CAN1&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;baudclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">resets</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> SRST_CAN1&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> SRST_P_CAN1&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reset-names</span> <span class="operator">=</span> <span class="string">&quot;can&quot;</span>, <span class="string">&quot;can-apb&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">tx-fifo-depth</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">rx-fifo-depth</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">6</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">can2:</span> <span class="title class_">can@fe590000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-can-2.0&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe590000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">3</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> CLK_CAN2&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_CAN2&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;baudclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">resets</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> SRST_CAN2&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> SRST_P_CAN2&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reset-names</span> <span class="operator">=</span> <span class="string">&quot;can&quot;</span>, <span class="string">&quot;can-apb&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">tx-fifo-depth</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">rx-fifo-depth</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">6</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>虽然这里有着 3 个 CAN 设备节点，但是在迅为的底板上因为引脚复用问题只有一个 CAN接口，对应的原理图部分如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260109155708618.png" alt="topeet RK3568 CAN1" loading="lazy"></p><p>可以看到在开发板上使用的是 CAN1，而在 <code>rk3568.dtsi</code> 设备树中 can1 节点的 status 设置的是 disabled，表示不使能，所以肯定是在其他设备树中有对该节点的追加:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//can接口</span></span><br><span class="line"><span class="variable">&amp;can1</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span><span class="comment">// 指定设备兼容性字符串</span></span><br><span class="line">        <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-can-2.0&quot;</span><span class="punctuation">;</span><span class="comment">// 设置设备状态为 &quot;okay&quot;，表示启用该设备</span></span><br><span class="line">        <span class="attr">assigned-clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> CLK_CAN1&gt;</span><span class="punctuation">;</span><span class="comment">// 分配时钟源：引用 CRU（Clock and Reset Unit）节点中的 CLK_CAN1。</span></span><br><span class="line">        <span class="attr">assigned-clock-rates</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">150000000</span>&gt;</span><span class="punctuation">;</span>  <span class="comment">//If can bitrate lower than 3M,the clock-rates should set 100M,else set 200M. // 设置分配的时钟频率为 150MHz，如果 CAN 波特率低于3Mbps，则建议将时钟频率设置为 100MHz；否则设置为 200MHz。</span></span><br><span class="line">        <span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span><span class="comment">// 定义引脚控制状态的名称，默认状态为 &quot;default&quot;。</span></span><br><span class="line">        pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;can1m1_pins</span>&gt;</span><span class="punctuation">;</span><span class="comment">// 引用引脚配置节点 &amp;can1m1_pins，定义 CAN1 的引脚复用和电气属性。</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>了设备树的使能之外，在内核配置文件种也要使能对应的驱动，具体路径如下所示：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Networking</span> sup<span class="keyword">port</span></span><br><span class="line">&gt; <span class="type">CAN</span> bus subsystem sup<span class="keyword">port</span></span><br><span class="line">&gt; <span class="type">CAN</span> <span class="type">Device</span> <span class="type">Drivers</span></span><br><span class="line">&lt;*&gt; <span class="type">Platform</span> <span class="type">CAN</span> drivers with <span class="type">Netlink</span> sup<span class="keyword">port</span></span><br></pre></td></tr></table></figure><h1 id="CAN工具的移植和使用"><a href="#CAN工具的移植和使用" class="headerlink" title="CAN工具的移植和使用"></a>CAN工具的移植和使用</h1><p><code>iproute2</code> 和 <code>can-utils</code> 是两个必不可少的工具。它们分别提供了对 CAN 接口的基础管理和高级操作功能，帮助我们轻松实现 CAN 总线的配置、测试和调试。</p><h2 id="iproute2-工具移植"><a href="#iproute2-工具移植" class="headerlink" title="iproute2 工具移植"></a>iproute2 工具移植</h2><p>iproute2 是一个用于网络管理的工具集，包含 ip、ss、tc 等命令，对应的源码压缩包可以在官网 进行下载</p><div class="tag link"><a class="link-card" title="iproute2" href="https://www.kernel.org/pub/linux/utils/net/iproute2/"><div class="left"><img src="https://www.kernel.org/theme/images/logos/favicon.png"/></div><div class="right"><p class="text">iproute2</p><p class="url">https://www.kernel.org/pub/linux/utils/net/iproute2/</p></div></a></div><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line"><span class="comment"># 修改configure生成的Makefile，修改下面这样为lib ip即编译使用ip这个工具</span></span><br><span class="line">SUBDIRS=lib ip</span><br><span class="line"></span><br><span class="line">make CC=/path/to/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x8</span><br><span class="line">6_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-gcc</span><br></pre></td></tr></table></figure><p>编译完成之后在 ip 目录下就会生成对应的可执行文件，将该文件拷贝到开发板上即可</p><h2 id="can-utils-工具移植"><a href="#can-utils-工具移植" class="headerlink" title="can utils 工具移植"></a>can utils 工具移植</h2><p>canutils 是一个常用的 CAN 通信测试工具包，包含 5 个独立的程序：canconfig、candump、canecho、cansend 和 cansequence，每个工具的介绍如下所示：</p><table><thead><tr><th align="center">工具名称</th><th align="center">功能描述</th><th align="center">主要配置项 &#x2F; 附加功能 &#x2F; 用途</th></tr></thead><tbody><tr><td align="center"><strong>canconfig</strong></td><td align="center">用于配置 CAN 总线接口的参数。</td><td align="center">波特率（Bitrate）<br />工作模式（Mode），如回环模式（Loopback）或正常模式（Normal）。</td></tr><tr><td align="center"><strong>candump</strong></td><td align="center">从 CAN 总线接口接收数据，并以十六进制形式打印到标准输出。</td><td align="center">可以将接收到的数据保存到指定文件中。</td></tr><tr><td align="center"><strong>canecho</strong></td><td align="center">将从 CAN 总线接口接收到的所有数据重新发送回 CAN 总线接口。</td><td align="center">用于测试 CAN 总线的回环功能。</td></tr><tr><td align="center"><strong>cansend</strong></td><td align="center">向指定的 CAN 总线接口发送指定的数据。</td><td align="center">数据以 CAN 帧格式发送，包括帧 ID 和帧数据。</td></tr><tr><td align="center"><strong>cansequence</strong></td><td align="center">向指定的 CAN 总线接口自动发送递增的数字序列；支持接收模式，可以校验接收到的递增数字是否正确。</td><td align="center">用于测试 CAN 总线的数据传输完整性和稳定性。</td></tr></tbody></table><p>由于 canutils 依赖于 libsocketcan 库，因此需要先编译 libsocketcan，然后再编译 canutils，libsocketcan对应源码链接：</p> <div class="tag link"><a class="link-card" title="libsocketcan" href="http://www.pengutronix.de/software/libsocketcan/download/"><div class="left"><img src="https://public.pengutronix.de/favicon.ico"/></div><div class="right"><p class="text">libsocketcan</p><p class="url">http://www.pengutronix.de/software/libsocketcan/download/</p></div></a></div><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ARCH=arm64</span><br><span class="line">$ <span class="built_in">export</span> CROSS_COMPILE=/path/to/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x8</span><br><span class="line">6_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-</span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/path/to/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x8</span><br><span class="line">6_64_aarch64-linux-gnu/bin/</span><br><span class="line"></span><br><span class="line">$ ./configure --host=aarch64-linux-gnu --prefix=/home/topeet/can/libsocketcan-0.0.12/out</span><br><span class="line"></span><br><span class="line">$ make &amp;&amp; make install</span><br><span class="line"><span class="comment"># 编译完成之后会在当前目录的 out 目录下生成对应的文件</span></span><br><span class="line">$ <span class="built_in">ls</span> out</span><br><span class="line">include lib share</span><br></pre></td></tr></table></figure><p>canutils 源码下载地址为</p> <div class="tag link"><a class="link-card" title="canutils" href="https://public.pengutronix.de/software/socket-can/canutils/v4.0/"><div class="left"><img src="https://public.pengutronix.de/favicon.ico"/></div><div class="right"><p class="text">canutils</p><p class="url">https://public.pengutronix.de/software/socket-can/canutils/v4.0/</p></div></a></div><p>解压后进入到对应的目录下，对 <code>config/autoconf/config.sub</code> 文件进行修改，分别添加以下内容，增加对 aarch64 的支持，修改完成如下所示：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| <span class="type">aarch64</span> | <span class="type">aarch64_be</span> \</span><br><span class="line">| <span class="type">aarch64</span>-* | <span class="type">aarch64_be</span>-* \</span><br></pre></td></tr></table></figure><p>然后对 configure 配置文件进行修改，将 2604 行编译器修改为 aarch64-linux-gnu-gcc，修改完成如下所示：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">at_ct_CC</span>=aarch64-linux-gnu-gcc</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ARCH=arm64</span><br><span class="line">$ <span class="built_in">export</span> CROSS_COMPILE=/path/to/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/aarch64-linux-gnu-</span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/topeet/work/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/</span><br><span class="line"></span><br><span class="line">$ ./configure \</span><br><span class="line">--host=aarch64-linux-gnu \</span><br><span class="line">--prefix=/path/to/canutils-4.0.6/out \</span><br><span class="line">libsocketcan_LIBS=<span class="string">&quot;-L/path/to/libsocketcan-0.0.12/out/lib -lsocketcan&quot;</span> \</span><br><span class="line">libsocketcan_LDFLAGS=<span class="string">&quot;-L/path/to/libsocketcan-0.0.12/out/lib&quot;</span> \</span><br><span class="line">libsocketcan_CFLAGS=<span class="string">&quot;-I/path/to/libsocketcan-0.0.12/out/include&quot;</span> \</span><br><span class="line">CFLAGS=<span class="string">&quot;-I/path/to/libsocketcan-0.0.12/out/include</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ make &amp;&amp; make install</span></span><br><span class="line"><span class="string">$ ls out/bin/</span></span><br><span class="line"><span class="string">candump canecho cansend cansequence</span></span><br></pre></td></tr></table></figure><h2 id="can工具使用"><a href="#can工具使用" class="headerlink" title="can工具使用"></a>can工具使用</h2><h3 id="设置-CAN-接囗的波特率"><a href="#设置-CAN-接囗的波特率" class="headerlink" title="设置 CAN 接囗的波特率"></a>设置 CAN 接囗的波特率</h3><p>CAN 接口的波特率可以通过 ip 命令设置,例如可以通过以下命令设置 CAN0 接口的波特率为250 k：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 <span class="built_in">type</span> can bitrate 250000</span><br></pre></td></tr></table></figure><h3 id="启动和关闭-CAN-接口"><a href="#启动和关闭-CAN-接口" class="headerlink" title="启动和关闭 CAN 接口"></a>启动和关闭 CAN 接口</h3><p>配置完 CAN 接口波特率之后，需要启动 CAN 接口才能使用。</p><ol><li>方法 1：使用 ifconfig 命令</li></ol><p>ifconfig 是传统的网络接口配置工具，可以通过以下命令启动 CAN 接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig can0 up</span><br></pre></td></tr></table></figure><p>关闭 CAN 接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig can0 down</span><br></pre></td></tr></table></figure><ol start="2"><li>方法 2：使用 ip 命令</li></ol><p>启动 CAN 接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 up</span><br></pre></td></tr></table></figure><p>关闭 CAN 接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can0 down</span><br></pre></td></tr></table></figure><h3 id="检查-CAN-接口状态"><a href="#检查-CAN-接口状态" class="headerlink" title="检查 CAN 接口状态"></a>检查 CAN 接口状态</h3><p>启动 CAN 接口后，可以使用 ifconfig 命令和 ip 命令检查其状态，</p><ol><li>使用 ifconfig 检查</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig can0</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 ip 命令检查</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -details <span class="built_in">link</span> show can0</span><br></pre></td></tr></table></figure><h3 id="使用-CAN-工具测试通信"><a href="#使用-CAN-工具测试通信" class="headerlink" title="使用 CAN 工具测试通信"></a>使用 CAN 工具测试通信</h3><h4 id="使用-candump-接收数据"><a href="#使用-candump-接收数据" class="headerlink" title="使用 candump 接收数据"></a><strong>使用 candump 接收数据</strong></h4><p>candump 用于从 CAN 总线接口接收数据，并以十六进制形式打印到标准输出。</p><p>命令格式：<code>candump &lt;接口&gt; [选项]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candump can0 -L &amp;</span><br></pre></td></tr></table></figure><h5 id="设置过滤规则"><a href="#设置过滤规则" class="headerlink" title="设置过滤规则"></a>设置过滤规则</h5><p>基本过滤公式分为两种：</p><ul><li><p><code>&lt;can id&gt;:&lt;can mask&gt;</code> 匹配特定的CAN帧</p><ul><li>表示当接收到的 CAN ID 满足条件 <code>&lt;received can id&gt; &amp; mask == can id &amp; mask</code> 时匹配。</li><li>mask 决定了哪些位需要参与匹配，只有对应位为 1 的部分才会被检查</li><li>can id 则是期望匹配的目标 ID。这种规则通常用于筛选符合特定 ID 和格式的帧，例如只接收某个标准帧或扩展帧。</li></ul></li><li><p><code>&lt;can id&gt;~&lt;can mask&gt;</code> 排除特定的CAN帧，与<code>&lt;can id&gt;:&lt;can mask&gt;</code> 正好相反，即忽略满足<br>条件的帧，而接收其他所有帧。</p><ul><li>表示当接收到的 CAN ID 满足条件<code>&lt;received can id&gt; &amp; mask != can id &amp; mask</code> 时匹配。</li></ul></li></ul><blockquote><ul><li><p>标准帧的 CAN ID 长度为 11 位，范围是 0x000 到 0x7FF，在过滤规则中，mask 的高 18 位通常设置为 0，表示不关<br>心扩展帧部分；</p></li><li><p>扩展帧的 CAN ID 长度为 29 位，范围是 0x00000000 到 0x1FFFFFFF，其过滤规则中，mask 的低 11 位可以灵活设置为 0 或 1，以决定是否同时匹配标准帧</p></li></ul></blockquote><p><strong>示例</strong></p><hr><p><strong>匹配特定扩展帧</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candump can0,12345678:1FFFFFFF</span><br></pre></td></tr></table></figure><ul><li>含义：只接收扩展帧，且 CAN ID 精确匹配 0x12345678。</li><li>解析：<ul><li>can id &#x3D; 0x12345678。</li><li>mask &#x3D; 0x1FFFFFFF（匹配所有 29 位，且要求是扩展帧）</li></ul></li></ul><hr><p><strong>匹配特定标准帧</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candump can0,123:C00007FF</span><br></pre></td></tr></table></figure><ul><li>含义：只接收标准帧，且 CAN ID 精确匹配 0x123。</li><li>解析：<ul><li>can id &#x3D; 0x123。</li><li>mask &#x3D; 0xC00007FF：高 18 位为 0xC0000（忽略扩展帧部分），低 11 位为 0x7FF（精确匹配标准帧 ID）。</li></ul></li></ul><hr><p><strong>匹配标准帧和远程帧</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candump can0,123:800007FF</span><br></pre></td></tr></table></figure><ul><li>含义：只接收标准帧或远程帧，且 CAN ID 精确匹配 0x123。</li><li>解析：<ul><li>can id &#x3D; 0x123</li><li>mask &#x3D; 0x800007FF：高 18 位为 0x80000（允许远程帧），低 11 位为 0x7FF（精确匹配标准帧 ID）。</li></ul></li></ul><hr><p><strong>排除特定扩展帧</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candump can0,12345678~1FFFFFFF</span><br></pre></td></tr></table></figure><ul><li>含义：排除扩展帧，且 CAN ID 精确匹配 0x12345678。</li><li>解析：<ul><li>can id &#x3D; 0x12345678。</li><li>mask &#x3D; 0x1FFFFFFF（匹配所有 29 位，且要求是扩展帧）。使用~表示排除匹配</li></ul></li></ul><hr><p><strong>多条匹配规则</strong></p><p>如果想要应用多条匹配规则，只需要通过逗号追加即可，例如只接收标准帧，且 CAN ID 精确匹配 0x123 和 0x456</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">candump can0,123:C00007FF,456:C00007FF</span><br></pre></td></tr></table></figure><h4 id="使用-cansend-发送数据"><a href="#使用-cansend-发送数据" class="headerlink" title="使用 cansend 发送数据"></a><strong>使用 cansend 发送数据</strong></h4><p>cansend 用于向 CAN 总线接口发送不同的帧，发送不同帧的示例如下</p><ul><li><strong>发送标准数据帧</strong></li><li>命令格式：<code>cansend &lt;接口&gt; &lt;帧 ID&gt;#&lt;数据&gt;</code><ul><li><code>&lt;接口&gt;</code>：CAN 接口名称（如 can0）。</li></ul></li><li><code>&lt;帧 ID&gt;</code>：CAN 帧的 ID（11 位，十六进制）。<ul><li><code>&lt;数据&gt;</code>：CAN 帧的数据（十六进制）。</li></ul></li><li>示例：can0 发送一个标准数据帧，ID 为 0x123，数据为 DE AD BE EF。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cansend can0 123#DEADBEE</span><br></pre></td></tr></table></figure><ul><li><strong>发送远程帧</strong><ul><li>命令格式：<code>cansend &lt;接口&gt; &lt;帧 ID&gt;#R</code></li><li><code>R</code>：表示远程帧。</li><li>示例：向 can0 发送一个标准远程帧，ID 为 0x123。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cansend can0 123#R</span><br></pre></td></tr></table></figure><ul><li><strong>发送扩展数据帧</strong><ul><li>命令格式：<code>cansend &lt;接口&gt; &lt;帧 ID&gt;#&lt;数据&gt;</code></li><li><code>&lt;帧 ID&gt;</code>：CAN 帧的 ID（29 位，十六进制）。</li><li>示例：向 can0 发送一个扩展数据帧，ID 为 0x00000123，数据为 12 34 56 78。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cansend can0 00000123#12345678</span><br></pre></td></tr></table></figure><ul><li><strong>发送扩展远程帧</strong><ul><li>命令格式：<code>cansend &lt;接口&gt; &lt;帧 ID&gt;#R</code></li><li>R：表示远程帧。</li><li>示例：向 can0 发送一个扩展远程帧，ID 为 0x00000123</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cansend can0 00000123#R</span><br></pre></td></tr></table></figure><h1 id="CAN应用编程"><a href="#CAN应用编程" class="headerlink" title="CAN应用编程"></a>CAN应用编程</h1><h2 id="创建socket套接字"><a href="#创建socket套接字" class="headerlink" title="创建socket套接字"></a>创建socket套接字</h2><p>socket 函数是网络编程中最基础的函数之一，用于创建一个套接字（socket）。</p><p><strong>套接字是网络通信的基本单元，它提供了进程间通信的机制</strong>。通过套接字，应用程序可以发送和接收数据包，从而实现网络通信。</p><p><code>socket()</code> 用于创建一个套接字（Socket），是进行网络通信的<strong>第一步</strong>。创建成功后返回的套接字描述符用于后续的 <code>bind</code>、<code>listen</code>、<code>connect</code>、<code>send</code>、<code>recv</code> 等操作。</p><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><ul><li><strong>成功</strong>：返回一个非负整数，表示套接字描述符（socket fd）</li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code></li></ul><p><strong>参数说明</strong></p><ol><li><code>domain</code> 协议族（地址族）</li></ol><p>指定通信所使用的协议族，决定<strong>地址格式和通信范围</strong>。常用取值：</p><table><thead><tr><th align="center">协议族</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">AF_UNIX</td><td align="center">用于本地通信（同一台机器上的进程间通信），也称为 AF_LOCAL。</td></tr><tr><td align="center">AF_INET</td><td align="center">IPv4 互联网协议族，用于基于 IPv4 的网络通信。</td></tr><tr><td align="center">AF_INET6</td><td align="center">IPv6 互联网协议族，用于基于 IPv6 的网络通信。</td></tr><tr><td align="center">AF_IPX</td><td align="center">Novell 的 IPX&#x2F;SPX 协议族，用于 Novell 网络。</td></tr><tr><td align="center">AF_NETLINK</td><td align="center">内核与用户空间之间的通信，用于接收内核事件通知。</td></tr><tr><td align="center">AF_X25</td><td align="center">ITU-T X.25&#x2F;ISO-8208 协议族，用于分组交换网络。</td></tr><tr><td align="center">AF_AX25</td><td align="center">业余无线电 AX.25 协议族，用于业余无线电通信。</td></tr><tr><td align="center">AF_ATMPVC</td><td align="center">用于访问原始 ATM PVCs（永久虚拟电路），ATM 是一种高速网络通信技术。</td></tr><tr><td align="center">AF_APPLETALK</td><td align="center">AppleTalk 协议族，用于连接 Mac 电脑和其他设备。</td></tr><tr><td align="center">AF_PACKET</td><td align="center">低级数据包接口，允许应用程序直接访问网络设备，发送和接收原始数据包。</td></tr><tr><td align="center">AF_ALG</td><td align="center">内核加密 API 的接口，允许应用程序使用内核提供的加密服务。</td></tr><tr><td align="center">PF_CAN</td><td align="center">用于 CAN（Controller Area Network）通信的协议族。</td></tr></tbody></table><ol start="2"><li><code>type</code> 套接字类型</li></ol><p>指定数据传输方式。常用取值：</p><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">SOCK_STREAM</td><td align="center">流式套接字，提供面向连接的、可靠的、双向的字节流通信（如 TCP）。</td></tr><tr><td align="center">SOCK_DGRAM</td><td align="center">数据报套接字，提供无连接的、不可靠的、固定长度的数据报通信（如 UDP）。</td></tr><tr><td align="center">SOCK_RAW</td><td align="center">原始套接字，允许直接访问底层协议（如 IP、ICMP）。</td></tr><tr><td align="center">SOCK_SEQPACKET</td><td align="center">提供面向连接的、可靠的、固定长度的数据报通信。</td></tr></tbody></table><ol start="3"><li><code>protocol</code> 协议类型</li></ol><p>指定具体使用的协议，通常设置为 <strong>0</strong>，由系统根据 <code>domain</code> 和 <code>type</code> 自动选择。常用取值：</p><table><thead><tr><th align="center">协议</th><th align="center">描述</th><th align="center">对应的 domain 和 type</th></tr></thead><tbody><tr><td align="center">IPPROTO_TCP</td><td align="center">TCP 协议，用于 SOCK_STREAM 类型</td><td align="center">AF_INET 或 AF_INET6, SOCK_STREAM</td></tr><tr><td align="center">IPPROTO_UDP</td><td align="center">UDP 协议，用于 SOCK_DGRAM 类型</td><td align="center">AF_INET 或 AF_INET6, SOCK_DGRAM</td></tr><tr><td align="center">IPPROTO_RAW</td><td align="center">原始协议，用于 SOCK_RAW 类型</td><td align="center">AF_INET 或 AF_INET6, SOCK_RAW</td></tr><tr><td align="center">CAN_RAW</td><td align="center">原始 CAN 协议，用于 CAN 总线通信</td><td align="center">PF_CAN, SOCK_RAW</td></tr><tr><td align="center">CAN_BCM</td><td align="center">广播管理协议，用于更复杂的 CAN 通信</td><td align="center">PF_CAN, SOCK_DGRAM</td></tr></tbody></table><p><strong>常见组合示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP IPv4 套接字</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UDP IPv4 套接字</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地进程通信</span></span><br><span class="line"><span class="type">int</span> fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始 CAN 套接字（最常用）</span></span><br><span class="line"><span class="type">int</span> fd = socket(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播管理（BCM）CAN 套接字</span></span><br><span class="line"><span class="type">int</span> fd = socket(PF_CAN, SOCK_DGRAM, CAN_BCM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ISO-TP（CAN 上的传输层）</span></span><br><span class="line"><span class="type">int</span> fd = socket(PF_CAN, SOCK_DGRAM, CAN_ISOTP);</span><br><span class="line"></span><br><span class="line"><span class="comment">// J1939（商用车协议）</span></span><br><span class="line"><span class="type">int</span> fd = socket(PF_CAN, SOCK_DGRAM, CAN_J1939);</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/raw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> sockfd;</span><br><span class="line"><span class="comment">// 创建 CAN 套接字</span></span><br><span class="line">sockfd = socket(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line"><span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;CAN socket created successfully\n&quot;</span>);</span><br><span class="line"><span class="comment">// 关闭套接字（可选）</span></span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bind-绑定套接字"><a href="#bind-绑定套接字" class="headerlink" title="bind 绑定套接字"></a>bind 绑定套接字</h2><p><strong>函数介绍</strong></p><p><code>bind()</code> 用于将一个套接字绑定到<strong>指定的本地地址</strong>。</p><p> 在网络编程中，它通常用于绑定 <strong>IP 地址和端口号</strong>； 在 <strong>CAN 通信</strong> 中，<code>bind()</code> 的主要作用是将套接字绑定到<strong>指定的 CAN 接口</strong>（如 <code>can0</code>），从而确定数据通过哪个 CAN 控制器进行收发。</p><p><code>bind()</code> 是 CAN Socket 通信的<strong>基础配置步骤之一</strong>，在进行数据收发前必须调用。</p><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><ul><li><strong>成功</strong>：返回 <code>0</code></li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code></li></ul><p><strong>参数说明</strong></p><ul><li><code>sockfd</code> 套接字描述符</li></ul><p>由 <code>socket()</code> 函数创建的套接字文件描述符，表示需要绑定的套接字。</p><ul><li><p><code>addr</code> 地址结构指针：指向要绑定的地址信息的结构体指针。在不同通信场景下，实际使用的结构体不同：</p><ul><li><p><strong>IPv4</strong>：<code>struct sockaddr_in</code></p></li><li><p><strong>IPv6</strong>：<code>struct sockaddr_in6</code></p></li><li><p><strong>CAN</strong>：<code>struct sockaddr_can</code></p></li></ul></li></ul><p>在调用 <code>bind()</code> 时，需要将其强制转换为 <code>struct sockaddr *</code> 类型。</p><ul><li><p><code>addrlen</code> 地址结构长度：表示 <code>addr</code> 所指向地址结构的大小，通常使用 <code>sizeof()</code> 计算：</p><ul><li><p>IPv4：<code>sizeof(struct sockaddr_in)</code></p></li><li><p>IPv6：<code>sizeof(struct sockaddr_in6)</code></p></li><li><p>CAN：<code>sizeof(struct sockaddr_can)</code></p></li></ul></li></ul><p>CAN 通信中的 bind 示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span></span><br><span class="line"></span><br><span class="line">addr.can_family  = AF_CAN;</span><br><span class="line">addr.can_ifindex = if_nametoindex(<span class="string">&quot;can0&quot;</span>);</span><br><span class="line"></span><br><span class="line">bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong></p><ul><li><code>can_family</code>：必须设置为 <code>AF_CAN</code></li><li><code>can_ifindex</code>：指定 CAN 接口索引（如 <code>can0</code>）</li><li>绑定后，该套接字只会在指定的 CAN 接口上通信</li></ul></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/raw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">int</span> sockfd; <span class="comment">// 套接字描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span> <span class="comment">// CAN 地址结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span> <span class="comment">// 用于获取网络接口信息</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 创建 CAN 套接字</span></span><br><span class="line">sockfd = socket(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定要绑定的 CAN 接口名称</span></span><br><span class="line"><span class="built_in">strncpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span>, IFNAMSIZ - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ioctl 获取 CAN 接口的索引号</span></span><br><span class="line">ioctl(sockfd, SIOCGIFINDEX, &amp;ifr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 CAN 地址结构体</span></span><br><span class="line">addr.can_family = AF_CAN; <span class="comment">// CAN 地址族</span></span><br><span class="line">addr.can_ifindex = ifr.ifr_ifindex; <span class="comment">// CAN 接口索引号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字到指定的 CAN 接口</span></span><br><span class="line">bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字（实际应用中可以继续发送/接收数据）</span></span><br><span class="line">close(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码使用 ioctl 系统调用通过 <code>SIOCGIFINDEX</code> 宏获取 CAN 接口的索引号，除了 <code>SIOCGIFINDEX</code> 宏之外，在网络设备中还有其他功能的宏，具体如下表所示：</p><table><thead><tr><th align="center">命令</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center"><strong>SIOCGIFADDR</strong></td><td align="center">获取网络接口的 IP 地址</td></tr><tr><td align="center"><strong>SIOCSIFADDR</strong></td><td align="center">设置网络接口的 IP 地址</td></tr><tr><td align="center"><strong>SIOCGIFNETMASK</strong></td><td align="center">获取网络接口的子网掩码</td></tr><tr><td align="center"><strong>SIOCSIFNETMASK</strong></td><td align="center">设置网络接口的子网掩码</td></tr><tr><td align="center"><strong>SIOCGIFBRDADDR</strong></td><td align="center">获取网络接口的广播地址</td></tr><tr><td align="center"><strong>SIOCSIFBRDADDR</strong></td><td align="center">设置网络接口的广播地址</td></tr><tr><td align="center"><strong>SIOCGIFDSTADDR</strong></td><td align="center">获取网络接口的目的地址（点对点接口的对端地址）</td></tr><tr><td align="center"><strong>SIOCSIFDSTADDR</strong></td><td align="center">设置网络接口的目的地址</td></tr><tr><td align="center"><strong>SIOCGIFHWADDR</strong></td><td align="center">获取网络接口的硬件地址（如 MAC 地址）</td></tr><tr><td align="center"><strong>SIOCSIFHWADDR</strong></td><td align="center">设置网络接口的硬件地址（通常不常用，因硬件地址多为固定）</td></tr><tr><td align="center"><strong>SIOCGIFINDEX</strong></td><td align="center">获取网络接口的索引号（系统分配的唯一标识）</td></tr><tr><td align="center"><strong>SIOCSIFMTU</strong></td><td align="center">设置网络接口的最大传输单元（MTU）</td></tr><tr><td align="center"><strong>SIOCGIFFLAGS</strong></td><td align="center">获取网络接口的标志（如是否启用、是否为广播接口等）</td></tr><tr><td align="center"><strong>SIOCSIFFLAGS</strong></td><td align="center">设置网络接口的标志</td></tr></tbody></table><h2 id="发送-接收数据"><a href="#发送-接收数据" class="headerlink" title="发送&#x2F;接收数据"></a>发送&#x2F;接收数据</h2><p>CAN 数据并不能直接发送，在发送之前需要进行封包的操作</p><h3 id="struct-can-frame"><a href="#struct-can-frame" class="headerlink" title="struct can_frame"></a>struct can_frame</h3><p>CAN 数据帧通常通过 <code>struct can_frame</code> 结构体来表示。这个结构体定义在<code>&lt;linux/can.h&gt;</code>头文件中，用于封装要发送的 CAN 数据。该结构体内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> &#123;</span></span><br><span class="line"><span class="type">canid_t</span> can_id; <span class="comment">// CAN 标识符（ID）</span></span><br><span class="line">__u8 can_dlc; <span class="comment">// 数据长度码（DLC），表示数据字段的长度（0 到 8 字节）</span></span><br><span class="line">__u8 data[<span class="number">8</span>]; <span class="comment">// 数据字段，最多 8 字节</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>can_id</code>：can_id 是一个 32 位无符号整数字段，用于表示 CAN 标识符（ID）。<ul><li>对于标准帧，can_id 的低 11 位表示标识符；</li><li>对于扩展帧，低 29 位表示标识符。</li><li>第 30 位用于标识是否为远程帧（通过 CAN_RTR_FLAG 标志）。</li><li>最高位（第 31 位）用于标识是否为扩展帧（通过 CAN_EFF_FLAG 标志），</li></ul></li><li><code>can_dlc</code>：can_dlc 是一个 8 位无符号整数字段，表示 CAN 数据帧中数据字段的长度。其取值范围为 0 到 8，对应经典 CAN 协议中最多支持的 8 字节数据长度。<ul><li>对于 CAN FD（Flexible Data-rate CAN），can_dlc 可以支持更大的数据长度（如 64 字节）。该字段决定了实际发送或接收的数据字节数，未使用的部分会被忽略。</li></ul></li><li><code>data</code>：data 是一个 8 字节数组字段，用于存储实际要发送或接收的数据内容。<ul><li>数据的实际长度由 can_dlc 字段决定，最大为 8 字节（经典 CAN）或更大（CAN FD）。</li><li>数组中未使用的部分不会被传输，因此在封装数据时只需填充有效字节即可。</li></ul></li></ul><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>[3];</span> <span class="comment">// CAN 帧数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">2</span>] = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>&#125;; <span class="comment">// 数据内容</span></span><br><span class="line"></span><br><span class="line">frame[<span class="number">0</span>].can_id = <span class="number">0x11</span>; <span class="comment">// 标准帧 ID</span></span><br><span class="line">frame[<span class="number">0</span>].can_dlc = <span class="number">2</span>; <span class="comment">// 数据长度（2 字节）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(frame[<span class="number">0</span>].data, data, <span class="number">2</span>); <span class="comment">// 填充数据</span></span><br><span class="line">frame[<span class="number">1</span>].can_id = <span class="number">0x11</span> | CAN_EFF_FLAG; <span class="comment">// 扩展帧 ID</span></span><br><span class="line">frame[<span class="number">1</span>].can_dlc = <span class="number">2</span>; <span class="comment">// 数据长度（2 字节）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(frame[<span class="number">1</span>].data, data, <span class="number">2</span>);<span class="comment">// 填充数据</span></span><br><span class="line"></span><br><span class="line">frame[<span class="number">2</span>].can_id = <span class="number">0x11</span> | CAN_RTR_FLAG; <span class="comment">// 远程帧 ID</span></span><br><span class="line">frame[<span class="number">2</span>].can_dlc = <span class="number">2</span>;<span class="comment">// 数据长度（2 字节）</span></span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/raw.h&gt;</span> <span class="comment">// 包含 CAN_RAW 相关定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">// 套接字描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span> <span class="comment">// CAN 地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span> <span class="comment">// 用于获取网络接口信息</span></span><br><span class="line">    <span class="type">int</span> ret; <span class="comment">// 用于存储系统调用返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 CAN 套接字</span></span><br><span class="line">    sockfd = socket(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定要绑定的 CAN 接口名称</span></span><br><span class="line">    <span class="built_in">strncpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span>, IFNAMSIZ - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ioctl 获取 CAN 接口的索引号</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(sockfd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ioctl failed&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 CAN 地址结构体</span></span><br><span class="line">    addr.can_family = AF_CAN; <span class="comment">// CAN 地址族</span></span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex; <span class="comment">// CAN 接口索引号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字到指定的 CAN 接口</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 CAN 帧数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>[3];</span> <span class="comment">// CAN 帧数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">2</span>] = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>&#125;; <span class="comment">// 数据内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化标准帧</span></span><br><span class="line">    frame[<span class="number">0</span>].can_id = <span class="number">0x11</span>; <span class="comment">// 标准帧 ID</span></span><br><span class="line">    frame[<span class="number">0</span>].can_dlc = <span class="number">2</span>;   <span class="comment">// 数据长度（2 字节）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(frame[<span class="number">0</span>].data, data, <span class="number">2</span>); <span class="comment">// 填充数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化扩展帧</span></span><br><span class="line">    frame[<span class="number">1</span>].can_id = <span class="number">0x11</span> | CAN_EFF_FLAG; <span class="comment">// 扩展帧 ID</span></span><br><span class="line">    frame[<span class="number">1</span>].can_dlc = <span class="number">2</span>;                 <span class="comment">// 数据长度（2 字节）</span></span><br><span class="line">    <span class="built_in">memcpy</span>(frame[<span class="number">1</span>].data, data, <span class="number">2</span>);       <span class="comment">// 填充数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化远程帧</span></span><br><span class="line">    frame[<span class="number">2</span>].can_id = <span class="number">0x11</span> | CAN_RTR_FLAG; <span class="comment">// 远程帧 ID</span></span><br><span class="line">    frame[<span class="number">2</span>].can_dlc = <span class="number">2</span>;                 <span class="comment">// 数据长度（2 字节）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环发送 CAN 帧</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送标准帧</span></span><br><span class="line">        ret = write(sockfd, &amp;frame[<span class="number">0</span>], <span class="keyword">sizeof</span>(frame[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(frame[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write (标准帧)&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;标准帧发送成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送扩展帧</span></span><br><span class="line">        ret = write(sockfd, &amp;frame[<span class="number">1</span>], <span class="keyword">sizeof</span>(frame[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(frame[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write (扩展帧)&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;扩展帧发送成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送远程帧</span></span><br><span class="line">        ret = write(sockfd, &amp;frame[<span class="number">2</span>], <span class="keyword">sizeof</span>(frame[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(frame[<span class="number">2</span>])) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;write (远程帧)&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;远程帧发送成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延时 1 秒</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/raw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 128 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span> <span class="comment">// CAN 地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span> <span class="comment">// 网络接口请求结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span> <span class="comment">// CAN 帧结构体</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE]; <span class="comment">// 格式化输出缓冲区</span></span><br><span class="line">    <span class="type">int</span> ret, n, i, err;</span><br><span class="line">    FILE *out = <span class="built_in">stdout</span>; <span class="comment">// 输出文件流（标准输出）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 CAN 套接字</span></span><br><span class="line">    sockfd = socket(PF_CAN, SOCK_RAW, CAN_RAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定 CAN 接口名称</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span>);</span><br><span class="line">    ioctl(sockfd, SIOCGIFINDEX, &amp;ifr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置地址信息</span></span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 CAN 接口</span></span><br><span class="line">    bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环接收 CAN 帧</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收 CAN 帧</span></span><br><span class="line">        ret = read(sockfd, &amp;frame, <span class="keyword">sizeof</span>(frame));</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化输出 CAN 帧信息</span></span><br><span class="line">        <span class="keyword">if</span> (frame.can_id &amp; CAN_EFF_FLAG) &#123;</span><br><span class="line">            <span class="comment">// 扩展帧</span></span><br><span class="line">            n = <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;&lt;0x%08x&gt;&quot;</span>, frame.can_id &amp; CAN_EFF_MASK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 标准帧</span></span><br><span class="line">            n = <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;&lt;0x%03x&gt;&quot;</span>, frame.can_id &amp; CAN_SFF_MASK);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据长度</span></span><br><span class="line">        n += <span class="built_in">snprintf</span>(buf + n, BUF_SIZE - n, <span class="string">&quot;[%d]&quot;</span>, frame.can_dlc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据内容</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame.can_dlc; i++) &#123;</span><br><span class="line">            n += <span class="built_in">snprintf</span>(buf + n, BUF_SIZE - n, <span class="string">&quot; %02x&quot;</span>, frame.data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是远程帧</span></span><br><span class="line">        <span class="keyword">if</span> (frame.can_id &amp; CAN_RTR_FLAG) &#123;</span><br><span class="line">            n += <span class="built_in">snprintf</span>(buf + n, BUF_SIZE - n, <span class="string">&quot; remote request&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出到标准输出</span></span><br><span class="line">        <span class="built_in">fprintf</span>(out, <span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新输出缓冲区</span></span><br><span class="line">        err = fflush(out);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fflush&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤规则的设置"><a href="#过滤规则的设置" class="headerlink" title="过滤规则的设置"></a>过滤规则的设置</h2><p>CAN 应用程序中的过滤规则设置需要用到 <code>setsockopt</code> 函数，<code>setsockopt</code> 的主要作用是配置CAN 套接字的过滤规则或其他特定选项。</p><p>通过设置这些选项，用户可以控制套接字的行为，例如筛选特定的 CAN 数据帧或调整通信模式。这是 CAN 通信中实现高效数据处理的重要步骤之一。</p><h3 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt()"></a>setsockopt()</h3><p><code>setsockopt()</code> 用于为套接字设置各种<strong>协议相关选项</strong>。在 <strong>CAN Socket 通信</strong> 中，它主要用于：</p><ul><li>设置 <strong>CAN 帧过滤规则</strong></li><li>控制是否接收错误帧</li><li>配置本地回环等行为</li></ul><p>其中最常用、也是 CAN 通信的核心配置之一是 <strong><code>CAN_RAW_FILTER</code></strong>，用于指定套接字<strong>接收哪些 CAN 帧</strong>。</p><p><strong>头文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>函数原型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> level,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">void</span> *optval,</span></span><br><span class="line"><span class="params">               <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><ul><li><strong>成功</strong>：返回 <code>0</code></li><li><strong>失败</strong>：返回 <code>-1</code>，并设置 <code>errno</code></li></ul><p><strong>参数说明</strong></p><ul><li><p><code>sockfd</code> 套接字描述符，由 <code>socket()</code> 创建的 CAN 套接字文件描述符，表示要配置的套接字。</p></li><li><p><code>level</code> 选项级别，指定选项所属的协议层级。CAN 通信中固定使用<code>SOL_CAN_RAW</code> 表示设置的是 <strong>原始 CAN 协议（CAN_RAW）相关选项</strong>。</p></li><li><p><code>optname</code> 具体选项名称，指定要设置的 CAN 套接字选项，常用选项包括：</p><ul><li><p><code>CAN_RAW_FILTER</code>，设置 CAN 数据帧的<strong>过滤规则</strong>（本章重点）</p></li><li><p><code>CAN_RAW_ERR_FILTER</code>，设置是否接收错误帧</p></li><li><p><code>CAN_RAW_LOOPBACK</code>，设置是否启用本地回环模式</p></li></ul></li><li><p><code>optval</code>选项值指针，指向选项数据的缓冲区。</p><ul><li>对于 <code>CAN_RAW_FILTER</code>，类型为 <code>struct can_filter *</code><ul><li>可为 <strong>单个过滤规则</strong></li><li>也可为 <strong>过滤规则数组</strong></li></ul></li></ul></li><li><p><code>optlen</code>选项值长度：表示 <code>optval</code> 缓冲区大小（字节数）：</p><ul><li><p>单个过滤规则：<code>sizeof(struct can_filter)</code></p></li><li><p>多个过滤规则：<code>sizeof(struct can_filter) * 规则数量</code></p></li></ul></li></ul><p>示例：</p><p><strong>只接收 ID 为 0x123 的标准帧</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">can_filter</span> <span class="title">filter</span>;</span></span><br><span class="line"></span><br><span class="line">filter.can_id   = <span class="number">0x123</span>;</span><br><span class="line">filter.can_mask = CAN_SFF_MASK;</span><br><span class="line"></span><br><span class="line">setsockopt(fd, SOL_CAN_RAW,</span><br><span class="line">           CAN_RAW_FILTER,</span><br><span class="line">           &amp;filter, <span class="keyword">sizeof</span>(filter));</span><br></pre></td></tr></table></figure><hr><p><strong>设置多个过滤规则</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">can_filter</span> <span class="title">filters</span>[2] =</span> &#123;</span><br><span class="line">    &#123; .can_id = <span class="number">0x100</span>, .can_mask = CAN_SFF_MASK &#125;,</span><br><span class="line">    &#123; .can_id = <span class="number">0x200</span>, .can_mask = CAN_SFF_MASK &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setsockopt(fd, SOL_CAN_RAW,</span><br><span class="line">           CAN_RAW_FILTER,</span><br><span class="line">           filters, <span class="keyword">sizeof</span>(filters));</span><br></pre></td></tr></table></figure><hr><p><strong>接收所有 CAN 帧（关闭过滤）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(fd, SOL_CAN_RAW,</span><br><span class="line">           CAN_RAW_FILTER,</span><br><span class="line">           <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="struct-can-filter"><a href="#struct-can-filter" class="headerlink" title="struct can_filter"></a>struct can_filter</h3><p>CAN 过滤规则结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">can_filter</span> &#123;</span></span><br><span class="line">    <span class="type">canid_t</span> can_id;    <span class="comment">// CAN ID + 标志位</span></span><br><span class="line">    <span class="type">canid_t</span> can_mask;  <span class="comment">// 掩码，决定哪些位参与匹配</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>can_id</code></p><ul><li><p>表示期望匹配的 CAN ID</p></li><li><p>可包含：</p><ul><li>标准帧 ID（11 位）</li><li>扩展帧 ID（29 位）</li><li>标志位（如 <code>CAN_EFF_FLAG</code>、<code>CAN_RTR_FLAG</code>）</li></ul></li></ul></li><li><p><code>can_mask</code></p><ul><li><p>用于指定 <strong>哪些位需要参与匹配</strong></p></li><li><p>某一位为：</p><ul><li><code>1</code>：该位必须匹配</li><li><code>0</code>：该位忽略</li></ul></li></ul></li></ul><h3 id="常用-CAN-掩码宏"><a href="#常用-CAN-掩码宏" class="headerlink" title="常用 CAN 掩码宏"></a>常用 CAN 掩码宏</h3><table><thead><tr><th align="center">掩码值</th><th align="center">含义</th><th align="center">示例代码与用途</th></tr></thead><tbody><tr><td align="center">CAN_SFF_MASK</td><td align="center">匹配标准帧的低 11 位（0x7FF），忽略扩展帧部分</td><td align="center"><code>can_id=0x123, can_mask=CAN_SFF_MASK</code><br />仅接收标准帧且 ID 精确匹配 0x123</td></tr><tr><td align="center">CAN_EFF_MASK</td><td align="center">匹配扩展帧的所有 29 位（0x1FFFFFFF）</td><td align="center"><code>can_id=0x12345678, can_mask=CAN_EFF_MASK</code><br />仅接收扩展帧且 ID 精确匹配 0x12345678</td></tr><tr><td align="center">CAN_EFF_FLAG</td><td align="center">匹配扩展帧标志位（第 30 位）</td><td align="center"><code>can_mask=CAN_EFF_FLAG</code><br />区分标准帧 &#x2F; 扩展帧，仅关注是否为扩展帧</td></tr><tr><td align="center">CAN_RTR_FLAG</td><td align="center">匹配远程帧标志位（第 31 位）</td><td align="center"><code>can_mask=CAN_RTR_FLAG</code><br />区分数据帧 &#x2F; 远程帧，仅关注是否为远程帧</td></tr><tr><td align="center">CAN_SFF_MASK | CAN_EFF_FLAG</td><td align="center">匹配标准帧低 11 位，区分是否为扩展帧</td><td align="center">&#96;can_id&#x3D;0x123, can_mask&#x3D;CAN_SFF_MASK</td></tr><tr><td align="center">CAN_EFF_MASK | CAN_RTR_FLAG</td><td align="center">匹配扩展帧 29 位，区分是否为远程帧</td><td align="center">&#96;can_id&#x3D;0x12345678, can_mask&#x3D;CAN_EFF_MASK</td></tr><tr><td align="center">CAN_SFF_MASK | CAN_RTR_FLAG</td><td align="center">匹配标准帧低 11 位，区分是否为远程帧</td><td align="center">&#96;can_id&#x3D;0x123, can_mask&#x3D;CAN_SFF_MASK</td></tr><tr><td align="center">CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG</td><td align="center">匹配标准帧低 11 位，区分是否为扩展帧和远程帧</td><td align="center">&#96;can_id&#x3D;0x123, can_mask&#x3D;CAN_SFF_MASK</td></tr><tr><td align="center">0xFFFFFFFF</td><td align="center">匹配所有 32 位（含标准帧、扩展帧、远程帧标志位）</td><td align="center"><code>can_id=0x123, can_mask=0xFFFFFFFF</code><br />精确匹配某个完整 CAN ID 和帧类型</td></tr><tr><td align="center">0x0</td><td align="center">忽略所有位，匹配所有帧（无过滤规则）</td><td align="center"><code>can_mask=0x0</code><br />接收所有帧，无过滤</td></tr></tbody></table><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/can/raw.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 128 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd; <span class="comment">// 套接字文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_can</span> <span class="title">addr</span>;</span> <span class="comment">// CAN 地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> <span class="title">ifr</span>;</span> <span class="comment">// 网络接口请求结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_frame</span> <span class="title">frame</span>;</span> <span class="comment">// CAN 帧结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">can_filter</span> <span class="title">rfilter</span>[2];</span> <span class="comment">// 过滤规则数组</span></span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE]; <span class="comment">// 格式化输出缓冲区</span></span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    FILE *out = <span class="built_in">stdout</span>; <span class="comment">// 输出文件流（标准输出）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 CAN 套接字</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(PF_CAN, SOCK_RAW, CAN_RAW)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Socket creation failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定 CAN 接口名称</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ifr.ifr_name, <span class="string">&quot;can0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ioctl(sockfd, SIOCGIFINDEX, &amp;ifr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl failed&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置地址信息</span></span><br><span class="line">    addr.can_family = AF_CAN;</span><br><span class="line">    addr.can_ifindex = ifr.ifr_ifindex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定 CAN 接口</span></span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Bind failed&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过滤规则</span></span><br><span class="line">    <span class="comment">// 第一条规则：只接收标准帧的数据帧，且 ID 精确匹配 0x123</span></span><br><span class="line">    rfilter[<span class="number">0</span>].can_id = <span class="number">0x123</span>; <span class="comment">// 目标 CAN ID</span></span><br><span class="line">    rfilter[<span class="number">0</span>].can_mask = CAN_SFF_MASK | CAN_EFF_FLAG | CAN_RTR_FLAG; <span class="comment">// 匹配标准帧，排除扩展帧和远程帧</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二条规则：只接收扩展帧的数据帧，且 ID 精确匹配 0x456</span></span><br><span class="line">    rfilter[<span class="number">1</span>].can_id = <span class="number">0x456</span>; <span class="comment">// 目标 CAN ID</span></span><br><span class="line">    rfilter[<span class="number">1</span>].can_mask = CAN_EFF_MASK | CAN_RTR_FLAG; <span class="comment">// 匹配扩展帧，排除远程帧</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用过滤规则</span></span><br><span class="line">    <span class="keyword">if</span> (setsockopt(sockfd, SOL_CAN_RAW, CAN_RAW_FILTER, &amp;rfilter, <span class="keyword">sizeof</span>(rfilter)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setsockopt failed&quot;</span>);</span><br><span class="line">        close(sockfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环接收 CAN 帧</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收 CAN 帧</span></span><br><span class="line">        <span class="keyword">if</span> (read(sockfd, &amp;frame, <span class="keyword">sizeof</span>(frame)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Read failed&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式化输出 CAN 帧信息</span></span><br><span class="line">        <span class="keyword">if</span> (frame.can_id &amp; CAN_EFF_FLAG) &#123;</span><br><span class="line">            <span class="comment">// 扩展帧</span></span><br><span class="line">            n = <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;&lt;0x%08x&gt;&quot;</span>, frame.can_id &amp; CAN_EFF_MASK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 标准帧</span></span><br><span class="line">            n = <span class="built_in">snprintf</span>(buf, BUF_SIZE, <span class="string">&quot;&lt;0x%03x&gt;&quot;</span>, frame.can_id &amp; CAN_SFF_MASK);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据长度</span></span><br><span class="line">        n += <span class="built_in">snprintf</span>(buf + n, BUF_SIZE - n, <span class="string">&quot;[%d]&quot;</span>, frame.can_dlc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加数据内容</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; frame.can_dlc; i++) &#123;</span><br><span class="line">            n += <span class="built_in">snprintf</span>(buf + n, BUF_SIZE - n, <span class="string">&quot; %02x&quot;</span>, frame.data[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是远程帧</span></span><br><span class="line">        <span class="keyword">if</span> (frame.can_id &amp; CAN_RTR_FLAG) &#123;</span><br><span class="line">            n += <span class="built_in">snprintf</span>(buf + n, BUF_SIZE - n, <span class="string">&quot; remote request&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出到标准输出</span></span><br><span class="line">        <span class="built_in">fprintf</span>(out, <span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新输出缓冲区</span></span><br><span class="line">        fflush(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux CAN</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Linux Watchdog</title>
    <link href="https://even629.com/posts/2601063/"/>
    <id>https://even629.com/posts/2601063/</id>
    <published>2026-01-06T05:09:00.000Z</published>
    <updated>2026-01-06T05:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2026-01-06</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="看门狗基础"><a href="#看门狗基础" class="headerlink" title="看门狗基础"></a>看门狗基础</h1><p><strong>看门狗（Watchdog Timer，简称 WDT）<strong>是嵌入式系统中</strong>基于定时器实现的硬件保护机制</strong>。</p><p>其核心构成是一个可编程计数器，通过周期性复位操作确保系统运行状态的可靠性。当系统遭遇异常情况时，比如电磁干扰导致程序跑飞，软件逻辑错误引发死循环，未知故障造成系统死锁，看门狗通过触发强制复位使系统恢复至初始状态，避免人工干预断电操作。</p><p>此机制显著提升了设备长期运行的稳定性。</p><blockquote><p>注意！虽然有看门狗，但是看门狗是最后的一道防线，所以在设计产品时要避免这些问题。</p></blockquote><p>运行流程如下所示：</p><ol><li>初始化配置</li></ol><p>设置看门狗的超时时间，使能看门狗定时器</p><ol start="2"><li>正常工作状态</li></ol><p>系统任务按时执行“投喂”动作（也就是主程序定期喂狗）每次投喂之后，计数器重置</p><ol start="2"><li>异常处理机制</li></ol><p>若系统失控，无法投喂（也就是程序会跑飞&#x2F;死锁），计数器归零时触发强制安全措施（也就是看门狗复位电路动作）系统恢复初始安全状态（也就是硬件复位）</p><p>现代处理器普遍采用 <strong>SoC 集成方案实现看门狗模块</strong>，以 iTOP-RK3568 开发平台为例，其芯片集成俩个看门狗，查看 RK3568 技术手册（TRM）如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260106130843819.png" alt="RK3568 Watchdog" loading="lazy"></p><p>在上图中，可以看到芯片中包含 WDT_NS 和 WDT_S 两个看门狗</p><h1 id="看门狗子系统框架"><a href="#看门狗子系统框架" class="headerlink" title="看门狗子系统框架"></a>看门狗子系统框架</h1><p>Linux 看门狗子系统采用经典三层架构设计，有效解耦用户接口，核心逻辑和硬件操作。看门狗子系统框架图如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260106130843935.png" alt="看门狗子系统框架" loading="lazy"></p><p>其中最上层为用户空间，第二层是内核空间，而第三层则为硬件层。</p><p>就看门狗而言，与之对应的硬件驱动程序便是看门狗设备驱动，此驱动<strong>属于字符设备驱动</strong>范畴。在 Linux 内核当中，针对看门狗驱动进行了一系列处理操作，具体包括封装以及归纳整理，进而形成了一个完整的框架。该框架主要由三个重要部分构成，分别是：</p><ul><li>负责与硬件直接交互的看门狗设备驱动层</li><li>承担核心逻辑处理的看门狗核心层</li><li>用于和用户空间进行交互的看门狗统一设备驱动层</li></ul><h2 id="watchdog-设备树配置"><a href="#watchdog-设备树配置" class="headerlink" title="watchdog 设备树配置"></a>watchdog 设备树配置</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">wdt:</span> <span class="title class_">watchdog@fe600000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;snps,dw-wdt&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe600000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> TCLK_WDT_NS&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_WDT_NS&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;tclk&quot;</span>, <span class="string">&quot;pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">149</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>compatible</code> 属性用于设备驱动的匹配</li><li><code>reg</code> 指定了看门狗寄存器的地址范围</li><li><code>clocks</code> 和 <code>clock-names</code> 定义了相关的时钟，<code>interrupts</code> 则配置了中断信息。</li></ul><h2 id="watchdog-设备驱动层"><a href="#watchdog-设备驱动层" class="headerlink" title="watchdog 设备驱动层"></a>watchdog 设备驱动层</h2><p>在 Linux 源码内核目录下搜索<code>snps,dw-wdt</code>找到 <code>drivers/watchdog/dw_wdt.c</code> 文件，此文件是 Watchdog 设备驱动层对应的驱动文件。<code>dw_wdt.c</code> 驱动文件如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">dw_wdt_driver</span> =</span> &#123;</span><br><span class="line">.probe= dw_wdt_drv_probe,</span><br><span class="line">.remove= dw_wdt_drv_remove,</span><br><span class="line">.driver= &#123;</span><br><span class="line">.name= <span class="string">&quot;dw_wdt&quot;</span>,</span><br><span class="line">.of_match_table = of_match_ptr(dw_wdt_of_match),</span><br><span class="line">.pm= &amp;dw_wdt_pm_ops,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(dw_wdt_driver);</span><br></pre></td></tr></table></figure><p><code>module_platform_driver(dw_wdt_driver)</code>宏将 <code>dw_wdt_driver</code> 注册为一个平台驱动</p><h3 id="dw-wdt-drv-probe"><a href="#dw-wdt-drv-probe" class="headerlink" title="dw_wdt_drv_probe()"></a>dw_wdt_drv_probe()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dw_wdt_drv_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取设备结构体指针，方便后续操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">    <span class="comment">// 定义指向看门狗设备结构体的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_device</span> *<span class="title">wdd</span>;</span></span><br><span class="line">    <span class="comment">// 定义指向 dw_wdt 结构体的指针，dw_wdt 结构体可能包含看门狗设备的特定信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dw_wdt</span> *<span class="title">dw_wdt</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 devm_kzalloc 函数分配内存，用于存储 dw_wdt 结构体</span></span><br><span class="line"><span class="comment">// dev 是设备结构体指针，用于提供内存分配的上下文</span></span><br><span class="line"><span class="comment">// sizeof(*dw_wdt) 是要分配的内存大小，即 dw_wdt 结构体的大小</span></span><br><span class="line"><span class="comment">// GFP_KERNEL 是内存分配标志，用于指定分配的内存类型（内核内存）</span></span><br><span class="line">dw_wdt = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*dw_wdt), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!dw_wdt)<span class="comment">// 如果内存分配失败，返回 -ENOMEM 错误码，表示内存不足</span></span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取设备的内存资源</span></span><br><span class="line">    <span class="comment">// 使用 devm_ioremap_resource 函数将内存资源映射到内核虚拟地址空间</span></span><br><span class="line">    <span class="comment">// dev 是设备结构体指针，mem 是要映射的内存资源</span></span><br><span class="line">dw_wdt-&gt;regs = devm_platform_ioremap_resource(pdev, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dw_wdt-&gt;regs))<span class="comment">// 如果映射失败，返回 PTR_ERR(dw_wdt-&gt;regs) 错误码</span></span><br><span class="line"><span class="keyword">return</span> PTR_ERR(dw_wdt-&gt;regs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Try to request the watchdog dedicated timer clock source. It must</span></span><br><span class="line"><span class="comment"> * be supplied if asynchronous mode is enabled. Otherwise fallback</span></span><br><span class="line"><span class="comment"> * to the common timer/bus clocks configuration, in which the very</span></span><br><span class="line"><span class="comment"> * first found clock supply both timer and APB signals.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 尝试请求看门狗专用的定时器时钟源。如果启用了异步模式，必须提供该时钟源。</span></span><br><span class="line"><span class="comment">* 否则，回退到通用定时器/总线时钟配置，在这种配置中，第一个找到的时钟同时为定时器和APB 信号提供时钟。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dw_wdt-&gt;clk = devm_clk_get(dev, <span class="string">&quot;tclk&quot;</span>);<span class="comment">// 获取名为 &quot;tclk&quot; 的时钟</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dw_wdt-&gt;clk)) &#123;<span class="comment">// 如果获取失败</span></span><br><span class="line">dw_wdt-&gt;clk = devm_clk_get(dev, <span class="literal">NULL</span>);<span class="comment">// 尝试获取默认时钟</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dw_wdt-&gt;clk))<span class="comment">// 如果再次失败，返回 PTR_ERR(dw_wdt-&gt;clk) 错误码</span></span><br><span class="line"><span class="keyword">return</span> PTR_ERR(dw_wdt-&gt;clk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = clk_prepare_enable(dw_wdt-&gt;clk);<span class="comment">// 准备并启用时钟</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">dw_wdt-&gt;rate = clk_get_rate(dw_wdt-&gt;clk);<span class="comment">// 获取时钟的速率</span></span><br><span class="line"><span class="keyword">if</span> (dw_wdt-&gt;rate == <span class="number">0</span>) &#123;<span class="comment">// 如果时钟速率为 0，设置错误码并跳转到 out_disable_clk 标签处进行清理</span></span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out_disable_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Request APB clock if device is configured with async clocks mode.</span></span><br><span class="line"><span class="comment"> * In this case both tclk and pclk clocks are supposed to be specified.</span></span><br><span class="line"><span class="comment"> * Alas we can&#x27;t know for sure whether async mode was really activated,</span></span><br><span class="line"><span class="comment"> * so the pclk phandle reference is left optional. If it couldn&#x27;t be</span></span><br><span class="line"><span class="comment"> * found we consider the device configured in synchronous clocks mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果设备配置为异步时钟模式，请求 APB 时钟。</span></span><br><span class="line"><span class="comment">* 在这种情况下，假设同时指定了 tclk 和 pclk 时钟。</span></span><br><span class="line"><span class="comment">* 遗憾的是，我们不能确定是否真的启用了异步模式，</span></span><br><span class="line"><span class="comment">* 所以 pclk 的 phandle 引用是可选的。如果找不到它，我们认为设备配置为同步时钟模式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 尝试获取名为 &quot;pclk&quot; 的时钟，devm_clk_get_optional 函数用于获取可选的时钟</span></span><br><span class="line">dw_wdt-&gt;pclk = devm_clk_get_optional(dev, <span class="string">&quot;pclk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dw_wdt-&gt;pclk)) &#123;<span class="comment">// 如果获取失败</span></span><br><span class="line">ret = PTR_ERR(dw_wdt-&gt;pclk);<span class="comment">// 设置错误码并跳转到 out_disable_clk 标签处进行清理</span></span><br><span class="line"><span class="keyword">goto</span> out_disable_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备并启用 APB 时钟</span></span><br><span class="line">ret = clk_prepare_enable(dw_wdt-&gt;pclk);</span><br><span class="line"><span class="keyword">if</span> (ret)<span class="comment">// 如果准备或启用 APB 时钟失败，跳转到 out_disable_clk 标签处进行清理</span></span><br><span class="line"><span class="keyword">goto</span> out_disable_clk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取复位控制对象，devm_reset_control_get_optional_shared 函数用于获取可选的共享复位控制对象</span></span><br><span class="line">dw_wdt-&gt;rst = devm_reset_control_get_optional_shared(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dw_wdt-&gt;rst)) &#123;<span class="comment">// 如果获取失败</span></span><br><span class="line">ret = PTR_ERR(dw_wdt-&gt;rst);<span class="comment">// 设置错误码并跳转到 out_disable_pclk 标签处进行清理</span></span><br><span class="line"><span class="keyword">goto</span> out_disable_pclk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable normal reset without pre-timeout by default. */</span></span><br><span class="line">dw_wdt_update_mode(dw_wdt, DW_WDT_RMOD_RESET);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pre-timeout IRQ is optional, since some hardware may lack support</span></span><br><span class="line"><span class="comment"> * of it. Note we must request rising-edge IRQ, since the lane is left</span></span><br><span class="line"><span class="comment"> * pending either until the next watchdog kick event or up to the</span></span><br><span class="line"><span class="comment"> * system reset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = platform_get_irq_optional(pdev, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = devm_request_irq(dev, ret, dw_wdt_irq,</span><br><span class="line">       IRQF_SHARED | IRQF_TRIGGER_RISING,</span><br><span class="line">       pdev-&gt;name, dw_wdt);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_disable_pclk;</span><br><span class="line"></span><br><span class="line">dw_wdt-&gt;wdd.info = &amp;dw_wdt_pt_ident;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line"><span class="keyword">goto</span> out_disable_pclk;</span><br><span class="line"></span><br><span class="line">dw_wdt-&gt;wdd.info = &amp;dw_wdt_ident;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放复位信号，使设备脱离复位状态</span></span><br><span class="line">reset_control_deassert(dw_wdt-&gt;rst);</span><br><span class="line"></span><br><span class="line">ret = dw_wdt_init_timeouts(dw_wdt, dev);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out_disable_clk;</span><br><span class="line"><span class="comment">// 将 dw_wdt 结构体中的 wdd 成员赋值给 wdd 指针</span></span><br><span class="line">wdd = &amp;dw_wdt-&gt;wdd;</span><br><span class="line">wdd-&gt;ops = &amp;dw_wdt_ops;<span class="comment">// 设置看门狗设备的操作函数集</span></span><br><span class="line">wdd-&gt;min_timeout = dw_wdt_get_min_timeout(dw_wdt);<span class="comment">// 设置看门狗设备的最小超时时间</span></span><br><span class="line">wdd-&gt;max_hw_heartbeat_ms = dw_wdt_get_max_timeout_ms(dw_wdt);<span class="comment">// 根据 dw_wdt 结构体和 DW_WDT_MAX_TOP 计算最大硬件心跳时间（以毫秒为单位）</span></span><br><span class="line">wdd-&gt;parent = dev;<span class="comment">// 设置看门狗设备的父设备</span></span><br><span class="line"></span><br><span class="line">watchdog_set_drvdata(wdd, dw_wdt);<span class="comment">// 将 dw_wdt 结构体与看门狗设备关联起来</span></span><br><span class="line">watchdog_set_nowayout(wdd, nowayout);<span class="comment">// 设置看门狗设备的 nowayout 属性，nowayout 可能用于控制看门狗的一些行为</span></span><br><span class="line">watchdog_init_timeout(wdd, <span class="number">0</span>, dev);<span class="comment">// 使用默认超时时间初始化看门狗设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the watchdog is already running, use its already configured</span></span><br><span class="line"><span class="comment"> * timeout. Otherwise use the default or the value provided through</span></span><br><span class="line"><span class="comment"> * devicetree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果看门狗已经在运行，使用其已配置的超时时间。</span></span><br><span class="line"><span class="comment">* 否则，使用默认值或通过设备树提供的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (dw_wdt_is_enabled(dw_wdt)) &#123;<span class="comment">// 检查看门狗是否已经启用</span></span><br><span class="line">        <span class="comment">// 如果已经启用，获取当前的超时时间并设置到看门狗设备中</span></span><br><span class="line">wdd-&gt;timeout = dw_wdt_get_timeout(dw_wdt);</span><br><span class="line">        <span class="comment">// 设置看门狗设备的状态位，表示硬件正在运行</span></span><br><span class="line">set_bit(WDOG_HW_RUNNING, &amp;wdd-&gt;status);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果未启用，设置默认超时时间</span></span><br><span class="line">wdd-&gt;timeout = DW_WDT_DEFAULT_SECONDS;</span><br><span class="line">        <span class="comment">// 使用默认超时时间重新初始化看门狗设备</span></span><br><span class="line">watchdog_init_timeout(wdd, <span class="number">0</span>, dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 dw_wdt 结构体与平台设备关联起来</span></span><br><span class="line">platform_set_drvdata(pdev, dw_wdt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置看门狗设备的重启优先级为 128</span></span><br><span class="line">watchdog_set_restart_priority(wdd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册看门狗设备</span></span><br><span class="line">ret = watchdog_register_device(wdd);</span><br><span class="line"><span class="keyword">if</span> (ret)<span class="comment">// 如果注册失败，跳转到 out_disable_pclk 标签处进行清理</span></span><br><span class="line"><span class="keyword">goto</span> out_disable_pclk;</span><br><span class="line"></span><br><span class="line">dw_wdt_dbgfs_init(dw_wdt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_disable_pclk:</span><br><span class="line">clk_disable_unprepare(dw_wdt-&gt;pclk);</span><br><span class="line"></span><br><span class="line">out_disable_clk:</span><br><span class="line">clk_disable_unprepare(dw_wdt-&gt;clk);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="struct-watchdog-device"><a href="#struct-watchdog-device" class="headerlink" title="struct watchdog_device"></a>struct watchdog_device</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** struct watchdog_device - The structure that defines a watchdog device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @id:The watchdog&#x27;s ID. (Allocated by watchdog_register_device)</span></span><br><span class="line"><span class="comment"> * @parent:The parent bus device</span></span><br><span class="line"><span class="comment"> * @groups:List of sysfs attribute groups to create when creating the</span></span><br><span class="line"><span class="comment"> *watchdog device.</span></span><br><span class="line"><span class="comment"> * @info:Pointer to a watchdog_info structure.</span></span><br><span class="line"><span class="comment"> * @ops:Pointer to the list of watchdog operations.</span></span><br><span class="line"><span class="comment"> * @gov:Pointer to watchdog pretimeout governor.</span></span><br><span class="line"><span class="comment"> * @bootstatus:Status of the watchdog device at boot.</span></span><br><span class="line"><span class="comment"> * @timeout:The watchdog devices timeout value (in seconds).</span></span><br><span class="line"><span class="comment"> * @pretimeout: The watchdog devices pre_timeout value.</span></span><br><span class="line"><span class="comment"> * @min_timeout:The watchdog devices minimum timeout value (in seconds).</span></span><br><span class="line"><span class="comment"> * @max_timeout:The watchdog devices maximum timeout value (in seconds)</span></span><br><span class="line"><span class="comment"> *as configurable from user space. Only relevant if</span></span><br><span class="line"><span class="comment"> *max_hw_heartbeat_ms is not provided.</span></span><br><span class="line"><span class="comment"> * @min_hw_heartbeat_ms:</span></span><br><span class="line"><span class="comment"> *Hardware limit for minimum time between heartbeats,</span></span><br><span class="line"><span class="comment"> *in milli-seconds.</span></span><br><span class="line"><span class="comment"> * @max_hw_heartbeat_ms:</span></span><br><span class="line"><span class="comment"> *Hardware limit for maximum timeout, in milli-seconds.</span></span><br><span class="line"><span class="comment"> *Replaces max_timeout if specified.</span></span><br><span class="line"><span class="comment"> * @reboot_nb:The notifier block to stop watchdog on reboot.</span></span><br><span class="line"><span class="comment"> * @restart_nb:The notifier block to register a restart function.</span></span><br><span class="line"><span class="comment"> * @driver_data:Pointer to the drivers private data.</span></span><br><span class="line"><span class="comment"> * @wd_data:Pointer to watchdog core internal data.</span></span><br><span class="line"><span class="comment"> * @status:Field that contains the devices internal status bits.</span></span><br><span class="line"><span class="comment"> * @deferred:Entry in wtd_deferred_reg_list which is used to</span></span><br><span class="line"><span class="comment"> *register early initialized watchdogs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The watchdog_device structure contains all information about a</span></span><br><span class="line"><span class="comment"> * watchdog timer device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The driver-data field may not be accessed directly. It must be accessed</span></span><br><span class="line"><span class="comment"> * via the watchdog_set_drvdata and watchdog_get_drvdata helpers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_device</span> &#123;</span><span class="comment">// 定义表示看门狗设备的结构体</span></span><br><span class="line"><span class="type">int</span> id;<span class="comment">// 设备唯一标识符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">parent</span>;</span><span class="comment">// 指向父设备的指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span><span class="comment">// 指向属性组数组的指针，用于管理设备属性</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchdog_info</span> *<span class="title">info</span>;</span><span class="comment">// 指向包含设备详细信息的结构体指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchdog_ops</span> *<span class="title">ops</span>;</span><span class="comment">// 指向包含设备操作函数的结构体指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchdog_governor</span> *<span class="title">gov</span>;</span><span class="comment">// 指向监管相关结构体指针，可能用于调控设备运行</span></span><br><span class="line">    <span class="comment">// 启动状态标志，具体含义由其他部分定义</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bootstatus;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> timeout;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pretimeout;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> min_timeout;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_timeout;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> min_hw_heartbeat_ms;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_hw_heartbeat_ms;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">reboot_nb</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">restart_nb</span>;</span></span><br><span class="line"><span class="type">void</span> *driver_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_core_data</span> *<span class="title">wd_data</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> status;</span><br><span class="line"><span class="comment">/* Bit numbers for status flags */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WDOG_ACTIVE0<span class="comment">/* Is the watchdog running/active */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WDOG_NO_WAY_OUT1<span class="comment">/* Is &#x27;nowayout&#x27; feature set ? */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WDOG_STOP_ON_REBOOT2<span class="comment">/* Should be stopped on reboot */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WDOG_HW_RUNNING3<span class="comment">/* True if HW watchdog running */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WDOG_STOP_ON_UNREGISTER4<span class="comment">/* Should be stopped on unregister */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="struct-watchdog-info"><a href="#struct-watchdog-info" class="headerlink" title="struct watchdog_info"></a>struct watchdog_info</h5><p><code>watchdog_info</code> 成员指向一个包含看门狗设备详细信息的结构体，结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 watchdog_info 的结构体，用于存储看门狗设备的相关特定信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_info</span> &#123;</span></span><br><span class="line">    <span class="comment">// 用于存储看门狗设备或其驱动所支持的选项标志位信息</span></span><br><span class="line"><span class="comment">// 通过不同的位设置来表示支持的各种功能、特性或工作模式等</span></span><br><span class="line">__u32 options;<span class="comment">/* Options the card/driver supports */</span></span><br><span class="line">    <span class="comment">// 用于存储看门狗设备的固件版本号</span></span><br><span class="line"><span class="comment">// 随着设备固件的更新，该版本号会相应改变，以便区分不同版本的固件</span></span><br><span class="line">__u32 firmware_version;<span class="comment">/* Firmware version of the card */</span></span><br><span class="line">    <span class="comment">// 用于存储能够标识该看门狗设备所在电路板或设备本身的字符串信息</span></span><br><span class="line"><span class="comment">// 最多可存储 32 个字节的字符内容，用于唯一识别该设备，比如设备名称、型号等</span></span><br><span class="line">__u8  identity[<span class="number">32</span>];<span class="comment">/* Identity of the board */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="struct-watchdog-ops"><a href="#struct-watchdog-ops" class="headerlink" title="struct watchdog_ops"></a>struct watchdog_ops</h5><p><code>watchdog_ops</code> 成员指向一个包含看门狗设备各种操作函数的结构体，结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** struct watchdog_ops - The watchdog-devices operations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @owner:The module owner.</span></span><br><span class="line"><span class="comment"> * @start:The routine for starting the watchdog device.</span></span><br><span class="line"><span class="comment"> * @stop:The routine for stopping the watchdog device.</span></span><br><span class="line"><span class="comment"> * @ping:The routine that sends a keepalive ping to the watchdog device.</span></span><br><span class="line"><span class="comment"> * @status:The routine that shows the status of the watchdog device.</span></span><br><span class="line"><span class="comment"> * @set_timeout:The routine for setting the watchdog devices timeout value (in seconds).</span></span><br><span class="line"><span class="comment"> * @set_pretimeout:The routine for setting the watchdog devices pretimeout.</span></span><br><span class="line"><span class="comment"> * @get_timeleft:The routine that gets the time left before a reset (in seconds).</span></span><br><span class="line"><span class="comment"> * @restart:The routine for restarting the machine.</span></span><br><span class="line"><span class="comment"> * @ioctl:The routines that handles extra ioctl calls.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The watchdog_ops structure contains a list of low-level operations</span></span><br><span class="line"><span class="comment"> * that control a watchdog device. It also contains the module that owns</span></span><br><span class="line"><span class="comment"> * these operations. The start function is mandatory, all other</span></span><br><span class="line"><span class="comment"> * functions are optional.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">// 指向拥有此操作函数集的模块指针，通常用于模块引用计数等管理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* mandatory operations */</span></span><br><span class="line">    <span class="comment">/* 以下是必须实现的操作函数指针 */</span></span><br><span class="line"><span class="type">int</span> (*start)(<span class="keyword">struct</span> watchdog_device *); <span class="comment">//启动看门狗设备的函数指针，传入指向看门狗设备结构体的指针，返回操作结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* optional operations */</span></span><br><span class="line">    <span class="comment">/* 以下是可选实现的操作函数指针 */</span></span><br><span class="line"><span class="type">int</span> (*stop)(<span class="keyword">struct</span> watchdog_device *);<span class="comment">// 停止看门狗设备的函数指针，传入指向看门狗设备结构体的指针，返回操作结果</span></span><br><span class="line"><span class="type">int</span> (*ping)(<span class="keyword">struct</span> watchdog_device *);<span class="comment">// 执行喂狗操作的函数指针，传入指向看门狗设备结构体的指针，返回操作结果</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*status)</span><span class="params">(<span class="keyword">struct</span> watchdog_device *)</span>;<span class="comment">// 获取看门狗设备当前状态的函数指针，传入指向看门狗设备结构体的指针，返回状态值</span></span><br><span class="line"><span class="type">int</span> (*set_timeout)(<span class="keyword">struct</span> watchdog_device *, <span class="type">unsigned</span> <span class="type">int</span>);<span class="comment">// 设置看门狗设备超时时间的函数指针，传入指向看门狗设备结构体的指针和新的超时时间值，返回操作结果</span></span><br><span class="line"><span class="type">int</span> (*set_pretimeout)(<span class="keyword">struct</span> watchdog_device *, <span class="type">unsigned</span> <span class="type">int</span>);<span class="comment">// 设置看门狗设备预超时时间的函数指针，传入指向看门狗设备结构体的指针和新的预超时时间值，返回操作结果</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_timeleft)</span><span class="params">(<span class="keyword">struct</span> watchdog_device *)</span>;<span class="comment">// 获取看门狗设备剩余时间的函数指针，传入指向看门狗设备结构体的指针，返回剩余时间值</span></span><br><span class="line"><span class="type">int</span> (*restart)(<span class="keyword">struct</span> watchdog_device *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">void</span> *);<span class="comment">// 重启看门狗设备的函数指针，传入指向看门狗设备结构体的指针、重启相关参数等，返回操作结果</span></span><br><span class="line"><span class="type">long</span> (*ioctl)(<span class="keyword">struct</span> watchdog_device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">// 处理 ioctl 系统调用的函数指针，传入指向看门狗设备结构体的指针、ioctl 命令码及参数等，返回处理结果</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="struct-watchdog-governor"><a href="#struct-watchdog-governor" class="headerlink" title="struct watchdog_governor"></a>struct watchdog_governor</h5><p><code>watchdog_governor</code> 成员指向一个用于对看门狗设备的运行进行某种管理和调控的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_governor</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>name[WATCHDOG_GOV_NAME_MAXLEN];</span><br><span class="line"><span class="type">void</span>(*pretimeout)(<span class="keyword">struct</span> watchdog_device *wdd);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>pretimeout</code> 函数指针所指向的函数主要用于在看门狗设备即将达到超时时间之前执行特定的操作。</p><p>通常情况下，看门狗设备会设置一个超时时间，当在这个规定时间内没有进行相应的“喂狗”操作（即重置定时器等相关操作，以表明系统正常运行）时，看门狗会触发一些动作，比如复位系统等。而 <strong><code>pretimeout</code> 函数所指向的函数就是在接近这个超时时间的某个前置阶段（预超时阶段）被调用，来执行一些提前的处理动作</strong>。</p><h4 id="struct-dw-wdt"><a href="#struct-dw-wdt" class="headerlink" title="struct dw_wdt"></a>struct dw_wdt</h4><p><code>dw_wdt_drv_probe</code> 函数中定义了一个指向自定义的 <code>struct dw_wdt</code> 类型的指针 <code>dw_wdt</code>，该结构体包含了与这个特定看门狗设备相关的一些特定信息，结构体如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义名为 dw_wdt 的结构体，用于存储与特定看门狗设备相关的各种信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dw_wdt</span> &#123;</span></span><br><span class="line"><span class="comment">// 指向设备寄存器的内存映射地址，通过此指针可访问设备的寄存器</span></span><br><span class="line"><span class="type">void</span> __iomem*regs;</span><br><span class="line">    <span class="comment">// 指向主时钟源的指针，用于获取设备的主时钟信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span>*<span class="title">clk</span>;</span></span><br><span class="line">    <span class="comment">// 指向 APB 时钟源的指针，可能用于与 APB 相关的时钟操作（具体取决于设备）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span>*<span class="title">pclk</span>;</span></span><br><span class="line">    <span class="comment">// 存储时钟频率相关的值，可能是当前设备所使用的时钟频率等信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>rate;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">dw_wdt_rmod</span><span class="title">rmod</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dw_wdt_timeout</span><span class="title">timeouts</span>[<span class="title">DW_WDT_NUM_TOPS</span>];</span></span><br><span class="line">    <span class="comment">// 包含看门狗设备通用信息和操作函数等的结构体，用于管理看门狗设备的基本属性和操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_device</span><span class="title">wdd</span>;</span></span><br><span class="line">    <span class="comment">// 指向复位控制结构体的指针，用于对设备进行复位相关的操作和控制</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reset_control</span>*<span class="title">rst</span>;</span></span><br><span class="line"><span class="comment">/* Save/restore */</span> <span class="comment">/* 以下成员可能用于保存和恢复设备的某些状态信息 */</span></span><br><span class="line">u32control;<span class="comment">// 存储设备的控制相关信息</span></span><br><span class="line">u32timeout;<span class="comment">// 存储设备的超时设置相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>*<span class="title">dbgfs_dir</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="watchdog核心层"><a href="#watchdog核心层" class="headerlink" title="watchdog核心层"></a>watchdog核心层</h2><h3 id="watchdog-register-device"><a href="#watchdog-register-device" class="headerlink" title="watchdog_register_device()"></a>watchdog_register_device()</h3><p>上面probe函数<code>dw_wdt_drv_probe()</code>中使用 <code>watchdog_register_device()</code> 函数对 <code>wdd</code> 指针所指向的 <code>struct watchdog_device</code> 结构体进行注册操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * watchdog_register_device() - register a watchdog device</span></span><br><span class="line"><span class="comment"> * @wdd: watchdog device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register a watchdog device with the kernel so that the</span></span><br><span class="line"><span class="comment"> * watchdog timer can be accessed from userspace.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A zero is returned on success and a negative errno code for</span></span><br><span class="line"><span class="comment"> * failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">watchdog_register_device</span><span class="params">(<span class="keyword">struct</span> watchdog_device *wdd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *dev_str;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;wtd_deferred_reg_mutex);</span><br><span class="line"><span class="keyword">if</span> (wtd_deferred_reg_done)<span class="comment">//如果 wtd_deferred_reg_done 为真，则执行__watchdog_register_device(wdd)函数</span></span><br><span class="line">ret = __watchdog_register_device(wdd);</span><br><span class="line"><span class="keyword">else</span><span class="comment">// 否则执行watchdog_deferred_registration_add(wdd);</span></span><br><span class="line">watchdog_deferred_registration_add(wdd);</span><br><span class="line">mutex_unlock(&amp;wtd_deferred_reg_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_str = wdd-&gt;parent ? dev_name(wdd-&gt;parent) :</span><br><span class="line">  (<span class="type">const</span> <span class="type">char</span> *)wdd-&gt;info-&gt;identity;</span><br><span class="line">pr_err(<span class="string">&quot;%s: failed to register watchdog device (err = %d)\n&quot;</span>,</span><br><span class="line">dev_str, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(watchdog_register_device);</span><br></pre></td></tr></table></figure><h4 id="watchdog-deferred-registration"><a href="#watchdog-deferred-registration" class="headerlink" title="watchdog_deferred_registration()"></a>watchdog_deferred_registration()</h4><p>在 <code>drivers/watchdog/watchdog_core.c</code> 文件中的 <code>watchdog_deferred_registration()</code> 函数中发现 <code>wtd_deferred_reg_done</code> 为 true</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">watchdog_deferred_registration</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">mutex_lock(&amp;wtd_deferred_reg_mutex);</span><br><span class="line">wtd_deferred_reg_done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!list_empty(&amp;wtd_deferred_reg_list)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_device</span> *<span class="title">wdd</span>;</span></span><br><span class="line"></span><br><span class="line">wdd = list_first_entry(&amp;wtd_deferred_reg_list,</span><br><span class="line">       <span class="keyword">struct</span> watchdog_device, deferred);</span><br><span class="line">list_del(&amp;wdd-&gt;deferred);</span><br><span class="line">__watchdog_register_device(wdd);</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;wtd_deferred_reg_mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而该函数由<code>watchdog_core.c</code>的初始化函数调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">watchdog_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">err = watchdog_dev_init();</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">watchdog_deferred_registration();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">watchdog_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">watchdog_dev_exit();</span><br><span class="line">ida_destroy(&amp;watchdog_ida);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subsys_initcall_sync(watchdog_init);</span><br><span class="line">module_exit(watchdog_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Wim Van Sebroeck &lt;wim@iguana.be&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;WatchDog Timer Driver Core&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>即，如果<code>watchdog_core.c</code>这个模块未加载，则延迟加载，<code>watchdog_register_device()</code>调用<code>watchdog_deferred_registration_add(wdd);</code></p><h4 id="watchdog-register-device-1"><a href="#watchdog-register-device-1" class="headerlink" title="__watchdog_register_device()"></a>__watchdog_register_device()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __watchdog_register_device(<span class="keyword">struct</span> watchdog_device *wdd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret, id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数有效性检查</span></span><br><span class="line"><span class="keyword">if</span> (wdd == <span class="literal">NULL</span> || wdd-&gt;info == <span class="literal">NULL</span> || wdd-&gt;ops == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mandatory operations need to be supported */</span></span><br><span class="line">    <span class="comment">// 操作函数校验（必须实现 start 和 stop/max_hw_heartbeat_ms</span></span><br><span class="line"><span class="keyword">if</span> (!wdd-&gt;ops-&gt;start || (!wdd-&gt;ops-&gt;stop &amp;&amp; !wdd-&gt;max_hw_heartbeat_ms))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查超时时间的合法性</span></span><br><span class="line">watchdog_check_min_max_timeout(wdd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: now that all watchdog_device data has been verified, we</span></span><br><span class="line"><span class="comment"> * will not check this anymore in other functions. If data gets</span></span><br><span class="line"><span class="comment"> * corrupted in a later stage then we expect a kernel panic!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use alias for watchdog id if possible */</span></span><br><span class="line"><span class="keyword">if</span> (wdd-&gt;parent) &#123;<span class="comment">// 获取 watchdog ID（优先使用设备树别名）</span></span><br><span class="line">ret = of_alias_get_id(wdd-&gt;parent-&gt;of_node, <span class="string">&quot;watchdog&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">id = ida_simple_get(&amp;watchdog_ida, ret,</span><br><span class="line">    ret + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)<span class="comment">// 分配 ID 失败时的处理</span></span><br><span class="line">id = ida_simple_get(&amp;watchdog_ida, <span class="number">0</span>, MAX_DOGS, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">wdd-&gt;id = id;</span><br><span class="line"></span><br><span class="line">ret = watchdog_dev_register(wdd);<span class="comment">// 注册 watchdog 字符设备</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">ida_simple_remove(&amp;watchdog_ida, id);</span><br><span class="line"><span class="keyword">if</span> (!(id == <span class="number">0</span> &amp;&amp; ret == -EBUSY))</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Retry in case a legacy watchdog module exists */</span></span><br><span class="line">        <span class="comment">// 处理旧版驱动冲突的特殊情况（id=0 时可能被占用）</span></span><br><span class="line">id = ida_simple_get(&amp;watchdog_ida, <span class="number">1</span>, MAX_DOGS, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">wdd-&gt;id = id;</span><br><span class="line"></span><br><span class="line">ret = watchdog_dev_register(wdd);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">ida_simple_remove(&amp;watchdog_ida, id);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Module parameter to force watchdog policy on reboot. */</span></span><br><span class="line"><span class="keyword">if</span> (stop_on_reboot != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (stop_on_reboot)</span><br><span class="line">set_bit(WDOG_STOP_ON_REBOOT, &amp;wdd-&gt;status);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">clear_bit(WDOG_STOP_ON_REBOOT, &amp;wdd-&gt;status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册系统重启通知回调</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(WDOG_STOP_ON_REBOOT, &amp;wdd-&gt;status)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!wdd-&gt;ops-&gt;stop)</span><br><span class="line">pr_warn(<span class="string">&quot;watchdog%d: stop_on_reboot not supported\n&quot;</span>, wdd-&gt;id);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">wdd-&gt;reboot_nb.notifier_call = watchdog_reboot_notifier;</span><br><span class="line"></span><br><span class="line">ret = register_reboot_notifier(&amp;wdd-&gt;reboot_nb);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;watchdog%d: Cannot register reboot notifier (%d)\n&quot;</span>,</span><br><span class="line">wdd-&gt;id, ret);</span><br><span class="line">watchdog_dev_unregister(wdd);</span><br><span class="line">ida_simple_remove(&amp;watchdog_ida, id);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册系统重启处理函数</span></span><br><span class="line"><span class="keyword">if</span> (wdd-&gt;ops-&gt;restart) &#123;</span><br><span class="line">wdd-&gt;restart_nb.notifier_call = watchdog_restart_notifier;</span><br><span class="line"></span><br><span class="line">ret = register_restart_handler(&amp;wdd-&gt;restart_nb);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">pr_warn(<span class="string">&quot;watchdog%d: Cannot register restart handler (%d)\n&quot;</span>,</span><br><span class="line">wdd-&gt;id, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>__watchdog_register_device</code>中调用 <code>watchdog_dev_register</code> 函数注册 <code>wdd</code> 指向的看门狗设备对应的字符设备。</p><p>若注册失败（ret 不为 0），先看是否因 ID 为 0 且返回-EBUSY。不是这情况就直接返回 ret给调用者；</p><p>若是，则重新分配 ID（1 到 MAX_DOGS）再注册设备。<code>watchdog_dev_register</code> 函数如下</p><h4 id="watchdog-dev-register"><a href="#watchdog-dev-register" class="headerlink" title="watchdog_dev_register()"></a>watchdog_dev_register()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *watchdog_dev_register: register a watchdog device</span></span><br><span class="line"><span class="comment"> *@wdd: watchdog device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Register a watchdog device including handling the legacy</span></span><br><span class="line"><span class="comment"> */dev/watchdog node. /dev/watchdog is actually a miscdevice and</span></span><br><span class="line"><span class="comment"> *thus we set it up like that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">watchdog_dev_register</span><span class="params">(<span class="keyword">struct</span> watchdog_device *wdd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 1. 注册字符设备（创建/dev/watchdogX 节点</span></span><br><span class="line">ret = watchdog_cdev_register(wdd);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">// 2. 注册预超时处理机制</span></span><br><span class="line">ret = watchdog_register_pretimeout(wdd);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">watchdog_cdev_unregister(wdd); <span class="comment">// 失败时回滚字符设备注册</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，最重要的是使用 <code>watchdog_cdev_register</code> 函数注册字符设备，是实现watchdog 统一设备驱动层的关键</p><h2 id="watchdog-统一设备驱动层"><a href="#watchdog-统一设备驱动层" class="headerlink" title="watchdog 统一设备驱动层"></a>watchdog 统一设备驱动层</h2><h3 id="watchdog-cdev-register"><a href="#watchdog-cdev-register" class="headerlink" title="watchdog_cdev_register()"></a>watchdog_cdev_register()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *watchdog_cdev_register: register watchdog character device</span></span><br><span class="line"><span class="comment"> *@wdd: watchdog device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Register a watchdog character device including handling the legacy</span></span><br><span class="line"><span class="comment"> */dev/watchdog node. /dev/watchdog is actually a miscdevice and</span></span><br><span class="line"><span class="comment"> *thus we set it up like that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">watchdog_cdev_register</span><span class="params">(<span class="keyword">struct</span> watchdog_device *wdd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 核心数据结构（包含设备状态、定时器等）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_core_data</span> *<span class="title">wd_data</span>;</span></span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">wd_data = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> watchdog_core_data), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!wd_data)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">mutex_init(&amp;wd_data-&gt;lock);<span class="comment">// 初始化保护锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立双向关联（设备 ↔ 核心数据）</span></span><br><span class="line">wd_data-&gt;wdd = wdd;</span><br><span class="line">wdd-&gt;wd_data = wd_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验内核工作队列有效性（心跳维持机制依赖）</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR_OR_NULL(watchdog_kworker)) &#123;</span><br><span class="line">kfree(wd_data);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设备节点初始化</span></span><br><span class="line">device_initialize(&amp;wd_data-&gt;dev);</span><br><span class="line">wd_data-&gt;dev.devt = MKDEV(MAJOR(watchdog_devt), wdd-&gt;id);<span class="comment">// 分配设备号</span></span><br><span class="line">wd_data-&gt;dev.class = &amp;watchdog_class;</span><br><span class="line">wd_data-&gt;dev.parent = wdd-&gt;parent;</span><br><span class="line">wd_data-&gt;dev.groups = wdd-&gt;groups;</span><br><span class="line">wd_data-&gt;dev.release = watchdog_core_data_release;</span><br><span class="line">dev_set_drvdata(&amp;wd_data-&gt;dev, wdd);</span><br><span class="line">dev_set_name(&amp;wd_data-&gt;dev, <span class="string">&quot;watchdog%d&quot;</span>, wdd-&gt;id);<span class="comment">// 命名设备节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时机制初始化</span></span><br><span class="line">kthread_init_work(&amp;wd_data-&gt;work, watchdog_ping_work);<span class="comment">// 心跳工作队列</span></span><br><span class="line">hrtimer_init(&amp;wd_data-&gt;timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD); <span class="comment">// 初始化高精度定时器</span></span><br><span class="line">wd_data-&gt;timer.function = watchdog_timer_expired;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传统设备注册（/dev/watchdog），注册为杂项设备</span></span><br><span class="line"><span class="keyword">if</span> (wdd-&gt;id == <span class="number">0</span>) &#123;</span><br><span class="line">old_wd_data = wd_data;</span><br><span class="line">watchdog_miscdev.parent = wdd-&gt;parent;</span><br><span class="line">err = misc_register(&amp;watchdog_miscdev);<span class="comment">// 注册 misc 设备（兼容旧版接口）</span></span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;%s: cannot register miscdev on minor=%d (err=%d).\n&quot;</span>,</span><br><span class="line">wdd-&gt;info-&gt;identity, WATCHDOG_MINOR, err);</span><br><span class="line"><span class="keyword">if</span> (err == -EBUSY)<span class="comment">// 处理设备号冲突的特殊情况（旧驱动存在时返回 EBUSY）</span></span><br><span class="line">pr_err(<span class="string">&quot;%s: a legacy watchdog module is probably present.\n&quot;</span>,</span><br><span class="line">wdd-&gt;info-&gt;identity);</span><br><span class="line">old_wd_data = <span class="literal">NULL</span>;</span><br><span class="line">put_device(&amp;wd_data-&gt;dev);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fill in the data structures */</span></span><br><span class="line">    <span class="comment">// 字符设备注册（创建/dev/watchdogX 节点）</span></span><br><span class="line">cdev_init(&amp;wd_data-&gt;cdev, &amp;watchdog_fops); <span class="comment">// 绑定文件操作接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the device */</span></span><br><span class="line">err = cdev_device_add(&amp;wd_data-&gt;cdev, &amp;wd_data-&gt;dev);<span class="comment">// 添加至系统</span></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;watchdog%d unable to add device %d:%d\n&quot;</span>,</span><br><span class="line">wdd-&gt;id,  MAJOR(watchdog_devt), wdd-&gt;id);</span><br><span class="line"><span class="keyword">if</span> (wdd-&gt;id == <span class="number">0</span>) &#123;</span><br><span class="line">misc_deregister(&amp;watchdog_miscdev);</span><br><span class="line">old_wd_data = <span class="literal">NULL</span>;</span><br><span class="line">put_device(&amp;wd_data-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wd_data-&gt;cdev.owner = wdd-&gt;ops-&gt;owner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Record time of most recent heartbeat as &#x27;just before now&#x27;. */</span></span><br><span class="line">wd_data-&gt;last_hw_keepalive = ktime_sub(ktime_get(), <span class="number">1</span>);</span><br><span class="line">watchdog_set_open_deadline(wd_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the watchdog is running, prevent its driver from being unloaded,</span></span><br><span class="line"><span class="comment"> * and schedule an immediate ping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (watchdog_hw_running(wdd)) &#123;<span class="comment">// 运行状态处理</span></span><br><span class="line">__module_get(wdd-&gt;ops-&gt;owner); <span class="comment">// 增加模块引用计数</span></span><br><span class="line">get_device(&amp;wd_data-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (handle_boot_enabled)<span class="comment">// 根据配置启动定时器（用户空间接管前维持心跳）</span></span><br><span class="line">hrtimer_start(&amp;wd_data-&gt;timer, <span class="number">0</span>,</span><br><span class="line">      HRTIMER_MODE_REL_HARD);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pr_info(<span class="string">&quot;watchdog%d running and kernel based pre-userspace handler disabled\n&quot;</span>,</span><br><span class="line">wdd-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="watchdog-ping-work"><a href="#watchdog-ping-work" class="headerlink" title="watchdog_ping_work()"></a>watchdog_ping_work()</h4><p><code>watchdog_cdev_register()</code>定义的工作队列中<code>watchdog_ping_work</code> 函数中执行了与看门狗相关的任务操作。函数代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">watchdog_ping_work</span><span class="params">(<span class="keyword">struct</span> kthread_work *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过工作项获取核心数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_core_data</span> *<span class="title">wd_data</span>;</span></span><br><span class="line"></span><br><span class="line">wd_data = container_of(work, <span class="keyword">struct</span> watchdog_core_data, work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁保证操作原子性（防止并发访问）</span></span><br><span class="line">mutex_lock(&amp;wd_data-&gt;lock);</span><br><span class="line">    <span class="comment">// 判断是否需要发送心跳信号：</span></span><br><span class="line"><span class="comment">// 1. 设备存在</span></span><br><span class="line"><span class="comment">// 2. 看门狗处于激活状态或硬件正在运行</span></span><br><span class="line"><span class="keyword">if</span> (watchdog_worker_should_ping(wd_data))</span><br><span class="line">__watchdog_ping(wd_data-&gt;wdd);<span class="comment">// 执行实际的心跳操作</span></span><br><span class="line">    <span class="comment">// 释放互斥锁</span></span><br><span class="line">mutex_unlock(&amp;wd_data-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="watchdog-fops"><a href="#watchdog-fops" class="headerlink" title="watchdog_fops"></a>watchdog_fops</h4><p><code>watchdog_cdev_register()</code>中通过<code>cdev_init(&amp;wd_data-&gt;cdev, &amp;watchdog_fops);</code>将cdev结构体中的设备操作函数设置为<code>watchdog_fops</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">watchdog_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.write= watchdog_write,</span><br><span class="line">.unlocked_ioctl= watchdog_ioctl,</span><br><span class="line">.compat_ioctl= compat_ptr_ioctl,</span><br><span class="line">.open= watchdog_open,</span><br><span class="line">.release= watchdog_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="open-watchdog-open"><a href="#open-watchdog-open" class="headerlink" title=".open &#x3D; watchdog_open"></a>.open &#x3D; watchdog_open</h5><p><code>open</code> 系统调用对应的操作函数指定为 <code>watchdog_open</code>。当用户空间程序尝试打开与该文件操作结构体关联的设备文件时，内核会调用 <code>watchdog_open</code> 函数来进行设备打开相关的初始化操作，比如可能会进行一些资源分配、状态初始化等工作，以确保设备在后续的读写、控制等操作中能够正常运行。</p><p><code>watchdog_open</code> 函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *watchdog_open: open the /dev/watchdog* devices.</span></span><br><span class="line"><span class="comment"> *@inode: inode of device</span></span><br><span class="line"><span class="comment"> *@file: file handle to device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *When the /dev/watchdog* device gets opened, we start the watchdog.</span></span><br><span class="line"><span class="comment"> *Watch out: the /dev/watchdog device is single open, so we make sure</span></span><br><span class="line"><span class="comment"> *it can only be opened once.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">watchdog_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_core_data</span> *<span class="title">wd_data</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_device</span> *<span class="title">wdd</span>;</span></span><br><span class="line"><span class="type">bool</span> hw_running;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the corresponding watchdog device */</span></span><br><span class="line"><span class="keyword">if</span> (imajor(inode) == MISC_MAJOR)<span class="comment">// 传统设备通过 miscdevice 获取，新设备通过字符设备结构获取</span></span><br><span class="line">wd_data = old_wd_data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">wd_data = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> watchdog_core_data,</span><br><span class="line">       cdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the watchdog is single open! */</span></span><br><span class="line">    <span class="comment">/* 单例模式检测 - 保证设备只能被打开一次 */</span></span><br><span class="line"><span class="keyword">if</span> (test_and_set_bit(_WDOG_DEV_OPEN, &amp;wd_data-&gt;status))<span class="comment">/* 单例模式检测 - 保证设备只能被打开一次 */</span></span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">wdd = wd_data-&gt;wdd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the /dev/watchdog device is open, we don&#x27;t want the module</span></span><br><span class="line"><span class="comment"> * to be unloaded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hw_running = watchdog_hw_running(wdd);<span class="comment">/* 模块引用管理 */</span></span><br><span class="line">    <span class="comment">// 如果硬件未运行，增加模块引用计数防止卸载</span></span><br><span class="line"><span class="keyword">if</span> (!hw_running &amp;&amp; !try_module_get(wdd-&gt;ops-&gt;owner)) &#123;</span><br><span class="line">err = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_clear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启动看门狗硬件 */</span></span><br><span class="line">err = watchdog_start(wdd);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out_mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 保存核心数据结构到文件私有数据 */</span></span><br><span class="line">file-&gt;private_data = wd_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新设备引用计数 */</span></span><br><span class="line"><span class="keyword">if</span> (!hw_running)</span><br><span class="line">get_device(&amp;wd_data-&gt;dev);<span class="comment">// 增加设备引用计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * open_timeout only applies for the first open from</span></span><br><span class="line"><span class="comment"> * userspace. Set open_deadline to infinity so that the kernel</span></span><br><span class="line"><span class="comment"> * will take care of an always-running hardware watchdog in</span></span><br><span class="line"><span class="comment"> * case the device gets magic-closed or WDIOS_DISABLECARD is</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">wd_data-&gt;open_deadline = KTIME_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dev/watchdog is a virtual (and thus non-seekable) filesystem */</span></span><br><span class="line"><span class="keyword">return</span> stream_open(inode, file);</span><br><span class="line"></span><br><span class="line">out_mod:</span><br><span class="line">module_put(wd_data-&gt;wdd-&gt;ops-&gt;owner);</span><br><span class="line">out_clear:</span><br><span class="line">clear_bit(_WDOG_DEV_OPEN, &amp;wd_data-&gt;status);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="write-watchdog-write"><a href="#write-watchdog-write" class="headerlink" title=".write &#x3D; watchdog_write,"></a>.write &#x3D; watchdog_write,</h5><p>write 系统调用对应的操作函数指定为 <code>watchdog_write</code>。当用户空间程序对与该文件操作结构体关联的设备文件（比如 <code>/dev/watchdog</code>）执行 write 操作时，内核会调用这里指定的<code>watchdog_write</code> 函数来处理具体的写入请求。这个函数用于执行喂狗操作等与写入相关的功能。<code>watchdog_write</code> 函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *watchdog_write: writes to the watchdog.</span></span><br><span class="line"><span class="comment"> *@file: file from VFS</span></span><br><span class="line"><span class="comment"> *@data: user address of data</span></span><br><span class="line"><span class="comment"> *@len: length of data</span></span><br><span class="line"><span class="comment"> *@ppos: pointer to the file offset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *A write to a watchdog device is defined as a keepalive ping.</span></span><br><span class="line"><span class="comment"> *Writing the magic &#x27;V&#x27; sequence allows the next close to turn</span></span><br><span class="line"><span class="comment"> *off the watchdog (if &#x27;nowayout&#x27; is not set).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">watchdog_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *data,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> len, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_core_data</span> *<span class="title">wd_data</span> =</span> file-&gt;private_data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_device</span> *<span class="title">wdd</span>;</span></span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note: just in case someone wrote the magic character</span></span><br><span class="line"><span class="comment"> * five months ago...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/* 清除上次遗留的魔术字符标记 */</span></span><br><span class="line">clear_bit(_WDOG_ALLOW_RELEASE, &amp;wd_data-&gt;status);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* scan to see whether or not we got the magic character */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != len; i++) &#123;<span class="comment">/* 扫描用户数据寻找魔术字符&#x27;V&#x27; */</span></span><br><span class="line"><span class="keyword">if</span> (get_user(c, data + i))<span class="comment">// 从用户空间安全复制数据</span></span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;V&#x27;</span>)<span class="comment">// 检测到魔术字符</span></span><br><span class="line">set_bit(_WDOG_ALLOW_RELEASE, &amp;wd_data-&gt;status);<span class="comment">// 允许安全关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* someone wrote to us, so we send the watchdog a keepalive ping */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 触发看门狗心跳维持 */</span></span><br><span class="line">err = -ENODEV;</span><br><span class="line">mutex_lock(&amp;wd_data-&gt;lock);<span class="comment">// 加锁保护设备状态</span></span><br><span class="line">wdd = wd_data-&gt;wdd;</span><br><span class="line"><span class="keyword">if</span> (wdd)</span><br><span class="line">err = watchdog_ping(wdd);<span class="comment">// 执行底层心跳操作</span></span><br><span class="line">mutex_unlock(&amp;wd_data-&gt;lock);<span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;<span class="comment">// 返回实际写入长度（成功时返回请求长度）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unlocked-ioctl-watchdog-ioctl"><a href="#unlocked-ioctl-watchdog-ioctl" class="headerlink" title=".unlocked_ioctl &#x3D; watchdog_ioctl,"></a>.unlocked_ioctl &#x3D; watchdog_ioctl,</h5><p><code>ioctl</code> 系统调用对应的操作函数指定为 <code>watchdog_ioctl</code>。</p><p><code>ioctl</code> 是一种在 Linux 中用于对设备进行特定控制操作的接口，用户空间程序可以通过 ioctl 向设备发送各种自定义的命令。</p><p>当对关联的设备文件执行 ioctl 操作时，内核会调用 <code>watchdog_ioctl</code> 函数来处理这些特定的控制请求。</p><p>对于看门狗设备，这个函数用于设置超时时间、获取设备状态等各种需要通过 ioctl 实现的功能。<code>watchdog_ioctl</code> 函数如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *watchdog_ioctl: handle the different ioctl&#x27;s for the watchdog device.</span></span><br><span class="line"><span class="comment"> *@file: file handle to the device</span></span><br><span class="line"><span class="comment"> *@cmd: watchdog command</span></span><br><span class="line"><span class="comment"> *@arg: argument pointer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *The watchdog API defines a common set of functions for all watchdogs</span></span><br><span class="line"><span class="comment"> *according to their available features.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">watchdog_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_core_data</span> *<span class="title">wd_data</span> =</span> file-&gt;private_data;</span><br><span class="line"><span class="type">void</span> __user *argp = (<span class="type">void</span> __user *)arg;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watchdog_device</span> *<span class="title">wdd</span>;</span></span><br><span class="line"><span class="type">int</span> __user *p = argp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;wd_data-&gt;lock);<span class="comment">// 获取设备状态锁</span></span><br><span class="line"></span><br><span class="line">wdd = wd_data-&gt;wdd;</span><br><span class="line"><span class="keyword">if</span> (!wdd) &#123;</span><br><span class="line">err = -ENODEV;<span class="comment">// 设备未就绪</span></span><br><span class="line"><span class="keyword">goto</span> out_ioctl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优先处理驱动自定义的 ioctl 操作 */</span></span><br><span class="line">err = watchdog_ioctl_op(wdd, cmd, arg);</span><br><span class="line"><span class="keyword">if</span> (err != -ENOIOCTLCMD)<span class="comment">// 已处理或错误</span></span><br><span class="line"><span class="keyword">goto</span> out_ioctl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 标准 ioctl 命令处理 */</span></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> WDIOC_GETSUPPORT:<span class="comment">// 获取看门狗能力信息</span></span><br><span class="line">err = copy_to_user(argp, wdd-&gt;info,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> watchdog_info)) ? -EFAULT : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WDIOC_GETSTATUS:<span class="comment">// 获取设备状态标志</span></span><br><span class="line">val = watchdog_get_status(wdd);</span><br><span class="line">err = put_user(val, p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WDIOC_GETBOOTSTATUS:<span class="comment">// 获取启动状态</span></span><br><span class="line">err = put_user(wdd-&gt;bootstatus, p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WDIOC_SETOPTIONS:<span class="comment">// 设置设备选项</span></span><br><span class="line"><span class="keyword">if</span> (get_user(val, p)) &#123;</span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val &amp; WDIOS_DISABLECARD) &#123;<span class="comment">// 停用看门狗</span></span><br><span class="line">err = watchdog_stop(wdd);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val &amp; WDIOS_ENABLECARD)<span class="comment">// 启用看门狗</span></span><br><span class="line">err = watchdog_start(wdd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WDIOC_KEEPALIVE:<span class="comment">// 手动触发心跳</span></span><br><span class="line"><span class="keyword">if</span> (!(wdd-&gt;info-&gt;options &amp; WDIOF_KEEPALIVEPING)) &#123;</span><br><span class="line">err = -EOPNOTSUPP;<span class="comment">// 设备不支持该操作</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = watchdog_ping(wdd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WDIOC_SETTIMEOUT:<span class="comment">// 设置超时时间</span></span><br><span class="line"><span class="keyword">if</span> (get_user(val, p)) &#123;</span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = watchdog_set_timeout(wdd, val);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* If the watchdog is active then we send a keepalive ping</span></span><br><span class="line"><span class="comment"> * to make sure that the watchdog keep&#x27;s running (and if</span></span><br><span class="line"><span class="comment"> * possible that it takes the new timeout) */</span></span><br><span class="line">err = watchdog_ping(wdd);<span class="comment">/* 设置成功后立即发送心跳，确保新超时生效 */</span></span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">fallthrough;</span><br><span class="line"><span class="keyword">case</span> WDIOC_GETTIMEOUT:</span><br><span class="line"><span class="comment">/* timeout == 0 means that we don&#x27;t know the timeout */</span></span><br><span class="line"><span class="keyword">if</span> (wdd-&gt;timeout == <span class="number">0</span>) &#123;</span><br><span class="line">err = -EOPNOTSUPP;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = put_user(wdd-&gt;timeout, p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WDIOC_GETTIMELEFT:</span><br><span class="line">err = watchdog_get_timeleft(wdd, &amp;val);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">err = put_user(val, p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WDIOC_SETPRETIMEOUT:</span><br><span class="line"><span class="keyword">if</span> (get_user(val, p)) &#123;</span><br><span class="line">err = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">err = watchdog_set_pretimeout(wdd, val);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WDIOC_GETPRETIMEOUT:</span><br><span class="line">err = put_user(wdd-&gt;pretimeout, p);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">err = -ENOTTY;<span class="comment">// 未知 ioctl 命令</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_ioctl:</span><br><span class="line">mutex_unlock(&amp;wd_data-&gt;lock);<span class="comment">// 释放设备状态锁</span></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="看门狗应用编写"><a href="#看门狗应用编写" class="headerlink" title="看门狗应用编写"></a>看门狗应用编写</h1><ol><li>打开设备文件：打开<code>/dev/watchdog0</code>，以可读可写模式打开，失败则输出<code>open error</code>并返回 -1。</li><li>设置超时时间：成功打开后，通过系统调用设超时时间为 2 秒，失败输出<code>set time out error</code>并返回 -2。</li><li>喂狗操作：设置好超时后，循环 5 次执行喂狗操作（用合适系统调用），成功输出<code>feed dog ok</code>并暂停 1 秒，失败输出<code>feed dog error</code>并返回 -2。</li><li>结束提示：完成喂狗循环后，输出<code>hungry dog</code>，最后程序以返回值 0 正常结束。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/watchdog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> time_out;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line">fd = open(<span class="string">&quot;/dev/watchdog0&quot;</span>,O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time_out = <span class="number">2</span>;</span><br><span class="line">ret = ioctl(fd,WDIOC_SETTIMEOUT,&amp;time_out);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;set time out error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i--)&#123;</span><br><span class="line">ret = ioctl(fd,WDIOC_KEEPALIVE,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;feed dog error\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;feed dog ok\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hungry dog\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux Watchdog</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Linux RTC</title>
    <link href="https://even629.com/posts/2601053/"/>
    <id>https://even629.com/posts/2601053/</id>
    <published>2026-01-05T14:09:00.000Z</published>
    <updated>2026-01-05T14:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2026-01-05</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="RTC-基础"><a href="#RTC-基础" class="headerlink" title="RTC 基础"></a>RTC 基础</h1><h2 id="RTC-介绍"><a href="#RTC-介绍" class="headerlink" title="RTC 介绍"></a>RTC 介绍</h2><p><strong>RTC（Real-Time Clock</strong>）即<strong>实时时钟</strong>，是一种集成电路或模块，用于<strong>在电子系统中提供精确的时间信息</strong>。</p><p>与系统主处理器（CPU）不同，<strong>RTC 主要负责维护系统的实时日期和时间</strong>，<emp>即使在设备关闭或断电的情况下，RTC 也能持续运行并保持时间准确性。</emp></p><p><strong>RTC 的主要功能</strong>：</p><ol><li><u>提供实时时间</u>：RTC 能够持续跟踪当前的日期和时间，通常包括年、月、日、时、分、秒等信息。</li><li><u>断电保持时间</u>：RTC 通常配备有备用电池（如纽扣电池），即使主系统断电，RTC也能继续运行，确保时间信息不会丢失。</li></ol><p><strong>RTC 的应用场景</strong>：</p><ol><li>电子时钟：如电脑、手机、智能手表等设备中的时钟功能。</li><li>嵌入式系统：在工业控制、物联网设备中，RTC 用于记录事件发生的时间。</li><li>数据记录：在需要时间戳的场景中，RTC 提供准确的时间信息。</li><li>定时任务：用于定时唤醒设备或执行特定操作。</li></ol><p><strong>RTC 的特点</strong>：</p><ol><li><u>低功耗</u>：RTC 通常设计为低功耗运行，适合长时间使用。</li><li><u>高精度</u>：能够提供较为精确的时间信息，误差较小。</li><li><u>独立性</u>：即使主系统关闭，RTC 也能独立运行。</li></ol><h3 id="内部-RTC-和外部-RTC"><a href="#内部-RTC-和外部-RTC" class="headerlink" title="内部 RTC 和外部 RTC"></a>内部 RTC 和外部 RTC</h3><p>实时时钟有着外部 RTC 和内部 RTC 这两种常见的实现方案。</p><p><strong>外部 RTC 是独立于主控芯片的专用 RTC 芯片，通过 I2C、SPI 等通信接口与主控芯片连接</strong>。</p><ul><li>优点<ul><li>具备高精度的特点，能够提供更准确的时间记录。</li><li>外部 RTC 拥有独立的电源管理电路，可配备纽扣电池实现长时间独立运行，即使主控芯片断电或损坏，也能确保时间记录的连续性。</li></ul></li><li>缺点<ul><li>外部 RTC 的成本较高，需要额外采购芯片及相关元件，同时增加了电路设计的复杂性和开发难度，并占用主控芯片的通信资源。</li></ul></li></ul><p>因此，外部 RTC 更适合对时间精度、可靠性和功能有较高要求的场景。在 iTOP-RK3568 开发板上就集成了外部 RTC，所使用的芯片是 RX8010，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260105221104569.png" alt="外部RTC" loading="lazy"></p><p><strong>内部 RTC 是集成在主控芯片内部的实时时钟模块</strong></p><ul><li>优点<ul><li>具有硬件集成的特点，无需额外硬件组件，因此设计简单、成本低且易于使用。</li></ul></li><li>缺点<ul><li>内部 RTC 依赖主控芯片的供电，通常需要备用电池来维持断电后的时间记录</li><li><emp>内部 RTC 非常容易受到温度和电压波动的影响，导致时间漂移较大，可靠性也相对较低</emp>。</li></ul></li></ul><p>因此，内部 RTC 更适合对时间精度要求不高、成本敏感的场景，例如家用电器、简单的物联网设备或实时性要求较低的系统。</p><p>而 iTOP-RK3568 核心板的电源管理芯片 RK809 默认是集成了内部 RTC 的，但由于上述内部 RTC 的种种缺点，且底板上已经有<br>了外部 RTC，所以内部 RTC 并没有被使能，RK809 电源管理芯片的内部 RTC 电路如下所示:</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260105221107412.png" alt="RK809电源管理芯片" loading="lazy"></p><p><strong>总结</strong></p><table><thead><tr><th>类别</th><th>内部RTC</th><th>外部RTC</th></tr></thead><tbody><tr><td>定义</td><td>集成在主控芯片内的RTC模块</td><td>独立的专用RTC芯片，通过I²C&#x2F;SPI等接口连接</td></tr><tr><td>特点</td><td>- 硬件集成 <br />- 低功耗模式支持 <br />- 依赖主控电源 <br />- 精度有限</td><td>- 独立运行<br />- 高精度<br />- 多功能扩展</td></tr><tr><td>优点</td><td>1. 成本低<br />2. 设计简单<br />3. 易于使用</td><td>1. 高精度<br />2. 独立性强<br />3. 功能丰富<br />4. 可靠性高</td></tr><tr><td>缺点</td><td>1. 精度不足<br />2. 可靠性较低<br />3. 缺乏独立性</td><td>1. 成本较高<br />2. 设计复杂<br />3. 占用资源</td></tr><tr><td>适用场景</td><td>对时间精度要求不高、成本敏感、实时性要求低的系统</td><td>对时间精度要求高、需长时间独立运行、需额外功能的场景</td></tr></tbody></table><h3 id="RK3568-RTC-外设"><a href="#RK3568-RTC-外设" class="headerlink" title="RK3568 RTC 外设"></a>RK3568 RTC 外设</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260105221104569.png" alt="外部RTC" loading="lazy"></p><p>可以将这个电路分为 RTC 电源供电部分以及 RTC 芯片电路部分，根据 RTC 芯片电路部分可以得到 RX8010 挂载到了 I2C5 上</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260105221128333.png" alt="VCC_RTC" loading="lazy"></p><p>该系统的主要功能是通过<strong>主电源供电模式和备用电池供电模式的切换</strong>，确保 RTC 模块在主电源（<code>VCC3V3_SYS</code>）断电时仍能通过备用电池（<code>CR1220</code>）继续工作，从而保持时间信息不丢失。分为以下两种情况。</p><ol><li>在系统正常运行时，<code>VCC3V3_SYS</code> 提供 3.3V 电源，二极管 D2 正向导通为 RTC 模块供电，同时二极管 D3 反向截止以防止主电源向电池充电或消耗电池电量；</li><li>当系统断电（<code>VCC3V3_SYS</code> 失效）时，二极管 D2 反向截止以防止电池电量通过主电源回路消耗，同时二极管 D3 正向导通，由<code>CR1220</code> 电池为 RTC 模块供电，确保 RTC 继续运行。</li></ol><h1 id="RX8010-驱动分析和移植"><a href="#RX8010-驱动分析和移植" class="headerlink" title="RX8010 驱动分析和移植"></a>RX8010 驱动分析和移植</h1><h2 id="RTC子系统框架"><a href="#RTC子系统框架" class="headerlink" title="RTC子系统框架"></a>RTC子系统框架</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260105221134473.png" alt="RTC子系统框架" loading="lazy"></p><p>在上图中 RTC 子系统被划分为了三个层次，分别为用户空间、设备驱动层和硬件层，设备驱动层又包括 RTC 设备驱动和 PWM 核心层：</p><ul><li><p>用户空间是应用程序运行的层级，在这一层，应用程序通过不同的接口与系统进行交互，比如访问 <code>/dev/xxx</code> 设备节点来读写 RTC 时间，或通过 <code>sysf</code>s 和 <code>proc</code> 文件系统来获取或设置硬件状态。</p></li><li><p>中间的设备驱动层又分为了 RTC 设备驱动和 RTC 核心层，，。</p><ul><li>RTC 设备驱动负责操作硬件的具体细节通过与硬件（RTC 芯片）进行直接通信来实现硬件控制，设备驱动程序还负责将硬件设备暴露给上层系统，如 <code>device</code>（设备文件）和 <code>driver</code>（驱动程序）。<ul><li><code>/dev/xxx</code> 是指用于操作设备的接口文件，用户应用程序通过它与 RTC 硬件进行交互。</li><li><code>driver</code> 部分则是系统内核的一个模块，负责具体的硬件控制操作。</li></ul></li><li>RTC 核心层负责管理和协调 RTC 的时间管理功能。它确保系统正确地读取和设置时间，同时确保时钟在断电时继续运行。</li></ul></li><li><p>在 RTC 硬件层代表实际的 RTC 硬件，通过硬件接口（如 I2C、SPI 等）与设备驱动层进行通信，提供实际的时间计时功能。</p></li></ul><h2 id="RTC-驱动源码分析"><a href="#RTC-驱动源码分析" class="headerlink" title="RTC 驱动源码分析"></a>RTC 驱动源码分析</h2><h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RTC 芯片使能</span></span><br><span class="line"><span class="variable">&amp;i2c5</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">        rx8010:</span> <span class="title class_">rx8010@32</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;epson,rx8010&quot;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x32</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line">        <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过再通过 compatible 属性<code>epson,rx8010</code>找到匹配的驱动文件，驱动的具体路径为 <code>drivers/rtc/rtc-rx8010.c</code>，先来找到驱动的入口函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">rx8010_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">&quot;rtc-rx8010&quot;</span>,</span><br><span class="line">.of_match_table = of_match_ptr(rx8010_of_match),</span><br><span class="line">&#125;,</span><br><span class="line">.probe= rx8010_probe,</span><br><span class="line">.id_table= rx8010_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_i2c_driver(rx8010_driver);</span><br></pre></td></tr></table></figure><h3 id="module-i2c-driver"><a href="#module-i2c-driver" class="headerlink" title="module_i2c_driver()"></a>module_i2c_driver()</h3><p>这个宏是用来简化 I2C 设备驱动的注册和注销过程的，定义在 <code>include/linux/i2c.h</code> 文件中，具体如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_i2c_driver() - Helper macro for registering a modular I2C driver</span></span><br><span class="line"><span class="comment"> * @__i2c_driver: i2c_driver struct</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Helper macro for I2C drivers which do not do anything special in module</span></span><br><span class="line"><span class="comment"> * init/exit. This eliminates a lot of boilerplate. Each module may only</span></span><br><span class="line"><span class="comment"> * use this macro once, and calling it replaces module_init() and module_exit()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_i2c_driver(__i2c_driver) \</span></span><br><span class="line"><span class="meta">module_driver(__i2c_driver, i2c_add_driver, \</span></span><br><span class="line"><span class="meta">i2c_del_driver)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="module-driver"><a href="#module-driver" class="headerlink" title="module_driver()"></a>module_driver()</h4><p><code>module_driver</code> 宏也是一个用来简化的宏，对应的宏定义如下所示</p><p><code>include/linux/device/driver.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * module_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in module init/exit. This eliminates a lot of boilerplate.</span></span><br><span class="line"><span class="comment"> * Each module may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * module_init() and module_exit().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @__unregister: unregister function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register and __unregister.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="meta">static int __init __driver##_init(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">return __register(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_init(__driver##_init); \</span></span><br><span class="line"><span class="meta">static void __exit __driver##_exit(void) \</span></span><br><span class="line"><span class="meta">&#123; \</span></span><br><span class="line"><span class="meta">__unregister(&amp;(__driver) , ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">&#125; \</span></span><br><span class="line"><span class="meta">module_exit(__driver##_exit);</span></span><br></pre></td></tr></table></figure><p>最后来对上述宏进行代入，展开可以得到如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rx8010_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i2c_add_driver(&amp;rx8010_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(rx8010_driver_init);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rx8010_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">i2c_del_driver(&amp;rx8010_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(rx8010_driver_exit);</span><br></pre></td></tr></table></figure><ul><li><p><code>rx8010_driver_init</code> 函数在模块加载时被调用，它通过 <code>i2c_add_driver</code> 函数将 <code>rx8010_driver</code>注册到内核中。</p></li><li><p><code>rx8010_driver_exit</code> 函数在模块卸载时被调用，它通过 <code>i2c_del_driver</code> 函数将 <code>rx8010_driver</code> 从内核中注销。</p></li></ul><h3 id="rx8010-probe"><a href="#rx8010-probe" class="headerlink" title="rx8010_probe()"></a>rx8010_probe()</h3><p>当 compatible 匹配之后会进入到 probe 函数，probe 函数内容如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rx8010_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span> =</span> to_i2c_adapter(client-&gt;dev.parent);<span class="comment">// 获取 I2C 适配器对象，用于检查功能支持</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">rtc_ops</span>;</span><span class="comment">// RTC 操作函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx8010_data</span> *<span class="title">rx8010</span>;</span><span class="comment">// 用于存储设备私有数据的结构体</span></span><br><span class="line"><span class="type">int</span> err = <span class="number">0</span>;<span class="comment">// 错误码初始化为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 I2C 适配器是否支持所需的 SMBus 功能</span></span><br><span class="line"><span class="keyword">if</span> (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA</span><br><span class="line">| I2C_FUNC_SMBUS_I2C_BLOCK)) &#123;</span><br><span class="line">dev_err(&amp;adapter-&gt;dev, <span class="string">&quot;doesn&#x27;t support required functionality\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;<span class="comment">// 如果不支持，打印错误信息并返回 -EIO（输入/输出错误）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一块清零的内存，并将其与设备生命周期绑定。</span></span><br><span class="line">rx8010 = devm_kzalloc(&amp;client-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rx8010_data),</span><br><span class="line">      GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!rx8010)<span class="comment">// 如果内存分配失败，返回 -ENOMEM（内存不足错误）</span></span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">// 初始化设备私有数据</span></span><br><span class="line">rx8010-&gt;client = client;</span><br><span class="line">i2c_set_clientdata(client, rx8010); <span class="comment">// 将私有数据与 I2C 客户端关联</span></span><br><span class="line"><span class="comment">// 初始化 RX8010 设备</span></span><br><span class="line">err = rx8010_init_client(client);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;<span class="comment">// 如果初始化失败，直接返回错误码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>) &#123;<span class="comment">// 检查设备是否提供了中断号</span></span><br><span class="line">dev_info(&amp;client-&gt;dev, <span class="string">&quot;IRQ %d supplied\n&quot;</span>, client-&gt;irq);</span><br><span class="line">        <span class="comment">// 请求线程化的中断处理程序</span></span><br><span class="line">err = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="literal">NULL</span>,</span><br><span class="line">rx8010_irq_1_handler,</span><br><span class="line">IRQF_TRIGGER_LOW | IRQF_ONESHOT,</span><br><span class="line"><span class="string">&quot;rx8010&quot;</span>, client);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="comment">// 如果请求中断失败，打印错误信息并返回错误码</span></span><br><span class="line">dev_err(&amp;client-&gt;dev, <span class="string">&quot;unable to request IRQ\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有中断支持，使用带有报警功能的 RTC 操作函数</span></span><br><span class="line">rtc_ops = &amp;rx8010_rtc_ops_alarm;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有中断支持，使用默认的 RTC 操作函数</span></span><br><span class="line">rtc_ops = &amp;rx8010_rtc_ops_default;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 RTC 设备</span></span><br><span class="line">rx8010-&gt;rtc = devm_rtc_device_register(&amp;client-&gt;dev, client-&gt;name,</span><br><span class="line">       rtc_ops, THIS_MODULE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rx8010-&gt;rtc)) &#123;</span><br><span class="line">        <span class="comment">// 如果注册失败，打印错误信息并返回错误码</span></span><br><span class="line">dev_err(&amp;client-&gt;dev, <span class="string">&quot;unable to register the class device\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rx8010-&gt;rtc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rx8010-&gt;rtc-&gt;max_user_freq = <span class="number">1</span>;<span class="comment">// 设置 RTC 设备的最大用户频率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;<span class="comment">// 返回成功状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>probe函数中定义了一个用于存储设备私有数据的 <code>rx8010_data</code> 结构体变量 rx8010，该结构体定义如下所示：</p><h4 id="struct-rx8010-data"><a href="#struct-rx8010-data" class="headerlink" title="struct rx8010_data"></a>struct rx8010_data</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx8010_data</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span> <span class="comment">// I2C 客户端，用于与 RX8010 设备通信</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span>;</span> <span class="comment">// RTC 设备，用于管理实时时钟功能</span></span><br><span class="line">u8 ctrlreg;<span class="comment">// 控制寄存器的值，用于存储或配置 RX8010 的控制状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>i2c_client</code> 是指向 I2C 客户端的指针，用于与 RX8010 设备通信，而 <code>rtc_device</code> 结构体表示与 RX8010 设备关联的 RTC（实时时<br>钟）设备，该结构体的定义如下所示：</p><h5 id="struct-rtc-device"><a href="#struct-rtc-device" class="headerlink" title="struct rtc_device"></a>struct rtc_device</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">// 设备结构体，用于与设备模型集成</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">// 拥有该 RTC 设备的模块</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id;<span class="comment">// RTC 设备的 ID</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span>;</span><span class="comment">// RTC 设备的操作函数集</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">ops_lock</span>;</span><span class="comment">// 用于保护操作函数集的互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">char_dev</span>;</span><span class="comment">// 字符设备，用于用户空间访问 RTC 设备</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;<span class="comment">// RTC 设备的标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> irq_data;<span class="comment">// 中断相关数据</span></span><br><span class="line"><span class="type">spinlock_t</span> irq_lock;<span class="comment">// 用于保护中断数据的自旋锁</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> irq_queue;<span class="comment">// 等待队列，用于处理中断事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span><span class="comment">// 异步通知队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> irq_freq;<span class="comment">// 中断频率</span></span><br><span class="line"><span class="type">int</span> max_user_freq;<span class="comment">// 用户空间允许的最大中断频率</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_head</span> <span class="title">timerqueue</span>;</span><span class="comment">// 定时器队列，用于管理定时器事件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">aie_timer</span>;</span><span class="comment">// 闹钟中断定时器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">uie_rtctimer</span>;</span> <span class="comment">// 更新中断定时器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">pie_timer</span>;</span> <span class="comment">/* sub second exp, so needs hrtimer */</span> <span class="comment">// 高精度定时器，用于处理亚秒级的中断</span></span><br><span class="line"><span class="type">int</span> pie_enabled;<span class="comment">// 高精度定时器是否启用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">irqwork</span>;</span><span class="comment">// 中断处理的工作队列</span></span><br><span class="line"><span class="comment">/* Some hardware can&#x27;t support UIE mode */</span></span><br><span class="line"><span class="type">int</span> uie_unsupported;<span class="comment">// 硬件是否不支持更新中断模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Number of nsec it takes to set the RTC clock. This influences when</span></span><br><span class="line"><span class="comment"> * the set ops are called. An offset:</span></span><br><span class="line"><span class="comment"> *   - of 0.5 s will call RTC set for wall clock time 10.0 s at 9.5 s</span></span><br><span class="line"><span class="comment"> *   - of 1.5 s will call RTC set for wall clock time 10.0 s at 8.5 s</span></span><br><span class="line"><span class="comment"> *   - of -0.5 s will call RTC set for wall clock time 10.0 s at 10.5 s</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> set_offset_nsec;<span class="comment">/* 设置 RTC 时钟时的偏移时间（纳秒） */</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> registered;<span class="comment">// 设备是否已注册</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Old ABI support */</span></span><br><span class="line"><span class="type">bool</span> nvram_old_abi;<span class="comment">// 是否使用旧的 NVRAM ABI</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> *<span class="title">nvram</span>;</span><span class="comment">// NVRAM 的二进制属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">time64_t</span> range_min;<span class="comment">// RTC 设备支持的最小时间范围</span></span><br><span class="line"><span class="type">timeu64_t</span> range_max;<span class="comment">// RTC 设备支持的最大时间范围</span></span><br><span class="line"><span class="type">time64_t</span> start_secs;<span class="comment">// RTC 设备的起始时间（秒）</span></span><br><span class="line"><span class="type">time64_t</span> offset_secs;<span class="comment">// RTC 设备的偏移时间（秒）</span></span><br><span class="line"><span class="type">bool</span> set_start_time;<span class="comment">// 是否设置了起始时间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RTC_INTF_DEV_UIE_EMUL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">uie_task</span>;</span><span class="comment">// 更新中断模拟任务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">uie_timer</span>;</span><span class="comment">// 更新中断模拟定时器</span></span><br><span class="line"><span class="comment">/* Those fields are protected by rtc-&gt;irq_lock */</span>  <span class="comment">/* 以下字段由 rtc-&gt;irq_lock 保护 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> oldsecs;<span class="comment">// 上一次读取的秒数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uie_irq_active:<span class="number">1</span>;<span class="comment">// 更新中断是否激活</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> stop_uie_polling:<span class="number">1</span>;<span class="comment">// 是否停止更新中断轮询</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uie_task_active:<span class="number">1</span>;<span class="comment">// 更新中断任务是否激活</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> uie_timer_active:<span class="number">1</span>;<span class="comment">// 更新中断定时器是否激活</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体是 Linux 内核中 RTC 设备的核心数据结构，涵盖了 RTC 设备的所有功能和状态。</p><h4 id="rx8010-init-client"><a href="#rx8010-init-client" class="headerlink" title="rx8010_init_client()"></a>rx8010_init_client()</h4><p>probe 函数中通过 <code>rx8010_init_client</code> 函数对 RX8010 芯片进行初始化和配置，由于不同的 RTC 芯片寄存器并不相同，因此初始化代码也不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rx8010_init_client</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx8010_data</span> *<span class="title">rx8010</span> =</span> i2c_get_clientdata(client);</span><br><span class="line">u8 ctrl[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> need_clear = <span class="number">0</span>, err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">u8 flag;</span><br><span class="line">    flag = i2c_smbus_read_byte_data(client, RX8010_FLAG);</span><br><span class="line">    <span class="keyword">if</span>(err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    flag &amp;= ~(RX8010_FLAG_VLF);</span><br><span class="line">        err = i2c_smbus_write_byte_data(client, RX8010_FLAG, flag);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialize reserved registers as specified in datasheet */</span></span><br><span class="line">err = i2c_smbus_write_byte_data(client, RX8010_RESV17, <span class="number">0xD8</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err = i2c_smbus_write_byte_data(client, RX8010_RESV30, <span class="number">0x00</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err = i2c_smbus_write_byte_data(client, RX8010_RESV31, <span class="number">0x08</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err = i2c_smbus_write_byte_data(client, RX8010_IRQ, <span class="number">0x00</span>);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">err = i2c_smbus_read_i2c_block_data(rx8010-&gt;client, RX8010_FLAG,</span><br><span class="line">    <span class="number">2</span>, ctrl);</span><br><span class="line"><span class="keyword">if</span> (err != <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> err &lt; <span class="number">0</span> ? err : -EIO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctrl[<span class="number">0</span>] &amp; RX8010_FLAG_VLF)</span><br><span class="line">dev_warn(&amp;client-&gt;dev, <span class="string">&quot;Frequency stop was detected\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctrl[<span class="number">0</span>] &amp; RX8010_FLAG_AF) &#123;</span><br><span class="line">dev_warn(&amp;client-&gt;dev, <span class="string">&quot;Alarm was detected\n&quot;</span>);</span><br><span class="line">need_clear = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctrl[<span class="number">0</span>] &amp; RX8010_FLAG_TF)</span><br><span class="line">need_clear = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctrl[<span class="number">0</span>] &amp; RX8010_FLAG_UF)</span><br><span class="line">need_clear = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (need_clear) &#123;</span><br><span class="line">ctrl[<span class="number">0</span>] &amp;= ~(RX8010_FLAG_AF | RX8010_FLAG_TF | RX8010_FLAG_UF);</span><br><span class="line">err = i2c_smbus_write_byte_data(client, RX8010_FLAG, ctrl[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rx8010-&gt;ctrlreg = (ctrl[<span class="number">1</span>] &amp; ~RX8010_CTRL_TEST);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="struct-rtc-class-ops"><a href="#struct-rtc-class-ops" class="headerlink" title="struct rtc_class_ops"></a>struct rtc_class_ops</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>) &#123;<span class="comment">// 检查设备是否提供了中断号</span></span><br><span class="line">dev_info(&amp;client-&gt;dev, <span class="string">&quot;IRQ %d supplied\n&quot;</span>, client-&gt;irq);</span><br><span class="line">       <span class="comment">// 请求线程化的中断处理程序</span></span><br><span class="line">err = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="literal">NULL</span>,</span><br><span class="line">rx8010_irq_1_handler,</span><br><span class="line">IRQF_TRIGGER_LOW | IRQF_ONESHOT,</span><br><span class="line"><span class="string">&quot;rx8010&quot;</span>, client);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">           <span class="comment">// 如果请求中断失败，打印错误信息并返回错误码</span></span><br><span class="line">dev_err(&amp;client-&gt;dev, <span class="string">&quot;unable to request IRQ\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有中断支持，使用带有报警功能的 RTC 操作函数</span></span><br><span class="line">rtc_ops = &amp;rx8010_rtc_ops_alarm;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 如果没有中断支持，使用默认的 RTC 操作函数</span></span><br><span class="line">rtc_ops = &amp;rx8010_rtc_ops_default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>probe 函数中会根据设备是否提供了中断号来决定 RTC 芯片的操作模式，但无论是硬件连接还是设备树配置中没有使用中断，所以进入的是第二个判断，也就是<code>rtc_ops = &amp;rx8010_rtc_ops_default;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> <span class="title">rx8010_rtc_ops_default</span> =</span> &#123;</span><br><span class="line">.read_time = rx8010_get_time, <span class="comment">// 读取当前时间的函数指针</span></span><br><span class="line">.set_time = rx8010_set_time,  <span class="comment">// 设置当前时间的函数指针</span></span><br><span class="line">.ioctl = rx8010_ioctl,      <span class="comment">// 提供额外控制功能的函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>rx8010_rtc_ops_default</code> 为 RX8010 实时时钟芯片提供一组默认的操作函数接口，包括读取当前时间的函数指针、设置当前时间的函数指针以及 ioctl 外控制功能</p><h4 id="devm-rtc-device-register"><a href="#devm-rtc-device-register" class="headerlink" title="devm_rtc_device_register()"></a>devm_rtc_device_register()</h4><p>在 probe 函数中，使用 <code>devm_rtc_device_register</code> 函数注册 rtc 设备，该函数在 <code>drivers/rtc/class.c</code> 文件中，函数具体内容如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_rtc_device_register - resource managed rtc_device_register()</span></span><br><span class="line"><span class="comment"> * @dev: the device to register</span></span><br><span class="line"><span class="comment"> * @name: the name of the device (unused)</span></span><br><span class="line"><span class="comment"> * @ops: the rtc operations structure</span></span><br><span class="line"><span class="comment"> * @owner: the module owner</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return a struct rtc on success, or an ERR_PTR on error</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Managed rtc_device_register(). The rtc_device returned from this function</span></span><br><span class="line"><span class="comment"> * are automatically freed on driver detach.</span></span><br><span class="line"><span class="comment"> * This function is deprecated, use devm_rtc_allocate_device and</span></span><br><span class="line"><span class="comment"> * rtc_register_device instead</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> rtc_device *<span class="title function_">devm_rtc_device_register</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="keyword">struct</span> rtc_class_ops *ops,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> module *owner)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> *<span class="title">rtc</span>;</span></span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="comment">// 分配设备资源管理器的内存，用于存储 RTC 设备指针</span></span><br><span class="line">rtc = devm_rtc_allocate_device(dev);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rtc))</span><br><span class="line"><span class="keyword">return</span> rtc;<span class="comment">// 如果分配失败，返回错误指针（内存不足）</span></span><br><span class="line"></span><br><span class="line">rtc-&gt;ops = ops;</span><br><span class="line"></span><br><span class="line">err = __rtc_register_device(owner, rtc);<span class="comment">// 调用 rtc_device_register 注册 RTC 设备</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rtc;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(devm_rtc_device_register);</span><br></pre></td></tr></table></figure><h5 id="rtc-register-device"><a href="#rtc-register-device" class="headerlink" title="__rtc_register_device()"></a>__rtc_register_device()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __rtc_register_device(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> rtc_device *rtc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_wkalrm</span> <span class="title">alrm</span>;</span><span class="comment">// 用于存储报警信息</span></span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!rtc-&gt;ops) &#123;</span><br><span class="line">dev_dbg(&amp;rtc-&gt;dev, <span class="string">&quot;no ops set\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtc-&gt;owner = owner;<span class="comment">// 设置模块所有者</span></span><br><span class="line">rtc_device_get_offset(rtc);<span class="comment">// 获取 RTC 设备的时间偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check to see if there is an ALARM already set in hw */</span></span><br><span class="line">    <span class="comment">// 检查硬件中是否已经设置了报警</span></span><br><span class="line">err = __rtc_read_alarm(rtc, &amp;alrm);<span class="comment">// 尝试读取硬件中的报警信息</span></span><br><span class="line"><span class="keyword">if</span> (!err &amp;&amp; !rtc_valid_tm(&amp;alrm.time))<span class="comment">// 如果读取成功且时间有效</span></span><br><span class="line">rtc_initialize_alarm(rtc, &amp;alrm);<span class="comment">// 初始化报警</span></span><br><span class="line"></span><br><span class="line">rtc_dev_prepare(rtc);<span class="comment">// 准备 RTC 设备的字符设备接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 RTC 设备的字符设备和设备结构体添加到内核</span></span><br><span class="line">err = cdev_device_add(&amp;rtc-&gt;char_dev, &amp;rtc-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">dev_warn(rtc-&gt;dev.parent, <span class="string">&quot;failed to add char device %d:%d\n&quot;</span>,</span><br><span class="line"> MAJOR(rtc-&gt;dev.devt), rtc-&gt;id);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dev_dbg(rtc-&gt;dev.parent, <span class="string">&quot;char device (%d:%d)\n&quot;</span>,</span><br><span class="line">MAJOR(rtc-&gt;dev.devt), rtc-&gt;id);</span><br><span class="line"></span><br><span class="line">rtc_proc_add_device(rtc);<span class="comment">// 将 RTC 设备添加到 proc 文件系统中</span></span><br><span class="line"></span><br><span class="line">rtc-&gt;registered = <span class="literal">true</span>;</span><br><span class="line">dev_info(rtc-&gt;dev.parent, <span class="string">&quot;registered as %s\n&quot;</span>,</span><br><span class="line"> dev_name(&amp;rtc-&gt;dev));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RTC_HCTOSYS_DEVICE<span class="comment">// 如果配置了 RTC 作为系统时间源，并且设备名称匹配，则同步硬件时钟到系统时钟</span></span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(dev_name(&amp;rtc-&gt;dev), CONFIG_RTC_HCTOSYS_DEVICE))</span><br><span class="line">rtc_hctosys(rtc);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__rtc_register_device);</span><br></pre></td></tr></table></figure><p>该函数主要作用是注册一个 RTC 设备到 Linux 内核的 RTC 子系统中 。它完成了一系列初始化和资源分配工作，使得内核可以通过标准接口与该 RTC 设备交互。</p><p>重点是调用了<code>cdev_device_add</code> 函数，将 RTC 设备的字符设备和设备结构体注册到内核中，使RTC 设备正式成为内核的一部分，可供用户空间或其他内核模块使用。</p><p>然后是其中的 <code>rtc_proc_add_device</code>，将 RTC 设备的信息添加到 proc 子系统当中，便于调试和监控。</p><h2 id="移植-RX8010-驱动"><a href="#移植-RX8010-驱动" class="headerlink" title="移植 RX8010 驱动"></a>移植 RX8010 驱动</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260105221146876.png" alt="RX8010芯片" loading="lazy"></p><p>可以确定 RX8010 挂载到了 I2C5 上，所以需要在设备树的 i2c5 节点下添加 rx8010 的节点，添加内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c5 &#123;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">rx8010: rx8010@<span class="number">32</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;epson,rx8010&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x32</span>&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"><span class="meta">#clock-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reg 属性表示 RX8010 的地址为 0x32，这里的地址可以根据 RX8010 数据手册得到，具体如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260105221153352.png" alt="RX8010数据手册" loading="lazy"></p><p>这里总共有 8 位的数据，这是因为在实际的数据传输过程中<u>主设备发送的第一个字节包含了从设备地址和读/写位</u>，其中从设备地址占字节的高 7 位（bit 7 到 bit 1），所以从上图可以得到 RX8010 的地址为 0110010，换算就可以得到 0x32 了。</p><p>然后来到 Linux 内核源码的根目录，使用menuconfig打开RX8010驱动</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line"><span class="built_in">Real</span> <span class="built_in">Time</span> Clock</span><br><span class="line">&lt;*&gt; Epson RX8010SJ</span><br></pre></td></tr></table></figure><p>除此之外还要确保 RK 电源管理芯片的内部 RTC 没有被勾选，确保系统里面不会存在两个RTC 设备</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line">Real Time Clock</span><br><span class="line">&lt;*&gt; Rockchip RK805<span class="regexp">/RK808/</span>RK809<span class="regexp">/RK816/</span>RK817/RK818 RTC</span><br></pre></td></tr></table></figure><h1 id="时间相关命令"><a href="#时间相关命令" class="headerlink" title="时间相关命令"></a>时间相关命令</h1><h2 id="date-命令"><a href="#date-命令" class="headerlink" title="date 命令"></a>date 命令</h2><p>date 是 Linux 系统中一个非常强大的命令行工具，用于显示或设置系统的日期和时间。它不仅可以查看当前的系统时间，还可以设置系统时间、格式化日期和时间的输出、解析时间字符串并进行时间计算。</p><ul><li><strong>显示当前日期和时间</strong></li></ul><p>直接运行 date 命令会显示当前系统的日期和时间，格式为默认的本地时间格式，如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">date</span></span><br><span class="line">Mon Jan  5 09:37:49 PM CST 2026</span><br></pre></td></tr></table></figure><blockquote><p>CST表示时区（China Standard Time）</p></blockquote><ul><li><strong>设置系统时间</strong></li></ul><p>使用 date 命令可以设置系统时间的命令格式如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line"><span class="comment"># MM：月份（两位数字，如 10 表示十月）。</span></span><br><span class="line"><span class="comment"># DD：日期（两位数字，如 30 表示 30 日）。</span></span><br><span class="line"><span class="comment"># hh：小时（24 小时制，两位数字，如 14 表示下午 2 点）。</span></span><br><span class="line"><span class="comment"># mm：分钟（两位数字，如 23 表示 23 分钟）。</span></span><br><span class="line"><span class="comment"># CC：世纪（可选，两位数字，如 20 表示 2000 年代）。</span></span><br><span class="line"><span class="comment"># YY：年份（两位数字，如 23 表示 2023 年）。</span></span><br><span class="line"><span class="comment"># .ss：秒数（可选，两位数字，如 .45 表示 45 秒）。</span></span><br></pre></td></tr></table></figure><p>例如将系统时间设置为 2025 年 1 月 20 日 14:23:45：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> 012014232025.45</span><br></pre></td></tr></table></figure><ul><li><strong>格式化输出</strong></li></ul><p>date 命令支持通过格式化字符串自定义输出的日期和时间格式。在 date 命令后加上 + 和格式化字符串，可以指定输出格式。</p><table><thead><tr><th>格式符</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>%Y</code></td><td>年份（四位数字）</td><td>2023</td></tr><tr><td><code>%m</code></td><td>月份（两位数字）</td><td>10</td></tr><tr><td><code>%d</code></td><td>日期（两位数字）</td><td>30</td></tr><tr><td><code>%H</code></td><td>小时（24小时制，两位数字）</td><td>14</td></tr><tr><td><code>%I</code></td><td>小时（12小时制，两位数字）</td><td>02</td></tr><tr><td><code>%M</code></td><td>分钟（两位数字）</td><td>23</td></tr><tr><td><code>%S</code></td><td>秒数（两位数字）</td><td>45</td></tr><tr><td><code>%A</code></td><td>星期几（完整名称）</td><td>Monday</td></tr><tr><td><code>%a</code></td><td>星期几（缩写名称）</td><td>Mon</td></tr><tr><td><code>%B</code></td><td>月份（完整名称）</td><td>October</td></tr><tr><td><code>%b</code></td><td>月份（缩写名称）</td><td>Oct</td></tr><tr><td><code>%p</code></td><td>AM&#x2F;PM</td><td>PM</td></tr><tr><td><code>%Z</code></td><td>时区</td><td>CST</td></tr></tbody></table><p>例如，将格式为 <code>YYYY-MM-DD HH:MM:SS</code>，并输出当前时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> <span class="string">&quot;+%Y-%m-%d %H:%M:%S&quot;</span></span><br></pre></td></tr></table></figure><h2 id="hwclock-命令"><a href="#hwclock-命令" class="headerlink" title="hwclock 命令"></a>hwclock 命令</h2><p>hwclock 是 Linux 系统中用于<strong>管理硬件时钟</strong>的命令行工具。包括查看、设置和同步硬件时钟与系统时钟。</p><ul><li><strong>查看硬件时钟</strong></li></ul><p>直接运行 hwclock 命令会显示当前硬件时钟的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> hwclock</span><br><span class="line">2026-01-05 21:52:44.991760+08:00</span><br></pre></td></tr></table></figure><blockquote><p>hwclock 命令显示的是硬件时钟的时间。硬件时钟通常默认存储的是 UTC 时间，UTC 是目前全球使用的标准时间，它是基于原子时钟的精确时间定义，并且不受地球自转变化的影响。</p><p>UTC 是全球时间的基准，不属于任何时区，因此它也被称为世界标准时间。</p><p>而 date 命令显示的是系统时钟的时间，系统时钟会根据操作系统的时区设置来调整时间。</p><p>上面打印的时区为 CST，即中国时区，那么 date 命令显示的时间会是 UTC+8。因此，系统时钟和硬件时钟使用不同的时间标准，导致二者之间的时间差。假设你在中国（UTC+8），那么两者的时间差正好是 8 小时。</p></blockquote><ul><li><strong>同步硬件时钟与系统时钟</strong><ul><li><code>hwclock -s</code>将系统时钟同步到硬件时钟</li><li><code>hwclock -w</code>将硬件时钟同步到系统时钟</li></ul></li></ul><p>每次系统上电启动之后，都会将 RTC 里面的硬件时间同步到系统时间，具体的实现在内核<code>drivers/rtc/class.c</code> 文件的 <code>rtc_hctosys</code> 函数实现的。该函数的具体内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RTC_HCTOSYS_DEVICE</span></span><br><span class="line"><span class="comment">/* Result of the last RTC to system clock attempt. */</span></span><br><span class="line"><span class="type">int</span> rtc_hctosys_ret = -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IMPORTANT: the RTC only stores whole seconds. It is arbitrary</span></span><br><span class="line"><span class="comment"> * whether it stores the most close value or the value with partial</span></span><br><span class="line"><span class="comment"> * seconds truncated. However, it is important that we use it to store</span></span><br><span class="line"><span class="comment"> * the truncated value. This is because otherwise it is necessary,</span></span><br><span class="line"><span class="comment"> * in an rtc sync function, to read both xtime.tv_sec and</span></span><br><span class="line"><span class="comment"> * xtime.tv_nsec. On some processors (i.e. ARM), an atomic read</span></span><br><span class="line"><span class="comment"> * of &gt;32bits is not possible. So storing the most close value would</span></span><br><span class="line"><span class="comment"> * slow down the sync API. So here we have the truncated value and</span></span><br><span class="line"><span class="comment"> * the best guess is to add 0.5s.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rtc_hctosys</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span><span class="comment">// 用于存储从 RTC 设备读取的时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">tv64</span> =</span> &#123;</span><br><span class="line">.tv_nsec = NSEC_PER_SEC &gt;&gt; <span class="number">1</span>, <span class="comment">// 设置纳秒部分为 0.5 秒（用于时间精度调整）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 RTC 设备读取当前时间</span></span><br><span class="line">err = rtc_read_time(rtc, &amp;tm);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;<span class="comment">// 如果读取时间失败</span></span><br><span class="line">dev_err(rtc-&gt;dev.parent,</span><br><span class="line"><span class="string">&quot;hctosys: unable to read the hardware clock\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 RTC 时间转换为 Unix 时间戳（自 1970 年 1 月 1 日以来的秒数）</span></span><br><span class="line">tv64.tv_sec = rtc_tm_to_time64(&amp;tm);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG == 32 </span></span><br><span class="line"><span class="keyword">if</span> (tv64.tv_sec &gt; INT_MAX) &#123;<span class="comment">// 在 32 位系统上，检查时间戳是否超出范围</span></span><br><span class="line">err = -ERANGE; <span class="comment">// 如果超出范围，设置错误码为 &quot;超出范围&quot;</span></span><br><span class="line"><span class="keyword">goto</span> err_read;<span class="comment">// 跳转到错误处理标签</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">err = do_settimeofday64(&amp;tv64);<span class="comment">// 将时间戳设置为系统时钟</span></span><br><span class="line"></span><br><span class="line">dev_info(rtc-&gt;dev.parent, <span class="string">&quot;setting system clock to %ptR UTC (%lld)\n&quot;</span>,</span><br><span class="line"> &amp;tm, (<span class="type">long</span> <span class="type">long</span>)tv64.tv_sec);</span><br><span class="line"></span><br><span class="line">err_read:</span><br><span class="line">rtc_hctosys_ret = err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 <code>rtc_read_time</code> 函数读取 RTC 硬件里面存储的时间，然后通过<code>do_settimeofday64</code> 函数将转换之后的时间戳设置为系统时钟。</p><h1 id="RTC-应用程序编写"><a href="#RTC-应用程序编写" class="headerlink" title="RTC 应用程序编写"></a>RTC 应用程序编写</h1><h2 id="ioctl-宏定义解析"><a href="#ioctl-宏定义解析" class="headerlink" title="ioctl 宏定义解析"></a><code>ioctl</code> 宏定义解析</h2><h3 id="RTC-RD-TIME"><a href="#RTC-RD-TIME" class="headerlink" title="RTC_RD_TIME"></a><code>RTC_RD_TIME</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_RD_TIME _IOR(<span class="string">&#x27;p&#x27;</span>, 0x09, struct rtc_time)</span></span><br></pre></td></tr></table></figure><ul><li><code>_IOR(type, nr, data_type)</code>：表示 <strong>从内核读取数据到用户空间</strong>。<ul><li><code>&#39;p&#39;</code>：魔数（magic number），用于区分不同设备的 <code>ioctl</code> 命令（RTC 固定为 <code>&#39;p&#39;</code>）。</li><li><code>0x09</code>：命令编号。</li><li><code>struct rtc_time</code>：期望的数据类型。</li></ul></li></ul><blockquote><p>功能：<strong>读取 RTC 硬件当前时间</strong>（注意：不是系统时间！）</p></blockquote><hr><h3 id="RTC-SET-TIME"><a href="#RTC-SET-TIME" class="headerlink" title="RTC_SET_TIME"></a><code>RTC_SET_TIME</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTC_SET_TIME _IOW(<span class="string">&#x27;p&#x27;</span>, 0x0a, struct rtc_time)</span></span><br></pre></td></tr></table></figure><ul><li><code>_IOW(type, nr, data_type)</code>：表示 <strong>从用户空间写入数据到内核</strong>。</li><li>其他参数同上。</li></ul><blockquote><p>功能：<strong>将用户指定的时间写入 RTC 硬件</strong>（通常需要 root 权限）。</p></blockquote><hr><h2 id="struct-rtc-time-结构体"><a href="#struct-rtc-time-结构体" class="headerlink" title="struct rtc_time 结构体"></a><code>struct rtc_time</code> 结构体</h2><p>这是 Linux 内核定义的标准时间结构（位于 <code>&lt;linux/rtc.h&gt;</code>），与 C 标准库的 <code>struct tm</code> <strong>几乎相同</strong>，但<strong>不保证完全兼容</strong>（尤其在跨平台时）。</p><table><thead><tr><th>字段</th><th>范围</th><th>说明</th><th>⚠️ 注意</th></tr></thead><tbody><tr><td><code>tm_sec</code></td><td>0–59</td><td>秒</td><td>—</td></tr><tr><td><code>tm_min</code></td><td>0–59</td><td>分钟</td><td>—</td></tr><tr><td><code>tm_hour</code></td><td>0–23</td><td>小时（24小时制）</td><td>—</td></tr><tr><td><code>tm_mday</code></td><td>1–31</td><td>日期（1号起）</td><td>不是 0-based！</td></tr><tr><td><code>tm_mon</code></td><td><strong>0–11</strong></td><td>月份（0&#x3D;Jan）</td><td><strong>容易出错！</strong></td></tr><tr><td><code>tm_year</code></td><td><strong>年份 - 1900</strong></td><td>如 2023 → <code>123</code></td><td><strong>必须减 1900！</strong></td></tr><tr><td><code>tm_wday</code></td><td>0–6</td><td>星期（0&#x3D;Sun）</td><td>驱动通常自动计算</td></tr><tr><td><code>tm_yday</code></td><td>0–365</td><td>年内第几天</td><td>驱动通常自动计算</td></tr><tr><td><code>tm_isdst</code></td><td>通常为 0</td><td>夏令时标志</td><td>RTC 硬件一般不支持</td></tr></tbody></table><blockquote><p><strong>关键陷阱</strong>：</p><ul><li>设置 2023 年 2 月 15 日 → <code>.tm_year = 123</code>, <code>.tm_mon = 1</code></li><li>打印时要加回去：<code>tm_year + 1900</code>, <code>tm_mon + 1</code></li></ul></blockquote><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rtc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_time</span> <span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须以 O_RDWR 打开才能写 RTC</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/rtc0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Failed to open /dev/rtc0 (try running as root)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取当前 RTC 时间</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, RTC_RD_TIME, &amp;tm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;RTC_RD_TIME&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current RTC time: %d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">           tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday,</span><br><span class="line">           tm.tm_hour, tm.tm_min, tm.tm_sec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 安全修改时间示例：设置为 2023-06-15 12:00:00 ===</span></span><br><span class="line">    <span class="comment">// 注意：这里假设你要设置一个完整、合法的时间</span></span><br><span class="line">    tm.tm_year = <span class="number">123</span>;   <span class="comment">// 2023</span></span><br><span class="line">    tm.tm_mon  = <span class="number">5</span>;     <span class="comment">// June (0-based)</span></span><br><span class="line">    tm.tm_mday = <span class="number">15</span>;    <span class="comment">// 15th</span></span><br><span class="line">    tm.tm_hour = <span class="number">12</span>;</span><br><span class="line">    tm.tm_min  = <span class="number">0</span>;</span><br><span class="line">    tm.tm_sec  = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 可选：清零其他字段（驱动通常会自动计算 wday/yday）</span></span><br><span class="line">    tm.tm_wday = tm.tm_yday = tm.tm_isdst = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 RTC</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, RTC_SET_TIME, &amp;tm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EPERM || errno == EACCES) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error: Permission denied. Run as root or use &#x27;sudo&#x27;.\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;RTC_SET_TIME&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证写入结果</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, RTC_RD_TIME, &amp;tm) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;RTC_RD_TIME (after set)&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Modified RTC time: %d-%02d-%02d %02d:%02d:%02d\n&quot;</span>,</span><br><span class="line">           tm.tm_year + <span class="number">1900</span>, tm.tm_mon + <span class="number">1</span>, tm.tm_mday,</span><br><span class="line">           tm.tm_hour, tm.tm_min, tm.tm_sec);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>读取：通常普通用户可读（取决于 udev 规则）。</p></li><li><p>写入（<code>RTC_SET_TIME</code>）：<strong>需要 root 权限</strong> 或 <code>CAP_SYS_TIME</code> 能力。</p></li></ul></blockquote>]]></content>
    
    
    <summary type="html">Linux RTC</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Linux PWM</title>
    <link href="https://even629.com/posts/2601043/"/>
    <id>https://even629.com/posts/2601043/</id>
    <published>2026-01-04T10:59:00.000Z</published>
    <updated>2026-01-04T10:59:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2026-01-04</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="PWM基础"><a href="#PWM基础" class="headerlink" title="PWM基础"></a>PWM基础</h1><p><strong>PWM</strong> 全称为 <strong>Pulse Width Modulation</strong>，翻译成中文为脉冲宽度调制，它是一种数字信号控制模拟电路的技术，可以通过改变高&#x2F;低电平的占空比来控制平均电压或功率,从而达到对模拟量的控制目的。</p><p>PWM 信号由一个矩形波组成,它包括高电平时间和低电平时间，PWM 信号可以由周期和占空比两个单位进行描述，两个单位的具体描述如下所示：</p><ul><li><strong>周期(T)</strong>：指一个完整的高低电平循环所需要的时间,而频率为周期的倒数，指在 1 秒钟有多少个周期，单位为 Hz，例如一个周期是 20ms，那么一秒钟就有 50 次 PWM 周期。</li><li><strong>占空比(Duty Cycle)</strong>：是指高电平时间与周期的比例,通常以百分比表示，例如周期为 20ms，高电平所占的时间为 10ms，那占空比就是 50%。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190127706.png" alt="PWM" loading="lazy"></p><h2 id="面积等效原理"><a href="#面积等效原理" class="headerlink" title="面积等效原理"></a>面积等效原理</h2><p>面积等效原理的定义为即使脉冲信号的宽度和幅度不同,只要它们的面积(脉冲宽度 × 脉冲幅度)相同,<strong>对于惯性环节的响应</strong>也是基本一致的，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190127748.png" alt="面积等效原理" loading="lazy"></p><p>例如：RK3568 IO 口高电平为 3.3V,低电平为 0V。如果我们想要输出不同的模拟电压,就可以利用 PWM 的面积等效原理技术来实现，通过改变 PWM 信号的占空比,可以调节输出信号的平均电压。</p><ul><li><p>当占空比为 50%时,高电平时间和低电平时间相等,平均输出电压为 1.65V (3.3V × 50%)。</p></li><li><p>占空比为 75%时,高电平时间占总周期的 75%,平均输出电压为 2.47V (3.3V × 75%)。</p></li></ul><p>而除了对电压的控制之外，PWM 还有着以下的工作场景：</p><ul><li>电机控制:控制电机转速和转矩。</li><li>照明控制:控制 LED 亮度。</li><li>信号调制:用于无线电通讯中的调制。</li></ul><h2 id="iTOP-RK3568-PWM-接口"><a href="#iTOP-RK3568-PWM-接口" class="headerlink" title="iTOP-RK3568 PWM 接口"></a>iTOP-RK3568 PWM 接口</h2><p>在 RK3568 芯片内置 16 路 PWM 通道,可以独立控制和输出 PWM 波形。并支持中断驱动,可以灵活响应中断事件。</p><ul><li>PWM 通道采用可编程的预分频器,可以先对总线时钟进行分频,然后再进行二次分频。</li><li>PWM 通道内置了 32 位的定时&#x2F;计数器功能。</li><li>PWM 通道支持捕获模式,可以捕获外部输入信号的脉冲宽度等信息。</li><li>PWM 通道支持连续输出模式和一次性输出模式。</li><li>PWM 通道提供参考模式,可以输出各种占空比的波形。</li><li>PWM3、PWM7、PWM11 和 PWM15 这 4 路 PWM 通道经过优化,特别适用于红外应用。</li></ul><p>上面的 16 路 PWM 都属于硬件 PWM，即由专门的 PWM 硬件模块来实现 PWM 输出，关于硬件 PWM 的介绍如下所示：</p><p><strong>硬件 PWM</strong>:</p><ol><li><strong>实现方式</strong>：硬件 PWM 是由专门的 PWM 硬件模块实现 PWM 输出的方式。</li><li><strong>优点</strong>:<ul><li>CPU 占用低,PWM 输出由硬件模块自动完成,无需 CPU 介入。</li><li>PWM 输出频率和分辨率高,可以达到高达 MHz 级的频率和 ns 级的分辨率。</li><li>输出波形稳定可靠,不易受 CPU 负载的影响。</li></ul></li><li><strong>缺点</strong>:<ul><li>需要专门的硬件 PWM 模块,成本较高。</li><li>PWM 输出引脚受限,只能在预定义的引脚上输出。</li></ul></li></ol><p>iTOP-RK3568 关于硬件 PWM 引脚复用功能表如下所示，可以根据该表格对 PWM 进行选用：</p><table><thead><tr><th>PWM 接口</th><th>pinctrl function</th><th>网络标号</th><th>对应的 GPIO</th><th>功能</th></tr></thead><tbody><tr><td>PWM0</td><td>PWM0_M0</td><td>Working_LEDEN_H_GPIO0_B7</td><td>GPIO0_B7</td><td>LED 灯控制引脚</td></tr><tr><td></td><td>PWM0_M1</td><td>LCD0_PWREN_H_GPIO0_C7</td><td>GPIO0_C7</td><td>LVDS 屏幕供电使能引脚</td></tr><tr><td>PWM1</td><td>PWM1_M0</td><td>VGA_HPDIN_GPIO0_C0</td><td>GPIO0_C0</td><td>VGA 热插拔判断引脚</td></tr><tr><td></td><td>PWM1_M1</td><td>PCIE20_WAKEN_M0</td><td>GPIO0_B5</td><td>PCIE2.0 唤醒</td></tr><tr><td>PWM2</td><td>PWM2_M0</td><td>PCIE20_PERSTn_GPIO0_C1</td><td>GPIO0_C1</td><td>PCIE2.0 复位引脚</td></tr><tr><td></td><td>PWM2_M1</td><td>TP_RST_L_GPIO0_B6</td><td>GPIO0_B6</td><td>MIPI 触摸屏复位引脚</td></tr><tr><td>PWM3_IR</td><td>PWM3_IR</td><td>PWM3_IR</td><td>GPIO0_C2</td><td>红外接收头</td></tr><tr><td>PWM4</td><td>PWM4</td><td>LCD0_BL_PWM4</td><td>GPIO0_C3</td><td>LVDS 屏幕背光</td></tr><tr><td>PWM5</td><td>PWM5</td><td>LCD1_BL_PWM5</td><td>GPIO0_C4</td><td>MIPI 屏幕背光</td></tr><tr><td>PWM6</td><td>PWM6</td><td>PWM_FAN</td><td>GPIO0_C5</td><td>散热风扇转速调节</td></tr><tr><td>PWM7_IR</td><td>PWM7_IR</td><td>RS485_DIR_GPIO0_C6</td><td>GPIO0_C6</td><td>485 收发控制引脚</td></tr><tr><td>PWM8</td><td>PWM8_M0</td><td>UART4_RX_M1</td><td>GPIO3_B1</td><td>串口 4 接收引脚</td></tr><tr><td></td><td>PWM8_M1</td><td>SDMWC0_D0</td><td>GPIO1_D5</td><td>SD 卡数据线</td></tr><tr><td>PWM9</td><td>PWM9_M0</td><td>UART4_TX_M1</td><td>GPIO3_B2</td><td>串口 4 发送引脚</td></tr><tr><td></td><td>PWM9_M1</td><td>SDMWC0_D1</td><td>GPIO1_D5</td><td>SD 卡数据线</td></tr><tr><td>PWM10</td><td>PWM10_M0</td><td>GPIO3_B5</td><td>GPIO3_B5</td><td>未使用</td></tr><tr><td></td><td>PWM10_M1</td><td>SDMWC0_CMD</td><td>GPIO2_A1</td><td>SD 卡 CMD 引脚</td></tr><tr><td>PWM11</td><td>PWM11_IR_M0</td><td>GPIO3_B6</td><td>GPIO3_B6</td><td>未使用</td></tr><tr><td></td><td>PWM11_IR_M1</td><td>CIF_CLKOUT</td><td>GPIO4_C0</td><td>未使用</td></tr><tr><td>PWM12</td><td>PWM12_M0</td><td>GMAC0_RSTn_GPIO3_B7</td><td>GPIO3_B7</td><td>网卡 0 复位引脚</td></tr><tr><td></td><td>PWM12_M1</td><td>GPIO4_C5</td><td>GPIO4_C5</td><td>串口 9 发送引脚</td></tr><tr><td>PWM13</td><td>PWM13_M0</td><td>GMAC0_INT&#x2F;PMEB_GPIO3_C0</td><td>GPIO3_C0</td><td>网卡 0 中断引脚</td></tr><tr><td></td><td>PWM13_M1</td><td>GPIO4_C6</td><td>GPIO4_C6</td><td>串口 9 接收引脚</td></tr><tr><td>PWM14</td><td>PWM14_M0</td><td>UART7_TX_M1</td><td>GPIO3_C4</td><td>串口 7 发送引脚</td></tr><tr><td></td><td>PWM14_M1</td><td>4G_DISABLE_GPIO4_C2</td><td>GPIO4_C2</td><td>CAN1 RX</td></tr><tr><td>PWM15</td><td>PWM15_IR_M0</td><td>UART7_RX_M1</td><td>GPIO3_C5</td><td>串口 7 接收引脚</td></tr><tr><td></td><td>PWM15_IR_M1</td><td>HDMI_RX_INT_L_GPIO4_C3</td><td>GPIO4_C3</td><td>CAN1 TX</td></tr></tbody></table><p>而当硬件 PWM 不够用的时候，可以使用 GPIO 来模拟实现 PWM，也可以称之为软件 PWM，关于软件 PWM 的介绍如下所示：</p><p><strong>软件 PWM</strong>:</p><ol><li><strong>实现方式</strong>：软件 PWM 是通过软件编程实现 PWM 输出的方式。利用定时器中断或者循环计数的方式,在软件中控制输出引脚的高低电平切换时间,从而生成 PWM 波形。</li><li><strong>优点:</strong><ul><li>灵活性强,可以在任意 GPIO 引脚上生成 PWM 波形。</li><li>成本低,不需要额外的硬件 PWM 模块。</li></ul></li><li><strong>缺点</strong>:<ul><li>CPU 占用较高,因为需要在中断服务程序或者循环中实时控制引脚电平。</li><li>PWM 输出的频率和分辨率受 CPU 主频和中断响应时间的影响,无法高频高分辨率。</li><li>对 CPU 性能和实时性要求较高。</li></ul></li></ol><h1 id="PWM-子系统框架"><a href="#PWM-子系统框架" class="headerlink" title="PWM 子系统框架"></a>PWM 子系统框架</h1><p>PWM 子系统可以划分成三个层次，分别为用户空间、内核空间和硬件层。</p><p>内核空间包括 PWM 设备驱动层、PWM 核心层和 PWM 适配器驱动层。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190127787.png" alt="PWM子系统框架" loading="lazy"></p><h2 id="PWM设备驱动层"><a href="#PWM设备驱动层" class="headerlink" title="PWM设备驱动层"></a>PWM设备驱动层</h2><p>PWM 设备驱动层在 Linux 内核中扮演了一个关键的角色,它为上层应用程序提供了一个统一、灵活和高效的 PWM 设备访问接口</p><ul><li><code>pwm_device</code><ul><li>代表一个连接到 PWM 总线上的从设备。</li><li>包含从设备的 PWM 通道号、所属的 PWM 控制器等信息。</li></ul></li><li><code>pwm_driver</code><ul><li>实现了具体 PWM 设备的驱动程序。</li><li>负责 PWM 设备的初始化、配置、启停等操作。</li><li>通过 pwm_chip 与 PWM 硬件设备进行交互。</li><li>向上层提供标准化的 PWM 设备访问接口。</li></ul></li><li><code>/dev/xxx</code> 设备节点<ul><li>为上层应用程序提供 PWM 设备访问的接口</li><li>通过打开&#x2F;读写&#x2F;控制设备节点,应用程序可以与 PWM 设备进行交互</li><li>内核 PWM 子系统负责将应用程序的操作转发到对应的 pwm_chip 驱动</li></ul></li></ul><h2 id="PWM核心层"><a href="#PWM核心层" class="headerlink" title="PWM核心层"></a>PWM核心层</h2><p>PWM 核心层是 Linux 内核中负责管理和控制 PWM 设备的重要组件。它的主要作用如下:</p><ul><li><strong>PWM 设备管理</strong><br>通过 <code>struct pwm_device</code> 统一描述 PWM 设备的信息,如设备名称、所属控制器等。为上层应用程序提供标准化的 PWM 设备访问 API。</li><li><strong>PWM 参数配置</strong><br>提供 <code>pwm_config</code> 接口,用于配置 PWM 设备的工作参数,如周期、占空比、极性等。将上层配置参数转换为底层硬件可以理解的形式,并通过适配器驱动进行设置。</li><li><strong>PWM 输出控制</strong><br>提供 <code>pwm_enable</code> 和 <code>pwm_disable</code> 接口,用于控制 PWM 输出的开启和关闭。负责调用适配器驱动程序的相应函数来执行实际的输出控制。</li><li><strong>PWM sysfs 接口</strong><br>PWM 核心层还提供了一组基于 sysfs 的接口,用于上层应用程序对 PWM 设备进行配置和控制。这些 sysfs 接口包括:<ul><li><code>/sys/class/pwm/pwmX/period</code>: 设置 PWM 周期</li><li><code>/sys/class/pwm/pwmX/duty_cycle</code>: 设置 PWM 占空比</li><li><code>/sys/class/pwm/pwmX/polarity</code>: 设置 PWM 极性</li><li><code>/sys/class/pwm/pwmX/enable</code>: 控制 PWM 输出的开启和关闭</li></ul></li></ul><h2 id="PWM控制器驱动层"><a href="#PWM控制器驱动层" class="headerlink" title="PWM控制器驱动层"></a>PWM控制器驱动层</h2><p>PWM 控制器驱动层是连接 PWM 硬件和上层 PWM 核心层的关键组件, 它负责对底层 PWM硬件进行抽象化封装, 并适配不同类型的 PWM 设备, 为上层提供标准化的硬件控制接口, 同时还需要处理一些硬件相关的初始化、状态管理和电源管理等任务。</p><p><strong>硬件抽象化</strong></p><p>PWM 适配器驱动层负责对底层 PWM 硬件设备进行抽象化封装。它定义了一组标准化的 <code>pwm_chip</code> 接口,包括设备初始化、参数配置、输出控制等功能。</p><p>上层 PWM 核心层可以通过调用这些标准接口来间接控制底层 PWM 硬件, 而不需要关注具体的硬件实现细节。</p><p><strong>硬件适配</strong></p><p>PWM适配器驱动程序需要实现 pwm_chip 接口中定义的各个函数,以适配底层PWM硬件的具体工作方式。这些适配函数将上层 PWM 核心层的标准化请求, 转换为底层硬件可以理解的操作指令。</p><p>通过这种适配层, PWM 核心层可以无缝地支持不同类型的 PWM 硬件设备。</p><p><strong>硬件初始化</strong></p><p>PWM 适配器驱动程序负责完成 PWM 硬件设备的初始化工作, 包括 GPIO、时钟、电源等相关资源的配置和初始化。</p><p>在 PWM 设备注册时,适配器驱动会执行初始化操作,确保硬件设备处于可用状态。</p><p><strong>状态管理</strong></p><p>适配器驱动程序需要维护 PWM 硬件设备的当前状态,如设备是否已经被使能、当前的工作参数等。这些状态信息会反馈给上层 PWM 核心层,以确保核心层能够正确地控制和管理 PWM设备。</p><p>至此对于 PWM 子系统框架的讲解就完成了，在下个章节将会对 sysfs 接口操作 PWM 的方式进行讲解。</p><h2 id="使用-sysfs-接口操作-pwm"><a href="#使用-sysfs-接口操作-pwm" class="headerlink" title="使用 sysfs 接口操作 pwm"></a>使用 sysfs 接口操作 pwm</h2><p>PWM核心层提供了sysfs操作pwm的接口，不过要想操作 PWM，首先需要将对应的 IO 口配置为 PWM 功能，选用的 IO 口为 iTOP-RK3568 背板 20 PIN GPIO 接口的 6 号引脚，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190127827.png" alt="硬件连接" loading="lazy"></p><p>根据 PWM 引脚复用表可知，PWM12_M1 功能引脚默认被复用为了串口 9，所以需要修改设备树将复用功能设置为 PWM</p><p>找到 uart9 节点，将 status 从 okay 修改为 disabled，然后设置PWM12</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;pwm12</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pwm12m1_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><h3 id="sys-class-pwm"><a href="#sys-class-pwm" class="headerlink" title="&#x2F;sys&#x2F;class&#x2F;pwm&#x2F;"></a>&#x2F;sys&#x2F;class&#x2F;pwm&#x2F;</h3><p>首先来到<code>/sys/class/pwm/</code>目录下，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190127869.png" alt="&#x2F;sys&#x2F;class&#x2F;pwm&#x2F;" loading="lazy"></p><p>对应关系如下</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190127917.png" alt="pwm" loading="lazy"></p><p>PWM12_M1 对应为 pwmchip3，进入 pwmchip3 目录之后如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190127950.png" alt="pwmchip3" loading="lazy"></p><p>在这个目录下总共有七个文件分别为 <strong>device</strong>、<strong>export</strong>、<strong>npwm</strong>、<strong>power</strong>、<strong>subsystem</strong>、<strong>uevent</strong> 和 <strong>unexport</strong>。需要关注的是 export、npwm 以及 unexport 这三个属性文件</p><ul><li><strong>npwm</strong>：是一个只读属性，读取该文件可以得知该 PWM 控制器下共有几路 PWM 输出，如下所示：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190127996.png" alt="npwm" loading="lazy"></p><ul><li><strong>export</strong>：在使用 PWM 之前，通过 export 属性进行导出，以下所示：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190128056.png" alt="export" loading="lazy"></p><ul><li><strong>unexport</strong>：当使用完 PWM 之后，需要将导出的 PWM 删除，譬如：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190128106.png" alt="unexport" loading="lazy"></p><blockquote><p>需要注意的是，export 文件和 unexport 文件都是只写的、没有读权限。</p></blockquote><p>再次使用以下命令导出 pwm0 目录，导出成功之后进入该文件夹如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190128154.png" alt="&#x2F;sys&#x2F;class&#x2F;pwm&#x2F;pwmchip3&#x2F;pwm0" loading="lazy"></p><ul><li><strong>polarity</strong>：用于 PWM 极性的查看，有 normal 和 inversed 可选<ul><li>normal 表示 PWM 信号为正极性,即高电平为有效信号</li><li>inversed 表示 PWM 信号为负极性,即低电平为有效信号。</li></ul></li><li><strong>period</strong>：用于配置 PWM 周期，可读可写；写入一个字符串数字值，以 ns（纳秒）为单位</li><li><strong>duty_cycle</strong>：用于配置 PWM 的占空比，可读可写；写入一个字符串数字值，同样也是以ns 为单位。</li><li><strong>enable</strong>：使能 PWM 输出通常配置好 PWM 之后，再使能 PWM。可读可写。<ul><li>写入”0”表示禁止 PWM；</li><li>写入”1”表示使能 PWM</li></ul></li></ul><h3 id="SG-90-舵机介绍"><a href="#SG-90-舵机介绍" class="headerlink" title="SG-90 舵机介绍"></a>SG-90 舵机介绍</h3><p>SG90 舵机是一种广泛应用于机器人、遥控飞机、遥控汽车等领域的小型伺服电机。它以其小巧的尺寸、轻便的重量、低功耗和高性价比而备受青睐。</p><p><strong>工作原理</strong></p><p>SG90 舵机通过脉宽调制（PWM）信号来控制位置。<strong>PWM 信号的宽度决定了舵机的旋转角度</strong>。</p><p>典型的控制信号周期为 20ms，其中高电平部分的持续时间（0.5ms 至 2.5ms）对应舵机从 0 度到 180 度的转动范围，具体对应 关系如下所示</p><table><thead><tr><th>高电平持续时间</th><th>转动角度</th></tr></thead><tbody><tr><td>0.5 ms</td><td>0°</td></tr><tr><td>1.0 ms</td><td>45°</td></tr><tr><td>1.5 ms</td><td>90°</td></tr><tr><td>2.0 ms</td><td>135°</td></tr><tr><td>2.5 ms</td><td>180°</td></tr></tbody></table><p><strong>硬件连接</strong></p><table><thead><tr><th>线缆颜色</th><th>功能</th><th>背板 20pin 引脚编号</th><th>网络标号</th></tr></thead><tbody><tr><td>红线</td><td>电源正极 (5V)</td><td>10&#x2F;12</td><td>VCC5V0_SYS</td></tr><tr><td>棕线</td><td>电源负极 (GND)</td><td>19&#x2F;20</td><td>GND</td></tr><tr><td>橙线</td><td>控制信号线 (PWM 信号)</td><td>6</td><td>UART9_TX_M1(GPIO4_C5)</td></tr></tbody></table><p><strong>应用场景</strong></p><ul><li>机器人: 用于机器人中的关节或其他可动部件，因其精确的角度控制使其适合多自由度运动的实现。</li><li>遥控模型: 用于控制舵面或车轮方向，实现灵活的操控。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>通过以下命令让舵机转动 135 度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 PWM 周期为 20 ms</span></span><br><span class="line"><span class="built_in">echo</span> 20000000 &gt; period</span><br><span class="line"><span class="comment"># 设置 PWM 高电平持续时间为 2 ms</span></span><br><span class="line"><span class="built_in">echo</span> 2000000 &gt; duty_cycle</span><br><span class="line"><span class="comment"># 设置 PWM 极性为正极性（normal）</span></span><br><span class="line"><span class="built_in">echo</span> normal &gt; polarity</span><br><span class="line"><span class="comment"># 启用 PWM 输出</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; <span class="built_in">enable</span></span><br></pre></td></tr></table></figure><h2 id="PWM-控制器注册流程分析"><a href="#PWM-控制器注册流程分析" class="headerlink" title="PWM 控制器注册流程分析"></a>PWM 控制器注册流程分析</h2><p>rk3568.dtsi 设备树，pwm 相关的节点如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">pwm0:</span> <span class="title class_">pwm@fdd70000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-pwm&quot;</span>, <span class="string">&quot;rockchip,rk3328-pwm&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfdd70000</span> <span class="number">0x0</span> <span class="number">0x10</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#pwm-cells = &lt;3&gt;;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;active&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pwm0m0_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;pmucru</span> CLK_PWM0&gt;</span>, <span class="params">&lt;<span class="variable">&amp;pmucru</span> PCLK_PWM0&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;pwm&quot;</span>, <span class="string">&quot;pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">pwm1:</span> <span class="title class_">pwm@fdd70010</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-pwm&quot;</span>, <span class="string">&quot;rockchip,rk3328-pwm&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfdd70010</span> <span class="number">0x0</span> <span class="number">0x10</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#pwm-cells = &lt;3&gt;;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;active&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pwm1m0_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;pmucru</span> CLK_PWM0&gt;</span>, <span class="params">&lt;<span class="variable">&amp;pmucru</span> PCLK_PWM0&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;pwm&quot;</span>, <span class="string">&quot;pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>根据 PWM 节点的 compatible 属性进行查找，可以找到瑞芯微的 PWM 驱动路径为内核目录下的 <code>drivers/pwm/pwm-rockchip.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">rockchip_pwm_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">&quot;rockchip-pwm&quot;</span>,</span><br><span class="line">.of_match_table = rockchip_pwm_dt_ids,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = rockchip_pwm_probe,</span><br><span class="line">.remove = rockchip_pwm_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后来看该驱动程序的 probe 函数，具体内容如下所示：</p><h3 id="rockchip-pwm-probe"><a href="#rockchip-pwm-probe" class="headerlink" title="rockchip_pwm_probe()"></a>rockchip_pwm_probe()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pwm_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">id</span>;</span><span class="comment">// 设备树匹配 ID</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pwm_chip</span> *<span class="title">pc</span>;</span><span class="comment">// PWM 芯片结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">r</span>;</span><span class="comment">// 资源信息</span></span><br><span class="line">u32 enable_conf, ctrl;</span><br><span class="line"><span class="type">bool</span> enabled;</span><br><span class="line"><span class="type">int</span> ret, count;<span class="comment">// 返回值和计数变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备树匹配</span></span><br><span class="line">id = of_match_device(rockchip_pwm_dt_ids, &amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (!id)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 PWM 芯片结构体</span></span><br><span class="line">pc = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*pc), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!pc)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取内存资源并映射 IO 地址</span></span><br><span class="line">r = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">pc-&gt;base = devm_ioremap(&amp;pdev-&gt;dev, r-&gt;start,</span><br><span class="line">resource_size(r));</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pc-&gt;base))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(pc-&gt;base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 PWM 总线时钟</span></span><br><span class="line">pc-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;pwm&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pc-&gt;clk)) &#123;</span><br><span class="line">pc-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pc-&gt;clk))</span><br><span class="line"><span class="keyword">return</span> dev_err_probe(&amp;pdev-&gt;dev, PTR_ERR(pc-&gt;clk),</span><br><span class="line">     <span class="string">&quot;Can&#x27;t get bus clk\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 APB 时钟</span></span><br><span class="line">count = of_count_phandle_with_args(pdev-&gt;dev.of_node,</span><br><span class="line">   <span class="string">&quot;clocks&quot;</span>, <span class="string">&quot;#clock-cells&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">2</span>)</span><br><span class="line">pc-&gt;pclk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;pclk&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pc-&gt;pclk = pc-&gt;clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pc-&gt;pclk)) &#123;</span><br><span class="line">ret = PTR_ERR(pc-&gt;pclk);</span><br><span class="line"><span class="keyword">if</span> (ret != -EPROBE_DEFER)</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t get APB clk: %d\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使能总线时钟</span></span><br><span class="line">ret = clk_prepare_enable(pc-&gt;clk);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t prepare enable bus clk: %d\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使能 APB 时钟</span></span><br><span class="line">ret = clk_prepare_enable(pc-&gt;pclk);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Can&#x27;t prepare enable APB clk: %d\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">goto</span> err_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pc-&gt;channel_id = rockchip_pwm_get_channel_id(pdev-&gt;dev.of_node-&gt;full_name);</span><br><span class="line"><span class="keyword">if</span> (pc-&gt;channel_id &lt; <span class="number">0</span> || pc-&gt;channel_id &gt;= PWM_MAX_CHANNEL_NUM) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Channel id is out of range: %d\n&quot;</span>, pc-&gt;channel_id);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_pclk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_PWM_ROCKCHIP_ONESHOT)) &#123;</span><br><span class="line">pc-&gt;irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pc-&gt;irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Get oneshot mode irq failed\n&quot;</span>);</span><br><span class="line">ret = pc-&gt;irq;</span><br><span class="line"><span class="keyword">goto</span> err_pclk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = devm_request_irq(&amp;pdev-&gt;dev, pc-&gt;irq, rockchip_pwm_oneshot_irq,</span><br><span class="line">       IRQF_NO_SUSPEND | IRQF_SHARED,</span><br><span class="line">       <span class="string">&quot;rk_pwm_oneshot_irq&quot;</span>, pc);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Claim oneshot IRQ failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_pclk;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取引脚控制器</span></span><br><span class="line">pc-&gt;pinctrl = devm_pinctrl_get(&amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pc-&gt;pinctrl)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Get pinctrl failed!\n&quot;</span>);</span><br><span class="line">ret = PTR_ERR(pc-&gt;pinctrl);</span><br><span class="line"><span class="keyword">goto</span> err_pclk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取引脚控制器的活动状态</span></span><br><span class="line">pc-&gt;active_state = pinctrl_lookup_state(pc-&gt;pinctrl, <span class="string">&quot;active&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(pc-&gt;active_state)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;No active pinctrl state\n&quot;</span>);</span><br><span class="line">ret = PTR_ERR(pc-&gt;active_state);</span><br><span class="line"><span class="keyword">goto</span> err_pclk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置驱动数据</span></span><br><span class="line">platform_set_drvdata(pdev, pc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 PWM 芯片结构体</span></span><br><span class="line">pc-&gt;data = id-&gt;data;</span><br><span class="line">pc-&gt;chip.dev = &amp;pdev-&gt;dev;</span><br><span class="line">pc-&gt;chip.ops = &amp;rockchip_pwm_ops;</span><br><span class="line">pc-&gt;chip.base = of_alias_get_id(pdev-&gt;dev.of_node, <span class="string">&quot;pwm&quot;</span>);</span><br><span class="line">pc-&gt;chip.npwm = <span class="number">1</span>;</span><br><span class="line">pc-&gt;clk_rate = clk_get_rate(pc-&gt;clk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果支持极性设置, 则使用带有极性的 of_pwm_xlate 函数</span></span><br><span class="line"><span class="keyword">if</span> (pc-&gt;data-&gt;supports_polarity) &#123;</span><br><span class="line">pc-&gt;chip.of_xlate = of_pwm_xlate_with_flags;</span><br><span class="line">pc-&gt;chip.of_pwm_n_cells = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enable_conf = pc-&gt;data-&gt;enable_conf;</span><br><span class="line">ctrl = readl_relaxed(pc-&gt;base + pc-&gt;data-&gt;regs.ctrl);</span><br><span class="line">enabled = (ctrl &amp; enable_conf) == enable_conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为中心对齐模式</span></span><br><span class="line">pc-&gt;center_aligned =</span><br><span class="line">device_property_read_bool(&amp;pdev-&gt;dev, <span class="string">&quot;center-aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 PWM 芯片</span></span><br><span class="line">ret = pwmchip_add(&amp;pc-&gt;chip);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;pwmchip_add() failed: %d\n&quot;</span>, ret);</span><br><span class="line"><span class="keyword">goto</span> err_pclk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keep the PWM clk enabled if the PWM appears to be up and running. */</span></span><br><span class="line"><span class="keyword">if</span> (!enabled)<span class="comment">// 如果 PWM 未启用, 则禁用总线时钟</span></span><br><span class="line">clk_disable(pc-&gt;clk);</span><br><span class="line"></span><br><span class="line">clk_disable(pc-&gt;pclk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_pclk:</span><br><span class="line">clk_disable_unprepare(pc-&gt;pclk);</span><br><span class="line">err_clk:</span><br><span class="line">clk_disable_unprepare(pc-&gt;clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建了一个 <code>struct rockchip_pwm_chip</code> 类型的指针变量，它主要用于描述 Rockchip 系列 SoC 上的 PWM 控制器的硬件特性和配置信息，具体内容如下所示：</p><h4 id="struct-rockchip-pwm-chip"><a href="#struct-rockchip-pwm-chip" class="headerlink" title="struct rockchip_pwm_chip"></a>struct rockchip_pwm_chip</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pwm_chip</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_chip</span> <span class="title">chip</span>;</span><span class="comment">// 通用 PWM 控制器芯片接口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span><span class="comment">// PWM 控制器的主时钟</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">pclk</span>;</span><span class="comment">// PWM 控制器的外设时钟</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span><span class="comment">// PWM 控制器的引脚复用控制器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">active_state</span>;</span><span class="comment">// PWM 控制器当前使用的引脚状态</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pwm_data</span> *<span class="title">data</span>;</span><span class="comment">// 特定于 Rockchip SoC 的 PWM 控制器配置信息</span></span><br><span class="line"><span class="type">void</span> __iomem *base;<span class="comment">// PWM 控制器寄存器空间的内核虚拟地址</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> clk_rate;<span class="comment">// PWM 控制器当前使用的时钟频率</span></span><br><span class="line"><span class="type">bool</span> vop_pwm_en; <span class="comment">// 标识 VOP (视频输出处理器) 是否也使能了 PWM 功能</span></span><br><span class="line"><span class="type">bool</span> center_aligned;<span class="comment">// 标识 PWM 控制器是否支持中心对齐模式</span></span><br><span class="line"><span class="type">bool</span> oneshot;<span class="comment">// 标识 PWM 控制器是否支持单次触发模式</span></span><br><span class="line"><span class="type">int</span> channel_id;</span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中第二行的 <code>struct pwm_chip</code> 结构体是 PWM 子系统中对 PWM 控制器的一种抽象和封装。</p><p>它将 PWM 控制器的基本信息和操作函数集中到一个结构体中,方便上层 PWM 框架进行管理和调用，该结构体定义在<code>include/linux/pwm.h</code> 文件中，具体内容如下所示：</p><h4 id="struct-pwm-chip"><a href="#struct-pwm-chip" class="headerlink" title="struct pwm_chip"></a>struct pwm_chip</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pwm_chip - abstract a PWM controller</span></span><br><span class="line"><span class="comment"> * @dev: device providing the PWMs</span></span><br><span class="line"><span class="comment"> * @ops: callbacks for this PWM controller</span></span><br><span class="line"><span class="comment"> * @base: number of first PWM controlled by this chip</span></span><br><span class="line"><span class="comment"> * @npwm: number of PWMs controlled by this chip</span></span><br><span class="line"><span class="comment"> * @of_xlate: request a PWM device given a device tree PWM specifier</span></span><br><span class="line"><span class="comment"> * @of_pwm_n_cells: number of cells expected in the device tree PWM specifier</span></span><br><span class="line"><span class="comment"> * @list: list node for internal use</span></span><br><span class="line"><span class="comment"> * @pwms: array of PWM devices allocated by the framework</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_chip</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span><span class="comment">// PWM 控制器所属的设备</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pwm_ops</span> *<span class="title">ops</span>;</span><span class="comment">// PWM 控制器的操作函数集</span></span><br><span class="line"><span class="type">int</span> base;<span class="comment">// PWM 控制器的寄存器基地址偏移</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> npwm;<span class="comment">// PWM 控制器提供的 PWM 通道数量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_device</span> * (*<span class="title">of_xlate</span>)(<span class="keyword">struct</span> <span class="title">pwm_chip</span> *<span class="title">pc</span>,</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="keyword">struct</span> <span class="title">of_phandle_args</span> *<span class="title">args</span>);</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> of_pwm_n_cells;<span class="comment">// 设备树中 PWM 属性描述所需的属性数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* only used internally by the PWM framework */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span><span class="comment">// PWM 控制器所在的全局链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_device</span> *<span class="title">pwms</span>;</span><span class="comment">// PWM 通道设备数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>pwm_ops</code>表示PWM 控制器的操作函数集</p><h4 id="struct-pwm-ops"><a href="#struct-pwm-ops" class="headerlink" title="struct pwm_ops"></a>struct pwm_ops</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pwm_ops - PWM controller operations</span></span><br><span class="line"><span class="comment"> * @request: optional hook for requesting a PWM</span></span><br><span class="line"><span class="comment"> * @free: optional hook for freeing a PWM</span></span><br><span class="line"><span class="comment"> * @capture: capture and report PWM signal</span></span><br><span class="line"><span class="comment"> * @apply: atomically apply a new PWM config</span></span><br><span class="line"><span class="comment"> * @get_state: get the current PWM state. This function is only</span></span><br><span class="line"><span class="comment"> *       called once per PWM device when the PWM chip is</span></span><br><span class="line"><span class="comment"> *       registered.</span></span><br><span class="line"><span class="comment"> * @get_output_type_supported: get the supported output type of this PWM</span></span><br><span class="line"><span class="comment"> * @owner: helps prevent removal of modules exporting active PWMs</span></span><br><span class="line"><span class="comment"> * @config: configure duty cycles and period length for this PWM</span></span><br><span class="line"><span class="comment"> * @set_polarity: configure the polarity of this PWM</span></span><br><span class="line"><span class="comment"> * @enable: enable PWM output toggling</span></span><br><span class="line"><span class="comment"> * @disable: disable PWM output toggling</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_ops</span> &#123;</span></span><br><span class="line"><span class="type">int</span> (*request)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line"><span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line"><span class="type">int</span> (*capture)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">       <span class="keyword">struct</span> pwm_capture *result, <span class="type">unsigned</span> <span class="type">long</span> timeout);</span><br><span class="line"><span class="type">int</span> (*apply)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">     <span class="type">const</span> <span class="keyword">struct</span> pwm_state *state);</span><br><span class="line"><span class="type">void</span> (*get_state)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">  <span class="keyword">struct</span> pwm_state *state);</span><br><span class="line"><span class="type">int</span> (*get_output_type_supported)(<span class="keyword">struct</span> pwm_chip *chip,</span><br><span class="line"><span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only used by legacy drivers */</span></span><br><span class="line"><span class="type">int</span> (*config)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">      <span class="type">int</span> duty_ns, <span class="type">int</span> period_ns);</span><br><span class="line"><span class="type">int</span> (*set_polarity)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">    <span class="keyword">enum</span> pwm_polarity polarity);</span><br><span class="line"><span class="type">int</span> (*enable)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line"><span class="type">void</span> (*disable)(<span class="keyword">struct</span> pwm_chip *chip, <span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后回到 <code>drivers/pwm/pwm-rockchip.c</code> 文件中找到 <code>rockchip_pwm_ops</code> 操作集，可以发现瑞芯微只实现了状态获取和申请两个函数，具体内容如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pwm_ops</span> <span class="title">rockchip_pwm_ops</span> =</span> &#123;</span><br><span class="line">.get_state = rockchip_pwm_get_state,</span><br><span class="line">.apply = rockchip_pwm_apply,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="pwmchip-add"><a href="#pwmchip-add" class="headerlink" title="pwmchip_add()"></a>pwmchip_add()</h3><p><code>rockchip_pwm_probe()</code> 中调用了<code>pwmchip_add</code> 函数将 PWM 控制器添加到 PWM 子系统中，<code>pwmchip_add</code> 函数定义在 <code>drivers/pwm/core.c</code> 文件中，具体内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pwmchip_add() - register a new PWM chip</span></span><br><span class="line"><span class="comment"> * @chip: the PWM chip to add</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register a new PWM chip. If chip-&gt;base &lt; 0 then a dynamically assigned base</span></span><br><span class="line"><span class="comment"> * will be used. The initial polarity for all channels is normal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: 0 on success or a negative error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pwmchip_add</span><span class="params">(<span class="keyword">struct</span> pwm_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pwmchip_add_with_polarity(chip, PWM_POLARITY_NORMAL);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pwmchip_add);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pwmchip_add_with_polarity() - register a new PWM chip</span></span><br><span class="line"><span class="comment"> * @chip: the PWM chip to add</span></span><br><span class="line"><span class="comment"> * @polarity: initial polarity of PWM channels</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register a new PWM chip. If chip-&gt;base &lt; 0 then a dynamically assigned base</span></span><br><span class="line"><span class="comment"> * will be used. The initial polarity for all channels is specified by the</span></span><br><span class="line"><span class="comment"> * @polarity parameter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns: 0 on success or a negative error code on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pwmchip_add_with_polarity</span><span class="params">(<span class="keyword">struct</span> pwm_chip *chip,</span></span><br><span class="line"><span class="params">      <span class="keyword">enum</span> pwm_polarity polarity)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_device</span> *<span class="title">pwm</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!chip || !chip-&gt;dev || !chip-&gt;ops || !chip-&gt;npwm)<span class="comment">// 检查 chip 结构体的有效性</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 pwm_ops 结构体的有效性</span></span><br><span class="line"><span class="keyword">if</span> (!pwm_ops_check(chip))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全局 pwm_lock 互斥锁</span></span><br><span class="line">mutex_lock(&amp;pwm_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 chip 分配 PWM 设备索引号</span></span><br><span class="line">ret = alloc_pwms(chip-&gt;base, chip-&gt;npwm);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配 chip-&gt;npwm 个 pwm_device 结构体</span></span><br><span class="line">chip-&gt;pwms = kcalloc(chip-&gt;npwm, <span class="keyword">sizeof</span>(*pwm), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!chip-&gt;pwms) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存分配的 PWM 设备索引号</span></span><br><span class="line">chip-&gt;base = ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化每个 PWM 设备</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; chip-&gt;npwm; i++) &#123;</span><br><span class="line">pwm = &amp;chip-&gt;pwms[i];</span><br><span class="line"></span><br><span class="line">pwm-&gt;chip = chip;</span><br><span class="line">pwm-&gt;pwm = chip-&gt;base + i;</span><br><span class="line">pwm-&gt;hwpwm = i;</span><br><span class="line">pwm-&gt;state.polarity = polarity;</span><br><span class="line">pwm-&gt;state.output_type = PWM_OUTPUT_FIXED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 PWM 设备添加到全局 PWM 设备树中</span></span><br><span class="line">radix_tree_insert(&amp;pwm_tree, pwm-&gt;pwm, pwm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记分配的 PWM 设备为已使用</span></span><br><span class="line">bitmap_set(allocated_pwms, chip-&gt;base, chip-&gt;npwm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 PWM 控制器添加到全局 PWM 控制器链表</span></span><br><span class="line">INIT_LIST_HEAD(&amp;chip-&gt;<span class="built_in">list</span>);</span><br><span class="line">list_add(&amp;chip-&gt;<span class="built_in">list</span>, &amp;pwm_chips);</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果内核开启了 Device Tree 支持,则注册 PWM 控制器到 Device Tree</span></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_OF))</span><br><span class="line">of_pwmchip_add(chip);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;pwm_lock);<span class="comment">// 释放全局 pwm_lock 互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ret)<span class="comment">// 如果添加成功,则在 sysfs 中导出 PWM 控制器</span></span><br><span class="line">pwmchip_sysfs_export(chip);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pwmchip_add_with_polarity);</span><br></pre></td></tr></table></figure><p>这个函数的主要作用是初始化一个新的 PWM 控制器,并<strong>调用 <code>list_add</code> 函数将其添加到 PWM 子系统的管理中</strong>。</p><h2 id="PWM子系统API"><a href="#PWM子系统API" class="headerlink" title="PWM子系统API"></a>PWM子系统API</h2><h3 id="pwm-config"><a href="#pwm-config" class="headerlink" title="pwm_config()"></a>pwm_config()</h3><blockquote><p>PWM 参数配置核心函数</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns);</code></td></tr><tr><td>核心作用</td><td>配置 PWM 信号的<strong>占空比</strong>和<strong>周期</strong>，是调整 PWM 输出特性的核心函数</td></tr><tr><td>参数说明</td><td>1. <code>pwm</code>：指向目标 PWM 设备结构体的指针（需先通过 <code>devm_of_pwm_get</code> 获取）<br />2. <code>duty_ns</code>：占空比时长，单位<strong>纳秒 (ns)</strong>，表示 PWM 一个周期内高电平持续的时间<br />3. <code>period_ns</code>：PWM 信号总周期，单位<strong>纳秒 (ns)</strong>，表示高电平 + 低电平的总时长</td></tr><tr><td>返回值</td><td>成功：返回 0；失败：返回负数错误码（如 -EINVAL 表示参数无效）</td></tr><tr><td>使用说明</td><td>需在 PWM 使能（<code>pwm_enable</code>）前调用，确保输出的 PWM 信号参数已正确配置；通过调整 <code>duty_ns</code> 可改变输出平均电压（如控制 LED 亮度、电机转速），占空比计算公式：<code>占空比(%) = (duty_ns / period_ns) * 100%</code></td></tr></tbody></table><h3 id="pwm-set-polarity"><a href="#pwm-set-polarity" class="headerlink" title="pwm_set_polarity()"></a>pwm_set_polarity()</h3><blockquote><p>PWM 极性设置函数</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity);</code></td></tr><tr><td>核心作用</td><td>设置 PWM 信号的极性，定义高低电平的逻辑含义</td></tr><tr><td>参数说明</td><td>1. <code>pwm</code>：指向目标 PWM 设备结构体的指针<br />2. <code>polarity</code>：极性枚举值，仅支持两种：<br />- <code>PWM_POLARITY_NORMAL</code>：正极性（默认），高电平为 “有效 &#x2F; 开启” 状态，低电平为 “无效 &#x2F; 关闭” 状态<br />- <code>PWM_POLARITY_INVERSED</code>：负极性，低电平为 “有效 &#x2F; 开启” 状态，高电平为 “无效 &#x2F; 关闭” 状态</td></tr><tr><td>返回值</td><td>成功：返回 0；失败：返回负数错误码</td></tr><tr><td>使用说明</td><td>适用于需要反向逻辑控制的场景（如某些电机正反转控制、LED 反向驱动电路），建议在 <code>pwm_config</code> 之后、<code>pwm_enable</code> 之前调用</td></tr></tbody></table><h3 id="pwm-enable"><a href="#pwm-enable" class="headerlink" title="pwm_enable()"></a>pwm_enable()</h3><blockquote><p>PWM 使能函数</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>int pwm_enable(struct pwm_device *pwm);</code></td></tr><tr><td>核心作用</td><td>使能 PWM 控制器，开始输出已配置好参数（占空比、周期、极性）的 PWM 信号</td></tr><tr><td>参数说明</td><td><code>pwm</code>：指向目标 PWM 设备结构体的指针</td></tr><tr><td>返回值</td><td>成功：返回 0；失败：返回负数错误码</td></tr><tr><td>使用说明</td><td>必须在 <code>pwm_config</code>（及 <code>pwm_set_polarity</code>，若需配置极性）之后调用，确保输出信号参数有效；调用后 PWM 持续输出，直至调用 <code>pwm_disable</code> 停止</td></tr></tbody></table><h3 id="pwm-disable"><a href="#pwm-disable" class="headerlink" title="pwm_disable()"></a>pwm_disable()</h3><blockquote><p>PWM 关闭函数</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>void pwm_disable(struct pwm_device *pwm);</code></td></tr><tr><td>核心作用</td><td>关闭 PWM 控制器，停止输出 PWM 信号</td></tr><tr><td>参数说明</td><td><code>pwm</code>：指向目标 PWM 设备结构体的指针</td></tr><tr><td>返回值</td><td>无返回值</td></tr><tr><td>使用说明</td><td>当不需要 PWM 输出时调用（如设备休眠、功能关闭），可节省系统功耗；调用后 PWM 不再输出信号，再次启用需重新调用 <code>pwm_enable</code>（无需重新配置参数，参数会保留）</td></tr></tbody></table><h3 id="devm-of-pwm-get"><a href="#devm-of-pwm-get" class="headerlink" title="devm_of_pwm_get()"></a>devm_of_pwm_get()</h3><blockquote><p>PWM 设备获取函数</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>struct pwm_device *devm_of_pwm_get(struct device *dev, struct device_node *np, const char *con_id);</code></td></tr><tr><td>核心作用</td><td>从 Linux 设备树（Device Tree）中获取 PWM 设备句柄，自动管理设备资源（无需手动释放）</td></tr><tr><td>参数说明</td><td>1. <code>dev</code>：指向当前驱动对应的设备结构体指针（如平台驱动中的 <code>struct device</code> 实例）<br />2. <code>np</code>：指向 PWM 设备对应的设备树节点指针<br />3. <code>con_id</code>：连接 ID（字符串类型），用于区分同一设备的多个 PWM 通道（若只有一个 PWM 通道，可传 <code>NULL</code>）</td></tr><tr><td>返回值</td><td>成功：返回指向 <code>struct pwm_device</code> 的有效指针；失败：返回 ERR_PTR 类型的错误指针（可通过 <code>IS_ERR()</code> 宏判断）</td></tr><tr><td>使用说明</td><td>是设备驱动中获取 PWM 设备的首选方法，基于 <code>devm</code> 系列接口的特性，当设备卸载时，内核会自动释放该 PWM 设备资源，避免内存泄漏；必须在使用其他 PWM 函数（<code>pwm_config</code> 等）之前调用，先获取设备句柄才能进行后续操作</td></tr></tbody></table><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>首先修改设备树，同样先设置pwm12复用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;pwm12 &#123;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pwm12m1_pins&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后新增sg90节点</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">sg90</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;sg90&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pwms</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;pwm12</span> <span class="number">0</span> <span class="number">20000000</span> <span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>compatible</code> 用于指定设备的兼容性字符串，内核会根据这个字符串来匹配合适的驱动程序。</li><li><code>pwms</code> 用来配置 PWM 控制器的信息。<ul><li><code>&amp;pwm12</code> 表示 PWM 控制器的引用</li><li><code>0</code> 表示 PWM通道号</li><li><code>20000000</code>: 表示 PWM 周期，单位为纳秒，即设置周期为 20ms</li><li><code>1</code> 为极性，表示正极性（active high），即 PWM 信号的高电平表示“开”状态</li></ul></li></ul><p><strong>驱动程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pwm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_t</span> dev_num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_device</span> *<span class="title">sg90_pwm_device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开设备时的回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev test open\n&quot;</span>);</span><br><span class="line">    pwm_config(sg90_pwm_device, <span class="number">500000</span>, <span class="number">20000000</span>);    <span class="comment">// 配置 PWM 参数:脉冲宽度为 50000000 纳秒, 周期为 20,000,000 纳秒</span></span><br><span class="line">    pwm_set_polarity(sg90_pwm_device, PWM_POLARITY_NORMAL);    <span class="comment">// 设置 PWM 极性为正常极性</span></span><br><span class="line">    pwm_enable(sg90_pwm_device);    <span class="comment">// 启动 PWM</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入设备时的回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">1</span>];</span><br><span class="line">    printk(<span class="string">&quot;This is cdev test write\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 从用户空间拷贝数据到内核空间</span></span><br><span class="line">    ret = copy_from_user(data, buf, size);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 PWM 参数:脉冲宽度根据用户输入的数据调整</span></span><br><span class="line">    pwm_config(sg90_pwm_device, <span class="number">500000</span> + data[<span class="number">0</span>] * <span class="number">100000</span> / <span class="number">9</span>, <span class="number">20000000</span>);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放设备时的回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev test release\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pwm_config(sg90_pwm_device, <span class="number">500000</span>, <span class="number">20000000</span>);    <span class="comment">// 回到初始的 PWM 参数配置</span></span><br><span class="line">    pwm_disable(sg90_pwm_device);    <span class="comment">// 停止 PWM</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义字符设备操作函数集合</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_ops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = cdev_test_open,</span><br><span class="line">    .write = cdev_test_write,</span><br><span class="line">    .release = cdev_test_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备探测函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sg90_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 PWM 设备</span></span><br><span class="line">    sg90_pwm_device = devm_pwm_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(sg90_pwm_device)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;Failed to get PWM device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(sg90_pwm_device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化字符设备</span></span><br><span class="line">    cdev_init(&amp;cdev_test, &amp;cdev_test_ops);</span><br><span class="line">    cdev_test.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    ret = cdev_add(&amp;cdev_test, dev_num, <span class="number">1</span>);<span class="comment">// 添加字符设备</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);    <span class="comment">// 创建设备类</span></span><br><span class="line">    device = device_create(class, <span class="literal">NULL</span>, dev_num, <span class="literal">NULL</span>, <span class="string">&quot;sg90&quot;</span>);    <span class="comment">// 创建设备</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;sg90_probe successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sg90_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line"></span><br><span class="line">    device_destroy(class, dev_num);    <span class="comment">// 删除设备</span></span><br><span class="line">    class_destroy(class);    <span class="comment">// 删除设备类</span></span><br><span class="line">    cdev_del(&amp;cdev_test);    <span class="comment">// 删除字符设备</span></span><br><span class="line">    unregister_chrdev_region(dev_num, <span class="number">1</span>);    <span class="comment">// 释放设备号</span></span><br><span class="line">    printk(<span class="string">&quot;sg90_remove successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备树匹配表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">sg90_of_device_id</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;sg90&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, sg90_of_device_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义平台驱动</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">sg90_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;sg90&quot;</span>,</span><br><span class="line">        .of_match_table = sg90_of_device_id,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = sg90_probe,</span><br><span class="line">    .remove = sg90_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">modulecdev_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;sg90_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;platform_driver_register is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;platform_driver_register is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">modulecdev_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注销平台驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;sg90_platform_driver);</span><br><span class="line">    printk(<span class="string">&quot;bye bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明模块许可证和作者</span></span><br><span class="line">module_init(modulecdev_init);</span><br><span class="line">module_exit(modulecdev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>app</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// argc 表示命令行参数的数量,包括程序名本身</span></span><br><span class="line">    <span class="comment">// argv 是一个字符串数组,存储了各个命令行参数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">// 文件描述符,用于标识打开的设备文件</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">1</span>];  <span class="comment">// 存储要写入设备的单个字节数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果命令行参数个数小于2,说明缺少要写入的值,打印用法并返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;value&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只写方式打开设备文件&quot;/dev/sg90&quot;</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/sg90&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;  <span class="comment">// 打开设备文件失败,输出错误信息并返回错误</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令行参数转换为整数,存储在buf[0]中</span></span><br><span class="line">    buf[<span class="number">0</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 将buf中的1个字节数据写入打开的设备文件</span></span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;  <span class="comment">// 写入失败,输出错误信息,关闭文件并返回错误</span></span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟3秒,模拟设备操作</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 关闭设备文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 程序执行成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><p>使用<code>./app 90</code>运行编译的可执行程序，这里的 90 代表舵机转动的角度</p><h1 id="模拟PWM"><a href="#模拟PWM" class="headerlink" title="模拟PWM"></a>模拟PWM</h1><p>当硬件 PWM 不够用的时候，可以使用 GPIO 来模拟实现 PWM，也可以称之为软件 PWM，软件 PWM 是通过软件编程实现 PWM 输出的方式，利用定时器中断或者循环计数的方式, 在软件中控制输出引脚的高低电平切换时间, 从而生成 PWM 波形。</p><h2 id="高精度定时器"><a href="#高精度定时器" class="headerlink" title="高精度定时器"></a>高精度定时器</h2><p>软件 PWM 的实现需要依靠定时器中断来实现，而<strong>传统的周期性定时器通常在 100Hz 到 1000Hz 之间, 只能提供毫秒级别的精度</strong>, 这对于一些时间精度要求较高的应用场景来说（例如模拟 PWM）,精度还不够。</p><p>为了解决这一问题,Linux 内核引入了**高精度定时器(<code>hrtimers</code>)**机制。</p><p><strong><code>hrtimers</code> 使用动态时钟(<code>CLOCK_MONOTONIC</code>)和动态时间戳(<code>ktime_t</code>)作为基准时间。通过利用底层硬件定时器(如 <code>HPET、LAPIC</code> 定时器等)提供纳秒级别的时间精度。</strong></p><p>高精度定时器结构体 <code>struct hrtimer</code> 内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> <span class="comment">// 定时器在时钟基准列表中的节点</span></span><br><span class="line"><span class="type">ktime_t</span> _softexpires;<span class="comment">// 软到期时间,实际到期时间可能稍晚</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title function_">hrtimer_restart</span> <span class="params">(*function)</span><span class="params">(<span class="keyword">struct</span> hrtimer *)</span>; <span class="comment">// 定时器到期时的回调函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>state; <span class="comment">// 定时器的状态标志</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hrtimer_clock_base</span> *<span class="title">base</span>;</span> <span class="comment">// 定时器所属的时钟基准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度定时器工作流程"><a href="#高精度定时器工作流程" class="headerlink" title="高精度定时器工作流程"></a>高精度定时器工作流程</h3><ol><li><p>初始化定时器</p><p>使用 <code>hrtimer_init()</code> 函数初始化一个 <code>struct hrtimer</code> 对象, 指定使用的时钟源和工作模式。在初始化过程中,会为定时器分配一个所属的时钟基准(<code>hrtimer_clock_base</code>)。每个 CPU 都有自己的时钟基准管理器。</p></li><li><p>设置定时器<br>使用 <code>hrtimer_start()</code>或者 <code>hrtimer_set()</code> 函数设置定时器的到期时间。可以指定绝对时间或相对时间。定时器到期时间会被转换为对应时钟基准的软到期时间(<code>_softexpires</code>)。将定时器插入到时钟基准的定时器链表中,按照到期时间排序。</p></li><li><p>定时器到期处理<br>当系统时钟发生中断时,会调用 <code>hrtimer_interrupt()</code> 函数。<code>hrtimer_interrupt()</code>会遍历时钟基准的定时器链表,检查是否有到期的定时器。对于已到期的定时器,调用其回调函数(<code>function</code>)处理到期事件。如果定时器尚未到期,则更新下一个到期定时器的唤醒时间。</p></li><li><p>定时器管理</p><ul><li><code>hrtimer_cancel()</code> 函数用于取消一个正在运行的定时器。</li><li><code>hrtimer_forward()</code> 函数用于前滚定时器,即根据当前时间重新计算定时器的到期时间。</li><li><code>hrtimer_start_range_ns()</code> 函数用于设置定时器的到期时间范围,以提高定时器的精度。</li></ul></li></ol><h3 id="高精度定时器API"><a href="#高精度定时器API" class="headerlink" title="高精度定时器API"></a>高精度定时器API</h3><h4 id="hrtimer-init"><a href="#hrtimer-init" class="headerlink" title="hrtimer_init"></a>hrtimer_init</h4><blockquote><p>定时器初始化</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>void hrtimer_init(struct hrtimer *timer, clockid_t clockid, enum hrtimer_mode mode);</code></td></tr><tr><td>核心作用</td><td>初始化<code>struct hrtimer</code>结构体，指定定时器的时钟源和工作模式</td></tr><tr><td>参数说明</td><td>- <code>timer</code>：指向待初始化的<code>hrtimer</code>结构体指针<br />- <code>clockid</code>：时钟源，常用值：<br />   - <code>CLOCK_MONOTONIC</code>：单调时钟（系统启动后不回退，推荐用于定时器）<br />   - <code>CLOCK_REALTIME</code>：实时时钟（可被修改，不推荐用于高精度定时）<br />   - <code>CLOCK_BOOTTIME</code>：包含系统挂起时间的单调时钟<br />- <code>mode</code>：工作模式，常用值：<br />   - <code>HRTIMER_MODE_ABS</code>：绝对时间模式（定时器在指定绝对时间触发）<br />   - <code>HRTIMER_MODE_REL</code>：相对时间模式（定时器在当前时间延后指定时长触发）</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>使用说明</td><td>必须在使用其他 hrtimer API 前调用，是定时器操作的前置步骤</td></tr></tbody></table><h4 id="hrtimer-set"><a href="#hrtimer-set" class="headerlink" title="hrtimer_set"></a>hrtimer_set</h4><blockquote><p>设置定时器到期时间</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>void hrtimer_set(struct hrtimer *timer, ktime_t time, const enum hrtimer_mode mode);</code></td></tr><tr><td>核心作用</td><td>为已初始化的定时器设置到期时间（通常配合<code>hrtimer_start</code>使用）</td></tr><tr><td>参数说明</td><td>- <code>timer</code>：指向<code>hrtimer</code>结构体的指针<br />- <code>time</code>：到期时间（<code>ktime_t</code>类型，需用<code>ktime_set(秒, 纳秒)</code>构造）<br />- <code>mode</code>：时间模式（<code>HRTIMER_MODE_ABS</code>&#x2F;<code>HRTIMER_MODE_REL</code>，需与<code>hrtimer_init</code>的模式一致）</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>使用说明</td><td>可单独设置时间后再调用<code>hrtimer_start</code>，也可直接通过<code>hrtimer_start</code>的参数设置时间（更常用）</td></tr></tbody></table><h4 id="hrtimer-start"><a href="#hrtimer-start" class="headerlink" title="hrtimer_start"></a>hrtimer_start</h4><blockquote><p>启动定时器</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>int hrtimer_start(struct hrtimer *timer, ktime_t time, const enum hrtimer_mode mode);</code></td></tr><tr><td>核心作用</td><td>将定时器加入内核定时器队列，启动定时（可直接设置到期时间）</td></tr><tr><td>参数说明</td><td>- <code>timer</code>：指向<code>hrtimer</code>结构体的指针- <code>time</code>：到期时间（<code>ktime_t</code>类型）- <code>mode</code>：时间模式（同<code>hrtimer_init</code>）</td></tr><tr><td>返回值</td><td>成功返回 0；失败返回负数错误码</td></tr><tr><td>使用说明</td><td>是启动定时器的核心函数，支持 “设置时间 + 启动” 一步完成（替代<code>hrtimer_set</code>+<code>hrtimer_start</code>）</td></tr></tbody></table><h4 id="hrtimer-forward"><a href="#hrtimer-forward" class="headerlink" title="hrtimer_forward"></a>hrtimer_forward</h4><blockquote><p>推进定时器到期时间</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>ktime_t hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval);</code></td></tr><tr><td>核心作用</td><td>在定时器回调函数中推进到期时间，实现<strong>周期性定时器</strong></td></tr><tr><td>参数说明</td><td>- <code>timer</code>：指向<code>hrtimer</code>结构体的指针<br />- <code>now</code>：当前时间（通常用<code>hrtimer_cb_get_time(timer)</code>获取）<br />- <code>interval</code>：周期时间间隔（<code>ktime_t</code>类型）</td></tr><tr><td>返回值</td><td>返回新的到期时间（<code>ktime_t</code>类型）</td></tr><tr><td>使用说明</td><td>必须在定时器回调函数中调用，配合<code>return HRTIMER_RESTART</code>实现周期性触发</td></tr></tbody></table><h4 id="hrtimer-cancel"><a href="#hrtimer-cancel" class="headerlink" title="hrtimer_cancel"></a>hrtimer_cancel</h4><blockquote><p>取消定时器</p></blockquote><table><thead><tr><th>项目</th><th>详情</th></tr></thead><tbody><tr><td>函数原型</td><td><code>int hrtimer_cancel(struct hrtimer *timer);</code></td></tr><tr><td>核心作用</td><td>取消已启动的定时器，将其从内核队列中移除</td></tr><tr><td>参数说明</td><td>- <code>timer</code>：指向<code>hrtimer</code>结构体的指针</td></tr><tr><td>返回值</td><td>定时器处于活动状态时返回 1；已停止时返回 0</td></tr><tr><td>使用说明</td><td>用于提前终止定时器（如模块卸载、功能关闭时）</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们用模拟PWM实现LED呼吸灯效果：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260104190128209.png" alt="LED原理图" loading="lazy"></p><p>LED 使用的引脚为 <code>GPIO0_B7</code>,在设备树中使用 LED 子系统进行注册，而在本章节中由于要用模拟 PWM 对该引脚进行控制，所以需要对设备树进行修改:</p><p>原来是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> LED_PWM</span></span><br><span class="line">        <span class="title class_">leds</span> <span class="punctuation">&#123;</span>                                                                                            <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;pwm-leds&quot;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="title class_">work</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">pwms</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;pwm0</span> <span class="number">0</span> <span class="number">500000</span> <span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">linux,default-trigger</span> <span class="operator">=</span> <span class="string">&quot;heartbeat&quot;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">default-state</span> <span class="operator">=</span> <span class="string">&quot;on&quot;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="punctuation">&#125;;</span></span><br><span class="line">        <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="title class_">leds</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;gpio-leds&quot;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="title class_">work</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> RK_PB7 GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">linux,default-trigger</span> <span class="operator">=</span> <span class="string">&quot;heartbeat&quot;</span><span class="punctuation">;</span></span><br><span class="line">                        <span class="attr">default-state</span> <span class="operator">=</span> <span class="string">&quot;on&quot;</span><span class="punctuation">;</span></span><br><span class="line">                <span class="punctuation">&#125;;</span></span><br><span class="line">        <span class="punctuation">&#125;;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">leds</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;pwm-leds&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">led-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> RK_PB7 GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p><strong>驱动程序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pwm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/hrtimer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_t</span> dev_num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 PWM LED 数据结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_led_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> sum_count;  <span class="comment">// PWM 周期总脉冲数</span></span><br><span class="line">    <span class="type">int</span> high_count;  <span class="comment">// PWM 高电平持续脉冲数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span>  <span class="comment">// GPIO 描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">pwm_timer</span>;</span>  <span class="comment">// 高分辨率定时器</span></span><br><span class="line">    <span class="type">ktime_t</span> time;  <span class="comment">// 定时器时间间隔</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 PWM LED 数据结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_led_data</span> *<span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PWM 定时器回调函数</span></span><br><span class="line"><span class="keyword">enum</span> hrtimer_restart <span class="title function_">pwm_timer_func</span><span class="params">(<span class="keyword">struct</span> hrtimer *timer)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> timer_count = <span class="number">0</span>;  <span class="comment">// 定时器计数器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_led_data</span> *<span class="title">mydata</span> =</span> container_of(timer, <span class="keyword">struct</span> pwm_led_data, pwm_timer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果计数器达到总脉冲数, 将 GPIO 设为高电平</span></span><br><span class="line">    <span class="keyword">if</span> (timer_count == mydata-&gt;sum_count) &#123;</span><br><span class="line">        gpiod_set_value(mydata-&gt;gpiod, <span class="number">1</span>);</span><br><span class="line">        timer_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果计数器达到高电平持续脉冲数, 将 GPIO 设为低电平</span></span><br><span class="line">    <span class="keyword">if</span> (timer_count == mydata-&gt;high_count) &#123;</span><br><span class="line">        gpiod_set_value(mydata-&gt;gpiod, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    timer_count++;</span><br><span class="line">    <span class="comment">// 如果高电平持续脉冲数为 0, 则计数器重置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (mydata-&gt;high_count == <span class="number">0</span>) &#123;</span><br><span class="line">        timer_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将定时器向前移动 time 时间间隔, 并重新启动</span></span><br><span class="line">    hrtimer_forward(timer, hrtimer_cb_get_time(timer), mydata-&gt;time);</span><br><span class="line">    <span class="keyword">return</span> HRTIMER_RESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符设备打开回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev test open\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符设备写入回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> kbuf[<span class="number">2</span>];</span><br><span class="line">    printk(<span class="string">&quot;This is cdev test write\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 从用户空间拷贝数据到内核空间</span></span><br><span class="line">    ret = copy_from_user(kbuf, buf, size);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;copy_from_user failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 PWM LED 数据结构体</span></span><br><span class="line">    data-&gt;sum_count = kbuf[<span class="number">0</span>];</span><br><span class="line">    data-&gt;high_count = kbuf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符设备释放回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev test release\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符设备操作函数集</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_ops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = cdev_test_open,</span><br><span class="line">    .write = cdev_test_write,</span><br><span class="line">    .release = cdev_test_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备探测回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 PWM LED 数据结构体内存</span></span><br><span class="line">    data = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pwm_led_data), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        printk(<span class="string">&quot;kmalloc failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 PWM LED 数据结构体</span></span><br><span class="line">    data-&gt;sum_count = <span class="number">20</span>;</span><br><span class="line">    data-&gt;high_count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region is error\n&quot;</span>);</span><br><span class="line">        kfree(data);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化字符设备</span></span><br><span class="line">    cdev_init(&amp;cdev_test, &amp;cdev_test_ops);</span><br><span class="line">    cdev_test.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    ret = cdev_add(&amp;cdev_test, dev_num, <span class="number">1</span>);    <span class="comment">// 向内核注册字符设备</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;cdev_add is error\n&quot;</span>);</span><br><span class="line">        unregister_chrdev_region(dev_num, <span class="number">1</span>);</span><br><span class="line">        kfree(data);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);    <span class="comment">// 创建设备类</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(class)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;class_create is error\n&quot;</span>);</span><br><span class="line">        cdev_del(&amp;cdev_test);</span><br><span class="line">        unregister_chrdev_region(dev_num, <span class="number">1</span>);</span><br><span class="line">        kfree(data);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    device = device_create(class, <span class="literal">NULL</span>, dev_num, <span class="literal">NULL</span>, <span class="string">&quot;pwm-gpio&quot;</span>);    <span class="comment">// 创建设备节点</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(device)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;device_create is error\n&quot;</span>);</span><br><span class="line">        class_destroy(class);</span><br><span class="line">        cdev_del(&amp;cdev_test);</span><br><span class="line">        unregister_chrdev_region(dev_num, <span class="number">1</span>);</span><br><span class="line">        kfree(data);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data-&gt;gpiod = gpiod_get(&amp;pdev-&gt;dev, <span class="string">&quot;led&quot;</span>, GPIOD_OUT_HIGH);    <span class="comment">// 获取 GPIO 描述符</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(data-&gt;gpiod)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpiod_get is error\n&quot;</span>);</span><br><span class="line">        device_destroy(class, dev_num);</span><br><span class="line">        class_destroy(class);</span><br><span class="line">        cdev_del(&amp;cdev_test);</span><br><span class="line">        unregister_chrdev_region(dev_num, <span class="number">1</span>);</span><br><span class="line">        kfree(data);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(data-&gt;gpiod);</span><br><span class="line">    &#125;</span><br><span class="line">    gpiod_set_value(data-&gt;gpiod, <span class="number">1</span>);    <span class="comment">// 将 GPIO 设为高电平</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化高分辨率定时器</span></span><br><span class="line">    data-&gt;time = ktime_set(<span class="number">0</span>, <span class="number">1000000</span>);  <span class="comment">// 1 ms</span></span><br><span class="line">    hrtimer_init(&amp;data-&gt;pwm_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">    data-&gt;pwm_timer.function = pwm_timer_func;</span><br><span class="line">    hrtimer_start(&amp;data-&gt;pwm_timer, data-&gt;time, HRTIMER_MODE_REL);    <span class="comment">// 启动高分辨率定时器</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;led_probe successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备移除回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    hrtimer_cancel(&amp;data-&gt;pwm_timer);    <span class="comment">// 停止高分辨率定时器</span></span><br><span class="line">    gpiod_put(data-&gt;gpiod);    <span class="comment">// 释放 GPIO 描述符</span></span><br><span class="line">    device_destroy(class, dev_num);    <span class="comment">// 删除设备节点</span></span><br><span class="line">    class_destroy(class);    <span class="comment">// 删除设备类</span></span><br><span class="line">    cdev_del(&amp;cdev_test);    <span class="comment">// 从内核注销字符设备</span></span><br><span class="line">    unregister_chrdev_region(dev_num, <span class="number">1</span>);    <span class="comment">// 释放设备号</span></span><br><span class="line">    kfree(data);    <span class="comment">// 释放 PWM LED 数据结构体内存</span></span><br><span class="line">    printk(<span class="string">&quot;led_remove successful\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备树匹配表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">led_of_device_id</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;pwm-leds&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, led_of_device_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台设备驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">led_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;pwm-leds&quot;</span>,</span><br><span class="line">        .of_match_table = led_of_device_id,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = led_probe,</span><br><span class="line">    .remove = led_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">modulecdev_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册平台设备驱动</span></span><br><span class="line">    ret = platform_driver_register(&amp;led_platform_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(<span class="string">&quot;platform_driver_register is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;platform_driver_register is ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">modulecdev_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注销平台设备驱动</span></span><br><span class="line">    platform_driver_unregister(&amp;led_platform_driver);</span><br><span class="line">    printk(<span class="string">&quot;bye bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化和退出函数注册</span></span><br><span class="line">module_init(modulecdev_init);</span><br><span class="line">module_exit(modulecdev_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块许可证、作者和描述信息</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">int</span> buf[<span class="number">2</span>]; <span class="comment">// 缓冲区,存放两个整数值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数个数是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;sum_count&gt; &lt;high_count&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 PWM GPIO 设备文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/pwm-gpio&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令行参数转换为整数,存入缓冲区</span></span><br><span class="line">    buf[<span class="number">0</span>] = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    buf[<span class="number">1</span>] = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将缓冲区的数据写入 PWM GPIO 设备</span></span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf, <span class="keyword">sizeof</span>(buf)) != <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭设备文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>呼吸灯</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> buf[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;duty_cycle&gt; &lt;period&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 /dev/pwm-gpio 设备</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/pwm-gpio&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error opening /dev/pwm-gpio\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 PWM 参数</span></span><br><span class="line">    buf[<span class="number">0</span>] = atoi(argv[<span class="number">1</span>]);  <span class="comment">// 占空比</span></span><br><span class="line">    buf[<span class="number">1</span>] = atoi(argv[<span class="number">2</span>]);  <span class="comment">// 周期</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 递增占空比</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= buf[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            buf[<span class="number">1</span>] = i;</span><br><span class="line">            write(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            usleep(<span class="number">30000</span>);  <span class="comment">// 延迟 30 毫秒</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递减占空比</span></span><br><span class="line">        <span class="keyword">for</span> (i = buf[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            buf[<span class="number">1</span>] = i;</span><br><span class="line">            write(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            usleep(<span class="number">30000</span>);  <span class="comment">// 延迟 30 毫秒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭设备</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PWM-输入捕获驱动"><a href="#PWM-输入捕获驱动" class="headerlink" title="PWM 输入捕获驱动"></a>PWM 输入捕获驱动</h1><p>瑞芯微只实现了状态获取和申请两个函数，并没有实现输入捕获相关的函数，而输入捕获也是 PWM 的常用功能之一，要想在RK3568 上实现 PWM 的输入捕获，就需要我们自己来实现 PWM 输入捕获的驱动了。</p><h2 id="设备树修改"><a href="#设备树修改" class="headerlink" title="设备树修改"></a>设备树修改</h2><p>RK3568 PWM 硬件介绍中提到只有 PWM3、PWM7、PWM11 和 PWM15这 4 路 PWM 通道可以进行输入捕获，我们将使用 PWM3 进行输入捕获演示，默认情况下PWM3 作为了红外接收的功能，具体硬件原理图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260105154609585.png" alt="IR Receiver" loading="lazy"></p><p>修改设备树，注释掉pwm3的节点，然后添加：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;pwm3</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;pwm-capture&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pwm-channel</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h2><p><code>rockchip_pwm_capture.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __RKXX_PWM_REMOTECTL_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RKXX_PWM_REMOTECTL_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pwm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最大按键数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM_KEYS                60</span></span><br><span class="line"><span class="comment">/* 最大PWM捕获数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PWR_KEY_CAPURURE_MAX    10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PWM寄存器定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_CNTR                0x00  <span class="comment">/* 计数器寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_HPR                 0x04  <span class="comment">/* 周期寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_LPR                 0x08  <span class="comment">/* 占空比寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_CTRL                0x0c  <span class="comment">/* 控制寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM3_REG_INTSTS             0x10  <span class="comment">/* PWM3中断状态寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM2_REG_INTSTS             0x20  <span class="comment">/* PWM2中断状态寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM1_REG_INTSTS             0x30  <span class="comment">/* PWM1中断状态寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM0_REG_INTSTS             0x40  <span class="comment">/* PWM0中断状态寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM3_REG_INT_EN             0x14  <span class="comment">/* PWM3中断使能寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM2_REG_INT_EN             0x24  <span class="comment">/* PWM2中断使能寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM1_REG_INT_EN             0x34  <span class="comment">/* PWM1中断使能寄存器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM0_REG_INT_EN             0x44  <span class="comment">/* PWM0中断使能寄存器 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 控制寄存器位定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_ENABLE                  (1 &lt;&lt; 0) <span class="comment">/* PWM使能 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_DISABLE                 (0 &lt;&lt; 0) <span class="comment">/* PWM禁用 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作模式 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_MODE_ONESHOT            (0x00 &lt;&lt; 1) <span class="comment">/* 单次模式 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_MODE_CONTINUMOUS        (0x01 &lt;&lt; 1) <span class="comment">/* 连续模式 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_MODE_CAPTURE            (0x02 &lt;&lt; 1) <span class="comment">/* 捕获模式 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 占空比输出极性 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_DUTY_POSTIVE            (0x01 &lt;&lt; 3) <span class="comment">/* 正极性 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_DUTY_NEGATIVE           (0x00 &lt;&lt; 3) <span class="comment">/* 负极性 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 非活动状态输出极性 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_INACTIVE_POSTIVE        (0x01 &lt;&lt; 4) <span class="comment">/* 正极性 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_INACTIVE_NEGATIVE       (0x00 &lt;&lt; 4) <span class="comment">/* 负极性 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时钟源选择 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CLK_SCALE               (1 &lt;&lt; 9) <span class="comment">/* 时钟分频 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CLK_NON_SCALE           (0 &lt;&lt; 9) <span class="comment">/* 无时钟分频 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH0_INT                 (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH1_INT                 (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH2_INT                 (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH3_INT                 (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PWR_KEY_INT             (1 &lt;&lt; 7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH0_POL                 (1 &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH1_POL                 (1 &lt;&lt; 9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH2_POL                 (1 &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH3_POL                 (1 &lt;&lt; 11)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH0_INT_ENABLE          (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH0_INT_DISABLE         (0 &lt;&lt; 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH1_INT_ENABLE          (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH1_INT_DISABLE         (0 &lt;&lt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH2_INT_ENABLE          (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH2_INT_DISABLE         (0 &lt;&lt; 2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH3_INT_ENABLE          (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH3_INT_DISABLE         (0 &lt;&lt; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_INT_ENABLE              1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_INT_DISABLE             0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 预分频因子 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWMCR_MIN_PRESCALE          0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWMCR_MAX_PRESCALE          0x07</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWMDCR_MIN_DUTY             0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWMDCR_MAX_DUTY             0xFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWMPCR_MIN_PERIOD           0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWMPCR_MAX_PERIOD           0xFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pwm_div</span> &#123;</span></span><br><span class="line">    PWM_DIV1    = (<span class="number">0x0</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    PWM_DIV2    = (<span class="number">0x1</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    PWM_DIV4    = (<span class="number">0x2</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    PWM_DIV8    = (<span class="number">0x3</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    PWM_DIV16   = (<span class="number">0x4</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    PWM_DIV32   = (<span class="number">0x5</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    PWM_DIV64   = (<span class="number">0x6</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">    PWM_DIV128  = (<span class="number">0x7</span> &lt;&lt; <span class="number">12</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NEC 协议 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_PRE_MIN         4000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_PRE_MAX         5000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_PRE_MIN_LOW     8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_PRE_MAX_LOW     10000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_BIT0_MIN        390</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_BIT0_MAX        730</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_BIT1_MIN        1300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_BIT1_MAX        2000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_BIT_MIN_LOW     390</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_BIT_MAX_LOW     730</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_RPT_MIN         2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_RPT_MAX         2500</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_SEQ1_MIN        95000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_SEQ1_MAX        98000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_SEQ2_MIN        30000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_TIME_SEQ2_MAX        55000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_INTSTS(n)           ((3 - (n)) * 0x10 + 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_INT_EN(n)           ((3 - (n)) * 0x10 + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RK_PWM_VERSION_ID(n)        ((3 - (n)) * 0x10 + 0x2c)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_PWRMATCH_CTRL(n)    ((3 - (n)) * 0x10 + 0x50)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_PWRMATCH_LPRE(n)    ((3 - (n)) * 0x10 + 0x54)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_PWRMATCH_HPRE(n)    ((3 - (n)) * 0x10 + 0x58)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_PWRMATCH_LD(n)      ((3 - (n)) * 0x10 + 0x5C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_PWRMATCH_HD_ZERO(n) ((3 - (n)) * 0x10 + 0x60)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_REG_PWRMATCH_HD_ONE(n)  ((3 - (n)) * 0x10 + 0x64)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PWRMATCH_VALUE(n)       ((3 - (n)) * 0x10 + 0x68)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PWRCAPTURE_VALUE(n)     ((3 - (n)) * 0x10 + 0x9c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH_INT(n)               BIT(n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH_POL(n)               BIT(n + 8)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_CH_INT_ENABLE(n)        BIT(n)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_PWR_INT_ENABLE          BIT(7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CH3_PWRKEY_ENABLE           BIT(3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PWM 数据结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> period_ns; <span class="comment">/* 周期（纳秒） */</span></span><br><span class="line">    <span class="type">int</span> duty_ns;   <span class="comment">/* 占空比（纳秒） */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PWM 状态枚举 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">RMC_STATE</span> &#123;</span></span><br><span class="line">    RMC_IDLE,   <span class="comment">/* 空闲状态 */</span></span><br><span class="line">    RMC_IDLE1,  <span class="comment">/* 空闲状态1 */</span></span><br><span class="line">    RMC_IDLE2,  <span class="comment">/* 空闲状态2 */</span></span><br><span class="line">    RMC_GETDATA,<span class="comment">/* 获取数据状态 */</span></span><br><span class="line">    RMC_DONE,   <span class="comment">/* 完成状态 */</span></span><br><span class="line">&#125; eRMC_STATE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PWM 捕获平台数据结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RKxx_remotectl_platform_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> nbuttons; <span class="comment">/* 按钮数 */</span></span><br><span class="line">    <span class="type">int</span> rep;      <span class="comment">/* 重复 */</span></span><br><span class="line">    <span class="type">int</span> timer;    <span class="comment">/* 计时器 */</span></span><br><span class="line">    <span class="type">int</span> wakeup;   <span class="comment">/* 唤醒 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PWM 捕获字符设备数据结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_capture_cdev</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span> dev_num;            <span class="comment">/* 设备号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev_test</span>;</span>    <span class="comment">/* 字符设备结构体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>      <span class="comment">/* 设备类 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>    <span class="comment">/* 设备结构体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rkxx_capture_drvdata</span> *<span class="title">ddata</span>;</span> <span class="comment">/* 驱动数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PWM 捕获驱动数据结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rkxx_capture_drvdata</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> __iomem *base;       <span class="comment">/* 基地址 */</span></span><br><span class="line">    <span class="type">int</span> irq;                  <span class="comment">/* 中断号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>        <span class="comment">/* 设备结构体 */</span></span><br><span class="line">    <span class="type">int</span> pwm_freq_nstime;      <span class="comment">/* PWM 频率（纳秒） */</span></span><br><span class="line">    <span class="type">int</span> pwm_channel;          <span class="comment">/* PWM 通道 */</span></span><br><span class="line">    <span class="type">int</span> hpr;                  <span class="comment">/* 高电平周期 */</span></span><br><span class="line">    <span class="type">int</span> lpr;                  <span class="comment">/* 低电平周期 */</span></span><br><span class="line">    eRMC_STATE state;         <span class="comment">/* PWM 状态 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span>          <span class="comment">/* 时钟 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">p_clk</span>;</span>        <span class="comment">/* 父时钟 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_capture_cdev</span> <span class="title">pwm_cdev</span>;</span> <span class="comment">/* PWM 捕获字符设备 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_data</span> <span class="title">data</span>;</span>             <span class="comment">/* PWM 数据结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PWM 中断控制 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rk_pwm_int_ctrl</span><span class="params">(<span class="type">void</span> __iomem *pwm_base, uint pwm_id, <span class="type">int</span> ctrl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pwm_id &gt; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* 如果 PWM ID 超过 3，直接返回 */</span></span><br><span class="line">    </span><br><span class="line">    val = readl_relaxed(pwm_base + PWM_REG_INT_EN(pwm_id)); <span class="comment">/* 读取当前中断使能状态 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ctrl) &#123;</span><br><span class="line">        val |= PWM_CH_INT_ENABLE(pwm_id); <span class="comment">/* 设置中断使能 */</span></span><br><span class="line">        writel_relaxed(val, pwm_base + PWM_REG_INT_EN(pwm_id)); <span class="comment">/* 写入中断使能寄存器 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val &amp;= ~PWM_CH_INT_ENABLE(pwm_id); <span class="comment">/* 清除中断使能 */</span></span><br><span class="line">        writel_relaxed(val, pwm_base + PWM_REG_INT_EN(pwm_id)); <span class="comment">/* 写入中断使能寄存器 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 PWM 捕获 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rk_pwm_capture_init</span><span class="params">(<span class="type">void</span> __iomem *pwm_base, uint pwm_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 禁用 PWM */</span></span><br><span class="line">    val = readl_relaxed(pwm_base + PWM_REG_CTRL);</span><br><span class="line">    val = (val &amp; <span class="number">0xFFFFFFFE</span>) | PWM_DISABLE;</span><br><span class="line">    writel_relaxed(val, pwm_base + PWM_REG_CTRL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置为捕获模式 */</span></span><br><span class="line">    val = readl_relaxed(pwm_base + PWM_REG_CTRL);</span><br><span class="line">    val = (val &amp; <span class="number">0xFFFFFFF9</span>) | PWM_MODE_CAPTURE;</span><br><span class="line">    writel_relaxed(val, pwm_base + PWM_REG_CTRL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置分频值 */</span></span><br><span class="line">    val = readl_relaxed(pwm_base + PWM_REG_CTRL);</span><br><span class="line">    val = (val &amp; <span class="number">0xFF0001FF</span>) | PWM_DIV64;</span><br><span class="line">    writel_relaxed(val, pwm_base + PWM_REG_CTRL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 启用中断 */</span></span><br><span class="line">    rk_pwm_int_ctrl(pwm_base, pwm_id, PWM_INT_ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 这里可以启用 PWM 捕获（注释掉的代码） */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    val = readl_relaxed(pwm_base + PWM_REG_CTRL);</span></span><br><span class="line"><span class="comment">    val = (val &amp; 0xFFFFFFFE) | PWM_ENABLE;</span></span><br><span class="line"><span class="comment">    writel_relaxed(val, pwm_base + PWM_REG_CTRL);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>pwm-rockchip-capture.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pwm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rockchip_pwm_capture.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开字符设备的回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rkxx_capture_drvdata</span> *<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_capture_cdev</span> *<span class="title">pcdev</span>;</span></span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_open\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 inode 中获取设备数据</span></span><br><span class="line">    pcdev = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> pwm_capture_cdev, cdev_test);</span><br><span class="line">    ddata = container_of(pcdev, <span class="keyword">struct</span> rkxx_capture_drvdata, pwm_cdev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ddata) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to get device data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将设备数据保存到文件私有数据中</span></span><br><span class="line">    file-&gt;private_data = ddata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取字符设备的回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">cdev_test_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rkxx_capture_drvdata</span> *<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="type">int</span> val, i, ret;</span><br><span class="line"></span><br><span class="line">    ddata = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ddata) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Device data is NULL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化捕获数据</span></span><br><span class="line">    ddata-&gt;lpr = <span class="number">0</span>;</span><br><span class="line">    ddata-&gt;hpr = <span class="number">0</span>;</span><br><span class="line">    ddata-&gt;state = RMC_IDLE1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 PWM</span></span><br><span class="line">    val = readl_relaxed(ddata-&gt;base + PWM_REG_CTRL);</span><br><span class="line">    val = (val &amp; <span class="number">0xFFFFFFFE</span>) | PWM_ENABLE;</span><br><span class="line">    writel_relaxed(val, ddata-&gt;base + PWM_REG_CTRL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待数据捕获完成</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        msleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ddata-&gt;state == RMC_DONE &amp;&amp; ddata-&gt;hpr &amp;&amp; ddata-&gt;lpr) &#123;</span><br><span class="line">            printk(<span class="string">&quot;capture ok!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用 PWM</span></span><br><span class="line">    val = readl_relaxed(ddata-&gt;base + PWM_REG_CTRL);</span><br><span class="line">    val = (val &amp; <span class="number">0xFFFFFFFE</span>) | PWM_DISABLE;</span><br><span class="line">    writel_relaxed(val, ddata-&gt;base + PWM_REG_CTRL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ddata-&gt;hpr == <span class="number">0</span> || ddata-&gt;lpr == <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to capture PWM data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算周期和占空比</span></span><br><span class="line">    ddata-&gt;data.period_ns = (ddata-&gt;lpr + ddata-&gt;hpr) * ddata-&gt;pwm_freq_nstime;</span><br><span class="line">    ddata-&gt;data.duty_ns = ddata-&gt;hpr * ddata-&gt;pwm_freq_nstime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据拷贝到用户空间</span></span><br><span class="line">    ret = copy_to_user(buf, &amp;ddata-&gt;data, size);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to copy data to user space\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_read\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ddata-&gt;state = RMC_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放字符设备的回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cdev_test_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;This is cdev_test_release\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符设备操作函数结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cdev_test_ops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = cdev_test_open,</span><br><span class="line">    .read = cdev_test_read,</span><br><span class="line">    .release = cdev_test_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PWM 捕获中断处理函数</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">rk_pwm_capture</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rkxx_capture_drvdata</span> *<span class="title">ddata</span> =</span> dev_id;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> channel = ddata-&gt;pwm_channel;</span><br><span class="line">    <span class="type">int</span> val, lpr, hpr;</span><br><span class="line"></span><br><span class="line">    val = readl_relaxed(ddata-&gt;base + PWM_REG_INTSTS(channel));</span><br><span class="line">    <span class="keyword">if</span> ((val &amp; PWM_CH_INT(channel)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> IRQ_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据极性读取 lpr 或 hpr</span></span><br><span class="line">    <span class="keyword">if</span> ((val &amp; PWM_CH_POL(channel)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ddata-&gt;state != RMC_DONE) &#123;</span><br><span class="line">            lpr = readl_relaxed(ddata-&gt;base + PWM_REG_LPR);</span><br><span class="line">            ddata-&gt;lpr = lpr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ddata-&gt;state != RMC_DONE) &#123;</span><br><span class="line">            hpr = readl_relaxed(ddata-&gt;base + PWM_REG_HPR);</span><br><span class="line">            ddata-&gt;hpr = hpr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除中断状态</span></span><br><span class="line">    writel_relaxed(PWM_CH_INT(channel), ddata-&gt;base + PWM_REG_INTSTS(channel));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态机处理</span></span><br><span class="line">    <span class="keyword">switch</span> (ddata-&gt;state) &#123;</span><br><span class="line">    <span class="keyword">case</span> RMC_IDLE1:</span><br><span class="line">        ddata-&gt;hpr = <span class="number">0</span>;</span><br><span class="line">        ddata-&gt;lpr = <span class="number">0</span>;</span><br><span class="line">        ddata-&gt;state = RMC_IDLE2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RMC_IDLE2:</span><br><span class="line">        ddata-&gt;hpr = <span class="number">0</span>;</span><br><span class="line">        ddata-&gt;lpr = <span class="number">0</span>;</span><br><span class="line">        ddata-&gt;state = RMC_GETDATA;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RMC_GETDATA:</span><br><span class="line">        printk(<span class="string">&quot;ddata-&gt;hpr is %d, ddata-&gt;lpr is %d\n&quot;</span>, ddata-&gt;hpr, ddata-&gt;lpr);</span><br><span class="line">        <span class="keyword">if</span> (ddata-&gt;hpr &amp;&amp; ddata-&gt;lpr) &#123;</span><br><span class="line">            ddata-&gt;state = RMC_DONE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动探测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">capture_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rkxx_capture_drvdata</span> *<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">r</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">p_clk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="type">int</span> pwm_channel;</span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_capture_cdev</span> *<span class="title">pcdev</span>;</span></span><br><span class="line">    <span class="type">int</span> freq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配驱动数据结构</span></span><br><span class="line">    ddata = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rkxx_capture_drvdata), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!ddata) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate memory for driver data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    ddata-&gt;state = RMC_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取资源</span></span><br><span class="line">    r = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    ddata-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, r);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ddata-&gt;base)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to map memory resource\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(ddata-&gt;base);</span><br><span class="line">    &#125;</span><br><span class="line">    ddata-&gt;dev = pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取时钟</span></span><br><span class="line">    clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;pwm&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(clk)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get PWM clock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(clk);</span><br><span class="line">    &#125;</span><br><span class="line">    ddata-&gt;clk = clk;</span><br><span class="line"></span><br><span class="line">    p_clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;pclk&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(p_clk)) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get peripheral clock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(p_clk);</span><br><span class="line">    &#125;</span><br><span class="line">    ddata-&gt;p_clk = p_clk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从设备树中读取 PWM 通道</span></span><br><span class="line">    ret = of_property_read_u32(np, <span class="string">&quot;pwm-channel&quot;</span>, &amp;pwm_channel);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get PWM channel from device tree\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    pwm_channel %= <span class="number">4</span>;</span><br><span class="line">    ddata-&gt;pwm_channel = pwm_channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中断号</span></span><br><span class="line">    irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> irq;</span><br><span class="line">    &#125;</span><br><span class="line">    ddata-&gt;irq = irq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置驱动数据</span></span><br><span class="line">    platform_set_drvdata(pdev, ddata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断</span></span><br><span class="line">    ret = devm_request_irq(&amp;pdev-&gt;dev, irq, rk_pwm_capture, IRQF_NO_SUSPEND, <span class="string">&quot;rk_pwm_capture_irq&quot;</span>, ddata);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to request IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用时钟</span></span><br><span class="line">    ret = clk_prepare_enable(ddata-&gt;clk);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to enable PWM clock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = clk_prepare_enable(ddata-&gt;p_clk);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        clk_disable_unprepare(ddata-&gt;clk);</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to enable peripheral clock\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 PWM 频率</span></span><br><span class="line">    freq = clk_get_rate(ddata-&gt;clk) / <span class="number">64</span>;</span><br><span class="line">    ddata-&gt;pwm_freq_nstime = <span class="number">1000000000</span> / freq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册字符设备</span></span><br><span class="line">    pcdev = &amp;ddata-&gt;pwm_cdev;</span><br><span class="line">    ret = alloc_chrdev_region(&amp;pcdev-&gt;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;alloc_name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;alloc_chrdev_region error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_chrdev;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">&quot;alloc_chrdev_region success\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pcdev-&gt;cdev_test.owner = THIS_MODULE;</span><br><span class="line">    cdev_init(&amp;pcdev-&gt;cdev_test, &amp;cdev_test_ops);</span><br><span class="line">    ret = cdev_add(&amp;pcdev-&gt;cdev_test, pcdev-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to add cdev\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_cdev_add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备类</span></span><br><span class="line">    pcdev-&gt;<span class="class"><span class="keyword">class</span> =</span> class_create(THIS_MODULE, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(pcdev-&gt;class)) &#123;</span><br><span class="line">        ret = PTR_ERR(pcdev-&gt;class);</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to create class\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_class_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备</span></span><br><span class="line">    pcdev-&gt;device = device_create(pcdev-&gt;class, <span class="literal">NULL</span>, pcdev-&gt;dev_num, <span class="literal">NULL</span>, <span class="string">&quot;capture&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(pcdev-&gt;device)) &#123;</span><br><span class="line">        ret = PTR_ERR(pcdev-&gt;device);</span><br><span class="line">        dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to create device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_device_create;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rk_pwm_capture_init(ddata-&gt;base, ddata-&gt;pwm_channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_device_create:</span><br><span class="line">    class_destroy(pcdev-&gt;class);</span><br><span class="line">err_class_create:</span><br><span class="line">    cdev_del(&amp;pcdev-&gt;cdev_test);</span><br><span class="line">err_cdev_add:</span><br><span class="line">    unregister_chrdev_region(pcdev-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line">err_alloc_chrdev:</span><br><span class="line">    clk_disable_unprepare(ddata-&gt;p_clk);</span><br><span class="line">    clk_disable_unprepare(ddata-&gt;clk);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动移除函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">capture_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rkxx_capture_drvdata</span> *<span class="title">ddata</span> =</span> platform_get_drvdata(pdev);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_capture_cdev</span> *<span class="title">pcdev</span> =</span> &amp;ddata-&gt;pwm_cdev;</span><br><span class="line"></span><br><span class="line">    device_destroy(pcdev-&gt;class, pcdev-&gt;dev_num);</span><br><span class="line">    class_destroy(pcdev-&gt;class);</span><br><span class="line">    cdev_del(&amp;pcdev-&gt;cdev_test);</span><br><span class="line">    unregister_chrdev_region(pcdev-&gt;dev_num, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    clk_disable_unprepare(ddata-&gt;p_clk);</span><br><span class="line">    clk_disable_unprepare(ddata-&gt;clk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备树匹配表</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">capture_of_device_id</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;pwm-capture&quot;</span>&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平台驱动结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">capture_platform_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;pwm-capture&quot;</span>,</span><br><span class="line">        .of_match_table = capture_of_device_id,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = capture_probe,</span><br><span class="line">    .remove = capture_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">modulecdev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;capture_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">modulecdev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;capture_platform_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(modulecdev_init);</span><br><span class="line">module_exit(modulecdev_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用固定宽度类型，避免 ABI 问题</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">pwm_data</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> period_ns;</span><br><span class="line">    <span class="type">int32_t</span> duty_ns;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dev_path = <span class="string">&quot;/dev/capture&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(dev_path, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;无法打开设备 %s: %s\n&quot;</span>, dev_path, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_data</span> <span class="title">data</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> n = read(fd, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;读取设备失败: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="keyword">sizeof</span>(data)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;读取数据不完整: 期望 %zu 字节，实际 %zd 字节\n&quot;</span>, </span><br><span class="line">                <span class="keyword">sizeof</span>(data), n);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;period_ns = %d ns, duty_ns = %d ns\n&quot;</span>, data.period_ns, data.duty_ns);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;占空比 = %.2f%%\n&quot;</span>, </span><br><span class="line">           (data.period_ns &gt; <span class="number">0</span>) ? (<span class="number">100.0</span> * data.duty_ns / data.period_ns) : <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要另外一个PWM作为输入信号，接入PWM3，让其捕获。</p>]]></content>
    
    
    <summary type="html">Linux PWM</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Linux UART</title>
    <link href="https://even629.com/posts/2512313/"/>
    <id>https://even629.com/posts/2512313/</id>
    <published>2025-12-31T12:46:13.000Z</published>
    <updated>2025-12-31T12:46:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-31</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><p>串口（Serial Port）也叫串行通信接口，通常也叫做 <strong>COM 接口</strong>，是一种计算机与外部设备(如串口通信设备)进行数据通信的<strong>异步全双工接口</strong>。它通过<strong>串行传输</strong>方式，即一次只发送一个比特位（bit）来进行数据传输。</p><p>具体来说，典型的串口通信只需要 3 根线，分别是地线（GND），发送线（TX），接收线（RX），如下图所示，发送和接收各用一条线，<strong>没有时钟线</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704091.png" alt="CPU与串口设备的连接连接" loading="lazy"></p><h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p>波特率（Baud Rate）是串口通信中的关键参数，它指的是每秒传输的比特位数或者码元速率。</p><p>在数字信道中，一个脉冲信号就是一个码元，如下图所示。码元速率表示在 1 秒内能发送多少码元或脉冲信号。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704131.png" alt="波特率" loading="lazy"></p><p>通信的双方必须设定相同的波特率才能确保数据能够正确传输。常见的标准波特率如 9600、115200 等，通常满足大多数应用需求。</p><blockquote><p>但在特定情况下，可能需要设置非标准的波特率，此时需确保所有通信设备都能支持和正确配置该波特率。</p><p>对于高于 1.5Mbps 的波特率的设置，可能需要通过时钟的小数分频或整数分频来实现。</p><p>如果无法通过分频来达到所需波特率，则可能需要调整 PLL（锁相环）设置，调整 PLL 存在一定风险，因为它可能会影响到设备的其他模块。</p></blockquote><p><strong>比特率</strong>是指<strong>单位时间内传输的比特数量</strong>，通常用 bps(bit per second)表示，单位是 bit&#x2F;s。与之相比，<strong>波特率</strong>则是<strong>每秒钟传输的码元或脉冲信号的数量</strong>。这俩者之间的关系可以用公式表示为<strong>比特率&#x3D;波特率*log2(M)</strong>，其中 M 表示每个码元承载的信息量。</p><p>一个码元实际上就是一个脉冲信号，它可能携带 1 个 bit，2 个bit 或者更多 bit 的数据，这取决于通信系统的具体实现方式。<strong>在二进制系统中，比特率等于波特率，因为每个码元正好承载 1 个 bit 的信息</strong>。</p><p>举例：假如串口的波特率为 9600，那么在二进制系统中，一秒钟可以传送多少个字节呢？</p><p>一个字节等于 8 个 bit，也就是 8 个高低电平变化，因为在二进制系统中，比特率等于波特率。因此一秒钟可以传输的字节数为 9600&#x2F;8&#x3D;1200 字节。</p><h2 id="串口通讯协议"><a href="#串口通讯协议" class="headerlink" title="串口通讯协议"></a>串口通讯协议</h2><h3 id="数据流结构"><a href="#数据流结构" class="headerlink" title="数据流结构"></a>数据流结构</h3><p>在串口通信中，除了关注波特率外，数据流的结构也至关重要。</p><p>每帧数据包括 11 位：</p><ul><li>1位起始位</li><li>8 位数据位</li><li>1 位奇偶校验位</li><li>1 位停止位</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704164.png" alt="串口数据流结构" loading="lazy"></p><ul><li><p><strong>起始位</strong>：表示数据传输的开始，数据线上空闲状态是 1，从高电平（空闲状态）拉低表示开始传输数据。</p></li><li><p><strong>数据位</strong>：指每个字节中的数据位数，通常为 7 或 8 位。</p></li><li><p><strong>校验位</strong>：用于验证传输数据的准确性，其类型包括奇校验、偶校验、0 校验、和 1 校验。</p></li><li><p><strong>奇校验（odd parity）</strong>: 当实际数据中 1 的个数为偶数的时候，校验位为 1，否则这个校验位就是 0。</p></li><li><p><strong>偶校验（even parity）</strong>: 当实际数据中 1 的个数为偶数的时候，校验位为 0，否则这个校验位就是 1。</p></li><li><p><strong>0 校验（space parity）</strong>: 校验位恒为 0，如果为 1 表示错误。</p></li><li><p><strong>1 校验（mark parity）</strong>: 校验位恒为 1，如果为 0 表示错误。</p></li><li><p><strong>停止位</strong>：指在每个数据字节传输结束后发送的位数，通常为 1 或 2 位。</p></li></ul><h3 id="时序波形分析"><a href="#时序波形分析" class="headerlink" title="时序波形分析"></a>时序波形分析</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704206.png" alt="逻辑分析仪波形" loading="lazy"></p><p>当<strong>数据线空闲时是高电平</strong>，而在<strong>数据传输时则会被拉低</strong>，图中的第一个脉冲对应于起始位。紧随其后的是 8 位数据位，它们按照最低有效位（LSB）优先的顺序传输。</p><p>例如，数据位“00110001”转换成十六进制是 0x31，换算成十进制是 49。在 ASCII码中，49 对应的字符是’1’，因此传输的数据是 1。数据传输完成之后，总线被拉高。</p><h2 id="串口通信接口的类型"><a href="#串口通信接口的类型" class="headerlink" title="串口通信接口的类型"></a>串口通信接口的类型</h2><p>UART 只规定了收发的时序，即“先发起始位，再发数据位，校验位，最后发停止位”，只规定了高低电平，但是并没有规定高电平指的是多少伏，低电平指的是多少伏。</p><p>串口一般的接口电平有 <strong>TTL</strong>，<strong>RS232</strong>,<strong>RS485</strong>,<strong>RS422</strong>，并且<strong>每种接口通常需要相应的电平转换芯片</strong>。直<strong>接使用处理器引出的串口接口时，通常是 TTL 电平</strong>。</p><p>然而，处理器的不同型号或供应商可能存在电平差异，这意味着在某些情况下不能直接连接设备。因此，为了确保正常通信必须进行适当的电平转换。一般的串口接口电平对比如下表所示：</p><table><thead><tr><th>电平标准</th><th>逻辑电平定义</th><th>典型高&#x2F;低电平电压</th><th>信号类型</th><th>最大传输距离</th><th>主要特点</th></tr></thead><tbody><tr><td><strong>TTL</strong></td><td>0 &#x3D; 低电平<br /> 1 &#x3D; 高电平</td><td>低电平：0 V 高电平：1.8 V &#x2F; 2.5 V &#x2F; 3.3 V &#x2F; 5 V（取决于供电）</td><td>单端信号</td><td>几米（通常 ≤ 2–5 m）</td><td>板内或板间短距离通信 ，与 MCU、传感器等直接兼容 ， 抗干扰能力弱，不适用于长距离</td></tr><tr><td><strong>RS-232</strong></td><td>0 &#x3D; <strong>正电压</strong>（+3 V ~ +15 V） <br />1 &#x3D; <strong>负电压</strong>（-3 V ~ -15 V）</td><td>逻辑 0（空号）：+3 V ~ +15 V 逻辑 1（传号）：-3 V ~ -15 V 常用 ±12 V</td><td>单端（但使用正负电压）</td><td>约 15–50 米（速率越低距离越长）</td><td>支持点对点通信，抗干扰能力较强于 TTL，需电平转换芯片（如 MAX232），已逐渐被 USB 等替代</td></tr><tr><td><strong>RS-422</strong></td><td>差分信号： <br />1 &#x3D; A &gt; B（+2 V ~ +6 V）<br /> 0 &#x3D; A &lt; B（-2 V ~ -6 V）</td><td>差分电压：±2 V ~ ±6 V</td><td><strong>差分信号</strong>（全双工，4 线）</td><td>最大约 <strong>1200 米</strong>（@ 100 kbps）</td><td>支持全双工通信，强抗共模干扰能力，适用于工业环境，通常为 1 发送器，多接收器</td></tr><tr><td><strong>RS-485</strong></td><td>差分信号：<br /> 1 &#x3D; A &gt; B（+1.5 V ~ +5 V）<br /> 0 &#x3D; A &lt; B（-1.5 V ~ -5 V）</td><td>差分电压：≥ ±1.5 V（典型 ±2 V ~ ±5 V）</td><td><strong>差分信号</strong>（半双工或全双工，2 或 4 线）</td><td>最大约 <strong>1200 米</strong>（@ 100 kbps） （理论可达 1219 米）</td><td>支持多点通信（最多 32~256 节点） ，广泛用于工业总线（如 Modbus），抗干扰强，适合长距离、噪声环境</td></tr></tbody></table><h3 id="RS232接口"><a href="#RS232接口" class="headerlink" title="RS232接口"></a>RS232接口</h3><p><strong>RS232（Recommended Standard 232）</strong> 协议是由美国电子工业协会在 1970 年制定的串行通信标准。该标准<strong>统一了串口通信的连接器和引脚定义</strong>，如下图所示，并明确规定了每个连接器引脚的电平标准</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704249.png" alt="DB9公头和母头" loading="lazy"></p><h4 id="DB9-引脚说明"><a href="#DB9-引脚说明" class="headerlink" title="DB9 引脚说明"></a><strong>DB9 引脚说明</strong></h4><p>DB9 是一种常见的串口连接器，通常用于 RS-232 串口通信和其他串行通信应用。它包含 9个引脚，每个引脚都有特定的功能。下面是 DB9 连接器的引脚说明：</p><ul><li><strong>Pin 1 - DCD (Data Carrier Detect)</strong>:数据载波检测。指示远程设备是否准备好进行通信。</li><li><strong>Pin 2 - RXD (Receive Data)</strong>:接收数据。从远程设备接收数据流。</li><li><strong>Pin 3 - TXD (Transmit Data)</strong>:发送数据。向远程设备发送数据流。</li><li><strong>Pin 4 - DTR (Data Terminal Ready)</strong>:数据终端就绪。指示数据终端设备（如计算机）准备好进行通信。</li><li><strong>Pin 5 - GND (Ground)</strong>:地线。电气接地，用于电路的参考和屏蔽。</li><li><strong>Pin 6 - DSR (Data Set Ready)</strong>:数据集准备好。指示远程设备准备好接收和发送数据。</li><li><strong>Pin 7 - RTS (Request to Send)</strong>:请求发送。发送方使用此信号请求开始发送数据。</li><li><strong>Pin 8 - CTS (Clear to Send)</strong>:清除发送。接收方使用此信号表示准备好接收数据。</li><li><strong>Pin 9 - RI (Ring Indicator)</strong>:铃信号指示器。指示远程设备发送了铃响信号。</li></ul><p>RS232 本质上也是串口协议，与串口协议相同。但它规定了串口的物理接口和电平特性，因此在硬件层面有所不同，但在软件编程和串口通信的实现上并无区别</p><h4 id="电平特性"><a href="#电平特性" class="headerlink" title="电平特性"></a>电平特性</h4><ul><li><p>RS232 接收-发送端的电信号是{ % emp 相对于公共地线（GND）的电压信号 %}。</p><ul><li>在 RS232 标准中，<strong>电压差值在+3V 至+15V 之间被定义为逻辑“0”</strong>，而在**-3V 至-15V 之间则表示逻辑“1”**。电压差值在-3V 至+3V 之间的情况未定义。</li><li>通常，实际应用中希望电压差的绝对值在 5V 至 15V 之间，以确保可靠的信号传输。</li><li>在数据发送时，发送端驱动器输出+5V 至+15V 的正电压信号表示逻辑“0”，而-5V 至-15V 的负电压信号表示逻辑“1”。</li><li>在数据接收时，只要检测到大于3V 的电信号，即视为有效信号。</li></ul></li><li><p>RS232 接口在发送和接收时具有相对较高的电流能力，可以处理相对较大的电流负载，这使得它适合于长距离通信和连接外部设备。</p></li><li><p>RS232 信号具有较高的抗干扰能力，能够在工业环境中稳定运行，不易受到电磁干扰的影响。</p></li><li><p>RS232 包括以下信号线：</p><ul><li>发送线（Tx）</li><li>接收线（Rx）</li><li>地线（Ground）</li><li>数据终端就绪（DTR）</li><li>数据就绪（DSR）</li><li>请求发送（RTS）</li><li>清除发送（CTS）</li><li>环路信号检测（DSR）</li></ul></li><li><p>RS232 支持各种波特率，通常从低速率到较高速率，最高可以达到数百千位每秒（kbps）</p></li></ul><p> iTOP-RK3568 开发板上，调试串口使用了 MAX3232 芯片将 TTL 电平转换成 232 电平，调试串口的原理图如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704297.png" alt="Debug UART2" loading="lazy"></p><h3 id="RS485接口"><a href="#RS485接口" class="headerlink" title="RS485接口"></a>RS485接口</h3><p>RS485 标准是由电信行业协会（Telecommunications Industry Association, TIA）和电子工业联盟（Electronic Industries Alliance, EIA）共同制定的。该标准的主要目的是<emp>解决长距离通信需求（最长达 1200 米）以及提供优秀的抗干扰性能</emp>。</p><h4 id="特点和优势"><a href="#特点和优势" class="headerlink" title="特点和优势"></a>特点和优势</h4><ul><li><strong>长距离通信能力</strong>：RS485 能够在理想条件下实现长达 1200 米的通信距离，适用于需要远距离数据传输的场合。</li><li><strong>抗干扰能力强</strong>：由于采用差分信号传输方式，RS485 能有效抵御电磁干扰（EMI）和射频干扰（RFI），保证数据传输的稳定性和可靠性。</li><li><strong>多站能力</strong>：RS485 支持多个设备（最多 32 个）在同一条总线上进行通信，每个设备可以独立地发送和接收数据，从而实现灵活的网络组网。</li><li>应用广泛：RS485 广泛应用于工业自动化控制系统、建筑自动化、智能家居系统、电力系统监控等领域，满足对长距离、高速和可靠通信的要求</li></ul><h4 id="电平特性-1"><a href="#电平特性-1" class="headerlink" title="电平特性"></a>电平特性</h4><p>RS485 的电平特性如下：</p><ul><li><strong>差分信号传输</strong>：RS485 使用差分信号进行数据传输，即数据信号是相对于两条信号线（通常标记为 A 和 B 线）之间的电压差来表示的。这种差分信号传输方式使得 RS485 具有良好的抗干扰能力和长距离传输能力。</li><li><strong>电压范围</strong>：<ul><li><strong>逻辑“ 1”以两线间的电压差为+(2~6)V 表示</strong>；</li><li><strong>逻辑“ 0”以两线间的电压差为-(2~6)V表示</strong>。</li><li><u>接口信号电平比 RS232 降低了</u>，不易损坏接口电路的芯片，且**该电平与 TTL 电平兼容**，可方便与 TTL 电路连接。</li></ul></li><li>电流能力：RS485 发送器具有较强的驱动能力，能够推动较长的通信线路和多个接收器。接收器能够处理较大的输入电流，以确保信号的可靠接收。</li><li>电气特性：RS485 支持<u>多个设备（最多 32 个）在同一条总线上进行通信</u>。支持长达 1200米的通信距离，在特定情况下甚至可以更长</li></ul><p> iTOP-RK3568 开发板上使用 <strong>SIT3485E 芯片</strong>将 TTL 电平转换为 485 电平，原理图如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704354.png" alt="将TTL电平转为485电平" loading="lazy"></p><p>可知 RK3568 开发板的 RS485 接口实际上是通过 SIT3485E 芯片转接的串口 7。</p><h4 id="SIT3485E芯片"><a href="#SIT3485E芯片" class="headerlink" title="SIT3485E芯片"></a>SIT3485E芯片</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704396.png" alt="SIT3485E 芯片特点" loading="lazy"></p><p>SIT3485E 是一款 3.0V~5.5V 宽电源供电、总线端口 ESD 水平达到 15KV HBM 以上、总线耐压范围达到±15V、<strong>半双工</strong>、<strong>低功耗</strong>，<strong>功能完全满足 TIA&#x2F;EIA-485 标准要求的 RS-485 收发器</strong>。</p><p>SIT3485E 包括<strong>一个驱动器</strong>和<strong>一个接收器</strong>，两者均可<strong>独立使能与关闭</strong>。当两者均禁用时，驱动器与接收器均输出高阻态。</p><p>SIT3485E 具有 1&#x2F;8 负载，允许 256 个 SIT3485E 收发器并接在同一通信总线上。可实现高达 12Mbps 的无差错数据传输。</p><p>SIT3485E 工作电压范围为 3.0~5.5 V，具备失效安全（fail-safe）、限流保护、过压保护等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704441.png" alt="引脚分布图" loading="lazy"></p><table><thead><tr><th>引脚序号</th><th>引脚名称</th><th>引脚功能</th></tr></thead><tbody><tr><td>1</td><td>RO</td><td><strong>接收器输出端</strong>。 当 &#x2F;RE 为低电平时，若 A-B ≥ -10mV，RO 输出为高电平； 若 A-B ≤ -200mV，RO 输出为低电平。</td></tr><tr><td>2</td><td>&#x2F;RE</td><td><strong>接收器输出使能控制</strong>。 当 &#x2F;RE 接低电平时，接收器输出使能，RO 输出有效； 当 &#x2F;RE 接高电平时，接收器输出禁能，RO 为高阻态； &#x2F;RE 接高电平且 DE 接低电平时，器件进入低功耗关断模式。</td></tr><tr><td>3</td><td>DE</td><td><strong>驱动器输出使能控制</strong>。 DE 接高电平时驱动器输出有效，DE 为低电平时输出为高阻态； &#x2F;RE 接高电平且 DE 接低电平时，器件进入低功耗关断模式。</td></tr><tr><td>4</td><td>DI</td><td><strong>DI 驱动器输入</strong>。 DE 为高电平时，DI 上的低电平使驱动器同相端 A 输出为低电平，驱动器反相端 B 输出为高电平； DI 上的高电平将使同相端输出为高电平，反相端输出为低。</td></tr><tr><td>5</td><td>GND</td><td><strong>接地</strong></td></tr><tr><td>6</td><td>A</td><td><strong>接收器同相输入和驱动器同相输出端</strong></td></tr><tr><td>7</td><td>B</td><td><strong>接收器反相输入和驱动器反相输出端</strong></td></tr><tr><td>8</td><td>VCC</td><td><strong>接电源</strong></td></tr></tbody></table><p>由引脚定义图可知：</p><ul><li>RO 引脚为接收器输出端，在原理图上连接到 UART7_RX_M1 引脚。</li><li>DI引脚为 DI 驱动器输入引脚，在原理图上连接到 UART7_TX_M1 引脚。</li><li>A 引脚是接收器同向输入和驱动器同向输出端</li><li>B 引脚是接收器反向输入和驱动器反向输出端，A 和 B 就是 RS485 的差分对了。</li><li><u>RE</u> 引脚是接收器输出使能控制引脚<ul><li>当&#x2F;RE 接低电平时，接收器输出使能，RO 输出有效</li><li>当&#x2F;RE 接高电平时，接收器输出禁能，RO 为高阻态。</li></ul></li><li>DE 引脚是驱动器输出使能控制引脚，DE 接高电平时驱动器输出有效，DE 为低电平时输出为高阻态。</li><li><u>RE</u>接高电平且 DE 接低电平时，器件进入低功耗模式。</li></ul><p>简单来说：</p><ul><li><u>RE</u>为低电平时，RO 输出有效。反之 RO 高阻态，也就是无效。RO 接的 UART7_RX_M1，UART7_RX_M1 是串口的接收引脚。因此，/RE 低电平时，串口可以接收数据，反之串口无法接收数据。</li><li>DE 是高电平时，DI 有效，DI 接的是 UART7_TX_M1，UART7_RX_M1 是串口发送引脚，因此，DE 是高电平时，DI 上的低电平使驱动器 同向端 A 输出为低电平，驱动器反向端 B 输出为高电平，串口可以发送数据，反之串口无法发送数据。</li></ul><p><strong><u>RE</u> 和 DE 有效电平刚好相反</strong>，又因为 485 是<strong>半双工</strong>，不能同时收发。所以<u>RE</u> 和 DE 肯定不能同时开启，<strong>即<u>RE</u> 和 DE 的电平必须相同</strong>。这样<u>RE</u>开启，就等于 DE 关闭，所以这两个引脚连在了一起。</p><p>这样就很清晰了，如果 GPIO0_C6 输出低电平，<u>RE</u> 和 DE 是低电平，<u>RE</u> 是低电平时，串口可以接收数据，DE 是低电平时，串口不能发送数据。</p><p>如果 GPIO0_C6 输出高电平，<u>RE</u>和 DE 是高电平，<u>RE</u> 是高电平时，串口不能接收数据，DE 是高电平时，串口可以发送数据。</p><p>也就是说，我们需要用 GPIO0_C6 这个引脚的高低电平来控制 RS485 是发送还是接收。因此，我们需要编写一个驱动来达到这个目的。迅为提供的源码中默认配置了驱动来控制GPIO0_C6。</p><h5 id="自收发-485-电路"><a href="#自收发-485-电路" class="headerlink" title="自收发 485 电路"></a>自收发 485 电路</h5><p>除了软件控制外，还可以通过硬件实现自动切换，以实现 RS485 的自动收发功能。软件控制发送和接收存在一定的时间差，为了减少这种时间差，迅为开发板的底板原理图进行了优化，兼容了硬件实现自动收发。具体的修改方式是将 R295 去掉，并将下图中标记为 DNP 的元件都进行焊接。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704497.png" alt="UART7_M1 To RS485" loading="lazy"></p><ul><li>当 UART_TX_M1 为高电平时，Q17 的基极也为高电平，导致 Q17 导通，<u>RE</u> 和 DE 为低电平，从而串口处于接收数据模式</li><li>当 UART_TX_M1 为低电平时，Q17的基极为低电平，导致Q17截止，<u>RE</u> 和DE为高电平，串口处于发送数据模式。由于UART_TX_M1 在空闲时为高电平，表明串口处于接收数据状态；当 UART_TX_M1 被拉低时，串口则处于发送数据状态。</li></ul><blockquote><p>既然 UART_TX_M1 高电平表示接收模式，那发送 1 时也是高电平。这样芯片会一直处于接收模式，导致 1 无法发送出去，是吗？</p><p><strong>当转接芯片处于接收模式时，A 和 B 两个引脚会处于高阻态模式</strong>。</p><p>高阻态意味着非常大的电阻，几乎等同于断路。<strong>此时，A 由上拉电阻拉高，B 由下拉电阻拉低</strong>。</p><p>因此，<strong>A 高、B 低表示通信中的 1</strong>。通过这种“接收模式”，我们巧妙地将“1”发送出去了。</p><p>这一优化省去了一个 RS485 收发控制 IO，将 RS485 完全当作串口使用，方便编写驱动。</p></blockquote><h1 id="串口子系统框架"><a href="#串口子系统框架" class="headerlink" title="串口子系统框架"></a>串口子系统框架</h1><p>串口子系统框架是 Linux 内核中专门用于处理串口设备的模块化框架，框架图如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704545.png" alt="串口子系统框架" loading="lazy"></p><ul><li><strong>应用层</strong>：位于最顶层，是串口子系统中用户空间应用程序与内核空间之间的接口，应用层包括了用户空间的串口应用程序，如串口通信工具 minicom 等。</li><li><strong>字符设备层</strong>：位于应用层的下方，负责将用户空间的串口读写请求传递给内核空间的tty_core 层。字符设备层将串口设备看作一个特殊的字符设备，通过字符设备接口来进行操作。</li><li><strong>tty_core 层</strong>：位于字符设备层的下方，是 Linux 内核中用于管理串口设备的核心模块，它处理串口设备的基本功能，如数据传输，控制，缓冲管理等。tty_core 层与具体的串口硬件无关，是串口设备的通用处理层。</li><li><strong>uart_core 层</strong>：位于 tty_core 层的下方，提供了串口设备的底层驱动接口，负责与具体的串口硬件进行通信。uart_core 层负责控制串口数据的发送和接收、中断处理、时钟管理等底层操作。</li><li><strong>硬件层</strong>：位于最底层，是串口子系统中与具体硬件有关的部分。硬件层包括了串口硬件的驱动程序，与具体的串口控制器进行通信，实现对硬件的底层控制和操作。</li></ul><h2 id="配置串口驱动"><a href="#配置串口驱动" class="headerlink" title="配置串口驱动"></a>配置串口驱动</h2><p>在瑞芯微官方提供的 SDK 内核源码里面，串口驱动使用的是 8250 通用串口驱动，以下是主要驱动文件</p><ul><li><code>drivers/tty/serial/8250/8250_core.c</code>     8250 串口驱动核心</li><li><code>drivers/tty/serial/8250/8250_dw.c</code>         Synopsis DesignWare 8250 串口驱动</li><li><code>drivers/tty/serial/8250/8250_dma.c</code>       8250 串口 DMA 驱动</li><li><code>drivers/tty/serial/8250/8250_port.c</code>     8250 串口端口操作</li><li><code>drivers/tty/serial/8250/8250_early.c</code>   8250 串口 early console 驱动</li></ul><p>make menuconfig中选中驱动</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Device Driver / <span class="type">Character</span> devices / <span class="type">Serial</span> drivers</span><br><span class="line">[*] Console <span class="keyword">on</span> <span class="number">8250</span>/<span class="number">16550</span> <span class="keyword">and</span> compatible <span class="type">serial</span> port</span><br></pre></td></tr></table></figure><p>迅为提供的 SDK 源码设备树中默认打开了串口 9，打开<code>arch/arm64/boot/dts/rockchip/rk3568.dtsi</code>设备树文件，串口 9 控制器的设备树节点如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">uart9:</span> <span class="title class_">serial@fe6d0000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-uart&quot;</span>, <span class="string">&quot;snps,dw-apb-uart&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe6d0000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">125</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> SCLK_UART9&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_UART9&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;baudclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-shift</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-io-width</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">dmas</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">18</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">19</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;uart9m0_xfer</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>compatible</code>：指定设备的兼容性字符串，表示此串口设备兼容于 <code>rockchip,rk3568-uart</code> 和<code>snps,dw-apb-uart</code> 两种串口控制器。这有助于设备树绑定相应的驱动程序。</li><li><code>reg</code>：指定串口设备的地址和大小，0xfe6d0000 是串口设备的基地址，0x100 表示地址空间的大小。</li><li><code>interrupts</code>：指定串口设备的中断信息，包括中断类型和中断号。</li><li><code>clocks</code>：指定串口设备所使用的时钟源，包括波特率时钟和 APB 时钟。</li><li><code>clock-names</code>：指定时钟源的名称，用于与时钟源的具体配置相匹配。</li><li><code>reg-shift</code>：表示地址偏移量的位数，即每个寄存器的偏移量是按字节还是按字（byte）。</li><li><code>reg-io-width</code>：表示对设备地址和数据的访问宽度，这里是 4 表示 4 字节宽度。</li><li><code>dmas</code>：指定串口设备使用的 DMA 控制器以及 DMA 通道号，用于数据传输的 DMA 操作。</li><li><code>dma-names</code>:可选值为<ul><li><code>tx</code>打开 tx dma</li><li><code>rx</code>打开 rx dma</li><li><code>!tx</code>关闭 tx dma</li><li><code>!rx</code>关闭 rx dma</li></ul></li><li><code>pinctrl-names</code> 和 <code>pinctrl-0</code>：用于串口设备的管脚控制，以配置和管理串口设备的引脚设置。可选参数为如下所示：<ul><li><code>&amp;uart9m0_xfer</code> 配置 tx 和 rx 引脚为 iomux group 0</li><li><code>&amp;uart9m1_xfer</code> 配置 tx 和 rx 引脚为 iomux group 1</li><li><code>&amp;uart9m0_ctsn</code> 和<code>&amp;uart1m0_rtsn</code> 配置硬件自动流控 cts 和 rts 引脚为 iomux group 0</li><li><code>&amp;uart9m1_ctsn</code>和<code>&amp;uart1m1_rtsn</code> 配置硬件自动流控 cts 和 rts 引脚为 iomux group 1</li></ul></li><li><code>status</code>：表示串口设备的状态，这里是 “disabled” 表示设备当前处于禁用状态。如果设置为“okay”表示打开设备</li></ul><h2 id="uart-driver-注册流程分析"><a href="#uart-driver-注册流程分析" class="headerlink" title="uart_driver 注册流程分析"></a>uart_driver 注册流程分析</h2><h3 id="uart-相关底层结构体"><a href="#uart-相关底层结构体" class="headerlink" title="uart 相关底层结构体"></a>uart 相关底层结构体</h3><p>uart 相关底层结构体之间的关系如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704587.png" alt="uart 相关底层结构体之间的关系" loading="lazy"></p><h4 id="struct-uart-driver"><a href="#struct-uart-driver" class="headerlink" title="struct uart_driver"></a>struct uart_driver</h4><p><code>uart_driver</code> 结构体代 表 UART 驱动，<code>uart_driver</code> 定义在 <code>include/linux/serial_core.h</code> 文件中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span>*<span class="title">owner</span>;</span><span class="comment">// 模块所有者</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*driver_name;<span class="comment">// 驱动程序名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*dev_name;<span class="comment">// 设备名称</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">// 设备分配的主设备号</span></span><br><span class="line"><span class="type">int</span> minor;<span class="comment">// 设备分配的次设备号</span></span><br><span class="line"><span class="type">int</span> nr;<span class="comment">// 设备的唯一标识符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console</span>*<span class="title">cons</span>;</span><span class="comment">// 控制台的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * these are private; the low level driver should not</span></span><br><span class="line"><span class="comment"> * touch these; they should be initialised to NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span>*<span class="title">state</span>;</span><span class="comment">// 指向 UART 驱动程序状态的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span>*<span class="title">tty_driver</span>;</span><span class="comment">// 指向 TTY 驱动程序的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>struct uart_driver</code> 封装了 <code>tty_driver</code>，使得底层的 UART 驱动不需要关心 <code>tty_driver</code>。</p><h4 id="struct-uart-port"><a href="#struct-uart-port" class="headerlink" title="struct uart_port"></a>struct uart_port</h4><p>uart_port 是针对一个串口的抽象，定义在 <code>kernel/include/linux/serial_core.h</code>，其内部包含一个 <code>uart_state</code> 类型的成员变量，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span>lock;<span class="comment">/* port lock */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>iobase;<span class="comment">/* in/out[bwl] */</span><span class="comment">/* io 端口基地址（物理） */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> __iomem*membase;<span class="comment">/* read/write[bwl] */</span><span class="comment">/* io 内存基地址（虚拟） */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span><span class="params">(*serial_in)</span><span class="params">(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span>(*serial_out)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">void</span>(*set_termios)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">               <span class="keyword">struct</span> ktermios *new,</span><br><span class="line">               <span class="keyword">struct</span> ktermios *old);</span><br><span class="line"><span class="type">void</span>(*set_ldisc)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">     <span class="keyword">struct</span> ktermios *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span><span class="params">(*get_mctrl)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;</span><br><span class="line"><span class="type">void</span>(*set_mctrl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span><span class="params">(*get_divisor)</span><span class="params">(<span class="keyword">struct</span> uart_port *,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> baud,</span></span><br><span class="line"><span class="params">       <span class="type">unsigned</span> <span class="type">int</span> *frac)</span>;</span><br><span class="line"><span class="type">void</span>(*set_divisor)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span> baud,</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span> quot,</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span> quot_frac);</span><br><span class="line"><span class="type">int</span>(*startup)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line"><span class="type">void</span>(*shutdown)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line"><span class="type">void</span>(*throttle)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line"><span class="type">void</span>(*unthrottle)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line"><span class="type">int</span>(*handle_irq)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line"><span class="type">void</span>(*pm)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> state,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> old);</span><br><span class="line"><span class="type">void</span>(*handle_break)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line"><span class="type">int</span>(*rs485_config)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line"><span class="keyword">struct</span> serial_rs485 *rs485);</span><br><span class="line"><span class="type">int</span>(*iso7816_config)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">  <span class="keyword">struct</span> serial_iso7816 *iso7816);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>irq;<span class="comment">/* irq number */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>irqflags;<span class="comment">/* irq flags  */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>uartclk;<span class="comment">/* base uart clock */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>fifosize;<span class="comment">/* tx fifo size */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>x_char;<span class="comment">/* xon/xoff char */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>regshift;<span class="comment">/* reg offset shift */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>iotype;<span class="comment">/* io access style */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>quirks;<span class="comment">/* internal quirks */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_PORT(SERIAL_IO_PORT)<span class="comment">/* 8b I/O port access */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_HUB6(SERIAL_IO_HUB6)<span class="comment">/* Hub6 ISA card */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM(SERIAL_IO_MEM)<span class="comment">/* driver-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM32(SERIAL_IO_MEM32)<span class="comment">/* 32b little endian */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_AU(SERIAL_IO_AU)<span class="comment">/* Au1x00 and RT288x type IO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_TSI(SERIAL_IO_TSI)<span class="comment">/* Tsi108/109 type IO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM32BE(SERIAL_IO_MEM32BE)<span class="comment">/* 32b big endian */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM16(SERIAL_IO_MEM16)<span class="comment">/* 16b little endian */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* quirks must be updated while holding port mutex */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPQ_NO_TXEN_TESTBIT(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>read_status_mask;<span class="comment">/* driver specific */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ignore_status_mask;<span class="comment">/* driver specific */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span>*<span class="title">state</span>;</span><span class="comment">/* pointer to parent state */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_icount</span><span class="title">icount</span>;</span><span class="comment">/* statistics */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console</span>*<span class="title">cons</span>;</span><span class="comment">/* struct console, if any */</span></span><br><span class="line"><span class="comment">/* flags must be updated while holding port mutex */</span></span><br><span class="line"><span class="type">upf_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These flags must be equivalent to the flags defined in</span></span><br><span class="line"><span class="comment"> * include/uapi/linux/tty_flags.h which are the userspace definitions</span></span><br><span class="line"><span class="comment"> * assigned from the serial_struct flags in uart_set_info()</span></span><br><span class="line"><span class="comment"> * [for bit definitions in the UPF_CHANGE_MASK]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Bits [0..UPF_LAST_USER] are userspace defined/visible/changeable</span></span><br><span class="line"><span class="comment"> * The remaining bits are serial-core specific and not modifiable by</span></span><br><span class="line"><span class="comment"> * userspace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_FOURPORT((__force upf_t) ASYNC_FOURPORT       <span class="comment">/* 1  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SAK((__force upf_t) ASYNC_SAK            <span class="comment">/* 2  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_HI((__force upf_t) ASYNC_SPD_HI         <span class="comment">/* 4  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_VHI((__force upf_t) ASYNC_SPD_VHI        <span class="comment">/* 5  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_CUST((__force upf_t) ASYNC_SPD_CUST   <span class="comment">/* 0x0030 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_WARP((__force upf_t) ASYNC_SPD_WARP   <span class="comment">/* 0x1010 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_MASK((__force upf_t) ASYNC_SPD_MASK   <span class="comment">/* 0x1030 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SKIP_TEST((__force upf_t) ASYNC_SKIP_TEST      <span class="comment">/* 6  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_AUTO_IRQ((__force upf_t) ASYNC_AUTO_IRQ       <span class="comment">/* 7  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_HARDPPS_CD((__force upf_t) ASYNC_HARDPPS_CD     <span class="comment">/* 11 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_SHI((__force upf_t) ASYNC_SPD_SHI        <span class="comment">/* 12 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_LOW_LATENCY((__force upf_t) ASYNC_LOW_LATENCY    <span class="comment">/* 13 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_BUGGY_UART((__force upf_t) ASYNC_BUGGY_UART     <span class="comment">/* 14 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_MAGIC_MULTIPLIER((__force upf_t) ASYNC_MAGIC_MULTIPLIER <span class="comment">/* 16 */</span> )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_NO_THRE_TEST((__force upf_t) (1 &lt;&lt; 19))</span></span><br><span class="line"><span class="comment">/* Port has hardware-assisted h/w flow control */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_AUTO_CTS((__force upf_t) (1 &lt;&lt; 20))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_AUTO_RTS((__force upf_t) (1 &lt;&lt; 21))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_HARD_FLOW((__force upf_t) (UPF_AUTO_CTS | UPF_AUTO_RTS))</span></span><br><span class="line"><span class="comment">/* Port has hardware-assisted s/w flow control */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SOFT_FLOW((__force upf_t) (1 &lt;&lt; 22))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_CONS_FLOW((__force upf_t) (1 &lt;&lt; 23))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SHARE_IRQ((__force upf_t) (1 &lt;&lt; 24))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_EXAR_EFR((__force upf_t) (1 &lt;&lt; 25))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_BUG_THRE((__force upf_t) (1 &lt;&lt; 26))</span></span><br><span class="line"><span class="comment">/* The exact UART type is known and should not be probed.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_FIXED_TYPE((__force upf_t) (1 &lt;&lt; 27))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_BOOT_AUTOCONF((__force upf_t) (1 &lt;&lt; 28))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_FIXED_PORT((__force upf_t) (1 &lt;&lt; 29))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_DEAD((__force upf_t) (1 &lt;&lt; 30))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_IOREMAP((__force upf_t) (1 &lt;&lt; 31))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UPF_CHANGE_MASK0x17fff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_CHANGE_MASK((__force upf_t) __UPF_CHANGE_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_USR_MASK((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __UPF_CHANGE_MASK &gt; ASYNC_FLAGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Change mask not equivalent to userspace-visible bit defines</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must hold termios_rwsem, port mutex and port lock to change;</span></span><br><span class="line"><span class="comment"> * can hold any one lock to read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">upstat_t</span>status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_CTS_ENABLE((__force upstat_t) (1 &lt;&lt; 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_DCD_ENABLE((__force upstat_t) (1 &lt;&lt; 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_AUTORTS((__force upstat_t) (1 &lt;&lt; 2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_AUTOCTS((__force upstat_t) (1 &lt;&lt; 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_AUTOXOFF((__force upstat_t) (1 &lt;&lt; 4))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_SYNC_FIFO((__force upstat_t) (1 &lt;&lt; 5))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>hw_stopped;<span class="comment">/* sw-assisted CTS flow state */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>mctrl;<span class="comment">/* current modem ctrl settings */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>timeout;<span class="comment">/* character-based timeout */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>type;<span class="comment">/* port type */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span>*<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>custom_divisor;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>line;<span class="comment">/* port index */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>minor;</span><br><span class="line"><span class="type">resource_size_t</span>mapbase;<span class="comment">/* for ioremap */</span></span><br><span class="line"><span class="type">resource_size_t</span>mapsize;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>*<span class="title">dev</span>;</span><span class="comment">/* parent device */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>sysrq;<span class="comment">/* sysrq timeout */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>sysrq_ch;<span class="comment">/* char for sysrq */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>has_sysrq;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>sysrq_seq;<span class="comment">/* index in sysrq_toggle_seq */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>hub6;<span class="comment">/* this should be in the 8250 driver */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>suspended;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>console_reinit;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;<span class="comment">/* port name */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>*<span class="title">attr_group</span>;</span><span class="comment">/* port specific attributes */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">tty_groups</span>;</span><span class="comment">/* all attributes (serial core use only) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">serial_rs485</span>     <span class="title">rs485</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>*<span class="title">rs485_term_gpio</span>;</span><span class="comment">/* enable RS485 bus termination */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">serial_iso7816</span>   <span class="title">iso7816</span>;</span></span><br><span class="line"><span class="type">void</span>*private_data;<span class="comment">/* generic platform data pointer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="struct-uart-state"><a href="#struct-uart-state" class="headerlink" title="struct uart_state"></a>struct uart_state</h4><p><code>struct uart_state</code> 是一个结构体，定义在 <code>include/linux/serial_core.h</code>，其内部包含一个 <code>tty_port</code> 类型的成员变量，通常用于表示UART 驱动程序的状态信息。通过 <code>uart_driver</code> 结构体中的 state 成员指针，可以访问和操作与UART 设备状态有关的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the state information which is persistent across opens.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span><span class="title">port</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">uart_pm_state</span><span class="title">pm_state</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">circ_buf</span><span class="title">xmit</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span>refcount;</span><br><span class="line"><span class="type">wait_queue_head_t</span>remove_wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span>*<span class="title">uart_port</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="struct-uart-ops"><a href="#struct-uart-ops" class="headerlink" title="struct uart_ops"></a>struct uart_ops</h4><p>结构体 <code>uart_ops</code> 包含了一系列函数指针，这些函数指针定义了对 UART 端口进行操作的接口。每个函数指针对应一个特定的操作，例如发送数据、设置控制信号、启动或停止传输等。</p><p>通过 <code>uart_ops</code> 结构体，上层应用程序或驱动程序可以调用这些函数指针来操作 UART 端口，实现数据传输和控制操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure describes all the operations that can be done on the</span></span><br><span class="line"><span class="comment"> * physical hardware.  See Documentation/driver-api/serial/driver.rst for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span><span class="params">(*tx_empty)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;<span class="comment">// 检查发送缓冲区是否为空的函数指针</span></span><br><span class="line"><span class="type">void</span>(*set_mctrl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> mctrl);<span class="comment">// 设置 modem 控制信号的函数指针</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">int</span><span class="params">(*get_mctrl)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;<span class="comment">// 获取 modem 控制信号的函数指针</span></span><br><span class="line"><span class="type">void</span>(*stop_tx)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 停止发送函数指针</span></span><br><span class="line"><span class="type">void</span>(*start_tx)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 启动发送函数指针</span></span><br><span class="line"><span class="type">void</span>(*throttle)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 限流函数指针</span></span><br><span class="line"><span class="type">void</span>(*unthrottle)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 解除限流函数指针</span></span><br><span class="line"><span class="type">void</span>(*send_xchar)(<span class="keyword">struct</span> uart_port *, <span class="type">char</span> ch);<span class="comment">// 发送特殊字符函数指针</span></span><br><span class="line"><span class="type">void</span>(*stop_rx)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 停止接收函数指针</span></span><br><span class="line"><span class="type">void</span>(*enable_ms)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 启用 RTS/CTS(硬件流控)函数指针</span></span><br><span class="line"><span class="type">void</span>(*break_ctl)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span> ctl);<span class="comment">// 控制发送 BREAK 信号函数指针</span></span><br><span class="line"><span class="type">int</span>(*startup)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 启动函数指针</span></span><br><span class="line"><span class="type">void</span>(*shutdown)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 关闭函数指针</span></span><br><span class="line"><span class="type">void</span>(*flush_buffer)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 刷新缓冲区函数指针</span></span><br><span class="line"><span class="type">void</span>(*set_termios)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> ktermios *new,</span><br><span class="line">       <span class="keyword">struct</span> ktermios *old);<span class="comment">// 设置终端信息函数指针</span></span><br><span class="line"><span class="type">void</span>(*set_ldisc)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> ktermios *);<span class="comment">// 设置行规则函数指针</span></span><br><span class="line"><span class="type">void</span>(*pm)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> state,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> oldstate);<span class="comment">// 电源管理函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return a string describing the type of the port</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*(*type)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 获取端口类型的函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Release IO and memory resources used by the port.</span></span><br><span class="line"><span class="comment"> * This includes iounmap if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span>(*release_port)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 释放端口函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Request IO and memory resources used by the port.</span></span><br><span class="line"><span class="comment"> * This includes iomapping the port if necessary.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>(*request_port)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 请求端口函数指针</span></span><br><span class="line"><span class="type">void</span>(*config_port)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>);<span class="comment">// 配置端口函数指针</span></span><br><span class="line"><span class="type">int</span>(*verify_port)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> serial_struct *);<span class="comment">// 验证端口函数指针</span></span><br><span class="line"><span class="type">int</span>(*ioctl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">// 控制操作函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line"><span class="type">int</span>(*poll_init)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 轮询初始化函数指针</span></span><br><span class="line"><span class="type">void</span>(*poll_put_char)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">char</span>);<span class="comment">// 轮询发送字符函数指针</span></span><br><span class="line"><span class="type">int</span>(*poll_get_char)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 轮询获取字符函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="uart-driver-注册分析"><a href="#uart-driver-注册分析" class="headerlink" title="uart_driver 注册分析"></a>uart_driver 注册分析</h3><p><code>drivers/tty/serial/8250/8250_core.c</code> 文件中的函数主要是与 8250 系列 UART 驱动程序的核心功能相关的。这个文件实现了 8250 这种串行通信设备的核心操作，包括初始化、配置、中断处理、数据传输等功能。</p><h4 id="serial8250-init"><a href="#serial8250-init" class="headerlink" title="serial8250_init()"></a>serial8250_init()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">serial8250_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_uarts == <span class="number">0</span>)<span class="comment">// 检查是否有 UART 端口被定义，如果没有则返回-ENODEV 错误</span></span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 8250/16550 串口</span></span><br><span class="line">serial8250_isa_init_ports();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印串口驱动信息，包括端口数量和 IRQ 共享状态</span></span><br><span class="line">pr_info(<span class="string">&quot;Serial: 8250/16550 driver, %d ports, IRQ sharing %sabled\n&quot;</span>,</span><br><span class="line">nr_uarts, share_irqs ? <span class="string">&quot;en&quot;</span> : <span class="string">&quot;dis&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARC</span></span><br><span class="line">    <span class="comment">// 如果是 SPARC 架构，注册串口设备的次设备号</span></span><br><span class="line">ret = sunserial_register_minors(&amp;serial8250_reg, UART_NR);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 否则，在当前平台上注册 UART 驱动程序</span></span><br><span class="line">serial8250_reg.nr = UART_NR;</span><br><span class="line">ret = uart_register_driver(&amp;serial8250_reg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">ret = serial8250_pnp_init();<span class="comment">// 初始化 PNP 设备（如果存在）</span></span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> unreg_uart_drv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 ISA 平台设备结构体并注册</span></span><br><span class="line">serial8250_isa_devs = platform_device_alloc(<span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">    PLAT8250_DEV_LEGACY);</span><br><span class="line"><span class="keyword">if</span> (!serial8250_isa_devs) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> unreg_pnp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将平台设备添加到系统</span></span><br><span class="line">ret = platform_device_add(serial8250_isa_devs);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> put_dev;</span><br><span class="line"><span class="comment">// 注册串口端口</span></span><br><span class="line">serial8250_register_ports(&amp;serial8250_reg, &amp;serial8250_isa_devs-&gt;dev);</span><br><span class="line"><span class="comment">// 注册平台驱动程序</span></span><br><span class="line">ret = platform_driver_register(&amp;serial8250_isa_driver);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">// 如果注册失败，删除已添加的 ISA 平台设备</span></span><br><span class="line">platform_device_del(serial8250_isa_devs);</span><br><span class="line">put_dev:</span><br><span class="line">platform_device_put(serial8250_isa_devs);</span><br><span class="line">unreg_pnp:</span><br><span class="line">serial8250_pnp_exit();<span class="comment">// 退出时释放 PNP 设备</span></span><br><span class="line">unreg_uart_drv:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARC</span></span><br><span class="line">sunserial_unregister_minors(&amp;serial8250_reg, UART_NR);<span class="comment">// 如果是 SPARC 架构，注销串口设备的次设备号</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">uart_unregister_driver(&amp;serial8250_reg);<span class="comment">// 否则，在当前平台上注销 UART 驱动程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> ret;<span class="comment">// 返回初始化结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化8250串口"><a href="#初始化8250串口" class="headerlink" title="初始化8250串口"></a>初始化8250串口</h4><h5 id="serial8250-isa-init-ports"><a href="#serial8250-isa-init-ports" class="headerlink" title="serial8250_isa_init_ports()"></a>serial8250_isa_init_ports()</h5><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动，其中第 10 行的 <code>serial8250_isa_init_ports()</code>;函数初始化 8250 串口，函数如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">serial8250_isa_init_ports</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> *<span class="title">up</span>;</span><span class="comment">// UART 8250 端口结构体指针</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;<span class="comment">// 静态变量，用于标记是否首次初始化</span></span><br><span class="line"><span class="type">int</span> i, irqflag = <span class="number">0</span>;<span class="comment">// 循环变量和 IRQ 标志位初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!first)<span class="comment">// 如果不是首次初始化，则直接返回，避免重复初始化</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">first = <span class="number">0</span>;<span class="comment">// 标记为不是首次初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果系统定义的 UART 端口数量大于硬件支持的最大数量，将其限制为最大支持数量</span></span><br><span class="line"><span class="keyword">if</span> (nr_uarts &gt; UART_NR)</span><br><span class="line">nr_uarts = UART_NR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有定义的 UART 端口数量，初始化每个端口</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> *<span class="title">up</span> =</span> &amp;serial8250_ports[i];<span class="comment">// 获取第 i 个 UART 端口结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;up-&gt;port;<span class="comment">// 获取端口的通用 UART 端口结构体</span></span><br><span class="line"></span><br><span class="line">port-&gt;line = i;<span class="comment">// 设置 UART 端口的逻辑线号</span></span><br><span class="line">serial8250_init_port(up);<span class="comment">// 初始化 UART 端口</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 base_ops 尚未设置，则使用当前端口的操作函数作为基本操作函数</span></span><br><span class="line"><span class="keyword">if</span> (!base_ops)</span><br><span class="line">base_ops = port-&gt;ops;</span><br><span class="line">port-&gt;ops = &amp;univ8250_port_ops;<span class="comment">// 设置 UART 端口的操作函数为 univ8250_port_ops</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化定时器</span></span><br><span class="line">timer_setup(&amp;up-&gt;timer, serial8250_timeout, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 UART 端口的驱动操作函数为 univ8250_driver_ops</span></span><br><span class="line">up-&gt;ops = &amp;univ8250_driver_ops;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ALPHA_KLUDGE_MCR needs to be killed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">up-&gt;mcr_mask = ~ALPHA_KLUDGE_MCR;<span class="comment">// 设置 UART 端口的 MCR 屏蔽位，屏蔽ALPHA_KLUDGE_MCR</span></span><br><span class="line">up-&gt;mcr_force = ALPHA_KLUDGE_MCR;<span class="comment">// 设置 UART 端口的 MCR 强制位，设置为ALPHA_KLUDGE_MCR</span></span><br><span class="line">serial8250_set_defaults(up);<span class="comment">// 设置 UART 端口的默认参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* chain base port ops to support Remote Supervisor Adapter */</span></span><br><span class="line">univ8250_port_ops = *base_ops;<span class="comment">// 将基本端口操作链到支持远程监控适配器（RSA）</span></span><br><span class="line">univ8250_rsa_support(&amp;univ8250_port_ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了共享 IRQ 标志，设置 IRQ 标志位</span></span><br><span class="line"><span class="keyword">if</span> (share_irqs)</span><br><span class="line">irqflag = IRQF_SHARED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历旧的串口端口数组，初始化对应的 UART 端口</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, up = serial8250_ports;</span><br><span class="line">     i &lt; ARRAY_SIZE(old_serial_port) &amp;&amp; i &lt; nr_uarts;</span><br><span class="line">     i++, up++) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;up-&gt;port;</span><br><span class="line"><span class="comment">// 设置 UART 端口的 IO 基地址、IRQ、IRQ 标志、时钟频率、标志、hub6 等参数</span></span><br><span class="line">port-&gt;iobase   = old_serial_port[i].port;</span><br><span class="line">port-&gt;irq      = irq_canonicalize(old_serial_port[i].irq);<span class="comment">// 规范化 IRQ</span></span><br><span class="line">port-&gt;irqflags = <span class="number">0</span>;</span><br><span class="line">port-&gt;uartclk  = old_serial_port[i].baud_base * <span class="number">16</span>;<span class="comment">// 设置 UART 时钟频率</span></span><br><span class="line">port-&gt;flags    = old_serial_port[i].flags;<span class="comment">// 设置 UART 端口标志</span></span><br><span class="line">port-&gt;hub6     = <span class="number">0</span>;</span><br><span class="line">port-&gt;membase  = old_serial_port[i].iomem_base;</span><br><span class="line">port-&gt;iotype   = old_serial_port[i].io_type;</span><br><span class="line">port-&gt;regshift = old_serial_port[i].iomem_reg_shift;</span><br><span class="line"></span><br><span class="line">port-&gt;irqflags |= irqflag;<span class="comment">// 设置 IRQ 标志位</span></span><br><span class="line">        <span class="comment">// 如果定义了 ISA 配置函数，调用配置函数进行额外的配置</span></span><br><span class="line"><span class="keyword">if</span> (serial8250_isa_config != <span class="literal">NULL</span>)</span><br><span class="line">serial8250_isa_config(i, &amp;up-&gt;port, &amp;up-&gt;capabilities);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="serial8250-init-port"><a href="#serial8250-init-port" class="headerlink" title="serial8250_init_port()"></a>serial8250_init_port()</h5><p>在上面的第 21 行代码执行了 <code>serial8250_init_port</code> 函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 初始化 UART 8250 端口的函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serial8250_init_port</span><span class="params">(<span class="keyword">struct</span> uart_8250_port *up)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;up-&gt;port;<span class="comment">// 获取 UART 8250 端口结构体</span></span><br><span class="line"></span><br><span class="line">spin_lock_init(&amp;port-&gt;lock);<span class="comment">// 初始化端口锁</span></span><br><span class="line">port-&gt;pm = <span class="literal">NULL</span>;</span><br><span class="line">port-&gt;ops = &amp;serial8250_pops;<span class="comment">// 设置端口操作函数为 serial8250_pops</span></span><br><span class="line">port-&gt;has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);</span><br><span class="line"></span><br><span class="line">up-&gt;cur_iotype = <span class="number">0xFF</span>;<span class="comment">// 设置当前端口的 IO 类型为 0xFF</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(serial8250_init_port);</span><br></pre></td></tr></table></figure><p><code>serial8250_pop</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> <span class="title">serial8250_pops</span> =</span> &#123;</span><br><span class="line">.tx_empty= serial8250_tx_empty,<span class="comment">// 传输缓冲区是否为空</span></span><br><span class="line">.set_mctrl= serial8250_set_mctrl, <span class="comment">// 设置控制信号</span></span><br><span class="line">.get_mctrl= serial8250_get_mctrl, <span class="comment">// 获取控制信号</span></span><br><span class="line">.stop_tx= serial8250_stop_tx,<span class="comment">// 停止发送</span></span><br><span class="line">.start_tx= serial8250_start_tx,<span class="comment">// 启动发送</span></span><br><span class="line">.throttle= serial8250_throttle,<span class="comment">// 限流</span></span><br><span class="line">.unthrottle= serial8250_unthrottle,<span class="comment">// 解除限流</span></span><br><span class="line">.stop_rx= serial8250_stop_rx,<span class="comment">// 停止接收</span></span><br><span class="line">.enable_ms= serial8250_enable_ms, <span class="comment">// 启用 RTS/CTS</span></span><br><span class="line">.break_ctl= serial8250_break_ctl,<span class="comment">// 控制发送 BREAK 信号</span></span><br><span class="line">.startup= serial8250_startup,<span class="comment">// 启动</span></span><br><span class="line">.shutdown= serial8250_shutdown, <span class="comment">// 关闭</span></span><br><span class="line">.flush_buffer= serial8250_flush_buffer,</span><br><span class="line">.set_termios= serial8250_set_termios,</span><br><span class="line">.set_ldisc= serial8250_set_ldisc,<span class="comment">// 设置终端参数</span></span><br><span class="line">.pm= serial8250_pm, <span class="comment">// 电源管理</span></span><br><span class="line">.type= serial8250_type, <span class="comment">// 返回端口类型的字符串</span></span><br><span class="line">.release_port= serial8250_release_port,<span class="comment">// 释放端口资源</span></span><br><span class="line">.request_port= serial8250_request_port,<span class="comment">// 请求端口资源</span></span><br><span class="line">.config_port= serial8250_config_port,<span class="comment">// 配置端口</span></span><br><span class="line">.verify_port= serial8250_verify_port,<span class="comment">// 验证端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">.poll_get_char = serial8250_get_poll_char,<span class="comment">// 获取字符（用于轮询）</span></span><br><span class="line">.poll_put_char = serial8250_put_poll_char,<span class="comment">// 发送字符（用于轮询</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="注册-UART-驱动程序"><a href="#注册-UART-驱动程序" class="headerlink" title="注册 UART 驱动程序"></a>注册 UART 驱动程序</h4><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动，其中的 <code>uart_register_driver(&amp;serial8250_reg)</code>，通过 <code>uart_register_driver</code> 函数向系统注册这个 uart_driver，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *uart)</span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下所示：</p><ul><li><strong>uart</strong>：要注册的 uart_driver。</li><li><strong>返回值</strong>：0，成功；负值，失败。</li></ul><p>注销驱动的时候也需要注销掉前面注册的 <code>uart_driver</code>，需要用到 <code>uart_unregister_driver</code>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_unregister_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *uart)</span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下所示：</p><ul><li><strong>uart</strong>：要注销的 uart_driver。</li><li><strong>返回值</strong>：无</li></ul><p><code>serial8250_init(void)</code>函数中 <code>uart_register_driver</code> 函数传入的参数是 <code>serial8250_reg</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> <span class="title">serial8250_reg</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,<span class="comment">// 模块的所有者</span></span><br><span class="line">.driver_name= <span class="string">&quot;serial&quot;</span>,<span class="comment">// 驱动程序名称</span></span><br><span class="line">.dev_name= <span class="string">&quot;ttyS&quot;</span>,<span class="comment">// 设备名称</span></span><br><span class="line">.major= TTY_MAJOR,<span class="comment">// 主设备号</span></span><br><span class="line">.minor= <span class="number">64</span>,<span class="comment">// 次设备号</span></span><br><span class="line">.cons= SERIAL8250_CONSOLE,<span class="comment">// 控制台</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="uart-register-driver"><a href="#uart-register-driver" class="headerlink" title="uart_register_driver()"></a>uart_register_driver()</h5><p><code>uart_register_driver</code> 函数内容如下所示，定义在在源码 <code>drivers/tty/serial/serial_core.c</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *uart_register_driver - register a driver with the uart core layer</span></span><br><span class="line"><span class="comment"> *@drv: low level driver structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Register a uart driver with the core driver.  We in turn register</span></span><br><span class="line"><span class="comment"> *with the tty layer, and initialise the core driver per-port state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *We have a proc file in /proc/tty/driver which is named after the</span></span><br><span class="line"><span class="comment"> *normal driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *drv-&gt;port should be NULL, and the per-port structures should be</span></span><br><span class="line"><span class="comment"> *registered using uart_add_one_port after this call has succeeded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">normal</span>;</span></span><br><span class="line"><span class="type">int</span> i, retval = -ENOMEM;</span><br><span class="line"></span><br><span class="line">BUG_ON(drv-&gt;state);<span class="comment">// 检查驱动状态是否已被占用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Maybe we should be using a slab cache for this, especially if</span></span><br><span class="line"><span class="comment"> * we have a large number of ports to handle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">drv-&gt;state = kcalloc(drv-&gt;nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> uart_state), GFP_KERNEL);<span class="comment">// 为 UART 状态分配内存空间</span></span><br><span class="line"><span class="keyword">if</span> (!drv-&gt;state)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 tty 驱动器</span></span><br><span class="line">normal = alloc_tty_driver(drv-&gt;nr);</span><br><span class="line"><span class="keyword">if</span> (!normal)</span><br><span class="line"><span class="keyword">goto</span> out_kfree;</span><br><span class="line"></span><br><span class="line">drv-&gt;tty_driver = normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 tty 驱动器的属性</span></span><br><span class="line">normal-&gt;driver_name= drv-&gt;driver_name;</span><br><span class="line">normal-&gt;name= drv-&gt;dev_name;</span><br><span class="line">normal-&gt;major= drv-&gt;major;</span><br><span class="line">normal-&gt;minor_start= drv-&gt;minor;</span><br><span class="line">normal-&gt;type= TTY_DRIVER_TYPE_SERIAL;</span><br><span class="line">normal-&gt;subtype= SERIAL_TYPE_NORMAL;</span><br><span class="line">normal-&gt;init_termios= tty_std_termios;</span><br><span class="line">normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">normal-&gt;init_termios.c_ispeed = normal-&gt;init_termios.c_ospeed = <span class="number">9600</span>;</span><br><span class="line">normal-&gt;flags= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</span><br><span class="line">normal-&gt;driver_state    = drv;</span><br><span class="line">tty_set_operations(normal, &amp;uart_ops);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Initialise the UART state(s).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; drv-&gt;nr; i++) &#123;<span class="comment">// 遍历每个 UART 状态并初始化对应的 tty 端口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> drv-&gt;state + i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> =</span> &amp;state-&gt;port;</span><br><span class="line"></span><br><span class="line">tty_port_init(port);</span><br><span class="line">port-&gt;ops = &amp;uart_port_ops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retval = tty_register_driver(normal);<span class="comment">// 注册 tty 驱动器</span></span><br><span class="line"><span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册失败时，销毁已初始化的 tty 端口并释放内存</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; drv-&gt;nr; i++)</span><br><span class="line">tty_port_destroy(&amp;drv-&gt;state[i].port);</span><br><span class="line">put_tty_driver(normal);</span><br><span class="line">out_kfree:</span><br><span class="line">kfree(drv-&gt;state);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>uart_register_driver</code> 函数中的第 48 行代码设置 tty 驱动器的操作函数，这些操作函数定义了与特定设备相关的操作，如读写、控制等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">uart_ops</span> =</span> &#123;</span><br><span class="line">.install= uart_install,<span class="comment">// 安装 tty 设备</span></span><br><span class="line">.open= uart_open,<span class="comment">// 打开 tty 设备</span></span><br><span class="line">.close= uart_close,<span class="comment">// 关闭 tty 设备</span></span><br><span class="line">.write= uart_write,<span class="comment">// 写入数据到 tty 设备</span></span><br><span class="line">.put_char= uart_put_char,<span class="comment">// 将字符写入 tty 设备输出缓冲区</span></span><br><span class="line">.flush_chars= uart_flush_chars,<span class="comment">// 刷新 tty 设备输出缓冲区</span></span><br><span class="line">.write_room= uart_write_room,<span class="comment">// 获取 tty 设备输出缓冲区剩余空间大小</span></span><br><span class="line">.chars_in_buffer= uart_chars_in_buffer, <span class="comment">// 获取 tty 设备输入缓冲区中的字符数量</span></span><br><span class="line">.flush_buffer= uart_flush_buffer,<span class="comment">// 刷新 tty 设备输入缓冲区</span></span><br><span class="line">.ioctl= uart_ioctl,<span class="comment">// 控制 tty 设备的操作</span></span><br><span class="line">.throttle= uart_throttle,<span class="comment">// 控制 tty 设备的流控状态</span></span><br><span class="line">.unthrottle= uart_unthrottle,<span class="comment">// 控制 tty 设备的流控状态</span></span><br><span class="line">.send_xchar= uart_send_xchar,<span class="comment">// 发送特殊字符到 tty 设备</span></span><br><span class="line">.set_termios= uart_set_termios,<span class="comment">// 设置 tty 设备的终端参数</span></span><br><span class="line">.set_ldisc= uart_set_ldisc,<span class="comment">// 设置 tty 设备的行规则</span></span><br><span class="line">.stop= uart_stop,<span class="comment">// 停止 tty 设备</span></span><br><span class="line">.start= uart_start,<span class="comment">// 启动 tty 设备</span></span><br><span class="line">.hangup= uart_hangup,<span class="comment">// 关闭 tty 设备的连接</span></span><br><span class="line">.break_ctl= uart_break_ctl,<span class="comment">// 控制 tty 设备的发送中断</span></span><br><span class="line">.wait_until_sent= uart_wait_until_sent,<span class="comment">// 等待 tty 设备发送完所有数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">.proc_show= uart_proc_show,<span class="comment">// 显示与 uart 相关的 proc 文件系统信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.tiocmget= uart_tiocmget,<span class="comment">// 获取 tty 设备的 modem 状态</span></span><br><span class="line">.tiocmset= uart_tiocmset,<span class="comment">// 设置 tty 设备的 modem 状态</span></span><br><span class="line">.set_serial= uart_set_info_user,</span><br><span class="line">.get_serial= uart_get_info_user,</span><br><span class="line">.get_icount= uart_get_icount,<span class="comment">// 获取 tty 设备的计数信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">.poll_init= uart_poll_init,<span class="comment">// 初始化 tty 设备的轮询模式</span></span><br><span class="line">.poll_get_char= uart_poll_get_char,<span class="comment">// 从 tty 设备获取字符（轮询模式）</span></span><br><span class="line">.poll_put_char= uart_poll_put_char,<span class="comment">// 将字符写入 tty 设备（轮询模式）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>uart_register_driver</code> 函 数 中 的 第 61 行 代 码调用 <code>tty_register_driver</code> 函 数 如 下 所 示 ， 定 义 在<code>drivers/tty/tty_io.c</code></p><h5 id="tty-register-dirver"><a href="#tty-register-dirver" class="headerlink" title="tty_register_dirver()"></a>tty_register_dirver()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called by a tty driver to register itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 tty 驱动程序调用此函数以注册自身时被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_register_driver</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">dev_t</span> dev;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">d</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!driver-&gt;major) &#123;<span class="comment">// 如果驱动程序没有指定主设备号，则分配一个</span></span><br><span class="line">error = alloc_chrdev_region(&amp;dev, driver-&gt;minor_start,</span><br><span class="line">driver-&gt;num, driver-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line">driver-&gt;major = MAJOR(dev);</span><br><span class="line">driver-&gt;minor_start = MINOR(dev);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dev = MKDEV(driver-&gt;major, driver-&gt;minor_start);</span><br><span class="line">error = register_chrdev_region(dev, driver-&gt;num, driver-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"><span class="comment">// 如果驱动标志为 TTY_DRIVER_DYNAMIC_ALLOC，则动态添加 tty 字符设备</span></span><br><span class="line"><span class="keyword">if</span> (driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_ALLOC) &#123;</span><br><span class="line">error = tty_cdev_add(driver, dev, <span class="number">0</span>, driver-&gt;num);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err_unreg_char;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;tty_mutex);</span><br><span class="line">    <span class="comment">// 将驱动程序添加到 tty 驱动程序列表中</span></span><br><span class="line">list_add(&amp;driver-&gt;tty_drivers, &amp;tty_drivers);</span><br><span class="line">mutex_unlock(&amp;tty_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果驱动标志没有设置为 TTY_DRIVER_DYNAMIC_DEV，则注册 tty 设备</span></span><br><span class="line"><span class="keyword">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_DEV)) &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; driver-&gt;num; i++) &#123;</span><br><span class="line">d = tty_register_device(driver, i, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(d)) &#123;</span><br><span class="line">error = PTR_ERR(d);</span><br><span class="line"><span class="keyword">goto</span> err_unreg_devs;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 注册 TTY 驱动程序到 proc 文件系统</span></span><br><span class="line">proc_tty_register_driver(driver);</span><br><span class="line">driver-&gt;flags |= TTY_DRIVER_INSTALLED;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_unreg_devs:</span><br><span class="line">    <span class="comment">// 注销已注册的 tty 设备</span></span><br><span class="line"><span class="keyword">for</span> (i--; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">tty_unregister_device(driver, i);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;tty_mutex);</span><br><span class="line">    <span class="comment">// 从 tty 驱动程序列表中移除驱动程序</span></span><br><span class="line">list_del(&amp;driver-&gt;tty_drivers);</span><br><span class="line">mutex_unlock(&amp;tty_mutex);</span><br><span class="line"></span><br><span class="line">err_unreg_char:</span><br><span class="line">unregister_chrdev_region(dev, driver-&gt;num);<span class="comment">// 注销已注册的字符设备</span></span><br><span class="line">err:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tty_register_driver);</span><br></pre></td></tr></table></figure><h4 id="分配平台设备结构体并注册"><a href="#分配平台设备结构体并注册" class="headerlink" title="分配平台设备结构体并注册"></a>分配平台设备结构体并注册</h4><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 分配 ISA 平台设备结构体并注册</span></span><br><span class="line">serial8250_isa_devs = platform_device_alloc(<span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">    PLAT8250_DEV_LEGACY);</span><br><span class="line"><span class="keyword">if</span> (!serial8250_isa_devs) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> unreg_pnp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将平台设备添加到系统</span></span><br><span class="line">ret = platform_device_add(serial8250_isa_devs);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> put_dev;</span><br></pre></td></tr></table></figure><p><code>platform_device_alloc</code> 函数用于<strong>分配一个平台设备结构体，但不会将其注册到平台总线上</strong>。返回的结构体可以在之后使用函数 <code>platform_device_add()</code>来将其注册到平台总线上。</p><h4 id="注册串口端口"><a href="#注册串口端口" class="headerlink" title="注册串口端口"></a>注册串口端口</h4><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动，其中第 42 行代码，如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册串口端口</span></span><br><span class="line">serial8250_register_ports(&amp;serial8250_reg, &amp;serial8250_isa_devs-&gt;dev);</span><br></pre></td></tr></table></figure><h5 id="serial8250-register-ports"><a href="#serial8250-register-ports" class="headerlink" title="serial8250_register_ports()"></a>serial8250_register_ports()</h5><p><code>serial8250_register_ports</code> 函数内容如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">serial8250_register_ports</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv, <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++) &#123;<span class="comment">// 遍历所有串口</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> *<span class="title">up</span> =</span> &amp;serial8250_ports[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (up-&gt;port.type == PORT_8250_CIR)<span class="comment">// 如果是 CIR 端口，则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (up-&gt;port.dev)<span class="comment">// 如果端口已经分配了设备，则跳过</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">up-&gt;port.dev = dev;<span class="comment">// 将设备指针与端口关联起来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (uart_console_enabled(&amp;up-&gt;port))</span><br><span class="line">pm_runtime_get_sync(up-&gt;port.dev);</span><br><span class="line"></span><br><span class="line">serial8250_apply_quirks(up);<span class="comment">// 应用串口 8250 的特殊处理</span></span><br><span class="line">uart_add_one_port(drv, &amp;up-&gt;port);<span class="comment">// 向 UART 驱动注册一个串口</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册-platform-driver-驱动"><a href="#注册-platform-driver-驱动" class="headerlink" title="注册 platform_driver 驱动"></a>注册 platform_driver 驱动</h4><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动，其中第 44 行代码，如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册平台驱动程序</span></span><br><span class="line">ret = platform_driver_register(&amp;serial8250_isa_driver);</span><br></pre></td></tr></table></figure><h2 id="端口注册流程分析"><a href="#端口注册流程分析" class="headerlink" title="端口注册流程分析"></a>端口注册流程分析</h2><p>迅为提供的 SDK 源码设备树中默认打开了串口 9，打开<code>arch/arm64/boot/dts/rockchip/rk3568.dtsi</code> 设备树文件，串口 9 控制器的设备树节点如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">uart9:</span> <span class="title class_">serial@fe6d0000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-uart&quot;</span>, <span class="string">&quot;snps,dw-apb-uart&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe6d0000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">125</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> SCLK_UART9&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_UART9&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;baudclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-shift</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg-io-width</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">dmas</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">18</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">19</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;uart9m0_xfer</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第 2 行 compatible 属性值为<code>snps,dw-apb-uart</code>。在 Linux 源码中搜索这个值即可找到对应的 UART 驱动文件，此文件为 <code>drivers/tty/serial/8250/8250_dw.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">dw8250_platform_driver</span> =</span> &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name= <span class="string">&quot;dw-apb-uart&quot;</span>,</span><br><span class="line">.pm= &amp;dw8250_pm_ops,</span><br><span class="line">.of_match_table= dw8250_of_match,</span><br><span class="line">.acpi_match_table = dw8250_acpi_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe= dw8250_probe,</span><br><span class="line">.remove= dw8250_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(dw8250_platform_driver);</span><br></pre></td></tr></table></figure><p>可以看出瑞芯微的 UART 本质上是一个 platform 驱动，当节点匹配成功之后，执行<code>dw_probe</code> 函数，函数内容如下所示：</p><h3 id="dw-probe"><a href="#dw-probe" class="headerlink" title="dw_probe()"></a>dw_probe()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dw8250_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> <span class="title">uart</span> =</span> &#123;&#125;, *up = &amp;uart;<span class="comment">// 初始化一个 uart_8250_port 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">regs</span> =</span> platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);<span class="comment">// 获取设备资源信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">p</span> =</span> &amp;up-&gt;port;<span class="comment">// 获取 uart_port 指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;<span class="comment">// 获取设备指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dw8250_data</span> *<span class="title">data</span>;</span> <span class="comment">// 定义 dw8250_data 结构体指针</span></span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line">u32 val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否获取到了设备资源信息</span></span><br><span class="line"><span class="keyword">if</span> (!regs) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;no registers defined\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (irq &lt; <span class="number">0</span>)<span class="comment">// 检查是否获取到了中断号</span></span><br><span class="line"><span class="keyword">return</span> irq;</span><br><span class="line"></span><br><span class="line">spin_lock_init(&amp;p-&gt;lock); <span class="comment">// 初始化锁</span></span><br><span class="line">p-&gt;mapbase= regs-&gt;start;<span class="comment">// 设置设备的物理地址</span></span><br><span class="line">p-&gt;irq= irq;<span class="comment">// 设置设备的中断号</span></span><br><span class="line">p-&gt;handle_irq= dw8250_handle_irq;<span class="comment">// 设置中断处理函数</span></span><br><span class="line">p-&gt;pm= dw8250_do_pm; <span class="comment">// 设置设备的电源管理函数</span></span><br><span class="line">p-&gt;type= PORT_8250; <span class="comment">// 设置设备类型</span></span><br><span class="line">p-&gt;flags= UPF_SHARE_IRQ | UPF_FIXED_PORT;<span class="comment">// 设置设备标志</span></span><br><span class="line">p-&gt;dev= dev;<span class="comment">// 设置设备指针</span></span><br><span class="line">p-&gt;iotype= UPIO_MEM; <span class="comment">// 设置 IO 类型</span></span><br><span class="line">p-&gt;serial_in= dw8250_serial_in;<span class="comment">// 设置读函数</span></span><br><span class="line">p-&gt;serial_out= dw8250_serial_out;<span class="comment">// 设置写函数</span></span><br><span class="line">p-&gt;set_ldisc= dw8250_set_ldisc; <span class="comment">// 设置行规则函数</span></span><br><span class="line">p-&gt;set_termios= dw8250_set_termios;<span class="comment">// 设置终端参数函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将设备的物理地址映射到内存空间</span></span><br><span class="line">p-&gt;membase = devm_ioremap(dev, regs-&gt;start, resource_size(regs));</span><br><span class="line"><span class="keyword">if</span> (!p-&gt;membase)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 dw8250_data 结构体内存空间</span></span><br><span class="line">data = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*data), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!data)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">data-&gt;data.dma.fn = dw8250_fallback_dma_filter;<span class="comment">// 设置 DMA 函数指针</span></span><br><span class="line">data-&gt;usr_reg = DW_UART_USR;<span class="comment">// 设置 UART 状态寄存器地址</span></span><br><span class="line">p-&gt;private_data = &amp;data-&gt;data;<span class="comment">// 设置设备的私有数据指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取设备属性&quot;snps,uart-16550-compatible&quot;，判断是否兼容 16550</span></span><br><span class="line">data-&gt;uart_16550_compatible = device_property_read_bool(dev,</span><br><span class="line"><span class="string">&quot;snps,uart-16550-compatible&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取设备属性&quot;reg-shift&quot;，获取地址偏移值</span></span><br><span class="line">err = device_property_read_u32(dev, <span class="string">&quot;reg-shift&quot;</span>, &amp;val);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">p-&gt;regshift = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取设备属性&quot;reg-io-width&quot;，获取 IO 宽度</span></span><br><span class="line">err = device_property_read_u32(dev, <span class="string">&quot;reg-io-width&quot;</span>, &amp;val);</span><br><span class="line"><span class="keyword">if</span> (!err &amp;&amp; val == <span class="number">4</span>) &#123;</span><br><span class="line">p-&gt;iotype = UPIO_MEM32;<span class="comment">// 设置 IO 类型为 32 位</span></span><br><span class="line">p-&gt;serial_in = dw8250_serial_in32;<span class="comment">// 设置读函数为 32 位</span></span><br><span class="line">p-&gt;serial_out = dw8250_serial_out32;<span class="comment">// 设置写函数为 32 位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性&quot;dcd-override&quot;存在，则始终将 DCD 状态设置为活动状态</span></span><br><span class="line"><span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;dcd-override&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">/* Always report DCD as active */</span></span><br><span class="line">data-&gt;msr_mask_on |= UART_MSR_DCD;</span><br><span class="line">data-&gt;msr_mask_off |= UART_MSR_DDCD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性&quot;dsr-override&quot;存在，则始终将 DSR 状态设置为活动状态</span></span><br><span class="line"><span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;dsr-override&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">/* Always report DSR as active */</span></span><br><span class="line">data-&gt;msr_mask_on |= UART_MSR_DSR;</span><br><span class="line">data-&gt;msr_mask_off |= UART_MSR_DDSR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性&quot;cts-override&quot;存在，则始终将 CTS 状态设置为活动状态</span></span><br><span class="line"><span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;cts-override&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">/* Always report CTS as active */</span></span><br><span class="line">data-&gt;msr_mask_on |= UART_MSR_CTS;</span><br><span class="line">data-&gt;msr_mask_off |= UART_MSR_DCTS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性&quot;ri-override&quot;存在，则始终将 RI 状态设置为非活动状态</span></span><br><span class="line"><span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;ri-override&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">/* Always report Ring indicator as inactive */</span></span><br><span class="line">data-&gt;msr_mask_off |= UART_MSR_RI;</span><br><span class="line">data-&gt;msr_mask_off |= UART_MSR_TERI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Always ask for fixed clock rate from a property. */</span></span><br><span class="line">    <span class="comment">// 读取属性&quot;clock-frequency&quot;，获取时钟频率</span></span><br><span class="line">device_property_read_u32(dev, <span class="string">&quot;clock-frequency&quot;</span>, &amp;p-&gt;uartclk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If there is separate baudclk, get the rate from it. */</span></span><br><span class="line">data-&gt;clk = devm_clk_get_optional(dev, <span class="string">&quot;baudclk&quot;</span>);<span class="comment">// 如果存在&quot;baudclk&quot;时钟，则从中获取时钟频率</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;clk == <span class="literal">NULL</span>)<span class="comment">// 如果没有定义时钟频率，则失败</span></span><br><span class="line">data-&gt;clk = devm_clk_get_optional(dev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(data-&gt;clk))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(data-&gt;clk);</span><br><span class="line"></span><br><span class="line">INIT_WORK(&amp;data-&gt;clk_work, dw8250_clk_work_cb);</span><br><span class="line">data-&gt;clk_notifier.notifier_call = dw8250_clk_notifier_cb;</span><br><span class="line"></span><br><span class="line">err = clk_prepare_enable(data-&gt;clk);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">dev_warn(dev, <span class="string">&quot;could not enable optional baudclk: %d\n&quot;</span>, err);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data-&gt;clk)</span><br><span class="line">p-&gt;uartclk = clk_get_rate(data-&gt;clk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If no clock rate is defined, fail. */</span></span><br><span class="line"><span class="keyword">if</span> (!p-&gt;uartclk) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;clock rate not defined\n&quot;</span>);</span><br><span class="line">err = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data-&gt;pclk = devm_clk_get_optional(dev, <span class="string">&quot;apb_pclk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(data-&gt;pclk)) &#123;</span><br><span class="line">err = PTR_ERR(data-&gt;pclk);</span><br><span class="line"><span class="keyword">goto</span> err_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = clk_prepare_enable(data-&gt;pclk);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">dev_err(dev, <span class="string">&quot;could not enable apb_pclk\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_clk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data-&gt;rst = devm_reset_control_get_optional_exclusive(dev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(data-&gt;rst)) &#123;</span><br><span class="line">err = PTR_ERR(data-&gt;rst);</span><br><span class="line"><span class="keyword">goto</span> err_pclk;</span><br><span class="line">&#125;</span><br><span class="line">reset_control_deassert(data-&gt;rst);</span><br><span class="line"><span class="comment">// 应用特定的 quirks</span></span><br><span class="line">dw8250_quirks(p, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the Busy Functionality is not implemented, don&#x27;t handle it */</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;uart_16550_compatible)<span class="comment">// 如果设备不兼容 16550，则不处理忙标志</span></span><br><span class="line">p-&gt;handle_irq = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!data-&gt;skip_autocfg)<span class="comment">// 如果不跳过自动配置，则进行端口配置</span></span><br><span class="line">dw8250_setup_port(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we have a valid fifosize, try hooking up DMA */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;fifosize) &#123;<span class="comment">// 如果有有效的 FIFO 大小，则尝试连接 DMA</span></span><br><span class="line">data-&gt;data.dma.rxconf.src_maxburst = p-&gt;fifosize / <span class="number">4</span>;</span><br><span class="line">data-&gt;data.dma.txconf.dst_maxburst = p-&gt;fifosize / <span class="number">4</span>;</span><br><span class="line">up-&gt;dma = &amp;data-&gt;data.dma;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 8250 端口</span></span><br><span class="line">data-&gt;data.line = serial8250_register_8250_port(up);</span><br><span class="line"><span class="keyword">if</span> (data-&gt;data.line &lt; <span class="number">0</span>) &#123;</span><br><span class="line">err = data-&gt;data.line;</span><br><span class="line"><span class="keyword">goto</span> err_reset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Some platforms may provide a reference clock shared between several</span></span><br><span class="line"><span class="comment"> * devices. In this case any clock state change must be known to the</span></span><br><span class="line"><span class="comment"> * UART port at least post factum.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (data-&gt;clk) &#123;</span><br><span class="line">err = clk_notifier_register(data-&gt;clk, &amp;data-&gt;clk_notifier);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">dev_warn(p-&gt;dev, <span class="string">&quot;Failed to set the clock notifier\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">queue_work(system_unbound_wq, &amp;data-&gt;clk_work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置平台设备的私有数据</span></span><br><span class="line">platform_set_drvdata(pdev, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置电源管理为激活状态</span></span><br><span class="line">pm_runtime_set_active(dev);</span><br><span class="line">pm_runtime_enable(dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_reset:</span><br><span class="line">reset_control_assert(data-&gt;rst);</span><br><span class="line"></span><br><span class="line">err_pclk:</span><br><span class="line">clk_disable_unprepare(data-&gt;pclk);</span><br><span class="line"></span><br><span class="line">err_clk:</span><br><span class="line">clk_disable_unprepare(data-&gt;clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 159行代码使用 <code>serial8250_register_8250_port</code> 函数注册了 8250 端口，<code>serial8250_register_8250_port</code> 函数内容如下所示：</p><h3 id="serial8250-register-8250-port"><a href="#serial8250-register-8250-port" class="headerlink" title="serial8250_register_8250_port()"></a>serial8250_register_8250_port()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *serial8250_register_8250_port - register a serial port</span></span><br><span class="line"><span class="comment"> *@up: serial port template</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Configure the serial port specified by the request. If the</span></span><br><span class="line"><span class="comment"> *port exists and is in use, it is hung up and unregistered</span></span><br><span class="line"><span class="comment"> *first.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *The port is then probed and if necessary the IRQ is autodetected</span></span><br><span class="line"><span class="comment"> *If this fails an error is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *On success the port is ready to use and the line number is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial8250_register_8250_port</span><span class="params">(<span class="keyword">struct</span> uart_8250_port *up)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> *<span class="title">uart</span>;</span></span><br><span class="line"><span class="type">int</span> ret = -ENOSPC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (up-&gt;port.uartclk == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;serial_mutex);</span><br><span class="line"></span><br><span class="line">uart = serial8250_find_match_or_unused(&amp;up-&gt;port);</span><br><span class="line"><span class="keyword">if</span> (uart &amp;&amp; uart-&gt;port.type != PORT_8250_CIR) &#123;</span><br><span class="line">....</span><br><span class="line">        <span class="keyword">if</span> (uart-&gt;port.type != PORT_8250_CIR) &#123;</span><br><span class="line"><span class="keyword">if</span> (serial8250_isa_config != <span class="literal">NULL</span>)</span><br><span class="line">serial8250_isa_config(<span class="number">0</span>, &amp;uart-&gt;port,</span><br><span class="line">&amp;uart-&gt;capabilities);</span><br><span class="line"></span><br><span class="line">serial8250_apply_quirks(uart);</span><br><span class="line">ret = uart_add_one_port(&amp;serial8250_reg,</span><br><span class="line">&amp;uart-&gt;port);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">ret = uart-&gt;port.line;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dev_info(uart-&gt;port.dev,</span><br><span class="line"><span class="string">&quot;skipping CIR port at 0x%lx / 0x%llx, IRQ %d\n&quot;</span>,</span><br><span class="line">uart-&gt;port.iobase,</span><br><span class="line">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)uart-&gt;port.mapbase,</span><br><span class="line">uart-&gt;port.irq);</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialise interrupt backoff work if required */</span></span><br><span class="line"><span class="keyword">if</span> (up-&gt;overrun_backoff_time_ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">uart-&gt;overrun_backoff_time_ms =</span><br><span class="line">up-&gt;overrun_backoff_time_ms;</span><br><span class="line">INIT_DELAYED_WORK(&amp;uart-&gt;overrun_backoff,</span><br><span class="line">serial_8250_overrun_backoff_work);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">uart-&gt;overrun_backoff_time_ms = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;serial_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">uart-&gt;port.dev = <span class="literal">NULL</span>;</span><br><span class="line">mutex_unlock(&amp;serial_mutex);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(serial8250_register_8250_port);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 <code>serial8250_find_match_or_unused </code>函数内容如下所示</p><h3 id="serial8250-find-match-or-unused"><a href="#serial8250-find-match-or-unused" class="headerlink" title="serial8250_find_match_or_unused()"></a>serial8250_find_match_or_unused()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> uart_8250_port *<span class="title function_">serial8250_find_match_or_unused</span><span class="params">(<span class="keyword">struct</span> uart_port *port)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * First, find a port entry which matches.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 首先，查找一个匹配的端口条目。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++)</span><br><span class="line"><span class="keyword">if</span> (uart_match_port(&amp;serial8250_ports[i].port, port))</span><br><span class="line"><span class="keyword">return</span> &amp;serial8250_ports[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* try line number first if still available */</span></span><br><span class="line">i = port-&gt;line;<span class="comment">/* 如果还有空闲的端口号，尝试使用 */</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; nr_uarts &amp;&amp; serial8250_ports[i].port.type == PORT_UNKNOWN &amp;&amp;</span><br><span class="line">serial8250_ports[i].port.iobase == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;serial8250_ports[i];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We didn&#x27;t find a matching entry, so look for the first</span></span><br><span class="line"><span class="comment"> * free entry.  We look for one which hasn&#x27;t been previously</span></span><br><span class="line"><span class="comment"> * used (indicated by zero iobase).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++)</span><br><span class="line"><span class="keyword">if</span> (serial8250_ports[i].port.type == PORT_UNKNOWN &amp;&amp;</span><br><span class="line">    serial8250_ports[i].port.iobase == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> &amp;serial8250_ports[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * That also failed.  Last resort is to find any entry which</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t have a real port associated with it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果仍然没有找到，最后的尝试是找到一个没有实际端口相关联的条目。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++)</span><br><span class="line"><span class="keyword">if</span> (serial8250_ports[i].port.type == PORT_UNKNOWN)</span><br><span class="line"><span class="keyword">return</span> &amp;serial8250_ports[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>serial8250_register_8250_port()</code>第 33 行 <code>uart_add_one_port()</code> 函数向 tty 核心层注册一个 UART 端口，<code>uart_add_one_port()</code> 函数内容如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *uart_add_one_port - attach a driver-defined port structure</span></span><br><span class="line"><span class="comment"> *@drv: pointer to the uart low level driver structure for this port</span></span><br><span class="line"><span class="comment"> *@uport: uart port structure to use for this port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *This allows the driver to register its own uart_port structure</span></span><br><span class="line"><span class="comment"> *with the core driver.  The main purpose is to allow the low</span></span><br><span class="line"><span class="comment"> *level uart drivers to expand uart_port, rather than having yet</span></span><br><span class="line"><span class="comment"> *more levels of structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_add_one_port</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv, <span class="keyword">struct</span> uart_port *uport)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">tty_dev</span>;</span></span><br><span class="line"><span class="type">int</span> num_groups;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register the port whether it&#x27;s detected or not.  This allows</span></span><br><span class="line"><span class="comment"> * setserial to be used to alter this port&#x27;s parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tty_dev = tty_port_register_device_attr_serdev(port, drv-&gt;tty_driver,</span><br><span class="line">uport-&gt;line, uport-&gt;dev, port, uport-&gt;tty_groups);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>tty_port_register_device_attr_serdev </code>函数内容如下所示：</p><h3 id="tty-port-register-device-attr-serdev"><a href="#tty-port-register-device-attr-serdev" class="headerlink" title="tty_port_register_device_attr_serdev()"></a>tty_port_register_device_attr_serdev()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tty_port_register_device_attr_serdev - register tty or serdev device</span></span><br><span class="line"><span class="comment"> * @port: tty_port of the device</span></span><br><span class="line"><span class="comment"> * @driver: tty_driver for this device</span></span><br><span class="line"><span class="comment"> * @index: index of the tty</span></span><br><span class="line"><span class="comment"> * @device: parent if exists, otherwise NULL</span></span><br><span class="line"><span class="comment"> * @drvdata: driver data for the device</span></span><br><span class="line"><span class="comment"> * @attr_grp: attribute group for the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register a serdev or tty device depending on if the parent device has any</span></span><br><span class="line"><span class="comment"> * defined serdev clients or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册一个 tty 设备到 tty 核心层，如果注册的设备是 serdev 设备，则不创建 cdev。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">tty_port_register_device_attr_serdev</span><span class="params">(<span class="keyword">struct</span> tty_port *port,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> tty_driver *driver, <span class="type">unsigned</span> index,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> device *device, <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> attribute_group **attr_grp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">tty_port_link_device(port, driver, index);<span class="comment">// 将 tty 端口链接到设备</span></span><br><span class="line"><span class="comment">// 注册 serdev 设备</span></span><br><span class="line">dev = serdev_tty_port_register(port, device, driver, index);</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(dev) != -ENODEV) &#123;</span><br><span class="line"><span class="comment">/* Skip creating cdev if we registered a serdev device */</span></span><br><span class="line"><span class="keyword">return</span> dev;<span class="comment">/* 如果注册的是 serdev 设备，则不创建 cdev */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果注册的不是 serdev 设备，则创建 cdev</span></span><br><span class="line"><span class="keyword">return</span> tty_register_device_attr(driver, index, device, drvdata,</span><br><span class="line">attr_grp);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(tty_port_register_device_attr_serdev);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数用于注册一个 tty 设备到 tty 核心层，如果注册的设备是 serdev 设备，则不创建 cdev。</p><p>首先，它将 tty 端口链接到设备，然后尝试注册 serdev 设备。如果注册的是 serdev 设备，则直接返回注册结果；否则，通过调用 <code>tty_register_device_attr()</code> 函数创建 cdev 并注册该设备到 tty 核心层。<code>tty_register_device_attr</code> 函数内容如下所示：</p><h3 id="tty-register-device-attr"><a href="#tty-register-device-attr" class="headerlink" title="tty_register_device_attr()"></a>tty_register_device_attr()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *tty_register_device_attr - register a tty device</span></span><br><span class="line"><span class="comment"> *@driver: the tty driver that describes the tty device</span></span><br><span class="line"><span class="comment"> *@index: the index in the tty driver for this tty device</span></span><br><span class="line"><span class="comment"> *@device: a struct device that is associated with this tty device.</span></span><br><span class="line"><span class="comment"> *This field is optional, if there is no known struct device</span></span><br><span class="line"><span class="comment"> *for this tty device it can be set to NULL safely.</span></span><br><span class="line"><span class="comment"> *@drvdata: Driver data to be set to device.</span></span><br><span class="line"><span class="comment"> *@attr_grp: Attribute group to be set on device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Returns a pointer to the struct device for this tty device</span></span><br><span class="line"><span class="comment"> *(or ERR_PTR(-EFOO) on error).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *This call is required to be made to register an individual tty device</span></span><br><span class="line"><span class="comment"> *if the tty driver&#x27;s flags have the TTY_DRIVER_DYNAMIC_DEV bit set.  If</span></span><br><span class="line"><span class="comment"> *that bit is not set, this function should not be called by a tty</span></span><br><span class="line"><span class="comment"> *driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Locking: ??</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册一个 tty 设备到 tty 核心层，包括创建 cdev，并添加属性组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">tty_register_device_attr</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver,</span></span><br><span class="line"><span class="params">   <span class="type">unsigned</span> index, <span class="keyword">struct</span> device *device,</span></span><br><span class="line"><span class="params">   <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> attribute_group **attr_grp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">64</span>];<span class="comment">// 设备名称缓冲区</span></span><br><span class="line"><span class="type">dev_t</span> devt = MKDEV(driver-&gt;major, driver-&gt;minor_start) + index;<span class="comment">// 计算设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> *<span class="title">tp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &gt;= driver-&gt;num) &#123;<span class="comment">// 检查索引是否超出范围</span></span><br><span class="line">pr_err(<span class="string">&quot;%s: Attempt to register invalid tty line number (%d)\n&quot;</span>,</span><br><span class="line">       driver-&gt;name, index);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (driver-&gt;type == TTY_DRIVER_TYPE_PTY)<span class="comment">// 根据驱动类型生成设备名称</span></span><br><span class="line">pty_line_name(driver, index, name);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tty_line_name(driver, index, name);</span><br><span class="line"></span><br><span class="line">dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);<span class="comment">// 分配设备结构体内存空间</span></span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置设备结构体的各个属性</span></span><br><span class="line">dev-&gt;devt = devt;</span><br><span class="line">dev-&gt;<span class="class"><span class="keyword">class</span> =</span> tty_class;</span><br><span class="line">dev-&gt;parent = device;</span><br><span class="line">dev-&gt;release = tty_device_create_release;</span><br><span class="line">dev_set_name(dev, <span class="string">&quot;%s&quot;</span>, name);<span class="comment">// 设置设备名称</span></span><br><span class="line">dev-&gt;groups = attr_grp;<span class="comment">// 设置属性组</span></span><br><span class="line">dev_set_drvdata(dev, drvdata);</span><br><span class="line"></span><br><span class="line">dev_set_uevent_suppress(dev, <span class="number">1</span>);<span class="comment">// 设置抑制 uevent</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册设备到内核</span></span><br><span class="line">retval = device_register(dev);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> err_put;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_ALLOC)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Free any saved termios data so that the termios state is</span></span><br><span class="line"><span class="comment"> * reset when reusing a minor number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果驱动不是动态分配的，则释放任何保存的终端参数数据，</span></span><br><span class="line"><span class="comment">* 这样当重用一个次设备号时，终端参数状态将被重置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">tp = driver-&gt;termios[index];</span><br><span class="line"><span class="keyword">if</span> (tp) &#123;</span><br><span class="line">driver-&gt;termios[index] = <span class="literal">NULL</span>;</span><br><span class="line">kfree(tp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加 cdev 到 tty 核心层</span></span><br><span class="line">retval = tty_cdev_add(driver, devt, index, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> err_del;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev_set_uevent_suppress(dev, <span class="number">0</span>);<span class="comment">// 取消抑制 uevent</span></span><br><span class="line">kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);<span class="comment">// 发送 uevent 通知设备已添加</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_del:</span><br><span class="line">device_del(dev); <span class="comment">// 删除设备</span></span><br><span class="line">err_put:</span><br><span class="line">put_device(dev);<span class="comment">// 释放设备结构体内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(tty_register_device_attr);</span><br></pre></td></tr></table></figure><p>该函数用于注册一个 tty 设备到 tty 核心层，包括创建 cdev，并添加属性组。</p><p>首先，它会根据驱动类型生成设备名称，并分配设备结构体内存空间，并设置设备的各个属性。</p><p>然后，它注册设备到内核，并根据驱动是否动态分配来决定是否添加 cdev 到 tty 核心层。</p><p>最后，取消抑制 uevent 并发送 uevent 通知设备已添加，并返回设备结构体指针。</p><h3 id="tty-cdev-add"><a href="#tty-cdev-add" class="headerlink" title="tty_cdev_add()"></a>tty_cdev_add()</h3><p>添加 cdev 到 tty 核心层使用 <code>tty_cdev_add</code> 函数，内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 向 tty 核心层添加 cdev。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_cdev_add</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">dev_t</span> dev,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init here, since reused cdevs cause crashes */</span></span><br><span class="line">driver-&gt;cdevs[index] = cdev_alloc();<span class="comment">// 分配一个 cdev 结构体</span></span><br><span class="line"><span class="keyword">if</span> (!driver-&gt;cdevs[index])<span class="comment">// 如果分配失败则返回错误</span></span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">driver-&gt;cdevs[index]-&gt;ops = &amp;tty_fops; <span class="comment">// 设置 cdev 的操作</span></span><br><span class="line">driver-&gt;cdevs[index]-&gt;owner = driver-&gt;owner;<span class="comment">// 设置 cdev 的所有者</span></span><br><span class="line">err = cdev_add(driver-&gt;cdevs[index], dev, count);<span class="comment">// 添加 cdev 到内核</span></span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">kobject_put(&amp;driver-&gt;cdevs[index]-&gt;kobj);<span class="comment">// 添加失败时释放资源</span></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数用于向 tty 核心层添加 cdev。首先，它分配一个 cdev 结构体，并设置其操作和所有者。然后，它通过调用 <code>cdev_add()</code> 函数将 cdev 添加到内核中。如果添加失败，则释放已分配的资源。</p><p>在上面代码第 13 行中，<code>tty_fops</code> 是 tty 驱动中的文件操作结构体，它定义了 tty 设备文件的操作函数。</p><p>这些函数包括了对 tty 设备文件进行打开、关闭、读取、写入、控制等操作的实现。一般来说，这些函数会调用相应的 tty 核心层函数来完成对底层 tty 设备的操作。</p><p><code>tty_fops</code> 结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">tty_fops</span> =</span> &#123;</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read_iter= tty_read,</span><br><span class="line">.write_iter= tty_write,</span><br><span class="line">.splice_read= generic_file_splice_read,</span><br><span class="line">.splice_write= iter_file_splice_write,</span><br><span class="line">.poll= tty_poll,</span><br><span class="line">.unlocked_ioctl= tty_ioctl,</span><br><span class="line">.compat_ioctl= tty_compat_ioctl,</span><br><span class="line">.open= tty_open,</span><br><span class="line">.release= tty_release,</span><br><span class="line">.fasync= tty_fasync,</span><br><span class="line">.show_fdinfo= tty_show_fdinfo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当用户空间对 tty 设备文件进行操作时，实际上是在调用对应的 tty_fops 中的操作函数。下面是一个简单的示例，展示了如何在用户空间对 tty 设备文件进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line"><span class="comment">// 打开 tty 设备文件</span></span><br><span class="line">fd = open(<span class="string">&quot;/dev/ttyS0&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;Failed to open tty device&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向 tty 设备文件写入数据</span></span><br><span class="line">write(fd, <span class="string">&quot;Hello, tty device!&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// 从 tty 设备文件读取数据</span></span><br><span class="line">read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received data: %s\n&quot;</span>, buffer);</span><br><span class="line"><span class="comment">// 关闭 tty 设备文件</span></span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="串口编程"><a href="#串口编程" class="headerlink" title="串口编程"></a>串口编程</h1><p>在 Linux 系统中，可以使用文件 I&#x2F;O 操作和ioctl 操作来进行串口编程。</p><ul><li><p>文件 I&#x2F;O 操作可以用于读取和写入串口数据</p></li><li><p>ioctl 操作可以用于设置串口参数、控制流控制和获取串口状态等操作</p></li></ul><h2 id="串口设备节点"><a href="#串口设备节点" class="headerlink" title="串口设备节点"></a>串口设备节点</h2><p>在 Linux 系统中，每个设备都由一个设备节点（device node）来表示，设备节点是与设备相关联的一个文<br>件，以&#x2F;dev 目录下的文件形式存在。</p><p>串口设备节点通常以 tty 开头，具体命名方式根据串口的类型和数量不同而不同。开发板系统启动之后，使用以下命令打印终端设备节点，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704636.png" alt="&#x2F;dev&#x2F;tty" loading="lazy"></p><ul><li><p><strong>dev&#x2F;ttyX（X 是一个数字编号，譬如 0、1、2、3 等）设备节点</strong>：tty 是 teletype 的简称，在 Linux 中，<code>/dev/ttyX</code> 代表的都是本地终端， Linux 内核在初始化时所生成的 63 个本地终端，包括<code>/dev/tty1</code>~&#96;&#x2F;dev&#x2F;tty63&#96; 一共 63 个本地终端，可以是连接到开发板的 LCD 显示器、键盘和鼠标等。</p></li><li><p><strong>串口终端设备节点</strong>：从开发板原理图可以了解到，在 iTOP-3568 开发板上有四个串口，分别 UART2、UART4、UART7、UART9，其中 UART2 为串口调试终端，对应的设备节点为<code>/dev/ttyFIQ0</code>,其他三个串口 UART4、UART7、UART9 分别对应<code>/dev/ttyS4</code>、<code>/dev/ttyS7</code>、<code>/dev/ttyS9</code>。</p></li><li><p><strong>基于 USB 的虚拟串口</strong>：<code>ttyGS0</code> 以及 <code>ttyUSBX</code>（X 是一个数字编号，譬如 0、1、2、3 等）都是 USB 的虚拟串口，其中 ttyGS0 为烧写 usb 虚拟出的串口，在系统启动之后可以在 windows 终端通过“adb shell”命令进入开发板控制台。ttyUSBX 在这里为 4G 模块的虚拟串口。</p></li></ul><h2 id="struct-termios-结构体"><a href="#struct-termios-结构体" class="headerlink" title="struct termios 结构体"></a>struct termios 结构体</h2><p><code>struct termios</code> 是 Linux 内核中用于描述终端设备（包括串口设备）参数的结构体。</p><p>它定义在 <code>&lt;linux/termios.h&gt;</code> 头文件中，包含了多个字段，用于配置和管理终端设备的属性和行为，包括了输入输出波特率、数据位、校验位、停止位等。其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> &#123;</span></span><br><span class="line"><span class="type">tcflag_t</span> c_iflag; <span class="comment">// 输入模式标志</span></span><br><span class="line"><span class="type">tcflag_t</span> c_oflag; <span class="comment">// 输出模式标志</span></span><br><span class="line"><span class="type">tcflag_t</span> c_cflag; <span class="comment">// 控制模式标志</span></span><br><span class="line"><span class="type">tcflag_t</span> c_lflag; <span class="comment">// 本地模式标志</span></span><br><span class="line"><span class="type">cc_t</span> c_cc[NCCS]; <span class="comment">// 控制字符数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是 struct termios 结构体的一些重要字段：</p><ul><li><code>tcflag_t c_iflag</code>：该字段包含了输入模式标志，用于配置终端设备的输入行为，如输入控制字符、输入数据处理等。</li><li><code>tcflag_t c_oflag</code>：该字段包含了输出模式标志，用于配置终端设备的输出行为，如输出数据处理、输出控制字符等。</li><li><code>tcflag_t c_cflag</code>：该字段包含了控制模式标志，用于配置终端设备的控制参数，如波特率、数据位数、停止位数、校验位等。</li><li><code>tcflag_t c_lflag</code>：该字段包含了本地模式标志，用于配置终端设备的本地操作以及输入输出行为。</li><li><code>cc_t c_cc[NCCS]</code>：该字段包含了特殊控制字符数组，用于配置终端设备的控制字符，如终端的擦除字符、结束字符、停止字符等。</li></ul><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>输入模式设置</p><table><thead><tr><th>成员</th><th>对应成员的含义</th></tr></thead><tbody><tr><td>IGNBRK</td><td>忽略输入终止条件</td></tr><tr><td>BRKINT</td><td>当检测到输入终止条件时发送 SIGINT 信号</td></tr><tr><td>IGNPAR</td><td>忽略帧错误和奇偶校验错误</td></tr><tr><td>PARMRK</td><td>对奇偶校验错误做出标记</td></tr><tr><td>INPCK</td><td>对接收到的数据执行奇偶校验</td></tr><tr><td>ISTRIP</td><td>将所有接收到的数据裁剪为 7 比特位、也就是去除第八位</td></tr><tr><td>INLCR</td><td>将接收到的 NL（换行符）转换为 CR（回车符）</td></tr><tr><td>IGNCR</td><td>忽略接收到的 CR（回车符）</td></tr><tr><td>ICRNL</td><td>将接收到的 CR（回车符）转换为 NL（换行符）</td></tr><tr><td>IUCLC</td><td>将接收到的大写字符映射为小写字符</td></tr><tr><td>IXON</td><td>启动输出软件流控</td></tr></tbody></table><h3 id="输出模式"><a href="#输出模式" class="headerlink" title="输出模式"></a>输出模式</h3><p>输出模式控制输出字符的处理方式，即由应用程序发送出去的字符数据在传递到串口或屏幕之前是如何处理的。可用于 <code>c_oflag</code> 成员的宏如下所示：</p><table><thead><tr><th>成员</th><th>对应成员的含义</th></tr></thead><tbody><tr><td>OPOST</td><td>启用输出处理功能，如果不设置该标志则其他标志都被忽略</td></tr><tr><td>OLCUC</td><td>将输出字符中的大写字符转换成小写字符</td></tr><tr><td>ONLCR</td><td>将输出中的换行符（NL ‘\n’）转换成回车符（CR ‘\r’）</td></tr><tr><td>OCRNL</td><td>将输出中的回车符（CR ‘\r’）转换成换行符（NL ‘\n’）</td></tr><tr><td>ONOCR</td><td>在第 0 列不输出回车符（CR）</td></tr><tr><td>ONLRET</td><td>不输出回车符</td></tr><tr><td>OFILL</td><td>发送填充字符以提供延时</td></tr><tr><td>OFDEL</td><td>如果设置该标志，则表示填充字符为 DEL 字符，否则为 NULL 字符</td></tr></tbody></table><h3 id="控制模式"><a href="#控制模式" class="headerlink" title="控制模式"></a>控制模式</h3><p>在这个结构体中，最重要的 <code>c_cflag</code>，可以控制模式控制终端设备的硬件特性，譬如对于串口来说，该字段比较重要，可设置串口波特率、数据位、校验位、停止位等硬件特性。通过设置 <code>struct termios</code> 结构中 <code>c_cflag</code> 成员的标志对控制模式进行配置。可用于 <code>c_cflag</code> 成员的标志如下所示：</p><h4 id="波特率（Baud-Rate）位掩码"><a href="#波特率（Baud-Rate）位掩码" class="headerlink" title="波特率（Baud Rate）位掩码"></a><strong>波特率（Baud Rate）位掩码</strong></h4><table><thead><tr><th>常量名称</th><th>含义</th></tr></thead><tbody><tr><td>B0</td><td>0 波特率（放弃 DTR）</td></tr><tr><td>B1800</td><td>1800 波特率</td></tr><tr><td>B2400</td><td>2400 波特率</td></tr><tr><td>B4800</td><td>4800 波特率</td></tr><tr><td>B9600</td><td>9600 波特率</td></tr><tr><td>B19200</td><td>19200 波特率</td></tr><tr><td>B38400</td><td>38400 波特率</td></tr><tr><td>B57600</td><td>57600 波特率</td></tr><tr><td>B115200</td><td>115200 波特率</td></tr></tbody></table><h4 id="数据位（Data-Bits）位掩码"><a href="#数据位（Data-Bits）位掩码" class="headerlink" title="数据位（Data Bits）位掩码"></a><strong>数据位（Data Bits）位掩码</strong></h4><table><thead><tr><th>常量名称</th><th>含义</th></tr></thead><tbody><tr><td>CS5</td><td>5 个数据位</td></tr><tr><td>CS6</td><td>6 个数据位</td></tr><tr><td>CS7</td><td>7 个数据位</td></tr><tr><td>CS8</td><td>8 个数据位</td></tr></tbody></table><h4 id="停止位（Stop-Bits）位掩码"><a href="#停止位（Stop-Bits）位掩码" class="headerlink" title="停止位（Stop Bits）位掩码"></a><strong>停止位（Stop Bits）位掩码</strong></h4><table><thead><tr><th>常量名称</th><th>含义</th></tr></thead><tbody><tr><td>CSTOPB</td><td>2 个停止位（不设则是 1 个停止位）</td></tr></tbody></table><h4 id="其他控制标志"><a href="#其他控制标志" class="headerlink" title="其他控制标志"></a><strong>其他控制标志</strong></h4><table><thead><tr><th>常量名称</th><th>含义</th></tr></thead><tbody><tr><td>CREAD</td><td>接收使能</td></tr><tr><td>PARENB</td><td>校验位使能</td></tr><tr><td>PARODD</td><td>使用奇校验而不使用偶校验</td></tr><tr><td>HUPCL</td><td>最后关闭时挂线（放弃 DTR）</td></tr><tr><td>CLOCAL</td><td>本地连接（不改变端口所有者）</td></tr><tr><td>LOBLK</td><td>块作业控制输出</td></tr><tr><td>CNET_CTSRTS</td><td>硬件流控制使能</td></tr></tbody></table><h3 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h3><p>本地模式用于控制终端的本地数据处理和工作模式。通过设置 <code>struct termios</code> 结构体中<code>c_lflag</code> 成员的标 志对本地模式进行配置。可用于 <code>c_lflag</code> 成员的标志如下所示：</p><table><thead><tr><th>常量名称</th><th>含义说明</th></tr></thead><tbody><tr><td><strong>INPCK</strong></td><td>启用奇偶校验功能。当启用时，系统会检查接收到的数据是否有奇偶校验错误。</td></tr><tr><td><strong>IGNPAR</strong></td><td>忽略奇偶校验错误。即使检测到校验错误，也不丢弃数据或产生异常。</td></tr><tr><td><strong>PARMRK</strong></td><td>当发生奇偶校验错误时，标记该字符（通常在前面插入 <code>\033</code> 和 <code>\000</code>）。用于调试。</td></tr><tr><td><strong>ISTRIP</strong></td><td>将所有接收到的数据字节的第8位（最高位）清零，即只保留低7位（用于7位字符集）。</td></tr><tr><td><strong>IXON</strong></td><td>启动<strong>输出软件流控</strong>（XON&#x2F;XOFF）。当缓冲区满时，发送 XOFF（^S）暂停发送；空闲时发送 XON（^Q）恢复。</td></tr><tr><td><strong>IXOFF</strong></td><td>启动<strong>输入软件流控</strong>。允许设备在接收端主动发送 XON&#x2F;XOFF 控制字符来控制发送方。</td></tr><tr><td><strong>IXANY</strong></td><td>允许任意字符（不仅仅是 XON）触发流控重启。默认情况下只有 XON 才能重启传输。</td></tr><tr><td><strong>IGNBRK</strong></td><td>忽略中断条件（Break Condition）。即忽略线路中断信号（如长时间低电平）。</td></tr><tr><td><strong>BRKINT</strong></td><td>当检测到中断（Break）时，向进程发送 <code>SIGINT</code> 信号（通常用于中断程序执行）。</td></tr><tr><td><strong>INLCR</strong></td><td>将输入中的换行符（NL, <code>\n</code>）转换为回车符（CR, <code>\r</code>）。常见于某些旧式终端。</td></tr><tr><td><strong>IGNCR</strong></td><td>忽略输入中的回车符（CR, <code>\r</code>），不作任何处理。</td></tr><tr><td><strong>ICRNL</strong></td><td>将输入中的回车符（CR, <code>\r</code>）转换为换行符（NL, <code>\n</code>）。这是常见的行末处理方式。</td></tr><tr><td><strong>ICANON</strong></td><td>启用“规范模式”（Canonical Mode）。在此模式下，输入按行处理（以换行符结束），支持编辑（如退格、删除）、回显等功能。关闭后进入“原始模式”</td></tr></tbody></table><h3 id="特殊控制字符"><a href="#特殊控制字符" class="headerlink" title="特殊控制字符"></a>特殊控制字符</h3><p>特殊控制字符是一些字符组合，如 Ctrl+C、Ctrl+Z 等，当用户键入这样的组合键，终端会采取特殊处理方式。<code>struct termios</code> 结构体中 <code>c_cc</code> 数组将各种特殊字符映射到对应的支持函数。每个字符位置（数组下标）由对应的宏定义的，如下所示</p><table><thead><tr><th>常量名</th><th>功能</th><th>默认键</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>VKILL</strong></td><td>删除整行</td><td>Ctrl+U</td><td>编辑长命令</td></tr><tr><td><strong>VEOF</strong></td><td>文件结束</td><td>Ctrl+D</td><td>提交输入或关闭</td></tr><tr><td><strong>VEOL</strong></td><td>行尾标记</td><td>CR</td><td>兼容旧终端</td></tr><tr><td><strong>VEOL2</strong></td><td>第二行尾</td><td>LF</td><td>多种换行格式</td></tr><tr><td><strong>VMIN</strong></td><td>最小字符数</td><td>-</td><td>非规范模式读取控制</td></tr><tr><td><strong>VTIME</strong></td><td>超时时间</td><td>-</td><td>非规范模式读取控制</td></tr><tr><td><strong>VINTR</strong></td><td>中断</td><td>Ctrl+C</td><td>终止程序</td></tr><tr><td><strong>VQUIT</strong></td><td>暂停</td><td>Ctrl+Z</td><td>挂起进程</td></tr><tr><td><strong>VERASE</strong></td><td>删除字符</td><td>Backspace</td><td>单字符编辑</td></tr></tbody></table><h2 id="常用串口控制函数"><a href="#常用串口控制函数" class="headerlink" title="常用串口控制函数"></a>常用串口控制函数</h2><h3 id="tcgetattr"><a href="#tcgetattr" class="headerlink" title="tcgetattr()"></a>tcgetattr()</h3><p><strong>功能</strong>：获取当前终端（或串口设备）的属性配置。<br><strong>原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcgetattr</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>fd</code>：文件描述符（如打开的串口 <code>/dev/ttyS0</code>）</li><li><code>termios_p</code>：指向 <code>struct termios</code> 的指针，用于存储当前配置</li></ul></li><li><strong>返回值</strong>：成功返回 0，失败返回 -1</li><li><strong>用途</strong>：读取当前串口的波特率、数据位、校验位、流控、输入&#x2F;输出模式等设置。</li></ul><blockquote><p>通常在修改串口前先调用此函数保存原始配置，以便程序退出时恢复。</p></blockquote><hr><h3 id="tcsetattr"><a href="#tcsetattr" class="headerlink" title="tcsetattr()"></a>tcsetattr()</h3><p><strong>功能</strong>：设置终端（或串口）的属性配置。<br><strong>原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcsetattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> optional_actions, <span class="type">const</span> <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>fd</code>：文件描述符</li><li><code>optional_actions</code>：指定何时应用新设置，常见值：<ul><li><code>TCSANOW</code>：立即生效</li><li><code>TCSADRAIN</code>：等待输出完成后再生效（常用于输出相关设置）</li><li><code>TCSAFLUSH</code>：清空输入&#x2F;输出缓冲区后立即生效</li></ul></li><li><code>termios_p</code>：包含新配置的 <code>struct termios</code> 指针</li></ul></li><li><strong>返回值</strong>：成功返回 0，失败返回 -1</li><li><strong>用途</strong>：应用新的串口参数（如波特率、8N1 配置、原始模式等）</li></ul><blockquote><p>⚠️ 修改后建议检查返回值，确保设置成功。</p></blockquote><hr><h3 id="cfgetispeed-和-cfgetospeed"><a href="#cfgetispeed-和-cfgetospeed" class="headerlink" title="cfgetispeed() 和 cfgetospeed()"></a>cfgetispeed() 和 cfgetospeed()</h3><p><strong>功能</strong>：分别获取输入（接收）和输出（发送）波特率。<br><strong>原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">speed_t</span> <span class="title function_">cfgetispeed</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> termios *termios_p)</span>;</span><br><span class="line"><span class="type">speed_t</span> <span class="title function_">cfgetospeed</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>返回值</strong>：波特率常量（如 <code>B9600</code>, <code>B115200</code>），不是实际数值（如 9600）</li><li><strong>注意</strong>：返回的是 <code>speed_t</code> 类型的<strong>掩码值</strong>，不能直接当作整数使用</li></ul><blockquote><p>实际波特率需通过查表或系统特定方式转换（某些系统提供 <code>cfmakeraw()</code> 或 <code>ioctl</code> 获取真实速率）。</p></blockquote><hr><h3 id="cfsetispeed-和-cfsetospeed"><a href="#cfsetispeed-和-cfsetospeed" class="headerlink" title="cfsetispeed()和 cfsetospeed()"></a>cfsetispeed()和 cfsetospeed()</h3><p><strong>功能</strong>：分别设置输入和输出波特率。</p><p><strong>原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cfsetispeed</span><span class="params">(<span class="keyword">struct</span> termios *termios_p, <span class="type">speed_t</span> speed)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cfsetospeed</span><span class="params">(<span class="keyword">struct</span> termios *termios_p, <span class="type">speed_t</span> speed)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>参数</strong>：</p><ul><li><code>termios_p</code>：指向要修改的 <code>termios</code> 结构</li><li><code>speed</code>：波特率常量（如 <code>B9600</code>, <code>B115200</code>）</li></ul></li><li><p><strong>返回值</strong>：成功返回 0，失败返回 -1</p></li><li><p><strong>典型用法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">tty</span>;</span></span><br><span class="line">tcgetattr(fd, &amp;tty);</span><br><span class="line">cfsetospeed(&amp;tty, B115200);</span><br><span class="line">cfsetispeed(&amp;tty, B115200);</span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;tty);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>通常收发波特率设为相同（全双工通信），除非特殊需求。</p></blockquote><hr><h3 id="tcflush-和-tcflow"><a href="#tcflush-和-tcflow" class="headerlink" title="tcflush() 和 tcflow()"></a>tcflush() 和 tcflow()</h3><h4 id="tcflush"><a href="#tcflush" class="headerlink" title="tcflush()"></a>tcflush()</h4><p><strong>功能</strong>：清空终端的输入或输出队列。<br><strong>原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcflush</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> queue_selector)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>queue_selector</code> 取值</strong>：<ul><li><code>TCIFLUSH</code>：清空<strong>输入队列</strong>（已收到但未读取的数据）</li><li><code>TCOFLUSH</code>：清空<strong>输出队列</strong>（待发送但未发出的数据）</li><li><code>TCIOFLUSH</code>：同时清空输入和输出队列</li></ul></li><li><strong>用途</strong>：在重新配置串口或重启通信前清除脏数据。</li></ul><h4 id="tcflow"><a href="#tcflow" class="headerlink" title="tcflow()"></a>tcflow()</h4><p><strong>功能</strong>：控制串口的数据流（暂停&#x2F;恢复传输）。<br><strong>原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcflow</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> action)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>action</code> 取值</strong>：<ul><li><code>TCOOFF</code>：暂停<strong>输出</strong>（发送端停止发送）</li><li><code>TCOON</code>：恢复<strong>输出</strong></li><li><code>TCIOFF</code>：暂停<strong>输入</strong>（向对端发送 XOFF，要求对方暂停）</li><li><code>TCION</code>：恢复<strong>输入</strong>（向对端发送 XON，允许继续发送）</li></ul></li><li><strong>用途</strong>：手动实现软件流控（XON&#x2F;XOFF），或应对缓冲区溢出。</li></ul><blockquote><p>💡 注意：<code>tcflow()</code> 依赖 <code>IXON/IXOFF</code> 标志是否启用。</p></blockquote><h2 id="串口操作流程"><a href="#串口操作流程" class="headerlink" title="串口操作流程"></a>串口操作流程</h2><h3 id="设置串口的波特率"><a href="#设置串口的波特率" class="headerlink" title="设置串口的波特率"></a>设置串口的波特率</h3><p>在编写串口应用程序时，设置串口波特率是必须的步骤之一，它决定了数据传输的速率。</p><p>在 Linux 中，设置波特率通常使用 cfsetspeed() 函数，cfsetspeed()函数所需头文件和函数原型如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cfsetspeed</span><span class="params">(<span class="keyword">struct</span> termios *termios_p, <span class="type">speed_t</span> speed)</span>;</span><br></pre></td></tr></table></figure><p>它接受一个 <code>struct termios</code> 结构体作为输入参数，同时返回一个整数值，表示操作是否成功。</p><p>该函数实际上是对 <code>c_cflag</code> 字段中的波特率进行设置。例如，如果要将波特率设置为115200，可以调用以下代码:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">options</span>;</span></span><br><span class="line"><span class="comment">// 获取当前终端配置</span></span><br><span class="line">tcgetattr(fd, &amp;options);</span><br><span class="line"><span class="comment">// 设置波特率为 115200</span></span><br><span class="line">cfsetspeed(&amp;options, B115200);</span><br><span class="line"><span class="comment">// 将新的终端配置写入终端</span></span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;options);</span><br></pre></td></tr></table></figure><p>需要注意以下几点：</p><ul><li>需要先打开串口设备文件并且获取串口的属性，包括波特率在内的其他属性。可以使用 <code>tcgetattr()</code> 函数获取属性值，并存储在一个 <code>termios</code> 结构体变量中。</li><li>设置波特率时需要调用 <code>cfsetspeed()</code> 函数，并传入一个波特率常量作为参数。常用的波特率常量包括 B9600、B115200 等。这些常量可以在头文件 <code>termios.h</code> 中找到。</li><li>设置完成后，需要使用 <code>tcsetattr()</code> 函数将属性值写回到串口设备中。</li></ul><h3 id="设置数据位大小"><a href="#设置数据位大小" class="headerlink" title="设置数据位大小"></a>设置数据位大小</h3><p>在串口通讯中，数据位指的是每个字符（byte）中实际包含的数据位数。通常情况下，一个字符包含 8 个位（即 8 个 0 或 1），但有时也可能为 7 个位或其他值。</p><p>在编写串口应用程序时，需要使用 <code>struct termios</code> 结构体中的 <code>c_cflag</code> 成员变量来设置数据位大小。具体来说，需要将 <code>c_cflag</code> 成员变量中与数据位相关的位清零，然后再根据需要设置相应的值。</p><p>清零操作通常使用按位与（&amp;）运算符和位运算中的“非”运算符（~），具体步骤如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;= ~CSIZE; <span class="comment">// 将数据位相关的比特位清零</span></span><br></pre></td></tr></table></figure><p>其中，CSIZE 是一个宏定义，表示数据位的位掩码。宏定义通常定义在 <code>termios.h</code> 头文件中，其取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CSIZE 0x00000300 <span class="comment">/* 字符长度掩码 */</span></span></span><br></pre></td></tr></table></figure><p>通过清零操作，将数据位相关的位全部置为 0。接下来，可以使用按位或（|）运算符和宏定义来设置具体的数据位数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag |= CS8; <span class="comment">// 将数据位数设置为 8 位</span></span><br></pre></td></tr></table></figure><p>此时，CS8 宏定义将会被解释为一个包含 8 位的位掩码，通过按位或运算，将其设置到 <code>c_cflag</code> 成员变量中，从而完成数据位的设置。</p><h3 id="设置奇偶校验位"><a href="#设置奇偶校验位" class="headerlink" title="设置奇偶校验位"></a>设置奇偶校验位</h3><p>串口的奇偶校验位配置一共涉及到 <code>struct termios</code> 结构体中的两个成员变量：<code>c_cflag</code> 和<code>c_iflag</code>。</p><p>首先对于 <code>c_cflag</code> 成员，需要添加 <code>PARENB</code> 标志以使能串口的奇偶校验功能，只有使能奇偶校验功能之后才会对输出数据产生校验位，从而对输入数据进行校验检查；</p><p>同时对于<code>c_iflag</code> 成员来说，还需要添加 <code>INPCK</code> 标志，这样才能对接收到的数据执行奇偶校验，代码如下所示：</p><h4 id="奇校验使能"><a href="#奇校验使能" class="headerlink" title="奇校验使能"></a>奇校验使能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag |= (PARODD | PARENB); <span class="comment">// 设置为奇校验</span></span><br><span class="line">new_cfg.c_iflag |= INPCK; <span class="comment">// 使能奇偶校验</span></span><br></pre></td></tr></table></figure><h4 id="偶校验使能"><a href="#偶校验使能" class="headerlink" title="偶校验使能"></a>偶校验使能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;= ~PARODD; <span class="comment">// 设置为偶校验</span></span><br><span class="line">new_cfg.c_cflag |= PARENB; <span class="comment">// 使能奇偶校验</span></span><br><span class="line">new_cfg.c_iflag |= INPCK; <span class="comment">// 对输入数据执行奇偶校验</span></span><br></pre></td></tr></table></figure><h4 id="无校验"><a href="#无校验" class="headerlink" title="无校验"></a>无校验</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;= ~PARENB; <span class="comment">// 禁用奇偶校验</span></span><br><span class="line">new_cfg.c_iflag &amp;= ~INPCK; <span class="comment">// 不执行奇偶校验</span></span><br></pre></td></tr></table></figure><h3 id="设置停止位"><a href="#设置停止位" class="headerlink" title="设置停止位"></a>设置停止位</h3><p>在串口通信中，停止位用于指定每个数据帧的结束位置。</p><p>在传输一个完整的数据字节后，通常需要一个或多个停止位，以便接收端能够确定一个数据帧的结束。</p><p>停止位的数量通常为 1位或 2 位，其中 1 位停止位被广泛使用，而 2 位停止位则较少使用。</p><p>在 Linux 中，通过在 <code>struct termios</code> 结构体中设置 <code>c_cflag</code> 成员变量的 <code>CSTOPB</code> 标志位来控制停止位的数量。当 <code>CSTOPB</code> 为 0 时，仅使用 1 位停止位；当 <code>CSTOPB</code> 为 1 时，则使用 2位停止位。</p><p>例如，以下代码将串口的停止位设置为 1 位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;= ~CSTOPB; <span class="comment">// 设置停止位为 1 位</span></span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置串口参数的函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_uart</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> speed, <span class="type">int</span> bits, <span class="type">char</span> check, <span class="type">int</span> stop)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">newtio</span>, <span class="title">oldtio</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一：保存原来的串口配置</span></span><br><span class="line">    <span class="keyword">if</span>(tcgetattr(fd, &amp;oldtio) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcgetattr oldtio error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;newtio, <span class="keyword">sizeof</span>(newtio));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤二：设置控制模式标志</span></span><br><span class="line">    newtio.c_cflag |= CLOCAL | CREAD;</span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤三：设置数据位</span></span><br><span class="line">    <span class="keyword">switch</span>(bits) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            newtio.c_cflag |= CS7;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            newtio.c_cflag |= CS8;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤四：设置奇偶校验位</span></span><br><span class="line">    <span class="keyword">switch</span>(check) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 偶校验位</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag |= PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: <span class="comment">// 奇校验位</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="comment">// 无校验</span></span><br><span class="line">            newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤五：设置波特率</span></span><br><span class="line">    <span class="keyword">switch</span>(speed) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9600</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">115200</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B115200);</span><br><span class="line">            cfsetospeed(&amp;newtio, B115200);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤六：设置停止位</span></span><br><span class="line">    <span class="keyword">switch</span>(stop) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            newtio.c_cflag &amp;= ~CSTOPB; <span class="comment">// 1位停止位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            newtio.c_cflag |= CSTOPB; <span class="comment">// 2位停止位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤七：刷新输入队列</span></span><br><span class="line">    tcflush(fd, TCIFLUSH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤八：设置配置立刻生效</span></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(fd, TCSANOW, &amp;newtio) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcsetattr newtio error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤九：打开串口设备</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/ttyS9&quot;</span>, O_RDWR | O_NOCTTY | O_NDELAY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置串口参数</span></span><br><span class="line">    set_uart(fd, <span class="number">115200</span>, <span class="number">8</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    write(fd, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    count = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    buf[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出读取的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read message is %s\n&quot;</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭串口设备</span></span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="GPS模块编程"><a href="#GPS模块编程" class="headerlink" title="GPS模块编程"></a>GPS模块编程</h1><p>全球卫星导航系统是一种利用卫星技术为全球用户提供精确时间和位置信息的系统。</p><p>定位模块往往和 CPU 通过串口相连，然后 CPU 通过 wifi 蓝牙等其他方式将坐标进行上传。</p><p>GPS模块原理图如下</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704683.png" alt="GPS模块原理图" loading="lazy"></p><p>其中 <code>BUF_GPS_RST</code> 接口悬空不接，以下为 20pin 底座连接到 RK3568 开发板 GPIO 接口连接表如下所示：</p><table><thead><tr><th>GPS 模块引脚编号</th><th>GPS 模块引脚名称</th><th>连接到的开发板引脚编号</th><th>连接到的开发板引脚名称</th></tr></thead><tbody><tr><td>2</td><td>BUF_GPS_TXD</td><td>8</td><td>UART9_RX_M1</td></tr><tr><td>3</td><td>BUF_GPS_RXD</td><td>6</td><td>UART9_TX_M1</td></tr><tr><td>11</td><td>GND</td><td>19&#x2F;20</td><td>GND</td></tr><tr><td>19</td><td>VDD33_A31</td><td>2&#x2F;4</td><td>VCC3V3_SYS</td></tr></tbody></table><blockquote><p> GPS 模块连接好之后，天线要放到户外</p></blockquote><h2 id="GPS-数据帧介绍"><a href="#GPS-数据帧介绍" class="headerlink" title="GPS 数据帧介绍"></a>GPS 数据帧介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704724.png" alt="GPS数据" loading="lazy"></p><p>这里列举的是 GPS NMEA 格式中常见的数据类型，其中包括：</p><ul><li><strong>GPRMC (Recommended Minimum Specific GPS&#x2F;Transit data)</strong>：GPRMC 数据类型提供了位置、速度、航向等最基本的 GPS 定位信息。这个数据类型常用于导航系统和船舶自动导航系统。</li><li><strong>GPVTG (Track Made Good and Ground Speed)</strong>：GPVTG 数据类型提供了航向角和地面速度信息，用于显示船、车等运动物体的导航信息。 它提供了地面航向角和相对地面的速度。</li><li><strong>GPGGA (Global Positioning System Fix Data)</strong>：GPGGA 数据类型包括了定位解、时间、位置准确度、海拔等位置信息，通常被用于接收机实时显示当前位置。</li><li><strong>GPGSA (GPS DOP and Active Satellites)</strong>：GPGSA 数据类型包括了 DOP 值和当前卫星定位状态。它用于提供 GPS 卫星测量数据中可用卫星数量、解算出的位置几何因子 DOP 等信息。</li><li><strong>GPGSV (GPS Satellites in View)</strong>：GPGSV 数据类型提供了现时可视卫星的信息，包括卫星的PRN、仰角、方位角、信号强度等信息。这些信息有助于接收器找到更多卫星并提高位置定位的准确性。</li><li><strong>GPGLL (Geographic Position - Latitude&#x2F;Longitude)</strong>：GPGLL 数据类型提供了经度和纬度信息，用于描述接收机的当前经纬度位置。</li></ul><p>我们只需要关注 GPRMC 这条信息即可，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704767.png" alt="GPRMC" loading="lazy"></p><p>GPRMC（Recommended Minimum Specific GNSS Data）是一种常见的 GPS 数据帧格式，用于在 GPS 设备之间或者 GPS 设备与其他设备之间传输 GPS 位置信息。以下是 GPRMC 数据帧中包含的信息：</p><table><thead><tr><th>字段编号</th><th>字段值（示例）</th><th>含义</th><th>详细解释</th></tr></thead><tbody><tr><td>0</td><td><code>$GPRMC</code></td><td>消息 ID</td><td>表示这是“推荐最小定位信息”帧。<code>GP</code> 表示由 GPS 系统提供；其他系统如 GLONASS 用 <code>GL</code>，北斗用 <code>BD</code> 或 <code>GB</code>。</td></tr><tr><td>1</td><td><code>083634.00</code></td><td>UTC 时间</td><td>格式：<code>hhmmss.sss</code> 表示 <strong>08:36:34.000 UTC</strong> → 北京时间 &#x3D; UTC + 8 小时 → <strong>16:36:34（下午 4 点 36 分）</strong></td></tr><tr><td>2</td><td><code>A</code></td><td>状态指示</td><td>- <code>A</code>：<strong>有效定位</strong>（Active &#x2F; Valid） - <code>V</code>：<strong>无效定位</strong>（Void &#x2F; Invalid），可能因信号弱或未锁定卫星</td></tr><tr><td>3</td><td><code>3854.62194</code></td><td>纬度（数值）</td><td>格式：<code>ddmm.mmmm</code> 即 <strong>38°54.62194′</strong> 转换为十进制度： <code>38 + 54.62194/60 ≈ 38.910366° N</code></td></tr><tr><td>4</td><td><code>N</code></td><td>纬度半球</td><td>- <code>N</code>：北纬（North） - <code>S</code>：南纬（South）</td></tr><tr><td>5</td><td><code>11526.10876</code></td><td>经度（数值）</td><td>格式：<code>dddmm.mmmm</code> 即 <strong>115°26.10876′</strong> 转换为十进制度： <code>115 + 26.10876/60 ≈ 115.435146° E</code></td></tr><tr><td>6</td><td><code>E</code></td><td>经度半球</td><td>- <code>E</code>：东经（East） - <code>W</code>：西经（West）</td></tr><tr><td>7</td><td><code>0.932</code></td><td>地面速率（节）</td><td>单位：<strong>knots（节）</strong> 1 节 &#x3D; 1 海里&#x2F;小时 ≈ 1.852 km&#x2F;h → <code>0.932 × 1.852 ≈ 1.73 km/h</code>（步行速度）</td></tr><tr><td>8</td><td><code>55.00</code></td><td>地面航向</td><td>单位：<strong>度（°）</strong>，以<strong>真北为 0°</strong> 范围：0.0 ~ 359.9° 55° 表示东北方向</td></tr><tr><td>9</td><td><code>200624</code></td><td>UTC 日期</td><td>格式：<code>ddmmyy</code> → <strong>2024 年 6 月 20 日</strong></td></tr><tr><td>10</td><td>（空）</td><td>磁偏角</td><td>可选字段，表示磁北与真北之间的夹角（单位：度）</td></tr><tr><td>11</td><td>（空）</td><td>磁偏角方向</td><td><code>E</code> 或 <code>W</code>，配合字段 10 使用</td></tr><tr><td>12</td><td>（空）</td><td>定位模式</td><td>- <code>A</code>：自主定位（Autonomous） - <code>D</code>：差分定位（DGPS） - <code>E</code>：估算（Dead Reckoning） - <code>N</code>：无定位 （注：部分模块在此字段输出，有些放在 <code>$GPGSA</code> 中）</td></tr><tr><td>13</td><td><code>D*50</code></td><td>校验和</td><td>从 <code>$</code> 后第一个字符到 <code>*</code> 前所有字符做 <strong>异或（XOR）校验</strong> 用于验证数据完整性</td></tr></tbody></table><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="gps-h"><a href="#gps-h" class="headerlink" title="gps.h"></a>gps.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GPS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GPS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体 gprmc_data，用于存储解析后的 GPS 数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gprmc_data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> id;         <span class="comment">// 数据标识（未使用）</span></span><br><span class="line">    <span class="type">int</span> time;      <span class="comment">// UTC 时间（hhmmss.sss 格式）</span></span><br><span class="line">    <span class="type">char</span> state;      <span class="comment">// 状态指示（A=有效，V=无效）</span></span><br><span class="line">    <span class="type">float</span> latitude;  <span class="comment">// 纬度（ddmm.mmmm 格式）</span></span><br><span class="line">    <span class="type">char</span> NS;         <span class="comment">// 纬度半球（N=北半球，S=南半球）</span></span><br><span class="line">    <span class="type">float</span> longitude; <span class="comment">// 经度（dddmm.mmmm 格式）</span></span><br><span class="line">    <span class="type">char</span> EW;         <span class="comment">// 经度半球（E=东经，W=西经）</span></span><br><span class="line">    <span class="type">float</span> speed;     <span class="comment">// 地面速率（节）</span></span><br><span class="line">    <span class="type">int</span> date;        <span class="comment">// UTC 日期（ddmmyy 格式）</span></span><br><span class="line">    <span class="type">char</span> mode;       <span class="comment">// 模式指示（A=自主定位，D=差分定位）</span></span><br><span class="line">    <span class="type">char</span> check;      <span class="comment">// 校验位（未使用）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数原型：设置串口参数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_uart</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> speed, <span class="type">int</span> bits, <span class="type">char</span> check, <span class="type">int</span> stop)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数原型：解析 GPS 数据</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">get_gps_data</span><span class="params">(<span class="type">char</span> *buff, <span class="keyword">struct</span> gprmc_data *gps_data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="gps-c"><a href="#gps-c" class="headerlink" title="gps.c"></a>gps.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gps.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：get_gps_data</span></span><br><span class="line"><span class="comment">// 描述：从数据缓冲区解析GPS数据，并填充到结构体中</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//   - buff: 指向包含GPS数据的缓冲区的指针</span></span><br><span class="line"><span class="comment">//   - gps_data: 指向结构体 gprmc_data 的指针，用于存储解析后的GPS数据</span></span><br><span class="line"><span class="comment">// 返回值：无</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_gps_data</span><span class="params">(<span class="type">char</span> *buff, <span class="keyword">struct</span> gprmc_data *gps_data)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 在缓冲区中查找以 &quot;$GPRMC&quot; 开头的位置</span></span><br><span class="line">    p = <span class="built_in">strstr</span>(buff, <span class="string">&quot;$GPRMC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="comment">// printf(&quot;Error: $GPRMC not found in buffer.\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 如果未找到 &quot;$GPRMC&quot;，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 sscanf 函数从字符串 p 开始按指定格式解析数据，并存储到 gps_data 结构体中对应的成员变量中</span></span><br><span class="line">    <span class="built_in">sscanf</span>(p,<span class="string">&quot;$GPRMC,%d.00,%c,%f,%c,%f,%c,%f,,%d,,,%c,%*c&quot;</span>,\</span><br><span class="line">    &amp;(gps_data-&gt;time),\</span><br><span class="line">    &amp;(gps_data-&gt;state),\</span><br><span class="line">    &amp;(gps_data-&gt;latitude),\</span><br><span class="line">    &amp;(gps_data-&gt;NS),\</span><br><span class="line">    &amp;(gps_data-&gt;longitude),\</span><br><span class="line">    &amp;(gps_data-&gt;EW),\</span><br><span class="line">    &amp;(gps_data-&gt;speed),\</span><br><span class="line">    &amp;(gps_data-&gt;date),\</span><br><span class="line">    &amp;(gps_data-&gt;mode));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印解析后的部分 GPS 数据，用于验证解析是否正确（可选）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;state:%c, %c:%f, %c:%f\n&quot;</span>, gps_data-&gt;state, gps_data-&gt;NS,</span><br><span class="line">           gps_data-&gt;latitude, gps_data-&gt;EW, gps_data-&gt;longitude);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="uart-c"><a href="#uart-c" class="headerlink" title="uart.c"></a>uart.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置串口参数的函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_uart</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> speed, <span class="type">int</span> bits, <span class="type">char</span> check, <span class="type">int</span> stop)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">newtio</span>, <span class="title">oldtio</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤一：保存原来的串口配置</span></span><br><span class="line">    <span class="keyword">if</span>(tcgetattr(fd, &amp;oldtio) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcgetattr oldtio error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;newtio, <span class="keyword">sizeof</span>(newtio));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤二：设置控制模式标志</span></span><br><span class="line">    newtio.c_cflag |= CLOCAL | CREAD;</span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤三：设置数据位</span></span><br><span class="line">    <span class="keyword">switch</span>(bits) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            newtio.c_cflag |= CS7;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            newtio.c_cflag |= CS8;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤四：设置奇偶校验位</span></span><br><span class="line">    <span class="keyword">switch</span>(check) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 偶校验位</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag |= PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: <span class="comment">// 奇校验位</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="comment">// 无校验</span></span><br><span class="line">            newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤五：设置波特率</span></span><br><span class="line">    <span class="keyword">switch</span>(speed) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9600</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">115200</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B115200);</span><br><span class="line">            cfsetospeed(&amp;newtio, B115200);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤六：设置停止位</span></span><br><span class="line">    <span class="keyword">switch</span>(stop) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            newtio.c_cflag &amp;= ~CSTOPB; <span class="comment">// 1位停止位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            newtio.c_cflag |= CSTOPB; <span class="comment">// 2位停止位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤七：刷新输入队列</span></span><br><span class="line">    tcflush(fd, TCIFLUSH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤八：设置配置立刻生效</span></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(fd, TCSANOW, &amp;newtio) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcsetattr newtio error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux UART</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Qemu 树莓派4b Linux module开发环境</title>
    <link href="https://even629.com/posts/2512310/"/>
    <id>https://even629.com/posts/2512310/</id>
    <published>2025-12-31T07:25:13.000Z</published>
    <updated>2026-01-14T10:48:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-31</p></div></div><div class='timeline-item-content'><p>init</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-01-14</p></div></div><div class='timeline-item-content'><p>add buildroot</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="Host-OS"><a href="#Host-OS" class="headerlink" title="Host OS"></a>Host OS</h2><p>使用WSL2的archlinux</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251120165235338.png" alt="环境" loading="lazy"></p><p>使用Ubuntu也可，参考：</p><div class="tag link"><a class="link-card" title="WSL Ubuntu20.04安装与配置" href="https://even629.com/posts/2512299"><div class="left"><img src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">WSL Ubuntu20.04安装与配置</p><p class="url">https://even629.com/posts/2512299</p></div></a></div><h2 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h2><p>ARM目前总共发布了8种架构：ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8。</p><p>针对于支持ARMv8指令集的处理器可以使用<code>-march=armv8-a</code>参数编译代码，ARM GNU编译器可通过下面的链接下载</p><div class="tag link"><a class="link-card" title="Arm GNU Toolchain Downloads" href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads"><div class="left"><img src="https://developer.arm.com/shared/common/img/favicon/favicon.ico"/></div><div class="right"><p class="text">Arm GNU Toolchain Downloads</p><p class="url">https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads</p></div></a></div><p>比如archlinux上通过pacman下载的aarch64-linux-gnu-gcc版本是15.1.0，它的文件是flat布局的。不适用于buildroot的编译工具链。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251226131446292.png" alt="aarch64-linux-gnu-gcc" loading="lazy"></p><p>推荐使用ARM官网的编译器，它是Portable的，解压后即可使用。</p><p>本文使用的是11.2版本的交叉编译器</p><div class="tag link"><a class="link-card" title="aarch64-none-linux-gnu 11.2" href="https://developer.arm.com/-/media/files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz"><div class="left"><img src="https://developer.arm.com/shared/common/img/favicon/favicon.ico"/></div><div class="right"><p class="text">aarch64-none-linux-gnu 11.2</p><p class="url">https://developer.arm.com/-/media/files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz</p></div></a></div><p>可以将其添加到环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ~/.bashrc或~/.</span></span><br><span class="line">emacs ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/tools/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure><p>使用11.2.1版本的aarch64-none-linux-gnu-gcc</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20260114164147335.png" alt="aarch64-none-linux-gnu-gcc" loading="lazy"></p><h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Syu bc</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 --branch rpi-5.10.y --single-branch https://github.com/raspberrypi/linux.git linux-5.10.y-raspi</span><br><span class="line">make mrproper</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- bcm2711_defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- modules_prepare</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-none-linux-gnu- Image modules dtbs -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把编译好的内核镜像和设备树放在指定目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/tftp/raspi4b</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm64/boot/Image ~/tftp/raspi4b</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm64/boot/dts/broadcom/bcm2711-rpi-4-b.dtb ~/tftp/raspi4b</span><br></pre></td></tr></table></figure><p>输出：</p><ul><li><code>arch/arm64/boot/Image</code></li><li><code>arch/arm64/boot/dts/broadcom/bcm2711-rpi-4-b.dtb</code></li></ul><h1 id="编译根文件系统"><a href="#编译根文件系统" class="headerlink" title="编译根文件系统"></a>编译根文件系统</h1><h2 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h2><p>参考：</p><div class="tag link"><a class="link-card" title="最小Linux系统编译运行" href="https://even629.com/posts/42869"><div class="left"><img src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">最小Linux系统编译运行</p><p class="url">https://even629.com/posts/42869</p></div></a></div><div class="tip warning faa-horizontal animated-hover"><p>注意这篇博客使用的是archlinux上pacman下载的aarch64-linux-gnu-gcc编译器，编译器最好和编译内核的编译器保持一致，这里我们选择aarch64-none-linux-gnu-gcc</p></div><p>拷贝动态库文件时要拷贝编译器目录下的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/tools/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/aarch64-none-linux-gnu/libc/lib/ld-linux-aarch64.so.1 ./lib/</span><br><span class="line"><span class="built_in">cp</span> ~/tools/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/aarch64-none-linux-gnu/libc/lib64/* ./lib64/</span><br></pre></td></tr></table></figure><p>编译完成后进入linux内核代码，安装驱动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装驱动，拷贝到根文件系统</span></span><br><span class="line"><span class="built_in">cd</span> /home/zhaohang/repository/linux/linux-5.10.y-raspi</span><br><span class="line"><span class="comment"># busybox</span></span><br><span class="line">make ARCH=arm64 \</span><br><span class="line">     CROSS_COMPILE=aarch64-none-linux-gnu- \</span><br><span class="line">     INSTALL_MOD_PATH=/home/zhaohang/repository/linux/busybox-1.37.0/_install/ \</span><br><span class="line">     modules_install</span><br></pre></td></tr></table></figure><h2 id="buildroot"><a href="#buildroot" class="headerlink" title="buildroot"></a>buildroot</h2><p>Archlinux默认工具链及AUR提供的交叉工具链都是无法复制使用的，而Buildroot在构建时会将工具链复制到工作目录执行，因此我们需要<strong>选择 Portable 的工具链</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://buildroot.org/downloads/buildroot-2025.11.tar.gz</span><br><span class="line"><span class="comment"># WSL下PATH含有空格，临时重新设置</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/usr/lib/wsl/lib</span><br><span class="line"></span><br><span class="line">tar xvf buildroot-2025.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> buildroot-2025.11</span><br><span class="line">make menucofig</span><br></pre></td></tr></table></figure><p>配置如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Target <span class="keyword">Options</span>  <span class="comment">---&gt;</span></span><br><span class="line">Target Architecture (AArch64 (little endian))  <span class="comment">---&gt; </span></span><br><span class="line"> Target Architecture Variant (cortex-A72)  <span class="comment">---&gt; </span></span><br><span class="line"> Floating <span class="type">point</span> strategy (FP-ARMv8)  <span class="comment">---&gt;</span></span><br><span class="line"> MMU Page Size (<span class="number">4</span>KB)  <span class="comment">---&gt;</span></span><br><span class="line"> Target Binary Format (ELF)  <span class="comment">---&gt; </span></span><br><span class="line"></span><br><span class="line">Toolchain  <span class="comment">---&gt;</span></span><br><span class="line">Toolchain <span class="keyword">type</span> (<span class="keyword">External</span> toolchain)  <span class="comment">---&gt;</span></span><br><span class="line">  *** Toolchain <span class="keyword">External</span> <span class="keyword">Options</span> ***                                                 </span><br><span class="line">Toolchain (Custom toolchain)  <span class="comment">---&gt;                                                         </span></span><br><span class="line">Toolchain origin (Pre-installed toolchain)  <span class="comment">---&gt; (/home/zhaohang/tools/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu) Toolchain path       </span></span><br><span class="line">($(ARCH)-<span class="keyword">none</span>-linux-gnu) Toolchain prefix                                                      </span><br><span class="line"><span class="keyword">External</span> toolchain gcc version (<span class="number">11.</span>x)  <span class="comment">---&gt;                                                </span></span><br><span class="line"><span class="keyword">External</span> toolchain kernel headers series (<span class="number">4.20</span>.x)  <span class="comment">---&gt;                                    </span></span><br><span class="line"><span class="keyword">External</span> toolchain C library (glibc)  <span class="comment">---&gt;                                                 </span></span><br><span class="line">[*] Toolchain has SSP support? (<span class="built_in">NEW</span>)                                                           </span><br><span class="line">[*]   Toolchain has SSP strong support? (<span class="built_in">NEW</span>)                                                  </span><br><span class="line">[ ] Toolchain has RPC support? (<span class="built_in">NEW</span>)                                                           </span><br><span class="line">[*] Toolchain has C++ support?                                                                 </span><br><span class="line">[ ] Toolchain has D support? (<span class="built_in">NEW</span>)                                                             </span><br><span class="line">[*] Toolchain has Fortran support?                                                             </span><br><span class="line">[*] Toolchain has OpenMP support?                                                              </span><br><span class="line">[ ] <span class="keyword">Copy</span> gdb <span class="keyword">server</span> <span class="keyword">to</span> the Target (<span class="built_in">NEW</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">System</span> <span class="keyword">configuration</span>  <span class="comment">---&gt; </span></span><br><span class="line">        /dev management (Dynamic <span class="keyword">using</span> devtmpfs + mdev)  <span class="comment">---&gt; </span></span><br><span class="line">[*] <span class="keyword">Enable</span> root <span class="keyword">login</span> <span class="keyword">with</span> <span class="keyword">password</span> (<span class="built_in">NEW</span>) </span><br><span class="line">(root) Root <span class="keyword">password</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Filesystem images  <span class="comment">---&gt; </span></span><br><span class="line">[*] ext2/<span class="number">3</span>/<span class="number">4</span> root filesystem</span><br><span class="line">ext2/<span class="number">3</span>/<span class="number">4</span> variant (ext4)  <span class="comment">---&gt; </span></span><br><span class="line">(rootfs) filesystem label</span><br><span class="line">(<span class="number">512</span>M) exact size   </span><br></pre></td></tr></table></figure><p>这里kernel中的选项都不要打开（默认是不打开的），因为我们要自己编译kernel；bootloader的选项也都不要打开，因为使用qemu启动不需要bootloader。</p><blockquote><p>External toolchain kernel headers series (4.20.x) 这里指的是工具链对应的内核版本，可以在<code>gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/aarch64-none-linux-gnu/libc/usr/include/linux/version.h</code>目录查看，这里应该是4.20.x</p></blockquote><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Syu unzip cpio rsync</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>进入linux内核目录，安装驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装驱动，拷贝到根文件系统</span></span><br><span class="line"><span class="built_in">cd</span> /home/zhaohang/repository/linux/linux-5.10.y-raspi</span><br><span class="line"></span><br><span class="line"><span class="comment"># buildroot</span></span><br><span class="line">make ARCH=arm64 \</span><br><span class="line">     CROSS_COMPILE=aarch64-none-linux-gnu- \</span><br><span class="line">     INSTALL_MOD_PATH=/home/zhaohang/repository/linux/buildroot-2025.11/output/target \</span><br><span class="line">     modules_install</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 编译生成rootfs.ext4</span></span><br><span class="line"><span class="built_in">cp</span> output/images/rootfs.ext4 ~/tftp</span><br></pre></td></tr></table></figure><h2 id="yocto"><a href="#yocto" class="headerlink" title="yocto"></a>yocto</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/repository/linux/yocto</span><br><span class="line"><span class="built_in">cd</span> ~/repository/linux/yocto</span><br><span class="line"><span class="comment"># use git to cline bitbake-setup</span></span><br><span class="line">git <span class="built_in">clone</span> https://git.openembedded.org/bitbake</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> pacman -Sy chrpath diffstat inetutils rpcsvc-proto</span><br><span class="line">python3 ./bitbake/bin/bitbake-setup init --non-interactive poky-whinlatter poky distro/poky machine/qemuarm64</span><br></pre></td></tr></table></figure><blockquote><p>Yocto 不会自动识别任意外部工具链！<br>必须有一个 专门的 layer 提供对该工具链的支持（通过 <code>tcmode-*.inc</code> 和 <code>toolchain-*.conf</code> 文件）。<br>常见支持层：<code>meta-arm</code> → 支持 ARM 官方 GNU Toolchain</p></blockquote><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">distribution</button><button type="button" class="tab">BitBake layers/templates</button><button type="button" class="tab">Target Machine</button><button type="button" class="tab">Distribution configuration variants</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>Yocto Project &#x2F; OpenEmbedded 构建系统</strong> 中可用的 <strong>发行版（distribution）配置</strong></p><ol><li><p><code>poky-master</code></p><ul><li><p><strong>Poky</strong> 是 Yocto Project 的参考发行版（reference distribution）。</p></li><li><p><code>-master</code> 表示使用 <strong>最新开发主线（main branch）</strong> 的代码，即 <strong>尚未发布、正在开发中的版本</strong>。</p></li></ul></li><li><p><code>oe-nodistro-master</code></p><ul><li><p><strong>OpenEmbedded (OE)</strong> 是 Yocto Project 底层的构建框架。</p></li><li><p><code>nodistro</code> 表示“无发行版”模式——<strong>不绑定任何特定发行版策略</strong>，只提供最基础的构建能力。</p></li><li><p><code>-master</code> 同样表示使用 <strong>开发主线</strong>。</p></li></ul></li><li><p><code>oe-nodistro-whinlatter</code></p><ul><li><p>基于 <strong>OpenEmbedded</strong> 的 <code>nodistro</code> 配置；</p></li><li><p>使用 <strong>Yocto 5.3 版本代号 “whinlatter”</strong> 的稳定分支；</p></li><li><p>属于长期支持版本；</p></li><li><p><code>nodistro</code> 表示“无发行版”模式。</p></li></ul></li><li><p><code>poky-whinlatter</code></p><ul><li><p><strong>Poky 发行版</strong> 的 <strong>5.3 “whinlatter” 稳定版本</strong>；</p></li><li><p>包含完整的默认配置（如使用 systemd、RPM&#x2F;deb 包格式可选、默认工具链等）；</p></li><li><p>属于长期支持版本；</p></li><li><p>是 Yocto Project 官方测试和认证的参考平台。</p></li></ul></li></ol><blockquote><p><strong>“whinlatter” 是 Yocto Project 5.3 的代号</strong>（Yocto 版本从 4.0 开始用鸟类名称命名，5.3 &#x3D; Whinchat + Lark → “Whinlatter”）。</p></blockquote></div><div class="tab-item-content"><p><strong>BitBake 构建配置（layers &#x2F; templates）</strong></p><ol><li><p><code>poky</code></p><ul><li><p>这是 <strong>标准的 Poky 构建配置</strong>。</p></li><li><p>所有软件包（recipes）都会从源码完整构建（除非你本地已有缓存）。</p></li><li><p>安全、可靠、行为可预测。</p></li></ul></li><li><p><code>poky-with-sstate</code></p><ul><li><p>启用了 <strong>远程共享状态（shared state, sstate）缓存</strong>。</p></li><li><p>构建时会尝试从 <strong>Yocto 官方或指定的 sstate 镜像服务器</strong> 下载预编译的中间产物（如已编译的库、内核模块等），从而<strong>大幅加快构建速度</strong>。</p></li><li><p><strong>但有严格前提</strong>：</p></li><li><p>你的 <strong>本地网络必须非常稳定且带宽充足</strong>；</p></li><li><p>必须能访问外部 sstate 服务器（通常需要互联网）；</p></li><li><p>如果网络中断或镜像不匹配，可能导致构建失败或不一致；</p></li><li><p>“Use with caution” 正是提醒这一点。</p></li></ul></li></ol><blockquote><p><strong>sstate 是 Yocto 的缓存机制</strong>：它保存任务的输出（如 <code>do_compile</code> 的结果），下次构建相同内容时可直接复用，无需重做。</p></blockquote></div><div class="tab-item-content"><p><strong>目标机器（Target Machine）</strong></p><ol><li><p><code>machine/qemux86-64</code></p><ul><li><p><strong>模拟 x86_64 架构的 PC</strong>，使用 <strong>QEMU 虚拟机</strong>。</p></li><li><p>基于标准 PC 硬件模型（如 Intel&#x2F;AMD 64 位 CPU、常见外设）。</p></li></ul></li><li><p><code>machine/qemuarm64</code></p><ul><li><p><strong>模拟 ARM64（AArch64）架构</strong> 的虚拟设备（如基于 Cortex-A57 的系统）。</p></li><li><p>也通过 QEMU 运行，无需真实 ARM 板子。</p></li></ul></li><li><p><code>machine/qemuriscv64</code></p><ul><li><strong>模拟 RISC-V 64 位架构</strong> 的虚拟机。</li></ul></li><li><p><code>machine/genericarm64</code></p><ul><li><p><strong>通用 ARM64 真实硬件</strong> 的参考配置（非模拟器）。</p></li><li><p>不绑定具体板子（如 Raspberry Pi、BeagleBone），而是提供一个“通用”ARM64 BSP。</p></li><li><p>需要将生成的镜像烧录到<strong>真实的 ARM64 开发板</strong>上运行。</p></li><li><p>可能缺少特定板级驱动（如 GPU、WiFi），需自行适配。</p></li></ul></li><li><p><code>machine/genericx86-64</code></p><ul><li><p><strong>通用 x86_64 真实硬件</strong> 的参考配置（如普通 PC、Intel NUC、工控机）。</p></li><li><p>生成的镜像可直接写入 U 盘，在真实 x86_64 电脑上启动。</p></li></ul></li></ol></div><div class="tab-item-content"><p><strong>发行版配置变体（Distribution configuration variants）</strong></p><ol><li><p><code>distro/poky</code></p><ul><li><strong>标准 Poky 发行版配置</strong>。包含完整的 Linux 系统：glibc、systemd、包管理器（RPM 或 IPK）、常用工具（bash、coreutls、networking 等）。</li><li>默认使用 systemd 作为 init 系统。</li><li>适合通用开发、学习和大多数嵌入式应用场景。</li><li>镜像较大（几百 MB），但功能齐全。</li></ul></li><li><p><code>distro/poky-altcfg</code></p><ul><li><p>Poky 的替代配置（alternative configuration）。</p></li><li><p>通常用于测试不同的底层组件组合，例如：</p><ul><li>使用 <strong>musl libc</strong> 替代 glibc；</li><li>使用 <strong>busybox + sysvinit</strong> 替代 systemd；</li><li>更小的默认镜像或不同安全策略。</li></ul></li><li><p>具体行为取决于 Yocto 版本，<strong>文档较少，稳定性不如标准 Poky</strong>。</p></li><li><p>主要用于 <strong>Yocto 内部测试或高级定制场景</strong>。</p></li></ul></li><li><p><code>distro/poky-tiny</code></p><ul><li><strong>极简版 Poky</strong>，专为资源受限设备设计。</li><li>特点：<ul><li>使用 <strong>musl libc</strong>（更小、更快）；</li><li>使用 <strong>busybox + sysvinit</strong>（无 systemd）；</li><li>移除了大量非必要软件包；</li><li>最终根文件系统可小至 <strong>10–20 MB</strong>。</li></ul></li><li>功能有限：可能没有网络工具、shell 功能简化、无包管理。</li><li>适合：微控制器级应用、启动加载器后的最小环境、安全关键系统。</li></ul></li></ol></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入构建环境</span></span><br><span class="line"><span class="built_in">cd</span> /home/zhaohang/repository/linux/yocto/bitbake-builds/poky-whinlatter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line"><span class="comment"># 生成文件系统的格式</span></span><br><span class="line">emacs build/conf/local.conf</span><br><span class="line"><span class="comment"># 添加下面内容</span></span><br><span class="line">IMAGE_FSTYPES = <span class="string">&quot;ext4 cpio.gz&quot;</span></span><br><span class="line"><span class="comment"># 指定工具链安装路径</span></span><br><span class="line"><span class="comment"># EXTERNAL_TOOLCHAIN = &quot;/home/zhaohang/tools/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活当前构建</span></span><br><span class="line"><span class="built_in">source</span> ./build/init-build-env</span><br><span class="line"><span class="comment"># 检测当前配置</span></span><br><span class="line">bitbake-config-build list-fragments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建最小 rootfs</span></span><br><span class="line">bitbake core-image-minimal</span><br></pre></td></tr></table></figure><h1 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h1><p><strong>内核模块示例代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_world_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_world_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;hello world module exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_world_init);</span><br><span class="line">module_exit(hello_world_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@outlook.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="external-module"><a href="#external-module" class="headerlink" title="external module"></a>external module</h2><blockquote><p>这里以busybox根文件系统为例</p></blockquote><p><strong>Makefile</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">DRIVER_NAME := hello_world</span><br><span class="line"></span><br><span class="line">obj-m += <span class="variable">$(DRIVER_NAME)</span>.o</span><br><span class="line">KERNEL_SRC:=/home/zhaohang/repository/linux/linux-5.10.y-raspi</span><br><span class="line"></span><br><span class="line">PWD ?=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">ARCH = arm64</span><br><span class="line">CROSS_COMPILE = aarch64-none-linux-gnu-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">all: build</span></span><br><span class="line"></span><br><span class="line"><span class="section">build:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=<span class="variable">$(ARCH)</span> CROSS_COMPILE=<span class="variable">$(CROSS_COMPILE)</span> -C <span class="variable">$(KERNEL_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> ARCH=<span class="variable">$(ARCH)</span> CROSS_COMPILE=<span class="variable">$(CROSS_COMPILE)</span> -C <span class="variable">$(KERNEL_SRC)</span> M=<span class="variable">$(PWD)</span> modules clean</span><br><span class="line">rm -rf *.ko *.o *.mod.o *.mod.c *.symvers *.order .tmp*</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all deploy qemu</span></span><br><span class="line"><span class="section">deploy:</span></span><br><span class="line">cp <span class="variable">$(DRIVER_NAME)</span>.ko /home/zhaohang/repository/linux/busybox-1.37.0/_install</span><br><span class="line">/bin/bash /home/zhaohang/repository/linux/busybox-1.37.0/deploy.sh</span><br><span class="line"></span><br><span class="line"><span class="section">qemu:</span></span><br><span class="line">qemu-system-aarch64 \</span><br><span class="line">-M raspi4b \</span><br><span class="line">-cpu cortex-a72 \</span><br><span class="line">-m 2G \</span><br><span class="line">-nographic \</span><br><span class="line">-kernel /home/zhaohang/tftp/raspi4b/Image \</span><br><span class="line">-dtb /home/zhaohang/tftp/raspi4b/bcm2711-rpi-4-b.dtb \</span><br><span class="line">-initrd /home/zhaohang/tftp/initramfs.cpio.gz \</span><br><span class="line">-append <span class="string">&quot;console=ttyAMA0 earlycon=pl011,0xfe201000 rdinit=/linuxrc&quot;</span></span><br></pre></td></tr></table></figure><p>其中打包根文件系统的脚本<code>deploy.sh</code>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">INSTALL_PATH=/home/zhaohang/repository/linux/busybox-1.37.0/_install</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$INSTALL_PATH</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf ../initramfs.cpio.gz ~/tftp/initramfs.cpio.gz</span><br><span class="line"></span><br><span class="line">find . | cpio -o -H newc | gzip -c &gt; ../initramfs.cpio.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> ../initramfs.cpio.gz ~/tftp</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cp initramfs.cpio.gz ~/tftp&quot;</span></span><br></pre></td></tr></table></figure><p>遇到一个问题是在WSL2 archlinux 上用 aarch64-linux-gnu-gcc 编译时没 print（aarch64-none-linux-gnu-gcc也不行），目前没找到解决办法，在 stackoverflow 上详细描述了具体问题：</p><div class="tag link"><a class="link-card" title="No gcc compiling log CC [M] showing up" href="https://stackoverflow.com/questions/79858012/"><div class="left"><img src="https://stackoverflow.com/Content/Sites/stackoverflow/Img/favicon.ico"/></div><div class="right"><p class="text">No gcc compiling log CC [M] showing up</p><p class="url">https://stackoverflow.com/questions/79858012/</p></div></a></div><p>而使用WSL2 Ubuntu20.04时没有这个问题。</p><h2 id="built-in-module"><a href="#built-in-module" class="headerlink" title="built-in module"></a>built-in module</h2><p>在<code>drivers/char</code>(以字符驱动为例)创建文件夹helloworld，然后将驱动源代码放入，然后创建Kconfig文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config HELLO_WORLD</span><br><span class="line">  bool &quot;helloworld support&quot;</span><br><span class="line">  default y</span><br><span class="line">  help</span><br><span class="line">      helloworld</span><br></pre></td></tr></table></figure><p>更改drivers</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emacs ../Kconfig</span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;drivers/char/helloworld/Kconfig&quot;</span></span><br></pre></td></tr></table></figure><p>在驱动源码里创建Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_helloworld)</span> += helloworld.o</span><br></pre></td></tr></table></figure><p>然后在上一级的Makefile中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">emacs ../Makefile</span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">obj-y += helloworld/</span><br></pre></td></tr></table></figure><p>然后编译内核即可</p><h1 id="qemu-运行"><a href="#qemu-运行" class="headerlink" title="qemu 运行"></a>qemu 运行</h1><p>qemu版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> pacman -Syu qemu-system-aarch64</span><br><span class="line">$ qemu-system-aarch64 --version</span><br><span class="line">QEMU emulator version 10.1.2</span><br><span class="line">Copyright (c) 2003-2025 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><h2 id="busybox-根文件系统"><a href="#busybox-根文件系统" class="headerlink" title="busybox 根文件系统"></a>busybox 根文件系统</h2><p>busybox这里我们编译成initramfs.cpio.gz，作为initrd参数的值。</p><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">  -M raspi4b \</span><br><span class="line">  -cpu cortex-a72 \</span><br><span class="line">  -m 2G \</span><br><span class="line">  -nographic \</span><br><span class="line">  -kernel /home/zhaohang/tftp/raspi4b/Image \</span><br><span class="line">  -dtb /home/zhaohang/tftp/raspi4b/bcm2711-rpi-4-b.dtb \</span><br><span class="line">  -initrd /home/zhaohang/tftp/initramfs.cpio.gz \</span><br><span class="line">  -append <span class="string">&quot;console=ttyAMA0 earlycon=pl011,0xfe201000 rdinit=/linuxrc&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>按<kbd>command</kbd> + <kbd>a</kbd>, 然后按 <kbd>x</kbd> 可以退出qemu</p></blockquote><h2 id="buildroot-根文件系统"><a href="#buildroot-根文件系统" class="headerlink" title="buildroot 根文件系统"></a>buildroot 根文件系统</h2><p>buildroot这里我们使用sd卡挂载文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-system-aarch64 \</span><br><span class="line">  -M raspi4b \</span><br><span class="line">  -cpu cortex-a72 \</span><br><span class="line">  -m 2G \</span><br><span class="line">  -nographic \</span><br><span class="line">  -kernel /home/zhaohang/tftp/raspi4b/Image \</span><br><span class="line">  -dtb /home/zhaohang/tftp/raspi4b/bcm2711-rpi-4-b.dtb \</span><br><span class="line">  -sd /home/zhaohang/tftp/rootfs.ext4 \</span><br><span class="line">  -append <span class="string">&quot;console=ttyAMA0 earlycon=pl011,0xfe201000 root=/dev/mmcblk1 rw rootwait&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>按<kbd>command</kbd> + <kbd>a</kbd>, 然后按 <kbd>x</kbd> 可以退出qemu</p></blockquote><h2 id="Yocto-根文件系统"><a href="#Yocto-根文件系统" class="headerlink" title="Yocto 根文件系统"></a>Yocto 根文件系统</h2><p>使用initramfs.cpio.gz或使用sd卡挂载文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-system-aarch64 \</span><br><span class="line">  -M raspi4b \</span><br><span class="line">  -cpu cortex-a72 \</span><br><span class="line">  -m 2G \</span><br><span class="line">  -nographic \</span><br><span class="line">  -kernel /home/zhaohang/tftp/raspi4b/Image \</span><br><span class="line">  -dtb /home/zhaohang/tftp/raspi4b/bcm2711-rpi-4-b.dtb \</span><br><span class="line">  -initrd /home/zhaohang/repository/linux/yocto/bitbake-builds/poky-whinlatter/build/tmp/deploy/images/qemuarm64/core-image-minimal-qemuarm64.rootfs.cpio.gz \</span><br><span class="line">  -append <span class="string">&quot;console=ttyAMA0 earlycon=pl011,0xfe201000 init=/sbin/init&quot;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://blog.colorfulshark.net/2021/01/30/boot-kernel-in-uboot-from-qemu.html">在QEMU中启动U-Boot和内核</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.bytezonex.com/archives/HrA7LCDC.html">Arch Linux下使用预装工具链配置Buildroot的解决方案</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html">Yocto Project</a></div>]]></content>
    
    
    <summary type="html">在Qemu上跑树莓派4b，使用Linux5.10内核，根文件系统使用busybox,buildroot或yocto，并用简单内核模块在Qemu上验证</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="qemu" scheme="https://even629.com/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>Linux SPI</title>
    <link href="https://even629.com/posts/2512303/"/>
    <id>https://even629.com/posts/2512303/</id>
    <published>2025-12-30T06:35:13.000Z</published>
    <updated>2025-12-30T06:35:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-30</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="SPI基础"><a href="#SPI基础" class="headerlink" title="SPI基础"></a>SPI基础</h1><h2 id="SPI特点"><a href="#SPI特点" class="headerlink" title="SPI特点"></a>SPI特点</h2><p>SPI（Serial Peripheral Interface）最初是由摩托罗拉公司在上世纪 80 年代末期提出和开发的一种串行通信协议。当时,随着微控制器技术的发展,越来越多的外围设备需要与微控制器进行数据交换。</p><p>但传统的并行总线接口存在着引脚数量多、接线麻烦、功耗高等问题,不太适合嵌入式系统的需求。</p><p>为此,摩托罗拉公司设计了 SPI 这种简单高效的串行通信总线协议,以解决当时嵌入式系统中通信接口的痛点。SPI 的核心设计思路如下:</p><ul><li><p><strong>使用最少的引脚数实现全双工通信</strong></p><ul><li><p><strong>单工通信</strong>： 指信号只在一个方向上传输，仅能发送或接收</p></li><li><p><strong>半双工通信</strong>：信号可以在俩个方向上传输，但某一个时刻只允许发送或接收(单总线和 I2C 都是半双工通信)</p></li><li><p><strong>全双工通信</strong>：全双工通信指数据同时在两个方向上传输，SPI 只需要 4 根信号线(<strong>SCLK、MOSI、MISO、CS</strong>)即可完成主从设备之间的数据交换，实现全双工通信。这大大减少了引脚数,简化了接线。</p></li></ul></li><li><p><strong>采用同步通信机制</strong></p><ul><li><p><strong>同步通信</strong>: <strong>指数据传输的发送方和接收方使用相同的时钟信号进行协调</strong>。每<strong>个时钟周期都会发送或接收一个数据位</strong>，因此，数据传输严格依赖于时钟信号的节奏。</p></li><li><p><strong>异步通信</strong>: <strong>不依赖一个共同的时钟信号进行数据传输</strong>，发送方和接收方独立运行，通过特定的协议进行数据同步，具体示意图如下所示：</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143841712.png" alt="并行通信与串行通信" loading="lazy"></p><ul><li><p><strong>主从结构设计</strong>: SPI 协议将通信设备分为主设备和从设备</p><ul><li>主设备负责<strong>提供时钟信号和控制通信过程</strong></li><li>从设备<strong>被动响应主设备的操作。</strong></li></ul></li><li><p><strong>支持多从设备接入</strong>: SPI 有多种连接模式，主要分为常规模式和菊花链模式（菊花链模式不常用），</p><ul><li><p>在<strong>常规模式</strong>下，每个从设备（Slave）都有独立的片选（Chip Select, CS）信号线。主设备（Master）通过拉低相应的 CS 线来选择从设备进行通信，具体示意图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143854714.png" alt="常规模式" loading="lazy"></p></li><li><p><strong>菊花链模式</strong>下，<wavy>从设备会串联在一起</wavy>，数据从主设备传输到第一个从设备，然后从第一个从设备传输到下一个，从而形成链式结构，具体连接示意图如下所示：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143907231.png" alt="菊花链模式" loading="lazy"></p></li></ul><h2 id="SPI硬件连接"><a href="#SPI硬件连接" class="headerlink" title="SPI硬件连接"></a>SPI硬件连接</h2><p> SPI 使用 4 根信号线进行通信,分别是 <strong>SCLK</strong>、<strong>MOSI</strong>、<strong>MISO</strong> 和 <strong>CS</strong>，现在对每根信号线的具体作用和功能进行介绍。</p><ul><li><strong>SCLK (Serial Clock)：时钟信号线</strong></li></ul><p>这是由主设备产生的同步时钟信号,用于驱动数据的收发。<emp>主设备负责提供稳定的时钟信号,频率可以根据需要进行调整</emp>。从设备需要使用这个时钟信号来对齐和采样数据。</p><ul><li><strong>MOSI (Master Output Slave Input)：主-&gt;从数据传输线</strong></li></ul><p>这是主设备向从设备传输数据的线路。主设备将要发送的数据放在这条线上,从设备则从这条线上读取数据。</p><ul><li><strong>MISO (Master Input Slave Output)：从-&gt;主数据传输线</strong></li></ul><p>这是从设备向主设备传输数据的线路。从设备将要发送的数据放在这条线上,主设备则从这条线上读取数据。</p><ul><li><strong>CS (Chip Select) 或 SS (Slave Select)：片选&#x2F;从设备选择信号</strong></li></ul><p>这是主设备用来选择与之通信的从设备的信号线。当主设备拉低某个从设备的 CS&#x2F;SS 线时,表示选中了该从设备进行通信。主设备可以通过控制多个 CS&#x2F;SS 线来选择与不同从设备通信。</p><p>主设备和从设备之间的连接关系如下所示:</p><ul><li><p>SCLK 线连接主设备的 SCLK 输出到从设备的 SCLK 输入</p></li><li><p>MOSI 线连接主设备的 MOSI 输出到从设备的 MOSI 输入</p></li><li><p>MISO 线连接主设备的 MISO 输入到从设备的 MISO 输出</p></li><li><p>CS&#x2F;SS 线连接主设备的片选输出到从设备的片选输入</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143913697.png" alt="主设备和从设备之间的连接关系" loading="lazy"></p><h2 id="SPI-通信原理"><a href="#SPI-通信原理" class="headerlink" title="SPI 通信原理"></a>SPI 通信原理</h2><p>SPI 总线在进行数据传输时，具有以下特点：</p><ul><li><strong>传输顺序</strong>：默认情况下，SPI 总线先传输高位（MSB，Most Significant Bit），然后传输低位（LSB，Least Significant Bit）。</li><li><strong>逻辑电平</strong>：数据线为高电平表示逻辑 1，数据线为低电平表示逻辑 0。</li><li><strong>字节传输</strong>：<wavy>一个字节传输完成之后，无需应答信号即可开启下一个字节的传输。</wavy></li></ul><p>SPI 是单通信协议，意味着总线中只有一个主设备能发起通信，而 SPI 主设备和从设备都有一个<strong>串行移位寄存器</strong>，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143920334.png" alt="SPI 主设备和从设备都有一个串行移位寄存器" loading="lazy"></p><p>当 SPI 主设备想读&#x2F;写从设备时，它<strong>首先要拉低从设备对应的 CS 线</strong>（CS 线是低电平有效），接着开始发送工作脉冲到时钟线上，在相应的脉冲时间上，<strong>主设备把信号发送到 MOSI 实现“写”，同时可对 MISO 采样实现“读”</strong>。</p><p><strong>在一个 SPI时钟周期内，收发是同时进行的</strong>：</p><ul><li>主机通过 MOSI 线发送 1bit 数据，从机通过该线读取这 1bit数据；</li><li>从机通过 MISO 线发送 1bit 数据，主机通过该线读取这 1bit 数据；</li></ul><p>当寄存器中的内容全部移出时，相当于完成了俩个寄存器内容的交换。如果主设备要给从设备传输数据，主设备只需要忽略掉从设备接收到的数据即可。如果主设备要从从设备接收数据，主设备向从设备随机发送数据，从设备忽略掉从主设备接收的数据即可。</p><h2 id="SPI极性和相位"><a href="#SPI极性和相位" class="headerlink" title="SPI极性和相位"></a>SPI极性和相位</h2><p>在 SPI 的通信之前需要先<strong>确定时钟信号的默认状态</strong>以及<strong>时钟信号的采样时间</strong>，这两个参数由 **CPOL(时钟极性 Clock Polarity)**和 **CPHA(时钟相位 Clock Phase)**来确定</p><ol><li><strong>CPOL(时钟极性 Clock Polarity)</strong>：CPOL 定义了<emp>时钟信号的默认状态(即空闲状态)</emp>。<ul><li>CPOL &#x3D; 0 时,表示时钟信号在空闲状态下为低电平(0)。</li><li>CPOL &#x3D; 1 时,表示时钟信号在空闲状态下为高电平(1)。</li></ul></li><li><strong>CPHA(时钟相位 Clock Phase)</strong>：CPHA 定义了<emp>数据信号相对于时钟信号的采样时间</emp>。<ul><li>CPHA &#x3D; 0 时,表示数据在时钟的<strong>第一个边沿(上升或下降)被采样</strong>。</li><li>CPHA &#x3D; 1 时,表示数据在时钟的<strong>第二个边沿(上升或下降)被采样</strong>。</li></ul></li></ol><p>四种组合模式：</p><ol><li>CPOL&#x3D;0, CPHA&#x3D;0: 时钟空闲为低电平,数据在时钟的第一个边沿(上升沿)被采样</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144110634.png" alt="CPOL&#x3D;0, CPHA&#x3D;0" loading="lazy"></p><ol start="2"><li>CPOL&#x3D;0, CPHA&#x3D;1: 时钟空闲为低电平,数据在时钟的第二个边沿(下降沿)被采样</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144106614.png" alt="CPOL&#x3D;0, CPHA&#x3D;1" loading="lazy"></p><ol start="3"><li>CPOL&#x3D;1, CPHA&#x3D;0: 时钟空闲为高电平,数据在时钟的第一个边沿(下降沿)被采样</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143935687.png" alt="CPOL&#x3D;1, CPHA&#x3D;0" loading="lazy"></p><ol start="4"><li>CPOL&#x3D;1, CPHA&#x3D;1: 时钟空闲为高电平,数据在时钟的第二个边沿(上升沿)被采样</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143940236.png" alt="CPOL&#x3D;1, CPHA&#x3D;1" loading="lazy"></p><blockquote><p>注意：<strong>主设备和从设备必须配置相同的 CPOL 和 CPHA,否则无法正常通信。</strong></p><p>而在一般情况下,主设备会配置 CPOL 和 CPHA,从设备则需要根据主设备的设置进行匹配</p></blockquote><h2 id="iTOP-RK3568-处理器中的-SPI-接口"><a href="#iTOP-RK3568-处理器中的-SPI-接口" class="headerlink" title="iTOP-RK3568 处理器中的 SPI 接口"></a>iTOP-RK3568 处理器中的 SPI 接口</h2><p>iTOP-RK3568支持 4 个 SPI 控制器</p><ul><li>1 个控制器支持 1 个片选输出其余 3 个控制器各支持 2 个片选输出</li><li>支持主机模式和从机模式,可通过软件进行配置切换</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230143947810.png" alt="RK3568核心板Datasheet" loading="lazy"></p><p>其中这里的 4 路 SPI 接口指的是硬件 SPI，在 SOC 上有专用的硬件 SPI 电路，关于硬件 I2C的介绍如下所示：</p><p><strong>硬件 SPI</strong>:</p><ul><li>实现方式: 通过专门的硬件电路来实现 SPI 通信协议。</li><li>优点:<ul><li>CPU 占用低: SPI 总线由硬件电路自动完成，CPU 无需直接介入。</li><li>传输速率高: 可以达到几十 MHz 甚至更高的通信速率。</li><li>灵活配置: 硬件 SPI 通常提供 CPOL 和 CPHA 的配置选项，用于设置时钟极性和相位。</li></ul></li><li>缺点:<ul><li>需要专用硬件: 需要专用的硬件 SPI 接口模块支持，成本相对较高。</li><li>接口固定: 接口固定，不如软件 SPI 灵活。</li></ul></li><li>适用范围: 适用于高速、大量数据传输的场合，如 LCD、EEPROM 等外设的连接。</li></ul><p>软件 SPI 指的是通过 GPIO 口模拟 SPI 的四根信号线，在硬件 SPI 不够用的情况下，可以通过 GPIO 来模拟软件 SPI,关于软件 SPI 的介绍如下所示：</p><p><strong>软件 SPI:</strong></p><ul><li>实现方式: 通过 CPU 的 GPIO 引脚模拟 SPI 通信协议。</li><li>优点<ul><li>灵活性高: 可以灵活配置 CPOL 和 CPHA，适用于高度定制化的 SPI 通信。</li><li>无专用硬件要求: 不需要专用的硬件 SPI 接口模块，适用于没有内置硬件 SPI 接口的系统。</li></ul></li><li>缺点:<ul><li>CPU 占用高: 需要 CPU 程序完成时钟信号的生成、数据的读写等全部操作。</li><li>传输速率低: 速度受到 CPU 执行程序的速度限制，通常较硬件 SPI 要慢。</li></ul></li><li>适用范围: 适用于没有内置硬件 SPI 接口的系统，或需要高度定制化 SPI 通信的场景。</li></ul><p>RK3568 开发板上的 SPI 接口具体使用情况如下表所示</p><h3 id="SPI0"><a href="#SPI0" class="headerlink" title="SPI0"></a><strong>SPI0</strong></h3><table><thead><tr><th>pinctrl function</th><th>网络标号</th><th>对应的 GPIO</th><th>功能</th></tr></thead><tbody><tr><td>SPI0_CLK_M0</td><td>TP_INT_L_GPI00_B5</td><td>GPIO00_B5</td><td>PCIE2.0 唤醒</td></tr><tr><td>SPI0_MISO_M0</td><td>LCD1_PWREN_H_GPI00_C5</td><td>GPIO00_C5</td><td>未使用</td></tr><tr><td>SPI0_MOSI_M0</td><td>TP_RST_L_GPI00_B6</td><td>GPIO00_B6</td><td>MIPI 屏幕触摸复位引脚</td></tr><tr><td>SPI0_CS0_M0</td><td>4G_PWREN_H_GPI00_C6</td><td>GPIO00_C6</td><td>未使用</td></tr><tr><td>SPI0_CS1_M0</td><td>LCD1_BL_PWM5</td><td>GPIO00_C4</td><td>MIPI 屏幕使能引脚</td></tr><tr><td>SPI0_CLK_M1</td><td>PCIE30X1_WAKEn_M1</td><td>GPIO2_D3</td><td>底板背面 SPI</td></tr><tr><td>SPI0_MISO_M1</td><td>PCIE20_CLKREQn_M1</td><td>GPIO2_D0</td><td>底板背面 SPI</td></tr><tr><td>SPI0_MOSI_M1</td><td>PCIE20_WAKEn_M1</td><td>GPIO2_D1</td><td>底板背面 SPI</td></tr><tr><td>SPI0_CS0_M1</td><td>PCIE30X1_CLKREQn_M1</td><td>GPIO2_D2</td><td>底板背面 SPI</td></tr></tbody></table><h3 id="SPI1"><a href="#SPI1" class="headerlink" title="SPI1"></a><strong>SPI1</strong></h3><table><thead><tr><th>pinctrl function</th><th>网络标号</th><th>对应的 GPIO</th><th>功能</th></tr></thead><tbody><tr><td>SPI1_CLK_M0</td><td>GMAC0_TXEN</td><td>GPIO2_B5</td><td>网口 0</td></tr><tr><td>SPI1_MISO_M0</td><td>GMAC0_RXD0</td><td>GPIO2_B6</td><td>网口 0</td></tr><tr><td>SPI1_MOSI_M0</td><td>GMAC0_RXD1</td><td>GPIO2_B7</td><td>网口 0</td></tr><tr><td>SPI1_CS0_M0</td><td>GMAC0_RXDV_CRS</td><td>GPIO2_C0</td><td>网口 0</td></tr><tr><td>SPI1_CS1_M0</td><td>CLK32K_OUT1_WIFI</td><td>GPIO2_C6</td><td>未使用</td></tr><tr><td>SPI1_CLK_M1</td><td>GMAC0_TXEN</td><td>GPIO3_C3</td><td>网口 0</td></tr><tr><td>SPI1_MISO_M1</td><td>SPK_CTL_H_GPI03_C3</td><td>GPIO2_B6</td><td>5G 复位</td></tr><tr><td>SPI1_MOSI_M1</td><td>PCIE20_PERSTn_M1</td><td>GPIO3_C1</td><td>未使用</td></tr><tr><td>SPI1_CS0_M1</td><td>PCIE30X1_PERSTn_M1</td><td>GPIO3_A1</td><td>未使用</td></tr></tbody></table><h3 id="SPI2"><a href="#SPI2" class="headerlink" title="SPI2"></a><strong>SPI2</strong></h3><table><thead><tr><th>pinctrl function</th><th>网络标号</th><th>对应的 GPIO</th><th>功能</th></tr></thead><tbody><tr><td>SPI2_CLK_M0</td><td>ETH0_REFCLK0_25M</td><td>GPIO2_C1</td><td>网口 0 时钟</td></tr><tr><td>SPI2_MISO_M0</td><td>GMAC0_MCLKINOUT</td><td>GPIO2_C2</td><td>网口 0 时钟</td></tr><tr><td>SPI2_MOSI_M0</td><td>GMAC0_MDC</td><td>GPIO2_C3</td><td>网口 0</td></tr><tr><td>SPI2_CS0_M0</td><td>GMAC0_MDIO</td><td>GPIO2_C4</td><td>网口 0</td></tr><tr><td>SPI2_CS1_M0</td><td>GPIO2_C5</td><td>GPIO2_C5</td><td>PCIE 电源使能引脚</td></tr><tr><td>SPI2_CLK_M1</td><td>PCIE30X1_PRSNT_L_GPI03_A0</td><td>GPIO3_A0</td><td>PCIE2.0</td></tr><tr><td>SPI2_MISO_M1</td><td>PCIE30X2_PRSNT_L_GPI02_D7</td><td>GPIO2_D7</td><td>PCIE3.0</td></tr><tr><td>SPI2_MOSI_M1</td><td>PCIE30X2_PERSTn_M1</td><td>GPIO2_D6</td><td>PCIE3.0</td></tr><tr><td>SPI2_CS0_M1</td><td>PCIE30X2_WAKEn_M1</td><td>GPIO2_D5</td><td>PCIE3.0</td></tr><tr><td>SPI2_CS1_M1</td><td>PCIE30X2_CLKREQn_M1</td><td>GPIO2_D4</td><td>PCIE3.0</td></tr></tbody></table><h3 id="SPI3"><a href="#SPI3" class="headerlink" title="SPI3"></a><strong>SPI3</strong></h3><table><thead><tr><th>pinctrl function</th><th>网络标号</th><th>对应的 GPIO</th><th>功能</th></tr></thead><tbody><tr><td>SPI3_CLK_M0</td><td>ETH1_REFCLK0_25M_M1</td><td>GPIO4_B3</td><td>网口 1 时钟</td></tr><tr><td>SPI3_MISO_M0</td><td>GMAC1_RXD1_M1</td><td>GPIO4_B0</td><td>网口 1</td></tr><tr><td>SPI3_MOSI_M0</td><td>GPIO4_B2</td><td>GPIO4_B2</td><td>未使用</td></tr><tr><td>SPI3_CS0_M0</td><td>GMAC1_TXEN_M1</td><td>GPIO4_A6</td><td>网口 1</td></tr><tr><td>SPI3_CS1_M0</td><td>GMAC1_RXD0_M1</td><td>GPIO4_A7</td><td>网口 1</td></tr><tr><td>SPI3_CLK_M1</td><td>4G_DISABLE_GPI04_C2</td><td>GPIO4_C2</td><td>CAN1_RX</td></tr><tr><td>SPI3_MISO_M1</td><td>GPIO4_C5</td><td>GPIO4_C5</td><td>未使用</td></tr><tr><td>SPI3_MOSI_M1</td><td>HDMI_RX_INT_L_GPI04_C3</td><td>GPIO4_C3</td><td>CAN1_TX</td></tr><tr><td>SPI3_CS0_M1</td><td>GPIO4_C6</td><td>GPIO4_C6</td><td>未使用</td></tr><tr><td>SPI3_CS1_M1</td><td>HDMI_TX_CEC_M0</td><td>GPIO4_D1</td><td>HDMI CEC 引脚</td></tr></tbody></table><p><strong>每个 SPI 控制器各自有两组 pinctrl，但某一个硬件 SPI 只能由一组 pinctrl 引脚进行复用</strong>。</p><h2 id="mcp2515"><a href="#mcp2515" class="headerlink" title="mcp2515"></a>mcp2515</h2><p>该模块不仅可以实现 SPI 转 CAN 的功能，还可以实现 TTL 转 485 的功能，相关的原理图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144004882.png" alt="mcp2515" loading="lazy"></p><p>上述原理图中总共涉及到了两个芯片，分别为 <strong>MCP2515 SPI 转 CAN 芯片</strong>和 <strong>MCP2551 CAN 收发器芯片</strong>，这里主要对 MCP2515 芯片进行介绍。</p><p>MCP2515 是一款独立的 CAN 协议控制器，完全支持 CAN V2.0B 技术规范。它通过标准的SPI 接口与控制器连接。主要特点如下：</p><ol><li>完全支持 CAN V2.0B：支持标准和扩展数据帧及远程帧的发送和接收。</li><li>高效的滤波功能：内置两个验收屏蔽寄存器和六个验收滤波寄存器，可以过滤掉不需要的报文，减少主 MCU 的处理负担。</li><li>SPI 接口：通过 SPI 接口与主控制器进行通信，提供高效的数据传输。</li><li>多种操作模式：包括正常模式、休眠模式、监听模式和环回模式，以满足不同应用需求。</li><li>自动重传：在发送失败时自动重传，确保数据传输的可靠性。</li><li>错误检测和处理：内置错误检测和处理机制，保证数据传输的准确性。</li></ol><p>SPI 转 CAN 模块与 iTOP-RK3568 开发板具体的连接示意图如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144017427.png" alt="SPI 转 CAN 模块与 iTOP-RK3568 开发板具体的连接" loading="lazy"></p><h1 id="SPI子系统框架"><a href="#SPI子系统框架" class="headerlink" title="SPI子系统框架"></a>SPI子系统框架</h1><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144021289.png" alt="SPI 子系统框架" loading="lazy"></p><p>可以将上面这一 SPI 子系统划分为三个层次，分别为用户空间、内核空间和硬件层，内核空间就包括 SPI 设备驱动层、SPI 核心层和 SPI 适配器驱动层，而本章的主要内容就是介绍 SPI 子系统框架中的内核空间。</p><h2 id="SPI设备驱动层"><a href="#SPI设备驱动层" class="headerlink" title="SPI设备驱动层"></a>SPI设备驱动层</h2><p>SPI 设备驱动层的主要作用是编写驱动程序，使 SPI 外设能够正常工作。它创建了对应的设备节点，提供了标准化的接口，使得上层应用程序能够方便地与 SPI 设备进行交互。</p><p>具体来说，SPI 设备驱动层包含以下几个关键部分：</p><ul><li><code>spi_device</code><ul><li>代表一个连接到 SPI 总线上的从设备</li><li>包含从设备的地址、所属的 SPI 主设备等信息。</li></ul></li><li><code>/dev/spiX</code> 设备节点<ul><li>为上层应用程序提供设备访问的接口</li><li>通过打开&#x2F;读写&#x2F;控制设备节点，应用程序可以与 SPI 设备进行交互。</li><li>内核 SPI 子系统负责将应用程序的操作转发到对应的 spi_driver。</li></ul></li><li><code>spi_driver</code><ul><li>实现了具体 SPI 从设备的驱动程序</li><li>负责设备的初始化、读写、配置等操作。</li><li>通过 spi_device 与设备进行交互。</li><li>向上层提供设备访问的标准化接口。</li></ul></li></ul><h2 id="SPI适配器驱动层"><a href="#SPI适配器驱动层" class="headerlink" title="SPI适配器驱动层"></a>SPI适配器驱动层</h2><p>SPI 适配器驱动层是 SPI 子系统的重要组成部分，负责实现具体的 SPI 硬件控制器的驱动程序。SPI 适配器驱动程序的作用如下：</p><ul><li><strong>提供标准化的 SPI 传输接口</strong><ul><li>适配器驱动层为 SPI 核心层提供标准化的传输接口，确保不同的 SPI 控制器可以统一使用这些接口进行数据传输。</li></ul></li><li><strong>实现 SPI 总线协议的时序控制和数据收发</strong><ul><li>负责实现 SPI 总线协议的时序控制，包括时钟极性（CPOL）和时钟相位（CPHA）的配置。</li><li>管理数据的发送和接收，确保数据传输的准确性和可靠性。</li><li>通过硬件 SPI 模块自动完成时钟信号的生成和数据收发，提高通信效率。</li></ul></li><li><strong>管理 SPI 总线上的从设备</strong><ul><li>适配器驱动层负责管理 SPI 总线上的所有从设备，包括注册和注销从设备。</li><li>确保 SPI 总线上的从设备可以正确地进行通信，协调主设备和从设备之间的交互。</li></ul></li><li><strong>处理 SPI 总线错误和异常情况</strong><ul><li>适配器驱动层负责监控和处理 SPI 总线上的错误和异常情况。</li><li>提供错误恢复和重试机制，确保系统的稳定性和可靠性。</li><li>处理硬件中断，及时响应数据传输中的各种异常情况。</li></ul></li></ul><h2 id="SPI-核心层"><a href="#SPI-核心层" class="headerlink" title="SPI 核心层"></a>SPI 核心层</h2><p>SPI 核心层位于 SPI 设备驱动层和 SPI 适配器驱动层之间，起到了承上启下的作用，负责SPI 设备驱动层和 SPI 适配器驱动层之间的数据传递。</p><p>SPI 核心层的主要函数为 <code>spi_write</code> 和<code>spi_read</code>，这些函数提供了基本的读写接口。核心函数介绍：</p><ul><li><code>spi_write</code><ul><li>函数作用：用于向 SPI 从设备发送数据。</li><li>函数参数介绍：<ul><li><code>struct spi_device *spi</code>: 指向目标 SPI 从设备的指针。</li><li><code>const void *buf</code>: 数据缓冲区。</li><li><code>size_t len</code>: 要发送的字节数。</li></ul></li><li>这个函数负责生成符合 SPI 协议的时序和数据帧，并通过对应的 SPI 适配器驱动程序进行实际的总线操作。</li></ul></li><li><code>spi_read</code><ul><li>函数作用：用于从 SPI 从设备接收数据。</li><li>函数参数介绍：<ul><li><code>struct spi_device *spi</code>: 指向目标 SPI 从设备的指针。</li><li><code>void *buf</code>: 数据缓冲区。</li><li><code>size_t len</code>: 要接收的字节数。</li></ul></li><li>这个函数同样负责生成符合 SPI 协议的时序和数据帧，并通过对应的 SPI 适配器驱动程序进行实际的总线操作。</li></ul></li></ul><p>核心层的具体作用如下：</p><ul><li>核心层负责在设备驱动层和适配器驱动层之间传递数据。通过 <code>spi_write</code> 和 <code>spi_read</code>函数，核心层将设备驱动层的数据传递给适配器驱动层进行实际的硬件操作。</li><li>核心层生成符合 SPI 协议的时序和数据帧，确保数据能够正确地在 SPI 总线上传输。</li><li>核心层提供标准化的接口，使得上层的设备驱动程序可以方便地进行数据传输，而无需关心底层硬件的具体实现。</li></ul><h1 id="通用SPI外设框架编写"><a href="#通用SPI外设框架编写" class="headerlink" title="通用SPI外设框架编写"></a>通用SPI外设框架编写</h1><h2 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h2><p>SPI 转 CAN 模块要接的 iTOP-RK3568 的引脚</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144030581.png" alt="SPI 转 CAN 模块要接的 iTOP-RK3568 的引脚" loading="lazy"></p><p>可以根据引脚的网络标号得到要使能的 SPI 控制器为 SPI0，然后开始对 iTOP-RK3568 的设备树进行修改</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;spi0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins_hs</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">mcp2515:</span><span class="title class_">mcp2515@0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;my-mcp2515&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>第 3-4 行，指定了要使用的 <code>spi pinctrl</code> 引脚，默认情况下使用的 spi0 控制器 pinctrl 引脚为 <code>spi0m0_cs0</code> 和 <code>spi0m0_pins</code>，而实际用的是第二组 pinctrl 引脚。</p><p>第 7 行，表述指定片选 0。</p><p>第 9 行，设置 <code>spi clk</code> 输出的时钟频率，这里设置的是 10M，RK3568 最大设置不超过 50M。如果 <code>reg</code> 属性和 <code>spi-max-frequency</code> 不设置在驱动加载时将无法进入 <code>probe spi</code> 初始化函数（驱动中匹配函数）。</p><h3 id="reg-和-spi-max-frequency属性"><a href="#reg-和-spi-max-frequency属性" class="headerlink" title="reg 和 spi-max-frequency属性"></a><code>reg</code> 和 <code>spi-max-frequency</code>属性</h3><p>在rk3568.dtsi中：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spi0:</span> <span class="title class_">spi@fe610000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3066-spi&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe610000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">103</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> CLK_SPI0&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_SPI0&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;spiclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">dmas</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">20</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">21</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">dma-names</span> <span class="operator">=</span> <span class="string">&quot;tx&quot;</span>, <span class="string">&quot;rx&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>, <span class="string">&quot;high_speed&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi0m0_cs0</span> <span class="variable">&amp;spi0m0_cs1</span> <span class="variable">&amp;spi0m0_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;spi0m0_cs0</span> <span class="variable">&amp;spi0m0_cs1</span> <span class="variable">&amp;spi0m0_pins_hs</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">num-cs</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>根据设备树的 <code>compatible</code> 属性来寻找对应的 SPI 控制器驱动程序，找到的具体驱动文件路径为 <code>spi/spi-rockchip.c</code>，该驱动程序的 probe 函数内容如下所示：</p><h4 id="rockchip-spi-probe"><a href="#rockchip-spi-probe" class="headerlink" title="rockchip_spi_probe()"></a>rockchip_spi_probe()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_spi_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_spi</span> *<span class="title">rs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> *<span class="title">ctlr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">mem</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">u32 rsd_nsecs, num_cs, csm;</span><br><span class="line"><span class="type">bool</span> slave_mode;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_spi_quirks</span> *<span class="title">quirks_cfg</span>;</span></span><br><span class="line"><span class="comment">// 检查设备节点是否配置为 SPI 从模式</span></span><br><span class="line">slave_mode = of_property_read_bool(np, <span class="string">&quot;spi-slave&quot;</span>);</span><br><span class="line"><span class="comment">// 根据从模式或主模式分配 SPI 控制器</span></span><br><span class="line"><span class="keyword">if</span> (slave_mode)</span><br><span class="line">ctlr = spi_alloc_slave(&amp;pdev-&gt;dev,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> rockchip_spi));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ctlr = spi_alloc_master(&amp;pdev-&gt;dev,</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> rockchip_spi));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ctlr)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">// 设置平台设备的驱动数据</span></span><br><span class="line">platform_set_drvdata(pdev, ctlr);</span><br><span class="line"></span><br><span class="line">rs = spi_controller_get_devdata(ctlr);</span><br><span class="line">ctlr-&gt;slave = slave_mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get basic io resource and map it */</span></span><br><span class="line">    <span class="comment">// 获取基本的 IO 资源并映射</span></span><br><span class="line">mem = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">rs-&gt;regs = devm_ioremap_resource(&amp;pdev-&gt;dev, mem);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rs-&gt;regs)) &#123;</span><br><span class="line">ret =  PTR_ERR(rs-&gt;regs);</span><br><span class="line"><span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">&#125;</span><br><span class="line">rs-&gt;base_addr_phy = mem-&gt;start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!has_acpi_companion(&amp;pdev-&gt;dev))</span><br><span class="line">rs-&gt;apb_pclk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;apb_pclk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rs-&gt;apb_pclk)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get apb_pclk\n&quot;</span>);</span><br><span class="line">ret = PTR_ERR(rs-&gt;apb_pclk);</span><br><span class="line"><span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!has_acpi_companion(&amp;pdev-&gt;dev))</span><br><span class="line">rs-&gt;spiclk = devm_clk_get(&amp;pdev-&gt;dev, <span class="string">&quot;spiclk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rs-&gt;spiclk)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get spi_pclk\n&quot;</span>);</span><br><span class="line">ret = PTR_ERR(rs-&gt;spiclk);</span><br><span class="line"><span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs-&gt;sclk_in = devm_clk_get_optional(&amp;pdev-&gt;dev, <span class="string">&quot;sclk_in&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rs-&gt;sclk_in)) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get sclk_in\n&quot;</span>);</span><br><span class="line">ret = PTR_ERR(rs-&gt;sclk_in);</span><br><span class="line"><span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启用 APB PCLK</span></span><br><span class="line">ret = clk_prepare_enable(rs-&gt;apb_pclk);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to enable apb_pclk\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_put_ctlr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启用 SPI CLK</span></span><br><span class="line">ret = clk_prepare_enable(rs-&gt;spiclk);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to enable spi_clk\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_disable_apbclk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = clk_prepare_enable(rs-&gt;sclk_in);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to enable sclk_in\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_disable_spiclk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁用 SPI 芯片</span></span><br><span class="line">spi_enable_chip(rs, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 获取平台中断资源</span></span><br><span class="line">ret = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_disable_sclk_in;</span><br><span class="line"><span class="comment">// 请求中断</span></span><br><span class="line">ret = devm_request_threaded_irq(&amp;pdev-&gt;dev, ret, rockchip_spi_isr, <span class="literal">NULL</span>,</span><br><span class="line">IRQF_ONESHOT, dev_name(&amp;pdev-&gt;dev), ctlr);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> err_disable_sclk_in;</span><br><span class="line"></span><br><span class="line">rs-&gt;dev = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">rs-&gt;freq = clk_get_rate(rs-&gt;spiclk);</span><br><span class="line"><span class="keyword">if</span> (!rs-&gt;freq) &#123;</span><br><span class="line">ret = device_property_read_u32(&amp;pdev-&gt;dev, <span class="string">&quot;clock-frequency&quot;</span>, &amp;rs-&gt;freq);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_warn(rs-&gt;dev, <span class="string">&quot;Failed to get clock or clock-frequency property\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_disable_sclk_in;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取接收采样延迟（以纳秒为单位）</span></span><br><span class="line"><span class="keyword">if</span> (!device_property_read_u32(&amp;pdev-&gt;dev, <span class="string">&quot;rx-sample-delay-ns&quot;</span>, &amp;rsd_nsecs)) &#123;</span><br><span class="line"><span class="comment">/* rx sample delay is expressed in parent clock cycles (max 3) */</span></span><br><span class="line">u32 rsd = DIV_ROUND_CLOSEST(rsd_nsecs * (rs-&gt;freq &gt;&gt; <span class="number">8</span>),</span><br><span class="line"><span class="number">1000000000</span> &gt;&gt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (!rsd) &#123;</span><br><span class="line">dev_warn(rs-&gt;dev, <span class="string">&quot;%u Hz are too slow to express %u ns delay\n&quot;</span>,</span><br><span class="line">rs-&gt;freq, rsd_nsecs);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rsd &gt; CR0_RSD_MAX) &#123;</span><br><span class="line">rsd = CR0_RSD_MAX;</span><br><span class="line">dev_warn(rs-&gt;dev, <span class="string">&quot;%u Hz are too fast to express %u ns delay, clamping at %u ns\n&quot;</span>,</span><br><span class="line">rs-&gt;freq, rsd_nsecs,</span><br><span class="line">CR0_RSD_MAX * <span class="number">1000000000U</span> / rs-&gt;freq);</span><br><span class="line">&#125;</span><br><span class="line">rs-&gt;rsd = rsd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!device_property_read_u32(&amp;pdev-&gt;dev, <span class="string">&quot;csm&quot;</span>, &amp;csm)) &#123;</span><br><span class="line"><span class="keyword">if</span> (csm &gt; CR0_CSM_ONE)&#123;</span><br><span class="line">dev_warn(rs-&gt;dev, <span class="string">&quot;The csm value %u exceeds the limit, clamping at %u\n&quot;</span>,</span><br><span class="line"> csm, CR0_CSM_ONE);</span><br><span class="line">csm = CR0_CSM_ONE;</span><br><span class="line">&#125;</span><br><span class="line">rs-&gt;csm = csm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs-&gt;version = readl_relaxed(rs-&gt;regs + ROCKCHIP_SPI_VERSION);</span><br><span class="line">rs-&gt;fifo_len = get_fifo_len(rs);<span class="comment">// 获取 FIFO 长度</span></span><br><span class="line"><span class="keyword">if</span> (!rs-&gt;fifo_len) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get fifo length\n&quot;</span>);</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> err_disable_sclk_in;</span><br><span class="line">&#125;</span><br><span class="line">quirks_cfg = device_get_match_data(&amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (quirks_cfg)</span><br><span class="line">rs-&gt;max_baud_div_in_cpha = quirks_cfg-&gt;max_baud_div_in_cpha;</span><br><span class="line"><span class="comment">// 设置并启用运行时电源管理</span></span><br><span class="line">pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">ctlr-&gt;auto_runtime_pm = <span class="literal">true</span>;</span><br><span class="line">ctlr-&gt;bus_num = pdev-&gt;id;</span><br><span class="line">ctlr-&gt;mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP | SPI_LSB_FIRST;</span><br><span class="line"><span class="keyword">if</span> (slave_mode) &#123;</span><br><span class="line">ctlr-&gt;mode_bits |= SPI_NO_CS;</span><br><span class="line">ctlr-&gt;slave_abort = rockchip_spi_slave_abort;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctlr-&gt;flags = SPI_MASTER_GPIO_SS;</span><br><span class="line">ctlr-&gt;max_native_cs = ROCKCHIP_SPI_MAX_CS_NUM;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * rk spi0 has two native cs, spi1..5 one cs only</span></span><br><span class="line"><span class="comment"> * if num-cs is missing in the dts, default to 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (device_property_read_u32(&amp;pdev-&gt;dev, <span class="string">&quot;num-cs&quot;</span>, &amp;num_cs))</span><br><span class="line">num_cs = <span class="number">1</span>;</span><br><span class="line">ctlr-&gt;num_chipselect = num_cs;</span><br><span class="line">ctlr-&gt;use_gpio_descriptors = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ctlr-&gt;dev.of_node = pdev-&gt;dev.of_node;</span><br><span class="line">ctlr-&gt;bits_per_word_mask = SPI_BPW_MASK(<span class="number">16</span>) | SPI_BPW_MASK(<span class="number">8</span>) | SPI_BPW_MASK(<span class="number">4</span>);</span><br><span class="line">ctlr-&gt;min_speed_hz = rs-&gt;freq / BAUDR_SCKDV_MAX;</span><br><span class="line">ctlr-&gt;max_speed_hz = min(rs-&gt;freq / BAUDR_SCKDV_MIN, MAX_SCLK_OUT);</span><br><span class="line"></span><br><span class="line">ctlr-&gt;setup = rockchip_spi_setup;</span><br><span class="line">ctlr-&gt;set_cs = rockchip_spi_set_cs;</span><br><span class="line">ctlr-&gt;transfer_one = rockchip_spi_transfer_one;</span><br><span class="line">ctlr-&gt;max_transfer_size = rockchip_spi_max_transfer_size;</span><br><span class="line">ctlr-&gt;handle_err = rockchip_spi_handle_err;</span><br><span class="line"><span class="comment">// 请求 TX DMA 通道</span></span><br><span class="line">ctlr-&gt;dma_tx = dma_request_chan(rs-&gt;dev, <span class="string">&quot;tx&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ctlr-&gt;dma_tx)) &#123;</span><br><span class="line"><span class="comment">/* Check tx to see if we need defer probing driver */</span></span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(ctlr-&gt;dma_tx) == -EPROBE_DEFER) &#123;</span><br><span class="line">ret = -EPROBE_DEFER;</span><br><span class="line"><span class="keyword">goto</span> err_disable_pm_runtime;</span><br><span class="line">&#125;</span><br><span class="line">dev_warn(rs-&gt;dev, <span class="string">&quot;Failed to request TX DMA channel\n&quot;</span>);</span><br><span class="line">ctlr-&gt;dma_tx = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 请求 RX DMA 通道</span></span><br><span class="line">ctlr-&gt;dma_rx = dma_request_chan(rs-&gt;dev, <span class="string">&quot;rx&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(ctlr-&gt;dma_rx)) &#123;</span><br><span class="line"><span class="keyword">if</span> (PTR_ERR(ctlr-&gt;dma_rx) == -EPROBE_DEFER) &#123;</span><br><span class="line">ret = -EPROBE_DEFER;</span><br><span class="line"><span class="keyword">goto</span> err_free_dma_tx;</span><br><span class="line">&#125;</span><br><span class="line">dev_warn(rs-&gt;dev, <span class="string">&quot;Failed to request RX DMA channel\n&quot;</span>);</span><br><span class="line">ctlr-&gt;dma_rx = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 TX 和 RX DMA 通道均成功请求</span></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;dma_tx &amp;&amp; ctlr-&gt;dma_rx) &#123;</span><br><span class="line">rs-&gt;dma_addr_tx = mem-&gt;start + ROCKCHIP_SPI_TXDR;</span><br><span class="line">rs-&gt;dma_addr_rx = mem-&gt;start + ROCKCHIP_SPI_RXDR;</span><br><span class="line">ctlr-&gt;can_dma = rockchip_spi_can_dma;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs-&gt;poll = device_property_read_bool(&amp;pdev-&gt;dev, <span class="string">&quot;rockchip,poll-only&quot;</span>);</span><br><span class="line"><span class="comment">// 检查 SPI 版本并设置 cs_inactive</span></span><br><span class="line"><span class="keyword">switch</span> (rs-&gt;version) &#123;</span><br><span class="line"><span class="keyword">case</span> ROCKCHIP_SPI_VER2_TYPE2:</span><br><span class="line">rs-&gt;cs_high_supported = <span class="literal">true</span>;</span><br><span class="line">ctlr-&gt;mode_bits |= SPI_CS_HIGH;</span><br><span class="line"><span class="keyword">if</span> (slave_mode)</span><br><span class="line">rs-&gt;cs_inactive = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">rs-&gt;cs_inactive = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">rs-&gt;cs_inactive = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取引脚控制</span></span><br><span class="line">pinctrl = devm_pinctrl_get(&amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(pinctrl)) &#123;</span><br><span class="line">rs-&gt;high_speed_state = pinctrl_lookup_state(pinctrl, <span class="string">&quot;high_speed&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR_OR_NULL(rs-&gt;high_speed_state)) &#123;</span><br><span class="line">dev_warn(&amp;pdev-&gt;dev, <span class="string">&quot;no high_speed pinctrl state\n&quot;</span>);</span><br><span class="line">rs-&gt;high_speed_state = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册 SPI 控制器</span></span><br><span class="line">ret = devm_spi_register_controller(&amp;pdev-&gt;dev, ctlr);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to register controller\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> err_free_dma_rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_SPI_ROCKCHIP_MISCDEV)) &#123;</span><br><span class="line"><span class="type">char</span> misc_name[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(misc_name, <span class="keyword">sizeof</span>(misc_name), <span class="string">&quot;rkspi-dev%d&quot;</span>, ctlr-&gt;bus_num);</span><br><span class="line">rs-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br><span class="line">rs-&gt;miscdev.name = misc_name;</span><br><span class="line">rs-&gt;miscdev.fops = &amp;rockchip_spi_misc_fops;</span><br><span class="line">rs-&gt;miscdev.parent = &amp;pdev-&gt;dev;</span><br><span class="line"></span><br><span class="line">ret = misc_register(&amp;rs-&gt;miscdev);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to register misc device %s\n&quot;</span>, misc_name);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;register misc device %s\n&quot;</span>, misc_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev_info(rs-&gt;dev, <span class="string">&quot;probed, poll=%d, rsd=%d\n&quot;</span>, rs-&gt;poll, rs-&gt;rsd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_free_dma_rx:</span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;dma_rx)</span><br><span class="line">dma_release_channel(ctlr-&gt;dma_rx);</span><br><span class="line">err_free_dma_tx:</span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;dma_tx)</span><br><span class="line">dma_release_channel(ctlr-&gt;dma_tx);</span><br><span class="line">err_disable_pm_runtime:</span><br><span class="line">pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">err_disable_sclk_in:</span><br><span class="line">clk_disable_unprepare(rs-&gt;sclk_in);</span><br><span class="line">err_disable_spiclk:</span><br><span class="line">clk_disable_unprepare(rs-&gt;spiclk);</span><br><span class="line">err_disable_apbclk:</span><br><span class="line">clk_disable_unprepare(rs-&gt;apb_pclk);</span><br><span class="line">err_put_ctlr:</span><br><span class="line">spi_controller_put(ctlr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="devm-spi-register-controller"><a href="#devm-spi-register-controller" class="headerlink" title="devm_spi_register_controller()"></a>devm_spi_register_controller()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_spi_register_controller - register managed SPI master or slave</span></span><br><span class="line"><span class="comment"> *controller</span></span><br><span class="line"><span class="comment"> * @dev:    device managing SPI controller</span></span><br><span class="line"><span class="comment"> * @ctlr: initialized controller, originally from spi_alloc_master() or</span></span><br><span class="line"><span class="comment"> *spi_alloc_slave()</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register a SPI device as with spi_register_controller() which will</span></span><br><span class="line"><span class="comment"> * automatically be unregistered and freed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">devm_spi_register_controller</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> spi_controller *ctlr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> **<span class="title">ptr</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 分配设备资源管理器(devres)内存，用于自动释放控制器资源</span></span><br><span class="line">ptr = devres_alloc(devm_spi_unregister, <span class="keyword">sizeof</span>(*ptr), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!ptr)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;<span class="comment">// 内存分配失败</span></span><br><span class="line"><span class="comment">// 注册 SPI 控制器</span></span><br><span class="line">ret = spi_register_controller(ctlr);</span><br><span class="line"><span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">*ptr = ctlr;<span class="comment">// 注册成功，将指针存储在设备资源管理器中</span></span><br><span class="line">devres_add(dev, ptr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">devres_free(ptr);<span class="comment">// 注册失败，释放分配的资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;<span class="comment">// 返回注册结果</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(devm_spi_register_controller);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="spi-register-controller"><a href="#spi-register-controller" class="headerlink" title="spi_register_controller()"></a>spi_register_controller()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_register_controller</span><span class="params">(<span class="keyword">struct</span> spi_controller *ctlr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>*<span class="title">dev</span> =</span> ctlr-&gt;dev.parent;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">boardinfo</span>*<span class="title">bi</span>;</span></span><br><span class="line"><span class="type">int</span>status;</span><br><span class="line"><span class="type">int</span>id, first_dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dev)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure all necessary hooks are implemented before registering</span></span><br><span class="line"><span class="comment"> * the SPI controller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在注册 SPI 控制器之前，确保所有必要的操作已实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">status = spi_controller_check_ops(ctlr);</span><br><span class="line"><span class="keyword">if</span> (status)</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;bus_num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* devices with a fixed bus num must check-in with the num */</span></span><br><span class="line">mutex_lock(&amp;board_lock);<span class="comment">/* 固定总线编号的设备必须使用该编号进行检查 */</span></span><br><span class="line">id = idr_alloc(&amp;spi_master_idr, ctlr, ctlr-&gt;bus_num,</span><br><span class="line">ctlr-&gt;bus_num + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">mutex_unlock(&amp;board_lock);</span><br><span class="line"><span class="keyword">if</span> (WARN(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> id == -ENOSPC ? -EBUSY : id;</span><br><span class="line">ctlr-&gt;bus_num = id;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctlr-&gt;dev.of_node) &#123;</span><br><span class="line"><span class="comment">/* allocate dynamic bus number using Linux idr */</span></span><br><span class="line">id = of_alias_get_id(ctlr-&gt;dev.of_node, <span class="string">&quot;spi&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">ctlr-&gt;bus_num = id;</span><br><span class="line">mutex_lock(&amp;board_lock);</span><br><span class="line">id = idr_alloc(&amp;spi_master_idr, ctlr, ctlr-&gt;bus_num,</span><br><span class="line">       ctlr-&gt;bus_num + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">mutex_unlock(&amp;board_lock);</span><br><span class="line"><span class="keyword">if</span> (WARN(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> id == -ENOSPC ? -EBUSY : id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;bus_num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">first_dynamic = of_alias_get_highest_id(<span class="string">&quot;spi&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (first_dynamic &lt; <span class="number">0</span>)</span><br><span class="line">first_dynamic = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">first_dynamic++;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;board_lock);</span><br><span class="line">id = idr_alloc(&amp;spi_master_idr, ctlr, first_dynamic,</span><br><span class="line">       <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">mutex_unlock(&amp;board_lock);</span><br><span class="line"><span class="keyword">if</span> (WARN(id &lt; <span class="number">0</span>, <span class="string">&quot;couldn&#x27;t get idr&quot;</span>))</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">ctlr-&gt;bus_num = id;</span><br><span class="line">&#125;</span><br><span class="line">INIT_LIST_HEAD(&amp;ctlr-&gt;<span class="built_in">queue</span>);</span><br><span class="line">spin_lock_init(&amp;ctlr-&gt;queue_lock);</span><br><span class="line">spin_lock_init(&amp;ctlr-&gt;bus_lock_spinlock);</span><br><span class="line">mutex_init(&amp;ctlr-&gt;bus_lock_mutex);</span><br><span class="line">mutex_init(&amp;ctlr-&gt;io_mutex);</span><br><span class="line">ctlr-&gt;bus_lock_flag = <span class="number">0</span>;</span><br><span class="line">init_completion(&amp;ctlr-&gt;xfer_completion);</span><br><span class="line"><span class="keyword">if</span> (!ctlr-&gt;max_dma_len)</span><br><span class="line">ctlr-&gt;max_dma_len = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* register the device, then userspace will see it.</span></span><br><span class="line"><span class="comment"> * registration fails if the bus ID is in use.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dev_set_name(&amp;ctlr-&gt;dev, <span class="string">&quot;spi%u&quot;</span>, ctlr-&gt;bus_num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!spi_controller_is_slave(ctlr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;use_gpio_descriptors) &#123;</span><br><span class="line">status = spi_get_gpio_descs(ctlr);</span><br><span class="line"><span class="keyword">if</span> (status)</span><br><span class="line"><span class="keyword">goto</span> free_bus_id;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A controller using GPIO descriptors always</span></span><br><span class="line"><span class="comment"> * supports SPI_CS_HIGH if need be.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ctlr-&gt;mode_bits |= SPI_CS_HIGH;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Legacy code path for GPIOs from DT */</span></span><br><span class="line">status = of_spi_get_gpio_numbers(ctlr);</span><br><span class="line"><span class="keyword">if</span> (status)</span><br><span class="line"><span class="keyword">goto</span> free_bus_id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Even if it&#x27;s just one always-selected device, there must</span></span><br><span class="line"><span class="comment"> * be at least one chipselect.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!ctlr-&gt;num_chipselect) &#123;</span><br><span class="line">status = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> free_bus_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status = device_add(&amp;ctlr-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> free_bus_id;</span><br><span class="line">dev_dbg(dev, <span class="string">&quot;registered %s %s\n&quot;</span>,</span><br><span class="line">spi_controller_is_slave(ctlr) ? <span class="string">&quot;slave&quot;</span> : <span class="string">&quot;master&quot;</span>,</span><br><span class="line">dev_name(&amp;ctlr-&gt;dev));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we&#x27;re using a queued driver, start the queue. Note that we don&#x27;t</span></span><br><span class="line"><span class="comment"> * need the queueing logic if the driver is only supporting high-level</span></span><br><span class="line"><span class="comment"> * memory operations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;transfer) &#123;</span><br><span class="line">dev_info(dev, <span class="string">&quot;controller is unqueued, this is deprecated\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctlr-&gt;transfer_one || ctlr-&gt;transfer_one_message) &#123;</span><br><span class="line">status = spi_controller_initialize_queue(ctlr);</span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">device_del(&amp;ctlr-&gt;dev);</span><br><span class="line"><span class="keyword">goto</span> free_bus_id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* add statistics */</span></span><br><span class="line">spin_lock_init(&amp;ctlr-&gt;statistics.lock);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;board_lock);</span><br><span class="line">list_add_tail(&amp;ctlr-&gt;<span class="built_in">list</span>, &amp;spi_controller_list);</span><br><span class="line">list_for_each_entry(bi, &amp;board_list, <span class="built_in">list</span>)</span><br><span class="line">spi_match_controller_to_boardinfo(ctlr, &amp;bi-&gt;board_info);</span><br><span class="line">mutex_unlock(&amp;board_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register devices from the device tree and ACPI */</span></span><br><span class="line">of_register_spi_devices(ctlr);</span><br><span class="line">acpi_register_spi_devices(ctlr);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">free_bus_id:</span><br><span class="line">mutex_lock(&amp;board_lock);</span><br><span class="line">idr_remove(&amp;spi_master_idr, ctlr-&gt;bus_num);</span><br><span class="line">mutex_unlock(&amp;board_lock);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(spi_register_controller);</span><br></pre></td></tr></table></figure><p>在该函数的第 132行会调用设备树资源注册函数 <code>of_register_spi_devices</code> 对 SPI 的子节点设备树进行注册，该函数的具体内容如下所示：</p><h4 id="of-register-spi-devices"><a href="#of-register-spi-devices" class="headerlink" title="of_register_spi_devices()"></a>of_register_spi_devices()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_register_spi_devices() - Register child devices onto the SPI bus</span></span><br><span class="line"><span class="comment"> * @ctlr:Pointer to spi_controller device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Registers an spi_device for each child node of controller node which</span></span><br><span class="line"><span class="comment"> * represents a valid SPI slave.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">of_register_spi_devices</span><span class="params">(<span class="keyword">struct</span> spi_controller *ctlr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nc</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ctlr-&gt;dev.of_node)<span class="comment">// 如果控制器没有设备树节点，则直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历控制器设备树节点下的每个子节点</span></span><br><span class="line">for_each_available_child_of_node(ctlr-&gt;dev.of_node, nc) &#123;</span><br><span class="line"><span class="keyword">if</span> (of_node_test_and_set_flag(nc, OF_POPULATED))<span class="comment">// 如果该节点已被标记为已填充，则跳过该节点</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">spi = of_register_spi_device(ctlr, nc);<span class="comment">// 为该节点注册一个 SPI 设备</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(spi)) &#123;<span class="comment">// 如果注册失败，记录警告信息并清除该节点的已填充标记</span></span><br><span class="line">dev_warn(&amp;ctlr-&gt;dev,</span><br><span class="line"> <span class="string">&quot;Failed to create SPI device for %pOF\n&quot;</span>, nc);</span><br><span class="line">of_node_clear_flag(nc, OF_POPULATED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第17 行会遍历控制器设备树节点下的每个子节点，通过 <code>of_register_spi_device</code> 函数注册该 SPI 子节点，<code>of_register_spi_device</code> 函数具体内容如下所示：</p><h4 id="of-register-spi-device"><a href="#of-register-spi-device" class="headerlink" title="of_register_spi_device()"></a>of_register_spi_device()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> spi_device *</span><br><span class="line"><span class="title function_">of_register_spi_device</span><span class="params">(<span class="keyword">struct</span> spi_controller *ctlr, <span class="keyword">struct</span> device_node *nc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span></span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alloc an spi_device */</span></span><br><span class="line">spi = spi_alloc_device(ctlr);<span class="comment">/* 分配一个 spi_device */</span></span><br><span class="line"><span class="keyword">if</span> (!spi) &#123;</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;spi_device alloc error for %pOF\n&quot;</span>, nc);</span><br><span class="line">rc = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> err_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Select device driver */</span></span><br><span class="line">    <span class="comment">/* 选择设备驱动 */</span></span><br><span class="line">rc = of_modalias_node(nc, spi-&gt;modalias,</span><br><span class="line"><span class="keyword">sizeof</span>(spi-&gt;modalias));</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;cannot find modalias for %pOF\n&quot;</span>, nc);</span><br><span class="line"><span class="keyword">goto</span> err_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rc = of_spi_parse_dt(ctlr, spi, nc);<span class="comment">/* 解析设备树中的 SPI 信息 */</span></span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">goto</span> err_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Store a pointer to the node in the device structure */</span></span><br><span class="line">of_node_get(nc);<span class="comment">/* 在设备结构中存储指向节点的指针 */</span></span><br><span class="line">spi-&gt;dev.of_node = nc;</span><br><span class="line">spi-&gt;dev.fwnode = of_fwnode_handle(nc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register the new device */</span></span><br><span class="line">rc = spi_add_device(spi);<span class="comment">/* 注册新设备 */</span></span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;spi_device register error %pOF\n&quot;</span>, nc);</span><br><span class="line"><span class="keyword">goto</span> err_of_node_put;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> spi;</span><br><span class="line"></span><br><span class="line">err_of_node_put:</span><br><span class="line">of_node_put(nc);</span><br><span class="line">err_out:</span><br><span class="line">spi_dev_put(spi);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第 24 行调用了 <code>of_spi_parse_dt</code> 函数来解析设备树子节点中的 SPI 信息，<code>of_spi_parse_dt</code> 函数具体内容如下所示</p><h4 id="of-spi-parse-dt"><a href="#of-spi-parse-dt" class="headerlink" title="of_spi_parse_dt()"></a>of_spi_parse_dt()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">of_spi_parse_dt</span><span class="params">(<span class="keyword">struct</span> spi_controller *ctlr, <span class="keyword">struct</span> spi_device *spi,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> device_node *nc)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 value;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mode (clock phase/polarity/etc.) */</span> <span class="comment">/* 设置模式 (时钟相位/极性等) */</span></span><br><span class="line"><span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-cpha&quot;</span>))</span><br><span class="line">spi-&gt;mode |= SPI_CPHA;</span><br><span class="line"><span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-cpol&quot;</span>))</span><br><span class="line">spi-&gt;mode |= SPI_CPOL;</span><br><span class="line"><span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-3wire&quot;</span>))</span><br><span class="line">spi-&gt;mode |= SPI_3WIRE;</span><br><span class="line"><span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-lsb-first&quot;</span>))</span><br><span class="line">spi-&gt;mode |= SPI_LSB_FIRST;</span><br><span class="line"><span class="keyword">if</span> (of_property_read_bool(nc, <span class="string">&quot;spi-cs-high&quot;</span>))</span><br><span class="line">spi-&gt;mode |= SPI_CS_HIGH;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Device DUAL/QUAD mode */</span></span><br><span class="line">    <span class="comment">/* 设置设备的 DUAL/QUAD 模式 */</span></span><br><span class="line"><span class="keyword">if</span> (!of_property_read_u32(nc, <span class="string">&quot;spi-tx-bus-width&quot;</span>, &amp;value)) &#123;</span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">spi-&gt;mode |= SPI_TX_DUAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">spi-&gt;mode |= SPI_TX_QUAD;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">spi-&gt;mode |= SPI_TX_OCTAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">dev_warn(&amp;ctlr-&gt;dev,</span><br><span class="line"><span class="string">&quot;spi-tx-bus-width %d not supported\n&quot;</span>,</span><br><span class="line">value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!of_property_read_u32(nc, <span class="string">&quot;spi-rx-bus-width&quot;</span>, &amp;value)) &#123;</span><br><span class="line"><span class="keyword">switch</span> (value) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">spi-&gt;mode |= SPI_RX_DUAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">spi-&gt;mode |= SPI_RX_QUAD;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">spi-&gt;mode |= SPI_RX_OCTAL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">dev_warn(&amp;ctlr-&gt;dev,</span><br><span class="line"><span class="string">&quot;spi-rx-bus-width %d not supported\n&quot;</span>,</span><br><span class="line">value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 如果是 SPI 从设备 */</span></span><br><span class="line"><span class="keyword">if</span> (spi_controller_is_slave(ctlr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!of_node_name_eq(nc, <span class="string">&quot;slave&quot;</span>)) &#123;</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;%pOF is not called &#x27;slave&#x27;\n&quot;</span>,</span><br><span class="line">nc);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Device address */</span></span><br><span class="line">rc = of_property_read_u32(nc, <span class="string">&quot;reg&quot;</span>, &amp;value);<span class="comment">/* 获取设备地址 */</span></span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;%pOF has no valid &#x27;reg&#x27; property (%d)\n&quot;</span>,</span><br><span class="line">nc, rc);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line">spi-&gt;chip_select = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Device speed */</span></span><br><span class="line"><span class="keyword">if</span> (!of_property_read_u32(nc, <span class="string">&quot;spi-max-frequency&quot;</span>, &amp;value))<span class="comment">/* 获取设备速度 */</span></span><br><span class="line">spi-&gt;max_speed_hz = value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设备树不存在 <code>reg</code> 和 <code>spi-max-frequency</code> 两个属性则会返回 rc，这就导致上一级函数 <code>of_register_spi_device</code> 会返回错误，从而无法成功注册 SPI 设备、不能成功解析设备树节点，最终导致编写的 SPI 设备驱动无法正常匹配。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mcp2515_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印一条消息,表示探测成功</span></span><br><span class="line">    printk(<span class="string">&quot;This is mcp2515 probe\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mcp2515_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备匹配表,用于设备树匹配</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mcp2515_of_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;my-mcp2515&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备ID匹配表,用于总线匹配</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">mcp2515_id_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;mcp2515&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515 SPI驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spi_mcp2515</span> =</span> &#123;</span><br><span class="line">    .probe = mcp2515_probe, <span class="comment">// 探测函数</span></span><br><span class="line">    .remove = mcp2515_remove, <span class="comment">// 移除函数</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;mcp2515&quot;</span>, <span class="comment">// 驱动名称</span></span><br><span class="line">        .owner = THIS_MODULE, <span class="comment">// 所属模块</span></span><br><span class="line">        .of_match_table = mcp2515_of_match_table, <span class="comment">// 设备树匹配表</span></span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table = mcp2515_id_table, <span class="comment">// 设备ID匹配表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mcp2515_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册SPI驱动</span></span><br><span class="line">    ret = spi_register_driver(&amp;spi_mcp2515);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注册失败,打印错误信息</span></span><br><span class="line">        printk(<span class="string">&quot;spi_register_driver error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mcp2515_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销SPI驱动</span></span><br><span class="line">    spi_unregister_driver(&amp;spi_mcp2515);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mcp2515_init);</span><br><span class="line">module_exit(mcp2515_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="注册字符设备示例"><a href="#注册字符设备示例" class="headerlink" title="注册字符设备示例"></a>注册字符设备示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kdev_t.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">dev_t</span> dev_num; <span class="comment">// 设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">mcp2515_cdev</span>;</span> <span class="comment">// 字符设备结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">mcp2515_class</span>;</span> <span class="comment">// 设备类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">mcp2515_device</span>;</span> <span class="comment">// 设备</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi_dev</span>;</span> <span class="comment">// SPI设备指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515芯片复位函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mcp2515_reset</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">char</span> write_buf[] = &#123;<span class="number">0xc0</span>&#125;; <span class="comment">// 复位指令0x11000000即0xc0</span></span><br><span class="line">    ret = spi_write(spi_dev, write_buf, <span class="keyword">sizeof</span>(write_buf)); <span class="comment">// 发送复位命令</span></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">&quot;spi_write is error\n&quot;</span>); <span class="comment">// 打印错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515读寄存器函数</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">mcp2515_read_reg</span><span class="params">(<span class="type">char</span> reg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> write_buf[] = &#123;<span class="number">0x03</span>, reg&#125;;  <span class="comment">// SPI写缓冲区写入SPI读指令0x03</span></span><br><span class="line">    <span class="type">char</span> read_buf;                   <span class="comment">// SPI读缓冲区</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = spi_write_then_read(spi_dev, write_buf, <span class="keyword">sizeof</span>(write_buf), &amp;read_buf, <span class="keyword">sizeof</span>(read_buf));  <span class="comment">// 调用SPI写读函数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;spi_write_then_read error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read_buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开设备文件的回调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mcp2515_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取设备文件的回调函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mcp2515_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入设备文件的回调函数</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mcp2515_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭设备文件的回调函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mcp2515_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备文件操作集合</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">mcp2515_fops</span> =</span> &#123;</span><br><span class="line">    .open = mcp2515_open,</span><br><span class="line">    .read = mcp2515_read,</span><br><span class="line">    .write = mcp2515_write,</span><br><span class="line">    .release = mcp2515_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备初始化函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mcp2515_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;This is mcp2515_probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    spi_dev = spi; <span class="comment">// 保存SPI设备指针</span></span><br><span class="line">    <span class="comment">// 分配字符设备号</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_num, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;mcp2515&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;alloc_chrdev_region error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化字符设备</span></span><br><span class="line">    cdev_init(&amp;mcp2515_cdev, &amp;mcp2515_fops);</span><br><span class="line">    mcp2515_cdev.owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加字符设备</span></span><br><span class="line">    ret = cdev_add(&amp;mcp2515_cdev, dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;cdev_add error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备类</span></span><br><span class="line">    mcp2515_class = class_create(THIS_MODULE, <span class="string">&quot;spi_to_can&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mcp2515_class)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;mcp2515_class error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mcp2515_class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建设备</span></span><br><span class="line">    mcp2515_device = device_create(mcp2515_class, <span class="literal">NULL</span>, dev_num, <span class="literal">NULL</span>, <span class="string">&quot;mcp2515&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mcp2515_device)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;mcp2515_device error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mcp2515_device);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mcp2515_reset();             <span class="comment">// 复位MCP2515设备</span></span><br><span class="line">    value = mcp2515_read_reg(<span class="number">0x0e</span>);  <span class="comment">// 读取寄存器值</span></span><br><span class="line">    printk(<span class="string">&quot;value is %x\n&quot;</span>, value);  <span class="comment">// 打印读取的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515 SPI设备的移除函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mcp2515_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span> &#123;</span><br><span class="line">    device_destroy(mcp2515_class, dev_num);</span><br><span class="line">    class_destroy(mcp2515_class);</span><br><span class="line">    cdev_del(&amp;mcp2515_cdev);</span><br><span class="line">    unregister_chrdev_region(dev_num, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备匹配表,用于设备树匹配</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">mcp2515_of_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;my-mcp2515&quot;</span> &#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515设备ID匹配表,用于总线匹配</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">mcp2515_id_table</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;mcp2515&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MCP2515 SPI驱动结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spi_mcp2515</span> =</span> &#123;</span><br><span class="line">    .probe = mcp2515_probe, <span class="comment">// 探测函数</span></span><br><span class="line">    .remove = mcp2515_remove, <span class="comment">// 移除函数</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;mcp2515&quot;</span>, <span class="comment">// 驱动名称</span></span><br><span class="line">        .owner = THIS_MODULE, <span class="comment">// 所属模块</span></span><br><span class="line">        .of_match_table = mcp2515_of_match_table, <span class="comment">// 设备树匹配表</span></span><br><span class="line">&#125;,</span><br><span class="line">    .id_table = mcp2515_id_table, <span class="comment">// 设备ID匹配表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mcp2515_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册SPI驱动</span></span><br><span class="line">    ret = spi_register_driver(&amp;spi_mcp2515);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注册失败,打印错误信息</span></span><br><span class="line">        printk(<span class="string">&quot;spi_register_driver error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mcp2515_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销SPI驱动</span></span><br><span class="line">    spi_unregister_driver(&amp;spi_mcp2515);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mcp2515_init);</span><br><span class="line">module_exit(mcp2515_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="SPI通信流程"><a href="#SPI通信流程" class="headerlink" title="SPI通信流程"></a>SPI通信流程</h1><p>在 Linux 驱动中可以使用 <code>spi_write</code> 函数来实现向 SPI 从设备发送数据，<code>spi_write</code> 函数定义在 <code>include/linux/spi/spi.h</code> 文件中，具体内容如下所示</p><h2 id="spi-write"><a href="#spi-write" class="headerlink" title="spi_write()"></a>spi_write()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_write - SPI synchronous write</span></span><br><span class="line"><span class="comment"> * @spi: device to which data will be written</span></span><br><span class="line"><span class="comment"> * @buf: data buffer</span></span><br><span class="line"><span class="comment"> * @len: data buffer size</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function writes the buffer @buf.</span></span><br><span class="line"><span class="comment"> * Callable only from contexts that can sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">spi_write</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span><span class="title">t</span> =</span> &#123;</span><br><span class="line">.tx_buf= buf,</span><br><span class="line">.len= len,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> spi_sync_transfer(spi, &amp;t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先会对要传输的数据以及传输的数据大小进行封装，然后调用 <code>spi_sync_transfer</code>函数进行输入传输，<code>spi_write</code> 函数传入的第一个参数为 <code>spi_device</code> 类型的结构体变量。</p><p><code>struct spi_device</code> 是 Linux 内核中用于描述 SPI 从设备的结构体。它包含了与 SPI 设备相关的各种信息和配置选项，该结构体的具体内容如下所示：</p><h2 id="struct-spi-device"><a href="#struct-spi-device" class="headerlink" title="struct spi_device"></a>struct spi_device</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct spi_device - Controller side proxy for an SPI slave device</span></span><br><span class="line"><span class="comment"> * @dev: Driver model representation of the device.</span></span><br><span class="line"><span class="comment"> * @controller: SPI controller used with the device.</span></span><br><span class="line"><span class="comment"> * @master: Copy of controller, for backwards compatibility.</span></span><br><span class="line"><span class="comment"> * @max_speed_hz: Maximum clock rate to be used with this chip</span></span><br><span class="line"><span class="comment"> *(on this board); may be changed by the device&#x27;s driver.</span></span><br><span class="line"><span class="comment"> *The spi_transfer.speed_hz can override this for each transfer.</span></span><br><span class="line"><span class="comment"> * @chip_select: Chipselect, distinguishing chips handled by @controller.</span></span><br><span class="line"><span class="comment"> * @mode: The spi mode defines how data is clocked out and in.</span></span><br><span class="line"><span class="comment"> *This may be changed by the device&#x27;s driver.</span></span><br><span class="line"><span class="comment"> *The &quot;active low&quot; default for chipselect mode can be overridden</span></span><br><span class="line"><span class="comment"> *(by specifying SPI_CS_HIGH) as can the &quot;MSB first&quot; default for</span></span><br><span class="line"><span class="comment"> *each word in a transfer (by specifying SPI_LSB_FIRST).</span></span><br><span class="line"><span class="comment"> * @bits_per_word: Data transfers involve one or more words; word sizes</span></span><br><span class="line"><span class="comment"> *like eight or 12 bits are common.  In-memory wordsizes are</span></span><br><span class="line"><span class="comment"> *powers of two bytes (e.g. 20 bit samples use 32 bits).</span></span><br><span class="line"><span class="comment"> *This may be changed by the device&#x27;s driver, or left at the</span></span><br><span class="line"><span class="comment"> *default (0) indicating protocol words are eight bit bytes.</span></span><br><span class="line"><span class="comment"> *The spi_transfer.bits_per_word can override this for each transfer.</span></span><br><span class="line"><span class="comment"> * @rt: Make the pump thread real time priority.</span></span><br><span class="line"><span class="comment"> * @irq: Negative, or the number passed to request_irq() to receive</span></span><br><span class="line"><span class="comment"> *interrupts from this device.</span></span><br><span class="line"><span class="comment"> * @controller_state: Controller&#x27;s runtime state</span></span><br><span class="line"><span class="comment"> * @controller_data: Board-specific definitions for controller, such as</span></span><br><span class="line"><span class="comment"> *FIFO initialization parameters; from board_info.controller_data</span></span><br><span class="line"><span class="comment"> * @modalias: Name of the driver to use with this device, or an alias</span></span><br><span class="line"><span class="comment"> *for that name.  This appears in the sysfs &quot;modalias&quot; attribute</span></span><br><span class="line"><span class="comment"> *for driver coldplugging, and in uevents used for hotplugging</span></span><br><span class="line"><span class="comment"> * @driver_override: If the name of a driver is written to this attribute, then</span></span><br><span class="line"><span class="comment"> *the device will bind to the named driver and only the named driver.</span></span><br><span class="line"><span class="comment"> * @cs_gpio: LEGACY: gpio number of the chipselect line (optional, -ENOENT when</span></span><br><span class="line"><span class="comment"> *not using a GPIO line) use cs_gpiod in new drivers by opting in on</span></span><br><span class="line"><span class="comment"> *the spi_master.</span></span><br><span class="line"><span class="comment"> * @cs_gpiod: gpio descriptor of the chipselect line (optional, NULL when</span></span><br><span class="line"><span class="comment"> *not using a GPIO line)</span></span><br><span class="line"><span class="comment"> * @word_delay: delay to be inserted between consecutive</span></span><br><span class="line"><span class="comment"> *words of a transfer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @statistics: statistics for the spi_device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A @spi_device is used to interchange data between an SPI slave</span></span><br><span class="line"><span class="comment"> * (usually a discrete chip) and CPU memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In @dev, the platform_data is used to hold information about this</span></span><br><span class="line"><span class="comment"> * device that&#x27;s meaningful to the device&#x27;s protocol driver, but not</span></span><br><span class="line"><span class="comment"> * to its controller.  One example might be an identifier for a chip</span></span><br><span class="line"><span class="comment"> * variant with slightly different functionality; another might be</span></span><br><span class="line"><span class="comment"> * information about how this particular board wires the chip&#x27;s pins.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span><span class="title">dev</span>;</span> <span class="comment">// 通用设备模型的设备结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>*<span class="title">controller</span>;</span> <span class="comment">// 指向控制器的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>*<span class="title">master</span>;</span><span class="comment">/* compatibility layer */</span> <span class="comment">// 兼容层，指向控制器的指针（与 controller 相同）</span></span><br><span class="line">u32max_speed_hz;<span class="comment">// 设备支持的最大速度（以赫兹为单位</span></span><br><span class="line">u8chip_select;<span class="comment">// 片选编号</span></span><br><span class="line">u8bits_per_word;<span class="comment">// 每个字的位数</span></span><br><span class="line"><span class="type">bool</span>rt;</span><br><span class="line">u32mode;<span class="comment">// SPI 模式配置（包括时钟相位和极性等）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_CPHA0x01<span class="comment">/* clock phase */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_CPOL0x02<span class="comment">/* clock polarity */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_MODE_0(0|0)<span class="comment">/* (original MicroWire) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_MODE_1(0|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_MODE_2(SPI_CPOL|0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_MODE_3(SPI_CPOL|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_CS_HIGH0x04<span class="comment">/* chipselect active high? */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_LSB_FIRST0x08<span class="comment">/* per-word bits-on-wire */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_3WIRE0x10<span class="comment">/* SI/SO signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_LOOP0x20<span class="comment">/* loopback mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_NO_CS0x40<span class="comment">/* 1 dev/bus, no chipselect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_READY0x80<span class="comment">/* slave pulls low to pause */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_TX_DUAL0x100<span class="comment">/* transmit with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_TX_QUAD0x200<span class="comment">/* transmit with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_RX_DUAL0x400<span class="comment">/* receive with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_RX_QUAD0x800<span class="comment">/* receive with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_CS_WORD0x1000<span class="comment">/* toggle cs after each word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_TX_OCTAL0x2000<span class="comment">/* transmit with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_RX_OCTAL0x4000<span class="comment">/* receive with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_3WIRE_HIZ0x8000<span class="comment">/* high impedance turnaround */</span></span></span><br><span class="line"><span class="type">int</span>irq;</span><br><span class="line"><span class="type">void</span>*controller_state; <span class="comment">// 控制器状态的私有数据</span></span><br><span class="line"><span class="type">void</span>*controller_data; <span class="comment">// 控制器数据的私有数据</span></span><br><span class="line"><span class="type">char</span>modalias[SPI_NAME_SIZE];<span class="comment">// 设备别名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*driver_override;<span class="comment">// 驱动程序覆盖</span></span><br><span class="line"><span class="type">int</span>cs_gpio;<span class="comment">/* LEGACY: chip select gpio */</span> <span class="comment">// 片选 GPIO 引脚</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>*<span class="title">cs_gpiod</span>;</span><span class="comment">/* chip select gpio desc */</span> <span class="comment">// 片选 GPIO 引脚</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span><span class="title">word_delay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* the statistics */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_statistics</span><span class="title">statistics</span>;</span><span class="comment">// 统计数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * likely need more hooks for more protocol options affecting how</span></span><br><span class="line"><span class="comment"> * the controller talks to each chip, like:</span></span><br><span class="line"><span class="comment"> *  - memory packing (12 bit samples into low bits, others zeroed)</span></span><br><span class="line"><span class="comment"> *  - priority</span></span><br><span class="line"><span class="comment"> *  - chipselect delays</span></span><br><span class="line"><span class="comment"> *  - ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>spi_write</code> 函数可以向 SPI 从设备发送数据，而 <code>spi_read</code> 函数可以接收从设备发送的数据，<code>spi_read</code> 函数具体内容如下所示：</p><h2 id="spi-read"><a href="#spi-read" class="headerlink" title="spi_read()"></a>spi_read()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_read - SPI synchronous read</span></span><br><span class="line"><span class="comment"> * @spi: device from which data will be read</span></span><br><span class="line"><span class="comment"> * @buf: data buffer</span></span><br><span class="line"><span class="comment"> * @len: data buffer size</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function reads the buffer @buf.</span></span><br><span class="line"><span class="comment"> * Callable only from contexts that can sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">spi_read</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span><span class="title">t</span> =</span> &#123;</span><br><span class="line">.rx_buf= buf,</span><br><span class="line">.len= len,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> spi_sync_transfer(spi, &amp;t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 <code>spi_write</code> 函数相同，<code>spi_read</code> 函数也会对数据进行封包的操作，将数据 buf 以及数据大小 len 封包成 <code>spi_transfer</code> 类型的结构体，<code>struct spi_transfer</code> 是一个描述 SPI 数据传输的结构体，用于配置一次 SPI 数据传输的各种参数，该结构体的具体内容如下所示：</p><h3 id="struct-spi-transfer"><a href="#struct-spi-transfer" class="headerlink" title="struct spi_transfer"></a>struct spi_transfer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line"><span class="comment">/* it&#x27;s ok if tx_buf == rx_buf (right?)</span></span><br><span class="line"><span class="comment"> * for MicroWire, one buffer must be null</span></span><br><span class="line"><span class="comment"> * buffers must work with dma_*map_single() calls, unless</span></span><br><span class="line"><span class="comment"> *   spi_message.is_dma_mapped reports a pre-existing mapping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*tx_buf;<span class="comment">// 发送缓冲区</span></span><br><span class="line"><span class="type">void</span>*rx_buf;<span class="comment">// 接收缓冲区</span></span><br><span class="line"><span class="type">unsigned</span>len;<span class="comment">// 传输数据的长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">dma_addr_t</span>tx_dma;<span class="comment">// 发送缓冲区的 DMA 地址</span></span><br><span class="line"><span class="type">dma_addr_t</span>rx_dma;<span class="comment">// 接收缓冲区的 DMA 地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">tx_sg</span>;</span><span class="comment">// 发送缓冲区的散列-聚集表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> <span class="title">rx_sg</span>;</span><span class="comment">// 接收缓冲区的散列-聚集表</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span>cs_change:<span class="number">1</span>;<span class="comment">// 是否在传输后改变片选状态</span></span><br><span class="line"><span class="type">unsigned</span>tx_nbits:<span class="number">3</span>;<span class="comment">// 发送的位数（单线、双线或四线传输）</span></span><br><span class="line"><span class="type">unsigned</span>rx_nbits:<span class="number">3</span>;<span class="comment">// 接收的位数（单线、双线或四线传输）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_NBITS_SINGLE0x01 <span class="comment">/* 1bit transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_NBITS_DUAL0x02 <span class="comment">/* 2bits transfer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SPI_NBITS_QUAD0x04 <span class="comment">/* 4bits transfer */</span></span></span><br><span class="line">u8bits_per_word;<span class="comment">// 每个字的位数</span></span><br><span class="line">u16delay_usecs;<span class="comment">// 传输之间的延迟（微秒）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span><span class="title">delay</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span><span class="title">cs_change_delay</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span><span class="title">word_delay</span>;</span><span class="comment">// 每个字之间的延迟</span></span><br><span class="line">u32speed_hz;<span class="comment">// 传输速度（赫兹）</span></span><br><span class="line"></span><br><span class="line">u32effective_speed_hz;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ptp_sts_word_pre;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>ptp_sts_word_post;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ptp_system_timestamp</span> *<span class="title">ptp_sts</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span>timestamped;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPI_TRANS_FAIL_NO_STARTBIT(0)</span></span><br><span class="line">u16error;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="spi-sync-transfer"><a href="#spi-sync-transfer" class="headerlink" title="spi_sync_transfer()"></a>spi_sync_transfer()</h3><p>而 <code>spi_write</code> 函数和 <code>spi_read</code> 函数只差在<code>struct spi_transfer</code> 结构体参数的不同，而封装为<code>struct spi_transfer</code> 之后还需要再一次进行封装，<code>spi_write</code> 函数和 <code>spi_read</code> 函数最后都会调用<code>spi_sync_transfer</code> 函数，该函数的具体内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_sync_transfer - synchronous SPI data transfer</span></span><br><span class="line"><span class="comment"> * @spi: device with which data will be exchanged</span></span><br><span class="line"><span class="comment"> * @xfers: An array of spi_transfers</span></span><br><span class="line"><span class="comment"> * @num_xfers: Number of items in the xfer array</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Does a synchronous SPI data transfer of the given spi_transfer array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For more specific semantics see spi_sync().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">spi_sync_transfer</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_transfer *xfers,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> num_xfers)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">msg</span>;</span></span><br><span class="line"><span class="comment">// 使用给定的传输初始化 SPI 消息</span></span><br><span class="line">spi_message_init_with_transfers(&amp;msg, xfers, num_xfers);</span><br><span class="line"><span class="comment">// 同步方式发送 SPI 消息</span></span><br><span class="line"><span class="keyword">return</span> spi_sync(spi, &amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数主要用于封装 SPI 同步传输操作，简化了调用过程。调用了 <code>spi_message_init_with_transfers</code> 函数进行 SPI 传输数据的初始化，最后调用 <code>spi_sync</code> 函数采用同步的方式发送 SPI 数据，<code>spi_sync</code> 函数的具体内容如下所示：</p><h3 id="spi-sync"><a href="#spi-sync" class="headerlink" title="spi_sync()"></a>spi_sync()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_sync - blocking/synchronous SPI data transfers</span></span><br><span class="line"><span class="comment"> * @spi: device with which data will be exchanged</span></span><br><span class="line"><span class="comment"> * @message: describes the data transfers</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call may only be used from a context that may sleep.  The sleep</span></span><br><span class="line"><span class="comment"> * is non-interruptible, and has no timeout.  Low-overhead controller</span></span><br><span class="line"><span class="comment"> * drivers may DMA directly into and out of the message buffers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that the SPI device&#x27;s chip select is active during the message,</span></span><br><span class="line"><span class="comment"> * and then is normally disabled between messages.  Drivers for some</span></span><br><span class="line"><span class="comment"> * frequently-used devices may want to minimize costs of selecting a chip,</span></span><br><span class="line"><span class="comment"> * by leaving it selected in anticipation that the next message will go</span></span><br><span class="line"><span class="comment"> * to the same chip.  (That may increase power usage.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also, the caller is guaranteeing that the memory associated with the</span></span><br><span class="line"><span class="comment"> * message will not be freed before this call returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi_sync</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 锁定 SPI 控制器的总线锁互斥体</span></span><br><span class="line">mutex_lock(&amp;spi-&gt;controller-&gt;bus_lock_mutex);</span><br><span class="line">    <span class="comment">// 执行同步 SPI 传输</span></span><br><span class="line">ret = __spi_sync(spi, message);</span><br><span class="line">    <span class="comment">// 解锁 SPI 控制器的总线锁互斥体</span></span><br><span class="line">mutex_unlock(&amp;spi-&gt;controller-&gt;bus_lock_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(spi_sync);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数的主要作用是确保 SPI 数据传输操作在一个互斥锁的保护下进行，以避免并发传输导致的冲突和数据错误。</p><p>通过调用内部的 <code>__spi_sync</code> 函数来执行实际的数据传输。<code>__spi_sync</code>函数如下所示</p><h3 id="spi-sync-1"><a href="#spi-sync-1" class="headerlink" title="__spi_sync()"></a>__spi_sync()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __spi_sync(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *message)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明并初始化一个完成变量</span></span><br><span class="line">DECLARE_COMPLETION_ONSTACK(done);</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> *<span class="title">ctlr</span> =</span> spi-&gt;controller;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="comment">// 验证 SPI 设备和消息</span></span><br><span class="line">status = __spi_validate(spi, message);</span><br><span class="line"><span class="keyword">if</span> (status != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置消息完成回调和上下文</span></span><br><span class="line">message-&gt;complete = spi_complete;</span><br><span class="line">message-&gt;context = &amp;done;</span><br><span class="line">message-&gt;spi = spi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新统计信息</span></span><br><span class="line">SPI_STATISTICS_INCREMENT_FIELD(&amp;ctlr-&gt;statistics, spi_sync);</span><br><span class="line">SPI_STATISTICS_INCREMENT_FIELD(&amp;spi-&gt;statistics, spi_sync);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we&#x27;re not using the legacy transfer method then we will</span></span><br><span class="line"><span class="comment"> * try to transfer in the calling context so special case.</span></span><br><span class="line"><span class="comment"> * This code would be less tricky if we could remove the</span></span><br><span class="line"><span class="comment"> * support for driver implemented message queues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;transfer == spi_queued_transfer) &#123;</span><br><span class="line">spin_lock_irqsave(&amp;ctlr-&gt;bus_lock_spinlock, flags);<span class="comment">// 锁定总线锁旋转锁并保存中断标志</span></span><br><span class="line"></span><br><span class="line">trace_spi_message_submit(message);<span class="comment">// 记录 SPI 消息提交的跟踪信息</span></span><br><span class="line"></span><br><span class="line">status = __spi_queued_transfer(spi, message, <span class="literal">false</span>);<span class="comment">// 执行队列传输</span></span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;ctlr-&gt;bus_lock_spinlock, flags);<span class="comment">// 解锁总线锁旋转锁并恢复中断标志</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">status = spi_async_locked(spi, message);<span class="comment">// 异步锁定传输</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* Push out the messages in the calling context if we</span></span><br><span class="line"><span class="comment"> * can.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;transfer == spi_queued_transfer) &#123;<span class="comment">/* 如果可以，则在调用上下文中推送消息 */</span></span><br><span class="line">            <span class="comment">// 更新同步立即传输的统计信息</span></span><br><span class="line">SPI_STATISTICS_INCREMENT_FIELD(&amp;ctlr-&gt;statistics,</span><br><span class="line">       spi_sync_immediate);</span><br><span class="line">SPI_STATISTICS_INCREMENT_FIELD(&amp;spi-&gt;statistics,</span><br><span class="line">       spi_sync_immediate);</span><br><span class="line">            <span class="comment">// 推送消息</span></span><br><span class="line">__spi_pump_messages(ctlr, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待完成</span></span><br><span class="line">wait_for_completion(&amp;done);</span><br><span class="line">        <span class="comment">// 获取消息的状态</span></span><br><span class="line">status = message-&gt;status;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 清除消息的上下文</span></span><br><span class="line">message-&gt;context = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数的主要作用是在锁定的上下文中同步执行 SPI 消息传输。它负责初始化传输消息，验证消息和设备的有效性，处理传输，并在完成后返回传输的状态。该函数的重点在<code>__spi_pump_messages</code> 推送消息函数，该函数的具体内容如下所示：</p><h3 id="spi-pump-messages"><a href="#spi-pump-messages" class="headerlink" title="__spi_pump_messages()"></a>__spi_pump_messages()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __spi_pump_messages - function which processes spi message queue</span></span><br><span class="line"><span class="comment"> * @ctlr: controller to process queue for</span></span><br><span class="line"><span class="comment"> * @in_kthread: true if we are in the context of the message pump thread</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function checks if there is any spi message in the queue that</span></span><br><span class="line"><span class="comment"> * needs processing and if so call out to the driver to initialize hardware</span></span><br><span class="line"><span class="comment"> * and transfer each message.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that it is called both from the kthread itself and also from</span></span><br><span class="line"><span class="comment"> * inside spi_sync(); the queue extraction handling at the top of the</span></span><br><span class="line"><span class="comment"> * function should deal with this safely.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __spi_pump_messages(<span class="keyword">struct</span> spi_controller *ctlr, <span class="type">bool</span> in_kthread)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">xfer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> *<span class="title">msg</span>;</span></span><br><span class="line"><span class="type">bool</span> was_busy = <span class="literal">false</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Lock queue */</span></span><br><span class="line">spin_lock_irqsave(&amp;ctlr-&gt;queue_lock, flags);<span class="comment">/* 锁定消息队列 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make sure we are not already running a message */</span></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;cur_msg) &#123;<span class="comment">/* 确保没有其他消息正在处理 */</span></span><br><span class="line">spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If another context is idling the device then defer */</span></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;idling) &#123;<span class="comment">/* 如果另一个上下文正在空闲设备，则推迟处理 */</span></span><br><span class="line">kthread_queue_work(ctlr-&gt;kworker, &amp;ctlr-&gt;pump_messages);</span><br><span class="line">spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if the queue is idle */</span></span><br><span class="line"><span class="keyword">if</span> (list_empty(&amp;ctlr-&gt;<span class="built_in">queue</span>) || !ctlr-&gt;running) &#123;<span class="comment">/* 检查队列是否空闲 */</span></span><br><span class="line"><span class="keyword">if</span> (!ctlr-&gt;busy) &#123;</span><br><span class="line">spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Defer any non-atomic teardown to the thread */</span></span><br><span class="line"><span class="keyword">if</span> (!in_kthread) &#123;<span class="comment">/* 只有在线程中执行拆除操作 */</span></span><br><span class="line"><span class="keyword">if</span> (!ctlr-&gt;dummy_rx &amp;&amp; !ctlr-&gt;dummy_tx &amp;&amp;</span><br><span class="line">    !ctlr-&gt;unprepare_transfer_hardware) &#123;</span><br><span class="line">spi_idle_runtime_pm(ctlr);</span><br><span class="line">ctlr-&gt;busy = <span class="literal">false</span>;</span><br><span class="line">trace_spi_controller_idle(ctlr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">kthread_queue_work(ctlr-&gt;kworker,</span><br><span class="line">   &amp;ctlr-&gt;pump_messages);</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctlr-&gt;busy = <span class="literal">false</span>;</span><br><span class="line">ctlr-&gt;idling = <span class="literal">true</span>;</span><br><span class="line">spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"></span><br><span class="line">kfree(ctlr-&gt;dummy_rx);</span><br><span class="line">ctlr-&gt;dummy_rx = <span class="literal">NULL</span>;</span><br><span class="line">kfree(ctlr-&gt;dummy_tx);</span><br><span class="line">ctlr-&gt;dummy_tx = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;unprepare_transfer_hardware &amp;&amp;</span><br><span class="line">    ctlr-&gt;unprepare_transfer_hardware(ctlr))</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev,</span><br><span class="line"><span class="string">&quot;failed to unprepare transfer hardware\n&quot;</span>);</span><br><span class="line">spi_idle_runtime_pm(ctlr);</span><br><span class="line">trace_spi_controller_idle(ctlr);</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line">ctlr-&gt;idling = <span class="literal">false</span>;</span><br><span class="line">spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Extract head of queue */</span></span><br><span class="line">msg = list_first_entry(&amp;ctlr-&gt;<span class="built_in">queue</span>, <span class="keyword">struct</span> spi_message, <span class="built_in">queue</span>);<span class="comment">/* 从队列中获取第一个消息 */</span></span><br><span class="line">ctlr-&gt;cur_msg = msg;</span><br><span class="line"></span><br><span class="line">list_del_init(&amp;msg-&gt;<span class="built_in">queue</span>);</span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;busy)</span><br><span class="line">was_busy = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ctlr-&gt;busy = <span class="literal">true</span>;</span><br><span class="line">spin_unlock_irqrestore(&amp;ctlr-&gt;queue_lock, flags);</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;ctlr-&gt;io_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!was_busy &amp;&amp; ctlr-&gt;auto_runtime_pm) &#123;</span><br><span class="line">ret = pm_runtime_get_sync(ctlr-&gt;dev.parent);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pm_runtime_put_noidle(ctlr-&gt;dev.parent);</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;Failed to power device: %d\n&quot;</span>,</span><br><span class="line">ret);</span><br><span class="line">mutex_unlock(&amp;ctlr-&gt;io_mutex);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!was_busy)</span><br><span class="line">trace_spi_controller_busy(ctlr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!was_busy &amp;&amp; ctlr-&gt;prepare_transfer_hardware) &#123;</span><br><span class="line">ret = ctlr-&gt;prepare_transfer_hardware(ctlr);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev,</span><br><span class="line"><span class="string">&quot;failed to prepare transfer hardware: %d\n&quot;</span>,</span><br><span class="line">ret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;auto_runtime_pm)</span><br><span class="line">pm_runtime_put(ctlr-&gt;dev.parent);</span><br><span class="line"></span><br><span class="line">msg-&gt;status = ret;</span><br><span class="line">spi_finalize_current_message(ctlr);</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;ctlr-&gt;io_mutex);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trace_spi_message_start(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctlr-&gt;prepare_message) &#123;</span><br><span class="line">ret = ctlr-&gt;prepare_message(ctlr, msg);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev, <span class="string">&quot;failed to prepare message: %d\n&quot;</span>,</span><br><span class="line">ret);</span><br><span class="line">msg-&gt;status = ret;</span><br><span class="line">spi_finalize_current_message(ctlr);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">ctlr-&gt;cur_msg_prepared = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = spi_map_msg(ctlr, msg);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">msg-&gt;status = ret;</span><br><span class="line">spi_finalize_current_message(ctlr);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ctlr-&gt;ptp_sts_supported &amp;&amp; !ctlr-&gt;transfer_one) &#123;</span><br><span class="line">list_for_each_entry(xfer, &amp;msg-&gt;transfers, transfer_list) &#123;</span><br><span class="line">xfer-&gt;ptp_sts_word_pre = <span class="number">0</span>;</span><br><span class="line">ptp_read_system_prets(xfer-&gt;ptp_sts);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = ctlr-&gt;transfer_one_message(ctlr, msg);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">dev_err(&amp;ctlr-&gt;dev,</span><br><span class="line"><span class="string">&quot;failed to transfer one message from queue\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">mutex_unlock(&amp;ctlr-&gt;io_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prod the scheduler in case transfer_one() was busy waiting */</span></span><br><span class="line"><span class="keyword">if</span> (!ret)<span class="comment">/* 如果成功传输，则唤醒调度器 *</span></span><br><span class="line"><span class="comment">cond_resched();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure><p>代码 <code>ctlr-&gt;transfer_one_message</code> 是一个函数指针，它指向了 SPI 控制器中负责执行 SPI 消息传输的函数。通过调用这个函数，将当前的 SPI 消息 <code>ctlr-&gt;cur_msg</code> 传递给该函数进行处理。这个函数通常会负责将消息的数据发送到 SPI 设备或从设备接收数据，并与硬件设备进行通信。</p><p>因此，<code>ctlr-&gt;transfer_one_message(ctlr, ctlr-&gt;cur_msg)</code>这一行代码的作用是将当前的 SPI 消息传递给 SPI 控制器中的传输函数进行处理，以完成消息的传输操作。</p><h3 id="spi-write-then-read"><a href="#spi-write-then-read" class="headerlink" title="spi_write_then_read()"></a>spi_write_then_read()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * spi_write_then_read - SPI synchronous write followed by read</span></span><br><span class="line"><span class="comment"> * @spi: device with which data will be exchanged</span></span><br><span class="line"><span class="comment"> * @txbuf: data to be written (need not be dma-safe)</span></span><br><span class="line"><span class="comment"> * @n_tx: size of txbuf, in bytes</span></span><br><span class="line"><span class="comment"> * @rxbuf: buffer into which data will be read (need not be dma-safe)</span></span><br><span class="line"><span class="comment"> * @n_rx: size of rxbuf, in bytes</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This performs a half duplex MicroWire style transaction with the</span></span><br><span class="line"><span class="comment"> * device, sending txbuf and then reading rxbuf.  The return value</span></span><br><span class="line"><span class="comment"> * is zero for success, else a negative errno status code.</span></span><br><span class="line"><span class="comment"> * This call may only be used from a context that may sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parameters to this routine are always copied using a small buffer.</span></span><br><span class="line"><span class="comment"> * Performance-sensitive or bulk transfer code should instead use</span></span><br><span class="line"><span class="comment"> * spi_&#123;async,sync&#125;() calls with dma-safe buffers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: zero on success, else a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">spi_write_then_read</span><span class="params">(<span class="keyword">struct</span> spi_device *spi,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">void</span> *txbuf, <span class="type">unsigned</span> n_tx,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *rxbuf, <span class="type">unsigned</span> n_rx)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_MUTEX</span><span class="params">(lock)</span>;<span class="comment">// 定义一个静态互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>status;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span><span class="title">message</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span><span class="title">x</span>[2];</span></span><br><span class="line">u8*local_buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use preallocated DMA-safe buffer if we can.  We can&#x27;t avoid</span></span><br><span class="line"><span class="comment"> * copying here, (as a pure convenience thing), but we can</span></span><br><span class="line"><span class="comment"> * keep heap costs out of the hot path unless someone else is</span></span><br><span class="line"><span class="comment"> * using the pre-allocated buffer or the transfer is too large.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((n_tx + n_rx) &gt; SPI_BUFSIZ || !mutex_trylock(&amp;lock)) &#123;</span><br><span class="line">local_buf = kmalloc(max((<span class="type">unsigned</span>)SPI_BUFSIZ, n_tx + n_rx),</span><br><span class="line">    GFP_KERNEL | GFP_DMA);</span><br><span class="line"><span class="keyword">if</span> (!local_buf)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM; <span class="comment">// 如果内存分配失败，返回错误码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">local_buf = buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spi_message_init(&amp;message);<span class="comment">// 初始化 SPI 消息</span></span><br><span class="line"><span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line"><span class="keyword">if</span> (n_tx) &#123;</span><br><span class="line">x[<span class="number">0</span>].len = n_tx;</span><br><span class="line">spi_message_add_tail(&amp;x[<span class="number">0</span>], &amp;message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n_rx) &#123;</span><br><span class="line">x[<span class="number">1</span>].len = n_rx;</span><br><span class="line">spi_message_add_tail(&amp;x[<span class="number">1</span>], &amp;message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(local_buf, txbuf, n_tx);<span class="comment">// 将发送数据复制到本地缓冲区</span></span><br><span class="line">x[<span class="number">0</span>].tx_buf = local_buf;</span><br><span class="line">x[<span class="number">1</span>].rx_buf = local_buf + n_tx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* do the i/o */</span></span><br><span class="line">status = spi_sync(spi, &amp;message);<span class="comment">/* 执行 I/O 操作 */</span></span><br><span class="line"><span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">memcpy</span>(rxbuf, x[<span class="number">1</span>].rx_buf, n_rx);<span class="comment">// 如果传输成功，将接收数据复制到接收缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x[<span class="number">0</span>].tx_buf == buf)<span class="comment">// 释放锁或释放内存</span></span><br><span class="line">mutex_unlock(&amp;lock);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">kfree(local_buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;<span class="comment">// 返回传输状态</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(spi_write_then_read);</span><br></pre></td></tr></table></figure><h1 id="mcp2515-驱动编写"><a href="#mcp2515-驱动编写" class="headerlink" title="mcp2515 驱动编写"></a>mcp2515 驱动编写</h1><h2 id="复位函数"><a href="#复位函数" class="headerlink" title="复位函数"></a>复位函数</h2><p>MCP2515 具有五种模式，分别为：</p><ul><li>配置模式</li><li>正常模式</li><li>休眠模式</li><li>仅监听模式</li><li>环回模式</li></ul><emp>只有在配置模式下，才能对关键寄存器进行初始化和配置</emp>，当 MCP2515 上电或者复位时，器件会自动进入配置模式，而 MCP2515 提供了一系列的 SPI 指令，SPI 指令表如下图所示：<p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144052698.png" alt="MCP2515 指令集" loading="lazy">通过向 MCP2515 发送上述 SPI 指令就能实现复位、读、写等操作，复位操作对应的指令格式为 <code>11000000</code>。示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi_dev</span>;</span> <span class="comment">// SPI 设备指针</span></span><br><span class="line"><span class="comment">// MCP2515 芯片复位函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mcp2515_reset</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="type">char</span> write_buf[] = &#123;<span class="number">0xc0</span>&#125;; <span class="comment">// 复位指令 0x11000000 即 0xc0</span></span><br><span class="line">ret = spi_write(spi_dev, write_buf, <span class="keyword">sizeof</span>(write_buf)); <span class="comment">// 发送复位命令</span></span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;spi_write is error\n&quot;</span>); <span class="comment">// 打印错误信息</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读寄存器函数"><a href="#读寄存器函数" class="headerlink" title="读寄存器函数"></a>读寄存器函数</h2><p>TODO</p><h2 id="配置模式下寄存器的配置"><a href="#配置模式下寄存器的配置" class="headerlink" title="配置模式下寄存器的配置"></a>配置模式下寄存器的配置</h2><p>TOOD</p><h2 id="修改工作模式"><a href="#修改工作模式" class="headerlink" title="修改工作模式"></a>修改工作模式</h2><p>TODO</p><h2 id="完善-write-和-read-函数"><a href="#完善-write-和-read-函数" class="headerlink" title="完善 write 和 read 函数"></a>完善 write 和 read 函数</h2><p>TODO</p><h1 id="Linux-中通用-SPI-设备驱动"><a href="#Linux-中通用-SPI-设备驱动" class="headerlink" title="Linux 中通用 SPI 设备驱动"></a>Linux 中通用 SPI 设备驱动</h1><p>跟 I2C 设备类似，在 Linux内核中也有着通用 SPI 设备驱动，menuconfig路径如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Device</span> <span class="type">Drivers</span></span><br><span class="line">&gt; <span class="type">SPI</span> sup<span class="keyword">port</span></span><br><span class="line">[] <span class="type">User</span> mode <span class="type">SPI</span> device driver sup<span class="keyword">port</span></span><br></pre></td></tr></table></figure><p>除了内核支持之外，还需要修改设备树，由于之前已经使能了 SPI0，所以这直接修改之前编写的 mcp2515 设备树节点，修改完成的 mcp2515 节点如下所示：<code>rockchip,spidev</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;spi0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins_hs</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">mcp2515:</span><span class="title class_">mcp2515@0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,spidev&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>开发板启动之后，如果存在&#x2F;dev&#x2F;spidev0.0 设备节点，证明设备树及内核配置正确，</p><p><code>/dev/spidev0.0</code> 表示一个 SPI 总线上的具体设备。0.0 是一个标识符，用于区分系统中的不同 SPI 控制器和设备。这个标识符由两部分组成：</p><ul><li>第一个数字 0：表示 SPI 总线的编号。一个系统中可能有多个 SPI 控制器，每个控制器对应一个总线编号，从 0 开始。</li><li>第二个数字 0：表示连接在该 SPI 总线上的具体设备编号。一个 SPI 总线上可以连接多个设备，每个设备通过片选信号（Chip Select, CS）进行区分，设备编号从 0 开始。</li></ul><h2 id="spidev-test-工具"><a href="#spidev-test-工具" class="headerlink" title="spidev_test 工具"></a>spidev_test 工具</h2><p><code>spidev_test</code> 是一个用于测试和调试 SPI 设备的命令行工具，通常在 Linux 系统上使用，它允许用户直接通过 SPI 总线与设备进行通信，可以发送数据并接收来自设备的响应。<code>spidev_test</code> 源码位于topeet Linux 源码的 <code>kernel/tools/spi</code> 目录下，编译要交叉编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">CC=/home/topeet/Linux/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-lin</span><br><span class="line">ux-gnu/bin/aarch64-linux-gnu-gcc</span><br><span class="line">LD=/home/topeet/Linux/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-lin</span><br><span class="line">ux-gnu/bin/aarch64-linux-gnu-ld</span><br></pre></td></tr></table></figure><ul><li><p><strong>基本介绍</strong>：spidev_test 是一个用于测试和验证 Linux 中 SPI 设备驱动程序的用户空间工具。它使用 spidev 接口与 SPI 设备通信。这个工具主要用来检查 SPI 设备是否工作正常，以及对 SPI 设备进行基本的读写操作。</p></li><li><p><strong>主要选项和参数</strong>：</p><ul><li><code>-D /dev/spidevX.Y</code>：指定要测试的 SPI 设备节点。</li><li><code>-s &lt;speed&gt;</code>：设置 SPI 时钟频率（以 Hz 为单位），例如 -s 1000000 表示 1 MHz。</li><li><code>-d &lt;delay&gt;</code>：设置数据传输之间的延迟时间（以微秒为单位）。</li><li><code>-b &lt;bits per word&gt;</code>：设置每个数据字的位数，通常是 8 或 16。</li><li><code>-H</code>：以十六进制模式显示传输的数据。</li></ul></li><li><p><strong>示例操作</strong></p><ul><li>读取设备信息：<code>spidev_test -D /dev/spidevX.Y -s 1000000</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144134950.png" alt="读取设备信息" loading="lazy"></p><p>这会使用 1 MHz 的时钟频率从 SPI 设备读取数据，默认情况下以十六进制显示</p><ul><li>写入和读取数据：<code>spidev_test -D /dev/spidevX.Y -s 1000000 -b 8 -d 1000 -H -p &#39;hello&#39;</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144141950.png" alt="写入和读取数据" loading="lazy"></p><p>这条命令会向 SPI 设备写入字符串 ‘hello’，并以十六进制模式显示设备的响应数据。<code>-b 8</code>指定每个字的位数为 8，<code>-d 1000</code> 设置 1000 微秒的延迟。</p></li><li><p><strong>连续传输</strong>：<code>spidev_test -D /dev/spidevX.Y -s 1000000 -b 8 -p &#39;abcdefgh&#39;</code></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251230144154098.png" alt="连续传输" loading="lazy"></p></li></ul><p>这个示例将连续发送字节 ‘abcdefgh’ 到 SPI 设备。</p><h2 id="spidev-fdx-工具"><a href="#spidev-fdx-工具" class="headerlink" title="spidev_fdx 工具"></a>spidev_fdx 工具</h2><ul><li><p><strong>基本介绍</strong>：spidev_fdx 是一个用于全双工 SPI 通信测试的命令行工具，主要用于在Linux 系统上与 SPI 设备进行双向数据传输和测试。</p></li><li><p><strong>主要选项和参数</strong></p><ul><li><code>-D /dev/spidevX.Y</code>：指定要测试的 SPI 设备节点。</li><li><code>-s &lt;speed&gt;</code>：设置 SPI 时钟频率（以 Hz 为单位），例如 -s 1000000 表示 1 MHz。</li><li><code>-w &lt;write_data&gt;</code>：指定要写入到 SPI 设备的数据，可以是十六进制或 ASCII 格式的字符串。</li><li><code>-r &lt;read_size&gt;</code>：指定从 SPI 设备读取的数据大小（以字节为单位）。</li><li><code>-b &lt;bits per word&gt;</code>：设置每个数据字的位数，通常是 8 或 16。</li><li><code>-d &lt;delay&gt;</code>：设置数据传输之间的延迟时间（以微秒为单位）。</li></ul></li><li><p><strong>示例操作</strong></p><ul><li><p><strong>发送和接收数据</strong>：<code>spidev_fdx -D /dev/spidevX.Y -s 1000000 -w &#39;hello&#39; -r 5</code></p><p>这会向 SPI 设备写入字符串 ‘hello’，并从设备读取 5 个字节的响应数据。</p></li><li><p>设置时钟频率和延迟：<code>spidev_fdx -D /dev/spidevX.Y -s 500000 -d 200 -w &#39;abcdef&#39; -r 10</code></p><p>这个示例将 SPI 时钟频率设置为 500 kHz，数据写入延迟为 200 微秒，并向设备写入字符串 ‘abcdef’，然后读取 10 个字节的响应数据。</p></li></ul></li></ul><h2 id="应用程序中如何使用-SPI"><a href="#应用程序中如何使用-SPI" class="headerlink" title="应用程序中如何使用 SPI"></a>应用程序中如何使用 SPI</h2><p>可以参考 <code>spidev_test</code> 工具的源码</p><h1 id="Linux中使用模拟SPI"><a href="#Linux中使用模拟SPI" class="headerlink" title="Linux中使用模拟SPI"></a>Linux中使用模拟SPI</h1><p>首先将模拟 SPI 驱动编译进内核，在 make menuconfig 图形化配置界面中选中如下选项</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D<span class="function"><span class="title">evice</span> Drivers ---&gt;</span></span><br><span class="line">[*]SPI <span class="function"><span class="title">support</span> --&gt;</span></span><br><span class="line">&lt;*&gt; GPIO-based bitbanging SPI Master <span class="comment">//选中</span></span><br></pre></td></tr></table></figure><p>软件 SPI 选定的引脚为开发板背面的 4 个 GPIO，具体引脚功能图如下所示：</p><table><thead><tr><th>RK3568 网络标号</th><th>对应 GPIO</th><th>模拟功能</th></tr></thead><tbody><tr><td>DVP_PWREN0_H_GPIO0_B0</td><td>GPIO0_B0</td><td>SCLK</td></tr><tr><td>PDM_SDI3_M0_ADC</td><td>GPIO1_B0</td><td>MISO</td></tr><tr><td>PDM_SDI2_M0_ADC</td><td>GPIO1_B1</td><td>MOSI</td></tr><tr><td>PDM_SDI1_M0_ADC</td><td>GPIO1_B2</td><td>CS</td></tr></tbody></table><p>设备树修改步骤如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spi5:</span> <span class="title class_">spi@gpiol</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;spi-gpio&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="attr">gpio-sck</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> RK_PB0_GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">gpio-miso</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PB0_GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">gpio-mosi</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PB1_GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">cs-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> RK_PB2_GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">num-chipselects</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi5_gpios</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>然后对 pinctrl 节点进行追加，设置引脚复用：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">spi5_gpios:</span> <span class="title class_">gpios</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span> RK_PB0 <span class="number">0</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line"><span class="params">&lt;<span class="number">1</span> RK_PB0 <span class="number">0</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line"><span class="params">&lt;<span class="number">1</span> RK_PB1 <span class="number">0</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line"><span class="params">&lt;<span class="number">1</span> RK_PB2 <span class="number">0</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">&gt;<span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>最后修改之前编写的 mcp2515 节点</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;spi5</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">mcp2515:</span><span class="title class_">mcp2515@0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,spidev&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/spidev5.0</span><br><span class="line">./spidev_test -D /dev/spidev5.0 -v</span><br></pre></td></tr></table></figure><h1 id="移植官方-mcp2515-驱动"><a href="#移植官方-mcp2515-驱动" class="headerlink" title="移植官方 mcp2515 驱动"></a>移植官方 mcp2515 驱动</h1><p>Linux 内 核 源 码 中 默 认 已 经 有 了 MCP2515 的 驱 动 程 序 ， 驱 动 具 体 路 径 为<code>drivers/net/can/spi/mcp251x.c</code>，所以只需要在<code>make menuconfig</code> 图形化配置界面选中即可：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Networking</span> sup<span class="keyword">port</span></span><br><span class="line">&gt; <span class="type">CAN</span> bus subsystem sup<span class="keyword">port</span></span><br><span class="line">&gt; <span class="type">CAN</span> <span class="type">Device</span> <span class="type">Drivers</span></span><br><span class="line">&gt; <span class="type">CAN</span> <span class="type">SPI</span> interfaces</span><br><span class="line">&lt;*&gt; <span class="type">Microchip</span> <span class="type">MCP251x</span> and <span class="type">MCP25625</span> <span class="type">SPI</span> <span class="type">CAN</span> controllers</span><br></pre></td></tr></table></figure><p>然后在设备树中添加如下节点：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;spi0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-1</span> = <span class="params">&lt;<span class="variable">&amp;spi0m1_cs0</span> <span class="variable">&amp;spi0m1_pins_hs</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">mcp2515:</span> <span class="title class_">mcp2515@0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;microchip,mcp2515&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">spi-max-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">10000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;RK_PB0 IRQ_TYPE_EDGE_FALLING&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;mcp2515_int</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;clk8m</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">clk8m:</span> <span class="title class_">clk8m</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;fixed-clock&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#clock-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">8000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>在 pinctrl 节点下添加以下内容</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mcp2515-gpio<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">mcp2515_int:</span><span class="title class_">mcp2515-int</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span> RK_PB0 RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br><span class="line"><span class="comment"># 回环测试</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 down</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 <span class="built_in">type</span> can bitrate 250000</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> can1 <span class="built_in">type</span> can loopback on</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> up can1</span><br><span class="line">candump can1 -L &amp;</span><br><span class="line">cansend can1 123#1122334455667788</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux SPI</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>WSL2安装Ubuntu-20.04与配置</title>
    <link href="https://even629.com/posts/2512299/"/>
    <id>https://even629.com/posts/2512299/</id>
    <published>2025-12-29T03:20:13.000Z</published>
    <updated>2025-12-29T03:20:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-29</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="wsl下载ubuntu"><a href="#wsl下载ubuntu" class="headerlink" title="wsl下载ubuntu"></a>wsl下载ubuntu</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可以下载的镜像</span></span><br><span class="line">wsl <span class="literal">--list</span> <span class="literal">--online</span></span><br><span class="line"><span class="comment"># 下载ubuntu20.04</span></span><br><span class="line">wsl <span class="literal">--install</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><h1 id="迁移到D盘"><a href="#迁移到D盘" class="headerlink" title="迁移到D盘"></a>迁移到D盘</h1><p>在D盘创建一个目录用来存放新的WSL，比如D:\WSL\Ubuntu-20.04</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 导出它的备份（比如命名为Ubuntu.tar)</span></span><br><span class="line">wsl <span class="literal">--export</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span> D:\WSL\Ubuntu<span class="literal">-20</span>.<span class="number">04</span>.tar</span><br><span class="line"><span class="comment"># 2. 注销原来的</span></span><br><span class="line">wsl <span class="literal">--unregister</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span></span><br><span class="line"><span class="comment"># 3. 将备份文件恢复到D:\WSL\Ubuntu-20.04中去</span></span><br><span class="line">wsl <span class="literal">--import</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span> D:\WSL\Ubuntu<span class="literal">-20</span>.<span class="number">04</span> D:\WSL\Ubuntu<span class="literal">-20</span>.<span class="number">04</span>.tar</span><br><span class="line"><span class="comment"># 这时候可以把Ubuntu-20.04.tar删除了</span></span><br></pre></td></tr></table></figure><p>如果这时候启动WSL，发现好像已经恢复正常了，但是用户变成了root。用以下命令恢复：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu2004 config <span class="literal">--default-user</span> username</span><br></pre></td></tr></table></figure><h1 id="安装最新版emacs"><a href="#安装最新版emacs" class="headerlink" title="安装最新版emacs"></a>安装最新版emacs</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Optional: 卸载snapd</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get purge snapd</span><br><span class="line"><span class="comment"># 编译tree-sitter</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tree-sitter/tree-sitter.git</span><br><span class="line"><span class="built_in">cd</span> tree-sitter</span><br><span class="line">git checkout release-0.25</span><br><span class="line">make</span><br><span class="line">make install PREFIX=<span class="string">&quot;<span class="subst">$(pwd)</span>/_install&quot;</span></span><br><span class="line"><span class="comment"># 修复 .pc 文件中的 prefix</span></span><br><span class="line">emacs _install/lib/pkgconfig/tree-sitter.pc</span><br><span class="line">prefix=/home/zhaohang/repository/tree-sitter/_install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量~/.bashrc或~/.zshrc</span></span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=<span class="string">&quot;<span class="variable">$HOME</span>/repository/tree-sitter/_install/lib/pkgconfig:<span class="variable">$PKG_CONFIG_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载emacs源码</span></span><br><span class="line">wget https://mirrors.ustc.edu.cn/gnu/emacs/emacs-30.2.tar.xz</span><br><span class="line"><span class="built_in">cd</span> emacs-30.2</span><br><span class="line"><span class="built_in">sudo</span> apt install zlib1g-dev libgccjit-9-dev pkg-config libgnutls28-dev libncurses-dev</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;<span class="variable">$HOME</span>/repository/tree-sitter/_install/lib:<span class="variable">$LD_LIBRARY_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">    --without-x \</span><br><span class="line">    --without-ns \</span><br><span class="line">    --without-pgtk \</span><br><span class="line">    --with-native-compilation \</span><br><span class="line">    --with-threads \</span><br><span class="line">    --with-tree-sitter \</span><br><span class="line">    --prefix=/usr/local \</span><br><span class="line">    LDFLAGS=<span class="string">&quot;-Wl,-rpath,<span class="variable">$LD_LIBRARY_PATH</span> -L<span class="variable">$LD_LIBRARY_PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="comment"># 编译后测试，应该输出：RUNPATH /home/zhaohang/repository/tree-sitter/_install/lib：</span></span><br><span class="line">objdump -p /usr/local/bin/emacs | grep RUNPATH</span><br></pre></td></tr></table></figure><ul><li><code>--without-x</code>  emacs-nox，不使用 X11（Xorg），只能用 emacs -nw（终端）</li><li><code>--without-ns</code> 禁用 macOS 的 Cocoa &#x2F; NS 窗口系统，只是防止 configure 自动探测到 macOS GUI</li><li><code>--without-pgtk</code> 禁用 Pure GTK（Wayland 下的新 GUI 后端）</li><li><code>--with-native-compilation</code> 启用 native-comp（.eln）将Elisp 编译成机器码</li><li><code>--with-threads</code>启用 多线程支持</li><li><code>--with-tree-sitter</code> 启用tree-sitter</li><li><code>--prefix=/usr/local</code>安装到 &#x2F;usr&#x2F;local</li></ul><p>emacs配置参考：</p><div class="tag link"><a class="link-card" title="我的Emacs配置" href="https://even629.com/posts/28521"><div class="left"><img src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">我的Emacs配置</p><p class="url">https://even629.com/posts/28521</p></div></a></div><p>另外通过apt下载的clangd版本比较老，可能不支持某些配置项，可通过下面命令安装较新的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget https://apt.llvm.org/llvm.sh</span><br><span class="line"><span class="built_in">chmod</span> u+x llvm.sh</span><br><span class="line"><span class="built_in">sudo</span> ./llvm.sh 21</span><br><span class="line"><span class="built_in">sudo</span> apt-get install clang-format-21</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 clang 到 alternatives 系统</span></span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/clang clang /usr/bin/clang-21 100</span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/clang++ clang++ /usr/bin/clang++-21 100</span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-21 100</span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-21 100</span><br></pre></td></tr></table></figure><p>git 版本比较低，不支持<code>-b</code>参数，可以添加apt源更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:git-core/ppa -y</span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br><span class="line"><span class="built_in">sudo</span> apt install git -y</span><br></pre></td></tr></table></figure><p>python 版本是3.8某些软件可能依赖3.9及以上的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install python3.9 python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册 python3.9，优先级设置为1</span></span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.9 1</span><br><span class="line"><span class="comment"># 注册 python3.8，优先级设置为2，这样优先级大于python3.9</span></span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.8 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择默认版本</span></span><br><span class="line"><span class="built_in">sudo</span> update-alternatives --config python3</span><br></pre></td></tr></table></figure><p>bear 也可以使用最新版本，旧版本的bear是python脚本，效率偏低，而新版本是rust编写的二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载rust</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"><span class="comment"># cargo 换源 visit https://mirrors.tuna.tsinghua.edu.cn/help/crates.io-index.git/</span></span><br><span class="line">rustup update</span><br><span class="line"><span class="comment"># 编译bear</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/rizsotto/Bear.git</span><br><span class="line"><span class="built_in">cd</span> bear</span><br><span class="line">cargo build --release</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> install -m 755 target/release/bear /usr/local/bin/</span><br><span class="line"><span class="comment"># For Debian based systems</span></span><br><span class="line"><span class="built_in">export</span> INSTALL_LIBDIR=lib/x86_64-linux-gnu</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /usr/local/libexec/bear/<span class="variable">$INSTALL_LIBDIR</span></span><br><span class="line"><span class="built_in">sudo</span> install -m 755 target/release/libexec.so /usr/local/libexec/bear/<span class="variable">$INSTALL_LIBDIR</span>/</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/thinkpad-ubuntu20.04.png" alt="WSL2 Ubuntu20.04" loading="lazy"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://documentation.ubuntu.com/wsl/stable/howto/install-ubuntu-wsl2/">Install Ubuntu on WSL 2</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://zhuanlan.zhihu.com/p/621873601">轻松搬迁！教你如何将WSL从C盘迁移到其他盘区，释放存储空间！</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://emacs-china.org/t/treesit-install-language-grammar-warning/30293/6">treesit-install-language-grammar warning</a></div>]]></content>
    
    
    <summary type="html">安装Ubuntu-20.04，从C盘转移到D盘，安装最新版emacs</summary>
    
    
    
    <category term="Misc" scheme="https://even629.com/categories/Misc/"/>
    
    
    <category term="Misc" scheme="https://even629.com/tags/Misc/"/>
    
    <category term="WSL" scheme="https://even629.com/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>WSL空间压缩</title>
    <link href="https://even629.com/posts/2512298/"/>
    <id>https://even629.com/posts/2512298/</id>
    <published>2025-12-29T03:10:13.000Z</published>
    <updated>2025-12-29T03:10:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-29</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="vhdx-文件的磁盘路径"><a href="#vhdx-文件的磁盘路径" class="headerlink" title=".vhdx 文件的磁盘路径"></a><code>.vhdx</code> 文件的磁盘路径</h1><p>把distribution-name替换成通过<code>wsl -l -v</code>看到的发行版的名称</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">-v</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> HKCU:\Software\Microsoft\Windows\CurrentVersion\Lxss | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.GetValue(<span class="string">&quot;DistributionName&quot;</span>) <span class="operator">-eq</span> <span class="string">&#x27;&lt;distribution-name&gt;&#x27;</span> &#125;).GetValue(<span class="string">&quot;BasePath&quot;</span>) + <span class="string">&quot;\ext4.vhdx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以archlinux为例</span></span><br><span class="line">(<span class="built_in">Get-ChildItem</span> <span class="literal">-Path</span> HKCU:\Software\Microsoft\Windows\CurrentVersion\Lxss | <span class="built_in">Where-Object</span> &#123; <span class="variable">$_</span>.GetValue(<span class="string">&quot;DistributionName&quot;</span>) <span class="operator">-eq</span> <span class="string">&#x27;archlinux&#x27;</span> &#125;).GetValue(<span class="string">&quot;BasePath&quot;</span>) + <span class="string">&quot;\ext4.vhdx&quot;</span></span><br></pre></td></tr></table></figure><h1 id="压缩磁盘"><a href="#压缩磁盘" class="headerlink" title="压缩磁盘"></a>压缩磁盘</h1><p>压缩前先关闭wsl</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br></pre></td></tr></table></figure><p>然后输入diskpart</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br></pre></td></tr></table></figure><p>此时弹出一个新的命令行窗口，依次输入下面内容，其中file的值替换成上面一步得到的路径</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择目标磁盘文件</span></span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;/path/to/your/.vhdx&quot;</span></span><br><span class="line"><span class="comment"># 以只读模式连接虚拟磁盘文件</span></span><br><span class="line">attach vdisk readonly</span><br><span class="line"><span class="comment"># 压缩虚拟磁盘文件</span></span><br><span class="line">compact vdisk</span><br><span class="line"><span class="comment"># 分离虚拟磁盘文件</span></span><br><span class="line">detach vdisk</span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://learn.microsoft.com/zh-cn/windows/wsl/disk-space#how-to-locate-the-vhdx-file-and-disk-path-for-your-linux-distribution">如何管理 WSL 磁盘空间</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://zhuanlan.zhihu.com/p/641436638">谁来救救被WSL占用的磁盘空间</a></div>]]></content>
    
    
    <summary type="html">解决WSL镜像占用空间过大的问题</summary>
    
    
    
    <category term="Misc" scheme="https://even629.com/categories/Misc/"/>
    
    
    <category term="Misc" scheme="https://even629.com/tags/Misc/"/>
    
    <category term="WSL" scheme="https://even629.com/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>Linux I2C</title>
    <link href="https://even629.com/posts/2512283/"/>
    <id>https://even629.com/posts/2512283/</id>
    <published>2025-12-28T11:55:13.000Z</published>
    <updated>2025-12-28T11:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-28</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="I2C简介"><a href="#I2C简介" class="headerlink" title="I2C简介"></a>I2C简介</h1><p>荷兰著名电子公司飞利浦(Philips)公司发明了一种名为I2C(Inter-Integrated Circuit)的集成电路互连通信协议。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204417959.png" alt="I2C" loading="lazy"></p><p>在<strong>空闲状态下</strong>，<strong>SDA 和 SCL 一般被上拉电阻拉高，保持高电平状态</strong>，在需要进行数据传输的时候，通过 SCL 和 SDA 的高低电平来产生 I2C 总线所需要的信号进行数据传递。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>总线拓扑结构</strong></li></ul><p>I2C 总线采用主从式架构,由一个主设备(Master)和一个或多个从设备(Slave)组成。主设备负责发起数据传输,从设备则响应主设备的请求。</p><ul><li><strong>物理层接口</strong><br>I2C 总线使用两根线路进行通信:<ul><li><p>SCL(Serial Clock Line)时钟线,由主设备提供时钟信号。</p></li><li><p>SDA(Serial Data Line)数据线,用于双向传输数据。</p></li></ul></li></ul><p>这两根线通常需要上拉电阻来保持信号的高电平状态。</p><ul><li><strong>通信协议</strong></li></ul><p>I2C 采用<strong>同步串行通信</strong>方式, 主设备发起通信并提供时钟。主设备首先发送一个”启动”信号,然后发送从设备地址和数据传输方向(读或写)。从设备在收到自己的地址后,会发送应答信号,表示已准备好接收或发送数据。之后主设备和从设备就可以开始传输数据。通信结束时,主设<br>备发送”停止”信号。</p><ul><li><p><strong>时钟频率</strong><br>I2C 总线支持多种通信速率,常见的有:</p><ul><li><p>标准模式(Standard mode):100kbps</p></li><li><p>快速模式(Fast mode):400kbps</p></li><li><p>高速模式(High-speed mode):3.4Mbps</p></li></ul></li><li><p><strong>寻址机制</strong><br>I2C 使用 7 位地址空间,最多可寻址 127 个从设备。地址空间的前 7 位用于指定从设备,最后1 位用于表示读&#x2F;写方向。<br>每一个 12C 外设都会对应一个唯一的地址(这个地址可以从 I2C 外设器件的数据手册中得到），主机和从机之间的通信就是通过这个地址来确定主机要和哪个从机进行通信的。</p></li><li><p><strong>多主机支持</strong><br>I2C 总线支持多个主设备共享同一总线, <strong>通过仲裁机制避免冲突</strong>。当多个主设备同时试图占用总线时,<strong>优先级最高的主设备将获得总线控制权</strong>。</p></li><li><p>其他特点:</p><ul><li><strong>总线最大电容限制为 400pF</strong>。</li><li><strong>以字节为单位传输数据</strong>。</li><li>存在硬件 I2C 和软件 I2C 两种实现方式。</li></ul></li></ul><h2 id="RK3568-上的I2C"><a href="#RK3568-上的I2C" class="headerlink" title="RK3568 上的I2C"></a>RK3568 上的I2C</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204419324.png" alt="rk3568 I2C" loading="lazy"></p><ul><li>支持 6 路 I2C 接口，分别为 I2C0、I2C1、I2C2、I2C3、I2C4、I2C5</li><li>支持 7 位和 10 位地址模式</li><li>软件可编程时钟频率</li><li>I2C 总线上的数据传输速率可达<ul><li>标准模式最高 100Kbit&#x2F;s</li><li>快速模式最高 400Kbit&#x2F;s</li><li>快速模式加最高 1Mbit&#x2F;s</li></ul></li></ul><h3 id="硬件I2C与软件I2C"><a href="#硬件I2C与软件I2C" class="headerlink" title="硬件I2C与软件I2C"></a>硬件I2C与软件I2C</h3><p>这里的 6 路 I2C 接口指的是<strong>硬件 I2C</strong>，<strong>在 SOC 上有专用的硬件 I2C 电路</strong>，关于硬件 I2C的介绍如下所示</p><h4 id="硬件-I2C"><a href="#硬件-I2C" class="headerlink" title="硬件 I2C"></a>硬件 I2C</h4><p><strong>硬件 I2C</strong>，<strong>在 SOC 上有专用的硬件 I2C 电路</strong></p><ul><li><strong>实现方式</strong>:通过专用的硬件 I2C 接口电路来实现 I2C 总线协议。</li><li><strong>优点</strong>: CPU 占用低,I2C 总线由硬件电路自动完成。传输速率高,可以达到 400kbit&#x2F;s 或 3.4Mbit&#x2F;s。更加可靠和稳定,不易受外部干扰。</li><li><strong>缺点</strong>: 需要专用的硬件 I2C 接口电路支持,成本相对较高。接口固定,不如软件 I2C 那么灵活。</li><li><strong>适用范围</strong>：适用于高速、大量数据传输的场合,如 LCD、EEPROM 等外设的连接。</li></ul><h4 id="软件-I2C"><a href="#软件-I2C" class="headerlink" title="软件 I2C"></a>软件 I2C</h4><p>指的是<strong>通过 GPIO 口模拟 SCL 和 SDA 信号线</strong>，在硬件 I2C 不够用的情况下，可以通过 GPIO 来模拟软件 I2C,关于软件 I2C 的介绍如下所示：</p><ul><li><strong>实现方式</strong>: 通过软件模拟 I2C 总线协议,使用通用 I&#x2F;O 口来模拟 SCL 和 SDA 信号线。</li><li><strong>优点</strong>: 灵活性强,可以在任何 I&#x2F;O 口上实现 I2C 接口。成本低,不需要额外的硬件支持。</li><li><strong>缺点</strong>: CPU 占用较高,因为需要在软件中模拟 I2C 时序。传输速率较低,受 CPU 性能限制,一般在 100kbit&#x2F;s 左右。</li><li><strong>适用范围</strong>：适用于低速、少量数据传输的场合。</li></ul><h2 id="I2C的上拉电阻"><a href="#I2C的上拉电阻" class="headerlink" title="I2C的上拉电阻"></a>I2C的上拉电阻</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204417959.png" alt="上拉电阻" loading="lazy"></p><p>在I2C中在 SDA 数据线和 SCL 时钟线上都需要接一个上拉电阻</p><h3 id="接上拉电阻的作用"><a href="#接上拉电阻的作用" class="headerlink" title="接上拉电阻的作用"></a>接上拉电阻的作用</h3><ul><li><strong>保证总线空闲时保持高电平</strong></li></ul><p><strong>I2C 总线采用开漏&#x2F;开集电极输出, 当没有设备驱动总线时, 总线会处于高阻态</strong>。如果不接上拉电阻,总线电平将不确定,很容易受到噪声干扰。接上拉电阻可以<strong>确保总线空闲时保持稳定的高电平</strong>。</p><ul><li><strong>实现线与功能</strong></li></ul><p><strong>I2C 总线允许多个设备挂载在同一总线上</strong>。<strong>当一个设备拉低总线时,其他设备的输出也会被拉低。这就是线与功能,实现总线仲裁</strong>。如果不接上拉电阻,当总线空闲时电平不确定,一个设备拉低总线时其他设备无法感知到总线电平变化,无法实现线与功能。</p><p>而这里的上拉电阻也并不能随意进行取值,需要考虑<strong>总线电容</strong>的影响。I2C 总线上存在各种寄生电容,可以等效成一个 RC 充电电路，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204420160.png" alt="等效RC充电电路" loading="lazy"></p><p><strong>当总线从低电平转为高电平时,需要通过上拉电阻为总线供电</strong>,充电总线电容。</p><ul><li><p>如果上拉电阻取值过大,充电时间过长,会导致上升沿过慢,可能影响通信；</p></li><li><p>如果上拉电阻取值过小，则无法产生低电平</p></li></ul><p>所以在 I2C 规范中要求总线电容不能超过 400PF,通常建议在 1k 至 10k 欧姆之间选择,能够既保证上升沿速度,又能够可靠拉低总线电平</p><h3 id="I2C上拉电阻阻值计算"><a href="#I2C上拉电阻阻值计算" class="headerlink" title="I2C上拉电阻阻值计算"></a>I2C上拉电阻阻值计算</h3><h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><p>公式：<br>$$<br>R_{\text{p(min)}} &#x3D; \frac{V_{\text{DD}} - V_{\text{OL(max)}}}{I_{\text{O}}}<br>$$</p><ul><li>$ V_{\text{DD} }$          通常为 5V 或 3.3V 等常用的供电电压,在 iTOP-RK3568开发板上为 3.3V</li><li>$V_{\text{OL(max)}}$  表示器件在低电平时的最大输出电压,具体数值表格如下所示，由于 VDD 为3.3V，所以 VOL 的最大值为 0.4</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204424118.png" alt="器件在低电平时的最大输出电压" loading="lazy"></p><ul><li>$I_{\text{O}}$         器件在低电平时的最大灌入电流,具体数值表格如下所示，通过$V_{\text{OL}}$ 值为 0.4，可以得到 $I_{\text{O}}$在常规模式下和快速模式下的值为 3ma。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204425159.png" alt="器件在低电平时的最大灌入电流" loading="lazy"></p><p><strong>计算</strong>：</p><ol><li>确定 $V_{\text{DD}}$、$V_{\text{OL(max)}}$ 和 $I_{\text{OL}}$ 的值： 在 RK3568 中，$V_{\text{DD}} &#x3D; 3.3,\text{V}$，取 $V_{\text{OL(max)}} &#x3D; 0.4,\text{V}$，对应的 $I_{\text{OL}} &#x3D; 3,\text{mA}$。 </li><li>代入公式： $ R_{\text{p(min)}} &#x3D; \frac{V_{\text{DD}} - V_{\text{OL(max)}}}{I_{\text{OL}}} $ 计算得到上拉电阻的最小值：$ R_{\text{p(min)}} &#x3D; \frac{3.3,\text{V} - 0.4,\text{V}}{3,\text{mA}} &#x3D; \frac{2.9,\text{V}}{0.003,\text{A}} \approx 966.7,\Omega$通常可取标准电阻值 <strong>910 Ω</strong> 或 <strong>1 kΩ</strong>（若允许略低于理论最小值，需结合实际总线电容和速度要求）。</li></ol><h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><p>公式：<br>$$<br>R_{\text{p(max)}} &#x3D; \frac{0.8473 \cdot C_{\text{b}}}{t_{\text{r}}}<br>$$</p><ul><li>$R_{\text{p(max)}}$：上拉电阻的最大值（单位：Ω）  </li><li>$C_{\text{b}}$：总线电容（单位：F），包括 PCB 走线电容、引脚电容和器件输入电容之和  </li><li>$t_{\text{r}}$：高电平上升时间（单位：s），一般上升时间是从 0.3VDD 到 0.7VDD，具体可以从数据手册获得</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204428426.png" alt="高电平上升时间" loading="lazy"></p><p>根据上图可以得到</p><ul><li>在标准模式下 $t_{\text{r}}$的取值为 ≤ 1000ns。</li><li>在快速模式下$t_{\text{r}}$ 的取值为 ≤ 300ns。</li><li>在超快速模式下 $t_{\text{r}}$ 的取值为≤ 120ns</li></ul><p><strong>计算</strong>：</p><p>I²C 工作在标准模式下，上拉电压为 $3.3,\text{V}$，引脚电容为 $10,\text{pF}$，连接电容为 $30,\text{pF}$，高电平上升时间 $t_{\text{r}} &#x3D; 1000,\text{ns}$。计算上拉电阻的最大值。</p><ol><li><strong>计算总线电容</strong>： $   C_{\text{b}} &#x3D; 10,\text{pF} + 30,\text{pF} &#x3D; 40,\text{pF} &#x3D; 40 \times 10^{-12},\text{F}   $</li><li><strong>代入公式</strong>：   $   R_{\text{p(max)}} &#x3D; \frac{0.8473 \cdot C_{\text{b}}}{t_{\text{r}}} $</li><li><strong>代入数值计算</strong>：  $   R_{\text{p(max)}} &#x3D; \frac{0.8473 \times 40 \times 10^{-12},\text{F}}{1000 \times 10^{-9},\text{s}} &#x3D; \frac{33.892 \times 10^{-12}}{10^{-6}},\Omega &#x3D; 33.892 \times 10^{3},\Omega \approx 33.89,\text{k}\Omega   $</li></ol><p>因此，上拉电阻的最大值约为 <strong>33.89 kΩ</strong>。</p><h4 id="具体选择"><a href="#具体选择" class="headerlink" title="具体选择"></a>具体选择</h4><p>一般来说,I2C 总线速度越快,所需的上拉电阻值越小，具体选择如下所示：</p><ul><li><p>100kbps: 一般选择 10k 上拉电阻</p></li><li><p>400kbps: 一般选择 4.7k 上拉电阻</p></li><li><p>1Mbps: 一般选择 2.2k 上拉电阻</p></li></ul><p>当然上述选择未必正确,需要根据实际测试结果进行调整。在实际使用中,可以先根据经验选择一个上拉电阻值试用,无需过于纠结于计算公式</p><h2 id="I2C通信时序"><a href="#I2C通信时序" class="headerlink" title="I2C通信时序"></a>I2C通信时序</h2><h3 id="起始信号与终止信号"><a href="#起始信号与终止信号" class="headerlink" title="起始信号与终止信号"></a>起始信号与终止信号</h3><p>所有的交互都是<strong>以 START(S) 信号开始</strong>, 并<strong>以 STOP(P)信号终止</strong>，具体的起始信号和终止信号通信时序图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204454169.png" alt="起始与终止时序" loading="lazy"></p><ul><li><strong>起始信号(START)</strong>：是由总线控制器生成（即主机）的,定义为 <strong>SDA 线从高电平到低电平的跳变,同时 SCL线保持高电平</strong>。</li><li><strong>终止信号(STOP)</strong>：是由总线控制器生成的,定义为 <strong>SDA 线从低电平到高电平的跳变,同时 SCL线保持高电平</strong>。</li></ul><blockquote><p>在 START 信号之后,总线被认为是忙碌状态,直到 STOP 信号出现后总线才被认为空闲</p></blockquote><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ol><li><strong>每一个传输到 SDA 线上的字节长度都必须是 8 位</strong>。每次传输可以包含任意数量的字节。</li><li><strong>每个字节之后都必须跟一个应答位(Acknowledge bit)</strong>。</li><li>数据以<strong>最高有效位(MSB)优先的顺序</strong>传输。</li><li>如果目标设备在处理内部中断等操作时无法立即接收或发送另一个完整的字节数据,它<strong>可以通过拉低 SCL 线来将控制器置于等待状态</strong>。当目标设备准备好接收下一字节数据时**,释放 SCL 线即可继续数据传输**。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204430022.png" alt="I2C数据格式" loading="lazy"></p><h3 id="应答信号和非应答信号"><a href="#应答信号和非应答信号" class="headerlink" title="应答信号和非应答信号"></a>应答信号和非应答信号</h3><ul><li>应答信号发生在每个字节传输之后。应答位让接收设备向发送设备表明字节数据已经成功接收,可以发送下一个字节了。<ul><li><strong>应答信号</strong>：当<strong>发送设备在第 9 个时钟脉冲期间释放 SDA 线时</strong>, <strong>接收设备可以拉低 SDA 线并在此时钟高电平期间保持稳定低电平</strong></li><li><strong>非应答信号</strong>：<strong>在第 9 个时钟脉冲期间 SDA 线保持高电平</strong>, 控制器可以产生停止信号中止传输,或者重复启动信号开始新的传输</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204433254.png" alt="应答信号与非应答信号" loading="lazy"></p><p>导致产生 NACK 信号的 5 种情况包括:</p><ul><li>总线上没有接收设备响应发送的地址</li><li>接收设备正忙于其他实时功能而无法开始通信</li><li>接收设备在传输过程中收到不能理解的数据或命令</li><li>接收设备无法再接收更多数据字节</li><li>控制器-接收器必须向目标发送器表明传输结束。</li></ul><h3 id="读写方向"><a href="#读写方向" class="headerlink" title="读写方向"></a>读写方向</h3><ol><li><p>数据传输格式，首先<strong>发送一个 7 位的目标地址</strong>, <strong>后跟一个读&#x2F;写方向位(R&#x2F;W 位)</strong>。</p></li><li><p>读&#x2F;写方向位是第 8 位, <strong>0 表示写操作(WRITE)</strong>，<strong>1 表示读操作(READ)</strong>。</p></li></ol><blockquote><p>数据传输总是<strong>由控制器产生的停止信号(P)来结束</strong>。但<strong>如果控制器需要继续在总线上通信,它可以产生一个重复起始信号(Sr)来寻址其他目标设备,而无需先产生停止条件</strong>。</p><p>这样就可以在同一次传输过程中实现各种读&#x2F;写格式的组合</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204433344.png" alt="读写" loading="lazy"></p><h2 id="I2C波形"><a href="#I2C波形" class="headerlink" title="I2C波形"></a>I2C波形</h2><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204434134.png" alt="写操作" loading="lazy"></p><p>在数据传输之前，主机要先<strong>发送一个起始信号</strong>，起始信号为 SDA 线从高电平到低电平的跳变,同时 SCL 线保持高电平，就对应图所示部分,逻辑分析仪软件也用一个绿色的远点进行了标注。</p><p>可以将写操作分为以下步骤：</p><ol><li><strong>主机发送一个起始信号</strong></li><li><strong>主机发送 I2C 外设的地址和写操作，等待应答信号</strong></li><li>从机发送应答信号</li><li><strong>主机要发送寄存器的地址，等待应答信号</strong></li><li>从机发送应答信号</li><li><strong>主机发送要写入的寄存器的数据，等待应答信号</strong></li><li>从机发送应答信号</li><li><strong>主机要发送终止信号，如果写多个寄存器，重复 6,7 步骤</strong></li></ol><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><p><strong>无论是读操作还是写操作，都要先写入 I2C 外设地址，所以最开始的波形是相同的</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204436936.png" alt="读操作" loading="lazy"></p><p>可以将读操作分为以下步骤：</p><ol><li><strong>主机发送一个起始信号</strong></li><li><strong>主机要发送 12C 外设地址和写操作，等待应答信号</strong></li><li>从机发送应答信号</li><li><strong>主机要发送要读取的寄存器的地址，等待应答信号</strong></li><li>从机发送应答信号</li><li><strong>主机发送起始信号</strong></li><li><strong>主机发送要读取的 12C 外设的地址和读操作，等待应答信号</strong></li><li>从机发送应答信号</li><li>从机发送数据，也就是要读取的寄存器的数据，等待应答或者非应答信号</li><li><strong>主机如果不在读取数据，就要发送非应答信号，如果继续读取，就发送应答信号</strong></li></ol><h1 id="I2C子系统框架"><a href="#I2C子系统框架" class="headerlink" title="I2C子系统框架"></a>I2C子系统框架</h1><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359810.png" alt="I2C子系统框架" loading="lazy"></p><h3 id="I2C设备驱动层"><a href="#I2C设备驱动层" class="headerlink" title="I2C设备驱动层"></a>I2C设备驱动层</h3><p>I2C 设备驱动层的主要作用为编写驱动程序,<strong>使 I2C 外设能够正常工作</strong>，然后<strong>创建了对应的设备节点</strong>，提供了标准化的接口,使得上层应用程序能够方便地与 I2C 设备进行交互。</p><p>具体来说,I2C 设备驱动层包含以下几个关键部分:</p><ul><li><strong>i2c_client</strong><ul><li><strong>代表一个连接到 I2C 总线上的从设备</strong></li><li>包含从设备的地址、所属的 I2C 适配器等信息</li></ul></li><li><strong><code>/dev/i2X</code> 设备节点</strong><ul><li>为上层应用程序提供设备访问的接口</li><li>通过打开&#x2F;读写&#x2F;控制设备节点,应用程序可以与 I2C 设备进行交互</li><li>内核 I2C 子系统负责将应用程序的操作转发到对应的 i2c_driver</li></ul></li><li><strong><code>i2c_driver</code></strong><ul><li>实现了具体 I2C 从设备的驱动程序</li><li>负责设备的初始化、读写、配置等操作</li><li>通过 i2c_client 与设备进行交互</li><li>向上层提供设备访问的标准化接口</li></ul></li><li><strong>I2C 总线子系统</strong><ul><li>管理整个 I2C 总线,包括注册&#x2F;注销 I2C 适配器和从设备</li><li>协调 i2c_client 和 i2c_driver 之间的交互</li><li>为上层提供统一的 I2C 访问接口</li></ul></li></ul><h3 id="I2C-核心层"><a href="#I2C-核心层" class="headerlink" title="I2C 核心层"></a>I2C 核心层</h3><p>I2C 核心层位于 I2C 设备驱动层和 I2C 适配器驱动层中间，起到了承上启下的作用，负责 I2C 设备驱动层和 I2C 适配器驱动层之间数据的传递，I2C 核心层的主要函数为 </p><ul><li><code>i2c_master_send</code></li><li><code>i2c_master_recv</code></li><li><code>i2c_transfer</code></li></ul><p><code>i2c_master_send</code>和<code>i2c_master_recv</code>这两个函数负责<strong>生成符合 I2C 协议的时序和数据帧</strong>,并通过对应的 I2C 适配器驱动程序进行实际的总线操作。</p><blockquote><p>其中 <code>i2c_master_send</code> 和<code>i2c_master_recv</code> 函数，是 I2C 核心层提供的基本读写接口。</p><p><code>i2c_master_send</code> 用于向 I2C 从设备发送数据, <code>i2c_master_recv</code> 用于从从设备接收数据。</p><p>它们分别接受如下参数:</p><ul><li><code>struct i2c_client *client</code>: 指向目标 I2C 从设备的指针</li><li><code>const char *buf/char *buf</code>: 数据缓冲区</li><li><code>int count</code>: 要发送&#x2F;接收的字节数</li></ul></blockquote><p>而 <code>i2c_transfer</code> 函数是一个更加综合的 I2C 传输函数，<code>i2c_master_send</code> 和 <code>i2c_master_recv</code>函数实际上便是调用的 <code>i2c_transfer</code></p><blockquote><p>i2c_transfer 函数它接受如下参数:</p><ul><li><code>struct i2c_adapter *adap</code>: 指向目标 I2C 适配器的指针</li><li><code>struct i2c_msg *msgs</code>: 指向一个 I2C 消息数组的指针</li><li><code>int num</code>: 消息数组中的消息数量</li></ul></blockquote><p>既然已经在 I2C 设备驱动层中创建了对应的设备节点，有了驱动程序就可以直接对 I2C 具体硬件进行操作了，但是在 I2C 子系<br>统并不是这样实现的，而是添加了 I2C 核心层和 I2C 适配器驱动层，那为什么要这样设计呢？</p><p>最主要的原因是通过驱动分层可以<strong>解决多个应用同时访问一个 I2C 设备冲突的问题</strong>，除此之外通过这种<strong>模块化设计</strong>,可以提高了代码的复用性和可维护性，使得 I2C 核心层和设备驱动程序可以独立开发和升级，I2C 适配器驱动程序也可以针对不同的硬件平台进行优化。</p><h3 id="I2C适配器驱动层"><a href="#I2C适配器驱动层" class="headerlink" title="I2C适配器驱动层"></a>I2C适配器驱动层</h3><p>I2C 适配器驱动层是 I2C 子系统的另一个重要组成部分,它负责<strong>实现具体的 I2C 硬件控制器的驱动程序</strong>。I2C 适配器驱动程序的作用如下所示：</p><ul><li>提供标准化的 I2C 传输接口,供 I2C 核心层调用</li><li>实现 I2C 总线协议的时序控制和数据收发</li><li>管理 I2C 总线上的从设备</li><li>处理 I2C 总线错误和异常情况</li></ul><h2 id="I2C-client-代码编写-设备树"><a href="#I2C-client-代码编写-设备树" class="headerlink" title="I2C client 代码编写(设备树)"></a>I2C client 代码编写(设备树)</h2><h3 id="设备树"><a href="#设备树" class="headerlink" title="设备树"></a>设备树</h3><p>在 <code>rk3568.dtsi</code> 设备树中有关于 I2C0、I2C1、I2C2、I2C3、I2C4、I2C5 的设备树节点，这里只列举出了 I2C1 的设备树节点，具体如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">i2c1:</span> <span class="title class_">i2c@fe5a0000</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3399-i2c&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe5a0000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> CLK_I2C1&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_I2C1&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;i2c&quot;</span>, <span class="string">&quot;pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">47</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;i2c1_xfer</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p><code>i2c1: i2c@fe5a0000</code> 节点代表 I2C1 控制器，如果 I2C 外设挂载到了 I2C1 上，就可以直接在 I2C1 控制器的节点下添加 I2C 外设的子节点，FT5X06 的设备树节点就在 <code>kernel/arch/arm64/boot/dts/rockchip/topeet-screen-lcds.dts</code> 中，具体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    </span><br><span class="line">ft5x061:ft5x06@<span class="number">38</span> &#123;</span><br><span class="line">status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">compatible = <span class="string">&quot;edt,edt-ft5306&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">touch-gpio = &lt;&amp;gpio3 RK_PA5 IRQ_TYPE_EDGE_RISING&gt;;</span><br><span class="line">interrupt-parent = &lt;&amp;gpio3&gt;;</span><br><span class="line">interrupts = &lt;RK_PA5 IRQ_TYPE_LEVEL_LOW&gt;;</span><br><span class="line">reset-gpio = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">touchscreen-size-x = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">touchscreen-size-y = &lt;<span class="number">1280</span>&gt;;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该节点向 I2C1 控制器节点追加了 FT5X06 触摸芯片相关的节点。即<strong>ft5x06作为i2c1的子节点</strong></p><h3 id="取消rk3568原本的驱动"><a href="#取消rk3568原本的驱动" class="headerlink" title="取消rk3568原本的驱动"></a>取消rk3568原本的驱动</h3><ol><li>在menuconfig中取消FT5X06驱动的勾选</li><li>在<code>topeet-screen-lcds.dts</code>中选用<code>LCD_TYPE_MIPI</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_TYPE_MIPI       <span class="comment">//in vp 1</span></span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_LVDS_10_1_1024X600  //in vp 2</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_LVDS_10_1_1280X800_gt9271 //in vp 2</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_LVDS_7_0   //in vp 2</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_EDP_VGA  //in vp 0</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_HDMI_VP0   //hdmi in vp 0</span></span><br><span class="line"><span class="comment">//#define LCD_TYPE_HDMI_VP1   //hdmi in vp 1</span></span><br></pre></td></tr></table></figure><ol start="3"><li>原本的ft5x06设备树节点status从okay设置为disabled</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LCD_TYPE_MIPI)</span></span><br><span class="line">...</span><br><span class="line"><span class="variable">&amp;ft5x061</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="FT5X06-Client编写"><a href="#FT5X06-Client编写" class="headerlink" title="FT5X06 Client编写"></a>FT5X06 Client编写</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;i2c1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">myft5x06:</span> <span class="title class_">my-ft5x06@38</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;my-ft5x06&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>关于追加的设备树节点描述如下所示：</p><ul><li><code>&amp;i2c1</code>: 表示对 I2C 控制器 1 进行引用。</li><li><code>status = &quot;okay&quot;;</code>: 表示启用 I2C 控制器 1。</li><li><code>myft5x06: my-ft5x06@38</code>: 定义了一个设备节点,命名为 myft5x06。<code>my-ft5x06@38</code>表示这个设备的 I2C 地址为 0x38。</li><li><code>compatible = &quot;my-ft5x06&quot;;</code>: 这个属性用于标识设备的类型,这里表示这是一个名为”my-ft5x06”的设备。</li><li><code>reg = &lt;0x38&gt;;</code>: 这个属性定义了设备在 I2C 总线上的地址,这里为 0x38</li></ul><p>而 FT5X06 触摸芯片除了 I2C 部分，还有另外两个 GPIO 分别为中断引脚和复位引脚，每个引脚对应的功能匹配表格如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204400010.png" alt="ft5x06两个 GPIO 分别为中断引脚和复位引脚" loading="lazy"></p><p>因此我们在设备树中也要描述</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;i2c1</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">myft5x06:</span> <span class="title class_">my-ft5x06@38</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;my-ft5x06&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reset-gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> RK_PB6 GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupt-parent</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts-gpio</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio3</span> RK_PA5 GPIO_ACTIVE_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;RK_PA5 IRQ_TYPE_LEVEL_LOW&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;myft5x06_pins</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><ul><li><code>reset-gpios = &lt;&amp;gpio0 RK_PB6 GPIO_ACTIVE_LOW&gt;;</code>: 定义了设备的复位引脚,连接到<code>GPIO0</code> 的 RK_PB6 引脚,电平为低电平有效。</li><li><code>interrupt-parent = &lt;&amp;gpio3&gt;;</code>: 指定中断的父节点为 GPIO3。</li><li><code>interrupts-gpio = &lt;&amp;gpio3 RK_PA5 GPIO_ACTIVE_LOW&gt;;</code>: 定义了设备的中断引脚,连接到 GPIO3 的 RK_PA5 引脚,电平为低电平触发。</li><li><code>interrupts = &lt;RK_PA5 IRQ_TYPE_LEVEL_LOW&gt;;</code>: 进一步描述了中断的触发方式,为电平低电平触发。</li><li><code>pinctrl-names = &quot;default&quot;;</code> 和<code>pinctrl-0 = &lt;&amp;myft5x06_pins&gt;;</code>: 指定了设备使用的默认针脚配置。</li></ul><p>这里指定的 pinctrl 节点名为 <code>myft5x06_pins</code>，所以还需要对 pinctrl 节点进行追加，追加内容如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="title class_">myft5x06</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">myft5x06_pins:</span> <span class="title class_">myft5x06-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line"><span class="params">&lt;<span class="number">0</span> RK_PB6 RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line"><span class="params">&lt;<span class="number">0</span> RK_PB6 RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="struct-i2c-client"><a href="#struct-i2c-client" class="headerlink" title="struct i2c_client"></a>struct i2c_client</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_client - represent an I2C slave device</span></span><br><span class="line"><span class="comment"> * @flags: see I2C_CLIENT_* for possible flags</span></span><br><span class="line"><span class="comment"> * @addr: Address used on the I2C bus connected to the parent adapter.</span></span><br><span class="line"><span class="comment"> * @name: Indicates the type of the device, usually a chip name that&#x27;s</span></span><br><span class="line"><span class="comment"> *generic enough to hide second-sourcing and compatible revisions.</span></span><br><span class="line"><span class="comment"> * @adapter: manages the bus segment hosting this I2C device</span></span><br><span class="line"><span class="comment"> * @dev: Driver model device node for the slave.</span></span><br><span class="line"><span class="comment"> * @init_irq: IRQ that was set at initialization</span></span><br><span class="line"><span class="comment"> * @irq: indicates the IRQ generated by this device (if any)</span></span><br><span class="line"><span class="comment"> * @detected: member of an i2c_driver.clients list or i2c-core&#x27;s</span></span><br><span class="line"><span class="comment"> *userspace_devices list</span></span><br><span class="line"><span class="comment"> * @slave_cb: Callback when I2C slave mode of an adapter is used. The adapter</span></span><br><span class="line"><span class="comment"> *calls it to pass on slave events to the slave driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_client identifies a single device (i.e. chip) connected to an</span></span><br><span class="line"><span class="comment"> * i2c bus. The behaviour exposed to Linux is defined by the driver</span></span><br><span class="line"><span class="comment"> * managing the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">/* div., see below*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_PEC0x04<span class="comment">/* Use Packet Error Checking */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_TEN0x10<span class="comment">/* we have a ten bit chip address */</span></span></span><br><span class="line"><span class="comment">/* Must equal I2C_M_TEN below */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_SLAVE0x20<span class="comment">/* we are the slave */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_HOST_NOTIFY0x40<span class="comment">/* We want to use I2C host notify */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_WAKE0x80<span class="comment">/* for board_info; true iff can wake */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_SCCB0x9000<span class="comment">/* Use Omnivision SCCB protocol */</span></span></span><br><span class="line"><span class="comment">/* Must match I2C_M_STOP|IGNORE_NAK */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> addr;<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit*/</span></span><br><span class="line"><span class="comment">/* addresses are stored in the*/</span></span><br><span class="line"><span class="comment">/* _LOWER_ 7 bits*/</span></span><br><span class="line"><span class="type">char</span> name[I2C_NAME_SIZE];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span><span class="comment">/* the adapter we sit on*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">/* the device structure*/</span></span><br><span class="line"><span class="type">int</span> init_irq;<span class="comment">/* irq set at initialization*/</span></span><br><span class="line"><span class="type">int</span> irq;<span class="comment">/* irq issued by device*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line"><span class="type">i2c_slave_cb_t</span> slave_cb;<span class="comment">/* callback for slave mode*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用C编写I2C-Client"><a href="#用C编写I2C-Client" class="headerlink" title="用C编写I2C Client"></a>用C编写I2C Client</h3><p>一般使用设备树编写I2C Client，不过在引入设备树之前使用C文件也可以</p><h4 id="i2c-get-adapter"><a href="#i2c-get-adapter" class="headerlink" title="i2c_get_adapter()"></a>i2c_get_adapter()</h4><p><code>i2c_get_adapter</code> 函数的主要作用是根据给定的 I2C 适配器编号 nr 从 <code>i2c_adapter_idr</code> 中查找对应的 <code>i2c_adapter</code> 结构体，该函数定义在<code>drivers/i2c/i2c-core-base.c</code>文件中，具体内容如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> i2c_adapter *<span class="title function_">i2c_get_adapter</span><span class="params">(<span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span></span><br><span class="line"><span class="comment">// 获取 i2c_adapter_idr 中的锁</span></span><br><span class="line">mutex_lock(&amp;core_lock);</span><br><span class="line">    <span class="comment">// 在 i2c_adapter_idr 中查找指定编号的适配器</span></span><br><span class="line">adapter = idr_find(&amp;i2c_adapter_idr, nr);</span><br><span class="line"><span class="keyword">if</span> (!adapter)</span><br><span class="line"><span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"><span class="comment">// 尝试获取适配器所属模块的引用计数</span></span><br><span class="line"><span class="keyword">if</span> (try_module_get(adapter-&gt;owner))</span><br><span class="line">        <span class="comment">// 增加适配器 device 的引用计数</span></span><br><span class="line">get_device(&amp;adapter-&gt;dev);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">adapter = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">exit</span>:</span><br><span class="line">    <span class="comment">// 释放 i2c_adapter_idr 中的锁</span></span><br><span class="line">mutex_unlock(&amp;core_lock);</span><br><span class="line"><span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_get_adapter);</span><br></pre></td></tr></table></figure><h4 id="i2c-put-adapter"><a href="#i2c-put-adapter" class="headerlink" title="i2c_put_adapter()"></a>i2c_put_adapter()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_put_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!adap)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">module_put(adap-&gt;owner);</span><br><span class="line"><span class="comment">/* Should be last, otherwise we risk use-after-free with &#x27;adap&#x27; */</span></span><br><span class="line">put_device(&amp;adap-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_put_adapter);</span><br></pre></td></tr></table></figure><p>当驱动卸载时 <code>i2c_adapter</code>结构体需要被释放，而当结构体 <code>i2c_put_adapter</code> 函数用于释放 <code>i2c_adapter</code> 结构体,<code>i2c_put_adapter</code> 函数也定义在<code>drivers/i2c/i2c-core-base.c</code>文件中</p><h4 id="struct-i2c-adaper"><a href="#struct-i2c-adaper" class="headerlink" title="struct i2c_adaper"></a>struct i2c_adaper</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span>  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line"><span class="type">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* data fields that are valid for all devices*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> timeout;<span class="comment">/* in jiffies */</span></span><br><span class="line"><span class="type">int</span> retries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span><span class="comment">/* the adapter device */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> locked_flags;<span class="comment">/* owned by the I2C core */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_ALF_IS_SUSPENDED0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_ALF_SUSPEND_REPORTED1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nr;</span><br><span class="line"><span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span> *<span class="title">host_notify_domain</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="i2c-new-client-device"><a href="#i2c-new-client-device" class="headerlink" title="i2c_new_client_device()"></a>i2c_new_client_device()</h4><p><code>i2c_new_client_device</code> 函数用于创建和注册与 I2C 总线上对应的设备。注册完成后,I2C 子系统会自动为该设备创建相应的设备节点,供上层应用程序进行访问和控制，该函数同样定义在定义在<code>drivers/i2c/i2c-core-base.c</code>文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_new_client_device - instantiate an i2c device</span></span><br><span class="line"><span class="comment"> * @adap: the adapter managing the device</span></span><br><span class="line"><span class="comment"> * @info: describes one I2C device; bus_num is ignored</span></span><br><span class="line"><span class="comment"> * Context: can sleep</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create an i2c device. Binding is handled through driver model</span></span><br><span class="line"><span class="comment"> * probe()/remove() methods.  A driver may be bound to this device when we</span></span><br><span class="line"><span class="comment"> * return from this function, or any later moment (e.g. maybe hotplugging will</span></span><br><span class="line"><span class="comment"> * load the driver module).  This call is not appropriate for use by mainboard</span></span><br><span class="line"><span class="comment"> * initialization logic, which usually runs during an arch_initcall() long</span></span><br><span class="line"><span class="comment"> * before any i2c_adapter could exist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This returns the new i2c client, which may be saved for later use with</span></span><br><span class="line"><span class="comment"> * i2c_unregister_device(); or an ERR_PTR to describe the error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> i2c_client *</span><br><span class="line"><span class="title function_">i2c_new_client_device</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_board_info <span class="type">const</span> *info)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>*<span class="title">client</span>;</span></span><br><span class="line"><span class="type">int</span>status;</span><br><span class="line"><span class="comment">// 分配 i2c_client 结构体空间</span></span><br><span class="line">client = kzalloc(<span class="keyword">sizeof</span> *client, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!client)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"><span class="comment">// 设置 i2c_client 的适配器指针</span></span><br><span class="line">client-&gt;adapter = adap;</span><br><span class="line"><span class="comment">// 从 i2c_board_info 结构体中拷贝相关信息到 i2c_client</span></span><br><span class="line">client-&gt;dev.platform_data = info-&gt;platform_data;</span><br><span class="line">client-&gt;flags = info-&gt;flags;</span><br><span class="line">client-&gt;addr = info-&gt;addr;</span><br><span class="line"></span><br><span class="line">client-&gt;init_irq = info-&gt;irq;</span><br><span class="line"><span class="keyword">if</span> (!client-&gt;init_irq)</span><br><span class="line">client-&gt;init_irq = i2c_dev_irq_from_resources(info-&gt;resources,</span><br><span class="line"> info-&gt;num_resources);</span><br><span class="line"></span><br><span class="line">strlcpy(client-&gt;name, info-&gt;type, <span class="keyword">sizeof</span>(client-&gt;name));</span><br><span class="line"><span class="comment">// 检查地址是否有效</span></span><br><span class="line">status = i2c_check_addr_validity(client-&gt;addr, client-&gt;flags);</span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">dev_err(&amp;adap-&gt;dev, <span class="string">&quot;Invalid %d-bit I2C address 0x%02hx\n&quot;</span>,</span><br><span class="line">client-&gt;flags &amp; I2C_CLIENT_TEN ? <span class="number">10</span> : <span class="number">7</span>, client-&gt;addr);</span><br><span class="line"><span class="keyword">goto</span> out_err_silent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for address business */</span></span><br><span class="line">    <span class="comment">// 检查地址是否已被其他设备占用</span></span><br><span class="line">status = i2c_check_addr_ex(adap, i2c_encode_flags_to_addr(client));</span><br><span class="line"><span class="keyword">if</span> (status)</span><br><span class="line">dev_err(&amp;adap-&gt;dev,</span><br><span class="line"><span class="string">&quot;%d i2c clients have been registered at 0x%02x&quot;</span>,</span><br><span class="line">status, client-&gt;addr);</span><br><span class="line"><span class="comment">// 设置 i2c_client 的设备信息</span></span><br><span class="line">client-&gt;dev.parent = &amp;client-&gt;adapter-&gt;dev;</span><br><span class="line">client-&gt;dev.bus = &amp;i2c_bus_type;</span><br><span class="line">client-&gt;dev.type = &amp;i2c_client_type;</span><br><span class="line">client-&gt;dev.of_node = of_node_get(info-&gt;of_node);</span><br><span class="line">client-&gt;dev.fwnode = info-&gt;fwnode;</span><br><span class="line"></span><br><span class="line">i2c_dev_set_name(adap, client, info, status);</span><br><span class="line"><span class="comment">// 如果有设备属性,添加到设备</span></span><br><span class="line"><span class="keyword">if</span> (info-&gt;properties) &#123;</span><br><span class="line">status = device_add_properties(&amp;client-&gt;dev, info-&gt;properties);</span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">dev_err(&amp;adap-&gt;dev,</span><br><span class="line"><span class="string">&quot;Failed to add properties to client %s: %d\n&quot;</span>,</span><br><span class="line">client-&gt;name, status);</span><br><span class="line"><span class="keyword">goto</span> out_err_put_of_node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册设备</span></span><br><span class="line">status = device_register(&amp;client-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (status)</span><br><span class="line"><span class="keyword">goto</span> out_free_props;</span><br><span class="line"></span><br><span class="line">dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;client [%s] registered with bus id %s\n&quot;</span>,</span><br><span class="line">client-&gt;name, dev_name(&amp;client-&gt;dev));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> client;</span><br><span class="line"></span><br><span class="line">out_free_props:</span><br><span class="line"><span class="keyword">if</span> (info-&gt;properties)</span><br><span class="line">device_remove_properties(&amp;client-&gt;dev);</span><br><span class="line">out_err_put_of_node:</span><br><span class="line">of_node_put(info-&gt;of_node);</span><br><span class="line">out_err_silent:</span><br><span class="line">kfree(client);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(status);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_new_client_device);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="i2c-bus-probe"><a href="#i2c-bus-probe" class="headerlink" title="i2c_bus_probe()"></a>i2c_bus_probe()</h5><p><code>i2c_new_client_device()</code>中client-&gt;dev-&gt;bus被赋值为<code>i2c_bus_type</code>,执行<code>i2c_driver</code>的probe之前会先执行<code>i2c_bus_probe()</code>。在这里，对client的irq进行了赋值操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">.name= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">.match= i2c_device_match,</span><br><span class="line">.probe= i2c_device_probe,</span><br><span class="line">.remove= i2c_device_remove,</span><br><span class="line">.shutdown= i2c_device_shutdown,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> <span class="title">i2c_client_type</span> =</span> &#123;</span><br><span class="line">.groups= i2c_dev_groups,</span><br><span class="line">.uevent= i2c_device_uevent,</span><br><span class="line">.release= i2c_client_dev_release,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_client_type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 device 结构体中获取 i2c_client 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>*<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">    <span class="comment">// 从 device 结构体中获取 i2c_driver 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>*<span class="title">driver</span>;</span></span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!client)<span class="comment">// 如果 client 不存在,则返回 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">client-&gt;irq = client-&gt;init_irq;</span><br><span class="line"><span class="comment">// 如果 client 没有中断号，则尝试获取中断号</span></span><br><span class="line"><span class="keyword">if</span> (!client-&gt;irq) &#123;</span><br><span class="line"><span class="type">int</span> irq = -ENOENT;</span><br><span class="line"><span class="comment">// 如果 client 使用 Host Notify 中断,则使用 i2c_smbus_host_notify_to_irq 获取中断号</span></span><br><span class="line"><span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_HOST_NOTIFY) &#123;</span><br><span class="line">dev_dbg(dev, <span class="string">&quot;Using Host Notify IRQ\n&quot;</span>);</span><br><span class="line"><span class="comment">/* Keep adapter active when Host Notify is required */</span></span><br><span class="line">pm_runtime_get_sync(&amp;client-&gt;adapter-&gt;dev);</span><br><span class="line">irq = i2c_smbus_host_notify_to_irq(client);</span><br><span class="line">        <span class="comment">// 如果设备有 DT 节点,则尝试从 DT 节点获取中断号</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">irq = of_irq_get_byname(dev-&gt;of_node, <span class="string">&quot;irq&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (irq == -EINVAL || irq == -ENODATA)</span><br><span class="line">irq = of_irq_get(dev-&gt;of_node, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果设备有 ACPI 关联,则尝试从 ACPI 获取中断号</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACPI_COMPANION(dev)) &#123;</span><br><span class="line">irq = i2c_acpi_get_irq(client);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果获取中断号失败,则设置为 0</span></span><br><span class="line"><span class="keyword">if</span> (irq == -EPROBE_DEFER) &#123;</span><br><span class="line">status = irq;</span><br><span class="line"><span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">irq = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 将获取到的中断号设置到 client 结构体中</span></span><br><span class="line">client-&gt;irq = irq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 dev-&gt;driver 转换为 i2c_driver 类型</span></span><br><span class="line">driver = to_i2c_driver(dev-&gt;driver);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An I2C ID table is not mandatory, if and only if, a suitable OF</span></span><br><span class="line"><span class="comment"> * or ACPI ID table is supplied for the probing device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 如果 driver 没有 ID 表,且设备也没有匹配的 OF 或 ACPI ID 表,则返回 -ENODEV</span></span><br><span class="line"><span class="keyword">if</span> (!driver-&gt;id_table &amp;&amp;</span><br><span class="line">    !acpi_driver_match_device(dev, dev-&gt;driver) &amp;&amp;</span><br><span class="line">    !i2c_of_match_device(dev-&gt;driver-&gt;of_match_table, client)) &#123;</span><br><span class="line">status = -ENODEV;</span><br><span class="line"><span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 client 需要唤醒功能,则尝试设置唤醒中断</span></span><br><span class="line"><span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_WAKE) &#123;</span><br><span class="line"><span class="type">int</span> wakeirq;</span><br><span class="line"></span><br><span class="line">wakeirq = of_irq_get_byname(dev-&gt;of_node, <span class="string">&quot;wakeup&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (wakeirq == -EPROBE_DEFER) &#123;</span><br><span class="line">status = wakeirq;</span><br><span class="line"><span class="keyword">goto</span> put_sync_adapter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启用设备的唤醒功能</span></span><br><span class="line">device_init_wakeup(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 如果获取到了唤醒中断号,且与普通中断号不同,则设置专用唤醒中断</span></span><br><span class="line"><span class="keyword">if</span> (wakeirq &gt; <span class="number">0</span> &amp;&amp; wakeirq != client-&gt;irq)</span><br><span class="line">status = dev_pm_set_dedicated_wake_irq(dev, wakeirq);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (client-&gt;irq &gt; <span class="number">0</span>)<span class="comment">// 否则,使用普通中断作为唤醒中断</span></span><br><span class="line">status = dev_pm_set_wake_irq(dev, client-&gt;irq);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">status = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 如果设置唤醒中断失败,则输出警告</span></span><br><span class="line"><span class="keyword">if</span> (status)</span><br><span class="line">dev_warn(&amp;client-&gt;dev, <span class="string">&quot;failed to set up wakeup irq\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dev_dbg(dev, <span class="string">&quot;probe\n&quot;</span>);</span><br><span class="line"><span class="comment">// 设置设备的时钟默认值</span></span><br><span class="line">status = of_clk_set_defaults(dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> err_clear_wakeup_irq;</span><br><span class="line"><span class="comment">// 附加 PM 域</span></span><br><span class="line">status = dev_pm_domain_attach(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (status)</span><br><span class="line"><span class="keyword">goto</span> err_clear_wakeup_irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When there are no more users of probe(),</span></span><br><span class="line"><span class="comment"> * rename probe_new to probe.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (driver-&gt;probe_new)<span class="comment">// 调用 driver 的 probe_new 或 probe 函数</span></span><br><span class="line">status = driver-&gt;probe_new(client);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (driver-&gt;probe)</span><br><span class="line">status = driver-&gt;probe(client,</span><br><span class="line">       i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">status = -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status)<span class="comment">// 如果 probe 函数失败,则清除唤醒中断并分离 PM 域</span></span><br><span class="line"><span class="keyword">goto</span> err_detach_pm_domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_detach_pm_domain:</span><br><span class="line">dev_pm_domain_detach(&amp;client-&gt;dev, <span class="literal">true</span>);</span><br><span class="line">err_clear_wakeup_irq:</span><br><span class="line">dev_pm_clear_wake_irq(&amp;client-&gt;dev);</span><br><span class="line">device_init_wakeup(&amp;client-&gt;dev, <span class="literal">false</span>);</span><br><span class="line">put_sync_adapter:</span><br><span class="line"><span class="keyword">if</span> (client-&gt;flags &amp; I2C_CLIENT_HOST_NOTIFY)</span><br><span class="line">pm_runtime_put_sync(&amp;client-&gt;adapter-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="struct-i2c-board-info"><a href="#struct-i2c-board-info" class="headerlink" title="struct i2c_board_info"></a>struct i2c_board_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_board_info - template for device creation</span></span><br><span class="line"><span class="comment"> * @type: chip type, to initialize i2c_client.name</span></span><br><span class="line"><span class="comment"> * @flags: to initialize i2c_client.flags</span></span><br><span class="line"><span class="comment"> * @addr: stored in i2c_client.addr</span></span><br><span class="line"><span class="comment"> * @dev_name: Overrides the default &lt;busnr&gt;-&lt;addr&gt; dev_name if set</span></span><br><span class="line"><span class="comment"> * @platform_data: stored in i2c_client.dev.platform_data</span></span><br><span class="line"><span class="comment"> * @of_node: pointer to OpenFirmware device node</span></span><br><span class="line"><span class="comment"> * @fwnode: device node supplied by the platform firmware</span></span><br><span class="line"><span class="comment"> * @properties: additional device properties for the device</span></span><br><span class="line"><span class="comment"> * @resources: resources associated with the device</span></span><br><span class="line"><span class="comment"> * @num_resources: number of resources in the @resources array</span></span><br><span class="line"><span class="comment"> * @irq: stored in i2c_client.irq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I2C doesn&#x27;t actually support hardware probing, although controllers and</span></span><br><span class="line"><span class="comment"> * devices may be able to use I2C_SMBUS_QUICK to tell whether or not there&#x27;s</span></span><br><span class="line"><span class="comment"> * a device at a given address.  Drivers commonly need more information than</span></span><br><span class="line"><span class="comment"> * that, such as chip type, configuration, associated IRQ, and so on.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * i2c_board_info is used to build tables of information listing I2C devices</span></span><br><span class="line"><span class="comment"> * that are present.  This information is used to grow the driver model tree.</span></span><br><span class="line"><span class="comment"> * For mainboards this is done statically using i2c_register_board_info();</span></span><br><span class="line"><span class="comment"> * bus numbers identify adapters that aren&#x27;t yet available.  For add-on boards,</span></span><br><span class="line"><span class="comment"> * i2c_new_client_device() does this dynamically with the adapter already known.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line"><span class="type">char</span>type[I2C_NAME_SIZE];<span class="comment">// I2C 设备的类型名称,最大长度为 I2C_NAME_SIZE</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>flags;<span class="comment">// I2C 设备的标志位,用于指定设备的特殊属性</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>addr;<span class="comment">// I2C 设备的地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*dev_name;<span class="comment">// I2C 设备的设备名称</span></span><br><span class="line"><span class="type">void</span>*platform_data;<span class="comment">// I2C 设备的平台数据,可为 NUL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span><span class="comment">// I2C 设备节点在设备树中的节点指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> *<span class="title">fwnode</span>;</span><span class="comment">// I2C 设备节点在 ACPI 中的 fwnode 句柄</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_entry</span> *<span class="title">properties</span>;</span><span class="comment">// I2C 设备的属性列表</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">resources</span>;</span><span class="comment">// I2C 设备使用的资源列表</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>num_resources;<span class="comment">// I2C 设备使用的资源数量</span></span><br><span class="line"><span class="type">int</span>irq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 i2c_adapter 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">i2c_ada</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_board_info 结构体数组,用于描述 ft5x06 设备</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">ft5x06</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .type = <span class="string">&quot;my-ft5x06&quot;</span>,</span><br><span class="line">        .addr = <span class="number">0x38</span>, <span class="comment">// ft5x06 设备的 I2C 地址</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动的初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_client_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 I2C 适配器</span></span><br><span class="line">    i2c_ada = i2c_get_adapter(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span> (!i2c_ada)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to get I2C adapter\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 ft5x06 设备</span></span><br><span class="line">    i2c_new_device(i2c_ada, ft5x06);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动的退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_client_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 释放 I2C 适配器</span></span><br><span class="line">    i2c_put_adapter(i2c_ada);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动的初始化和退出入口函数</span></span><br><span class="line">module_init(ft5x06_client_init);</span><br><span class="line">module_exit(ft5x06_client_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="核心层-I2C-通信"><a href="#核心层-I2C-通信" class="headerlink" title="核心层 I2C 通信"></a>核心层 I2C 通信</h2><p>I2C 核心层的主要函数为 <code>i2c_master_send</code>、<code>i2c_master_recv</code> 和 <code>i2c_transfer</code>，其中 <code>i2c_master_send</code> 和<code>i2c_master_recv</code> 函数，是 I2C 核心层提供的基本读写接口。这两个函数负责生成符合 I2C 协议的时序和数据帧,并通过对应的 I2C 适配器驱动程序进行实际的总线操作。两个函数定义在<code>include/linux/i2c.h</code>文件当中</p><h3 id="i2c-master-recv"><a href="#i2c-master-recv" class="headerlink" title="i2c_master_recv()"></a>i2c_master_recv()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_recv - issue a single I2C message in master receive mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where to store data read from slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to read, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i2c_transfer_buffer_flags(client, buf, count, I2C_M_RD);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="i2c-master-send"><a href="#i2c-master-send" class="headerlink" title="i2c_master_send()"></a>i2c_master_send()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_master_send - issue a single I2C message in master transmit mode</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Data that will be written to the slave</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to write, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes written.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i2c_transfer_buffer_flags(client, (<span class="type">char</span> *)buf, count, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="i2c-transfer-buffer-flags"><a href="#i2c-transfer-buffer-flags" class="headerlink" title="i2c_transfer_buffer_flags()"></a>i2c_transfer_buffer_flags()</h3><p><code>i2c_master_recv()</code>和<code>i2c_master_send()</code>实际调用了<code>i2c_transfer_buffer_flags()</code>这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/i2c/i2c-core-base.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer_buffer_flags - issue a single I2C message transferring data</span></span><br><span class="line"><span class="comment"> *       to/from a buffer</span></span><br><span class="line"><span class="comment"> * @client: Handle to slave device</span></span><br><span class="line"><span class="comment"> * @buf: Where the data is stored</span></span><br><span class="line"><span class="comment"> * @count: How many bytes to transfer, must be less than 64k since msg.len is u16</span></span><br><span class="line"><span class="comment"> * @flags: The flags to be used for the message, e.g. I2C_M_RD for reads</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, or else the number of bytes transferred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer_buffer_flags</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">char</span> *buf,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> count, u16 flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 构建 i2c_msg 结构体,描述本次传输操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span> =</span> &#123;</span><br><span class="line">.addr = client-&gt;addr, <span class="comment">// 设置从设备地址</span></span><br><span class="line">.flags = flags | (client-&gt;flags &amp; I2C_M_TEN),<span class="comment">// 设置传输标志位,包括用户传入的标志位和客户端对象自身的标志位</span></span><br><span class="line">.len = count,<span class="comment">// 设置传输数据长度</span></span><br><span class="line">.buf = buf,<span class="comment">// 设置数据缓冲区</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 调用 i2c_transfer 函数进行数据传输</span></span><br><span class="line">    <span class="comment">// 该函数会根据传输的消息数量返回实际传输成功的消息数量</span></span><br><span class="line">ret = i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If everything went ok (i.e. 1 msg transferred), return #bytes</span></span><br><span class="line"><span class="comment"> * transferred, else error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (ret == <span class="number">1</span>) ? count : ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer_buffer_flags);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数用于通过 I2C 总线传输数据。它首先构建了一个 <code>i2c_msg</code> 结构体,描述本次传输操作,包括从设备地址、传输标志位、数据长度和数据缓冲区。然后调用 <code>i2c_transfer</code> 函数进行实际的数据传输。</p><h3 id="i2c-transfer"><a href="#i2c-transfer" class="headerlink" title="i2c_transfer()"></a>i2c_transfer()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i2c_transfer - execute a single or combined I2C message</span></span><br><span class="line"><span class="comment"> * @adap: Handle to I2C bus</span></span><br><span class="line"><span class="comment"> * @msgs: One or more messages to execute before STOP is issued to</span></span><br><span class="line"><span class="comment"> *terminate the operation; each message begins with a START.</span></span><br><span class="line"><span class="comment"> * @num: Number of messages to be executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, else the number of messages executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that there is no requirement that each message be sent to</span></span><br><span class="line"><span class="comment"> * the same slave address, although that is the most common model.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!adap-&gt;algo-&gt;master_xfer) &#123;<span class="comment">// 如果适配器不支持 master_xfer 操作,直接返回错误</span></span><br><span class="line">dev_dbg(&amp;adap-&gt;dev, <span class="string">&quot;I2C level transfers not supported\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* REVISIT the fault reporting model here is weak:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - When we get an error after receiving N bytes from a slave,</span></span><br><span class="line"><span class="comment"> *    there is no way to report &quot;N&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - When we get a NAK after transmitting N bytes to a slave,</span></span><br><span class="line"><span class="comment"> *    there is no way to report &quot;N&quot; ... or to let the master</span></span><br><span class="line"><span class="comment"> *    continue executing the rest of this combined message, if</span></span><br><span class="line"><span class="comment"> *    that&#x27;s the appropriate response.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - When for example &quot;num&quot; is two and we successfully complete</span></span><br><span class="line"><span class="comment"> *    the first message but get an error part way through the</span></span><br><span class="line"><span class="comment"> *    second, it&#x27;s unclear whether that should be reported as</span></span><br><span class="line"><span class="comment"> *    one (discarding status on the second message) or errno</span></span><br><span class="line"><span class="comment"> *    (discarding status on the first one).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = __i2c_lock_bus_helper(adap);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">// 调用__i2c_transfer 执行实际的消息传输</span></span><br><span class="line">ret = __i2c_transfer(adap, msgs, num);</span><br><span class="line">i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);<span class="comment">// 解锁 I2C 总线</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_transfer);</span><br></pre></td></tr></table></figure><ul><li><code>struct i2c_adapter *adap</code>: 表示要使用的 I2C 适配器。每个 I2C 控制器对应一个 <code>i2c_adapter</code> 结构体,里面包含了这个适配器的各种属性和操作函数。</li><li><code>struct i2c_msg *msgs</code>: 指向一个 i2c_msg 结构体数组,用于描述要传输的一个或多个 I2C消息。</li></ul><h4 id="struct-i2c-msg"><a href="#struct-i2c-msg" class="headerlink" title="struct i2c_msg"></a>struct i2c_msg</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/i2c.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_msg - an I2C transaction segment beginning with START</span></span><br><span class="line"><span class="comment"> * @addr: Slave address, either seven or ten bits.  When this is a ten</span></span><br><span class="line"><span class="comment"> *bit address, I2C_M_TEN must be set in @flags and the adapter</span></span><br><span class="line"><span class="comment"> *must support I2C_FUNC_10BIT_ADDR.</span></span><br><span class="line"><span class="comment"> * @flags: I2C_M_RD is handled by all adapters.  No other flags may be</span></span><br><span class="line"><span class="comment"> *provided unless the adapter exported the relevant I2C_FUNC_*</span></span><br><span class="line"><span class="comment"> *flags through i2c_check_functionality().</span></span><br><span class="line"><span class="comment"> * @len: Number of data bytes in @buf being read from or written to the</span></span><br><span class="line"><span class="comment"> *I2C slave address.  For read transactions where I2C_M_RECV_LEN</span></span><br><span class="line"><span class="comment"> *is set, the caller guarantees that this buffer can hold up to</span></span><br><span class="line"><span class="comment"> *32 bytes in addition to the initial length byte sent by the</span></span><br><span class="line"><span class="comment"> *slave (plus, if used, the SMBus PEC); and this value will be</span></span><br><span class="line"><span class="comment"> *incremented by the number of block data bytes received.</span></span><br><span class="line"><span class="comment"> * @buf: The buffer into which data is read, or from which it&#x27;s written.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An i2c_msg is the low level representation of one segment of an I2C</span></span><br><span class="line"><span class="comment"> * transaction.  It is visible to drivers in the @i2c_transfer() procedure,</span></span><br><span class="line"><span class="comment"> * to userspace from i2c-dev, and to I2C adapter drivers through the</span></span><br><span class="line"><span class="comment"> * @i2c_adapter.@master_xfer() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Except when I2C &quot;protocol mangling&quot; is used, all I2C adapters implement</span></span><br><span class="line"><span class="comment"> * the standard rules for I2C transactions.  Each transaction begins with a</span></span><br><span class="line"><span class="comment"> * START.  That is followed by the slave address, and a bit encoding read</span></span><br><span class="line"><span class="comment"> * versus write.  Then follow all the data bytes, possibly including a byte</span></span><br><span class="line"><span class="comment"> * with SMBus PEC.  The transfer terminates with a NAK, or when all those</span></span><br><span class="line"><span class="comment"> * bytes have been transferred and ACKed.  If this is the last message in a</span></span><br><span class="line"><span class="comment"> * group, it is followed by a STOP.  Otherwise it is followed by the next</span></span><br><span class="line"><span class="comment"> * @i2c_msg transaction segment, beginning with a (repeated) START.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Alternatively, when the adapter supports I2C_FUNC_PROTOCOL_MANGLING then</span></span><br><span class="line"><span class="comment"> * passing certain @flags may have changed those standard protocol behaviors.</span></span><br><span class="line"><span class="comment"> * Those flags are only for use with broken/nonconforming slaves, and with</span></span><br><span class="line"><span class="comment"> * adapters which are known to support the specific mangling options they</span></span><br><span class="line"><span class="comment"> * need (one or more of IGNORE_NAK, NO_RD_ACK, NOSTART, and REV_DIR_ADDR).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">__u16 addr;<span class="comment">/* slave address*/</span></span><br><span class="line">__u16 flags;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD0x0001<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line"><span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN0x0010<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_DMA_SAFE0x0200<span class="comment">/* the buffer of this message is DMA safe */</span></span></span><br><span class="line"><span class="comment">/* makes only sense in kernelspace */</span></span><br><span class="line"><span class="comment">/* userspace buffers are copied anyway */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN0x0400<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK0x0800<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK0x1000<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR0x2000<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART0x4000<span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_STOP0x8000<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">__u16 len;<span class="comment">/* msg length*/</span></span><br><span class="line">__u8 *buf;<span class="comment">/* pointer to msg data*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据 <code>i2c_master_send</code> 函数传入参数可推断出 0 为写操作</p><h4 id="struct-i2c-algorithm"><a href="#struct-i2c-algorithm" class="headerlink" title="struct i2c_algorithm"></a>struct i2c_algorithm</h4><p><code>i2c_transfer</code> 函数自身并没有控制硬件的能力，<br>实际上 <code>master_xfer</code> 才是真正驱动硬件工作的函数，从而实现 I2C 通信，<code>master_xfer</code> 定义在<code>i2c_adapter</code> 结构体的 <code>i2c_algorithm </code>结构体中，具体内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_algorithm - represent I2C transfer method</span></span><br><span class="line"><span class="comment"> * @master_xfer: Issue a set of i2c transactions to the given I2C adapter</span></span><br><span class="line"><span class="comment"> *   defined by the msgs array, with num messages available to transfer via</span></span><br><span class="line"><span class="comment"> *   the adapter specified by adap.</span></span><br><span class="line"><span class="comment"> * @master_xfer_atomic: same as @master_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer: Issue smbus transactions to the given I2C adapter. If this</span></span><br><span class="line"><span class="comment"> *   is not present, then the bus layer will try and convert the SMBus calls</span></span><br><span class="line"><span class="comment"> *   into I2C transfers instead.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer_atomic: same as @smbus_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @functionality: Return the flags that this algorithm/adapter pair supports</span></span><br><span class="line"><span class="comment"> *   from the ``I2C_FUNC_*`` flags.</span></span><br><span class="line"><span class="comment"> * @reg_slave: Register given client to I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> * @unreg_slave: Unregister given client from I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following structs are for those who like to implement new bus drivers:</span></span><br><span class="line"><span class="comment"> * i2c_algorithm is the interface to a class of hardware solutions which can</span></span><br><span class="line"><span class="comment"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span></span><br><span class="line"><span class="comment"> * to name two of the most common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return codes from the ``master_xfer&#123;_atomic&#125;`` fields should indicate the</span></span><br><span class="line"><span class="comment"> * type of error code that occurred during the transfer, as documented in the</span></span><br><span class="line"><span class="comment"> * Kernel Documentation file Documentation/i2c/fault-codes.rst.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment"> * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment"> * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment"> * using common I2C messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment"> * processed, or a negative value on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">   <span class="type">int</span> num);</span><br><span class="line"><span class="type">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line"><span class="type">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"><span class="type">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line"> u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">u32 (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line"><span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>master_xfer</code>和<code>smbus_xfer</code>两个函数都是 I2C 设备驱动层控制硬件的函数，由原厂工程师进行编写，rk3568 的实现函数定义在<code>drivers/i2c/busses/i2c-rk3x.c</code>文件中，一般情况下只需使用<code>i2c_transfer</code> 函数间接调用即可。</p><h4 id="i2c-lock-bus-helper"><a href="#i2c-lock-bus-helper" class="headerlink" title="__i2c_lock_bus_helper"></a>__i2c_lock_bus_helper</h4><p><code>i2c_transfer</code>中调用实际执行传输的函数<code>__i2c_transfer</code>之前要调用<code>__i2c_lock_bus_helper</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We only allow atomic transfers for very late communication, e.g. to access a</span></span><br><span class="line"><span class="comment"> * PMIC when powering down. Atomic transfers are a corner case and not for</span></span><br><span class="line"><span class="comment"> * generic use!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">i2c_in_atomic_xfer_mode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> system_state &gt; SYSTEM_RUNNING &amp;&amp; irqs_disabled();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __i2c_lock_bus_helper(<span class="keyword">struct</span> i2c_adapter *adap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i2c_in_atomic_xfer_mode()) &#123;</span><br><span class="line">WARN(!adap-&gt;algo-&gt;master_xfer_atomic &amp;&amp; !adap-&gt;algo-&gt;smbus_xfer_atomic,</span><br><span class="line">     <span class="string">&quot;No atomic I2C transfer handler for &#x27;%s&#x27;\n&quot;</span>, dev_name(&amp;adap-&gt;dev));</span><br><span class="line">ret = i2c_trylock_bus(adap, I2C_LOCK_SEGMENT) ? <span class="number">0</span> : -EAGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i2c_lock_bus(adap, I2C_LOCK_SEGMENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的目的是在保证系统的稳定性的前提下,通过适当的锁定机制来管理对 I2C 总线的访问,防止多个操作之间的竞争条件.</p><ul><li>如果<strong>当前处于原子上下文或者中断被禁用</strong>, 在这两种情况下,<strong>内核通常不允许执行可能导致上下文切换的操作</strong>。</li></ul><p>代码使用<code>i2c_trylock_bus()</code> 函数来尝试获取 I2C总线的锁定。<code>I2C_LOCK_SEGMENT</code> 是用于指定锁定标志的。如果<code>i2c_trylock_bus()</code> 返回失败(返回值为 false),表示 I2C 总线上正在进行活动,此时函数返回错误码 -EAGAIN,表示暂时无法获取锁。</p><ul><li>如果不处于原子上下文或者中断被禁用</li></ul><p>代码直接调用 i2c_lock_bus() 函数来获取 I2C 总线的锁,而不进行条件检查。这是因为在这种情况下,系统允许执行可能导致上下文切换的操作。</p><h4 id="i2c-transfer-1"><a href="#i2c-transfer-1" class="headerlink" title="__i2c_transfer"></a>__i2c_transfer</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __i2c_transfer - unlocked flavor of i2c_transfer</span></span><br><span class="line"><span class="comment"> * @adap: Handle to I2C bus</span></span><br><span class="line"><span class="comment"> * @msgs: One or more messages to execute before STOP is issued to</span></span><br><span class="line"><span class="comment"> *terminate the operation; each message begins with a START.</span></span><br><span class="line"><span class="comment"> * @num: Number of messages to be executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns negative errno, else the number of messages executed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Adapter lock must be held when calling this function. No debug logging</span></span><br><span class="line"><span class="comment"> * takes place. adap-&gt;algo-&gt;master_xfer existence isn&#x27;t checked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __i2c_transfer(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> orig_jiffies;<span class="comment">// 记录初始的 jiffies 值</span></span><br><span class="line"><span class="type">int</span> ret, try;<span class="comment">// 返回值和重试次数</span></span><br><span class="line"><span class="comment">// 如果 msgs 为空或 num 小于 1,返回无效参数错误</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!msgs || num &lt; <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">ret = __i2c_check_suspended(adap);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">// 如果适配器有特殊需求,检查是否支持当前的 I2C 消息</span></span><br><span class="line"><span class="keyword">if</span> (adap-&gt;quirks &amp;&amp; i2c_check_for_quirks(adap, msgs, num))</span><br><span class="line"><span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_trace_msg_key gets enabled when tracepoint i2c_transfer gets</span></span><br><span class="line"><span class="comment"> * enabled.  This is an efficient way of keeping the for-loop from</span></span><br><span class="line"><span class="comment"> * being executed when not needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 如果启用了 i2c_trace_msg_key 这个分支点(用于跟踪 I2C 传输消息),</span></span><br><span class="line"><span class="comment">* 则遍历所有消息,分别记录读操作和写操作的跟踪信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;i2c_trace_msg_key)) &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line"><span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">trace_i2c_read(adap, &amp;msgs[i], i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">trace_i2c_write(adap, &amp;msgs[i], i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Retry automatically on arbitration loss */</span> <span class="comment">// 自动重试仲裁丢失错误</span></span><br><span class="line">orig_jiffies = jiffies;</span><br><span class="line"><span class="keyword">for</span> (ret = <span class="number">0</span>, try = <span class="number">0</span>; try &lt;= adap-&gt;retries; try++) &#123;</span><br><span class="line">        <span class="comment">// 调用适配器的 master_xfer 函数完成 I2C 传输</span></span><br><span class="line"><span class="keyword">if</span> (i2c_in_atomic_xfer_mode() &amp;&amp; adap-&gt;algo-&gt;master_xfer_atomic)</span><br><span class="line">ret = adap-&gt;algo-&gt;master_xfer_atomic(adap, msgs, num);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = adap-&gt;algo-&gt;master_xfer(adap, msgs, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret != -EAGAIN)<span class="comment">// 如果不是仲裁丢失错误,退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (time_after(jiffies, orig_jiffies + adap-&gt;timeout))<span class="comment">// 如果超时,退出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果启用了 i2c_trace_msg_key 这个分支点,记录 I2C 传输的结果</span></span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;i2c_trace_msg_key)) &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++)</span><br><span class="line"><span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD)</span><br><span class="line">trace_i2c_reply(adap, &amp;msgs[i], i);</span><br><span class="line">trace_i2c_result(adap, num, ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__i2c_transfer);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>__i2c_transfer</code>中会 记 录 当 前 的 时 间 戳 <code>orig_jiffies</code>, 并 循 环 最多 <code>adap-&gt;retries</code> 次重试。在每次重试时,调用适配器的 <code>master_xfer</code> 函数完成 I2C 传输。如果返回值不是 <code>-EAGAIN</code>(表示仲裁丢失错误),或者已经超时,则退出循环。</p><h2 id="I2C-驱动"><a href="#I2C-驱动" class="headerlink" title="I2C 驱动"></a>I2C 驱动</h2><h3 id="i2c-add-driver"><a href="#i2c-add-driver" class="headerlink" title="i2c_add_driver()"></a>i2c_add_driver()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i2c_add_driver(driver) \</span></span><br><span class="line"><span class="meta">i2c_register_driver(THIS_MODULE, driver)</span></span><br></pre></td></tr></table></figure><p>具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/i2c/i2c-core-base.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * An i2c_driver is used with one or more i2c_client (device) nodes to access</span></span><br><span class="line"><span class="comment"> * i2c slave chips, on a bus instance associated with some i2c_adapter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_register_driver</span><span class="params">(<span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Can&#x27;t register until after driver model init */</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(!is_registered))</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* add the driver to the list of i2c drivers in the driver core */</span></span><br><span class="line">driver-&gt;driver.owner = owner;</span><br><span class="line">driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line">INIT_LIST_HEAD(&amp;driver-&gt;clients);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When registration returns, the driver core</span></span><br><span class="line"><span class="comment"> * will have called probe() for all matching-but-unbound devices.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">res = driver_register(&amp;driver-&gt;driver);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">&quot;driver [%s] registered\n&quot;</span>, driver-&gt;driver.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Walk the adapters that are already present */</span></span><br><span class="line">i2c_for_each_dev(driver, __process_new_driver);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(i2c_register_driver);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数的主要作用是将 I2C 设备驱动程序注册到驱动核心中,并初始化相关数据结构,这里传入的数据结构类型为 <code>i2c_driver</code>，需要我们在驱动程序编写的时候进行填充，该结构体定义在<code>include/linux/i2c.h</code>头文件中，具体内容如下所示：</p><h3 id="struct-i2c-driver"><a href="#struct-i2c-driver" class="headerlink" title="struct i2c_driver"></a>struct i2c_driver</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_driver - represent an I2C device driver</span></span><br><span class="line"><span class="comment"> * @class: What kind of i2c device we instantiate (for detect)</span></span><br><span class="line"><span class="comment"> * @probe: Callback for device binding - soon to be deprecated</span></span><br><span class="line"><span class="comment"> * @probe_new: New callback for device binding</span></span><br><span class="line"><span class="comment"> * @remove: Callback for device unbinding</span></span><br><span class="line"><span class="comment"> * @shutdown: Callback for device shutdown</span></span><br><span class="line"><span class="comment"> * @alert: Alert callback, for example for the SMBus alert protocol</span></span><br><span class="line"><span class="comment"> * @command: Callback for bus-wide signaling (optional)</span></span><br><span class="line"><span class="comment"> * @driver: Device driver model driver</span></span><br><span class="line"><span class="comment"> * @id_table: List of I2C devices supported by this driver</span></span><br><span class="line"><span class="comment"> * @detect: Callback for device detection</span></span><br><span class="line"><span class="comment"> * @address_list: The I2C addresses to probe (for detect)</span></span><br><span class="line"><span class="comment"> * @clients: List of detected clients we created (for i2c-core use only)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The driver.owner field should be set to the module owner of this driver.</span></span><br><span class="line"><span class="comment"> * The driver.name field should be set to the name of this driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For automatic device detection, both @detect and @address_list must</span></span><br><span class="line"><span class="comment"> * be defined. @class should also be set, otherwise only devices forced</span></span><br><span class="line"><span class="comment"> * with module parameters will be created. The detect function must</span></span><br><span class="line"><span class="comment"> * fill at least the name field of the i2c_board_info structure it is</span></span><br><span class="line"><span class="comment"> * handed upon successful detection, and possibly also the flags field.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @detect is missing, the driver will still work fine for enumerated</span></span><br><span class="line"><span class="comment"> * devices. Detected devices simply won&#x27;t be supported. This is expected</span></span><br><span class="line"><span class="comment"> * for the many I2C/SMBus devices which can&#x27;t be detected reliably, and</span></span><br><span class="line"><span class="comment"> * the ones which can always be enumerated in practice.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The i2c_client structure which is handed to the @detect callback is</span></span><br><span class="line"><span class="comment"> * not a real i2c_client. It is initialized just enough so that you can</span></span><br><span class="line"><span class="comment"> * call i2c_smbus_read_byte_data and friends on it. Don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * else with it. In particular, calling dev_dbg and friends on it is</span></span><br><span class="line"><span class="comment"> * not allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span> <span class="comment">// 驱动程序所属的设备类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line"><span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id);<span class="comment">// 探测并绑定设备的回调函数</span></span><br><span class="line"><span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *client);<span class="comment">// 从设备上解绑驱动程序的回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment"> * current probe()&#x27;s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*probe_new)(<span class="keyword">struct</span> i2c_client *client);<span class="comment">// 新的探测设备并绑定的回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line"><span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *client); <span class="comment">// 设备关闭时调用的回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment"> * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment"> * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment"> * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment"> * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment"> * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> data);<span class="comment">// 设备报警时调用的回调函数,格式和含义取决于所使用的协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment"> * with the device.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span><span class="comment">// 设备驱动程序基础结构</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span><span class="comment">// 与该驱动程序匹配的设备 ID 表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line"><span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> i2c_board_info *info);<span class="comment">// 用于自动创建设备的探测回调函数</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list;<span class="comment">// 与该驱动程序匹配的设备地址列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span><span class="comment">// 与该驱动程序绑定的 I2C 设备列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在调用 <code>i2c_add_driver</code> 函数注册 I2C 设备之前，需要先填充 <code>i2c_driver</code> 结构体，然后实现的各种回调函数，跟前面讲解的平台总线内容相同</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个工作结构体</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WORK</span><span class="params">(ft5x06_work, ft5x06_func)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 ft5x06 设备的 GPIO 描述符</span></span><br><span class="line"><span class="comment">// 用于保存 reset 和 interrupt 引脚的 GPIO 描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">reset_gpio</span>, *<span class="title">irq_gpio</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存 ft5x06 设备的 i2c 客户端对象指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">ft5x06_client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存 ft5x06 输入设备的dev指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">ft5x06_input_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 ft5x06 设备寄存器的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_read_reg</span><span class="params">(u8 reg_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 data;</span><br><span class="line">    <span class="comment">// 定义两个 i2c_msg 结构体,分别表示写操作和读操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[2] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr, <span class="comment">// 设备地址</span></span><br><span class="line">            .flags = <span class="number">0</span>,        <span class="comment">// 写操作</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(reg_addr),</span><br><span class="line">            .buf = &amp;reg_addr,  <span class="comment">// 写入要读取的寄存器地址</span></span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="number">1</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr,</span><br><span class="line">            .flags = I2C_M_RD, <span class="comment">// 读操作</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(data),</span><br><span class="line">            .buf = &amp;data,      <span class="comment">// 读取到的数据存储位置</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 i2c_transfer 函数进行 i2c 总线读取操作</span></span><br><span class="line">   <span class="comment">// 如果读取失败,返回 -EIO 错误码</span></span><br><span class="line">   <span class="keyword">if</span> (i2c_transfer(ft5x06_client-&gt;adapter, msgs, ARRAY_SIZE(msgs)) != ARRAY_SIZE(msgs))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 返回读取到的寄存器值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 ft5x06 设备写入寄存器的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(u8 reg_addr, u8 *data, u16 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buff[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr, <span class="comment">// 设备地址</span></span><br><span class="line">            .flags = <span class="number">0</span>,        <span class="comment">// 写操作</span></span><br><span class="line">            .len = len + <span class="number">1</span>,    <span class="comment">// 数据长度 + 寄存器地址长度</span></span><br><span class="line">            .buf = buff,       <span class="comment">// 数据缓冲区</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    buff[<span class="number">0</span>] = reg_addr;       <span class="comment">// 写入寄存器地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buff[<span class="number">1</span>], data, len); <span class="comment">// 写入数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 i2c_transfer 函数进行 i2c 总线写入操作</span></span><br><span class="line">    <span class="comment">// 如果写入失败,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (i2c_transfer(ft5x06_client-&gt;adapter, msgs, ARRAY_SIZE(msgs)) != ARRAY_SIZE(msgs)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 中断处理函数</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">ft5x06_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 ft5x06_work 工作结构体提交到工作队列中</span></span><br><span class="line">    schedule_work(&amp;ft5x06_work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示中断已经被处理</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> TOUCH1_XH, TOUCH1_XL, x;</span><br><span class="line">    <span class="type">int</span> TOUCH1_YH, TOUCH1_YL, y;</span><br><span class="line">    <span class="type">int</span> TD_STATUS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从寄存器中读取触摸坐标数据</span></span><br><span class="line">    TOUCH1_XH = ft5x06_read_reg(<span class="number">0x03</span>);</span><br><span class="line">    TOUCH1_XL = ft5x06_read_reg(<span class="number">0x04</span>);</span><br><span class="line">    x = ((TOUCH1_XH &lt;&lt; <span class="number">8</span>) | TOUCH1_XL) &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">    TOUCH1_YH = ft5x06_read_reg(<span class="number">0x05</span>);</span><br><span class="line">    TOUCH1_YL = ft5x06_read_reg(<span class="number">0x06</span>);</span><br><span class="line">    y = ((TOUCH1_YH &lt;&lt; <span class="number">8</span>) | TOUCH1_YL) &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取触摸状态寄存器</span></span><br><span class="line">    TD_STATUS = ft5x06_read_reg(<span class="number">0x02</span>);</span><br><span class="line">    TD_STATUS = TD_STATUS &amp; <span class="number">0xf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据触摸状态更新输入设备</span></span><br><span class="line">    <span class="keyword">if</span> (TD_STATUS == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 触摸释放</span></span><br><span class="line">        input_report_key(ft5x06_input_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(ft5x06_input_dev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 触摸按下</span></span><br><span class="line">        input_report_key(ft5x06_input_dev, BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">        input_report_abs(ft5x06_input_dev, ABS_X, x);</span><br><span class="line">        input_report_abs(ft5x06_input_dev, ABS_Y, y);</span><br><span class="line">        input_sync(ft5x06_input_dev);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ft5x06 设备的初始化函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    printk(<span class="string">&quot;This is ft5x06 probe\n&quot;</span>);</span><br><span class="line">    ft5x06_client = client; <span class="comment">// 保存 i2c 客户端对象指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 reset GPIO 描述符</span></span><br><span class="line">    <span class="comment">// gpiod_get_optional 函数尝试获取设备树中名为 &quot;reset&quot; 的 GPIO 描述符,</span></span><br><span class="line">    <span class="comment">// 如果获取失败则返回 NULL</span></span><br><span class="line">    reset_gpio = gpiod_get_optional(&amp;client-&gt;dev, <span class="string">&quot;reset&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!reset_gpio) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpiod_get_optional reset gpio is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 irq GPIO 描述符</span></span><br><span class="line">    <span class="comment">// gpiod_get_optional 函数尝试获取设备树中名为 &quot;interrupts&quot; 的 GPIO 描述符,</span></span><br><span class="line">    <span class="comment">// 如果获取失败则返回 NULL</span></span><br><span class="line">    irq_gpio = gpiod_get_optional(&amp;client-&gt;dev, <span class="string">&quot;interrupts&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!irq_gpio) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpiod_get_optional irq gpio is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 reset GPIO 为输出,并拉低 5ms 后拉高</span></span><br><span class="line">    <span class="comment">// 这是一个复位操作,用于初始化 ft5x06 设备</span></span><br><span class="line">    gpiod_direction_output(reset_gpio, <span class="number">0</span>);</span><br><span class="line">    msleep(<span class="number">5</span>);</span><br><span class="line">    gpiod_direction_output(reset_gpio, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断,设置为下降沿触发,单次触发</span></span><br><span class="line">    <span class="comment">// 当 ft5x06 设备产生中断时,会调用 ft5x06_handler 函数处理</span></span><br><span class="line">    ret = request_irq(client-&gt;irq, ft5x06_handler,</span><br><span class="line">                     IRQ_TYPE_EDGE_FALLING | IRQF_ONESHOT, <span class="string">&quot;ft5x06 irq&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;request irq is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个 input 设备</span></span><br><span class="line">    ft5x06_input_dev = input_allocate_device();</span><br><span class="line">    <span class="keyword">if</span> (ft5x06_input_dev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input allocate device is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 input 设备的名称</span></span><br><span class="line">    ft5x06_input_dev-&gt;name = <span class="string">&quot;ft5x06_dev&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 input 设备支持的事件类型和事件</span></span><br><span class="line">    set_bit(EV_KEY, ft5x06_input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, ft5x06_input_dev-&gt;keybit);</span><br><span class="line">    set_bit(EV_ABS, ft5x06_input_dev-&gt;evbit);</span><br><span class="line">    set_bit(ABS_X, ft5x06_input_dev-&gt;absbit);</span><br><span class="line">    set_bit(ABS_Y, ft5x06_input_dev-&gt;absbit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 input 设备的绝对坐标范围</span></span><br><span class="line">    input_set_abs_params(ft5x06_input_dev, ABS_X, <span class="number">0</span>, <span class="number">800</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    input_set_abs_params(ft5x06_input_dev, ABS_Y, <span class="number">0</span>, <span class="number">1280</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 input 设备</span></span><br><span class="line">    ret = input_register_device(ft5x06_input_dev);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;input register device is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> error_0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error_0:</span><br><span class="line">    input_free_device(ft5x06_input_dev);</span><br><span class="line">    free_irq(client-&gt;irq, <span class="literal">NULL</span>);</span><br><span class="line">    gpiod_put(reset_gpio);</span><br><span class="line">    gpiod_put(irq_gpio);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 设备的移除函数</span></span><br><span class="line"><span class="comment">// 参数 client 是 i2c 客户端对象指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    free_irq(client-&gt;irq, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 释放 GPIO 资源</span></span><br><span class="line">    gpiod_put(reset_gpio);</span><br><span class="line">    gpiod_put(irq_gpio);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_device_id 结构体数组,用于标识 ft5x06 设备</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ft5x06_id</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;my-ft5x06&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_driver 结构体,描述 ft5x06 设备驱动</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my-ft5x06&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = ft5x06_probe,</span><br><span class="line">    .remove = ft5x06_remove,</span><br><span class="line">    .id_table = ft5x06_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ft5x06_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 注册 I2C 设备驱动</span></span><br><span class="line">    ret = i2c_add_driver(&amp;ft5x06_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c_add_driver is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 释放中断 */</span></span><br><span class="line">    free_irq(ft5x06_client-&gt;irq, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注销输入设备 */</span></span><br><span class="line">    input_unregister_device(ft5x06_input_dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 释放 GPIO */</span></span><br><span class="line">    gpiod_put(reset_gpio);</span><br><span class="line">    gpiod_put(irq_gpio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除 I2C 驱动 */</span></span><br><span class="line">    i2c_del_driver(&amp;ft5x06_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ft5x06_driver_init);</span><br><span class="line">module_exit(ft5x06_driver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="在应用程序中使用I2C"><a href="#在应用程序中使用I2C" class="headerlink" title="在应用程序中使用I2C"></a>在应用程序中使用I2C</h2><h3 id="ioctl-控制-I2C"><a href="#ioctl-控制-I2C" class="headerlink" title="ioctl 控制 I2C"></a>ioctl 控制 I2C</h3><p>ioctl 是设备驱动程序中用来控制设备的接口函数，可以在应用程序中通过 ioctl 控制 I2C控制器从而对 I2C 设备进行读写。RK3568 的 I2C 控制器节点如下所示：<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359881.png" alt="i2c控制器节点" loading="lazy"></p><p>对于 I2C 控制器的控制命令 CMD 定义在<code>include/uapi/linux/i2c-dev.h</code>文件中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /dev/i2c-X ioctl commands.  The ioctl&#x27;s parameter is always an</span></span><br><span class="line"><span class="comment"> * unsigned long, except for:</span></span><br><span class="line"><span class="comment"> *- I2C_FUNCS, takes pointer to an unsigned long</span></span><br><span class="line"><span class="comment"> *- I2C_RDWR, takes pointer to struct i2c_rdwr_ioctl_data</span></span><br><span class="line"><span class="comment"> *- I2C_SMBUS, takes pointer to struct i2c_smbus_ioctl_data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置重试次数,即当从设备没有响应时要重新轮询的次数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_RETRIES0x0701<span class="comment">/* number of times a device address should</span></span></span><br><span class="line"><span class="comment"><span class="meta">   be polled when not acknowledging */</span></span></span><br><span class="line"><span class="comment">//设置超时时间,单位为 10 毫秒</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_TIMEOUT0x0702<span class="comment">/* set timeout in units of 10 ms */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span> Slave address is 7 or 10 bits, but 10-bit addresses</span></span><br><span class="line"><span class="comment"> * are NOT supported! (due to code brokenness)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//使用此从机地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SLAVE0x0703<span class="comment">/* Use this slave address */</span></span></span><br><span class="line"><span class="comment">//强制使用此从机地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SLAVE_FORCE0x0706<span class="comment">/* Use this slave address, even if it</span></span></span><br><span class="line"><span class="comment"><span class="meta">   is already in use by a driver! */</span></span></span><br><span class="line"><span class="comment">//0 表示 7 位地址, 非 0 表示 10 位地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_TENBIT0x0704<span class="comment">/* 0 for 7 bit addrs, != 0 for 10 bit */</span></span></span><br><span class="line"><span class="comment">//获取适配器功能掩码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNCS0x0705<span class="comment">/* Get the adapter functionality mask */</span></span></span><br><span class="line"><span class="comment">//执行合并读写传输(只有一个 STOP 信号)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_RDWR0x0707<span class="comment">/* Combined R/W transfer (one STOP only) */</span></span></span><br><span class="line"><span class="comment">//使用 PEC(校验码)进行 SMBus 传输</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_PEC0x0708<span class="comment">/* != 0 to use PEC with SMBus */</span></span></span><br><span class="line"><span class="comment">//执行 SMBus 传输</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SMBUS0x0720<span class="comment">/* SMBus transfer */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the structure as used in the I2C_SMBUS ioctl call */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_smbus_ioctl_data</span> &#123;</span></span><br><span class="line">__u8 read_write;</span><br><span class="line">__u8 command;</span><br><span class="line">__u32 size;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">i2c_smbus_data</span> __<span class="title">user</span> *<span class="title">data</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is the structure as used in the I2C_RDWR ioctl call */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> __<span class="title">user</span> *<span class="title">msgs</span>;</span><span class="comment">/* pointers to i2c_msgs */</span></span><br><span class="line">__u32 nmsgs;<span class="comment">/* number of i2c_msgs */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  I2C_RDWR_IOCTL_MAX_MSGS42</span></span><br><span class="line"><span class="comment">/* Originally defined with a typo, keep it for compatibility */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  I2C_RDRW_IOCTL_MAX_MSGSI2C_RDWR_IOCTL_MAX_MSGS</span></span><br></pre></td></tr></table></figure><p><code>i2c_rdwr_ioctl_data</code>这 个 结 构 体 用 于 在<code>I2C_RDWR ioctl</code> 调 用 中 传 递I2C 消 息 。 其 中</p><ul><li><code>msgs</code> 是 一 个 指向 <code>i2c_msg</code> 结构体数组的指针,用于存储一个或多个 I2C 消息。</li><li><code>nmsgs</code> 是 <code>i2c_msg</code> 结构体数组的长度,即 I2C 消息的数量。</li></ul><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 从 I2C 设备的寄存器中读取数据</span></span><br><span class="line"><span class="comment"> * @param fd 打开的 I2C 设备文件描述符</span></span><br><span class="line"><span class="comment"> * @param slave_addr I2C 设备的从机地址</span></span><br><span class="line"><span class="comment"> * @param reg_addr 要读取的寄存器地址</span></span><br><span class="line"><span class="comment"> * @return 寄存器的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_read_reg</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">char</span> slave_addr, <span class="type">unsigned</span> <span class="type">char</span> reg_addr)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> <span class="title">i2c_msgs</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义两个 i2c_msg 结构体, 第一个用于写入寄存器地址, 第二个用于读取数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">dev_msgs</span>[] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = slave_addr,</span><br><span class="line">            .flags = <span class="number">0</span>,</span><br><span class="line">            .len = <span class="keyword">sizeof</span>(reg_addr),</span><br><span class="line">            .buf = &amp;reg_addr,</span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="number">1</span>] = &#123;</span><br><span class="line">            .addr = slave_addr,</span><br><span class="line">            .flags = I2C_M_RD, <span class="comment">// 设置读取标志</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(data),</span><br><span class="line">            .buf = &amp;data,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    i2c_msgs.msgs = dev_msgs;</span><br><span class="line">    i2c_msgs.nmsgs = <span class="number">2</span>; <span class="comment">// 两个 i2c_msg 结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ioctl 函数执行读取操作</span></span><br><span class="line">    ret = ioctl(fd, I2C_RDWR, &amp;i2c_msgs);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向 I2C 设备的寄存器写入数据</span></span><br><span class="line"><span class="comment"> * @param fd 打开的 I2C 设备文件描述符</span></span><br><span class="line"><span class="comment"> * @param slave_addr I2C 设备的从机地址</span></span><br><span class="line"><span class="comment"> * @param reg_addr 要写入的寄存器地址</span></span><br><span class="line"><span class="comment"> * @param data 要写入的数据</span></span><br><span class="line"><span class="comment"> * @param len 数据长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">char</span> slave_addr, <span class="type">unsigned</span> <span class="type">char</span> reg_addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buff[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> <span class="title">i2c_msgs</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 i2c_msg 结构体, 用于写入寄存器地址和数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">dev_msgs</span>[] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = slave_addr,</span><br><span class="line">            .flags = <span class="number">0</span>,</span><br><span class="line">            .len = len + <span class="number">1</span>,</span><br><span class="line">            .buf = buff,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将寄存器地址和数据拷贝到 buff 数组中</span></span><br><span class="line">    buff[<span class="number">0</span>] = reg_addr;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buff[<span class="number">1</span>], data, len);</span><br><span class="line"></span><br><span class="line">    i2c_msgs.msgs = dev_msgs;</span><br><span class="line">    i2c_msgs.nmsgs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 ioctl 函数执行写入操作</span></span><br><span class="line">    ret = ioctl(fd, I2C_RDWR, &amp;i2c_msgs);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> ID_G_THGROUP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 I2C 设备文件</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/i2c-1&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 0x38 地址的寄存器 0x80 写入 0x55</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data = <span class="number">0x55</span>;</span><br><span class="line">    ft5x06_write_reg(fd, <span class="number">0x38</span>, <span class="number">0x80</span>, &amp;data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 0x38 地址的寄存器 0x80 读取数据</span></span><br><span class="line">    ID_G_THGROUP = ft5x06_read_reg(fd, <span class="number">0x38</span>, <span class="number">0x80</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID_G_THGROUP is 0x%02X\n&quot;</span>, ID_G_THGROUP);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通用I2C驱动"><a href="#通用I2C驱动" class="headerlink" title="通用I2C驱动"></a>通用I2C驱动</h2><p>通用 I2C 驱动文件为 <code>drivers/i2c/i2c-dev.c</code>，它为 I2C 外设提供了统一的驱动框架,分为 I2C客户端 (I2C client) 和 I2C 驱动 (I2C driver)。</p><p>它为上层应用程序提供了通用的设备节点 <code>/dev/i2c-X</code>(X 代表 I2C 总线号)。</p><p>应用程序可以直接通过打开这个设备节点 <code>/dev/i2c-X</code>，并使用标准的 I&#x2F;O 操作如 open()、ioctl()、read()、write() 等来与 I2C 从设备进行通信。</p><p>该驱动程序一般情况下都是默认使能的，具体路径如下所示：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line">I2C Support</span><br><span class="line">I2C Device <span class="keyword">interface</span></span><br></pre></td></tr></table></figure><h3 id="i2c-dev-init"><a href="#i2c-dev-init" class="headerlink" title="i2c_dev_init()"></a>i2c_dev_init()</h3><p>驱动初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">i2c_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="comment">// 打印内核日志,表示 i2c /dev 条目驱动已经初始化</span></span><br><span class="line">printk(KERN_INFO <span class="string">&quot;i2c /dev entries driver\n&quot;</span>);</span><br><span class="line"><span class="comment">// 注册字符设备驱动,主设备号为 I2C_MAJOR,次设备号范围为 0 到 I2C_MINORS-1,设备名为&quot;i2c&quot;</span></span><br><span class="line">res = register_chrdev_region(MKDEV(I2C_MAJOR, <span class="number">0</span>), I2C_MINORS, <span class="string">&quot;i2c&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="comment">// 创建一个 class 对象,名称为 &quot;i2c-dev&quot;,用于在用户空间创建设备节点</span></span><br><span class="line">i2c_dev_class = class_create(THIS_MODULE, <span class="string">&quot;i2c-dev&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(i2c_dev_class)) &#123;</span><br><span class="line">res = PTR_ERR(i2c_dev_class);</span><br><span class="line"><span class="keyword">goto</span> out_unreg_chrdev;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将 i2c_groups 数组设置为该 class 的 dev_groups 属性</span></span><br><span class="line">i2c_dev_class-&gt;dev_groups = i2c_groups;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Keep track of adapters which will be added or removed later */</span></span><br><span class="line">    <span class="comment">// 注册一个总线通知函数 i2cdev_notifier,用于追踪 i2c 总线上新添加或删除的适配器</span></span><br><span class="line">res = bus_register_notifier(&amp;i2c_bus_type, &amp;i2cdev_notifier);</span><br><span class="line"><span class="keyword">if</span> (res)</span><br><span class="line"><span class="keyword">goto</span> out_unreg_class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bind to already existing adapters right away */</span></span><br><span class="line">    <span class="comment">// 立即绑定已经存在的 i2c 适配器到 i2c 设备</span></span><br><span class="line">i2c_for_each_dev(<span class="literal">NULL</span>, i2cdev_attach_adapter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unreg_class:</span><br><span class="line">    <span class="comment">// 销毁创建的 class 对象</span></span><br><span class="line">class_destroy(i2c_dev_class);</span><br><span class="line">out_unreg_chrdev:</span><br><span class="line">    <span class="comment">// 注销已注册的字符设备驱动</span></span><br><span class="line">unregister_chrdev_region(MKDEV(I2C_MAJOR, <span class="number">0</span>), I2C_MINORS);</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">// 打印初始化失败的内核日志</span></span><br><span class="line">printk(KERN_ERR <span class="string">&quot;%s: Driver Initialisation failed\n&quot;</span>, __FILE__);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="i2c-dev-adapter"><a href="#i2c-dev-adapter" class="headerlink" title="i2c_dev_adapter()"></a>i2c_dev_adapter()</h3><p><code>i2c_dev_init()</code>函数中最后调用<code>i2cdev_attach_adapter()</code>函数来绑定已存在的i2c适配器到i2c设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2cdev_attach_adapter</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">void</span> *dummy)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_dev</span> *<span class="title">i2c_dev</span>;</span></span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="comment">// 检查设备类型是否为 i2c_adapter_type,如果不是则返回</span></span><br><span class="line"><span class="keyword">if</span> (dev-&gt;type != &amp;i2c_adapter_type)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">adap = to_i2c_adapter(dev);</span><br><span class="line"><span class="comment">// 从 i2c_dev_list 中获取一个空闲的 i2c_dev 结构体</span></span><br><span class="line">i2c_dev = get_free_i2c_dev(adap);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(i2c_dev))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(i2c_dev);</span><br><span class="line"><span class="comment">// 初始化 i2c_dev 结构体中的 cdev 字段,设置文件操作函数为 i2cdev_fops</span></span><br><span class="line">cdev_init(&amp;i2c_dev-&gt;cdev, &amp;i2cdev_fops);</span><br><span class="line">i2c_dev-&gt;cdev.owner = THIS_MODULE;</span><br><span class="line"><span class="comment">// 初始化设备对象 i2c_dev-&gt;dev</span></span><br><span class="line">device_initialize(&amp;i2c_dev-&gt;dev);</span><br><span class="line">    <span class="comment">// 设置设备号为主设备号 I2C_MAJOR 和次设备号 adap-&gt;nr</span></span><br><span class="line">i2c_dev-&gt;dev.devt = MKDEV(I2C_MAJOR, adap-&gt;nr);</span><br><span class="line">i2c_dev-&gt;dev.class = i2c_dev_class;</span><br><span class="line">i2c_dev-&gt;dev.parent = &amp;adap-&gt;dev;</span><br><span class="line">i2c_dev-&gt;dev.release = i2cdev_dev_release;</span><br><span class="line">    <span class="comment">// 设置设备名称为 &quot;i2c-&#123;adap-&gt;nr&#125;&quot;</span></span><br><span class="line">dev_set_name(&amp;i2c_dev-&gt;dev, <span class="string">&quot;i2c-%d&quot;</span>, adap-&gt;nr);</span><br><span class="line"><span class="comment">// 将 i2c_dev 设备添加到设备树中</span></span><br><span class="line">res = cdev_device_add(&amp;i2c_dev-&gt;cdev, &amp;i2c_dev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">// 如果添加失败,则释放 i2c_dev 结构体</span></span><br><span class="line">put_i2c_dev(i2c_dev, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印调试信息,表示适配器 [adap-&gt;name] 已注册为次设备号 adap-&gt;nr</span></span><br><span class="line">pr_debug(<span class="string">&quot;i2c-dev: adapter [%s] registered as minor %d\n&quot;</span>,</span><br><span class="line"> adap-&gt;name, adap-&gt;nr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的作用是在系统总线上发现新的 i2c 适配器时,为其创建对应的字符设备节点。</p><h3 id="struct-file-operations-i2cdev-fops"><a href="#struct-file-operations-i2cdev-fops" class="headerlink" title="struct file_operations i2cdev_fops"></a>struct file_operations i2cdev_fops</h3><p><code>i2c_dev</code> 结构体中的 cdev 字段指定的文件操作集结构体为 <code>i2cdev_fops</code>，具体内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">i2cdev_fops</span> =</span> &#123;</span><br><span class="line">.owner= THIS_MODULE,</span><br><span class="line">.llseek= no_llseek,</span><br><span class="line">.read= i2cdev_read,</span><br><span class="line">.write= i2cdev_write,</span><br><span class="line">.unlocked_ioctl= i2cdev_ioctl,</span><br><span class="line">.compat_ioctl= compat_i2cdev_ioctl,</span><br><span class="line">.open= i2cdev_open,</span><br><span class="line">.release= i2cdev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="i2cdev-open"><a href="#i2cdev-open" class="headerlink" title="i2cdev_open()"></a>i2cdev_open()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2cdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> minor = iminor(inode);<span class="comment">// 获取次设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span><span class="comment">// 声明 i2c_client 和 i2c_adapter 结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adap</span>;</span></span><br><span class="line"><span class="comment">// 根据次设备号获取对应的 i2c_adapter</span></span><br><span class="line">adap = i2c_get_adapter(minor);</span><br><span class="line">    <span class="comment">// 如果没有找到对应的 i2c_adapter，返回 -ENODEV 错误</span></span><br><span class="line"><span class="keyword">if</span> (!adap)</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This creates an anonymous i2c_client, which may later be</span></span><br><span class="line"><span class="comment"> * pointed to some address using I2C_SLAVE or I2C_SLAVE_FORCE.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This client is ** NEVER REGISTERED ** with the driver model</span></span><br><span class="line"><span class="comment"> * or I2C core code!!  It just holds private copies of addressing</span></span><br><span class="line"><span class="comment"> * information and maybe a PEC flag.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">client = kzalloc(<span class="keyword">sizeof</span>(*client), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!client) &#123;<span class="comment">// 如果内存分配失败，释放 i2c_adapter 并返回 -ENOMEM 错误</span></span><br><span class="line">i2c_put_adapter(adap);</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 设置 i2c_client 的名称</span></span><br><span class="line"><span class="built_in">snprintf</span>(client-&gt;name, I2C_NAME_SIZE, <span class="string">&quot;i2c-dev %d&quot;</span>, adap-&gt;nr);</span><br><span class="line"></span><br><span class="line">client-&gt;adapter = adap;<span class="comment">// 将 i2c_adapter 赋值给 i2c_client 的 adapter 字段</span></span><br><span class="line">file-&gt;private_data = client;<span class="comment">// 将 i2c_client 指针保存到 file 的 private_data 字段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="i2cdev-read"><a href="#i2cdev-read" class="headerlink" title="i2cdev_read()"></a>i2cdev_read()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * After opening an instance of this character special file, a file</span></span><br><span class="line"><span class="comment"> * descriptor starts out associated only with an i2c_adapter (and bus).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Using the I2C_RDWR ioctl(), you can then *immediately* issue i2c_msg</span></span><br><span class="line"><span class="comment"> * traffic to any devices on the bus used by that adapter.  That&#x27;s because</span></span><br><span class="line"><span class="comment"> * the i2c_msg vectors embed all the addressing information they need, and</span></span><br><span class="line"><span class="comment"> * are submitted directly to an i2c_adapter.  However, SMBus-only adapters</span></span><br><span class="line"><span class="comment"> * don&#x27;t support that interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * To use read()/write() system calls on that file descriptor, or to use</span></span><br><span class="line"><span class="comment"> * SMBus interfaces (and work with SMBus-only hosts!), you must first issue</span></span><br><span class="line"><span class="comment"> * an I2C_SLAVE (or I2C_SLAVE_FORCE) ioctl.  That configures an anonymous</span></span><br><span class="line"><span class="comment"> * (never registered) i2c_client so it holds the addressing information</span></span><br><span class="line"><span class="comment"> * needed by those system calls and by this SMBus interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">i2cdev_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params"><span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *tmp;<span class="comment">// 声明一个临时缓冲区指针</span></span><br><span class="line"><span class="type">int</span> ret;<span class="comment">// 保存 i2c_master_recv 的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;<span class="comment">// 从 file 的 private_data 字段获取 i2c_client 指针</span></span><br><span class="line"><span class="comment">// 限制最大读取字节数为 8192</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">8192</span>)</span><br><span class="line">count = <span class="number">8192</span>;</span><br><span class="line"><span class="comment">// 分配临时缓冲区</span></span><br><span class="line">tmp = kzalloc(count, GFP_KERNEL);</span><br><span class="line">    <span class="comment">// 如果内存分配失败,返回 -ENOMEM 错误</span></span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="comment">// 打印调试信息</span></span><br><span class="line">pr_debug(<span class="string">&quot;i2c-dev: i2c-%d reading %zu bytes.\n&quot;</span>,</span><br><span class="line">iminor(file_inode(file)), count);</span><br><span class="line"><span class="comment">// 使用 i2c_master_recv 函数从 i2c_client 设备读取数据</span></span><br><span class="line">ret = i2c_master_recv(client, tmp, count);</span><br><span class="line">    <span class="comment">// 如果读取成功</span></span><br><span class="line"><span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(buf, tmp, ret))<span class="comment">// 将读取的数据拷贝到用户空间缓冲区</span></span><br><span class="line">ret = -EFAULT;<span class="comment">// 如果拷贝失败,返回 -EFAULT 错误</span></span><br><span class="line">kfree(tmp);<span class="comment">// 释放临时缓冲区</span></span><br><span class="line"><span class="keyword">return</span> ret;<span class="comment">// 返回实际读取的字节数,或者错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="i2cdev-write"><a href="#i2cdev-write" class="headerlink" title="i2cdev_write()"></a>i2cdev_write()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">i2cdev_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params"><span class="type">size_t</span> count, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;<span class="comment">// 保存 i2c_master_send 的返回值</span></span><br><span class="line"><span class="type">char</span> *tmp;<span class="comment">// 声明一个临时缓冲区指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;<span class="comment">// 从 file 的 private_data 字段获取 i2c_client 指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">8192</span>)<span class="comment">// 限制最大写入字节数为 8192</span></span><br><span class="line">count = <span class="number">8192</span>;</span><br><span class="line"><span class="comment">// 分配一个临时缓冲区,并从用户空间拷贝数据到该缓冲区</span></span><br><span class="line">tmp = memdup_user(buf, count);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(tmp))<span class="comment">// 如果内存拷贝失败,返回错误码</span></span><br><span class="line"><span class="keyword">return</span> PTR_ERR(tmp);</span><br><span class="line"><span class="comment">// 打印调试信息</span></span><br><span class="line">pr_debug(<span class="string">&quot;i2c-dev: i2c-%d writing %zu bytes.\n&quot;</span>,</span><br><span class="line">iminor(file_inode(file)), count);</span><br><span class="line"><span class="comment">// 使用 i2c_master_send 函数将数据写入 i2c_client 设备</span></span><br><span class="line">ret = i2c_master_send(client, tmp, count);</span><br><span class="line">    <span class="comment">// 释放临时缓冲区</span></span><br><span class="line">kfree(tmp);</span><br><span class="line">    <span class="comment">// 返回实际写入的字节数,或者错误码</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="i2cdev-ioctl"><a href="#i2cdev-ioctl" class="headerlink" title="i2cdev_ioctl()"></a>i2cdev_ioctl()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">i2cdev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 file 的 private_data 字段获取 i2c_client 指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="comment">// 声明一个无符号长整型变量,用于保存设备功能</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> funcs;</span><br><span class="line"><span class="comment">// 打印调试信息</span></span><br><span class="line">dev_dbg(&amp;client-&gt;adapter-&gt;dev, <span class="string">&quot;ioctl, cmd=0x%02x, arg=0x%02lx\n&quot;</span>,</span><br><span class="line">cmd, arg);</span><br><span class="line"><span class="comment">// 根据不同的 ioctl 命令进行处理</span></span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> I2C_SLAVE:</span><br><span class="line"><span class="keyword">case</span> I2C_SLAVE_FORCE:</span><br><span class="line">        <span class="comment">// 检查从设备地址是否合法</span></span><br><span class="line"><span class="keyword">if</span> ((arg &gt; <span class="number">0x3ff</span>) ||</span><br><span class="line">    (((client-&gt;flags &amp; I2C_M_TEN) == <span class="number">0</span>) &amp;&amp; arg &gt; <span class="number">0x7f</span>))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="comment">// 如果是 I2C_SLAVE 命令,检查地址是否被占用</span></span><br><span class="line"><span class="keyword">if</span> (cmd == I2C_SLAVE &amp;&amp; i2cdev_check_addr(client-&gt;adapter, arg))</span><br><span class="line"><span class="keyword">return</span> -EBUSY;</span><br><span class="line"><span class="comment">/* REVISIT: address could become busy later */</span></span><br><span class="line">        <span class="comment">// 设置从设备地址</span></span><br><span class="line">client-&gt;addr = arg;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> I2C_TENBIT:</span><br><span class="line"><span class="keyword">if</span> (arg)<span class="comment">// 设置 10 位地址模式</span></span><br><span class="line">client-&gt;flags |= I2C_M_TEN;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">client-&gt;flags &amp;= ~I2C_M_TEN;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> I2C_PEC:<span class="comment">// 设置 PEC 标志</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setting the PEC flag here won&#x27;t affect kernel drivers,</span></span><br><span class="line"><span class="comment"> * which will be using the i2c_client node registered with</span></span><br><span class="line"><span class="comment"> * the driver model core.  Likewise, when that client has</span></span><br><span class="line"><span class="comment"> * the PEC flag already set, the i2c-dev driver won&#x27;t see</span></span><br><span class="line"><span class="comment"> * (or use) this setting.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (arg)</span><br><span class="line">client-&gt;flags |= I2C_CLIENT_PEC;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">client-&gt;flags &amp;= ~I2C_CLIENT_PEC;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> I2C_FUNCS:</span><br><span class="line">funcs = i2c_get_functionality(client-&gt;adapter);<span class="comment">// 获取 i2c 适配器的功能</span></span><br><span class="line"><span class="keyword">return</span> put_user(funcs, (<span class="type">unsigned</span> <span class="type">long</span> __user *)arg);<span class="comment">// 将结果写入用户空间的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> I2C_RDWR: &#123;<span class="comment">// 处理 I2C_RDWR 命令</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> <span class="title">rdwr_arg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> *<span class="title">rdwr_pa</span>;</span></span><br><span class="line"><span class="comment">// 从用户空间拷贝参数结构体</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;rdwr_arg,</span><br><span class="line">   (<span class="keyword">struct</span> i2c_rdwr_ioctl_data __user *)arg,</span><br><span class="line">   <span class="keyword">sizeof</span>(rdwr_arg)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="comment">// 检查参数合法性</span></span><br><span class="line"><span class="keyword">if</span> (!rdwr_arg.msgs || rdwr_arg.nmsgs == <span class="number">0</span>)<span class="comment">// 限制最大消息数为 I2C_RDWR_IOCTL_MAX_MSGS</span></span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Put an arbitrary limit on the number of messages that can</span></span><br><span class="line"><span class="comment"> * be sent at once</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (rdwr_arg.nmsgs &gt; I2C_RDWR_IOCTL_MAX_MSGS)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">rdwr_pa = memdup_user(rdwr_arg.msgs,</span><br><span class="line">      rdwr_arg.nmsgs * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_msg));<span class="comment">// 将用户空间的消息数组复制到内核空间</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(rdwr_pa))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(rdwr_pa);</span><br><span class="line"><span class="comment">// 调用 i2cdev_ioctl_rdwr 函数进行 i2c 读写操作</span></span><br><span class="line"><span class="keyword">return</span> i2cdev_ioctl_rdwr(client, rdwr_arg.nmsgs, rdwr_pa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> I2C_SMBUS: &#123;<span class="comment">// 处理 I2C_SMBUS 命令</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_smbus_ioctl_data</span> <span class="title">data_arg</span>;</span></span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;data_arg,</span><br><span class="line">   (<span class="keyword">struct</span> i2c_smbus_ioctl_data __user *) arg,</span><br><span class="line">   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> i2c_smbus_ioctl_data)))</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line"><span class="keyword">return</span> i2cdev_ioctl_smbus(client, data_arg.read_write,</span><br><span class="line">  data_arg.command,</span><br><span class="line">  data_arg.size,</span><br><span class="line">  data_arg.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> I2C_RETRIES:<span class="comment">// 设置 i2c 适配器的重试次数</span></span><br><span class="line"><span class="keyword">if</span> (arg &gt; INT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">client-&gt;adapter-&gt;retries = arg;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> I2C_TIMEOUT:<span class="comment">// 设置 i2c 适配器的超时时间</span></span><br><span class="line"><span class="keyword">if</span> (arg &gt; INT_MAX)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For historical reasons, user-space sets the timeout</span></span><br><span class="line"><span class="comment"> * value in units of 10 ms.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">// 用户空间设置的单位是 10 ms</span></span><br><span class="line">client-&gt;adapter-&gt;timeout = msecs_to_jiffies(arg * <span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">// 不支持的 ioctl 命令</span></span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span>  returning a fault code here could cause trouble</span></span><br><span class="line"><span class="comment"> * in buggy userspace code.  Some old kernel bugs returned</span></span><br><span class="line"><span class="comment"> * zero in this case, and userspace code might accidentally</span></span><br><span class="line"><span class="comment"> * have depended on that bug.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> -ENOTTY;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="I2C-tools"><a href="#I2C-tools" class="headerlink" title="I2C_tools"></a>I2C_tools</h2><div class="tag link"><a class="link-card" title="I2C tools" href="https://archive.kernel.org/oldwiki/i2c.wiki.kernel.org/index.php/I2C_Tools.html"><div class="left"><img src="https://archive.kernel.org/oldwiki/i2c.wiki.kernel.org/favicon.ico"/></div><div class="right"><p class="text">I2C tools</p><p class="url">https://archive.kernel.org/oldwiki/i2c.wiki.kernel.org/index.php/I2C_Tools.html</p></div></a></div><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make CC=/home/topeet/Linux/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarc</span><br><span class="line">h64-linux-gnu/bin/aarch64-linux-gnu-gcc \</span><br><span class="line">AR=/home/topeet/Linux/linux_sdk/prebuilts/gcc/linux-x86/aarch64/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-lin</span><br><span class="line">ux-gnu/bin/aarch64-linux-gnu-ar \</span><br><span class="line">USE_STATIC_LIB=1</span><br></pre></td></tr></table></figure><p>如果使用的是 ubuntu 或者 Debian 系统只需要使用命令<code>sudo apt install i2c-tools</code>进行安装即可</p><h3 id="i2cdetect"><a href="#i2cdetect" class="headerlink" title="i2cdetect"></a>i2cdetect</h3><p>i2cdetect 可以用来检测和探测 I2C 总线上连接的设备。</p><ul><li><code>i2cdetect -V</code>: <strong>输出版本信息</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359975.png" alt="i2cdetect -V" loading="lazy"></p><ul><li><code>i2cdetect -l</code>:<strong>列出所有的i2c总线</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359917.png" alt="i2cdetect -l" loading="lazy"></p><ul><li><code>i2cdetect -F</code> <strong>查询总线上设备支持的功能集</strong>，例如 <code>i2cdetect -F 1</code> 将列出总线 1 上设备支持的功能</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204359947.png" alt="i2cdetect -F 1" loading="lazy"></p><ul><li><code>i2cdetect -a</code> 扫描总线上 0x00 到 0xFF 范围内的所有 I2C 设备地址。例如: <code>i2cdetect -a -y 1</code>将扫描 I2C1 总线上全部的 I2C 设备地址</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204407477.png" alt="image-20251228201405427" loading="lazy"></p><p>这里的 0x38 就是 FT5X06 触摸芯片的 I2C 设备地址</p><h3 id="i2cdump"><a href="#i2cdump" class="headerlink" title="i2cdump"></a>i2cdump</h3><p>i2cdump 可以读取设备上所有寄存器的值，具体用法如下：</p><ul><li><code>i2cdump -V</code> 查看版本号</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204410361.png" alt="i2cdump -V" loading="lazy"></p><ul><li><code>i2cdump -f -a</code>读取设备寄存器,使用 <code>i2cdump -f -a 1 0x38</code> 命令可以读取 I2C 设备地址为 0x38 的所有寄存<br>器值(从 0x00 到 0xFF)。<ul><li>-f 选项用于强制使用设备地址</li><li>-a 选项则是用于读取整个地址范围。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204410626.png" alt="i2cdump -f -a 1 0x38" loading="lazy"></p><ul><li><code>i2cdump -f -r</code>指定寄存器范围读取，使用 <code>i2cdump -f -r 0x80-0xff 1 0x38</code> 命令可以只读取 I2C 设备地址为0x38 的 0x80 到 0xff 范围内的寄存器值。-r 选项用于指定要读取的寄存器地址范围</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204415130.png" alt="i2cdump -f -r" loading="lazy"></p><h3 id="i2cset"><a href="#i2cset" class="headerlink" title="i2cset"></a>i2cset</h3><p>i2cset 命令用于向 I2C 设备的特定寄存器写入数据。它的用法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cset -f -r 1 0x38 0x80 0x11</span><br></pre></td></tr></table></figure><p>这条命令的意思是:</p><ul><li>强制使用 I2C 总线 1 上的设备地址 0x38</li><li>向该设备的寄存器地址 0x80 写入值 0x11</li></ul><p>写入完成后,该命令会返回一个确认信息,表示写入是否成功。如果写入失败,则会返回一个错误信息。</p><h3 id="i2cget"><a href="#i2cget" class="headerlink" title="i2cget"></a>i2cget</h3><p>i2cget 命令用于从 I2C 设备的指定寄存器中读取数据它的用法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cget -f 1 0x38 0x80</span><br></pre></td></tr></table></figure><p>这条命令的意思是:</p><ul><li>强制使用 I2C 总线 1 上的设备地址 0x38</li><li>从该设备的寄存器地址 0x80 读取数据</li></ul><p>该命令会返回寄存器 0x80 的值。读取成功后,会显示类似 0x11 的十六进制值。如果读取失败,则会返回一个错误信息。</p><h3 id="i2ctransfer"><a href="#i2ctransfer" class="headerlink" title="i2ctransfer"></a>i2ctransfer</h3><p>i2ctransfer 是一个更加强大和灵活的 I2C 操作工具,与之前介绍的 i2cset 和 i2cget 命令相比,它可以在单个命令中完成读写操作。具体用法如下所示：<br><strong>写操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2ctransfer 1 w2@0x38 0x80 0x22</span><br></pre></td></tr></table></figure><ul><li><code>1</code> 表示操作的 I2C 总线编号为 1</li><li><code>w2</code> 表示写入 2 个字节的数据</li><li><code>@0x38</code> 表示设备地址为 0x38</li><li><code>0x80</code> 表示要写入的寄存器地址为 0x80</li><li><code>0x22</code> 表示要写入寄存器的值为 0x22</li></ul><p><strong>读操作</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2ctransfer 1 w1@0x38 0x80 r1</span><br></pre></td></tr></table></figure><ul><li><code>1</code> 表示操作的 I2C 总线编号为 1</li><li><code>w1</code> 表示写入 1 个字节的数据</li><li><code>@0x38</code> 表示设备地址为 0x38</li><li><code>0x80</code> 表示要写入的寄存器地址为 0x80</li><li><code>r1</code> 表示读取 1 个字节的数据</li></ul><h2 id="使用-GPIO-模拟-I2C-驱动"><a href="#使用-GPIO-模拟-I2C-驱动" class="headerlink" title="使用 GPIO 模拟 I2C 驱动"></a>使用 GPIO 模拟 I2C 驱动</h2><p>由于要使用软件 I2C，所以要取消掉在设备树中硬件 I2C1 的使能，要在设备树中把ft5x06和i2c1的status都设置为disabled。</p><p>此时 I2C1 的两个复用引脚 GPIO0 B3、GPIO0 B4 会设置为默认的 GPIO 功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 I2C 总线的时钟线和数据线对应的 GPIO 引脚编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SCL 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_SDA 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个 GPIO 描述符变量,用于保存 SCL 和 SDA 引脚的描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">i2c_scl_desc</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">i2c_sda_desc</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C 起始条件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 SCL 和 SDA 引脚设置为输出模式,并初始化为高电平</span></span><br><span class="line">    <span class="comment">// 这是 I2C 总线的空闲状态</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SDA 引脚设置为低电平,保持 SCL 为高电平</span></span><br><span class="line">    <span class="comment">// 这将产生 I2C 总线的起始条件</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SCL 引脚设置为低电平</span></span><br><span class="line">    <span class="comment">// 起始条件建立完成</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C 停止条件函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 SCL 和 SDA 引脚设置为低电平</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SCL 引脚设置为高电平</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 SDA 引脚设置为高电平</span></span><br><span class="line">    <span class="comment">// 这将产生 I2C 总线的停止条件</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>); <span class="comment">// 延时 1 毫秒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送ACK信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_send_ack</span><span class="params">(<span class="type">int</span> ack)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置SDA线为输出模式</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        <span class="comment">// 发送ACK信号, SDA线拉低</span></span><br><span class="line">        gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送NACK信号, SDA线拉高</span></span><br><span class="line">        gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉高SCL线1ms,然后拉低</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>);</span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收ACK信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_recv_ack</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置SDA线为输入模式</span></span><br><span class="line">    gpiod_direction_input(i2c_sda_desc);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉高SCL线1ms</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取SDA线的电平状态</span></span><br><span class="line">    <span class="keyword">if</span> (gpiod_get_value(i2c_sda_desc)) &#123;</span><br><span class="line">        value = <span class="number">1</span>; <span class="comment">// 接收到NACK信号</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="number">0</span>; <span class="comment">// 接收到ACK信号</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉低SCL线</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置SDA线为输出模式并拉高</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_send_data</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SCL线为输出模式并拉低</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送8位数据</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取当前位的值</span></span><br><span class="line">        value = (data &lt;&lt; i) &amp; <span class="number">0x80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据当前位的值设置SDA线</span></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            gpiod_direction_output(i2c_sda_desc, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拉高SCL线1ms,然后拉低</span></span><br><span class="line">        gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line">        gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_recv_data</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SDA线为输入模式</span></span><br><span class="line">    gpiod_direction_input(i2c_sda_desc);</span><br><span class="line">    mdelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收8位数据</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 拉低SCL线1ms</span></span><br><span class="line">        gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拉高SCL线1ms</span></span><br><span class="line">        gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">        mdelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取SDA线的电平状态</span></span><br><span class="line">        data = gpiod_get_value(i2c_sda_desc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据当前位的值更新接收数据</span></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            temp = (temp &lt;&lt; <span class="number">1</span>) | data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = (temp &lt;&lt; <span class="number">1</span>) &amp; ~data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拉低SCL线</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置SDA线为输出模式并拉高</span></span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 触摸屏写寄存器函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(<span class="type">int</span> addr, <span class="type">int</span> reg, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始 I2C 通信</span></span><br><span class="line">    i2c_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送触摸屏设备地址(写操作)</span></span><br><span class="line">    i2c_send_data(addr &lt;&lt; <span class="number">1</span> | <span class="number">0x00</span>);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send write + addr error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送寄存器地址</span></span><br><span class="line">    i2c_send_data(reg);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send reg error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送要写入的值</span></span><br><span class="line">    i2c_send_data(value);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send value error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">// 结束 I2C 通信</span></span><br><span class="line">    i2c_stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  ft5x06 触摸屏读寄存器函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_read_reg</span><span class="params">(<span class="type">int</span> addr, <span class="type">int</span> reg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ack;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始 I2C 通信</span></span><br><span class="line">    i2c_start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送触摸屏设备地址(写操作)</span></span><br><span class="line">    i2c_send_data(addr &lt;&lt; <span class="number">1</span> | <span class="number">0x00</span>);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send write + addr error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送要读取的寄存器地址</span></span><br><span class="line">    i2c_send_data(reg);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send reg error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新开始 I2C 通信,发送读操作地址</span></span><br><span class="line">    i2c_start();</span><br><span class="line">    i2c_send_data(addr &lt;&lt; <span class="number">1</span> | <span class="number">0x01</span>);</span><br><span class="line">    ack = i2c_recv_ack();</span><br><span class="line">    <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">        printk(<span class="string">&quot;send read + addr error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取寄存器值</span></span><br><span class="line">    data = i2c_recv_data();</span><br><span class="line">    printk(<span class="string">&quot;data is %d\n&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 ACK 以结束读操作</span></span><br><span class="line">    i2c_send_ack(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">// 结束 I2C 通信</span></span><br><span class="line">    i2c_stop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 GPIO 编号转换为 GPIO 描述符</span></span><br><span class="line">    i2c_scl_desc = gpio_to_desc(I2C_SCL);</span><br><span class="line">    <span class="keyword">if</span> (i2c_scl_desc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpio_to_desc error for SCL pin\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i2c_sda_desc = gpio_to_desc(I2C_SDA);</span><br><span class="line">    <span class="keyword">if</span> (i2c_sda_desc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;gpio_to_desc error for SDA pin\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 GPIO 引脚设置为输出模式,并初始化为高电平</span></span><br><span class="line">    <span class="comment">// 这是 I2C 总线的空闲状态</span></span><br><span class="line">    gpiod_direction_output(i2c_scl_desc, <span class="number">1</span>);</span><br><span class="line">    gpiod_direction_output(i2c_sda_desc, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">ft5x06_write_reg(<span class="number">0x38</span>,<span class="number">0x80</span>,<span class="number">0x33</span>);</span><br><span class="line">ft5x06_read_reg(<span class="number">0x38</span>,<span class="number">0x80</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放 GPIO 描述符</span></span><br><span class="line">    gpiod_put(i2c_scl_desc);</span><br><span class="line">    gpiod_put(i2c_sda_desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册驱动初始化和退出函数</span></span><br><span class="line">module_init(ft5x06_driver_init);</span><br><span class="line">module_exit(ft5x06_driver_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="使用Linux默认的模拟I2C程序"><a href="#使用Linux默认的模拟I2C程序" class="headerlink" title="使用Linux默认的模拟I2C程序"></a>使用Linux默认的模拟I2C程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line">make rockchip_linux_defconfig</span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line">&gt; Device Drivers</span><br><span class="line">&gt; I2C support</span><br><span class="line">&gt; I2C Hardware Bus support</span><br><span class="line">&lt;*&gt; GPIO-based bitbanging I2C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> .config <span class="built_in">arch</span>/arm64/configs/rockchip_linux_defconfig</span><br></pre></td></tr></table></figure><p>设备树修改</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">i2c6:</span><span class="title class_">i2c6@gpio</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;i2c-gpio&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line"><span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpi00</span> RK PB4 GPIO ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="params">&lt;<span class="variable">&amp;gpi00</span> RK PB3 GPIO ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">i2<span class="attr">c-gpio,delay-us</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">5</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p>对 I2C6 节点进行追加，最佳 FT5X06 触摸芯片相关的内容，添加内容如下所示：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;i2c6</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol">myft5x06:</span> <span class="title class_">my-ft5x06@38</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;my-ft5x06&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x38</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，由于之前编写的设备树节点名也叫 myft5x06，会产生命名冲突，所以需要将之前编写的 myft5x06 设备树节点注释掉</p></blockquote><p>编写驱动程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存 ft5x06 设备的 i2c 客户端对象指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">ft5x06_client</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 ft5x06 设备寄存器的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_read_reg</span><span class="params">(u8 reg_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 data;</span><br><span class="line">    <span class="comment">// 定义两个 i2c_msg 结构体,分别表示写操作和读操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[2] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr, <span class="comment">// 设备地址</span></span><br><span class="line">            .flags = <span class="number">0</span>,        <span class="comment">// 写操作</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(reg_addr),</span><br><span class="line">            .buf = &amp;reg_addr,  <span class="comment">// 写入要读取的寄存器地址</span></span><br><span class="line">        &#125;,</span><br><span class="line">        [<span class="number">1</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr,</span><br><span class="line">            .flags = I2C_M_RD, <span class="comment">// 读操作</span></span><br><span class="line">            .len = <span class="keyword">sizeof</span>(data),</span><br><span class="line">            .buf = &amp;data,      <span class="comment">// 读取到的数据存储位置</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 i2c_transfer 函数进行 i2c 总线读取操作</span></span><br><span class="line">   <span class="comment">// 如果读取失败,返回 -EIO 错误码</span></span><br><span class="line">   <span class="keyword">if</span> (i2c_transfer(ft5x06_client-&gt;adapter, msgs, ARRAY_SIZE(msgs)) != ARRAY_SIZE(msgs))&#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 返回读取到的寄存器值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 ft5x06 设备写入寄存器的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(u8 reg_addr, u8 *data, u16 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 buff[<span class="number">256</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[] =</span> &#123;</span><br><span class="line">        [<span class="number">0</span>] = &#123;</span><br><span class="line">            .addr = ft5x06_client-&gt;addr, <span class="comment">// 设备地址</span></span><br><span class="line">            .flags = <span class="number">0</span>,        <span class="comment">// 写操作</span></span><br><span class="line">            .len = len + <span class="number">1</span>,    <span class="comment">// 数据长度 + 寄存器地址长度</span></span><br><span class="line">            .buf = buff,       <span class="comment">// 数据缓冲区</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    buff[<span class="number">0</span>] = reg_addr;       <span class="comment">// 写入寄存器地址</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;buff[<span class="number">1</span>], data, len); <span class="comment">// 写入数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 i2c_transfer 函数进行 i2c 总线写入操作</span></span><br><span class="line">    <span class="comment">// 如果写入失败,直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (i2c_transfer(ft5x06_client-&gt;adapter, msgs, ARRAY_SIZE(msgs)) != ARRAY_SIZE(msgs)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 设备的探测函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    printk(<span class="string">&quot;This is ft5x06 probe\n&quot;</span>);</span><br><span class="line">    ft5x06_client = client; <span class="comment">// 保存 i2c 客户端对象指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写寄存器</span></span><br><span class="line">    ft5x06_write_reg(<span class="number">0x80</span>, &amp;(u8)&#123;<span class="number">0x4b</span>&#125;, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读寄存器</span></span><br><span class="line">    value = ft5x06_read_reg(<span class="number">0x80</span>);</span><br><span class="line">    printk(<span class="string">&quot;reg 0x80 is %x\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ft5x06 设备的移除函数</span></span><br><span class="line"><span class="comment">// 参数 client 是 i2c 客户端对象指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ft5x06_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_device_id 结构体数组,用于标识 ft5x06 设备</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ft5x06_id</span>[] =</span> &#123;</span><br><span class="line">    &#123; <span class="string">&quot;my-ft5x06&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 i2c_driver 结构体,描述 ft5x06 设备驱动</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = <span class="string">&quot;my-ft5x06&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = ft5x06_probe,</span><br><span class="line">    .remove = ft5x06_remove,</span><br><span class="line">    .id_table = ft5x06_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ft5x06_driver_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 注册 I2C 设备驱动</span></span><br><span class="line">    ret = i2c_add_driver(&amp;ft5x06_driver);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(<span class="string">&quot;i2c_add_driver is error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ft5x06_driver_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注销 I2C 设备驱动</span></span><br><span class="line">    i2c_del_driver(&amp;ft5x06_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ft5x06_driver_init);</span><br><span class="line">module_exit(ft5x06_driver_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="SMBus总线"><a href="#SMBus总线" class="headerlink" title="SMBus总线"></a>SMBus总线</h2><p>SMBus(System Management Bus)是由 Intel 在 1995 年发布的一种基于 I2C 总线的串行总线协议。它最初被设计用于在电脑系统内部连接智能电池和其他系统管理设备。</p><p>SMBus 与 I2C 总线非常相似,它们都采用两线式串行通信。SMBus 使用 SMBDAT 和 SMBCLK 作为数据线和时钟线,与 I2C 的 SDA 和 SCL 很相似，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251228204416226.png" alt="SMBus" loading="lazy"></p><h3 id="SMBus特点"><a href="#SMBus特点" class="headerlink" title="SMBus特点"></a>SMBus特点</h3><p>SMBus 的主要特点如下所示：</p><p><strong>电气特性</strong>:</p><ul><li>采用开漏输出,需要外部上拉电阻</li><li>电压范围:0V 到 5.5V</li><li>最大时钟频率:100kHz</li></ul><p><strong>通信协议:</strong></p><ul><li>主从式通信,一个主设备控制多个从设备</li><li>地址空间:7 位或 10 位</li><li>支持读&#x2F;写操作</li><li>支持块传输和字节传输</li><li>支持多种事务类型,如快速命令、写字节、读字节等</li></ul><p><strong>功能特性:</strong></p><ul><li>简单、低成本、低功耗</li><li>面向系统管理应用,如电源管理、温度监控等</li><li>与 I2C 高度兼容,可以复用 I2C 硬件</li></ul><p><strong>时序特性</strong>:</p><ul><li>Start 和 Stop 条件与 I2C 相同</li><li>地址和数据传输时序也与 I2C 相似</li><li>但有一些特殊的时序,如快速命令、块传输等</li></ul><h3 id="SMBus-和-I2C-的区别"><a href="#SMBus-和-I2C-的区别" class="headerlink" title="SMBus 和 I2C 的区别"></a>SMBus 和 I2C 的区别</h3><ul><li><strong>速度范围</strong>:<br>I2C 支持从 10kHz 到 3.4MHz 不等的速度范围,覆盖了更广泛的应用场景。SMBus 则只支持 10kHz 到 100kHz 的速度范围,主要面向低速的系统管理应用场景。</li><li><strong>ACK 应答:</strong><br>I2C 不强制从机发送 ACK 应答,这样可以提高灵活性。但如果从机没有应答,主机可能会产生错误。SMBus 要求从机必须发送 ACK 应答,这可以确保主机能够检测到从机是否存在,避免误操作。</li><li><strong>时间限制</strong>:<br>SMBus 规定,从机不能将 SCL 线拉低超过 35ms,否则会复位正在进行的通信。I2C 没有这样的时间限制,主机和从机可以自主控制 SCL 线的状态。</li><li><strong>其他区别:</strong><br>SMBus 有一些专门为系统管理设计的命令和事务类型,如快速命令、块传输等。SMBus 的地址空间相比 I2C 更小,只支持 7 位或 10 位地址。SMBus 在电气特性上也有一些差异,如电压范围等</li></ul><h3 id="SMBus-总线软件实现"><a href="#SMBus-总线软件实现" class="headerlink" title="SMBus 总线软件实现"></a>SMBus 总线软件实现</h3><p>在 Linux 内核中,<strong>I2C 和 SMBus 是共用的总线架构</strong>,<strong>通过 i2c-core 子系统进行管理和抽象</strong>，在 <code>i2c.h</code> 头文件中定义了<code> i2c_algorithm</code> 结构体中，具体内容如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct i2c_algorithm - represent I2C transfer method</span></span><br><span class="line"><span class="comment"> * @master_xfer: Issue a set of i2c transactions to the given I2C adapter</span></span><br><span class="line"><span class="comment"> *   defined by the msgs array, with num messages available to transfer via</span></span><br><span class="line"><span class="comment"> *   the adapter specified by adap.</span></span><br><span class="line"><span class="comment"> * @master_xfer_atomic: same as @master_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer: Issue smbus transactions to the given I2C adapter. If this</span></span><br><span class="line"><span class="comment"> *   is not present, then the bus layer will try and convert the SMBus calls</span></span><br><span class="line"><span class="comment"> *   into I2C transfers instead.</span></span><br><span class="line"><span class="comment"> * @smbus_xfer_atomic: same as @smbus_xfer. Yet, only using atomic context</span></span><br><span class="line"><span class="comment"> *   so e.g. PMICs can be accessed very late before shutdown. Optional.</span></span><br><span class="line"><span class="comment"> * @functionality: Return the flags that this algorithm/adapter pair supports</span></span><br><span class="line"><span class="comment"> *   from the ``I2C_FUNC_*`` flags.</span></span><br><span class="line"><span class="comment"> * @reg_slave: Register given client to I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> * @unreg_slave: Unregister given client from I2C slave mode of this adapter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following structs are for those who like to implement new bus drivers:</span></span><br><span class="line"><span class="comment"> * i2c_algorithm is the interface to a class of hardware solutions which can</span></span><br><span class="line"><span class="comment"> * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584</span></span><br><span class="line"><span class="comment"> * to name two of the most common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return codes from the ``master_xfer&#123;_atomic&#125;`` fields should indicate the</span></span><br><span class="line"><span class="comment"> * type of error code that occurred during the transfer, as documented in the</span></span><br><span class="line"><span class="comment"> * Kernel Documentation file Documentation/i2c/fault-codes.rst.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment"> * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment"> * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment"> * using common I2C messages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment"> * processed, or a negative value on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">   <span class="type">int</span> num);</span><br><span class="line"><span class="type">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line"><span class="type">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"><span class="type">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line"> u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">u32 (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line"><span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 smbus_xfer 函数用于实现 SMBus 特有的一些操作,如快速命令、写字节、读字节等。</p><p><strong>当 I2C 控制器工作在 SMBus 模式时,会通过 smbus_xfer 函数来执行 SMBus 的特殊事务。</strong></p><h3 id="SMBus-总线-API-函数"><a href="#SMBus-总线-API-函数" class="headerlink" title="SMBus 总线 API 函数"></a>SMBus 总线 API 函数</h3><ol><li><strong><code>i2c_smbus_read_byte(const struct i2c_client *client)</code></strong><ul><li>发送 <strong>SMBus Read Byte</strong> 协议。</li><li>不发送寄存器地址，直接读取设备当前指向的数据字节。</li><li>适用于：设备支持自动递增地址（如某些 EEPROM 连续读），或之前已通过其他方式设置好地址指针。</li><li>⚠️ 大多数现代 I2C 设备<strong>不支持</strong>这种无地址读取，因此<strong>较少使用</strong>。</li></ul></li><li><strong><code>i2c_smbus_write_byte(const struct i2c_client *client, u8 value)</code></strong><ul><li>发送 <strong>SMBus Send Byte</strong> 协议。</li><li>仅发送一个字节（<code>value</code> 作为命令），<strong>不带数据阶段</strong>。</li><li>注意：这里的 <code>value</code> 被当作 <strong>command</strong>，而不是写入的数据！</li><li>常用于触发设备动作（如复位、启动转换），<strong>不是写寄存器值</strong>。</li><li>❗容易误解！若想“向寄存器写值”，应使用 <code>i2c_smbus_write_byte_data</code>。</li></ul></li><li><strong><code>i2c_smbus_read_byte_data(const struct i2c_client *client, u8 command)</code></strong><ul><li>发送 <strong>SMBus Read Byte Data</strong> 协议。</li><li>先发送 <code>command</code>（寄存器地址），再读回 1 字节数据。</li><li>✅ <strong>最常用的读寄存器方式</strong>。</li></ul></li><li><strong><code>i2c_smbus_write_byte_data(const struct i2c_client *client, u8 command, u8 value)</code></strong><ul><li>发送 <strong>SMBus Write Byte Data</strong> 协议。</li><li>发送 <code>command</code>（寄存器地址） + <code>value</code>（要写入的数据）。</li><li>✅ <strong>最常用的写寄存器方式</strong>。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">Linux I2C</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>Hexo butterfly主题实现MacOS液态玻璃效果</title>
    <link href="https://even629.com/posts/2512270/"/>
    <id>https://even629.com/posts/2512270/</id>
    <published>2025-12-27T05:25:13.000Z</published>
    <updated>2025-12-27T05:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>在Codepen上看到的，稍微改了一下，效果可以看本站aside的card或nav。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>主要思路是利用多层叠加，共四层</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;liquidGlass-wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;liquidGlass-effect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="comment">&lt;!-- 模糊 + 扭曲 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;liquidGlass-tint&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>     <span class="comment">&lt;!-- 半透明白色蒙层 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;liquidGlass-shine&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    <span class="comment">&lt;!-- 内发光高光 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;liquidGlass-box&quot;</span>&gt;</span>            <span class="comment">&lt;!-- 实际内容容器 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="liquidGlass-wrapper"><a href="#liquidGlass-wrapper" class="headerlink" title="liquidGlass-wrapper"></a>liquidGlass-wrapper</h2><blockquote><p>容器壳</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.liquidGlass-wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">6px</span> <span class="number">6px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.4s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.175</span>, <span class="number">0.885</span>, <span class="number">0.32</span>, <span class="number">2.2</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">background</span>: none <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">backdrop-filter</span>: none <span class="meta">!important</span>;</span><br><span class="line">  -webkit-<span class="attribute">backdrop-filter</span>: none <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：最外层容器，负责整体阴影和动画过渡。</li><li><strong>关键点</strong>：<ul><li><code>background: none</code> 和 <code>backdrop-filter: none</code> 是为了不让它自己产生模糊，把模糊交给内部 <code>.liquidGlass-effect</code>。</li><li>阴影模拟玻璃的立体感。</li><li><code>transition</code> 让 hover 时的圆角和 padding 变化更流畅。</li></ul></li></ul><hr><h2 id="liquidGlass-effect"><a href="#liquidGlass-effect" class="headerlink" title="liquidGlass-effect"></a>liquidGlass-effect</h2><blockquote><p>核心“液态”模糊层</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.liquidGlass-effect</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">inset</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">backdrop-filter</span>: <span class="built_in">blur</span>(<span class="number">3px</span>);</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">url</span>(<span class="string">#glass-distortion</span>);</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">isolation</span>: isolate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>backdrop-filter: blur(3px)</code></strong><br> 对背景内容（如网页其他部分）做模糊处理 → 这是“毛玻璃”的基础。</li><li><strong><code>filter: url(#glass-distortion)</code></strong>⭐ <strong>这是“液态”感的关键！<strong>它引用了一个 SVG 滤镜（<code>#glass-distortion</code>），通常定义在页面 <code>&lt;svg&gt;</code> 中，用于对图像施加</strong>扭曲、波纹、液态流动</strong>等效果。</li><li><strong><code>isolation: isolate</code></strong> 确保该层创建新的层叠上下文，避免滤镜影响其他元素。</li></ul><h3 id="glass-distortion"><a href="#glass-distortion" class="headerlink" title="glass-distortion"></a>glass-distortion</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;glass-distortion&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">x</span>=<span class="string">&quot;0%&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">y</span>=<span class="string">&quot;0%&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">filterUnits</span>=<span class="string">&quot;objectBoundingBox&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">feTurbulence</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;fractalNoise&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">baseFrequency</span>=<span class="string">&quot;0.01 0.01&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">numOctaves</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">seed</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">result</span>=<span class="string">&quot;turbulence&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Seeds: 14, 17,  --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">feComponentTransfer</span> <span class="attr">in</span>=<span class="string">&quot;turbulence&quot;</span> <span class="attr">result</span>=<span class="string">&quot;mapped&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">feFuncR</span> <span class="attr">type</span>=<span class="string">&quot;gamma&quot;</span> <span class="attr">amplitude</span>=<span class="string">&quot;1&quot;</span> <span class="attr">exponent</span>=<span class="string">&quot;10&quot;</span> <span class="attr">offset</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">feFuncG</span> <span class="attr">type</span>=<span class="string">&quot;gamma&quot;</span> <span class="attr">amplitude</span>=<span class="string">&quot;0&quot;</span> <span class="attr">exponent</span>=<span class="string">&quot;1&quot;</span> <span class="attr">offset</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">feFuncB</span> <span class="attr">type</span>=<span class="string">&quot;gamma&quot;</span> <span class="attr">amplitude</span>=<span class="string">&quot;0&quot;</span> <span class="attr">exponent</span>=<span class="string">&quot;1&quot;</span> <span class="attr">offset</span>=<span class="string">&quot;0.5&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">feComponentTransfer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">feGaussianBlur</span> <span class="attr">in</span>=<span class="string">&quot;turbulence&quot;</span> <span class="attr">stdDeviation</span>=<span class="string">&quot;3&quot;</span> <span class="attr">result</span>=<span class="string">&quot;softMap&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">feSpecularLighting</span></span></span><br><span class="line"><span class="tag">    <span class="attr">in</span>=<span class="string">&quot;softMap&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">surfaceScale</span>=<span class="string">&quot;5&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">specularConstant</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">specularExponent</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">lighting-color</span>=<span class="string">&quot;white&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">result</span>=<span class="string">&quot;specLight&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fePointLight</span> <span class="attr">x</span>=<span class="string">&quot;-200&quot;</span> <span class="attr">y</span>=<span class="string">&quot;-200&quot;</span> <span class="attr">z</span>=<span class="string">&quot;300&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">feSpecularLighting</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">feComposite</span></span></span><br><span class="line"><span class="tag">    <span class="attr">in</span>=<span class="string">&quot;specLight&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">operator</span>=<span class="string">&quot;arithmetic&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">k1</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">k2</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">k3</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">k4</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">result</span>=<span class="string">&quot;litImage&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">feDisplacementMap</span></span></span><br><span class="line"><span class="tag">    <span class="attr">in</span>=<span class="string">&quot;SourceGraphic&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">in2</span>=<span class="string">&quot;softMap&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">scale</span>=<span class="string">&quot;150&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xChannelSelector</span>=<span class="string">&quot;R&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">yChannelSelector</span>=<span class="string">&quot;G&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="liquidGlass-tint"><a href="#liquidGlass-tint" class="headerlink" title="liquidGlass-tint"></a>liquidGlass-tint</h2><blockquote><p>色调蒙层</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.liquidGlass-tint</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">inset</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.25</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在模糊层之上叠加一层<strong>半透明白色</strong>（也可改为浅蓝、浅灰等）。</li><li>模拟真实玻璃的“反光底色”，让文字&#x2F;内容更易读。</li><li><code>z-index: 1</code> 确保它在 effect 之上、shine 之下。</li></ul><hr><h2 id="liquidGlass-shine"><a href="#liquidGlass-shine" class="headerlink" title="liquidGlass-shine"></a>liquidGlass-shine</h2><blockquote><p>高光层</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.liquidGlass-shine</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">inset</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">2px</span> <span class="number">2px</span> <span class="number">1px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>),</span><br><span class="line">    inset -<span class="number">1px</span> -<span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <strong>内阴影（inset box-shadow）</strong> 模拟玻璃边缘的<strong>高光和微反光</strong>。</li><li>上右亮（+2px 白光），下左稍暗（-1px 白光）→ 营造光照方向感。</li><li><code>z-index: 2</code> 放在最上层（但低于内容）。</li></ul><hr><h2 id="liquidGlass-box"><a href="#liquidGlass-box" class="headerlink" title="liquidGlass-box"></a>liquidGlass-box</h2><blockquote><p>内容层</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-box</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">box-shadow</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>真正放内容的地方（如头像、文字）。</li><li><code>z-index: 3</code> 确保内容在所有玻璃效果层之上，清晰可见。</li><li><code>position: relative</code> 使其脱离普通流，但仍在 wrapper 内。</li></ul><hr><h2 id="交互效果（Hover-动态）"><a href="#交互效果（Hover-动态）" class="headerlink" title="交互效果（Hover 动态）"></a>交互效果（Hover 动态）</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* OTHER STYLES */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span>,</span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.liquidGlass-box</span>) &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.4rem</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">var</span>(--glass-border-radius) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.6rem</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">calc</span>(<span class="built_in">var</span>(--glass-border-radius) + <span class="number">1em</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.liquidGlass-box</span>)<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">calc</span>(<span class="built_in">var</span>(--glass-border-radius) + <span class="number">1em</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>悬停时</strong>：<ul><li>圆角变大（<code>+1em</code>）→ 模拟“液体膨胀”或“柔软变形”；</li><li>内边距增大 → 整体“呼吸感”；</li><li>所有非内容层同步圆角变化，保持视觉一致。</li></ul></li></ul><h1 id="应用到butterfly的例子"><a href="#应用到butterfly的例子" class="headerlink" title="应用到butterfly的例子"></a>应用到butterfly的例子</h1><p>下面以<code>card_author</code>为例，即显示作者信息的卡片。</p><h2 id="card-author-pug"><a href="#card-author-pug" class="headerlink" title="card_author.pug"></a>card_author.pug</h2><p>修改<code>themes\butterfly\layout\includes\widget\card_author.pug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if theme.aside.card_author.enable</span><br><span class="line">  .card-widget.card-info.text-center.liquidGlass-wrapper</span><br><span class="line">    .liquidGlass-effect</span><br><span class="line">    .liquidGlass-tint</span><br><span class="line">    .liquidGlass-shine</span><br><span class="line">    .liquidGlass-box</span><br><span class="line">      div.card-info-avatar</span><br><span class="line">        .avatar-img</span><br><span class="line">          img(</span><br><span class="line">            src=url_for(theme.avatar.img)</span><br><span class="line">            onerror=&quot;this.onerror=null;this.src=&#x27;&quot; + url_for(theme.error_img.flink) + &quot;&#x27;&quot;</span><br><span class="line">            alt=&quot;avatar&quot;</span><br><span class="line">          )</span><br></pre></td></tr></table></figure><h2 id="liquid-glass-css"><a href="#liquid-glass-css" class="headerlink" title="liquid_glass.css"></a>liquid_glass.css</h2><p>创建自定义css文件<code>themes\butterfly\source\css\liquid_glass.css</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LIQUID GLASS STYLES */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attr">--glass-border-radius</span>: <span class="number">1.2rem</span>; <span class="comment">/* 默认圆角 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">6px</span> <span class="number">6px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.4s</span> <span class="built_in">cubic-bezier</span>(<span class="number">0.175</span>, <span class="number">0.885</span>, <span class="number">0.32</span>, <span class="number">2.2</span>) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">background</span>: none <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">backdrop-filter</span>: none <span class="meta">!important</span>;</span><br><span class="line">  -webkit-<span class="attribute">backdrop-filter</span>: none <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-effect</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">inset</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">backdrop-filter</span>: <span class="built_in">blur</span>(<span class="number">3px</span>);</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">url</span>(<span class="string">#glass-distortion</span>);</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">isolation</span>: isolate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-tint</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">inset</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.25</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-shine</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">inset</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">box-shadow</span>: inset <span class="number">2px</span> <span class="number">2px</span> <span class="number">1px</span> <span class="number">0</span> <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>),</span><br><span class="line">    inset -<span class="number">1px</span> -<span class="number">1px</span> <span class="number">1px</span> <span class="number">1px</span> <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-box</span> &#123;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">box-shadow</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* OTHER STYLES */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span>,</span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.liquidGlass-box</span>) &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.4rem</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">var</span>(--glass-border-radius) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.6rem</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">calc</span>(<span class="built_in">var</span>(--glass-border-radius) + <span class="number">1em</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.liquidGlass-wrapper</span> &gt; <span class="selector-tag">div</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.liquidGlass-box</span>)<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="built_in">calc</span>(<span class="built_in">var</span>(--glass-border-radius) + <span class="number">1em</span>) <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h2><p>主题的<code>_config.yaml</code>的inject中引入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/liquid_glass.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line"><span class="string">      &lt;svg style=&quot;display: none&quot;&gt;</span></span><br><span class="line"><span class="string">      &lt;filter</span></span><br><span class="line"><span class="string">        id=&quot;glass-distortion&quot;</span></span><br><span class="line"><span class="string">        x=&quot;0%&quot;</span></span><br><span class="line"><span class="string">        y=&quot;0%&quot;</span></span><br><span class="line"><span class="string">        width=&quot;100%&quot;</span></span><br><span class="line"><span class="string">        height=&quot;100%&quot;</span></span><br><span class="line"><span class="string">        filterUnits=&quot;objectBoundingBox&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">        &lt;feTurbulence</span></span><br><span class="line"><span class="string">          type=&quot;fractalNoise&quot;</span></span><br><span class="line"><span class="string">          baseFrequency=&quot;0.01 0.01&quot;</span></span><br><span class="line"><span class="string">          numOctaves=&quot;1&quot;</span></span><br><span class="line"><span class="string">          seed=&quot;5&quot;</span></span><br><span class="line"><span class="string">          result=&quot;turbulence&quot;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">        &lt;!-- Seeds: 14, 17,  --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">        <span class="string">&lt;feComponentTransfer</span> <span class="string">in=&quot;turbulence&quot;</span> <span class="string">result=&quot;mapped&quot;&gt;</span></span><br><span class="line">          <span class="string">&lt;feFuncR</span> <span class="string">type=&quot;gamma&quot;</span> <span class="string">amplitude=&quot;1&quot;</span> <span class="string">exponent=&quot;10&quot;</span> <span class="string">offset=&quot;0.5&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">          <span class="string">&lt;feFuncG</span> <span class="string">type=&quot;gamma&quot;</span> <span class="string">amplitude=&quot;0&quot;</span> <span class="string">exponent=&quot;1&quot;</span> <span class="string">offset=&quot;0&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">          <span class="string">&lt;feFuncB</span> <span class="string">type=&quot;gamma&quot;</span> <span class="string">amplitude=&quot;0&quot;</span> <span class="string">exponent=&quot;1&quot;</span> <span class="string">offset=&quot;0.5&quot;</span> <span class="string">/&gt;</span></span><br><span class="line">        <span class="string">&lt;/feComponentTransfer&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;feGaussianBlur</span> <span class="string">in=&quot;turbulence&quot;</span> <span class="string">stdDeviation=&quot;3&quot;</span> <span class="string">result=&quot;softMap&quot;</span> <span class="string">/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;feSpecularLighting</span></span><br><span class="line">          <span class="string">in=&quot;softMap&quot;</span></span><br><span class="line">          <span class="string">surfaceScale=&quot;5&quot;</span></span><br><span class="line">          <span class="string">specularConstant=&quot;1&quot;</span></span><br><span class="line">          <span class="string">specularExponent=&quot;100&quot;</span></span><br><span class="line">          <span class="string">lighting-color=&quot;white&quot;</span></span><br><span class="line">          <span class="string">result=&quot;specLight&quot;</span></span><br><span class="line">        <span class="string">&gt;</span></span><br><span class="line"><span class="string">          &lt;fePointLight x=&quot;-200&quot; y=&quot;-200&quot; z=&quot;300&quot; /&gt;</span></span><br><span class="line"><span class="string"></span>        <span class="string">&lt;/feSpecularLighting&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;feComposite</span></span><br><span class="line">          <span class="string">in=&quot;specLight&quot;</span></span><br><span class="line">          <span class="string">operator=&quot;arithmetic&quot;</span></span><br><span class="line">          <span class="string">k1=&quot;0&quot;</span></span><br><span class="line">          <span class="string">k2=&quot;1&quot;</span></span><br><span class="line">          <span class="string">k3=&quot;1&quot;</span></span><br><span class="line">          <span class="string">k4=&quot;0&quot;</span></span><br><span class="line">          <span class="string">result=&quot;litImage&quot;</span></span><br><span class="line">        <span class="string">/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;feDisplacementMap</span></span><br><span class="line">          <span class="string">in=&quot;SourceGraphic&quot;</span></span><br><span class="line">          <span class="string">in2=&quot;softMap&quot;</span></span><br><span class="line">          <span class="string">scale=&quot;150&quot;</span></span><br><span class="line">          <span class="string">xChannelSelector=&quot;R&quot;</span></span><br><span class="line">          <span class="string">yChannelSelector=&quot;G&quot;</span></span><br><span class="line">        <span class="string">/&gt;</span></span><br><span class="line">        <span class="string">&lt;/filter&gt;</span></span><br><span class="line">      <span class="string">&lt;/svg&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://codepen.io/lucasromerodb/pen/vEOWpYM">Liquid Glass Effect macOS (button background) </a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://juejin.cn/post/7514618352829448244">HTML + CSS 实现 Liquid Glass 液态玻璃效果</a></div>]]></content>
    
    
    <summary type="html">hexo butterfly 上实现MacOS液态玻璃效果</summary>
    
    
    
    <category term="hexo" scheme="https://even629.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://even629.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>PMOS和NMOS</title>
    <link href="https://even629.com/posts/2512263/"/>
    <id>https://even629.com/posts/2512263/</id>
    <published>2025-12-26T08:25:13.000Z</published>
    <updated>2025-12-26T08:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-26</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><h2 id="PMOS-与-NMOS"><a href="#PMOS-与-NMOS" class="headerlink" title="PMOS 与 NMOS"></a>PMOS 与 NMOS</h2><ul><li><p><strong>S: Source 源级</strong></p></li><li><p><strong>D: Drain   漏极</strong></p></li><li><p><strong>G: Gate     栅极</strong></p></li><li><p><strong>NMOS</strong>：用<strong>正电压</strong>控制导通，电流从<strong>漏极（D）→源极（S）</strong>，适合<strong>低边开关</strong>。</p></li><li><p><strong>PMOS</strong>：用<strong>负电压</strong>控制导通，电流从<strong>源极（S）→漏极（D）</strong>，适合<strong>高边开关</strong>。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/B68BA58240AACE9D805F6CD54DCD1DC9.jpg" alt="NMOS管" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/2C840CC504D1205278CB5DA4E33DD8D2.jpg" alt="NMOS管" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/wKgZO2fROIaAOEqeAABoCh39dwE236.jpg" alt="d1ea90de-fe61-11ef-9310-92fbcf53809c.jpg" loading="lazy"></p><p>上图为PMOS的示意图，衬底为N型半导体，源极 (Source) 和漏极 (Drain)掺杂了P型杂质 (如硼B)，形成P+区。N型硅多电子</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/wKgZPGfROIaAOM9tAAHVloCmPeM927.png" alt="d1ee6380-fe61-11ef-9310-92fbcf53809c.png" loading="lazy"></p><p>上图为NMOS的示意图，衬底为P型硅，衬底源极 (Source) 和漏极 (Drain)掺杂了N型杂质 (如磷P)，形成 N+区。P型硅多空穴。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.elecfans.com/d/6484053.html">PMOS与NMOS的工作原理</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://blog.csdn.net/he30837993/article/details/149138870">NMOS 和 PMOS 的区别（通俗易懂）</a></div><p>参考B站视频：</p><div class="bilibili"><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1055906685&bvid=BV12n4y1X7Cd&cid=1601023905&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><div>]]></content>
    
    
    <summary type="html">PMOS和NMOS</summary>
    
    
    
    <category term="Hardware" scheme="https://even629.com/categories/Hardware/"/>
    
    
    <category term="Hardware" scheme="https://even629.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title>Open Drain和Open Collector</title>
    <link href="https://even629.com/posts/2512262/"/>
    <id>https://even629.com/posts/2512262/</id>
    <published>2025-12-26T07:25:13.000Z</published>
    <updated>2025-12-26T07:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-26</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>TODO</p>]]></content>
    
    
    <summary type="html">Open Drain和Open Collector详解</summary>
    
    
    
    <category term="Hardware" scheme="https://even629.com/categories/Hardware/"/>
    
    
    <category term="Hardware" scheme="https://even629.com/tags/Hardware/"/>
    
  </entry>
  
  <entry>
    <title>Soc启动流程</title>
    <link href="https://even629.com/posts/2512261/"/>
    <id>https://even629.com/posts/2512261/</id>
    <published>2025-12-26T07:25:13.000Z</published>
    <updated>2025-12-26T06:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-26</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="BootROM"><a href="#BootROM" class="headerlink" title="BootROM"></a>BootROM</h1><p>通常来说，SoC厂家都会做一个ROM在SoC的内部，这个ROM很小，里面固化了上电启动的代码（一经固化，永不能改，是芯片做的时候，做进去的）；这部分代码呢，我们管它叫做BootROM，也叫作<strong>一级启动程序</strong>。</p><p>芯片上电后先接管系统的是SoC厂家的BootROM，它要初始化硬件，然后加载程序到SRAM</p><h2 id="初始化硬件"><a href="#初始化硬件" class="headerlink" title="初始化硬件"></a>初始化硬件</h2><ul><li>CPU的配置</li><li>关闭看门狗</li><li>初始化时钟</li><li>初始化一些外设（比如 USB Controller、MMC Controller，Nand Controller等）；</li></ul><h2 id="加载程序到SRAM"><a href="#加载程序到SRAM" class="headerlink" title="加载程序到SRAM"></a>加载程序到SRAM</h2><blockquote><p>一款新的SoC一般会在芯片<strong>外挂一些存储设备</strong>（eMMC、Nand、Nor、SDCard等）和内存（SDRAM、DDR等）。</p><p>然后我们需要烧写程序让CPU执行，烧写程序，其实就是将<strong>可执行的二进制文件</strong>写到<strong>外部的存储设备</strong>上（<strong>eMMC、Nand、SD</strong>等）。系统上电启动的时候，会<strong>将他们读到内存中执行</strong>。</p></blockquote><p>上电后先接管系统的是SoC厂家的BootROM，其它可执行的程序（u-boot、Kernel）都放（烧写）到了外部存储器上；那么BootROM的代码除了去初始化硬件环境以外，还需要去外部存储器上面，将接下来可执行的程序读到内存来执行。</p><div class="tip info"><p>既然是读到内存执行，那么这个内存可以不可以是我们板载的 DDR呢？</p></div><p>理论上是可以的，但是，SoC厂家设计的DDR控制器一般会支持很多种类型的DDR设备，并且会提供兼容性列表，SoC厂家怎么可能知道用户PCB上到底用了哪种内存呢？</p><p>所以，直接把外部可执行程序读到DDR显然是不太友好的，因此一般来说，<strong>SoC都会做一个内部的小容量的SRAM</strong> ，<strong>BootROM将外部的可执行程序从外部存储器中读出来，放到SRAM去执行</strong>；</p><div class="tip info"><p>那么 BootROM从具体哪个存储器读出二进制文件呢？</p></div><p>SoC厂家一般会支持多种启动方式，比如：</p><ul><li>从eMMC读取</li><li>从SDCard读取</li><li>从Nand Flash读取等等</li></ul><p>上电的时候，需要告诉它，它需要从什么样的外设来读取后面的启动二进制文件；</p><blockquote><p>一般的设计思路是，做一组Bootstrap Pin，上电的时候BootROM去采集这几个IO的电平，来确认要从什么样的外部存储器来加载后续的可执行文件；比如2 个 IO，2’b00 表示从Nand启动，2’b01表示从eMMC启动，2’b10 表示从SDCard启动等等；</p><p>当BootROM读到这些值后，就会去初始化对应的外设，然后来读取后面要执行的代码；这些IO一般来说，会做成板载的拨码开关，用于调整芯片的启动方式；</p></blockquote><div class="tip warning faa-horizontal animated-hover"><p>这里，读取烧写的二进制的时候，需要注意一些细节，比如SoC厂家告诉你，你需要先把SDCard初始化称为某种文件系统，然后把东西放进去才有效之类的；因为<strong>文件系统是组织文件的方式</strong>，并不是裸分区；你<strong>按照A文件系统的方式放进去，然后SoC的BootROM也按照A文件系统的方式读出来，才能够达成一致</strong>；</p></div><h1 id="SPL"><a href="#SPL" class="headerlink" title="SPL"></a>SPL</h1><p>芯片上电后BootROM会根据Bootstrap Pin去确定从某个存储器来读可执行的二进制文件到SRAM并执行；理论上来说，这个二进制文件就可以是我们的<code>u-boot.bin</code>文件了；也就是BootROM直接加载<code>u-boot.bin</code>；</p><p>理论上是这样的，但是这里有一个问题，就是SRAM很贵，一般来说，SoC的片上SRAM都不会太大，一般4KB、8KB、16KB…256KB不等；但是呢，u-boot 编译出来却很大，好几百KB，放不下。</p><p>放不下怎么办？有两种办法：</p><ul><li>假设片内SRAM为4KB，<strong>uboot的前4KB程序实现uboot的重定位</strong>，即<strong>将uboot拷贝到SDRAM中运行</strong>；</li><li>做一个小一点的boot程序，<strong>先让BootROM加载这个小的程序，后面再由这个小boot去加载uboot；</strong></li></ul><h2 id="方案一：uboot重定位"><a href="#方案一：uboot重定位" class="headerlink" title="方案一：uboot重定位"></a>方案一：uboot重定位</h2><p>比如，我们的uboot有400KB，SRAM有4KB，外部SDRAM有64MB；</p><p>如果使用第一种方案的话，uboot的前面4KB被加载进入SRAM执行，uboot被截断，我们就需要<strong>保证在uboot的前4KB代码，把板载的SDRAM初始化好，把整个uboot拷贝到SDRAM，然后跳转到SDRAM执行</strong>；</p><h2 id="方案二：SPL"><a href="#方案二：SPL" class="headerlink" title="方案二：SPL"></a>方案二：SPL</h2><p>第二种方案的话，我们做一个小的uboot ，这个uboot就叫做<strong>SPL</strong>（<strong>Secondary Program Loader</strong>），它很小很小（小于SRAM大小），它<strong>先被BootROM加载到SRAM运行</strong>，SPL做的事情最主要的就是要<strong>初始化内存控制器，然后将真正的大u-boot从外部存储器读取到SDRAM中，然后跳转到大uboot</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1328274-20230510212823113-1918630480.png" alt="启动流程" loading="lazy"></p><p>如上图所示：</p><ol start="0"><li>上电后，BootROM开始执行，初始化时钟，关闭看门狗，关Cache，关中断等等，根据Bootstrap Pin来确定启动设备，初始化外设；</li><li>使用外设驱动，从存储器读取SPL；</li></ol><p>—————- 以上部分是SoC厂家的事情，下面是用户要做的事情 —————-</p><ol start="2"><li>SPL被读到SRAM 执行，此刻，控制权以及移交到我们的SPL 了；</li><li>SPL初始化外部SDRAM；</li><li>SPL使用驱动从外部存储器读取uboot并放到SDRAM；</li><li>跳转到SDRAM中的uboot执行；</li><li>加载内核；</li></ol><blockquote><p>实际情况中，还需注意很多问题：</p><ul><li>编译阶段的链接地址，是否需要地址无关？</li><li>SPL的代码和uboot的代码是否有重合的地方？如果有，是否意味着SPL执行过的，跳转到uboot又要在执行一次？</li><li>具体情况下，需要配置哪些硬件？怎么配置？</li></ul></blockquote><h1 id="Rockchip引导流程"><a href="#Rockchip引导流程" class="headerlink" title="Rockchip引导流程"></a>Rockchip引导流程</h1><p>针对不同的解决方案，Rockchip提供了两种不同的启动加载程序方法，其步骤和生成的镜像文件也是完全不同的。</p><ul><li><strong>TPL&#x2F;SPL加载</strong>：使用Rockchip官方提供的TPL&#x2F;SPL就是我们上面说的小的uboot），该方式完全开源；</li><li><strong>官方固件加载</strong>：使用Rockchip idbLoader，它由<code>Rockchip rkbin project</code>的<code>Rockchip ddr init bin</code>和<code>miniloader bin</code>组合而成，该方式不开源；</li></ul><p>上面我们介绍了SPL，那什么是TPL？实际上将我们上面所说的<strong>SPL初始化SDRAM等硬件工作的部分独立出去，就是TPL</strong>。那么我们总结一下：</p><ul><li><strong>TPL</strong>是<strong>Targer Program Loader</strong>，就是<strong>芯片级的初始化过程</strong>，这个时候的代码都是基于芯片平台的部分，它在启动过程中进行DDR初始化和一些其他的系统配置，以便后续的SPL能够正确地运行；</li><li><strong>SPL</strong>是<strong>Secondary Program Loader</strong>，它从存储设备中<strong>读取trust（如ATF&#x2F;OP-TEE）和uboot二进制文件，将它们加载到系统内存中并运行它们，进而启动完整的操作系统</strong>；</li></ul><blockquote><p>TPL和SPL的区别在于它们的职责不同。TPL主要负责初始化系统硬件，而SPL负责加载和运行其它软件组件，如trust和uboot。</p><p>此外，在一些特殊情况下，如加密启动或安全启动模式下，TPL还可能执行其他额外的任务。</p></blockquote><h2 id="启动阶段"><a href="#启动阶段" class="headerlink" title="启动阶段"></a>启动阶段</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--------+----------------+----------+-------------+---------+</span><br><span class="line">|<span class="string"> Boot   </span>|<span class="string"> Terminology #1 </span>|<span class="string"> Actual   </span>|<span class="string"> Rockchip    </span>|<span class="string"> Image   </span>|</span><br><span class="line">|<span class="string"> stage  </span>|<span class="string">                </span>|<span class="string"> program  </span>|<span class="string">  Image      </span>|<span class="string"> Location</span>|</span><br><span class="line">|<span class="string"> number </span>|<span class="string">                </span>|<span class="string"> name     </span>|<span class="string">   Name      </span>|<span class="string"> (sector)</span>|</span><br><span class="line">+--------+----------------+----------+-------------+---------+</span><br><span class="line">|<span class="string"> 1      </span>|<span class="string">  Primary       </span>|<span class="string"> ROM code </span>|<span class="string"> BootROM     </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">  Program       </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">  Loader        </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string"> 2      </span>|<span class="string">  Secondary     </span>|<span class="string"> U-Boot   </span>|<span class="string">idbloader.img</span>|<span class="string"> 0x40    </span>|<span class="string"> pre-loader</span></span><br><span class="line"><span class="string"></span>|<span class="string">        </span>|<span class="string">  Program       </span>|<span class="string"> TPL/SPL  </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">  Loader (SPL)  </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string"> 3      </span>|<span class="string">  -             </span>|<span class="string"> U-Boot   </span>|<span class="string"> u-boot.itb  </span>|<span class="string"> 0x4000  </span>|<span class="string"> including u-boot and atf</span></span><br><span class="line"><span class="string"></span>|<span class="string">        </span>|<span class="string">                </span>|<span class="string">          </span>|<span class="string"> uboot.img   </span>|<span class="string">         </span>|<span class="string"> only used with miniloader</span></span><br><span class="line"><span class="string"></span>|<span class="string">        </span>|<span class="string">                </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                </span>|<span class="string"> ATF/TEE  </span>|<span class="string"> trust.img   </span>|<span class="string"> 0x6000  </span>|<span class="string"> only used with miniloader</span></span><br><span class="line"><span class="string"></span>|<span class="string">        </span>|<span class="string">                </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string"> 4      </span>|<span class="string">  -             </span>|<span class="string"> kernel   </span>|<span class="string"> boot.img    </span>|<span class="string"> 0x8000  </span>|</span><br><span class="line">|<span class="string">        </span>|<span class="string">                </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">         </span>|</span><br><span class="line">|<span class="string"> 5      </span>|<span class="string">  -             </span>|<span class="string"> rootfs   </span>|<span class="string"> rootfs.img  </span>|<span class="string"> 0x40000 </span>|</span><br><span class="line">+--------+----------------+----------+-------------+---------+</span><br></pre></td></tr></table></figure><p>启动阶段涉及到了多个镜像文件：</p><ul><li>阶段一中的BootROM这个是SoC厂商提供的；</li><li>阶段二方式需要提供一个<code>idbloader.img</code>；</li><li>阶段三实际上就是uboot的镜像文件了，这里有两种: <strong>uboot.img（还需要搭配trust.img）<strong>和</strong>u-boot.itb（这个是因为它已经把ATF打包进去了）</strong>；这两个文件里面除了都包含u-boot.bin原始二进制文件，又放了点其他东西，可以被<code>idbloader.img</code>识别，然后加载；</li><li>阶段四和阶段五是内核镜像和根文件系统；</li></ul><blockquote><p>当我们讨论从eMMC&#x2F;SD&#x2F;U盘&#x2F;网络启动时，它们涉及到不同的概念：</p><ul><li>第一阶段始终在BootROM中，它加载第二阶段并可能加载第三阶段（当启用SPL_BACK_TO_BROM选项时）；</li><li>从SPI闪存启动意味着第二阶段和第三阶段固件（仅限SPL和U-Boot）在SPI闪存中，第四&#x2F;五阶段在其他位置；</li><li>从eMMC启动意味着所有固件（包括第二、三、四、五阶段）都在eMMC中；</li><li>从SD Card启动意味着所有固件（包括第二、三、四、五阶段）都在SD Card中；</li><li>从U盘启动意味着第四和第五阶段的固件（不包括SPL和U-Boot）在磁盘中，可选地仅包括第五阶段；</li><li>从Net&#x2F;TFTP启动意味着第四和第五阶段的固件（不包括SPL和U-Boot）在网络上。</li></ul></blockquote><h3 id="idbloader-img"><a href="#idbloader-img" class="headerlink" title="idbloader.img"></a>idbloader.img</h3><p>idbloader.img文件是一个Rockchip格式的预加载程序，在SoC启动时工作，它包含：</p><ul><li>由Rockchip BootROM知道的IDBlock 头；</li><li>DDR初始化程序，由BootROM加载到SRAM，运行在SRAM内部；</li><li>下一级加载程序，由BootROM加载并运行在DDR上；</li></ul><h3 id="u-boot-img"><a href="#u-boot-img" class="headerlink" title="u-boot.img"></a>u-boot.img</h3><p>u-boot.bin是uboot源码编译后生成的原始二进制映像，可以直接烧录到设备的闪存中。而u-boot.img则是通过<code>mkimage</code>工具在u-boot.bin基础上增加了一个头部信息，这个头部信息可能也包括一些额外的数据，例如启动参数和内核映像地址等。</p><p>因此，通过<strong>使用u-boot.img而不是u-boot.bin</strong>，可以使引导ROM更容易地识别uboot映像，并更好地指导uboot在设备上正确启动。</p><h3 id="u-boot-itb"><a href="#u-boot-itb" class="headerlink" title="u-boot.itb"></a>u-boot.itb</h3><p>u-boot.itb实际上是u-boot.img的另一个变种，也是通过mkimage构建出来的，里面除了u-boot.dtb和u-boot-nodtb.bin这两个uboot源码编译出来的文件之外，还包含了bl31.elf、bl32.bin、tee.bin等ARM trust固件。其中bl31.elf是必须要有的，bl32.bin、tee.bin是可选的，可以没有。</p><h3 id="trust-img"><a href="#trust-img" class="headerlink" title="trust.img"></a>trust.img</h3><p>ARM64的SOC还需要编译<strong>ATF (ARM Trust Firmware)</strong>，<strong>ATF主要负责在启动uboot之前把CPU从安全的EL3切换到EL2</strong>，<strong>然后跳转到uboot，并且在内核启动后负责启动其他的CPU</strong>。</p><p>ATF将系统启动从最底层进行了完整的统一划分，将secure monitor的功能放到了bl31中进行，这样当系统完全启动之后，在CA或者TEE OS中触发了smc或者是其他的中断之后，首先是遍历注册到bl31中的对应的service来判定具体的handle，这样可以对系统所有的关键smc或者是中断操作做统一的管理和分配。ATF的code boot整个启动过程框图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1328274-20230514232734556-1467299130.png" alt="ATF" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1328274-20230510214919955-766557863.png" alt="Rockchip提供的外部uboot加载的流程图" loading="lazy"></p><p>如上图所示：</p><ul><li>引导流程1是典型的使用Rockchip miniloader的Rockchip引导流程；</li><li>引导流程2用于大多数SoC，使用U-Boot TPL进行DDR初始化，使用SPL加载加载u-boot.itb文件；</li></ul><p>注1：如果loader1具有多个阶段，则程序将返回到BootROM，BootROM将载入并运行到下一个阶段。例如，如果loader1是TPL和SPL，则BootROM将首先运行到TPL，TPL初始化DDR并返回到BootROM，BootROM然后将加载并运行到SPL。</p><p>注2：如果启用了trust，在安全模式（armv8中的EL3）下，loader1需要同时加载trust和U-Boot，然后运行到trust中，trust在非安全模式（armv8中的EL2）下进行初始化，并运行到U-Boot。</p><p>注3：对于trust（在trust.img或u-boot.itb中），armv7仅有一个带或不带TA的tee.bin，armv8具有bl31.elf并且可选包含bl32。</p><p>注4：在boot.img中，内容可以是Linux的zImage和其dtb，可以选择grub.efi，也可以是AOSP boot.img，ramdisk可选。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.cnblogs.com/zyly/p/17380243.html">Rockchip RK3399 - 引导流程和准备工作 </a></div>]]></content>
    
    
    <summary type="html">uboot</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>topeet RK3568 Linux5.10 ArchLinux编译</title>
    <link href="https://even629.com/posts/2512260/"/>
    <id>https://even629.com/posts/2512260/</id>
    <published>2025-12-26T05:25:13.000Z</published>
    <updated>2025-12-26T05:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-26</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>使用wsl的archlinux<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251120165235338.png" alt="环境" loading="lazy"></p><h2 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h2><p>ARM目前总共发布了8种架构：ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8。</p><p>针对于Cortex-A5x处理器可以使用<code>aarch64-linux-gnu-gcc -march=armv8-a</code>命令编译代码，ARM GNU编译器可通过下面的链接下载</p><div class="tag link"><a class="link-card" title="Arm GNU Toolchain Downloads" href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads"><div class="left"><img src="https://developer.arm.com/shared/common/img/favicon/favicon.ico"/></div><div class="right"><p class="text">Arm GNU Toolchain Downloads</p><p class="url">https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads</p></div></a></div><p>使用archlinux上通过pacman下载的aarch64-linux-gnu-gcc版本是15.1.0</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251226131446292.png" alt="aarch64-linux-gnu-gcc" loading="lazy"></p><h2 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h2><p>源码是topeet提供的：</p><div class="tag link"><a class="link-card" title="topeet RK3568 Linux5.10源码" href="https://pan.baidu.com/s/1c9wUwvY0oe72--K-f5l8SA?pwd=ba5f"><div class="left"><img src="https://nd-static.bdstatic.com/m-static/v20-main/favicon-main.ico"/></div><div class="right"><p class="text">topeet RK3568 Linux5.10源码</p><p class="url">https://pan.baidu.com/s/1c9wUwvY0oe72--K-f5l8SA?pwd=ba5f</p></div></a></div><h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>使用aarch64-linux-gnu-gcc 15.1.0版本编译器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -Sy bc</span><br><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- clean</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- rockchip_linux_defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- modules_prepare</span><br><span class="line"></span><br><span class="line"><span class="comment"># -Wno-dangling-pointer 禁用 GCC 的 “悬空指针” 警告。</span></span><br><span class="line"><span class="comment"># -Wno-enum-int-mismatch 禁用 “枚举类型与整数类型不匹配” 的警告。</span></span><br><span class="line"><span class="built_in">export</span> KCFLAGS=<span class="string">&quot;-Wno-dangling-pointer -Wno-enum-int-mismatch&quot;</span></span><br><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image dtbs -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> KCFLAGS  <span class="comment"># 可选，用完清除</span></span><br></pre></td></tr></table></figure><h2 id="clangd-查看内核源码"><a href="#clangd-查看内核源码" class="headerlink" title="clangd 查看内核源码"></a>clangd 查看内核源码</h2><h3 id="生成compile-command-json"><a href="#生成compile-command-json" class="headerlink" title="生成compile_command.json"></a>生成compile_command.json</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/clang-tools/gen_compile_commands.py</span><br></pre></td></tr></table></figure><p>使用clangd作为语言服务器要添加ComplieFlags，因为clangd对GCC的某些编译选项不识别：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">CompileFlags:</span></span><br><span class="line"><span class="symbol">  Add:</span> -Wno-unknown-warning-option</span><br><span class="line"><span class="symbol">  Remove:</span> [-m*, -f*]</span><br></pre></td></tr></table></figure><h3 id="sp报错"><a href="#sp报错" class="headerlink" title="sp报错"></a>sp报错</h3><p>clangd报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang [asm_invalid_global_var_reg]: Register <span class="string">&#x27;sp&#x27;</span> unsuitable <span class="keyword">for</span> global register variables on this target</span><br></pre></td></tr></table></figure><p>将变量 current_stack_pointer 绑定到 sp 寄存器（即当前栈指针），以便直接读取栈顶地址。这种写法在 GCC 编译 Linux 内核时是合法的（尤其在 ARM64 架构下），但 Clang 对此有更严格的限制。因此我们修改<code>arch/arm64/include/asm/stack_pointer.h</code>源码如下，对于<code>__clang__</code>使用内联汇编函数返回sp的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASM_STACK_POINTER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASM_STACK_POINTER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * how to get the current stack pointer from C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __clang__</span></span><br><span class="line"><span class="comment">// For clang: fake it</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_sp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sp;</span><br><span class="line">__asm__(<span class="string">&quot;&quot;</span> : <span class="string">&quot;=r&quot;</span>(sp) : <span class="string">&quot;r&quot;</span>(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current_stack_ptr get_sp()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">register</span> <span class="type">unsigned</span> <span class="type">long</span> current_stack_pointer <span class="title function_">asm</span><span class="params">(<span class="string">&quot;sp&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASM_STACK_POINTER_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="编译uboot"><a href="#编译uboot" class="headerlink" title="编译uboot"></a>编译uboot</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make rk3568_defconfig</span><br><span class="line"><span class="built_in">export</span> KCFLAGS=<span class="string">&quot;-Wno-enum-int-mismatch -Wno-maybe-uninitialized&quot;</span></span><br><span class="line">make CROSS_COMPILE=aarch64-linux-gnu- -j$(<span class="built_in">nproc</span>) all</span><br><span class="line"><span class="built_in">unset</span> KCFLAGS  <span class="comment"># 可选，用完清除</span></span><br></pre></td></tr></table></figure><p>生成：</p><ul><li><code>u-boot</code>（ELF）</li><li><code>u-boot.bin</code>（原始二进制）</li><li><code>spl/u-boot-spl.bin</code>（如果启用 SPL）</li><li><code>tpl/u-boot-tpl.bin</code>（如果启用 TPL）</li><li><code>u-boot.dtb</code>（内嵌或外部设备树）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tools/mkimage -n rk3568 -T rksd -d tpl/u-boot-tpl.bin idbloader.img</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> spl/u-boot-spl.bin &gt;&gt; idbloader.img</span><br></pre></td></tr></table></figure><p>这样生成的loader可能有点问题还待研究TODO</p><h1 id="编译根文件系统"><a href="#编译根文件系统" class="headerlink" title="编译根文件系统"></a>编译根文件系统</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- rockchip_rk3568_defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"><span class="built_in">sudo</span> pacman -Sy cpio rsync</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="编译recover"><a href="#编译recover" class="headerlink" title="编译recover"></a>编译recover</h1><p>TODO</p><h1 id="烧写"><a href="#烧写" class="headerlink" title="烧写"></a>烧写</h1><p>TODO</p>]]></content>
    
    
    <summary type="html">编译topeet的RK3568 Linux5.10,在wsl的ArchLinux上使用aarch64-linux-gnu-gcc 15.1.0版本</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode热题100 P283 移动零</title>
    <link href="https://even629.com/posts/283/"/>
    <id>https://even629.com/posts/283/</id>
    <published>2025-12-24T03:55:13.000Z</published>
    <updated>2025-12-24T03:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：</p><div class="tag link"><a class="link-card" title="P183 移动零" href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P183 移动零</p><p class="url">https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked</p></div></a></div><p>冒泡排序写法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                                j = i;</span><br><span class="line">                                <span class="keyword">while</span> (nums[j] == <span class="number">0</span> &amp;&amp; j &lt; k) &#123;</span><br><span class="line">                                        std::<span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                                        j++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                k--;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针:<br>左指针指向已经处理完的元素的下一个，右指针指向左指针后面的第一个非零元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; n &amp;&amp; nums[left] != <span class="number">0</span>) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                &#125;</span><br><span class="line">                right = left;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; n &amp;&amp; nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                        right++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">                                std::<span class="built_in">swap</span>(nums[left], nums[right]);</span><br><span class="line">                                left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        right++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- flag of hidden posts -->]]></content>
    
    
    <summary type="html">双指针</summary>
    
    
    
    <category term="algorithm" scheme="https://even629.com/categories/algorithm/"/>
    
    
    <category term="algorithm" scheme="https://even629.com/tags/algorithm/"/>
    
    <category term="双指针" scheme="https://even629.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="leetcode热题100" scheme="https://even629.com/tags/leetcode%E7%83%AD%E9%A2%98100/"/>
    
  </entry>
  
  <entry>
    <title>Linux 单总线</title>
    <link href="https://even629.com/posts/2512233/"/>
    <id>https://even629.com/posts/2512233/</id>
    <published>2025-12-23T11:55:13.000Z</published>
    <updated>2025-12-23T11:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="单总线简介"><a href="#单总线简介" class="headerlink" title="单总线简介"></a>单总线简介</h1><h2 id="单总线概述"><a href="#单总线概述" class="headerlink" title="单总线概述"></a>单总线概述</h2><p><strong>单总线（One-Wire）是一种串行通信协议和硬件总线</strong>，用于在电子设备之间传输数据和控制信号。它是由独立的芯片制造商 Dallas Semiconductor 开发的，并且在多种应用中得到了广泛应用。</p><p>与 SPI I2C 等串行数据通信方式不同，单总线的特点是<strong>只需要一根信号线，既可以传输时钟又可以传输数据，而且数据是双向的</strong>。所以单总线具有节省 IO 口，结构简单，便于扩展和维护等特点。</p><p>单总线用于各种应用，包括<strong>温度传感器，湿度传感器，EEPROM 存储器，时钟</strong>等。它在许多领域中得到了广泛应用，例如工业自动化，家庭自动化，物联网和电子设备监测等。本篇使用温度传感器 DS18b20 进行举例学习单总线。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195437951.png" alt="单总线的硬件结构" loading="lazy"></p><ol><li><strong>信号线</strong>：单总线使用一根信号线进行数据传输和通信。这根线被称为数据线，也是提供电源的线路。单总线上的所有设备都连接到这根信号线上。</li><li><strong>上拉电阻</strong>：单总线需要一个上拉电阻连接到信号线和电源之间，以确保在没有设备发送数据时，信号线上的电平保持为高电平（逻辑 1）。上拉电阻的值通常在 4.7 千欧姆到 10 千欧姆之间。(GPIO设置成上拉)</li><li><strong>设备</strong>：单总线支持多个设备连接到信号线上。每个设备都具有唯一的 64 位地址，通过这个地址来识别和选择通信的目标设备。设备可以是各种类型的传感器，存储器，时钟等。</li><li><strong>处理器</strong>：处理器是单总线上的控制器，处理器负责发送命令，读取响应和控制单总线上的从设备</li></ol><h2 id="单总线的通信步骤"><a href="#单总线的通信步骤" class="headerlink" title="单总线的通信步骤"></a>单总线的通信步骤</h2><p>单总线是<strong>主从结构</strong>，<strong>当主机呼叫从机时，从机才会应答</strong>，所以<strong>主机都必须严格遵循单总线的命令时序</strong>。如果命令时序不对，则器件不会响应。</p><p>单总线的通信步骤通常包括以下几个阶段。</p><ol><li><strong>初始化</strong>：通信开始之前，<strong>主设备会发送初始化信号来确保单总线上没有其他设备正在通信</strong>。初始化信号是一个特定的序列，通常是将数据线拉低一段时间然后释放。</li><li><strong>ROM 操作命令</strong></li><li><strong>功能命令</strong></li></ol><h1 id="DS18B20-介绍"><a href="#DS18B20-介绍" class="headerlink" title="DS18B20 介绍"></a>DS18B20 介绍</h1><h2 id="DS18b20-芯片概述"><a href="#DS18b20-芯片概述" class="headerlink" title="DS18b20 芯片概述"></a>DS18b20 芯片概述</h2><p>DS18b20 是一种数字温度传感器芯片，<strong>提供 9 到 12bit 分辨率的温度测量</strong>，可以通过<strong>可编程非易失性存储单元</strong>实现温度的下限和上限报警。</p><p>它是基于单总线通信协议的设备，只需要一根信号线和一根地线。</p><p>DS18b20 能够以较高的精度测量温度精确到 0.0625°C。它具有广泛的测量范围，通常介于-55°C 到+125°C 之间。</p><p>DS18B20 芯片可以通过单总线从主设备获取供电，也可以通过外部电源进行供电。这使得它在一些低功耗应用中能够灵活选择供电方式。</p><p>每个DS18b20 都会有一个全球唯一的 64 位序列号，可以将多个 DS18b20 串联在同一根单总线上进行组网，只需要一个处理器就可以控制分布在大面积区域中的多颗 DS18b20。这种组网方式特别适合 HVAC 环境控制，建筑，设备，粮情测温和工业测温以及过程监测控制等应用领域。</p><h2 id="DS18b20-基本性能"><a href="#DS18b20-基本性能" class="headerlink" title="DS18b20 基本性能"></a>DS18b20 基本性能</h2><p>DS18B20 是一款数字温度传感器芯片，具有以下基本性能特点：</p><ul><li>采用单总线接口仅需一个端口引脚进行通信</li><li>每颗芯片具有全球唯一的 64 位的序列号</li><li>具有多点分布式测温功能无需外围元器件</li><li>可通过数据线供电，供电电压范围为 2.5V~5.5V</li><li>测度测量范围为-55°C 到+125°C</li><li>在-10°C~ 70°C 范围内精确度为±0.4°C</li><li>温度分辨率 9-12 位可选</li><li>最高 12 位精度下，温度转换速度小于 750ms</li><li>具有用户自定义的非易失性温度报警设置</li><li>报警搜索命令识别并标识超过程序设定温度的器件</li><li>超强静电保护能力：HBM 8000V MM 800V</li><li>可提供贴片的 MSOP8，SOP8 封装和 3 脚的 TO-92、TO-92S 封装。</li></ul><h2 id="DS18b20-引脚配置和封装"><a href="#DS18b20-引脚配置和封装" class="headerlink" title="DS18b20 引脚配置和封装"></a>DS18b20 引脚配置和封装</h2><p>DS18B20 芯片引脚配置：</p><ul><li><strong>VDD</strong>：供电引脚，用于提供芯片的正电源。</li><li><strong>DQ</strong>：数据引脚，用于单总线通信和数据传输。</li><li><strong>GND</strong>：地引脚，连接芯片的地（负电源）。</li></ul><p>DS18B20 芯片可用于不同的封装类型，其中最常见的封装是 TO-92 封装和 TO-92-3 封装。这些封装都是具有三个引脚的小型封装，适用于直插式安装和表面贴装。</p><p>TO-92 封装是一种常见的小型塑料封装，引脚按照顺序排列，依次为 VDD、DQ 和 GND。</p><p>TO-92-3 封装与 TO-92 封装类似，但引脚顺序略有不同。TO-92-3 封装的引脚顺序为 GND、DQ 和 VDD。</p><p>除了这些常见的封装类型，DS18B20 还可以在其他封装类型中使用，例如 SOT-23 封装和TO-263 封装等，这些封装类型可能具有不同的引脚排列和尺寸。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195437971.png" alt="DS18B20封装类型" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195438102.png" alt="DC Electrical Characteristics" loading="lazy"></p><h2 id="DS18b20-内部结构"><a href="#DS18b20-内部结构" class="headerlink" title="DS18b20 内部结构"></a>DS18b20 内部结构</h2><p>DS18b20 是一种数字温度传感器芯片，其内部结构主要包括以下组成部分，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195438050.png" alt="DS18b20 Block Diagram" loading="lazy"></p><ul><li><strong>温度传感器</strong>：DS18B20 内部集成了温度传感器，用于测量环境的温度。传感器通常基于基准电压的变化来检测温度，并将其转换为数字信号。</li><li><strong>A&#x2F;D 转换器</strong>：DS18B20 芯片内部包含了一种模数转换器（A&#x2F;D 转换器），用于将传感器测量到的模拟温度值转换为相应的数字表示。这使得温度数据能够以数字形式进行处理和传输。</li><li><strong>存储器</strong>：DS18B20 芯片还具有内部存储器，用于存储配置信息和温度测量结果。存储器可以存储唯一的 64 位地址、温度分辨率和其他相关设置。</li><li><strong>控制逻辑</strong>：DS18B20 芯片包含了控制逻辑电路，用于管理温度测量、通信和其他相关功能。控制逻辑协调各个部分的操作，并与主设备进行通信。</li><li><strong>单总线接口</strong>：DS18B20 采用了单总线通信协议，其内部结构包括一条数据线和一个上拉电阻，用于与主设备进行通信。单总线接口简化了连接和通信的布线，使得多个 DS18B20 传感器能够方便地串联在同一条总线上。</li></ul><p>存储器由 9 个字节组成，其分配如下表所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195438078.png" alt="DS18B20 Memory Map" loading="lazy"></p><p>当温度转换命令发布后，经转换所得的温度值以<strong>二字节补码形式</strong>存放在高速暂存存储器的第 0 和第 1 个字节，单片机可通过单线接口读到该数据，读取时低位在前，高位在后，数据格式如下表所示。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195459968.png" alt="Temperature Register Format" loading="lazy"></p><h2 id="DS18b20-寄存器介绍"><a href="#DS18b20-寄存器介绍" class="headerlink" title="DS18b20 寄存器介绍"></a>DS18b20 寄存器介绍</h2><p>DS18B20 芯片具有几个重要的寄存器，用于配置和控制传感器的功能。以下是 DS18B20常用的寄存器介绍：</p><ul><li><p><strong>温度寄存器（Temperature Register）</strong>：温度寄存器存储了最近一次温度测量的结果。它是一个 16 位的寄存器，包含了温度值的原始数据。通过读取温度寄存器中的数据，并结合分辨率设置，可以计算出实际的温度值。</p></li><li><p><strong>配置寄存器（Configuration Register）</strong>：配置寄存器用于设置 DS18B20 的工作模式和温度分辨率。它是一个 8 位的寄存器，每个位对应一个配置选项。通过写入配置寄存器，可以选择温度分辨率、触发温度转换和使用电源供电模式等。</p></li><li><p><strong>精度寄存器（Resolution Register）</strong>：精度寄存器用于设置温度分辨率。它是一个 8 位的寄存器，每个位对应一种分辨率选项。通过写入精度寄存器，可以选择不同的温度分辨率，例如 9 位、10 位、11 位或 12 位。</p></li><li><p><strong>唯一地址寄存器（Unique Address Register）</strong>：唯一地址寄存器存储了 DS18B20 芯片的唯一64 位地址。每个 DS18B20 芯片都有唯一的地址，通过读取唯一地址寄存器中的数据，可以获取芯片的地址信息。</p></li></ul><h3 id="配置寄存器"><a href="#配置寄存器" class="headerlink" title="配置寄存器"></a>配置寄存器</h3><p>配置寄存器用于设置 DS18B20 的工作模式和温度分辨率。它是一个 8 位的寄存器，每个位对应一个配置选项。如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195441591.png" alt="配置寄存器" loading="lazy"></p><blockquote><p>注意：上电默认设置 R0&#x3D;1,R1&#x3D;1(12 位精度)。</p></blockquote><p><strong>精度和转换时间之间有直接关系</strong>。配置寄存器的位 7 和位 0 到 4 被器件保留，禁止写入。温度分辨率设置表如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195442527.png" alt="硬度和转换时间的关系" loading="lazy"></p><h3 id="温度测量寄存器"><a href="#温度测量寄存器" class="headerlink" title="温度测量寄存器"></a>温度测量寄存器</h3><p>DS18B20 芯片的温度寄存器是一个 16 位的寄存器，用于存储最近一次温度测量的原始数据。温度寄存器的位布局如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195504612.png" alt="Temperature Register Format" loading="lazy"></p><p>温度寄存器的最低有效位（LSB）是 2^-4 位，表示温度的最小精度为 0.0625°C。其他位依次表示更高的温度精度，分别为: </p><ul><li>2^-3^（0.125）</li><li>2^-2^（0.25）</li><li>2^-1^（0.5）</li><li>2^0^（1）</li><li>2^1^（2）</li><li>2^2^（4）</li><li>2^3^（8）</li></ul><p>DS18B20 芯片的温度寄存器中存储的原始数据可以通过以下步骤计算出实际温度值：</p><ol><li>从温度寄存器读取的 16 位数据可以解释为一个有符号整数，其中最高位（MSB）表示符号位。如果符号位为 0，表示正温度；如果符号位为 1，表示负温度。</li><li>取出温度寄存器中的低 11 位（位 4 到位 15），这些位表示温度的绝对值，其中位值为 1 表示该位对应的温度分辨率有效。</li><li>将这 11 位数据与符号位组合成一个有符号整数。</li><li>根据所选择的温度分辨率，<strong>将有符号整数乘以相应的分辨率因子</strong>，以获得实际的温度值。</li><li>当温度大于 0 时，符号位为 0，测量到的温度值乘以分辨率因子即可得到实际的温度。</li><li>当温度小于 0 时，符号位为 1，测量得到的温度值取反加一再乘以分辨率因子即可得到实际的温度。</li></ol><blockquote><p>举个例子，假设选择了 12 位的温度分辨率，并从温度寄存器读取的数据为 0x1FFF。</p><p>0x1FFF 的二进制表示为：0001 1111 1111 1111。最高位为 0，表示正温度。取出低 11 位：111 1111 1111。将这 11 位与符号位组合，得到有符号整数为：0111 1111 1111（对应 0x07FF）。</p><p>对于 12 位的温度分辨率，分辨率因子为 0.0625°C。将有符号整数 0x07FF乘以分辨率因子：0x07FF * 0.0625 &#x3D; 127.9375°C。</p><p>因此，从温度寄存器读取的数据 0x1FFF 对应着约 127.94°C 的实际温度值。</p></blockquote><h2 id="DS18b20-指令介绍"><a href="#DS18b20-指令介绍" class="headerlink" title="DS18b20 指令介绍"></a>DS18b20 指令介绍</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>根据 DS18B20 的通讯协议，主机（单片机）控制 DS18B20 完成温度转换必须经过三个步骤：</p><ul><li>每一次读写之前都要对 DS18B20 进行复位操作</li><li>复位成功后发送一条 ROM 指令</li><li>最后发送 RAM 指令，这样才能对 DS18B20 进行预定的操作。</li></ul><p>复位要求主 CPU 将数据线下拉 500 微秒，然后 释放，当 DS18B20 收到信号后等待 16～60 微秒左右，后发出 60～240 微秒的存在低脉冲，主 CPU 收到此信号表示复位成功。</p><p>ROM指令</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195442659.png" alt="ROM指令" loading="lazy"></p><p>RAM指令</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223195443252.png" alt="DS18B20 Function Command Set" loading="lazy"></p><h3 id="操作举例"><a href="#操作举例" class="headerlink" title="操作举例"></a>操作举例</h3><p><strong>当单总线上只有一个 DS18b20 的时候</strong>：</p><ol><li>开始进行温度转换：<ul><li>复位信号</li><li>发送 ROM 指令 OXCC 跳过搜索</li><li>发送 RAM 指令 0x44 进行温度转换。</li></ul></li><li>读温度：<ul><li>复位信号</li><li>发送 ROM 指令 OXCC 跳过搜索</li><li>发送 RAM 指令 0xbe 读暂存器。</li></ul></li><li>设置 ds18b20:<ul><li>复位信号</li><li>发送 ROM 指令 OXCC 跳过搜索</li><li>发送 RAM 指令 0x4e 写暂存器</li><li>要写的数据。</li></ul></li></ol><p><strong>当单总线上有多个 ds18b20 的时候</strong></p><ol><li>开始进行温度转换：<ul><li>复位信号</li><li>发送 ROM 指令 0x55 匹配指令</li><li>发送 DS18b20 的地址</li><li>发送 RAM 指令 0x44 进行温度转换。</li></ul></li><li>读温度：<ul><li>复位信号</li><li>发送 ROM 指令 0x55 匹配指令</li><li>发送 DS18b20 的地址</li><li>发送 RAM 指令 0xbe 读暂存器。</li></ul></li><li>设置 ds18b20:<ul><li>复位信号</li><li>发送 ROM 指令 0x55 匹配指令</li><li>发送 DS18b20 的地址</li><li>发送RAM 指令 0x4e 写暂存器</li><li>要写的数据。</li></ul></li></ol><h2 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h2><h3 id="复位时序"><a href="#复位时序" class="headerlink" title="复位时序"></a>复位时序</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251225174653693.png" loading="lazy"></p><h3 id="读写时序"><a href="#读写时序" class="headerlink" title="读写时序"></a>读写时序</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251225174717363.png" loading="lazy"></p>]]></content>
    
    
    <summary type="html">Linux 单总线</summary>
    
    
    
    <category term="Linux" scheme="https://even629.com/categories/Linux/"/>
    
    
    <category term="GNU" scheme="https://even629.com/tags/GNU/"/>
    
    <category term="Linux" scheme="https://even629.com/tags/Linux/"/>
    
    <category term="driver" scheme="https://even629.com/tags/driver/"/>
    
  </entry>
  
</feed>
