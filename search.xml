<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GCC内嵌汇编</title>
      <link href="/posts/50001/"/>
      <url>/posts/50001/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>参考文档：</p><div class="tag link"><a class="link-card" title="gcc" href="https://gcc.gnu.org/onlinedocs/gcc.pdf"><div class="left"><img src="https://gcc.gnu.org/favicon.ico"/></div><div class="right"><p class="text">gcc</p><p class="url">https://gcc.gnu.org/onlinedocs/gcc.pdf</p></div></a></div><blockquote><p>内嵌汇编（Inline Assembly Language）在C语言中嵌入汇编代码</p></blockquote><p>目的：</p><ul><li>优化：针对特定重要代码(time-sensitive进行优化)</li><li>C语言需要访问某些特殊指令来实现特殊功能，比如内存屏障指令</li></ul><p>内存汇编两种模式</p><ul><li>基础内嵌汇编</li><li>扩展内嵌汇编</li></ul><h3 id="基础内嵌汇编"><a href="#基础内嵌汇编" class="headerlink" title="基础内嵌汇编"></a>基础内嵌汇编</h3><p><strong>格式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="keyword">asm</span>-qualifiers(AssemblerInstructions)</span><br></pre></td></tr></table></figure><ul><li>asm关键字：表明这是一个GNU扩展</li><li><p>修饰词（qualifiers）</p><ul><li>volatile：在基础内嵌汇编中通常不需要这个修饰词</li><li>inline：内联，asm汇编的代码会尽可能小</li></ul></li><li><p>汇编代码块（AssemblerInstructions）</p><ul><li><p>GCC编译器把内嵌汇编当成一个字符串</p></li><li><p>GCC编译不会去解析和分析内嵌汇编</p></li><li><p>多条汇编指令，需要使用”\n\t“来换行</p></li><li><p>GCC的优化器，可以移动汇编指令的前后位置。如果你需要保存汇编指令的顺序，最后使用多个内嵌汇编的方式</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807225346177.png" alt="image-20250807225346177"></p><h3 id="扩展内嵌汇编"><a href="#扩展内嵌汇编" class="headerlink" title="扩展内嵌汇编"></a>扩展内嵌汇编</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807225554976.png" alt="image-20250807225554976"></p><ul><li>格式<ul><li>asm关键字：表明这个是一个GNU扩展</li><li>修饰词(asm-qualifiers)<ul><li>volatile：用来关闭GCC优化</li><li>inline内联，asm汇编的代码会尽可能小</li><li>goto 在内嵌会便利会跳转到C语言的标签里</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807225535346.png" alt="image-20250807225535346"></p><ul><li><p>输出部：</p><blockquote><p>用于描述在指令部中<strong>可以被修改的C语言变量</strong>以及约束条件</p></blockquote><ul><li>每个输出约束通常以”=”开头，接着的字母表示对操作数类型的说明，然后是关于变量结合的约束</li><li>输出部通常使用”=“或者”+”作为输出约束，其中”<strong>=“表示被修饰的操作数只具有可写属性</strong>，”<strong>+“表示被修饰的操作数只具有可读可写属性</strong></li><li>输出部可以是空的</li></ul></li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;=/+&quot;</span> <span class="punctuation">+</span> 约束修饰符 <span class="punctuation">+</span> 变量</span><br></pre></td></tr></table></figure><ul><li><p>输入部</p><blockquote><p>用来描述在指令部<strong>只能被读取访问的C语言变量</strong>以及约束条件</p></blockquote><ul><li>输入部描述的参数是只有只读属性，不要试图修改输入部的参数内容，因为GCC编译器假定，输入部的参数的内容在内嵌汇编之前和之后都是一致的</li><li>在输入部中不能使用”=”或者”+“约束条件，否则编译器会报错</li><li>输入部可以是空的</li></ul></li><li><p>损坏部（Clobbers）</p><ul><li>“memory”告诉GCC编译器内联汇编指令改变了内存中的值，强迫编译器在执行该汇编代码前存储所有缓存中的值，在执行完汇编代码之后重新加载该值，目的是防止编译乱序</li><li>”cc”表示内嵌汇编代码修改了状态寄存器相关的标志位</li></ul></li></ul><ul><li>指令部的参数表示<ul><li>%0 对应输出输入部的第一个参数，%1表示第二个参数</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807232638621.png" alt="image-20250807232638621"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807232843751.png" alt="image-20250807232843751"></p><p><strong>输出和输入部的约束修饰符</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807232923213.png" alt="image-20250807232923213"></p><p><strong>输出部和输入部的约束修饰符——通用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807232959031.png" alt="image-20250807232959031"></p><p><strong>输出部和输入部的约束修饰符——ARM64</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807233047966.png" alt="image-20250807233047966"></p><p><strong>汇编符号名字来代替前缀%</strong></p><ul><li><p><code>%[name]</code> → 引用约束变量</p></li><li><p><code>%w[name]</code> → 引用 <strong>低 32 位寄存器</strong>（如 <code>w0, w1</code>）</p></li><li><p><code>%x[name]</code> → 引用 <strong>完整 64 位寄存器</strong>（如 <code>x0, x1</code>）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807233254708.png" alt="image-20250807233254708"></p><h3 id="实验1：实现简单的memcpy函数"><a href="#实验1：实现简单的memcpy函数" class="headerlink" title="实验1：实现简单的memcpy函数"></a>实验1：实现简单的memcpy函数</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807233332933.png" alt="image-20250807233332933"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250808105751008.png" alt="image-20250808105751008"></p><h3 id="陷阱与坑"><a href="#陷阱与坑" class="headerlink" title="陷阱与坑"></a>陷阱与坑</h3><ul><li><strong>GDB不能单步调试内嵌汇编</strong></li><li><strong>输出部和输入部的修饰符不能用错</strong>，否则程序会跑错</li></ul><h3 id="实验3：使用内嵌汇编实现memset函数"><a href="#实验3：使用内嵌汇编实现memset函数" class="headerlink" title="实验3：使用内嵌汇编实现memset函数"></a>实验3：使用内嵌汇编实现memset函数</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250808225407690.png" alt="image-20250808225407690"></p><h3 id="内嵌汇编的高级玩法：和宏结合"><a href="#内嵌汇编的高级玩法：和宏结合" class="headerlink" title="内嵌汇编的高级玩法：和宏结合"></a>内嵌汇编的高级玩法：和宏结合</h3><ul><li>技巧1：使用了C语言的#运算符。在带参数的宏中，“#”运算符作为一个预处理运算符，可以把记号转换为字符串</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250808225815839.png" alt="image-20250808225815839"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, asm_op) \</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v) &#123; \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__( \</span></span><br><span class="line"><span class="meta">        asm_op <span class="string">&quot; %1, %0&quot;</span> \</span></span><br><span class="line"><span class="meta">        : <span class="string">&quot;+m&quot;</span> (v-&gt;counter) \</span></span><br><span class="line"><span class="meta">        : <span class="string">&quot;ir&quot;</span> (i)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以用这个宏来生成多个原子操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC_OP(add, <span class="string">&quot;addl&quot;</span>)</span><br><span class="line">ATOMIC_OP(sub, <span class="string">&quot;subl&quot;</span>)</span><br></pre></td></tr></table></figure><p>这会展开为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;addl %1, %0&quot;</span></span><br><span class="line">        : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span><br><span class="line">        : <span class="string">&quot;ir&quot;</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_sub</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;subl %1, %0&quot;</span></span><br><span class="line">        : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span><br><span class="line">        : <span class="string">&quot;ir&quot;</span> (i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片中的这个宏使用 <code>#asm_op</code> 是因为 <strong>它需要将宏参数 <code>asm_op</code> 转换成字符串字面量</strong>，用于字符串拼接或输出。这种语法叫做 <strong>宏字符串化（stringification）</strong></p><p><code>asm_op</code> 是宏参数，<strong>在宏展开时会替换为你提供的值</strong>（比如 <code>&quot;addl&quot;</code>）。</p><p>它已经是一个字符串，比如你调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC_OP(add, &quot;addl&quot;)</span><br></pre></td></tr></table></figure><p>宏展开后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;addl %1, %0&quot;</span></span><br><span class="line">    : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span><br><span class="line">    : <span class="string">&quot;ir&quot;</span> (i));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ATOMIC_OP(add, addl)</span><br></pre></td></tr></table></figure><p>宏展开后是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">    addl <span class="string">&quot;%1, %0&quot;</span></span><br><span class="line">    : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span><br><span class="line">    : <span class="string">&quot;ir&quot;</span> (i));</span><br></pre></td></tr></table></figure><p>则不是</p><p><code>##name</code> —— <strong>符号连接（token pasting）运算符</strong></p><ul><li><p>把宏参数和前后的标识符直接拼接成一个新的标识符（不是字符串）。</p></li><li><p>常用来生成变量名、函数名等。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_FUNC(name) void func_##name(void) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">MAKE_FUNC(test); <span class="comment">// 展开成：void func_test(void) &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="实验4：使用内嵌汇编与宏的结合"><a href="#实验4：使用内嵌汇编与宏的结合" class="headerlink" title="实验4：使用内嵌汇编与宏的结合"></a>实验4：使用内嵌汇编与宏的结合</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250808230527386.png" alt="image-20250808230527386"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809090720797.png" alt="image-20250809090720797"></p><h3 id="实验5：实现读写系统寄存器的宏"><a href="#实验5：实现读写系统寄存器的宏" class="headerlink" title="实验5：实现读写系统寄存器的宏"></a>实验5：实现读写系统寄存器的宏</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809090751064.png" alt="image-20250809090751064"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809095412295.png" alt="image-20250809095412295"></p><p>这里用到了<strong>GNU C 的语句表达式 (statement expression)</strong> 语法:</p><p><strong><code>(&#123; ... &#125;)</code> 是什么</strong></p><ul><li><p>这是 GNU 扩展，不是标准 C。</p></li><li><p>它让一段代码块既能像语句一样执行，也能<strong>返回一个值</strong>。</p></li><li><p>语法规则：</p><blockquote><p><code>(&#123; statement1; statement2; ...; expression; &#125;)</code><br>代码块里最后的那个 <strong>表达式</strong>（不加分号）就是返回值。</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809101048717.png" alt="image-20250809101048717"></p><h3 id="内嵌汇编：goto"><a href="#内嵌汇编：goto" class="headerlink" title="内嵌汇编：goto"></a>内嵌汇编：goto</h3><blockquote><p>内嵌汇编的goto模板，可以跳转到C语言的label标签里</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809090847056.png" alt="image-20250809090847056"></p><ul><li>Goto模板的输出部必须为空</li><li>新增一个gotolabels的部，里面列出了C语言的label，是允许跳转的label</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809090955403.png" alt="image-20250809090955403"></p><h3 id="实验6：goto模板的内嵌汇编"><a href="#实验6：goto模板的内嵌汇编" class="headerlink" title="实验6：goto模板的内嵌汇编"></a>实验6：goto模板的内嵌汇编</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809091027525.png" alt="image-20250809091027525"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809102425122.png" alt="image-20250809102425122"></p><p><code>%l[label]</code> 是 GCC 内联汇编中 <code>asm goto</code> 语法的特殊写法，表示跳转到 C 代码中的标签 <code>label</code>。</p><p>详细解释：</p><ul><li><code>%l[...]</code> 是告诉编译器这是一个<strong>标签符号</strong>（label），而不是普通的寄存器或立即数。</li><li><code>label</code> 是你在 C 代码里定义的标签名，比如你代码中的 <code>label:</code>。</li><li><code>asm goto</code> 允许汇编代码通过条件跳转直接跳转到 C 代码中的某个标签，实现条件分支。</li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU LD</title>
      <link href="/posts/50001/"/>
      <url>/posts/50001/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h2 id="GNU-LD链接器"><a href="#GNU-LD链接器" class="headerlink" title="GNU LD链接器"></a>GNU LD链接器</h2><div class="tag link"><a class="link-card" title="ld" href="https://sourceware.org/binutils/docs/ld.pdf"><div class="left"><img src="https://sourceware.org/favicon.ico"/></div><div class="right"><p class="text">ld</p><p class="url">https://sourceware.org/binutils/docs/ld.pdf</p></div></a></div><h3 id="链接器Linker"><a href="#链接器Linker" class="headerlink" title="链接器Linker"></a>链接器Linker</h3><ul><li>链接器是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件</li><li>GNU Linker采用AT&amp;T链接脚本语言</li></ul><h4 id="ld命令"><a href="#ld命令" class="headerlink" title="ld命令"></a>ld命令</h4><ul><li>aarch64-linux-gnu-ld</li><li>常用参数<ul><li>-T 指定链接脚本</li><li>-Map 输出一个符号表文件</li><li>-o 输出最终可执行二进制文件</li></ul></li></ul><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">. = 0x10000;</span><br><span class="line">.text : &#123;* (.text)&#125;</span><br><span class="line">. = 0x8000000</span><br><span class="line">.data : &#123;*(.data)&#125;</span><br><span class="line">.bss : &#123;*(.bss)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>输入段(input section)，输出段(output section)</li><li>每个段包括name和大小</li><li>段的属性<ul><li>loadable 运行时会加载这些段的内容到内存</li><li>allocatable 运行时不会加载段的内容</li></ul></li><li>段的地址<ul><li><strong>VMA</strong>(virtual memory address) 虚拟地址，运行时的地址</li><li><strong>LMA</strong>(load memory address) 加载地址</li><li><strong>通常ROM的地址为加载地址，而RAM的地址为VMA</strong></li></ul></li></ul><h4 id="链接脚本命令"><a href="#链接脚本命令" class="headerlink" title="链接脚本命令"></a>链接脚本命令</h4><ul><li>ENTRY(symbol) 设置程序的入口函数</li><li>链接程序有如下几种方式来设置入口点：<ul><li>使用-e参数</li><li>使用ENTRY(symbol)</li><li>在.text的最开始的地方</li><li>0地址</li></ul></li></ul><ul><li>INCLUDE filename 引入filename链接脚本</li><li>OUTPUT filename 输出二进制文件，类似在命令行里使用“-o filename”</li><li>OUTPUT_FORMAT(bfd) 输出BFD格式</li><li>OUTPUT_ARCH(bfdarch) 输出处理器体系结构格式</li></ul><h4 id="符号赋值"><a href="#符号赋值" class="headerlink" title="符号赋值"></a>符号赋值</h4><ul><li>符号也可以像C语言一样赋值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144008126.png" alt="image-20250806144008126"></p><ul><li>“.” 表示location counter，表示当前位置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144044005.png" alt="image-20250806144044005"></p><h4 id="符号的引用"><a href="#符号的引用" class="headerlink" title="符号的引用"></a>符号的引用</h4><ul><li>高级语言中常常需要引用链接脚本定义的符号</li><li>在C语言里，定义一个变量并初始化一个变量。例如 int foo = 100<ul><li>编译器会在符号表定义了一个符号foo</li><li>编译器会在内存中为符号存储100</li></ul></li></ul><ul><li>在链接脚本中定义一个变量<ul><li><strong>链接器仅仅在符号表里定义这个符号，没有分配内存来存储变量的值</strong></li></ul></li><li>访问链接脚本定义的变量：<strong>访问的时变量的地址，不能访问变量的值</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144340025.png" alt="image-20250806144340025"></p><ul><li>我们可以在每个段设置一些符号，以方便C语言访问每个段的起始地址和结束地址</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144449580.png" alt="image-20250806144449580"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144531159.png" alt="image-20250806144531159"></p><h4 id="SECTIONS命令"><a href="#SECTIONS命令" class="headerlink" title="SECTIONS命令"></a>SECTIONS命令</h4><ul><li>SECTIONS命令：告诉链接器如何把输入段(input sections)映射到输出段(output sections)，以及如何在内存中摆放这些输出段</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144744861.png" alt="image-20250806144744861"></p><ul><li>输出section的描述符</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144807073.png" alt="image-20250806144807073"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806153841387.png" alt="image-20250806153841387"></p><h4 id="LMA加载地址"><a href="#LMA加载地址" class="headerlink" title="LMA加载地址"></a>LMA加载地址</h4><ul><li>每个段都有<strong>VMA</strong>（虚拟地址，运行地址）以及<strong>LMA</strong>（加载地址）</li><li>在输出段描述符中<strong>使用”AT”来指定LMA</strong></li><li><strong>如果没有通过”AT”来指定LMA，通常LMA=VMA</strong></li><li>构建<strong>一个基于ROM的映像文件常常会设置输出段的虚拟地址和加载地址不一致</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806154638115.png" alt="image-20250806154638115"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806154806423.png" alt="image-20250806154806423"></p><ul><li>data段的加载地址和链接地址（虚拟地址）不一样，因此程序的初始化需要把data段从ROM的加载地址复制到SDRAM中的虚拟地址中</li><li>数据加载地址在_etext起始的地方，数据段的运行地址是在_data起始的地方，数据段的大小为“_edata-_data”,下面这段代码把数据段从_etext起始的地方复制到_data起始的地方</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806155249116.png" alt="image-20250806155249116"></p><h4 id="常见的内建函数"><a href="#常见的内建函数" class="headerlink" title="常见的内建函数"></a>常见的内建函数</h4><h5 id="ADDR-section"><a href="#ADDR-section" class="headerlink" title="ADDR(section)"></a>ADDR(section)</h5><blockquote><p>返回前面已经定义过的段的VMA地址</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806155401495.png" alt="image-20250806155401495"></p><h5 id="ALIGN-n"><a href="#ALIGN-n" class="headerlink" title="ALIGN(n)"></a>ALIGN(n)</h5><blockquote><p>返回下一个与n字节对齐的地址，它是基于当前的位置(location counter)来计算对齐地址的</p><p>注意这里是n个字节，而不是2^n个字节（与汇编器的.align区分）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806155545710.png" alt="image-20250806155545710"></p><h5 id="SIZEOF-section"><a href="#SIZEOF-section" class="headerlink" title="SIZEOF(section)"></a>SIZEOF(section)</h5><blockquote><p>返回一个段的大小</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806161245829.png" alt="image-20250806161245829"></p><h5 id="MAX-exp1-exp2-MIN-exp1-exp2"><a href="#MAX-exp1-exp2-MIN-exp1-exp2" class="headerlink" title="MAX(exp1, exp2) / MIN(exp1, exp2)"></a>MAX(exp1, exp2) / MIN(exp1, exp2)</h5><blockquote><p>返回两个表达式的最大值或最小值</p></blockquote><h4 id="实验1：打印每个段的内存布局"><a href="#实验1：打印每个段的内存布局" class="headerlink" title="实验1：打印每个段的内存布局"></a>实验1：打印每个段的内存布局</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806161417469.png" alt="image-20250806161417469"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806162136414.png" alt="image-20250806162136414"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806224541291.png" alt="image-20250806224541291"></p><ol><li><strong>链接器导出的符号是地址，不是变量值</strong></li></ol><p>链接脚本中的这些符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_text = .;</span><br></pre></td></tr></table></figure><p>定义的不是变量本身，而是一个 地址标签（symbol address）。在 C 中没有对应“地址标签”的语法，因此只能通过某种“变量”来间接引用这个地址。</p><p>用 char[] 声明它，其实是在说：</p><blockquote><p>“这是一段起始于 _text 的内存区域，我关心的是它的地址，而不是它的具体内容。”</p></blockquote><ol><li><p><strong>char[] 是一种“单位最小”的内存表示，方便做指针运算</strong></p><p>char 是 C 中最小的可寻址单位（1 字节）。</p><p>所以用 char[] 类型，我们就可以直接进行精确的地址操作：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _text[], _etext[];</span><br><span class="line"><span class="type">size_t</span> text_size = _etext - _text;  <span class="comment">// 计算段长度（字节）</span></span><br></pre></td></tr></table></figure><p>如果你写成 int[] 或 void*，这个计算就可能出错，或者无法编译。</p><ol><li>char[] vs char<em> 的差异：<em>*链接器符号是“数组地址”而非指针变量</em></em></li></ol><p>虽然你也可以写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *_text;</span><br></pre></td></tr></table></figure><p>但这其实意味着 _text 是一个“指向字符的变量”，而不是一个地址标签。</p><blockquote><p>char *_text; 说明编译器要去“取变量 _text 的值”，它必须由代码赋值。<br>而 char _text[]; 是“声明链接器会提供这个地址”，不会生成额外符号或变量。</p></blockquote><p>所以推荐使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _text[];</span><br></pre></td></tr></table></figure><h4 id="实验2：加载地址不等于运行地址"><a href="#实验2：加载地址不等于运行地址" class="headerlink" title="实验2：加载地址不等于运行地址"></a>实验2：加载地址不等于运行地址</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806161556892.png" alt="image-20250806161556892"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807221445041.png" alt="image-20250807221445041"></p><p>需要把代码从装载地址拷贝到运行地址</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807221516225.png" alt="image-20250807221516225"></p><h4 id="实验3：分析Linux5-0内核的链接脚本"><a href="#实验3：分析Linux5-0内核的链接脚本" class="headerlink" title="实验3：分析Linux5.0内核的链接脚本"></a>实验3：分析Linux5.0内核的链接脚本</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806161726598.png" alt="image-20250806161726598"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807221613565.png" alt="image-20250807221613565"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807221621624.png" alt="image-20250807221621624"></p><h4 id="运行地址，装载地址，链接地址"><a href="#运行地址，装载地址，链接地址" class="headerlink" title="运行地址，装载地址，链接地址"></a>运行地址，装载地址，链接地址</h4><h5 id="链接地址（Link-Address）"><a href="#链接地址（Link-Address）" class="headerlink" title="链接地址（Link Address）"></a>链接地址（Link Address）</h5><p>定义：</p><blockquote><p> 编译器和链接器在生成可执行文件（如 ELF 文件）时，为各段（如 .text, .data, .bss 等）分配的地址。</p></blockquote><p>特征：</p><ul><li>是编译阶段由 链接器设定的地址。</li><li>可以通过链接脚本 (ld script) 显式设置，比如 . = 0x80000;。</li><li>可执行文件中的节表（section headers）或段表（program headers）中就记录了这些地址。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text : &#123; *(.text) &#125; &gt; 0x80000</span><br></pre></td></tr></table></figure><p>表示 .text 段的 链接地址是 0x80000。</p><h5 id="装载地址（Load-Address）"><a href="#装载地址（Load-Address）" class="headerlink" title="装载地址（Load Address）"></a>装载地址（Load Address）</h5><p>定义：</p><blockquote><p>可执行文件中的内容被加载到内存中的位置，也就是 操作系统/bootloader 将文件装入内存的位置。</p></blockquote><p>特征：</p><ul><li>通常等于链接地址，但在某些情况下（如动态链接、加载地址重定位）可以不同。</li><li>由 操作系统或 bootloader 决定，也可以通过 objcopy 等工具进行重新定位。</li></ul><p>例子：</p><ul><li>你的 ELF 文件 .text 段链接地址是 0x80000，bootloader 将它加载到 0x100000，那么：<ul><li>链接地址 ≠ 装载地址</li><li>如果没有做重定位，程序运行会出错（因为代码中有绝对地址）</li></ul></li></ul><h5 id="运行地址（Runtime-Execution-Address）"><a href="#运行地址（Runtime-Execution-Address）" class="headerlink" title="运行地址（Runtime/Execution Address）"></a>运行地址（Runtime/Execution Address）</h5><p>定义：</p><blockquote><p>程序在执行时，CPU 实际访问的内存地址。</p></blockquote><p>特征：</p><ul><li><p>通常 = 装载地址（程序加载到哪里就从哪里执行）</p></li><li><p>如果启用了 MMU（内存管理单元），运行地址是虚拟地址，由 MMU 映射到物理装载地址。</p></li><li><p>在裸机程序中，一般 = 链接地址 = 装载地址 = 运行地址。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU AS</title>
      <link href="/posts/50000/"/>
      <url>/posts/50000/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>参考文档：</p><div class="tag link"><a class="link-card" title="gas" href="https://sourceware.org/binutils/docs/as.pdf"><div class="left"><img src="https://sourceware.org/favicon.ico"/></div><div class="right"><p class="text">gas</p><p class="url">https://sourceware.org/binutils/docs/as.pdf</p></div></a></div><p>ARM64的汇编器</p><ul><li>ARM公司的官方的汇编器</li><li>GNU AS汇编器：aarch64-linux-gnu-as</li><li>gcc采用as作为其汇编器，所以汇编代码是AT&amp;T的<ul><li>AT&amp;T：源自贝尔实验室，为开发UNIX系统而产生的汇编语法</li><li>ARM格式：arm官方汇编语法</li></ul></li></ul><h3 id="汇编语法"><a href="#汇编语法" class="headerlink" title="汇编语法"></a>汇编语法</h3><ul><li>label: <strong>任何以冒号结尾的标识符都被认为是一个标号</strong></li><li><strong>注释</strong>：<ul><li>// 表示注释</li><li># 在一行的开始，表示注释整行</li></ul></li><li>指令，伪指令，寄存器可以全部都是大写或者小写，GNU风格默认小写</li></ul><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><blockquote><p>代表它所在的地址，也可以当作变量或者函数来使用</p></blockquote><ul><li>全局symbol, 可以用.global来声明</li><li>局部symbol，主要在局部范围内使用，开头以0-99直接的数字为标号名，通常和b指令结合使用</li><li>f: 指示编译向前搜索</li><li>b:指示编译器向后搜索</li></ul><h4 id="对齐伪指令"><a href="#对齐伪指令" class="headerlink" title="对齐伪指令"></a>对齐伪指令</h4><ul><li>.align对齐，填充数据来实现对齐。可以填充0或者使用nop指令。<ul><li>告诉汇编程序,align后面的汇编必须从下一个能被2^n整除的地址开始分配</li><li>ARM64系统中，第一个参数表示2^n大小</li></ul></li></ul><h4 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h4><h5 id="整数与浮点伪指令汇总"><a href="#整数与浮点伪指令汇总" class="headerlink" title="整数与浮点伪指令汇总"></a>整数与浮点伪指令汇总</h5><div class="table-container"><table><thead><tr><th>指令</th><th>数据类型/作用</th><th>字节数</th><th>补充说明</th></tr></thead><tbody><tr><td><code>.byte</code></td><td>定义 8 位整数</td><td>1 B</td><td>通常用于字符、控制位</td></tr><tr><td><code>.hword</code></td><td>定义 16 位整数（half-word）</td><td>2 B</td><td>某些架构中也叫<code>.short</code></td></tr><tr><td><code>.int</code>/<code>.long</code></td><td>定义 32 位整数</td><td>4 B</td><td><code>.int</code> 是别名，效果一样</td></tr><tr><td><code>.quad</code></td><td>定义 64 位整数（quad-word）</td><td>8 B</td><td>在 AArch64 中非常常用</td></tr><tr><td><code>.float</code></td><td>定义 IEEE-754 单精度浮点数（32 位）</td><td>4 B</td><td>等价于 C 语言中的 <code>float</code></td></tr></tbody></table></div><h5 id="字符串定义伪指令"><a href="#字符串定义伪指令" class="headerlink" title="字符串定义伪指令"></a>字符串定义伪指令</h5><div class="table-container"><table><thead><tr><th>指令</th><th>功能说明</th></tr></thead><tbody><tr><td><code>.ascii &quot;str&quot;</code></td><td>将字符串原样插入，不自动添加 <code>\0</code>，适用于非 C 风格字符串</td></tr><tr><td><code>.asciz &quot;str&quot;</code></td><td>在字符串末尾<strong>自动追加一个空字符 <code>\0</code></strong>，适用于 C 字符串（推荐）</td></tr></tbody></table></div><h5 id="rept-…-endr：重复块定义"><a href="#rept-…-endr：重复块定义" class="headerlink" title=".rept … .endr：重复块定义"></a>.rept … .endr：重复块定义</h5><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rept &lt;count&gt;</span><br><span class="line">  &lt;内容&gt;</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure><p>作用：重复某段汇编代码或数据定义若干次，适用于初始化数组或填充空间。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rept 3</span><br><span class="line">    .long 0</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure><p> 等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.long 0</span><br><span class="line">.long 0</span><br><span class="line">.long 0</span><br></pre></td></tr></table></figure><h5 id="equ-set：常量定义（赋值操作）"><a href="#equ-set：常量定义（赋值操作）" class="headerlink" title=".equ / .set：常量定义（赋值操作）"></a>.equ / .set：常量定义（赋值操作）</h5><p>这两个指令完全等价，只是语法风格略不同。<br> .equ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.equ abcd, 0x45</span><br></pre></td></tr></table></figure><p> 让 abcd 成为 常量宏定义，值为 0x45。<br> .set</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.set abcd, 0x45</span><br></pre></td></tr></table></figure><p> 同样效果，也定义 abcd 为 0x45。</p><p>典型用途：用于定义寄存器地址、常量位掩码等。<br>常见用法示例（结合 .equ 与 .rept）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.equ LED_BASE, 0x3F200000</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">.rept 4</span><br><span class="line">    .int LED_BASE</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure><p>表示将 LED_BASE 这个地址填充 4 次，每次 4 字节，共 16 字节。</p><p><code>.equ</code> 与 C 的 <code>#define</code> 区别：</p><div class="table-container"><table><thead><tr><th><code>.equ</code> / <code>.set</code></th><th><code>#define</code></th></tr></thead><tbody><tr><td>汇编阶段赋值，数值不可变</td><td>预处理阶段文本替换</td></tr><tr><td>可用于表达式（如 <code>.equ val, 4+5</code>）</td><td>只做文本拼接</td></tr><tr><td>不可用于条件编译</td><td>可与 <code>#ifdef</code> 等配合使用</td></tr></tbody></table></div><h5 id="函数相关的伪指令"><a href="#函数相关的伪指令" class="headerlink" title="函数相关的伪指令"></a>函数相关的伪指令</h5><div class="table-container"><table><thead><tr><th>伪操作</th><th>作用说明</th></tr></thead><tbody><tr><td><code>.global</code></td><td>定义一个全局的符号</td></tr><tr><td><code>.include</code></td><td>引用头文件</td></tr><tr><td><code>.if .else .endif</code></td><td>控制语句结构，用于条件编译</td></tr></tbody></table></div><h5 id="if语句伪操作"><a href="#if语句伪操作" class="headerlink" title="if语句伪操作"></a>if语句伪操作</h5><div class="table-container"><table><thead><tr><th>指令</th><th>含义说明</th></tr></thead><tbody><tr><td><code>.ifdef symbol</code></td><td>判断 <code>symbol</code> 是否已定义</td></tr><tr><td><code>.ifndef symbol</code></td><td>判断 <code>symbol</code> 是否<strong>未</strong>定义</td></tr><tr><td><code>.ifc str1,str2</code></td><td>判断字符串 <code>str1</code> 与 <code>str2</code> 是否相等</td></tr><tr><td><code>.ifeq expr</code></td><td>判断表达式 <code>expr</code> 的值是否为 0</td></tr><tr><td><code>.ifeqs str1,str2</code></td><td>等价于 <code>.ifc str1,str2</code></td></tr><tr><td><code>.ifge expr</code></td><td>判断表达式 <code>expr</code> 的值是否 ≥ 0</td></tr><tr><td><code>.ifle expr</code></td><td>判断表达式 <code>expr</code> 的值是否 ≤ 0</td></tr><tr><td><code>.ifne expr</code></td><td>判断表达式 <code>expr</code> 的值是否 ≠ 0</td></tr></tbody></table></div><h5 id="与段相关的伪操作"><a href="#与段相关的伪操作" class="headerlink" title="与段相关的伪操作"></a>与段相关的伪操作</h5><ul><li>.section 表示接下来的汇编会链接到哪个段里，例如代码段，数据段等</li><li>每一个段以段名为开始，以下一个段名或者文件尾为结束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section name, &quot;flags&quot;</span><br></pre></td></tr></table></figure><p>后面可以添加flags，表示段的属性</p><div class="table-container"><table><thead><tr><th>标志</th><th>含义说明</th></tr></thead><tbody><tr><td><code>a</code></td><td><strong>allocatable</strong>：该段在运行时需要被加载到内存中。</td></tr><tr><td><code>d</code></td><td><strong>GNU_MBIND section</strong>：GNU 使用的特殊绑定段。</td></tr><tr><td><code>e</code></td><td><strong>excluded</strong>：该段不会被包含在可执行文件或共享库中。</td></tr><tr><td><code>w</code></td><td><strong>writable</strong>：该段可写。</td></tr><tr><td><code>x</code></td><td><strong>executable</strong>：该段包含可执行代码。</td></tr><tr><td><code>M</code></td><td><strong>mergeable</strong>：可以和其他具有相同属性的段合并（通常用于只读字符串等）。</td></tr><tr><td><code>S</code></td><td><strong>string</strong>：该段包含以 0 结尾的字符串。</td></tr><tr><td><code>G</code></td><td><strong>group</strong>：该段属于某个 section group（如 COMDAT）。</td></tr><tr><td><code>T</code></td><td><strong>thread-local-storage</strong>：该段用于线程局部存储（TLS）。</td></tr><tr><td><code>?</code></td><td><strong>unspecified group</strong>：该段属于前一个 section 的 group（如果有的话）。</td></tr></tbody></table></div><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section &quot;.idmap.text&quot;,&quot;awx&quot;</span><br></pre></td></tr></table></figure><p><code>.pushsection &lt;name&gt;</code><br> 将接下来的代码或数据<strong>插入到指定的 section（段）中</strong>，同时<strong>保存当前 section 状态</strong>。</p><p><code>.popsection</code><br> 表示<strong>结束前面的 push</strong>，并<strong>恢复原来的 section</strong>。</p><ul><li><p><strong>成对使用</strong>。</p></li><li><p>作用仅在 <code>pushsection</code> 和 <code>popsection</code> 之间的代码，对其他代码没有影响。</p></li><li><p>其余代码仍然属于原先的段，比如 <code>.text</code> 或 <code>.data</code>。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .globl _start</span><br><span class="line">_start:</span><br><span class="line">    nop             // 在默认的 .text 段中</span><br><span class="line"></span><br><span class="line">    .pushsection .mydata, &quot;a&quot;</span><br><span class="line">    .long 0x12345678  // 被插入到 .mydata 段中</span><br><span class="line">    .popsection</span><br><span class="line">    </span><br><span class="line">    nop             // 又回到 .text 段</span><br></pre></td></tr></table></figure><p><code>_start</code> 和两个 <code>nop</code> 都属于 <code>.text</code> 段；</p><p><code>.long 0x12345678</code> 被插入到了自定义的 <code>.mydata</code> 段中。</p><h5 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h5><ul><li>.macro和.endm组成一个宏</li><li>.macro后面跟着的是宏的名称，在后面是宏的参数</li><li>在宏里使用参数，需要添加前缀“\”</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.macro plus1 p, p1</span><br></pre></td></tr></table></figure><blockquote><p>定义了一个名为plus1的宏，有两个参数p和p1</p><p>在宏里使用参数需要前缀,”\p”表示第一个参数,”\p1”属于第二个参数</p></blockquote><ul><li>宏参数定义的时候可以设置一个初始化值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.macro reserve_str p1=0 p2</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数p1有一个初始化的值，0。这个时候可以使用reserve_str a,b或者reserve_str, b来调用这个宏</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250805162753780.png" alt="image-20250805162753780"></p><p>解决办法：</p><ul><li>使用空格或者使用altmacro+&amp;</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250805162907493.png" alt="image-20250805162907493"></p><ul><li>使用”\()“表示连接（）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250805163001419.png" alt="image-20250805163001419"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250805163128544.png" alt="image-20250805163128544"></p><h4 id="ARM64特有的特性"><a href="#ARM64特有的特性" class="headerlink" title="ARM64特有的特性"></a>ARM64特有的特性</h4><h5 id="ARM64编译选项"><a href="#ARM64编译选项" class="headerlink" title="ARM64编译选项"></a>ARM64编译选项</h5><ul><li>-EB：用于大端模式的CPU，-EL：用于小端模式的CPU</li><li>-mabi：指定ABI模式，ilp32用于ELF32，lp64用于ELF64，默认值为lp64</li><li>-mcpu=processor+extension：指定CPU型号，例如cortex-a72</li><li>-march=，用于指定支持的架构，例如armv8.2-a</li><li>ARM64支持的extension，见GNU汇编器as_v2.34 9.1.2章</li></ul><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><ul><li>//表示注释</li><li><h1 id="若在一行开始表示注释，不在一行开始也可表示立即数"><a href="#若在一行开始表示注释，不在一行开始也可表示立即数" class="headerlink" title="若在一行开始表示注释，不在一行开始也可表示立即数"></a>若在一行开始表示注释，不在一行开始也可表示立即数</h1></li><li><h1 id="low12-表示低12位"><a href="#low12-表示低12位" class="headerlink" title=":low12 表示低12位"></a>:low12 表示低12位</h1></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp x0, foo</span><br><span class="line">ldr x0, [x0, #:lo12:foo]</span><br></pre></td></tr></table></figure><ul><li>ldr伪操作</li><li>.bss 切换到bss段</li><li>.dword/.xword 64位数据</li><li>name .reg register_name 为寄存器命名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo .req w0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P88 合并两个有序数组</title>
      <link href="/posts/88/"/>
      <url>/posts/88/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P88 合并两个有序数组" href="https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P88 合并两个有序数组</p><p class="url">https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>这题其实可以原地合并，因为 num1 后 n 个元素为 0，可以从后往前合并。但下面的代码未考虑到这点。<br>注意 std::move，它其实是将参数 t 转换为一个右值引用类型，不会拷贝内存，不会释放资源，不会调用构造函数和析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 std::vector<int> 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; b = std::<span class="built_in">move</span>(a);</span><br></pre></td></tr></table></figure><p>这里：std::move(a) 把 a 变成右值引用。编译器会选择 vector 的移动构造函数，而不是拷贝构造。<br>移动构造函数做的事：</p><ul><li>把 a 的内部指针直接“偷走”，交给 b。</li><li>把 a 的指针设为空，避免析构时释放同一块内存。</li></ul><p>所以最后：b 持有 {1,2,3} 的数据。a 变成空的（size()==0，但仍然是合法对象）</p><p>总结：<br>  nums1 = std::move(vec);</p><ul><li>旧内容自动释放（移动赋值内部完成）</li><li>新内容接管</li><li>vec 变空<br>不需要自己手动调用析构函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt;= nums2[j])</span><br><span class="line">          vec.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          vec.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; m &amp;&amp; j &gt;= n) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums1 = std::<span class="built_in">move</span>(vec);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P812 最大三角形面积</title>
      <link href="/posts/812/"/>
      <url>/posts/812/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P812 最大三角形面积" href="https://leetcode.cn/problems/largest-triangle-area/?envType=daily-question&envId=2025-09-27"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P812 最大三角形面积</p><p class="url">https://leetcode.cn/problems/largest-triangle-area/?envType=daily-question&envId=2025-09-27</p></div></a></div></p><p>此题不用考虑太多，主要是考察几何知识，直接枚举即可。<br>三角形计算面积为：</p><script type="math/tex; mode=display">S = \frac{1}{2} \left| x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) \right|</script><p>假设这三个点，第一个点i在points数组左边，第二个点的数组位置位于两点之间，第三个点在右边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">largestTriangleArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> x1, x2, x3;</span><br><span class="line">    <span class="type">int</span> y1, y2, y3;</span><br><span class="line">    <span class="type">double</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> area;</span><br><span class="line"></span><br><span class="line">    n = points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">          x1 = points[i][<span class="number">0</span>];</span><br><span class="line">          x2 = points[j][<span class="number">0</span>];</span><br><span class="line">          x3 = points[k][<span class="number">0</span>];</span><br><span class="line">          y1 = points[i][<span class="number">1</span>];</span><br><span class="line">          y2 = points[j][<span class="number">1</span>];</span><br><span class="line">          y3 = points[k][<span class="number">1</span>];</span><br><span class="line">          area =</span><br><span class="line">              <span class="number">0.5</span> * std::<span class="built_in">fabs</span>(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));</span><br><span class="line">          <span class="keyword">if</span> (area &gt; max_area) &#123;</span><br><span class="line">            max_area = area;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P611 有效三角形的个数</title>
      <link href="/posts/611/"/>
      <url>/posts/611/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-26</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P611 有效三角形的个数" href="https://leetcode.cn/problems/valid-triangle-number/description/?envType=daily-question&envId=2025-09-26"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P611 有效三角形的个数</p><p class="url">https://leetcode.cn/problems/valid-triangle-number/description/?envType=daily-question&envId=2025-09-26</p></div></a></div></p><p>此题固定套路是先固定最大的边，然后通过双指针一个从前向后(表示最小边)，一个从后向前(表示次大边)，如果前面那个指针指向的值和后面那个指针指向的值加起来满足了三角形构成条件，那么最小边可以取两个指针之间的任意值，然后可以令次大的边变小些，看是否满足。如果不满足，说明最小的边太小了，让最小的边变大些，因为是最小边，所以其值不能大于次大边。两个指针相遇时，说明已经遍历完了最大边是当前固定的最大边时的情况，此时令最大边小些，然后最小边和次大边重新开始遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数</span></span><br><span class="line">  <span class="comment">// 1 &lt;= nums.length &lt;= 1000</span></span><br><span class="line">  <span class="comment">// 0 &lt;= nums[i] &lt;= 1000</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">triangleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三角形两边之和大于第三边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(nums)</span></span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 去重,去重前需要先排序</span></span><br><span class="line">    <span class="comment">// vec.erase(std::unique(vec.begin(), vec.end()), vec.end());</span></span><br><span class="line"></span><br><span class="line">    n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 先固定最大边,k为三角形中最大的边,其次是j,i是最小的</span></span><br><span class="line">    <span class="keyword">for</span> (k = n - <span class="number">1</span>; k &gt;= <span class="number">2</span>; k--) &#123;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      j = k - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] &gt; nums[k]) &#123;</span><br><span class="line">          <span class="comment">// 因为j是从k-1向前遍历,i从0向后遍历</span></span><br><span class="line">          <span class="comment">// 所以如果 nums[i] + nums[j] &gt; nums[k]</span></span><br><span class="line">          <span class="comment">// 所有 [i,j-1] 都和 j, k 可以组成三角形</span></span><br><span class="line">          res += (j - i);</span><br><span class="line">          --j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不满足三角形构成条件说明i太小了</span></span><br><span class="line">          <span class="comment">// 令i++,直到i==j时退出循环</span></span><br><span class="line">          <span class="comment">// 因为此时k和j固定,任何一个i都无法满足三角形构成条件</span></span><br><span class="line">          <span class="comment">// 说明k太大了,令k--</span></span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P166 分数到小数</title>
      <link href="/posts/166/"/>
      <url>/posts/166/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P166 分数到小数" href="https://leetcode.cn/problems/fraction-to-recurring-decimal/description/?envType=daily-question&envId=2025-09-26"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P166 分数到小数</p><p class="url">https://leetcode.cn/problems/fraction-to-recurring-decimal/description/?envType=daily-question&envId=2025-09-26</p></div></a></div></p><p>我采用模拟的方法，拼尽全力终于战胜，特殊情况太多了，最好是用 gdb 一次次调试发现代码中没有考虑到的地方再完善。<br>注意不要先除以最大公因数，因为最大公因数的计算时间复杂度要高于长除法。<br>此外最好先计算整数部分，再计算小数部分，我的这个解法没有考虑这个导致代码有点复杂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> dividend;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> divisor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> quotient;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> reminder;</span><br><span class="line">    <span class="type">int</span> dot = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> bracket = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 记录结果</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res_vec;</span><br><span class="line">    <span class="comment">// 记录numerator的每一位</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numerator_vec;</span><br><span class="line">    <span class="comment">// 记录所有被除数</span></span><br><span class="line">    unordered_map&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; div_map;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0除以任何数都为0</span></span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((numerator &lt; <span class="number">0</span> &amp;&amp; denominator &gt; <span class="number">0</span>) ||</span><br><span class="line">        (numerator &gt; <span class="number">0</span> &amp;&amp; denominator &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">      negative = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不用abs主要是因为abs返回的是unsigned int存在范围问题</span></span><br><span class="line">    dividend = std::<span class="built_in">llabs</span>((<span class="type">long</span> <span class="type">long</span>)numerator);</span><br><span class="line">    divisor = std::<span class="built_in">llabs</span>((<span class="type">long</span> <span class="type">long</span>)denominator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先都除以最大公因数</span></span><br><span class="line">    <span class="comment">// n = std::gcd(dividend, divisor);</span></span><br><span class="line">    <span class="comment">// dividend /= n;</span></span><br><span class="line">    <span class="comment">// divisor /= n;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将numerator每一位放入numerator_vec中</span></span><br><span class="line">    <span class="keyword">while</span> (dividend != <span class="number">0</span>) &#123;</span><br><span class="line">      numerator_vec.<span class="built_in">insert</span>(numerator_vec.<span class="built_in">begin</span>(), dividend % <span class="number">10</span>);</span><br><span class="line">      dividend /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dividend = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 高精度除法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个被除数</span></span><br><span class="line">    n = numerator_vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; dividend &lt; divisor) &#123;</span><br><span class="line">      dividend = dividend * <span class="number">10</span> + numerator_vec[i];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 记录被除数</span></span><br><span class="line">      <span class="keyword">if</span> (div_map.<span class="built_in">find</span>(dividend) != div_map.<span class="built_in">end</span>() &amp;&amp; dot &gt; <span class="number">0</span>) &#123; <span class="comment">// 重复了</span></span><br><span class="line">        bracket = div_map[dividend];                            <span class="comment">// 重复的位置</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        div_map[dividend] = res_vec.<span class="built_in">size</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 商 = 被除数/除数</span></span><br><span class="line">      quotient = dividend / divisor;</span><br><span class="line">      <span class="comment">// 余数 = 被除数/除数</span></span><br><span class="line">      reminder = dividend % divisor;</span><br><span class="line">      res_vec.<span class="built_in">push_back</span>(quotient);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &lt; numerator_vec.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        dividend = reminder * <span class="number">10</span> + numerator_vec[i];</span><br><span class="line">        i++;</span><br><span class="line">        reminder = <span class="number">1</span>; <span class="comment">// 防止退出循环</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dividend = reminder * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (dot &lt; <span class="number">0</span>)</span><br><span class="line">          dot = res_vec.<span class="built_in">size</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (reminder != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bracket &gt;= <span class="number">0</span> &amp;&amp; dot &gt; <span class="number">0</span> &amp;&amp; bracket &lt; dot) &#123;</span><br><span class="line">      n = dot - bracket;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res_vec.<span class="built_in">push_back</span>(res_vec[i + bracket]);</span><br><span class="line">      &#125;</span><br><span class="line">      bracket = dot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = res_vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 构建字符串</span></span><br><span class="line">    <span class="keyword">if</span> (negative) &#123;</span><br><span class="line">      res += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == dot) &#123;</span><br><span class="line">        res += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == bracket) &#123;</span><br><span class="line">        res += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      res += <span class="string">&#x27;0&#x27;</span> + res_vec[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bracket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      res += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution s;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">420</span>, <span class="number">226</span>).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">-22</span>, <span class="number">-2</span>).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">500</span>, <span class="number">10</span>).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">4</span>, <span class="number">333</span>).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">50</span>, <span class="number">8</span>).<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>官方方法也是模拟长除法，但不同的是我是记录了被除数，这个解法记录的是余数从而判断是否产生了循环小数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> numeratorLong = numerator;</span><br><span class="line">        <span class="type">long</span> denominatorLong = denominator;</span><br><span class="line">        <span class="keyword">if</span> (numeratorLong % denominatorLong == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(numeratorLong / denominatorLong);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span> (numeratorLong &lt; <span class="number">0</span> ^ denominatorLong &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整数部分</span></span><br><span class="line">        numeratorLong = <span class="built_in">abs</span>(numeratorLong);</span><br><span class="line">        denominatorLong = <span class="built_in">abs</span>(denominatorLong);</span><br><span class="line">        <span class="type">long</span> integerPart = numeratorLong / denominatorLong;</span><br><span class="line">        ans += <span class="built_in">to_string</span>(integerPart);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小数部分</span></span><br><span class="line">        string fractionPart;</span><br><span class="line">        unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; remainderIndexMap;</span><br><span class="line">        <span class="type">long</span> remainder = numeratorLong % denominatorLong;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span> &amp;&amp; !remainderIndexMap.<span class="built_in">count</span>(remainder)) &#123;</span><br><span class="line">            remainderIndexMap[remainder] = index;</span><br><span class="line">            remainder *= <span class="number">10</span>;</span><br><span class="line">            fractionPart += <span class="built_in">to_string</span>(remainder / denominatorLong);</span><br><span class="line">            remainder %= denominatorLong;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123; <span class="comment">// 有循环节</span></span><br><span class="line">            <span class="type">int</span> insertIndex = remainderIndexMap[remainder];</span><br><span class="line">            fractionPart = fractionPart.<span class="built_in">substr</span>(<span class="number">0</span>,insertIndex) + <span class="string">&#x27;(&#x27;</span> + fractionPart.<span class="built_in">substr</span>(insertIndex);</span><br><span class="line">            fractionPart.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += fractionPart;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P165 比较版本号</title>
      <link href="/posts/165/"/>
      <url>/posts/165/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P165 比较版本号" href="https://leetcode.cn/problems/compare-version-numbers/description/?envType=daily-question&envId=2025-09-23"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P165 比较版本号</p><p class="url">https://leetcode.cn/problems/compare-version-numbers/description/?envType=daily-question&envId=2025-09-23</p></div></a></div><br>这题比较简单，不过还是注意下 stringstream 的用法吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="type">int</span> revision_number;</span><br><span class="line">    string revision_number_str;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec1, vec2;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(version1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, revision_number_str, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        revision_number = std::<span class="built_in">stoi</span>(revision_number_str);</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception e) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;illegal input: %s\n&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      vec<span class="number">1.</span><span class="built_in">push_back</span>(revision_number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖缓冲区内容</span></span><br><span class="line">    ss.<span class="built_in">str</span>(version2);</span><br><span class="line">    <span class="comment">// 重置状态位</span></span><br><span class="line">    ss.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, revision_number_str, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        revision_number = std::<span class="built_in">stoi</span>(revision_number_str);</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception e) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Illegal input: %s\n&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      vec<span class="number">2.</span><span class="built_in">push_back</span>(revision_number);</span><br><span class="line">    &#125;</span><br><span class="line">    n = vec<span class="number">1.</span><span class="built_in">size</span>() &gt; vec<span class="number">2.</span><span class="built_in">size</span>() ? vec<span class="number">1.</span><span class="built_in">size</span>() : vec<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// 赋值</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; vec<span class="number">1.</span><span class="built_in">size</span>())</span><br><span class="line">        v1 = vec1[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; vec<span class="number">2.</span><span class="built_in">size</span>())</span><br><span class="line">        v2 = vec2[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (v1 &lt; v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 &gt; v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3005 最大频率元素计数</title>
      <link href="/posts/3005/"/>
      <url>/posts/3005/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-22</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3005 最大频率元素计数" href="https://leetcode.cn/problems/count-elements-with-maximum-frequency/description/?envType=daily-question&envId=2025-09-22"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3005 最大频率元素计数</p><p class="url">https://leetcode.cn/problems/count-elements-with-maximum-frequency/description/?envType=daily-question&envId=2025-09-22</p></div></a></div></p><p>这题主要利用数组下标作为元素的标识，数组元素记录频率。<br>第一次遍历记录所有元素的频率，第二次遍历找到频率的最大值，第三次遍历将所有最大值频率的相加。总体复杂度 O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 1 &lt;= nums[i] &lt;= 100</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxFrequencyElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> max = INT_MIN;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">memset</span>(array, <span class="number">0</span>, <span class="number">101</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      array[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">        max = array[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] == max) &#123;</span><br><span class="line">        res += array[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P1912 设计电影租界系统</title>
      <link href="/posts/1912/"/>
      <url>/posts/1912/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-21</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="p1912 设计电影租界系统" href="https://leetcode.cn/problems/design-movie-rental-system/description/?envType=daily-question&envId=2025-09-21"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">p1912 设计电影租界系统</p><p class="url">https://leetcode.cn/problems/design-movie-rental-system/description/?envType=daily-question&envId=2025-09-21</p></div></a></div></p><p>题目给的n个商店没有用到，思路主要是用利用set的有序性，将排序时间放入到插入删除中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::set;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> shop;</span><br><span class="line">  <span class="type">int</span> movie;</span><br><span class="line">  <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Movie &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (price != other.price)</span><br><span class="line">      <span class="keyword">return</span> price &lt; other.price;</span><br><span class="line">    <span class="keyword">if</span> (shop != other.shop)</span><br><span class="line">      <span class="keyword">return</span> shop &lt; other.shop;</span><br><span class="line">    <span class="keyword">return</span> movie &lt; other.movie;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovieRentingSystem</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// map&lt;movies, map&lt;shop,price&gt;&gt; 存放全局数据data map</span></span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dmap;</span><br><span class="line">  <span class="comment">// map&lt;movie, set&lt;Movie&gt;&gt; 未借出的map</span></span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, set&lt;Movie&gt;&gt; umap;</span><br><span class="line">  <span class="comment">// set&lt;Movies&gt; 表示已经借出</span></span><br><span class="line">  set&lt;Movie&gt; rented;</span><br><span class="line">  <span class="comment">// set&lt;Movies&gt; 表示未借出</span></span><br><span class="line">  set&lt;Movie&gt; unrented;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> shop_num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// [shopi, moviei, pricei]</span></span><br><span class="line">  <span class="built_in">MovieRentingSystem</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;entries) &#123;</span><br><span class="line">    <span class="type">int</span> shop, movie, price;</span><br><span class="line">    shop_num = n;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; vec : entries) &#123;</span><br><span class="line">      shop = vec[<span class="number">0</span>];</span><br><span class="line">      movie = vec[<span class="number">1</span>];</span><br><span class="line">      price = vec[<span class="number">2</span>];</span><br><span class="line">      <span class="comment">// 全局数据</span></span><br><span class="line">      dmap[movie][shop] = price;</span><br><span class="line">      <span class="comment">// 未租赁的set</span></span><br><span class="line">      unrented.<span class="built_in">insert</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">      <span class="comment">// 未租赁的map</span></span><br><span class="line">      umap[movie].<span class="built_in">insert</span>(&#123;&#123;shop, movie, price&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到拥有指定电影且 未借出 的商店中 最便宜的 5 个</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">search</span><span class="params">(<span class="type">int</span> movie)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    set&lt;Movie&gt; &amp;tmp_set = umap[movie];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tmp_set.<span class="built_in">begin</span>(); it != tmp_set.<span class="built_in">end</span>() &amp;&amp; cnt &lt; <span class="number">5</span>;</span><br><span class="line">         it++, cnt++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(it-&gt;shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从指定商店借出指定电影，题目保证指定电影在指定商店未借出</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rent</span><span class="params">(<span class="type">int</span> shop, <span class="type">int</span> movie)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> price = dmap[movie][shop];</span><br><span class="line">    rented.<span class="built_in">insert</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    unrented.<span class="built_in">erase</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    umap[movie].<span class="built_in">erase</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    <span class="keyword">if</span> (umap[movie].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      umap.<span class="built_in">erase</span>(movie);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在指定商店返还 之前已借出 的指定电影</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">drop</span><span class="params">(<span class="type">int</span> shop, <span class="type">int</span> movie)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> price = dmap[movie][shop];</span><br><span class="line">    unrented.<span class="built_in">insert</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    rented.<span class="built_in">erase</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    umap[movie].<span class="built_in">insert</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回 最便宜的 5 部已借出电影 （可能有重复的电影 ID）</span></span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">report</span>() &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = rented.<span class="built_in">begin</span>(); it != rented.<span class="built_in">end</span>() &amp;&amp; cnt &lt; <span class="number">5</span>; it++, cnt++) &#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(it-&gt;shop);</span><br><span class="line">      vec.<span class="built_in">push_back</span>(it-&gt;movie);</span><br><span class="line">      res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovieRentingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovieRentingSystem* obj = new MovieRentingSystem(n, entries);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;search(movie);</span></span><br><span class="line"><span class="comment"> * obj-&gt;rent(shop,movie);</span></span><br><span class="line"><span class="comment"> * obj-&gt;drop(shop,movie);</span></span><br><span class="line"><span class="comment"> * vector&lt;vector&lt;int&gt;&gt; param_4 = obj-&gt;report();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出辅助函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">vec_to_str</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    s += std::<span class="built_in">to_string</span>(v[i]);</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> != v.<span class="built_in">size</span>())</span><br><span class="line">      s += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">mat_to_str</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    s += <span class="built_in">vec_to_str</span>(m[i]);</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> != m.<span class="built_in">size</span>())</span><br><span class="line">      s += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; entries = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line">  vector&lt;string&gt; outputs;</span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="function">MovieRentingSystem <span class="title">obj</span><span class="params">(<span class="number">3</span>, entries)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// search(1)</span></span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="built_in">vec_to_str</span>(obj.<span class="built_in">search</span>(<span class="number">1</span>)));</span><br><span class="line">  <span class="comment">// rent(0,1)</span></span><br><span class="line">  obj.<span class="built_in">rent</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="comment">// rent(1,2)</span></span><br><span class="line">  obj.<span class="built_in">rent</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="comment">// report()</span></span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="built_in">mat_to_str</span>(obj.<span class="built_in">report</span>()));</span><br><span class="line">  <span class="comment">// drop(1,2)</span></span><br><span class="line">  obj.<span class="built_in">drop</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="comment">// search(2)</span></span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="built_in">vec_to_str</span>(obj.<span class="built_in">search</span>(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印最终结果</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; outputs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    cout &lt;&lt; outputs[i];</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> != outputs.<span class="built_in">size</span>())</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3508 设计路由器</title>
      <link href="/posts/3508/"/>
      <url>/posts/3508/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-20</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3508 设计路由器" href="https://leetcode.cn/problems/implement-router/description/?envType=daily-question&envId=2025-09-20"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3508 设计路由器</p><p class="url">https://leetcode.cn/problems/implement-router/description/?envType=daily-question&envId=2025-09-20</p></div></a></div></p><p>这题很容易超时，主要是因为这个时间本来就是有序的，如果认为是无序的那么基本就超时了，比如用 multiset 存 timestamp 以求其有序，但实际上用简单的 vector 存就行。</p><p>注意 std::distance 这个函数，有的迭代器不支持减法只能用这个求其距离</p><p>注意 std::set 如果存入 class 或者 struct 那么得实现比较的 operator,因为 set 是有序的</p><ul><li>std::lower_bound<ul><li>作用: 返回第一个 大于等于 (&gt;=) 指定值的元素的迭代器。 - 如果值存在: 返回该值的第一个位置。 - 如果值不存在: 返回比目标值 大的第一个元素 位置。 - 如果所有元素都小于目标值: 返回 end() 迭代器。<blockquote><p>反向查找小于目标值的元素: std::lower_bound 返回的迭代器减一，即 std::lower_bound(vec.begin(), vec.end(), target) - 1。</p></blockquote></li></ul></li><li>std::upper_bound<ul><li>作用: 返回第一个 大于 (&gt;) 指定值的元素的迭代器。 - 如果值存在: 跳过所有相同值，返回比目标值 大的第一个元素 位置。 - 如果值不存在: 返回比目标值 大的第一个元素 位置。 - 如果所有元素都小于等于目标值: 返回 end() 迭代器。<blockquote><p>反向查找小于等于目标值的元素: std::upper_bound 返回的迭代器减一，即 std::upper_bound(vec.begin(), vec.end(), target) - 1。</p></blockquote></li></ul></li></ul><p>注意 写 operator&lt;时</p><ul><li>参数必须是 const Movie&amp;（不能接受非 const 引用）</li><li>函数本身必须是 const（不会修改 *this）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"><span class="keyword">using</span> std::set;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Packet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> source;</span><br><span class="line">  <span class="type">int</span> destination;</span><br><span class="line">  <span class="type">int</span> timestamp;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Packet &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (destination != other.destination)</span><br><span class="line">      <span class="keyword">return</span> destination &lt; other.destination;</span><br><span class="line">    <span class="keyword">if</span> (timestamp != other.timestamp)</span><br><span class="line">      <span class="keyword">return</span> timestamp &lt; other.timestamp;</span><br><span class="line">    <span class="keyword">return</span> source &lt; other.source;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  set&lt;Packet&gt; router_set;</span><br><span class="line">  queue&lt;Packet&gt; fifo;</span><br><span class="line">  <span class="comment">// destination-&gt;[timestamp array]</span></span><br><span class="line">  map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; router_map;</span><br><span class="line">  <span class="type">int</span> memoryLimit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Router</span>(<span class="type">int</span> memoryLimit) &#123; <span class="keyword">this</span>-&gt;memoryLimit = memoryLimit; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">addPacket</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Packet</span> newPacket = &#123;source, destination, timestamp&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (router_set.<span class="built_in">find</span>(newPacket) != router_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (router_set.<span class="built_in">size</span>() &gt;= memoryLimit ||</span><br><span class="line">        fifo.<span class="built_in">size</span>() &gt;= memoryLimit) &#123; <span class="comment">// out of memory</span></span><br><span class="line">      Packet s = fifo.<span class="built_in">front</span>();</span><br><span class="line">      fifo.<span class="built_in">pop</span>();</span><br><span class="line">      router_set.<span class="built_in">erase</span>(s);</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; &amp;timestamp_array = router_map[s.destination];</span><br><span class="line">      timestamp_array.<span class="built_in">erase</span>(</span><br><span class="line">          <span class="built_in">find</span>(timestamp_array.<span class="built_in">begin</span>(), timestamp_array.<span class="built_in">end</span>(), s.timestamp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router_set.<span class="built_in">insert</span>(newPacket);</span><br><span class="line">    fifo.<span class="built_in">push</span>(newPacket);</span><br><span class="line"></span><br><span class="line">    router_map[destination].<span class="built_in">push_back</span>(timestamp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">forwardPacket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (fifo.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Packet resPacket = fifo.<span class="built_in">front</span>();</span><br><span class="line">    fifo.<span class="built_in">pop</span>();</span><br><span class="line">    res = &#123;resPacket.source, resPacket.destination, resPacket.timestamp&#125;;</span><br><span class="line">    router_set.<span class="built_in">erase</span>(resPacket);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; &amp;timestamp_array = router_map[resPacket.destination];</span><br><span class="line">    timestamp_array.<span class="built_in">erase</span>(<span class="built_in">find</span>(timestamp_array.<span class="built_in">begin</span>(), timestamp_array.<span class="built_in">end</span>(),</span><br><span class="line">                               resPacket.timestamp));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">(<span class="type">int</span> destination, <span class="type">int</span> startTime, <span class="type">int</span> endTime)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; &amp;vec = router_map[destination];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">distance</span>(std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), startTime),</span><br><span class="line">                         std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), endTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Router object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Router* obj = new Router(memoryLimit);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;addPacket(source,destination,timestamp);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;forwardPacket();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getCount(destination,startTime,endTime);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 p3484 设计电子表格</title>
      <link href="/posts/3484/"/>
      <url>/posts/3484/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-19</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="p3484 设计电子表格" href="https://leetcode.cn/problems/design-spreadsheet/description/?envType=daily-question&envId=2025-09-19"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">p3484 设计电子表格</p><p class="url">https://leetcode.cn/problems/design-spreadsheet/description/?envType=daily-question&envId=2025-09-19</p></div></a></div></p><p>这题直接模拟是可以过的，用哈希表会更好，因为行列是唯一的可以作为键值，这样就免去很多字符串转 int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spreadsheet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sheet;</span><br><span class="line">  <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">get_row_and_column</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> column = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      row = std::<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    row = row - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;row, column&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Spreadsheet</span>(<span class="type">int</span> rows) &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    sheet.<span class="built_in">assign</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setCell</span><span class="params">(string cell, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [row, column] = <span class="built_in">get_row_and_column</span>(cell);</span><br><span class="line">    sheet[row][column] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resetCell</span><span class="params">(string cell)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [row, column] = <span class="built_in">get_row_and_column</span>(cell);</span><br><span class="line">    sheet[row][column] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(string formula)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res_value = <span class="number">0</span>;</span><br><span class="line">    string formula_s = formula.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="function">std::stringstream <span class="title">ss</span><span class="params">(formula_s)</span></span>;</span><br><span class="line">    vector&lt;string&gt; values;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, token, <span class="string">&#x27;+&#x27;</span>)) &#123;</span><br><span class="line">      values.<span class="built_in">push_back</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> int_value;</span><br><span class="line">    <span class="keyword">for</span> (string value : values) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        int_value = std::<span class="built_in">stoi</span>(value);</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::invalid_argument) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [row, column] = <span class="built_in">get_row_and_column</span>(value);</span><br><span class="line">        int_value = sheet[row][column];</span><br><span class="line">      &#125;</span><br><span class="line">      res_value += int_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Spreadsheet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Spreadsheet* obj = new Spreadsheet(rows);</span></span><br><span class="line"><span class="comment"> * obj-&gt;setCell(cell,value);</span></span><br><span class="line"><span class="comment"> * obj-&gt;resetCell(cell);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getValue(formula);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [&quot;Spreadsheet&quot;,&quot;getValue&quot;]</span></span><br><span class="line">  <span class="comment">// [[458],[&quot;=O126+10272&quot;]]</span></span><br><span class="line"></span><br><span class="line">  Spreadsheet *obj = <span class="keyword">new</span> <span class="built_in">Spreadsheet</span>(<span class="number">458</span>);</span><br><span class="line">  <span class="type">int</span> result = obj-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;=O126+10272&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result is %d\n&quot;</span>, result);</span><br><span class="line">  <span class="keyword">delete</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3408 设计任务管理器</title>
      <link href="/posts/3408/"/>
      <url>/posts/3408/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-18</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3408 设计任务管理器" href="https://leetcode.cn/problems/design-task-manager/description/?envType=daily-question&envId=2025-09-18"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3408 设计任务管理器</p><p class="url">https://leetcode.cn/problems/design-task-manager/description/?envType=daily-question&envId=2025-09-18</p></div></a></div></p><h2 id="自定义最大堆，TLE"><a href="#自定义最大堆，TLE" class="headerlink" title="自定义最大堆，TLE"></a>自定义最大堆，TLE</h2><p>这题很自然想到用堆实现，但是要自定义实现堆，C++的 priority_queue 虽然也是堆，但是不提供修改元素的方法，使用受较大限制<br>但是下面的写法纯用堆 660/663 个通过，660 的测试用例 TLE 了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = std::less&lt;T&gt;&gt; <span class="keyword">class</span> Heap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Heap</span>() &#123;&#125;</span><br><span class="line">  <span class="type">void</span> <span class="built_in">push</span>(T val) &#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">    <span class="built_in">shiftUp</span>(vec.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(vec[<span class="number">0</span>], vec.<span class="built_in">back</span>());</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">shiftDown</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> vec.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> vec.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">cmp</span>(vec[<span class="built_in">parent</span>(index)], vec[index])) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// vec[index]返回的是元素的引用而不是拷贝</span></span><br><span class="line">      <span class="built_in">swap</span>(vec[<span class="built_in">parent</span>(index)], vec[index]);</span><br><span class="line">      index = <span class="built_in">parent</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">size_t</span> left = <span class="built_in">left_child</span>(index);</span><br><span class="line">      <span class="type">size_t</span> right = <span class="built_in">right_child</span>(index);</span><br><span class="line">      <span class="type">size_t</span> largest = index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (left &lt; n &amp;&amp; <span class="built_in">cmp</span>(vec[largest], vec[left]))</span><br><span class="line">        largest = left;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; n &amp;&amp; <span class="built_in">cmp</span>(vec[largest], vec[right]))</span><br><span class="line">        largest = right;</span><br><span class="line">      <span class="keyword">if</span> (largest == index)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">swap</span>(vec[index], vec[largest]);</span><br><span class="line">      index = largest;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">left_child</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">right_child</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">parent</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123; <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;T&gt; vec;</span><br><span class="line">  Compare cmp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskManager</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;tasks) &#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; task : tasks) &#123;</span><br><span class="line">      max_heap.<span class="built_in">push</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> taskId, <span class="type">int</span> priority)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(userId);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(taskId);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(priority);</span><br><span class="line">    <span class="comment">// 拷贝</span></span><br><span class="line">    max_heap.<span class="built_in">push</span>(vec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">edit</span><span class="params">(<span class="type">int</span> taskId, <span class="type">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> oldPriority;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_heap.vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (max_heap.vec[i][<span class="number">1</span>] == taskId) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        oldPriority = max_heap.vec[i][<span class="number">2</span>];</span><br><span class="line">        max_heap.vec[i][<span class="number">2</span>] = newPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldPriority &lt; newPriority) &#123;</span><br><span class="line">      max_heap.<span class="built_in">shiftUp</span>(index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max_heap.<span class="built_in">shiftDown</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rmv</span><span class="params">(<span class="type">int</span> taskId)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> oldPriority;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_heap.vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (max_heap.vec[i][<span class="number">1</span>] == taskId) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        oldPriority = max_heap.vec[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == max_heap.vec.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      max_heap.vec.<span class="built_in">pop_back</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(max_heap.vec.<span class="built_in">back</span>(), max_heap.vec[index]);</span><br><span class="line">    max_heap.vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldPriority &gt; max_heap.vec[index][<span class="number">2</span>]) &#123;</span><br><span class="line">      max_heap.<span class="built_in">shiftDown</span>(index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max_heap.<span class="built_in">shiftUp</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> userId;</span><br><span class="line">    <span class="keyword">if</span> (max_heap.vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    userId = max_heap.<span class="built_in">top</span>()[<span class="number">0</span>];</span><br><span class="line">    max_heap.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[<span class="number">2</span>] != b[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]; <span class="comment">// priority 小的优先级低</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  Heap&lt;vector&lt;<span class="type">int</span>&gt;, Compare&gt; max_heap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TaskManager object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TaskManager* obj = new TaskManager(tasks);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(userId,taskId,priority);</span></span><br><span class="line"><span class="comment"> * obj-&gt;edit(taskId,newPriority);</span></span><br><span class="line"><span class="comment"> * obj-&gt;rmv(taskId);</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;execTop();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Step 1: 初始化任务</span></span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tasks = &#123;&#123;<span class="number">10</span>, <span class="number">26</span>, <span class="number">25</span>&#125;&#125;; <span class="comment">// 用户 10，任务 26，优先级 25</span></span><br><span class="line">  <span class="function">TaskManager <span class="title">taskManager</span><span class="params">(tasks)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 2: 删除任务 26</span></span><br><span class="line">  taskManager.<span class="built_in">rmv</span>(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> topUser = taskManager.<span class="built_in">execTop</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;execTop() -&gt; &quot;</span> &lt;&lt; topUser &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最大堆-懒删除"><a href="#最大堆-懒删除" class="headerlink" title="最大堆 + 懒删除"></a>最大堆 + 懒删除</h2><p>我们之前说 priority_queue 不能删除。使用懒删除的方法，只要这个应该删除的元素不是最大值就不删除它。<br>经过此题我算是明白为什么 priority_queue 不提供修改或删除非堆顶元素的方法了。<br>懒删除点赞 👍</p><div class="tip warning faa-horizontal animated"><p>注意该题懒删除”懒删”的有两种： 1.修改产生的，taskId 可能在堆里重复出现，因此最后只通过 taskId 是否在 map 中存在是不行的； 2.删除产生的，taskId 消失；</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; map;</span><br><span class="line">  priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskManager</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;tasks) &#123;</span><br><span class="line">    <span class="type">int</span> userId, taskId, priority;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;task : tasks) &#123;</span><br><span class="line">      userId = task[<span class="number">0</span>];</span><br><span class="line">      taskId = task[<span class="number">1</span>];</span><br><span class="line">      priority = task[<span class="number">2</span>];</span><br><span class="line">      map[taskId] = &#123;priority, userId&#125;;</span><br><span class="line">      heap.<span class="built_in">emplace</span>(priority, taskId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> taskId, <span class="type">int</span> priority)</span> </span>&#123;</span><br><span class="line">    heap.<span class="built_in">emplace</span>(priority, taskId);</span><br><span class="line">    map[taskId] = &#123;priority, userId&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">edit</span><span class="params">(<span class="type">int</span> taskId, <span class="type">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="built_in">find</span>(taskId) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      map[taskId].first = newPriority;</span><br><span class="line">      heap.<span class="built_in">emplace</span>(newPriority, taskId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rmv</span><span class="params">(<span class="type">int</span> taskId)</span> </span>&#123; map.<span class="built_in">erase</span>(taskId); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> top_userId, top_taskId, top_priority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      top_priority = heap.<span class="built_in">top</span>().first;</span><br><span class="line">      top_taskId = heap.<span class="built_in">top</span>().second;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (map.<span class="built_in">find</span>(top_taskId) != map.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">          map[top_taskId].first == top_priority) &#123; <span class="comment">// 存在,且priority相同</span></span><br><span class="line">        top_userId = map[top_taskId].second;</span><br><span class="line">        map.<span class="built_in">erase</span>(top_taskId);</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top_userId;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 应该删除的元素</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TaskManager object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TaskManager* obj = new TaskManager(tasks);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(userId,taskId,priority);</span></span><br><span class="line"><span class="comment"> * obj-&gt;edit(taskId,newPriority);</span></span><br><span class="line"><span class="comment"> * obj-&gt;rmv(taskId);</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;execTop();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 heap.emplace(…) 是 C++ 标准库 priority_queue 的一个成员函数，用来 在堆中直接原地构造元素，而不是先创建对象再拷贝或移动进去。它和 push() 功能类似，但通常比 push() 更高效，尤其是构造复杂对象时。</p><p>语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;T&gt; heap;</span><br><span class="line">heap.<span class="built_in">emplace</span>(args...);</span><br></pre></td></tr></table></figure><p>args… 会被直接传给 T 的构造函数<br>等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap.<span class="built_in">push</span>(<span class="built_in">T</span>(args...));</span><br></pre></td></tr></table></figure><p>但 emplace 避免了 临时对象的创建。<br>举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 push</span></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(p);   <span class="comment">// 会拷贝 p 到堆里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace</span></span><br><span class="line">    heap.<span class="built_in">emplace</span>(<span class="number">2</span>, <span class="number">200</span>); <span class="comment">// 直接在堆中构造 pair&lt;int,int&gt;(2,200)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; heap.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; heap.<span class="built_in">top</span>().second &lt;&lt; endl;</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2349 设计数字容器系统</title>
      <link href="/posts/2349/"/>
      <url>/posts/2349/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-17</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2349 设计数字容器系统" href="https://leetcode.cn/problems/design-a-number-container-system/description/?envType=daily-question&envId=2025-09-17"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2349 设计数字容器系统</p><p class="url">https://leetcode.cn/problems/design-a-number-container-system/description/?envType=daily-question&envId=2025-09-17</p></div></a></div></p><p>这题主要利用空间换时间的思想，根据提示的 index 和 number 的大小范围可以断定暴力解法肯定 TLE，而事实也的确如此。<br>利用 set 的特性：std::set 内部是平衡二叉搜索树（通常是红黑树）。树中 最小元素总是在最左边 → set.begin() 指向最左叶子节点。因此 rbegin() 则返回 最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberContainers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NumberContainers</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map.<span class="built_in">count</span>(index)) &#123; <span class="comment">// map中原本有该index</span></span><br><span class="line">      <span class="type">int</span> last_number = map[index];</span><br><span class="line">      min_map[last_number].<span class="built_in">erase</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    map[index] = number;</span><br><span class="line">    min_map[number].<span class="built_in">insert</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (min_map.<span class="built_in">count</span>(number) &amp;&amp; !min_map[number].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> *min_map[number].<span class="built_in">begin</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::set&lt;<span class="type">int</span>&gt;&gt; min_map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumberContainers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> *      NumberContainers* obj = new NumberContainers();</span></span><br><span class="line"><span class="comment"> * obj-&gt;change(index,number);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;find(number);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2197 替换数组中的非互质数</title>
      <link href="/posts/2197/"/>
      <url>/posts/2197/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-16</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2197 替换数组中的非互质数" href="https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/description/?envType=daily-question&envId=2025-09-16"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2197 替换数组中的非互质数</p><p class="url">https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/description/?envType=daily-question&envId=2025-09-16</p></div></a></div></p><p><numeric>中有 std::lcm 和 std::gcd 分别用于计算最小公倍数和最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">replaceNonCoprimes</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 用 nums[0..top] 作为“栈”</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// std::gcd最大公约数 greatest common divisor</span></span><br><span class="line">      <span class="comment">// 如果栈顶 nums[top] 和当前 nums[i] 不是互质，就合并.</span></span><br><span class="line">      <span class="comment">// 一个数可能会和多个前面的数连续不互质。</span></span><br><span class="line">      <span class="comment">// 所以必须不断往回合并，直到和栈顶互质为止。</span></span><br><span class="line">      <span class="keyword">while</span> (top &gt;= <span class="number">0</span> <span class="keyword">and</span> std::<span class="built_in">gcd</span>(nums[top], nums[i]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// std::lcm最小公倍数 least common multiple</span></span><br><span class="line">        nums[i] = std::<span class="built_in">lcm</span>(nums[top], nums[i]);</span><br><span class="line">        <span class="comment">// 弹出栈顶，继续和新的栈顶比较</span></span><br><span class="line">        top--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把合并后的结果压回栈顶</span></span><br><span class="line">      nums[++top] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">resize</span>(top + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P1935 可以输入的最大单词数</title>
      <link href="/posts/1935/"/>
      <url>/posts/1935/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-15</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P1935 可以输入的最大单词数" href="https://leetcode.cn/problems/maximum-number-of-words-you-can-type/description/?envType=daily-question&envId=2025-09-15"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P1935 可以输入的最大单词数</p><p class="url">https://leetcode.cn/problems/maximum-number-of-words-you-can-type/description/?envType=daily-question&envId=2025-09-15</p></div></a></div></p><p>这题简单,主要注意下C++怎么分割字符串吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">canBeTypedWords</span><span class="params">(string text, string brokenLetters)</span> </span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    vector&lt;string&gt; words;</span><br><span class="line">    <span class="type">int</span> broken = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, token, <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">      words.<span class="built_in">push_back</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (string word : words) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> ch : brokenLetters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.<span class="built_in">find</span>(ch) != string::npos) &#123;</span><br><span class="line">          broken++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> words.<span class="built_in">size</span>() - broken;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution s;</span><br><span class="line">  <span class="type">int</span> res = s.<span class="built_in">canBeTypedWords</span>(<span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;ad&quot;</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P966 元音拼写检查器</title>
      <link href="/posts/966/"/>
      <url>/posts/966/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-15</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P966 元音拼写检查器" href="https://leetcode.cn/problems/vowel-spellchecker/description/?envType=daily-question&envId=2025-09-14"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P966 元音拼写检查器</p><p class="url">https://leetcode.cn/problems/vowel-spellchecker/description/?envType=daily-question&envId=2025-09-14</p></div></a></div></p><p>最开始使用暴力搜索的方法，但是 TLE 了，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">      c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcomplexcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> len1, len2;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  len1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line">  len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len1 &amp;&amp; i &lt; len2; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1[i] == str2[i]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVowel(str1[i]) &amp;&amp; isVowel(str2[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">tolower</span>(str1[i]) == <span class="built_in">tolower</span>(str2[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> str1[i] - str2[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (str1[i] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; str2[i] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str1[i] - str2[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> **<span class="title function_">spellchecker</span><span class="params">(<span class="type">char</span> **wordlist, <span class="type">int</span> wordlistSize, <span class="type">char</span> **queries,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> queriesSize, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">  <span class="type">char</span> **returnArray;</span><br><span class="line">  <span class="type">char</span> *totally_matched;</span><br><span class="line">  <span class="type">char</span> *case_matched;</span><br><span class="line">  <span class="type">char</span> *vowel_matched;</span><br><span class="line">  <span class="type">char</span> *complex_matched;</span><br><span class="line"></span><br><span class="line">  *returnSize = queriesSize;</span><br><span class="line">  returnArray = (<span class="type">char</span> **)<span class="built_in">malloc</span>(queriesSize * <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line">    totally_matched = <span class="literal">NULL</span>;</span><br><span class="line">    case_matched = <span class="literal">NULL</span>;</span><br><span class="line">    vowel_matched = <span class="literal">NULL</span>;</span><br><span class="line">    complex_matched = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wordlistSize; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(wordlist[j], queries[i]) == <span class="number">0</span> &amp;&amp; totally_matched == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        totally_matched = wordlist[j];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(wordlist[j], queries[i]) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 case_matched == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        case_matched = wordlist[j];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcomplexcmp(wordlist[j], queries[i]) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 complex_matched == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        complex_matched = wordlist[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (totally_matched) &#123;</span><br><span class="line">      returnArray[i] = strdup(totally_matched);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (case_matched) &#123;</span><br><span class="line">      returnArray[i] = strdup(case_matched);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (complex_matched) &#123;</span><br><span class="line">      returnArray[i] = strdup(complex_matched);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      returnArray[i] = strdup(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> returnArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *wordlist[] = &#123;<span class="string">&quot;KiTe&quot;</span>, <span class="string">&quot;kite&quot;</span>, <span class="string">&quot;hare&quot;</span>, <span class="string">&quot;Hare&quot;</span>&#125;;</span><br><span class="line">  <span class="type">int</span> wordlistSize = <span class="number">4</span>;</span><br><span class="line">  <span class="type">char</span> *queries[] = &#123;<span class="string">&quot;kite&quot;</span>, <span class="string">&quot;Kite&quot;</span>, <span class="string">&quot;KiTe&quot;</span>, <span class="string">&quot;Hare&quot;</span>, <span class="string">&quot;HARE&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Hear&quot;</span>, <span class="string">&quot;hear&quot;</span>, <span class="string">&quot;keti&quot;</span>, <span class="string">&quot;keet&quot;</span>, <span class="string">&quot;keto&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> queriesSize = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> returnSize = queriesSize;</span><br><span class="line">  <span class="type">char</span> **returnArray;</span><br><span class="line">  returnArray =</span><br><span class="line">      spellchecker(wordlist, wordlistSize, queries, queriesSize, &amp;returnSize);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; returnSize; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s, &quot;</span>, returnArray[i]);</span><br><span class="line">    <span class="built_in">free</span>(returnArray[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(returnArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用哈希表查找能从 O(n^2)降低到 O(n)，下面是官方推荐的 C++写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 存储未处理的字符串</span></span><br><span class="line">  unordered_set&lt;string&gt; words_perfect;</span><br><span class="line">  <span class="comment">// 存储小写后的字符串和原字符串的映射</span></span><br><span class="line">  unordered_map&lt;string, string&gt; words_cap;</span><br><span class="line">  <span class="comment">// 存储将元音字母都转换为*的字符串和原字符串的映射</span></span><br><span class="line">  unordered_map&lt;string, string&gt; words_vow;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将元音字母都转换为*</span></span><br><span class="line">  <span class="function">string <span class="title">devowel</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">      ans += <span class="built_in">isVowel</span>(c) ? <span class="string">&#x27;*&#x27;</span> : c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是否是元音字母</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isVowel</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    c = <span class="built_in">tolower</span>(c);</span><br><span class="line">    <span class="keyword">return</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">match</span><span class="params">(string query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完全匹配</span></span><br><span class="line">    <span class="keyword">if</span> (words_perfect.<span class="built_in">count</span>(query)) &#123;</span><br><span class="line">      <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大小写</span></span><br><span class="line">    string queryL;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : query) &#123;</span><br><span class="line">      queryL += <span class="built_in">tolower</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (words_cap.<span class="built_in">count</span>(queryL)) &#123;</span><br><span class="line">      <span class="keyword">return</span> words_cap[queryL];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都转为小写字母后，查找元音字母</span></span><br><span class="line">    string queryLV = <span class="built_in">devowel</span>(queryL);</span><br><span class="line">    <span class="keyword">if</span> (words_vow.<span class="built_in">count</span>(queryLV)) &#123;</span><br><span class="line">      <span class="keyword">return</span> words_vow[queryLV];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">spellchecker</span><span class="params">(vector&lt;string&gt; &amp;wordlist,</span></span></span><br><span class="line"><span class="params"><span class="function">                              vector&lt;string&gt; &amp;queries)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//填充set和两个map</span></span><br><span class="line">    <span class="keyword">for</span> (string word : wordlist) &#123;</span><br><span class="line">      words_perfect.<span class="built_in">insert</span>(word);</span><br><span class="line">      string wordlow;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">        wordlow += <span class="built_in">tolower</span>(c);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!words_cap.<span class="built_in">count</span>(wordlow)) &#123;</span><br><span class="line">        words_cap[wordlow] = word;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 都转成小写字母后再将元音字母转为*</span></span><br><span class="line">      string wordlowDV = <span class="built_in">devowel</span>(wordlow);</span><br><span class="line">      <span class="keyword">if</span> (!words_vow.<span class="built_in">count</span>(wordlowDV)) &#123;</span><br><span class="line">        words_vow[wordlowDV] = word;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (string query : queries) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(<span class="built_in">match</span>(query));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度</strong></p><div class="table-container"><table><thead><tr><th>操作</th><th>unordered_set</th><th>unordered_map</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(1)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(1)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><ul><li>这里的 <strong>O(1)</strong> 是 <strong>平均复杂度</strong>，假设哈希函数分布均匀，冲突较少。</li><li>主要优点：<strong>比 std::set/std::map（基于红黑树）快</strong>，红黑树的查找是 O(log n)。</li></ul><p><strong>最坏情况时间复杂度</strong></p><ul><li>最坏情况下，如果所有元素都被哈希到同一个桶（hash collision），退化成 <strong>链表</strong>：<ul><li>查找、插入、删除都变为 <strong>O(n)</strong>。</li></ul></li><li>C++ 标准库实现通常用 <strong>桶 + 链表（或红黑树）</strong>，在冲突过多时，会把链表转换成红黑树，从而降低最坏情况复杂度：<ul><li>C++11 以后，unordered_map/unordered_set 的单个桶链表长度超过一定阈值（通常是 8），会转换成红黑树，保证最坏复杂度 <strong>O(log n)</strong>。</li></ul></li></ul><hr><p><strong>空间复杂度</strong></p><ul><li>平均 O(n)，存储哈希表和元素。</li><li>哈希表需要额外的桶数组，占用额外空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3541 找到频率最高的元音和辅音</title>
      <link href="/posts/3541/"/>
      <url>/posts/3541/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-13</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3541找到频率最高的元音和辅音" href="https://leetcode.cn/problems/find-most-frequent-vowel-and-consonant/description/?envType=daily-question&envId=2025-09-13"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3541找到频率最高的元音和辅音</p><p class="url">https://leetcode.cn/problems/find-most-frequent-vowel-and-consonant/description/?envType=daily-question&envId=2025-09-13</p></div></a></div></p><p>利用计数排序思想，空间换时间，复杂度 O(n)<br><div class="tag link"><a class="link-card" title="ASCII码表" href="https://www.runoob.com/w3cnote/ascii.html"><div class="left"><img src="https://static.char123.com/images/favicon.ico"/></div><div class="right"><p class="text">ASCII码表</p><p class="url">https://www.runoob.com/w3cnote/ascii.html</p></div></a></div><br><div class="tag link"><a class="link-card" title="计数排序" href="https://www.runoob.com/w3cnote/counting-sort.html"><div class="left"><img src="https://static.char123.com/images/favicon.ico"/></div><div class="right"><p class="text">计数排序</p><p class="url">https://www.runoob.com/w3cnote/counting-sort.html</p></div></a></div></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">      c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxFreqSum</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">58</span>];</span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="number">58</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    arr[s[i] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> vowel_max = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> consonant_max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">58</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isVowel(<span class="string">&#x27;A&#x27;</span> + i) &amp;&amp; arr[i] &gt; vowel_max) &#123;</span><br><span class="line">      vowel_max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isVowel(<span class="string">&#x27;A&#x27;</span> + i) &amp;&amp; arr[i] &gt; consonant_max) &#123;</span><br><span class="line">      consonant_max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vowel_max + consonant_max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  n = maxFreqSum(<span class="string">&quot;successes&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3227 字符串元音游戏</title>
      <link href="/posts/3227/"/>
      <url>/posts/3227/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3227字符串元音游戏" href="https://leetcode.cn/problems/vowels-game-in-a-string/description/?envType=daily-question&envId=2025-09-12"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3227字符串元音游戏</p><p class="url">https://leetcode.cn/problems/vowels-game-in-a-string/description/?envType=daily-question&envId=2025-09-12</p></div></a></div></p><p>这题可以画一个状态机来看</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509121103619.png" alt="image-20250912110341407"></p><p>小红先手，如果整个串的元音字母是奇数，那么直接拿所有的串，小红胜</p><p>小红先手，如果整个串的元音字母是偶数，除非是0个，小红先手就输了；如果是非零，那么再拿一个奇数个元音字母字串后，至少还剩下2-1=1个元音子串，而这时小明要拿偶数个，只能拿0个，因此必定可以进入状态机的第三个，整个串剩下奇数个，而轮到小红拿奇数个了，直接拿走所有串，小红胜出。</p><p>因此，只要这个字符串有元音字母，就是小红胜出，fou’ze</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">      c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">doesAliceWin</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  <span class="type">int</span> vowel_num = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="comment">// 统计所有的元音数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVowel(s[i])) &#123;</span><br><span class="line">      vowel_num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vowel_num == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vowel_num % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 偶数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 奇数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust language</title>
      <link href="/posts/42871/"/>
      <url>/posts/42871/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-11</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>cargo new 项目名称</p><p>帮助信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Create a new cargo package at &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Usage: cargo.exe new [OPTIONS] &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -q, --quiet                Do not <span class="built_in">print</span> cargo <span class="built_in">log</span> messages</span><br><span class="line">      --registry &lt;REGISTRY&gt;  Registry to use</span><br><span class="line">      --vcs &lt;VCS&gt;            Initialize a new repository <span class="keyword">for</span> the given version control system (git, hg, pijul, or fossil) or <span class="keyword">do</span> not initialize any version control at all (none), overriding a global configuration. [possible values: git, hg, pijul, fossil, none]</span><br><span class="line">      --bin                  Use a binary (application) template [default]</span><br><span class="line">  -v, --verbose...           Use verbose output (-vv very verbose/build.rs output)</span><br><span class="line">      --lib                  Use a library template</span><br><span class="line">      --color &lt;WHEN&gt;         Coloring: auto, always, never</span><br><span class="line">      --edition &lt;YEAR&gt;       Edition to <span class="built_in">set</span> <span class="keyword">for</span> the crate generated [possible values: 2015, 2018, 2021]</span><br><span class="line">      --frozen               Require Cargo.lock and cache are up to <span class="built_in">date</span></span><br><span class="line">      --name &lt;NAME&gt;          Set the resulting package name, defaults to the directory name</span><br><span class="line">      --locked               Require Cargo.lock is up to <span class="built_in">date</span></span><br><span class="line">      --offline              Run without accessing the network</span><br><span class="line">      --config &lt;KEY=VALUE&gt;   Override a configuration value</span><br><span class="line">  -Z &lt;FLAG&gt;                  Unstable (nightly-only) flags to Cargo, see <span class="string">&#x27;cargo -Z help&#x27;</span> <span class="keyword">for</span> details</span><br><span class="line">  -h, --<span class="built_in">help</span>                 Print <span class="built_in">help</span> information</span><br><span class="line"></span><br><span class="line">Run `cargo <span class="built_in">help</span> new` <span class="keyword">for</span> more detailed information.</span><br></pre></td></tr></table></figure><p><strong>Cargo.toml</strong></p><p>TOML(Tom’s Obvious,Minimal Language)格式，是Cargo的配置格式</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span><span class="comment">#区域标题，表示一下面是用来配置包package的</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello&quot;</span> <span class="comment">#项目名称</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> <span class="comment">#项目版本</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;cauchy &lt;731005515@qq.com&gt;&quot;</span>] <span class="comment">#作者</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> <span class="comment">#使用的Rust版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span><span class="comment">#依赖项</span></span><br></pre></td></tr></table></figure><p>在Rust中，代码的包叫做<strong>crate</strong></p><h2 id="构建Cargo项目"><a href="#构建Cargo项目" class="headerlink" title="构建Cargo项目"></a>构建Cargo项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure><p>创建可执行文件target/debug/hello_cargo或target\debug\hello_cargo.exe(Windows)</p><p>运行.\target\debug\hello_cargo.exe</p><p>第一次运行会生成cargo.lock文件</p><p>该文件负责追踪项目依赖的精确版本，不需要手动修改该文件</p><h2 id="构建和运行Cargo项目"><a href="#构建和运行Cargo项目" class="headerlink" title="构建和运行Cargo项目"></a>构建和运行Cargo项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><p>如果之前编译过且代码没有修改的话会直接执行</p><h2 id="cargo-check"><a href="#cargo-check" class="headerlink" title="cargo check"></a>cargo check</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo check</span><br></pre></td></tr></table></figure><p>检查代码，确保能通过编译，但是不产生任何可执行文件</p><p>cargo check比cargo build快得多</p><h2 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure><p>编译时会进行优化，代码运行的更快但是编译时间更长</p><p>会在target/release而不是target/debug生成可执行文件</p><h1 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h1><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><p>声明使用<strong>let</strong>关键字</p><p>默认情况下，变量是不可变的(immutable)</p><p>声明变量时，前面加上<strong>mut</strong>关键字，就可以使变量可变</p><p>let mut x = 3;</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h3><p>类似于不可变变量，<em>常量(constants)</em> 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p><p>1.不允许对常量使用 mut。常量不光默认不能变，它总是不能变。</p><p>2.声明常量使用 const 关键字而不是 let，并且 <strong><em>必须</em></strong> <strong>注明值的类型</strong>。</p><p>3.常量可以在任何作用域中声明，包括全局作用域，</p><p>4.最后一个区别是，常量只能被设置为<strong>常量表达式</strong>，而<strong>不可以是其他任何只能在运行时计算出的值</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> MAX_POINTS:<span class="type">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure><p>命名规范:全部大写，下划线间隔</p><h3 id="隐藏-shadow"><a href="#隐藏-shadow" class="headerlink" title="隐藏(shadow)"></a>隐藏(shadow)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以定义一个与之前变量同名的新变量,<strong>新的变量会shadow之前声明的同名变量</strong></p><p>shadow和把变量标记为mut<strong>是不一样的</strong></p><ul><li>如果不适用let关键字，那么给非mut的变量赋值会导致编译时错误</li><li>使用let声明的同名新变量，也是不可变的</li><li>使用let声明的同名新变量，<strong>他的类型可以与之前不同</strong></li></ul><h3 id="允许未使用的变量"><a href="#允许未使用的变量" class="headerlink" title="允许未使用的变量"></a>允许未使用的变量</h3><p>两种方式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Rust是静态编译语言，编译时必须知道所有变量的类型</p><h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><p>Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>如果我们没有显式的给予变量一个类型，那编译器会自动帮我们推导一个类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;i32&quot;</span>.<span class="title function_ invoke__">to_string</span>(),<span class="title function_ invoke__">type_of</span>(&amp;x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下函数可以获取传入参数的类型，并返回类型的字符串形式</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">type_of</span>&lt;T&gt;(_: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::any::type_name::&lt;T&gt;())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数如果不赋予类型默认为i32类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">u16</span> = <span class="number">38_u8</span> <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>长度</strong></th><th><strong>有符号</strong></th><th><strong>无符号</strong></th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table></div><p>isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">i8</span>::MAX, <span class="number">127</span>); </span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX, <span class="number">255</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整型字面值</strong></p><div class="table-container"><table><thead><tr><th><strong>数字字面值</strong></th><th><strong>例子</strong></th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td>98_222</td></tr><tr><td>Hex (十六进制)</td><td>0xff</td></tr><tr><td>Octal (八进制)</td><td>0o77</td></tr><tr><td>Binary (二进制)</td><td>0b1111_0000</td></tr><tr><td>Byte (单字节字符)(仅限于u8)</td><td>b’A’</td></tr></tbody></table></div><p>Rust 的数字类型默认是 i32。isize 或 usize 主要作为某些集合的索引。</p><p><strong>整形溢出</strong></p><p>比方说有一个 u8 ，它可以存放从零到 255 的值。那么当你将其修改为 256 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），这会导致以下两种行为之一的发生。当在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em>，这个术语被 Rust 用来表明程序因错误而退出。</p><p>在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码回绕（<em>two’s complement wrapping</em>）的操作。简而言之，比此类型能容纳最大值还大的值会回绕到最小值，值 256 变成 0，值 257 变成 1，依此类推。依赖整型回绕被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，Wrapping。 为了显式地处理溢出的可能性，你可以使用标准库在原生数值类型上提供的以下方法:</p><ul><li>所有模式下都可以使用 wrapping_* 方法进行回绕，如 wrapping_add</li><li>如果 checked_* 方法出现溢出，则返回 None值</li><li>用 overflowing_* 方法返回值和一个布尔值，表示是否出现溢出</li><li>用 saturating_* 方法在值的最小值或最大值处进行饱和处理</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决代码中的错误和 `panic`</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">251_u8</span> + <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">i8</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">251</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">247_u8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">i8</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">119</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">251_u16</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">u16</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">251</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浮点数采用 IEEE-754 标准表示。f32 是单精度浮点数，f64 是双精度浮点数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1_000.000_1</span>; <span class="comment">// f64</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">0.12</span>; <span class="comment">// f32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="number">0.01_f64</span>; <span class="comment">// f64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数值运算</strong></p><p>Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会<strong>向下舍入</strong>到最接近的整数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>);<span class="comment">//报错</span></span><br><span class="line"> &#125;</span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>assertion failed: `(left == right)`</span><br><span class="line">  left: `<span class="number">0.30000000000000004</span>`,</span><br><span class="line"> right: `<span class="number">0.3</span>`<span class="string">&#x27;, src<span class="char escape_">\m</span>ain.rs:5:5</span></span><br></pre></td></tr></table></figure><p>两种修改方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="number">0.1</span>+<span class="number">0.2</span>&gt;=<span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="number">0.1_f32</span>+<span class="number">0.2_f32</span>==<span class="number">0.3_f32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T &gt;(something:T)</span><br><span class="line"><span class="keyword">where</span> T : Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,something);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 整数加法</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1u32</span> + <span class="number">2</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数减法</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1i32</span> - <span class="number">2</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1i8</span> - <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">3</span> * <span class="number">50</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">9</span> / <span class="number">3</span> == <span class="number">3</span>); <span class="comment">// error ! 修改它让代码工作</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">24</span> % <span class="number">5</span>  );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逻辑与或非操作</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="literal">true</span> || <span class="literal">false</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(!<span class="literal">true</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 AND 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> &amp; <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 OR 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> | <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> ^ <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;</span>, <span class="number">1u32</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;</span>, <span class="number">0x80u32</span> &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> -<span class="number">3</span>..<span class="number">2</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;i is &#123;&#125;&quot;</span>,i);<span class="comment">//-3到1不包括2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,c);<span class="comment">//a-z包括z</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="comment">// 解决代码中的错误和 `panic`</span></span><br><span class="line"><span class="keyword">use</span> std::ops::&#123;Range, RangeInclusive&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..<span class="number">5</span>), Range&#123; start: <span class="number">1</span>, end: <span class="number">5</span> &#125;);</span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..=<span class="number">5</span>), RangeInclusive::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>Rust 中的布尔类型使用 bool 表示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span> || <span class="literal">true</span>;<span class="comment">//布尔运算</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(t, f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>Rust的 char 类型是语言中最原生的字母类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_char</span>(c1);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_char</span>(c : <span class="type">char</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用单引号声明 char 字面量，而与之相反的是，使用双引号声明字符串字面量。Rust 的 char 类型的大小为<strong>四个字节</strong>(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 char 并不符合。</p><p><strong>大小</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::mem::size_of_val;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;c1),<span class="number">4</span>); <span class="comment">//一个字符4个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;c2),<span class="number">4</span>); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v</span>: () = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = (<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(_v, <span class="title function_ invoke__">implicitly_ret_unit</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">implicitly_ret_unit</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I will return a ()&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单元类型所占的内存为0！！！</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::size_of_val;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unit</span>: () = ();</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;unit) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p><h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组<strong>长度固定</strong>：一旦声明，其长度不会增大或缩小</p><p>使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的<strong>类型也不必是相同的</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tup 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用<strong>模式匹配</strong>（pattern matching）来<strong>解构</strong>（destructure）元组值，像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    (y,z,x) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(y, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(z, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先创建了一个元组并绑定到 tup 变量上。接着使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y 和 z。这叫做 <strong>解构</strong>（<strong><em>destructuring</em></strong>），因为它将一个元组拆成了三个部分。</p><p>也可以<strong>使用点号（.）后跟值的索引来直接访问它们</strong>。元组的第一个索引值是 0。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p><p><strong>过长的元组无法打印</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复代码错误</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">too_long_tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;too long tuple: &#123;:?&#125;&quot;</span>, too_long_tuple);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修复</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">too_long_tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;too long tuple: &#123;:?&#125;&quot;</span>, too_long_tuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust中的数组长度是固定的。</p><p><strong>数组的类型是[T; Length]</strong>，<strong>数组的长度是类型签名的一部分，因此数组的长度必须在编译期就已知，</strong></p><p>vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。</p><p>可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p><p>let a: [i32; 5] = [1, 2, 3, 4, 5];</p><p>这里，i32 是每个元素的类型。分号之后，数字 5 表明该数组包含五个元素。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 很多时候，我们可以忽略数组的部分类型，也可以忽略全部类型，让编译器帮助我们推导</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr0</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">char</span>; <span class="number">3</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组分配在栈上， `std::mem::size_of_val` 函数会返回整个数组占用的内存空间</span></span><br><span class="line">    <span class="comment">// 数组中的每个 char 元素占用 4 字节的内存空间，因为在 Rust 中， char 是 Unicode 字符</span></span><br><span class="line">    <span class="built_in">assert!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;arr) == <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个<strong>每个元素都为相同值的数组</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>变量名为 a 的数组将包含 5 个元素，这些元素的值最初都将被设置为 3。这种写法与 let a = [3, 3, 3, 3, 3]; 效果相同，但更简洁。</p><p><strong>访问数组元素</strong></p><p>数组是可以在栈(stack)上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素，像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Sunfei&quot;</span>), <span class="string">&quot;Sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name0</span> = names.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是下标索引就存在越界的风险了</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_name1</span> = &amp;names[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无效的数组访问</strong></p><p>如果我们访问数组结尾之后的元素，程序在索引操作中使用一个无效的值时导致 <strong>运行时</strong> 错误。程序带着错误信息退出。当<strong>尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em></strong>，这是 Rust 术语，它用于程序因为错误而退出的情况。<strong>这种检查必须在运行时进行</strong>，特别是在某些情况下，因为编译器不可能知道用户在以后运行代码时将输入什么值。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="使用as进行基本类型转换"><a href="#使用as进行基本类型转换" class="headerlink" title="使用as进行基本类型转换"></a>使用as进行基本类型转换</h3><p>1.Rust 并没有为基本类型提供隐式的类型转换( coercion )，但是我们可以通过 as 来进行显式地转换。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">decimal</span> = <span class="number">97.123_f32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">integer</span>: <span class="type">u8</span> = decimal <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c1</span>: <span class="type">char</span> = decimal <span class="keyword">as</span> <span class="type">u8</span> <span class="keyword">as</span> <span class="type">char</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c2</span> = integer <span class="keyword">as</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;c1 is &#123;&#125;&quot;</span>,c1);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(integer, <span class="string">&#x27;b&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.默认情况下, 数值溢出会导致编译错误，但是我们可以通过添加一行全局注解的方式来避免编译错误(溢出还是会发生)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(overflowing_literals)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">1000</span> <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.当将任何数值转换成无符号整型 T 时，如果当前的数值不在新类型的范围内，我们可以对当前数值进行加值或减值操作( 增加或减少 T::MAX + 1 )，直到最新的值在新类型的范围内，假设我们要将 300 转成 u8 类型，由于u8 最大值是 255，因此 300 不在新类型的范围内并且大于新类型的最大值，因此我们需要减去 T::MAX + 1，也就是 300 - 256 = 44。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#![allow(overflowing_literals)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">  assert_eq!(1000 as u16, 1000);</span><br><span class="line"></span><br><span class="line">  assert_eq!(1000 as u8, 232);</span><br><span class="line"></span><br><span class="line">  // 事实上，之前说的规则对于正整数而言，就是如下的取模</span><br><span class="line">  println!(&quot;1000 mod 256 is : &#123;&#125;&quot;, 1000 % 256);</span><br><span class="line"></span><br><span class="line">  assert_eq!(-1_i8 as u8, 255);</span><br><span class="line">  </span><br><span class="line">   // 从 Rust 1.45 开始，当浮点数超出目标整数的范围时，转化会直接取正整数取值范围的最大或最小值</span><br><span class="line">  assert_eq!(300.1_f32 as u8, 255);</span><br><span class="line">  assert_eq!(-100.1_f32 as u8, 0);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    // 上面的浮点数转换有一点性能损耗，如果对于某段代码有极致的性能要求，</span><br><span class="line">    // 可以考虑下面的方法，但是这些方法的结果可能会溢出并且返回一些无意义的值</span><br><span class="line">    // 总之，请小心使用</span><br><span class="line">  unsafe &#123;</span><br><span class="line">      // 300.0 is 44</span><br><span class="line">      println!(&quot;300.0 is &#123;&#125;&quot;, 300.0_f32.to_int_unchecked::&lt;u8&gt;());</span><br><span class="line">      // -100.0 as u8 is 156</span><br><span class="line">      println!(&quot;-100.0 as u8 is &#123;&#125;&quot;, (-100.0_f32).to_int_unchecked::&lt;u8&gt;());</span><br><span class="line">      // nan as u8 is 0</span><br><span class="line">      println!(&quot;nan as u8 is &#123;&#125;&quot;, f32::NAN.to_int_unchecked::&lt;u8&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.裸指针可以和代表内存地址的整数互相转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut values: [i32; 2] = [1, 2];</span><br><span class="line">    let p1: *mut i32 = values.as_mut_ptr();</span><br><span class="line">    let first_address = p1 as usize; </span><br><span class="line">    let second_address = first_address + 4; // 4 == std::mem::size_of::&lt;i32&gt;()</span><br><span class="line">    let p2 = second_address as *mut i32;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        *p2 += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    assert_eq!(values[1], 3);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let arr :[u64; 13] = [0; 13];</span><br><span class="line">    assert_eq!(std::mem::size_of_val(&amp;arr), 8 * 13);</span><br><span class="line">    let a: *const [u64] = &amp;arr;</span><br><span class="line">    let b = a as *const [u8];</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        assert_eq!(std::mem::size_of_val(&amp;*b), 13)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="From-Into"><a href="#From-Into" class="headerlink" title="From/Into"></a>From/Into</h3><ol><li>From 特征允许让一个类型定义如何基于另一个类型来创建自己，因此它提供了一个很方便的类型转换的方式。</li><li>From 和 Into 是配对的，我们只要实现了前者，那后者就会自动被实现：只要实现了 impl From<T> for U， 就可以使用以下两个方法: let u: U = U::from(T) 和 let u:U = T.into()，前者由 From 特征提供，而后者由自动实现的 Into 特征提供。</li><li>需要注意的是，当使用 into 方法时，需要进行显式地类型标注，因为编译器很可能无法帮我们推导出所需的类型。</li></ol><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let my_str = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    // 以下三个转换都依赖于一个事实：String 实现了 From&lt;&amp;str&gt; 特征</span><br><span class="line">    let string1 = String::from(my_str);</span><br><span class="line">    let string2 = my_str.to_string();</span><br><span class="line">    // 这里需要显式地类型标注</span><br><span class="line">    let string3: String = my_str.into();</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">     // impl From&lt;bool&gt; for i32</span><br><span class="line">    let i1:i32 = false.into();</span><br><span class="line">    let i2:i32 = i32::from(false);  </span><br><span class="line">    assert_eq!(i1, i2);</span><br><span class="line">    assert_eq!(i1, 0);</span><br><span class="line"></span><br><span class="line">    // 使用两种方式修复错误</span><br><span class="line">    // 1. 哪个类型实现 From 特征 : impl From&lt;char&gt; for ? , 你可以查看一下之前提到的文档，来找到合适的类型</span><br><span class="line">    // 2. 上一章节中介绍过的某个关键字</span><br><span class="line">    let i3: i32 = &#x27;a&#x27;.into();</span><br><span class="line"></span><br><span class="line">    // 使用两种方法来解决错误</span><br><span class="line">    let s: String = &#x27;a&#x27; as String;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第一种方法</span><br><span class="line">fn main() &#123;</span><br><span class="line">  // impl From&lt;bool&gt; for i32</span><br><span class="line"> let i1:i32 = false.into();</span><br><span class="line"> let i2:i32 = i32::from(false);  </span><br><span class="line"> assert_eq!(i1, i2);</span><br><span class="line"> assert_eq!(i1, 0);</span><br><span class="line"></span><br><span class="line"> let i3:u32 = &#x27;a&#x27;.into();</span><br><span class="line"></span><br><span class="line"> let s: String = &#x27;a&#x27;.into();</span><br><span class="line"></span><br><span class="line"> println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二种方法</span><br><span class="line">fn main() &#123;</span><br><span class="line">     // impl From&lt;bool&gt; for i32</span><br><span class="line">    let i1:i32 = false.into();</span><br><span class="line">    let i2:i32 = i32::from(false);  </span><br><span class="line">    assert_eq!(i1, i2);</span><br><span class="line">    assert_eq!(i1, 0);</span><br><span class="line"></span><br><span class="line">    let i3: u32 = &#x27;a&#x27; as u32 ;</span><br><span class="line"></span><br><span class="line">    let s: String = String::from(&#x27;a&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为自定义类型实现-From-特征"><a href="#为自定义类型实现-From-特征" class="headerlink" title="为自定义类型实现 From 特征"></a>为自定义类型实现 From 特征</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// From 被包含在 `std::prelude` 中，因此我们没必要手动将其引入到当前作用域来</span><br><span class="line">// use std::convert::From;</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct Number &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl From&lt;i32&gt; for Number &#123;</span><br><span class="line">    // 实现 `from` 方法</span><br><span class="line">    fn from(item: i32) -&gt; Self &#123;</span><br><span class="line">        Number &#123; value: item &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 填空</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let num = Number::from(30);</span><br><span class="line">    assert_eq!(num.value, 30);</span><br><span class="line"></span><br><span class="line">    let num: Number = 30.into();</span><br><span class="line">    assert_eq!(num.value, 30);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行错误处理时，为我们自定义的错误类型实现 From 特征是非常有用。这样就可以通过 ? 自动将某个错误类型转换成我们自定义的错误类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">use std::fs;</span><br><span class="line">use std::io;</span><br><span class="line">use std::num;</span><br><span class="line"></span><br><span class="line">enum CliError &#123;</span><br><span class="line">    IoError(io::Error),</span><br><span class="line">    ParseError(num::ParseIntError),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl From&lt;io::Error&gt; for CliError &#123;</span><br><span class="line">    fn from(error: io::Error) -&gt; Self &#123;</span><br><span class="line">        CliError::IoError(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl From&lt;num::ParseIntError&gt; for CliError &#123;</span><br><span class="line">    fn from(error: num::ParseIntError) -&gt; Self &#123;</span><br><span class="line">        CliError::ParseError(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn open_and_parse_file(file_name: &amp;str) -&gt; Result&lt;i32, CliError&gt; &#123;</span><br><span class="line">    // ? automatically converts io::Error to CliError</span><br><span class="line">    let contents = fs::read_to_string(&amp;file_name)?;</span><br><span class="line">    // num::ParseIntError -&gt; CliError</span><br><span class="line">    let num: i32 = contents.trim().parse()?;</span><br><span class="line">    Ok(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TryFrom-TryInto"><a href="#TryFrom-TryInto" class="headerlink" title="TryFrom / TryInto"></a>TryFrom / TryInto</h3><p>类似于 From 和 Into, TryFrom 和 TryInto 也是用于类型转换的泛型特征。</p><p>但是又与 From/Into 不同, TryFrom 和 TryInto 可以对转换后的失败进行处理，然后返回一个 Result。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">  let n: i16 = 256;</span><br><span class="line"></span><br><span class="line">  // Into 特征拥有一个方法`into`,</span><br><span class="line">  // 因此 TryInto 有一个方法是 ?</span><br><span class="line">  let n: u8 = match n.try_into() &#123;</span><br><span class="line">      Ok(n) =&gt; n,</span><br><span class="line">      Err(e) =&gt; &#123;</span><br><span class="line">          println!(&quot;there is an error when converting: &#123;:?&#125;, but we catch it&quot;, e.to_string());</span><br><span class="line">          0</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  assert_eq!(n, 0);</span><br><span class="line"></span><br><span class="line">  println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug, PartialEq)]</span><br><span class="line">struct EvenNum(i32);</span><br><span class="line"></span><br><span class="line">impl TryFrom&lt;i32&gt; for EvenNum &#123;</span><br><span class="line">    type Error = ();</span><br><span class="line"></span><br><span class="line">    // 实现 `try_from`</span><br><span class="line">    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; &#123;</span><br><span class="line">        if value % 2 == 0 &#123;</span><br><span class="line">            Ok(EvenNum(value))</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Err(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    assert_eq!(EvenNum::try_from(8), Ok(EvenNum(8)));</span><br><span class="line">    assert_eq!(EvenNum::try_from(5), Err(()));</span><br><span class="line"></span><br><span class="line">    // 填空</span><br><span class="line">    let result: Result&lt;EvenNum, ()&gt; = 8i32.try_into();</span><br><span class="line">    assert_eq!(result, Ok(EvenNum(8)));</span><br><span class="line">    let result: Result&lt;EvenNum, ()&gt; = 5i32.try_into();</span><br><span class="line">    assert_eq!(result,Err(()));</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它转换"><a href="#其它转换" class="headerlink" title="其它转换"></a>其它转换</h3><h4 id="将任何类型转换成String"><a href="#将任何类型转换成String" class="headerlink" title="将任何类型转换成String"></a>将任何类型转换成String</h4><p>只要为一个类型实现了 ToString，就可以将任何类型转换成 String。事实上，这种方式并不是最好的，大家还记得 fmt::Display 特征吗？它可以控制一个类型如何打印，在实现它的时候还会自动实现 ToString。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt;</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl fmt::Display for Point &#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f, &quot;The point is (&#123;&#125;, &#123;&#125;)&quot;, self.x, self.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let origin = Point &#123; x: 0, y: 0 &#125;;</span><br><span class="line">    assert_eq!(origin.to_string(), &quot;The point is (0, 0)&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;&#125;&quot;, origin), &quot;The point is (0, 0)&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析String"><a href="#解析String" class="headerlink" title="解析String"></a>解析String</h4><p>使用 parse 方法可以将一个 String 转换成 i32 数字，这是因为在标准库中为 i32 类型实现了 FromStr: : impl FromStr for i32</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// To use `from_str` method, you needs to introduce this trait into the current scope.</span><br><span class="line">use std::str::FromStr;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let parsed: i32 = &quot;5&quot;.parse().unwrap();</span><br><span class="line">    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();</span><br><span class="line">    let from_str = i32::from_str(&quot;20&quot;).unwrap();</span><br><span class="line">    let sum = parsed + turbo_parsed + from_str;</span><br><span class="line">    assert_eq!(sum, 35);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义实现FromStr特征"><a href="#自定义实现FromStr特征" class="headerlink" title="自定义实现FromStr特征"></a>自定义实现FromStr特征</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">use std::str::FromStr;</span><br><span class="line">use std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line">#[derive(Debug, PartialEq)]</span><br><span class="line">struct Point &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl FromStr for Point &#123;</span><br><span class="line">    type Err = ParseIntError;</span><br><span class="line"></span><br><span class="line">    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; &#123;</span><br><span class="line">        let coords: Vec&lt;&amp;str&gt; = s.trim_matches(|p| p == &#x27;(&#x27; || p == &#x27;)&#x27; )</span><br><span class="line">                                 .split(&#x27;,&#x27;)</span><br><span class="line">                                 .collect();</span><br><span class="line"></span><br><span class="line">        let x_fromstr = coords[0].parse::&lt;i32&gt;()?;</span><br><span class="line">        let y_fromstr = coords[1].parse::&lt;i32&gt;()?;</span><br><span class="line"></span><br><span class="line">        Ok(Point &#123; x: x_fromstr, y: y_fromstr &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = &quot;(3,4)&quot;.parse::&lt;Point&gt;();</span><br><span class="line">    assert_eq!(p.unwrap(), Point&#123; x: 3, y: 4&#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transmute"><a href="#transmute" class="headerlink" title="transmute"></a>transmute</h4><p>std::mem::transmute 是一个 unsafe 函数，可以把一个类型按位解释为另一个类型，其中这两个类型必须有同样的位数( bits )。</p><p>transmute 相当于将一个类型按位移动到另一个类型，它会将源值的所有位拷贝到目标值中，然后遗忘源值。该函数跟 C 语言中的 memcpy 函数类似。</p><p>正因为此，<strong>transmute</strong> <strong>非常非常不安全!</strong> 调用者必须要自己保证代码的安全性，当然这也是 unsafe 的目的。</p><p><strong>示例</strong></p><p>1.transmute 可以将一个指针转换成一个函数指针，该转换并不具备可移植性，原因是在不同机器上，函数指针和数据指针可能有不同的位数( size )。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn foo() -&gt; i32 &#123;</span><br><span class="line">    0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let pointer = foo as *const ();</span><br><span class="line">    let function = unsafe &#123;</span><br><span class="line">        std::mem::transmute::&lt;*const (), fn() -&gt; i32&gt;(pointer)</span><br><span class="line">    &#125;;</span><br><span class="line">    assert_eq!(function(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.transmute 还可以扩展或缩短一个不变量的生命周期，将 Unsafe Rust 的不安全性体现的淋漓尽致!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct R&lt;&#x27;a&gt;(&amp;&#x27;a i32);</span><br><span class="line">unsafe fn extend_lifetime&lt;&#x27;b&gt;(r: R&lt;&#x27;b&gt;) -&gt; R&lt;&#x27;static&gt; &#123;</span><br><span class="line">    std::mem::transmute::&lt;R&lt;&#x27;b&gt;, R&lt;&#x27;static&gt;&gt;(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsafe fn shorten_invariant_lifetime&lt;&#x27;b, &#x27;c&gt;(r: &amp;&#x27;b mut R&lt;&#x27;static&gt;)</span><br><span class="line">                                             -&gt; &amp;&#x27;b mut R&lt;&#x27;c&gt; &#123;</span><br><span class="line">    std::mem::transmute::&lt;&amp;&#x27;b mut R&lt;&#x27;static&gt;, &amp;&#x27;b mut R&lt;&#x27;c&gt;&gt;(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.事实上我们还可以使用一些安全的方法来替代 transmute.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    /*Turning raw bytes(&amp;[u8]) to u32, f64, etc.: */</span><br><span class="line">    let raw_bytes = [0x78, 0x56, 0x34, 0x12];</span><br><span class="line"></span><br><span class="line">    let num = unsafe &#123; std::mem::transmute::&lt;[u8; 4], u32&gt;(raw_bytes) &#125;;</span><br><span class="line"></span><br><span class="line">    // use `u32::from_ne_bytes` instead</span><br><span class="line">    let num = u32::from_ne_bytes(raw_bytes);</span><br><span class="line">    // or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness</span><br><span class="line">    let num = u32::from_le_bytes(raw_bytes);</span><br><span class="line">    assert_eq!(num, 0x12345678);</span><br><span class="line">    let num = u32::from_be_bytes(raw_bytes);</span><br><span class="line">    assert_eq!(num, 0x78563412);</span><br><span class="line"></span><br><span class="line">    /*Turning a pointer into a usize: */</span><br><span class="line">    let ptr = &amp;0;</span><br><span class="line">    let ptr_num_transmute = unsafe &#123; std::mem::transmute::&lt;&amp;i32, usize&gt;(ptr) &#125;;</span><br><span class="line"></span><br><span class="line">    // Use an `as` cast instead</span><br><span class="line">    let ptr_num_cast = ptr as *const i32 as usize;</span><br><span class="line"></span><br><span class="line">    /*Turning an &amp;mut T into an &amp;mut U: */</span><br><span class="line">    let ptr = &amp;mut 0;</span><br><span class="line">    let val_transmuted = unsafe &#123; std::mem::transmute::&lt;&amp;mut i32, &amp;mut u32&gt;(ptr) &#125;;</span><br><span class="line"></span><br><span class="line">    // Now, put together `as` and reborrowing - note the chaining of `as`</span><br><span class="line">    // `as` is not transitive</span><br><span class="line">    let val_casts = unsafe &#123; &amp;mut *(ptr as *mut i32 as *mut u32) &#125;;</span><br><span class="line"></span><br><span class="line">    /*Turning an &amp;str into a &amp;[u8]: */</span><br><span class="line">    // this is not a good way to do this.</span><br><span class="line">    let slice = unsafe &#123; std::mem::transmute::&lt;&amp;str, &amp;[u8]&gt;(&quot;Rust&quot;) &#125;;</span><br><span class="line">    assert_eq!(slice, &amp;[82, 117, 115, 116]);</span><br><span class="line"></span><br><span class="line">    // You could use `str::as_bytes`</span><br><span class="line">    let slice = &quot;Rust&quot;.as_bytes();</span><br><span class="line">    assert_eq!(slice, &amp;[82, 117, 115, 116]);</span><br><span class="line"></span><br><span class="line">    // Or, just use a byte string, if you have control over the string</span><br><span class="line">    // literal</span><br><span class="line">    assert_eq!(b&quot;Rust&quot;, &amp;[82, 117, 115, 116]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词</p><p>我们在Rust 中通过输入 fn 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>我们可以定义为拥有 <strong>参数</strong>（<em>parameters</em>）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（<em>arguments</em>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    another_function(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn another_function(x: i32) &#123;</span><br><span class="line">    println!(&quot;The value of x is: &#123;x&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义多个参数时，使用逗号分隔</p><h3 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h3><p>函数体由一系列的语句和一个可选的结尾表达式构成。</p><p><strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。</p><p><strong>表达式</strong>（<em>Expressions</em>）计算并产生一个值。</p><p>语句不返回值，表达式会计算出一个值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5u32;</span><br><span class="line"></span><br><span class="line">    let y = &#123;</span><br><span class="line">        let x_squared = x * x;</span><br><span class="line">        let x_cube = x_squared * x;</span><br><span class="line"></span><br><span class="line">        // 下面表达式的值将被赋给 `y`</span><br><span class="line">        x_cube + x_squared + x</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let z = &#123;</span><br><span class="line">        // 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`</span><br><span class="line">        2 * x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;x is &#123;:?&#125;&quot;, x);</span><br><span class="line">    println!(&quot;y is &#123;:?&#125;&quot;, y);</span><br><span class="line">    println!(&quot;z is &#123;:?&#125;&quot;, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 let y = 6; 中的 6 是一个表达式，它计算出的值是 6。<strong>函数调用是一个表达式</strong>。<strong>宏调用是一个表达式</strong>。<strong>用大括号创建的一个新的块作用域也是一个表达式</strong>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let y = &#123;</span><br><span class="line">        let x = 3;</span><br><span class="line">        x + 1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The value of y is: &#123;y&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let x = 3;</span><br><span class="line">    x + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个代码块，它的值是 4。表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>不对返回值命名，但要在箭头（-&gt;）后声明它的类型</p><p>在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = plus_one(5);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The value of x is: &#123;x&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">    x + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回类型为"><a href="#返回类型为" class="headerlink" title="返回类型为()"></a><strong>返回类型为()</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,type_of(&amp;println!(&quot;helloworld&quot;)))</span><br><span class="line">&#125;</span><br><span class="line">fn type_of&lt;T&gt;(_: &amp;T) -&gt; String&#123;</span><br><span class="line">    format!(&quot;&#123;&#125;&quot;,std::any::type_name::&lt;T&gt;())</span><br><span class="line">&#125;</span><br><span class="line">//output:</span><br><span class="line">//helloworld</span><br><span class="line">//()</span><br></pre></td></tr></table></figure><h4 id="返回类型为never"><a href="#返回类型为never" class="headerlink" title="返回类型为never"></a>返回类型为never</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    never_return();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn never_return() -&gt; ! &#123;</span><br><span class="line">    // implement this function, don&#x27;t modify fn signatures</span><br><span class="line">    panic!(&quot;I return nothing!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    never_return();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use std::thread;</span><br><span class="line">use std::time;</span><br><span class="line"></span><br><span class="line">fn never_return() -&gt; ! &#123;</span><br><span class="line">    // implement this function, don&#x27;t modify fn signatures</span><br><span class="line">    loop &#123;</span><br><span class="line">        println!(&quot;I return nothing&quot;);</span><br><span class="line">        // sleeping for 1 second to avoid exhausting the cpu resource</span><br><span class="line">        thread::sleep(time::Duration::from_secs(1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发散函数（Diverging-function）"><a href="#发散函数（Diverging-function）" class="headerlink" title="发散函数（Diverging function）"></a>发散函数（Diverging function）</h4><p>发散函数( Diverging function )不会返回任何值，因此它们可以用于替代需要返回任何值的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">    match tp &#123;</span><br><span class="line">        1 =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 这里与其返回一个 None，不如使用发散函数替代</span><br><span class="line">    never_return_fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用三种方法实现以下发散函数</span><br><span class="line">fn never_return_fn() -&gt; ! &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">    match tp &#123;</span><br><span class="line">        1 =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    never_return_fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IMPLEMENT this function</span><br><span class="line">// DON&#x27;T change any code else</span><br><span class="line">fn never_return_fn() -&gt; ! &#123;</span><br><span class="line">    unimplemented!()</span><br><span class="line">&#125;</span><br><span class="line">// IMPLEMENT this function in THREE ways</span><br><span class="line">fn never_return_fn() -&gt; ! &#123;</span><br><span class="line">    panic!()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IMPLEMENT this function in THREE ways</span><br><span class="line">fn never_return_fn() -&gt; ! &#123;</span><br><span class="line">    todo!();</span><br><span class="line">&#125;</span><br><span class="line">// IMPLEMENT this function in THREE ways</span><br><span class="line">fn never_return_fn() -&gt; ! &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        std::thread::sleep(std::time::Duration::from_secs(1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The difference between unimplemented! and [todo] is that while todo! conveys an intent of implementing the functionality later and the message is “not yet implemented”, unimplemented! makes no such claims. Its message is “not implemented”. Also some IDEs will mark todo!s.</p><p><strong>调用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#[allow(unused)]</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    get_option(3);</span><br><span class="line">    println!(&quot;Success!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">    match tp &#123;</span><br><span class="line">        1 =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            // TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    never_return_fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IMPLEMENT this function</span><br><span class="line">// DON&#x27;T change any code else</span><br><span class="line">fn never_return_fn() -&gt; ! &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        std::thread::sleep(std::time::Duration::from_secs(1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用unimplemented!()和todo!();会报以下错误</p><p>thread ‘main’ panicked at ‘not implemented’, src\main.rs:24:5</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let _v = match b &#123;</span><br><span class="line">        true =&gt; 1,</span><br><span class="line">        // 发散函数也可以用于 `match` 表达式，用于替代任何类型的值</span><br><span class="line">        false =&gt; &#123;</span><br><span class="line">            println!(&quot;Success!&quot;);</span><br><span class="line">            panic!(&quot;we have no value for `false`, but we can panic&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let number = 3;</span><br><span class="line"></span><br><span class="line">    if number &lt; 5 &#123;</span><br><span class="line">        println!(&quot;condition was true&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;condition was false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 表达式中与条件关联的代码块有时被叫做 *arms</p><p>if/else 可以用作表达式来进行赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let n = 5;</span><br><span class="line"></span><br><span class="line">    let big_n =</span><br><span class="line">        if n &lt; 10 &amp;&amp; n &gt; -10 &#123;</span><br><span class="line">            println!(&quot; 数字太小，先增加 10 倍再说&quot;);</span><br><span class="line"></span><br><span class="line">            10 * n</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;数字太大，我们得让它减半&quot;);</span><br><span class="line"></span><br><span class="line">            n / 2 </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>1.代码中的条件 <strong>必须</strong> 是 bool 值。如果条件不是 bool 值，我们将得到一个错误。Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 if 的条件。</p><p>2.如果使用了多于1个else if最好使用match对代码进行重构</p><h3 id="在let语句中使用if"><a href="#在let语句中使用if" class="headerlink" title="在let语句中使用if"></a>在let语句中使用if</h3><p>因为 if 是一个表达式，我们可以在 let 语句的右侧使用它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let condition = true;</span><br><span class="line">    let number = if condition &#123; 5 &#125; else &#123; 6 &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The value of number is: &#123;number&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 的每个分支的可能的返回值都必须是相同类型</p><p><strong>注意</strong></p><p>if 代码块中的表达式返回一个整数，而 else 代码块中的表达式返回一个字符串。这不可行，因为变量必须只有一个类型。Rust 需要在编译时就确切的知道变量的类型</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        println!(&quot;again!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从循环中返回值"><a href="#从循环中返回值" class="headerlink" title="从循环中返回值"></a>从循环中返回值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut counter = 0;</span><br><span class="line"></span><br><span class="line">    let result = loop &#123;</span><br><span class="line">        counter += 1;</span><br><span class="line"></span><br><span class="line">        if counter == 10 &#123;</span><br><span class="line">            break counter * 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The result is &#123;result&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h5><p>如果存在嵌套循环，break 和 continue 应用于此时最内层的循环。你可以选择在一个循环上指定一个 <strong>循环标签</strong>（<em>loop label</em>），然后将标签与 break 或 continue 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0;</span><br><span class="line">    &#x27;counting_up: loop &#123;</span><br><span class="line">        println!(&quot;count = &#123;count&#125;&quot;);</span><br><span class="line">        let mut remaining = 10;</span><br><span class="line"></span><br><span class="line">        loop &#123;</span><br><span class="line">            println!(&quot;remaining = &#123;remaining&#125;&quot;);</span><br><span class="line">            if remaining == 9 &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if count == 2 &#123;</span><br><span class="line">                break &#x27;counting_up;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;End count = &#123;count&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut number = 3;</span><br><span class="line"></span><br><span class="line">    while number != 0 &#123;</span><br><span class="line">        println!(&quot;&#123;number&#125;!&quot;);</span><br><span class="line"></span><br><span class="line">        number -= 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;LIFTOFF!!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [10, 20, 30, 40, 50];</span><br><span class="line"></span><br><span class="line">    for element in a &#123;</span><br><span class="line">        println!(&quot;the value is: &#123;element&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for循环遍历集合元素相较于while循环，增强了代码安全性，并消除了可能由于超出数组的结尾或遍历长度不够而缺少一些元素而导致的 bug</p><p>对于没有实现copy的可迭代对象for in 会取得所有权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];</span><br><span class="line">    for name in &amp;names &#123;</span><br><span class="line">        // do something with name...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, names);</span><br><span class="line"></span><br><span class="line">    let numbers = [1, 2, 3];</span><br><span class="line">    // numbers中的元素实现了 Copy，因此无需转移所有权</span><br><span class="line">    for n in numbers &#123;</span><br><span class="line">        // do something with name...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过索引和值的方式迭代数组"><a href="#通过索引和值的方式迭代数组" class="headerlink" title="通过索引和值的方式迭代数组"></a>通过索引和值的方式迭代数组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = [4,3,2,1];</span><br><span class="line"></span><br><span class="line">    // 通过索引和值的方式迭代数组 `a` </span><br><span class="line">    for (i,v) in a.iter().enumerate() &#123;</span><br><span class="line">        println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;,i+1,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Range</strong></p><p>它是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列。(不包括结束的数字)</p><p>rev方法可以反转range</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    for number in (1..4).rev() &#123;</span><br><span class="line">        println!(&quot;&#123;number&#125;!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;LIFTOFF!!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="所有权，引用与借用"><a href="#所有权，引用与借用" class="headerlink" title="所有权，引用与借用"></a>所有权，引用与借用</h1><h2 id="栈（Stack）与堆（Heap）"><a href="#栈（Stack）与堆（Heap）" class="headerlink" title="栈（Stack）与堆（Heap）"></a>栈（Stack）与堆（Heap）</h2><p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。</p><p>增加数据叫做 <strong>进栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。栈中的所有数据都必须占用已知且固定的大小。</p><p>在编译时大小未知或大小可能变化的数据，要改为存储在堆上。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。</p><p>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p><p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存），出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。</p><p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p><p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p><h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ol><li><strong>Rust 中的每一个值都有一个 所有者（<em>*</em></strong>owner<strong>*</strong>）。**</li><li><strong>值在任一时刻有且只有一个所有者。</strong></li><li><strong>当所有者（变量）离开作用域，这个值将被丢弃。</strong></li></ol><p>所有权的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = give_ownership();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只能修改下面的代码!</span><br><span class="line">fn give_ownership() -&gt; String &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line">    // convert String to Vec</span><br><span class="line">    // 将 String 转换成 Vec 类型</span><br><span class="line">    let _s = s.into_bytes();//into_bytes会转移所有权</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = give_ownership();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Only modify the code below!</span><br><span class="line">fn give_ownership() -&gt; String &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line">    // convert String to Vec</span><br><span class="line">    let _s = s.as_bytes();//as_bytes不会转移所有权</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = give_ownership();</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Only modify the code below!</span><br><span class="line">fn give_ownership() -&gt; String &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当所有权转移时，可变性也可以随之改变。"><a href="#当所有权转移时，可变性也可以随之改变。" class="headerlink" title="当所有权转移时，可变性也可以随之改变。"></a>当所有权转移时，可变性也可以随之改变。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, &quot;);</span><br><span class="line">    </span><br><span class="line">    let mut s1 = s;</span><br><span class="line"></span><br><span class="line">    s1.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量与作用域"><a href="#变量与作用域" class="headerlink" title="变量与作用域"></a>变量与作用域</h2><p>作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p><p>let s = “hello”;</p><p>变量 s 绑定到了一个字符串字面值，这个字符串值是<strong>硬编码</strong>进程序代码中的。这个变量从声明的点开始直到当前 <strong>作用域</strong> 结束时都是有效的。示例 4-1 中的注释标明了变量 s 在何处是有效的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      // s 在这里无效, 它尚未声明</span><br><span class="line">        let s = &quot;hello&quot;;   // 从此处起，s 是有效的</span><br><span class="line"></span><br><span class="line">        // 使用 s</span><br><span class="line">    &#125;                      // 此作用域已结束，s 不再有效</span><br></pre></td></tr></table></figure><ul><li>当 s<strong>进入作用域</strong> 时，它就是有效的。</li><li>这一直持续到它 <strong>离开作用域</strong> 为止。</li></ul><h2 id="str和-amp-str"><a href="#str和-amp-str" class="headerlink" title="str和&amp;str"></a>str和&amp;str</h2><p>正常情况下我们无法使用 str 类型，但是可以使用 &amp;str 来替代</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s: &amp;str = &quot;hello, world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要使用 str 类型，只能配合 Box。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s: Box&lt;str&gt; = &quot;hello, world&quot;.into();</span><br><span class="line">    greetings(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: Box&lt;str&gt;) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&amp; 可以用来将 Box<str> 转换为 &amp;str 类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s: Box&lt;str&gt; = &quot;hello, world&quot;.into();</span><br><span class="line">    greetings(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: &amp;str) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String 是定义在标准库中的类型，分配在堆上，可以动态的增长。它的底层存储是动态字节数组的方式( Vec<u8> )，但是与字节数组不同，String 是 UTF-8 编码。</p><p>Rust 有第二个字符串类型，String。这个类型管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String</p><p>let s = String::from(“hello”);</p><p><strong>可以</strong> 修改此类字符串 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    s.push_str(&quot;, world!&quot;); // push_str() 在字符串后追加字面值</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, s); // 将打印 `hello, world!`</span><br></pre></td></tr></table></figure><h2 id="内存与分配"><a href="#内存与分配" class="headerlink" title="内存与分配"></a>内存与分配</h2><p>就字符串字面值来说，我们在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p><p>对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p><ul><li>必须在运行时向内存分配器（memory allocator）请求内存。</li><li>需要一个当我们处理完 String 时将内存返回给分配器的方法。（某些语言的垃圾回收GC）</li></ul><p>Rust 采取了一个不同的策略：<strong>内存在拥有它的变量离开作用域后就被自动释放</strong>。下面是示例 4-1 中作用域例子的一个使用 String 而不是字符串字面值的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的</span><br><span class="line"></span><br><span class="line">        // 使用 s</span><br><span class="line">    &#125;                                  // 此作用域已结束，</span><br><span class="line">                                       // s 不再有效</span><br></pre></td></tr></table></figure><p>这是一个将 String 需要的内存返回给分配器的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop">drop</a>，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。</p><h2 id="变量与数据交互的方式"><a href="#变量与数据交互的方式" class="headerlink" title="变量与数据交互的方式"></a>变量与数据交互的方式</h2><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p><strong>栈数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let x = 5;</span><br><span class="line"> let y = x;</span><br></pre></td></tr></table></figure><p>将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y”。现在有了两个变量，x 和 y，都等于 5</p><p>因为整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中。</p><p>对于此类数据，移动和克隆没有区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">let s2 = s1;</span><br></pre></td></tr></table></figure><p>一个String由3部分组成：</p><ol><li>一个指向存放字符串内容的内存的指针</li><li>一个长度len,指存放字符串内容所需的字节数</li><li>一个容量capacity,指String从操作系统中总共获得内存的总字节数</li></ol><p>上面这些<strong>存放在栈上</strong></p><p>存放字符串内容的部分存放在heap上</p><p>当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。</p><p>当变量离开时，会调用drop,导致double free</p><p>为了保证内存安全</p><ul><li>Rust没有尝试复制被分配的内存</li><li>Rust让s1失效，即变量s1离开作用域时不需要释放任何东西（对应所有权规则2:值在任一时刻有且只有一个所有者）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">    let s2 = s1;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, world!&quot;, s1);</span><br><span class="line">warning: unused variable: `s2`</span><br><span class="line"> --&gt; src\main.rs:3:9</span><br><span class="line">  |</span><br><span class="line">3 |     let s2 = s1;</span><br><span class="line">  |         ^^ help: if this is intentional, prefix it with an underscore: `_s2`</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_variables)]` on by default</span><br><span class="line"></span><br><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"> --&gt; src\main.rs:5:28</span><br><span class="line">  |</span><br><span class="line">2 |     let s1 = String::from(&quot;hello&quot;);</span><br><span class="line">  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">3 |     let s2 = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line">4 |</span><br><span class="line">5 |     println!(&quot;&#123;&#125;, world!&quot;, s1);</span><br><span class="line">  |                            ^^ value borrowed here after move</span><br><span class="line">  |</span><br><span class="line">  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">warning: `loop_test` (bin &quot;loop_test&quot;) generated 1 warning</span><br><span class="line">error: could not compile `loop_test` due to previous error; 1 warning emitted</span><br></pre></td></tr></table></figure><p>rust的这种方式不同于浅拷贝，因为在浅拷贝的同时让被拷贝者失效了，因此使用新的术语：移动(Move)</p><p><strong>隐含的设计原则**</strong>rust不会自动创建数据的深拷贝**</p><p>因为就运行性能而言，任何自动赋值的操作都是廉价的</p><h4 id="部分move"><a href="#部分move" class="headerlink" title="部分move"></a>部分move</h4><p>当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。</p><p>在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    #[derive(Debug)]</span><br><span class="line">    struct Person &#123;</span><br><span class="line">        name: String,</span><br><span class="line">        age: Box&lt;u8&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let person = Person &#123;</span><br><span class="line">        name: String::from(&quot;Alice&quot;),</span><br><span class="line">        age: Box::new(20),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`</span><br><span class="line">    // 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age </span><br><span class="line">    let Person &#123; name, ref age &#125; = person;</span><br><span class="line"></span><br><span class="line">    println!(&quot;The person&#x27;s age is &#123;&#125;&quot;, age);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The person&#x27;s name is &#123;&#125;&quot;, name);</span><br><span class="line"></span><br><span class="line">    // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它</span><br><span class="line">    //println!(&quot;The person struct is &#123;:?&#125;&quot;, person);</span><br><span class="line"></span><br><span class="line">    // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用</span><br><span class="line">    println!(&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;, person.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>如果相对heap的数据进行深拷贝，而不仅仅时stack上面的数据，可以使用clone方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let s1=String::from(&quot;Hello&quot;);</span><br><span class="line">let s2=s1.clone();</span><br><span class="line">println!(&quot;&#123;&#125;,&#123;&#125;&quot;,s1,s2);</span><br><span class="line">#[allow(unused)]</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));</span><br><span class="line"></span><br><span class="line">    let (s1, s2) = t.clone();</span><br><span class="line"> </span><br><span class="line">    println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>Copy trait,可以用于像整数这样完全放在stack上面的类型</p><ul><li>如果一个类型实现了Copy trait，那么旧的变量在赋值后仍然可用</li><li>如果一个类型或该类型的一部分实现了Drop trait，那么Rust不允许让它再去实现Copy trait了</li></ul><p>任何简单标量的组合类型都是Copy的</p><p>任何需要分配内存或某种资源的都不是Copy的</p><p>一些拥有Copy trait的类型：</p><ul><li>所有整数类型，比如 u32。</li><li>布尔类型，bool，它的值是 true 和 false。</li><li>所有浮点数类型，比如 f64。</li><li>字符类型，char。</li><li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</li></ul><h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);  // s 进入作用域</span><br><span class="line"></span><br><span class="line">    takes_ownership(s);             // s 的值移动到函数里 ...</span><br><span class="line">                                    // ... 所以到这里不再有效</span><br><span class="line"></span><br><span class="line">    let x = 5;                      // x 进入作用域</span><br><span class="line"></span><br><span class="line">    makes_copy(x);                  // x 应该移动函数里，</span><br><span class="line">                                    // 但 i32 是 Copy 的，</span><br><span class="line">                                    // 所以在后面可继续使用 x</span><br><span class="line"></span><br><span class="line">&#125; // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br><span class="line">  // 没有特殊之处</span><br><span class="line"></span><br><span class="line">fn takes_ownership(some_string: String) &#123; // some_string 进入作用域</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, some_string);</span><br><span class="line">&#125; // 这里，some_string 移出作用域并调用 `drop` 方法。</span><br><span class="line">  // 占用的内存被释放</span><br><span class="line"></span><br><span class="line">fn makes_copy(some_integer: i32) &#123; // some_integer 进入作用域</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, some_integer);</span><br><span class="line">&#125; // 这里，some_integer 移出作用域。没有特殊之处</span><br></pre></td></tr></table></figure><p>当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。</p><h3 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h3><p>返回值也可以转移所有权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = gives_ownership();         // gives_ownership 将返回值</span><br><span class="line">                                        // 转移给 s1</span><br><span class="line"></span><br><span class="line">    let s2 = String::from(&quot;hello&quot;);     // s2 进入作用域</span><br><span class="line"></span><br><span class="line">    let s3 = takes_and_gives_back(s2);  // s2 被移动到</span><br><span class="line">                                        // takes_and_gives_back 中,</span><br><span class="line">                                        // 它也将返回值移给 s3</span><br><span class="line">&#125; // 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br><span class="line">  // 所以什么也不会发生。s1 离开作用域并被丢弃</span><br><span class="line"></span><br><span class="line">fn gives_ownership() -&gt; String &#123;             // gives_ownership 会将</span><br><span class="line">                                             // 返回值移动给</span><br><span class="line">                                             // 调用它的函数</span><br><span class="line"></span><br><span class="line">    let some_string = String::from(&quot;yours&quot;); // some_string 进入作用域.</span><br><span class="line"></span><br><span class="line">    some_string                              // 返回 some_string </span><br><span class="line">                                             // 并移出给调用的函数</span><br><span class="line">                                             // </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="line">fn takes_and_gives_back(a_string: String) -&gt; String &#123; // a_string 进入作用域</span><br><span class="line">                                                      // </span><br><span class="line"></span><br><span class="line">    a_string  // 返回 a_string 并移出给调用的函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的所有权总是遵循相同的模式：</p><ul><li><strong>将值赋给另一个变量时移动它</strong>。</li><li>当持有堆中数据值的变量<strong>离开作用域时</strong>，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。</li></ul><p>如果让函数获得所得值而不获得所有权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let (s2, len) = calculate_length(s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn calculate_length(s: String) -&gt; (String, usize) &#123;</span><br><span class="line">    let length = s.len(); // len() 返回字符串的长度</span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样过于麻烦，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 <strong>引用</strong>（<em>references</em>）。</p><h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn calculate_length(s: &amp;String) -&gt; usize &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用</strong>（<em>reference</em>）像一个指针，因为<strong>它是一个地址</strong>，我们可以由此访问储存于该地址的属于其他变量的数据。 </p><p>与指针不同，<strong>引用确保指向某个特定类型的有效值。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let x = 5;</span><br><span class="line">   // 填写空白处</span><br><span class="line">   let p = &amp;x;</span><br><span class="line"></span><br><span class="line">   println!(&quot;x 的内存地址是 &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：与使用 &amp; 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符，*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let len = calculate_length(&amp;s1);</span><br></pre></td></tr></table></figure><p>&amp;s1 语法让我们创建一个 <strong>指向</strong> 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以<strong>当引用停止使用时，它所指向的值也不会被丢弃</strong>。</p><p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）</p><p>正如变量默认是不可变的，引用也一样。<strong>引用（默认）不允许修改引用的值。</strong></p><h3 id="rust会在某些情况下自动解引用"><a href="#rust会在某些情况下自动解引用" class="headerlink" title="rust会在某些情况下自动解引用"></a>rust会在某些情况下自动解引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let p = &amp;mut s;</span><br><span class="line">    </span><br><span class="line">    p.push_str(&quot;world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;String) &#123;&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    push_str(&amp;mut s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn push_str(s: &amp;mut String) &#123;</span><br><span class="line">    s.push_str(&quot;world&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    change(&amp;mut s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn change(some_string: &amp;mut String) &#123;</span><br><span class="line">    some_string.push_str(&quot;, world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变引用有一个很大的限制：<strong>如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。这些尝试创建两个</strong> <strong>s</strong> <strong>的可变引用的代码会失败</strong>(这<strong>没有考虑NIL</strong>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br></pre></td></tr></table></figure><p>考虑NIL这段代码不会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br></pre></td></tr></table></figure><p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <strong>同时</strong> 拥有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let r1 = &amp;mut s;</span><br><span class="line">    &#125; // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span><br><span class="line"></span><br><span class="line">    let r2 = &amp;mut s;</span><br></pre></td></tr></table></figure><p>另外一个限制：<strong>不可以同时拥有一个可变引用和一个不可变的引用</strong></p><p>但是<strong>多个不可变的引用是可以的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;s; // 没问题</span><br><span class="line">    let r2 = &amp;s; // 没问题</span><br><span class="line">    let r3 = &amp;mut s; // 大问题</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br></pre></td></tr></table></figure><h3 id="悬空引用（悬垂引用Dangling-References"><a href="#悬空引用（悬垂引用Dangling-References" class="headerlink" title="悬空引用（悬垂引用Dangling References)"></a>悬空引用（悬垂引用Dangling References)</h3><p>在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p><p>让我们尝试创建一个悬垂引用，Rust 会通过一个编译时错误来避免：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">    let s = String::from(&quot;hello&quot;);//s在函数结束后就drop了</span><br><span class="line">    &amp;s//返回引用，但是函数结束后该地址就被释放掉了</span><br><span class="line">&#125;</span><br><span class="line">Compiling loop_test v0.1.0 (C:\Users\cauchy\Desktop\rust\loop_test)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src\main.rs:5:16</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="line">help: consider using the `&#x27;static` lifetime</span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;&#x27;static String &#123;</span><br><span class="line">  |                 +++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `loop_test` due to previous error</span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 与 &amp; 类似，可以用来获取一个值的引用，但是它们的用法有所不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let c = &#x27;中&#x27;;</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;c;</span><br><span class="line">    // 填写空白处，但是不要修改其它行的代码</span><br><span class="line">    let ref r2 = c;</span><br><span class="line"></span><br><span class="line">    assert_eq!(*r1, *r2);</span><br><span class="line">    </span><br><span class="line">    // 判断两个内存地址的字符串是否相等</span><br><span class="line">    assert_eq!(get_addr(r1),get_addr(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取传入引用的内存地址的字符串形式</span><br><span class="line">fn get_addr(r: &amp;char) -&gt; String &#123;</span><br><span class="line">    format!(&quot;&#123;:p&#125;&quot;, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用规则-借用规则-总结"><a href="#引用规则-借用规则-总结" class="headerlink" title="引用规则(借用规则)总结"></a>引用规则(借用规则)总结</h3><ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li><li>引用必须总是有效的。</li></ul><p>Ok: 从可变对象借用不可变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    borrow_object(&amp;s);</span><br><span class="line">    </span><br><span class="line">    s.push_str(&quot;world&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn borrow_object(s: &amp;String) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="None-Lexical-Lifetimes-NLL-非词法作用域生命周期"><a href="#None-Lexical-Lifetimes-NLL-非词法作用域生命周期" class="headerlink" title="None Lexical Lifetimes(NLL)非词法作用域生命周期"></a>None Lexical Lifetimes(NLL)非词法作用域生命周期</h3><p><a href="https://zhuanlan.zhihu.com/p/32884290">https://zhuanlan.zhihu.com/p/32884290</a></p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 注释掉一行代码让它工作</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    r1.push_str(&quot;world&quot;);</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line">    r2.push_str(&quot;!&quot;);</span><br><span class="line">    </span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,r1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释掉println即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    r1.push_str(&quot;world&quot;);//rust编译器知道这之后r1对s的借用生命周期结束了</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line">    r2.push_str(&quot;!&quot;);</span><br><span class="line">    </span><br><span class="line">    //println!(&quot;&#123;&#125;&quot;,r1);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut x = 22;</span><br><span class="line"></span><br><span class="line">    let p = &amp;mut x; // mutable borrow</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, x); // later used</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码顺利编译，因为编译器知道 x 的可变借用并没有持续到作用域结尾，而是在 x 被再次使用之前就结束了，所以这里不存在冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time</span><br><span class="line">    // 你不能同时使用 r1 和 r2</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入r1.push_str(“world”);即可</p><h2 id="切片-Slice-类型"><a href="#切片-Slice-类型" class="headerlink" title="切片 Slice 类型"></a>切片 Slice 类型</h2><p><em>slice</em> 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn first_word(s: &amp;String) -&gt; usize &#123;</span><br><span class="line">    let bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    for (i, &amp;item) in bytes.iter().enumerate() &#123;</span><br><span class="line">        if item == b&#x27; &#x27; &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数接收一个用空格分隔单词的字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。</p><p>first_word 函数有一个参数 &amp;String。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取 <strong>部分</strong> 字符串的办法。不过，我们可以返回单词结尾的索引，结尾由一个空格表示</p><p>因为需要逐个元素的检查 String 中的值是否为空格，需要用 as_bytes 方法将 String 转化为字节数组：</p><p>​    let bytes = s.as_bytes();</p><p>接下来，使用 iter 方法在字节数组上创建一个迭代器：</p><p>​    for (i, &amp;item) in bytes.iter().enumerate() {</p><p>因为 enumerate 方法返回一个元组，我们可以使用模式来解构，所以在 for 循环中，我们指定了一个模式，其中元组中的 i 是索引而元组中的 &amp;item 是单个字节。因为我们从 .iter().enumerate() 中获取了集合元素的引用，所以模式中使用了 &amp;。</p><p>不过这有一个问题。我们返回了一个独立的 usize，不过它只在 &amp;String 的上下文中才是一个有意义的数字。换句话说，因为它是一个与 String 相分离的值，无法保证将来它仍然有效。</p><h3 id="字符串切片string-slice"><a href="#字符串切片string-slice" class="headerlink" title="字符串切片string slice"></a>字符串切片string slice</h3><p><strong>字符串 slice</strong>（<em>string slice</em>）是 String 中一部分值的引用，它看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">    let hello = &amp;s[0..5];</span><br><span class="line">    let world = &amp;s[6..11];</span><br></pre></td></tr></table></figure><p><strong>[开始索引..终止索引]</strong></p><p><strong>[starting_index..ending_index]</strong></p><p>其中 starting_index 是 slice 的第一个位置，ending_index 则是 slice <strong>最后一个位置的后一个值。</strong></p><p>如果想要从索引 0 开始，可以不写两个点号之前的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[0..2];</span><br><span class="line">let slice = &amp;s[..2];</span><br></pre></td></tr></table></figure><p>如果 slice 包含 String 的最后一个字节，也可以舍弃尾部的数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[3..len];</span><br><span class="line">let slice = &amp;s[3..];</span><br></pre></td></tr></table></figure><p>也可以同时舍弃这两个值来获取整个字符串的 slice</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s = String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[0..len];</span><br><span class="line">let slice = &amp;s[..];</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;你好，世界&quot;;</span><br><span class="line">    let slice = &amp;s[0..3];</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,slice);</span><br><span class="line">    assert!(slice == &quot;你&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写函数，返回一个slice(字符串切片返回值可以写成：&amp;str)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn first_word(s: &amp;String) -&gt; &amp;str &#123;</span><br><span class="line">    let bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    for (i, &amp;item) in bytes.iter().enumerate() &#123;</span><br><span class="line">        if item == b&#x27; &#x27; &#123;</span><br><span class="line">            return &amp;s[0..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">    let word = first_word(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.clear(); // 错误!</span><br><span class="line"></span><br><span class="line">    println!(&quot;the first word is: &#123;&#125;&quot;, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 clear 需要清空 String，它尝试获取一个可变引用。在调用 clear 之后的 println! 使用了 word 中的引用，所以这个不可变的引用在此时必须仍然有效。Rust 不允许 clear 中的可变引用和 word 中的不可变引用同时存在，因此编译失败</p><h3 id="字符串字面值就是slice"><a href="#字符串字面值就是slice" class="headerlink" title="字符串字面值就是slice"></a>字符串字面值就是slice</h3><p>let s = “Hello, world!”;</p><p>这里 s 的类型是 &amp;str：它是一个指向二进制程序特定位置的 slice,这也就是为什么字符串字面值是不可变的；&amp;str 是一个不可变引用。</p><h3 id="字符串slice作为参数"><a href="#字符串slice作为参数" class="headerlink" title="字符串slice作为参数"></a>字符串slice作为参数</h3><p>在知道了能够获取字面值和 String 的 slice 后，我们对 first_word 做了改进，这是它的签名：</p><p>fn first_word(s: &amp;String) -&gt; &amp;str {</p><p>而更有经验的 Rustacean 会编写出如下的签名，因为它使得可以对 &amp;String 值和 &amp;str 值使用相同的函数：</p><p>fn first_word(s: &amp;str) -&gt; &amp;str {</p><p>如果有一个字符串 slice，可以直接传递它。如果有一个 String，则可以传递整个 String 的 slice 或对 String 的引用。这种灵活性利用了 <em>deref coercions</em> 的优势，定义一个获取字符串 slice 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let my_string = String::from(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">    // `first_word` 适用于 `String`（的 slice），整体或全部</span><br><span class="line">    let word = first_word(&amp;my_string[0..6]);</span><br><span class="line">    let word = first_word(&amp;my_string[..]);</span><br><span class="line">    // `first_word` 也适用于 `String` 的引用，</span><br><span class="line">    // 这等价于整个 `String` 的 slice</span><br><span class="line">    let word = first_word(&amp;my_string);</span><br><span class="line"></span><br><span class="line">    let my_string_literal = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">    // `first_word` 适用于字符串字面值，整体或全部</span><br><span class="line">    let word = first_word(&amp;my_string_literal[0..6]);</span><br><span class="line">    let word = first_word(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    // 因为字符串字面值已经 **是** 字符串 slice 了，</span><br><span class="line">    // 这也是适用的，无需 slice 语法！</span><br><span class="line">    let word = first_word(my_string_literal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&amp;String可以被隐式地转换为&amp;str类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello world&quot;);</span><br><span class="line"></span><br><span class="line">    // 这里, &amp;s 是 `&amp;String` 类型，但是 `first_character` 函数需要的是 `&amp;str` 类型。</span><br><span class="line">    // 尽管两个类型不一样，但是代码仍然可以工作，原因是 `&amp;String` 会被隐式地转换成 `&amp;str` 类型，如果大家想要知道更多，可以看看 Deref 章节: https://course.rs/advance/smart-pointer/deref.html</span><br><span class="line">    let ch = first_character(&amp;s);</span><br><span class="line"></span><br><span class="line">    println!(&quot;the first character is: &#123;&#125;&quot;, ch);</span><br><span class="line">    s.clear();</span><br><span class="line">&#125;</span><br><span class="line">fn first_character(s: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">    &amp;s[..1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他类型的slice"><a href="#其他类型的slice" class="headerlink" title="其他类型的slice"></a>其他类型的slice</h3><p>字符串 slice，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：</p><p>let a = [1, 2, 3, 4, 5];</p><p>就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">let slice = &amp;a[1..3];</span><br><span class="line"></span><br><span class="line">assert_eq!(slice, &amp;[2, 3]);</span><br></pre></td></tr></table></figure><p>这个 slice 的类型是 &amp;[i32]。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。</p><p>切片跟数组相似，但是<strong>切片的长度无法在编译期得知</strong>，因此你<strong>无法直接使用切片类型</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 修复代码中的错误，不要新增代码行!</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let arr = [1, 2, 3];</span><br><span class="line">    let s1: [i32] = arr[0..2];</span><br><span class="line"></span><br><span class="line">    let s2: str = &quot;hello, world&quot; as str;</span><br><span class="line">&#125;</span><br><span class="line">//修复后</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let arr = [1, 2, 3];</span><br><span class="line">    let s1: &amp;[i32] = &amp;arr[0..2];</span><br><span class="line"></span><br><span class="line">    let s2: &amp;str = &quot;hello, world&quot; as &amp;str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个切片引用占用了<strong>2个字</strong>大小的内存空间( 从现在开始，为了简洁性考虑，如无特殊原因，我们统一使用切片来特指切片引用 )。 该切片的第一个字是指向数据的指针，第二个字是切片的长度。</li><li>字的大小取决于处理器架构，例如在 x86-64 上，字的大小是 64 位也就是 8 个字节，那么一个切片引用就是 16 个字节大小。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let arr: [char; 3] = [&#x27;中&#x27;, &#x27;国&#x27;, &#x27;人&#x27;];</span><br><span class="line"></span><br><span class="line">    let slice = &amp;arr[..2];</span><br><span class="line">    </span><br><span class="line">    assert!(std::mem::size_of_val(&amp;slice) == 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>切片( 引用 )可以用来<strong>借用数组的某个连续的部分</strong>，对应的签名是 &amp;[T]，可以与数组的签名对比下 [T; Length]。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let arr: [i32; 5] = [1, 2, 3, 4, 5];</span><br><span class="line">  </span><br><span class="line">  let slice: &amp;[i32] = &amp;arr[1..4];</span><br><span class="line">  assert_eq!(slice, &amp;[2, 3, 4]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>需要使用 struct 关键字并为整个结构体提供一个名字。</p><p>在大括号中，定义每一部分数据的名字和类型，我们称为 <strong>字段</strong>（<em>field</em>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    active: bool,</span><br><span class="line">    username: String,</span><br><span class="line">    email: String,</span><br><span class="line">    sign_in_count: u64,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        email: String::from(&quot;someone@example.com&quot;),</span><br><span class="line">        username: String::from(&quot;someusername123&quot;),</span><br><span class="line">        active: true,</span><br><span class="line">        sign_in_count: 1,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在实例化一个结构体时将它整体标记为可变的，但是 Rust <strong>不允许我们将结构体的某个字段专门指定为可变的.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: u8,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let age = 18;</span><br><span class="line">    let mut p = Person &#123;</span><br><span class="line">        name: String::from(&quot;sunface&quot;),</span><br><span class="line">        age,</span><br><span class="line">    &#125;;</span><br><span class="line">    p.age = 30;</span><br><span class="line">    p.name = String::from(&quot;sunfei&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut user1 = User &#123;</span><br><span class="line">        email: String::from(&quot;someone@example.com&quot;),</span><br><span class="line">        username: String::from(&quot;someusername123&quot;),</span><br><span class="line">        active: true,</span><br><span class="line">        sign_in_count: 1,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = String::from(&quot;anotheremail@example.com&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦struct的实例是可变的，那么实例中所有的字段都是可变的</p><h2 id="字段初始化简写"><a href="#字段初始化简写" class="headerlink" title="字段初始化简写"></a>字段初始化简写</h2><p>当字段名与字段值对应的变量名相同时，就可以使用字段初始化简写的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn build_user(email: String, username: String) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: true,</span><br><span class="line">        sign_in_count: 1,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Struct更新语法"><a href="#Struct更新语法" class="headerlink" title="Struct更新语法"></a>Struct更新语法</h2><p>基于 现有的struct实例创建一个新的实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // --snip--</span><br><span class="line"></span><br><span class="line">    let user2 = User &#123;</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,</span><br><span class="line">        email: String::from(&quot;another@example.com&quot;),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用struct更新语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // --snip--</span><br><span class="line"></span><br><span class="line">    let user2 = User &#123;</span><br><span class="line">        email: String::from(&quot;another@example.com&quot;),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tuple-Struct元组结构体"><a href="#Tuple-Struct元组结构体" class="headerlink" title="Tuple Struct元组结构体"></a>Tuple Struct元组结构体</h2><p>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。</p><p>适用于给整个元组取一个名字，并使元组成为与其他元组不同的类型时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Color(i32, i32, i32);</span><br><span class="line">struct Point(i32, i32, i32);</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let black = Color(0, 0, 0);</span><br><span class="line">    let origin = Point(0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="没有任何字段的类单元结构体（unit-like-structs）"><a href="#没有任何字段的类单元结构体（unit-like-structs）" class="headerlink" title="没有任何字段的类单元结构体（unit-like structs）"></a>没有任何字段的类单元结构体（unit-like structs）</h2><p><strong>没有任何字段的类单元结构体</strong>,它们类似于 ()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct AlwaysEqual;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let subject = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="struct中的所有权"><a href="#struct中的所有权" class="headerlink" title="struct中的所有权"></a>struct中的所有权</h2><p>在示例 5-1 中的 User 结构体的定义中，我们使用了自身拥有所有权的 String 类型而不是 &amp;str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要<strong>这个结构体拥有它所有的数据</strong>，<strong>为此只要整个结构体是有效的话其数据也是有效的。</strong></p><p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 <strong>生命周期</strong>（<em>lifetimes</em>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    active: bool,</span><br><span class="line">    username: &amp;str,</span><br><span class="line">    email: &amp;str,</span><br><span class="line">    sign_in_count: u64,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        email: &quot;someone@example.com&quot;,</span><br><span class="line">        username: &quot;someusername123&quot;,</span><br><span class="line">        active: true,</span><br><span class="line">        sign_in_count: 1,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：缺少生命周期标识符</p><h2 id="打印struct"><a href="#打印struct" class="headerlink" title="打印struct"></a>打印struct</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Rectangle&#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    length: u32,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect=Rectangle&#123;</span><br><span class="line">        width:30,</span><br><span class="line">        length:50,</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,area(&amp;rect));</span><br><span class="line">    println!(&quot;&#123;:#?&#125;&quot;,rect)</span><br><span class="line">&#125;</span><br><span class="line">fn area(rect: &amp;Rectangle)-&gt;u32&#123;</span><br><span class="line">    rect.width*rect.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="struct-的方法"><a href="#struct-的方法" class="headerlink" title="struct 的方法"></a>struct 的方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Rectangle&#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    length: u32,</span><br><span class="line">&#125;</span><br><span class="line">impl Rectangle&#123;</span><br><span class="line">    fn area(&amp;self)-&gt;u32&#123;</span><br><span class="line">        self.width*self.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect=Rectangle&#123;</span><br><span class="line">        width:30,</span><br><span class="line">        length:50,</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,rect.area());</span><br><span class="line">    println!(&quot;&#123;:#?&#125;&quot;,rect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在impl块里面定义方法</li><li>方法的第一个参数可以是&amp;self，也可以获得其所有权或可变借用，和其他参数一样</li><li>更良好的代码组织</li></ol><h2 id="方法调用的运算符"><a href="#方法调用的运算符" class="headerlink" title="方法调用的运算符"></a>方法调用的运算符</h2><p>在 C/C++ 语言中，有两个不同的运算符来调用方法：. 直接在对象上调用方法，而 -&gt; 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 object 是一个指针，那么 object-&gt;something() 就像 (*object).something() 一样。</p><p>Rust 并没有一个与 -&gt; 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。<strong>方法调用</strong>是 Rust 中<strong>少数几个拥有这种行为的地方</strong>。</p><p>它是这样工作的：当使用 object.something() 调用方法时，Rust 会自动为 object 添加 &amp;、&amp;mut 或 * 以便使 object 与方法签名匹配。也就是说，这些代码是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.distance(&amp;p2);</span><br><span class="line">(&amp;p1).distance(&amp;p2);</span><br></pre></td></tr></table></figure><p>这种自动引用的行为之所以有效，是因为方法有一个明确的接收者———— self 的类型。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（&amp;self），做出修改（&amp;mut self）或者是获取所有权（self）。</p><h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn square(size: u32) -&gt; Self &#123;</span><br><span class="line">        Self &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有在 impl 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>）</p><p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数的名称通常为 new ，但 new 并不是一个关键字。</p><p>使用结构体名和 :: 语法来调用这个关联函数：比如 let sq = Rectangle::square(3);。这个函数位于结构体的命名空间中：:: 语法用于关联函数和模块创建的命名空间</p><p>每个结构体都允许拥有多个 impl 块。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    x: f64,</span><br><span class="line">    y: f64,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// `Point` 的关联函数都放在下面的 `impl` 语句块中</span><br><span class="line">impl Point &#123;</span><br><span class="line">    // 关联函数的使用方法跟构造器非常类似</span><br><span class="line">    fn origin() -&gt; Point &#123;</span><br><span class="line">        Point &#123; x: 0.0, y: 0.0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 另外一个关联函数，有两个参数</span><br><span class="line">    fn new(x: f64, y: f64) -&gt; Point &#123;</span><br><span class="line">        Point &#123; x: x, y: y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    p1: Point,</span><br><span class="line">    p2: Point,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    // 这是一个方法</span><br><span class="line">    // `&amp;self` 是 `self: &amp;Self` 的语法糖</span><br><span class="line">    // `Self` 是当前调用对象的类型，对于本例来说 `Self` = `Rectangle`</span><br><span class="line">    fn area(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        // 使用点操作符可以访问 `self` 中的结构体字段</span><br><span class="line">        let Point &#123; x: x1, y: y1 &#125; = self.p1;</span><br><span class="line">        let Point &#123; x: x2, y: y2 &#125; = self.p2;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">        // `abs` 是一个 `f64` 类型的方法，会返回调用者的绝对值</span><br><span class="line">        ((x1 - x2) * (y1 - y2)).abs()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn perimeter(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        let Point &#123; x: x1, y: y1 &#125; = self.p1;</span><br><span class="line">        let Point &#123; x: x2, y: y2 &#125; = self.p2;</span><br><span class="line"></span><br><span class="line">        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 该方法要求调用者是可变的，`&amp;mut self` 是 `self: &amp;mut Self` 的语法糖</span><br><span class="line">    fn translate(&amp;mut self, x: f64, y: f64) &#123;</span><br><span class="line">        self.p1.x += x;</span><br><span class="line">        self.p2.x += x;</span><br><span class="line"></span><br><span class="line">        self.p1.y += y;</span><br><span class="line">        self.p2.y += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// `Pair` 持有两个分配在堆上的整数</span><br><span class="line">struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);</span><br><span class="line"></span><br><span class="line">impl Pair &#123;</span><br><span class="line">    // 该方法会拿走调用者的所有权</span><br><span class="line">    // `self` 是 `self: Self` 的语法糖</span><br><span class="line">    fn destroy(self) &#123;</span><br><span class="line">        let Pair(first, second) = self;</span><br><span class="line"></span><br><span class="line">        println!(&quot;Destroying Pair(&#123;&#125;, &#123;&#125;)&quot;, first, second);</span><br><span class="line"></span><br><span class="line">        // `first` 和 `second` 在这里超出作用域并被释放</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rectangle = Rectangle &#123;</span><br><span class="line">        // 关联函数的调用不是通过点操作符，而是使用 `::`</span><br><span class="line">        p1: Point::origin(),</span><br><span class="line">        p2: Point::new(3.0, 4.0),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 方法才是通过点操作符调用</span><br><span class="line">    // 注意，这里的方法需要的是 `&amp;self` 但是我们并没有使用 `(&amp;rectangle).perimeter()` 来调用，原因在于：</span><br><span class="line">    // 编译器会帮我们自动取引用</span><br><span class="line">    //  `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`</span><br><span class="line">    println!(&quot;Rectangle perimeter: &#123;&#125;&quot;, rectangle.perimeter());</span><br><span class="line">    println!(&quot;Rectangle area: &#123;&#125;&quot;, rectangle.area());</span><br><span class="line"></span><br><span class="line">    let mut square = Rectangle &#123;</span><br><span class="line">        p1: Point::origin(),</span><br><span class="line">        p2: Point::new(1.0, 1.0),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 错误！`rectangle` 是不可变的，但是这个方法要求一个可变的对象</span><br><span class="line">    //rectangle.translate(1.0, 0.0);</span><br><span class="line">    // TODO ^ 试着反注释此行，看看会发生什么</span><br><span class="line"></span><br><span class="line">    // 可以！可变对象可以调用可变的方法</span><br><span class="line">    square.translate(1.0, 1.0);</span><br><span class="line"></span><br><span class="line">    let pair = Pair(Box::new(1), Box::new(2));</span><br><span class="line"></span><br><span class="line">    pair.destroy();</span><br><span class="line"></span><br><span class="line">    // Error! 上一个 `destroy` 调用拿走了 `pair` 的所有权</span><br><span class="line">    //pair.destroy();</span><br><span class="line">    // TODO ^ 试着反注释此行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum IpAddrKind &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在代码中定义一个 IpAddrKind 枚举来表现这个概念并列出可能的 IP 地址类型，V4 和 V6。这被称为枚举的 <strong>成员</strong>（<em>variants</em>）：</p><p>在创建枚举时，你可以使用显式的<strong>整数</strong>设定枚举成员的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">enum Number &#123;</span><br><span class="line">    Zero,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Number1 &#123;</span><br><span class="line">    Zero = 0,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误，不能用小数</span><br><span class="line">//enum Number2 &#123;</span><br><span class="line">//    Zero = 0.0,</span><br><span class="line">//    One = 1.0,</span><br><span class="line">//    Two = 2.0,</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">// C-like enum</span><br><span class="line">enum Number2 &#123;</span><br><span class="line">    Zero = 0,</span><br><span class="line">    One = 1,</span><br><span class="line">    Two = 2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 通过 `as` 可以将枚举值强转为整数类型</span><br><span class="line">    assert_eq!(Number::One as u8, Number1::One as u8);</span><br><span class="line">    assert_eq!(Number1::One as u8, Number2::One as u8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>可以像这样创建 IpAddrKind 两个不同成员的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let four = IpAddrKind::V4;</span><br><span class="line">    let six = IpAddrKind::V6;</span><br></pre></td></tr></table></figure><p>枚举成员中的值可以使用模式匹配来获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let msg = Message::Move&#123;x: 1, y: 1&#125;;</span><br><span class="line"></span><br><span class="line">    if let Message::Move&#123;x:a,y: b&#125; = msg &#123;</span><br><span class="line">        assert_eq!(a, b);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        panic!(&quot;不要让这行代码运行！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将数据附加到枚举的变体中"><a href="#将数据附加到枚举的变体中" class="headerlink" title="将数据附加到枚举的变体中"></a>将数据附加到枚举的变体中</h2><p>使用struct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enum IpAddrKind &#123;</span><br><span class="line">        V4,</span><br><span class="line">        V6,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct IpAddr &#123;</span><br><span class="line">        kind: IpAddrKind,</span><br><span class="line">        address: String,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr &#123;</span><br><span class="line">        kind: IpAddrKind::V4,</span><br><span class="line">        address: String::from(&quot;127.0.0.1&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr &#123;</span><br><span class="line">        kind: IpAddrKind::V6,</span><br><span class="line">        address: String::from(&quot;::1&quot;),</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。IpAddr 枚举的新定义表明了 V4 和 V6 成员都关联了 String 值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum IpAddr &#123;</span><br><span class="line">        V4(String),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));</span><br></pre></td></tr></table></figure><p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum IpAddr &#123;</span><br><span class="line">        V4(u8, u8, u8, u8),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(127, 0, 0, 1);</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));</span><br></pre></td></tr></table></figure><p>注意虽然标准库中包含一个 IpAddr 的定义，仍然可以创建和使用我们自己的定义而不会有冲突，因为我们并没有将标准库中的定义引入作用域。</p><p>枚举可以嵌入多种类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Quit 没有关联任何数据。</li><li>Move 类似结构体包含命名字段。</li><li>Write 包含单独一个 String。</li><li>ChangeColor 包含三个 i32。</li></ul><h2 id="枚举中定义函数"><a href="#枚举中定义函数" class="headerlink" title="枚举中定义函数"></a>枚举中定义函数</h2><p>结构体和枚举还有另一个相似点：就像可以使用 impl 来为结构体定义方法那样，也可以在枚举上定义方法。这是一个定义于我们 Message 枚举上的叫做 call 的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">impl Message &#123;</span><br><span class="line">        fn call(&amp;self) &#123;</span><br><span class="line">            // 在这里定义方法体</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let m = Message::Write(String::from(&quot;hello&quot;));</span><br><span class="line">    m.call();</span><br></pre></td></tr></table></figure><p>方法体使用了 self 来获取调用方法的值。这个例子中，创建了一个值为 Message::Write(String::from(“hello”)) 的变量 m，而且这就是当 m.call() 运行时 call 方法中的 self 的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">enum TrafficLightColor &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Yellow,</span><br><span class="line">    Green,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// implement TrafficLightColor with a method</span><br><span class="line">impl TrafficLightColor &#123;</span><br><span class="line">    fn color(&amp;self) -&gt; String &#123;</span><br><span class="line">        match *self &#123;</span><br><span class="line">            TrafficLightColor::Red =&gt; &quot;red&quot;.to_string(),</span><br><span class="line">            TrafficLightColor::Yellow =&gt; &quot;yellow&quot;.to_string(),</span><br><span class="line">            TrafficLightColor::Green =&gt; &quot;green&quot;.to_string(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let c = TrafficLightColor::Yellow;</span><br><span class="line"></span><br><span class="line">    assert_eq!(c.color(), &quot;yellow&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Option枚举"><a href="#Option枚举" class="headerlink" title="Option枚举"></a>Option枚举</h2><p>定义域标准库中，在prelude(预导入模块中)</p><p><strong>Rust没有Null</strong>，提供了类似于Null概念的枚举-Option<T>,它定义于标准库中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    None,</span><br><span class="line">    Some(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let some_number = Some(5);</span><br><span class="line">    let some_char = Some(&#x27;e&#x27;);</span><br><span class="line"></span><br><span class="line">    let absent_number: Option&lt;i32&gt; = None;</span><br></pre></td></tr></table></figure><p>当有一个 Some 值时，我们就知道存在一个值，而这个值保存在 Some 中。当有个 None 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，Option<T> 为什么就比空值要好呢？</p><p>简而言之，因为 Option<T> 和 T（这里 T 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 Option<T>。例如，这段代码不能编译，因为它尝试将 Option<i8> 与 i8 相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x: i8 = 5;</span><br><span class="line">    let y: Option&lt;i8&gt; = Some(5);</span><br><span class="line"></span><br><span class="line">    let sum = x + y;</span><br></pre></td></tr></table></figure><p>事实上，错误信息意味着 Rust 不知道该如何将 Option<i8> 与 i8 相加，因为它们的类型不同。当在 Rust 中拥有一个像 i8 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 Option<i8>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p><p>换句话说，在对 Option<T> 进行 T 的运算之前必须将其转换为 T。</p><p>为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 Option<T> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 Option<T> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。</p><p>这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p><h2 id="枚举实现链表"><a href="#枚举实现链表" class="headerlink" title="枚举实现链表"></a>枚举实现链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#[allow(unused)]</span><br><span class="line">// 填空，让代码运行</span><br><span class="line">use crate::List::*;</span><br><span class="line"></span><br><span class="line">enum List &#123;</span><br><span class="line">    // Cons: 链表中包含有值的节点，节点是元组类型，第一个元素是节点的值，第二个元素是指向下一个节点的指针</span><br><span class="line">    Cons(u32, Box&lt;List&gt;),</span><br><span class="line">    // Nil: 链表中的最后一个节点，用于说明链表的结束</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为枚举实现一些方法</span><br><span class="line">impl List &#123;</span><br><span class="line">    // 创建空的链表</span><br><span class="line">    fn new() -&gt; List &#123;</span><br><span class="line">        // 因为没有节点，所以直接返回 Nil 节点</span><br><span class="line">        // 枚举成员 Nil 的类型是 List</span><br><span class="line">        Nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在老的链表前面新增一个节点，并返回新的链表</span><br><span class="line">    fn prepend(self, elem: u32) -&gt; List &#123;</span><br><span class="line">        Cons(elem, Box::new(self))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回链表的长度</span><br><span class="line">    fn len(&amp;self) -&gt; u32 &#123;</span><br><span class="line">        match *self &#123;</span><br><span class="line">            // 这里我们不能拿走 tail 的所有权，因此需要获取它的引用，递归计算</span><br><span class="line">            Cons(_,ref tail) =&gt; 1 + tail.len(),</span><br><span class="line">            // 空链表的长度为 0</span><br><span class="line">            Nil =&gt; 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回链表的字符串表现形式，用于打印输出</span><br><span class="line">    fn stringify(&amp;self) -&gt; String &#123;</span><br><span class="line">        match *self &#123;</span><br><span class="line">            Cons(head, ref tail) =&gt; &#123;</span><br><span class="line">                // 递归生成字符串</span><br><span class="line">                format!(&quot;&#123;&#125;, &#123;&#125;&quot;, head, tail.stringify())</span><br><span class="line">            &#125;,</span><br><span class="line">            Nil =&gt; &#123;</span><br><span class="line">                format!(&quot;Nil&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 创建一个新的链表(也是空的)</span><br><span class="line">    let mut list = List::new();</span><br><span class="line"></span><br><span class="line">    // 添加一些元素</span><br><span class="line">    list = list.prepend(1);</span><br><span class="line">    list = list.prepend(2);</span><br><span class="line">    list = list.prepend(3);</span><br><span class="line"></span><br><span class="line">    // 打印列表的当前状态</span><br><span class="line">    println!(&quot;链表的长度是: &#123;&#125;&quot;, list.len());</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, list.stringify());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><h2 id="match控制流结构"><a href="#match控制流结构" class="headerlink" title="match控制流结构"></a>match控制流结构</h2><p>Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将<strong>一个值</strong>与<strong>一系列的模式</strong>相比较，并根据相匹配的模式执行相应代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; 1,</span><br><span class="line">        Coin::Nickel =&gt; 5,</span><br><span class="line">        Coin::Dime =&gt; 10,</span><br><span class="line">        Coin::Quarter =&gt; 25,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            println!(&quot;Lucky penny!&quot;);</span><br><span class="line">            1</span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; 5,</span><br><span class="line">        Coin::Dime =&gt; 10,</span><br><span class="line">        Coin::Quarter =&gt; 25,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="matches"><a href="#matches" class="headerlink" title="matches!"></a>matches!</h3><p>matches!看起来像 match, 但是它可以做一些特别的事情</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let alphabets = [&#x27;a&#x27;, &#x27;E&#x27;, &#x27;Z&#x27;, &#x27;0&#x27;, &#x27;x&#x27;, &#x27;9&#x27; , &#x27;Y&#x27;];</span><br><span class="line"></span><br><span class="line">    // fill the blank with `matches!` to make the code work</span><br><span class="line">    for ab in alphabets &#123;</span><br><span class="line">        assert!(matches!(ab, &#x27;a&#x27;..=&#x27;z&#x27; | &#x27;A&#x27;..=&#x27;Z&#x27; | &#x27;0&#x27;..=&#x27;9&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">enum MyEnum &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0;</span><br><span class="line"></span><br><span class="line">    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];</span><br><span class="line">    for e in v &#123;</span><br><span class="line">        if e == MyEnum::Foo &#123; // 修复错误，只能修改本行代码</span><br><span class="line">            count += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(count, 2);</span><br><span class="line">&#125;</span><br><span class="line">Compiling demo v0.1.0 (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">error[E0369]: binary operation `==` cannot be applied to type `MyEnum`</span><br><span class="line">  --&gt; src\main.rs:13:14</span><br><span class="line">   |</span><br><span class="line">13 |         if e == MyEnum::Foo &#123; // 修复错误，只能修改本行代码</span><br><span class="line">   |            - ^^ ----------- MyEnum</span><br><span class="line">   |            |</span><br><span class="line">   |            MyEnum</span><br><span class="line">   |</span><br><span class="line">note: an implementation of `PartialEq&lt;_&gt;` might be missing for `MyEnum`</span><br><span class="line">  --&gt; src\main.rs:3:1</span><br><span class="line">   |</span><br><span class="line">3  | enum MyEnum &#123;</span><br><span class="line">   | ^^^^^^^^^^^ must implement `PartialEq&lt;_&gt;`</span><br><span class="line">help: consider annotating `MyEnum` with `#[derive(PartialEq)]`</span><br><span class="line">   |</span><br><span class="line">3  | #[derive(PartialEq)]</span><br><span class="line">   |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0369`.</span><br><span class="line">error: could not compile `demo` due to previous error</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum MyEnum &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut count = 0;</span><br><span class="line"></span><br><span class="line">    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];</span><br><span class="line">    for e in v &#123;</span><br><span class="line">        if matches!(e, MyEnum::Foo) &#123; // 修复错误，只能修改本行代码</span><br><span class="line">            count += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(count, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h3><p>匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举成员中提取值的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)] // 这样可以立刻看到州的名称</span><br><span class="line">enum UsState &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; 1,</span><br><span class="line">        Coin::Nickel =&gt; 5,</span><br><span class="line">        Coin::Dime =&gt; 10,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            println!(&quot;State quarter from &#123;:?&#125;!&quot;, state);</span><br><span class="line">            25</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let c= Coin::Quarter(UsState::Alaska);</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,value_in_cents(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配Option"><a href="#匹配Option" class="headerlink" title="匹配Option"></a>匹配Option<T></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let five = Some(5);</span><br><span class="line">    let six = plus_one(five);</span><br><span class="line">    let none = plus_one(None); </span><br><span class="line">&#125;</span><br><span class="line">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">     match x &#123;</span><br><span class="line">        None =&gt; None,</span><br><span class="line">        Some(i) =&gt; Some(i + 1),</span><br><span class="line">     &#125;</span><br><span class="line">&#125;//它获取一个 Option&lt;i32&gt; ，如果其中含有一个值，将其加一。如果其中没有值，函数应该返回 None 值，而不尝试执行任何操作。</span><br></pre></td></tr></table></figure><h3 id="match匹配必须穷举所有的可能性"><a href="#match匹配必须穷举所有的可能性" class="headerlink" title="match匹配必须穷举所有的可能性"></a>match匹配必须穷举所有的可能性</h3><p>使用<strong>_占位符</strong>(必须放到最后面)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">match dice_roll &#123;</span><br><span class="line">    3 =&gt; add_fancy_hat(),</span><br><span class="line">    7 =&gt; remove_fancy_hat(),</span><br><span class="line">    _ =&gt; reroll(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if-let-简洁控制流"><a href="#if-let-简洁控制流" class="headerlink" title="if let 简洁控制流"></a>if let 简洁控制流</h2><p>处理只关心一种模式匹配而忽略其它匹配的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let config_max = Some(3u8);</span><br><span class="line">  match config_max &#123;</span><br><span class="line">        Some(max) =&gt; println!(&quot;The maximum is configured to be &#123;&#125;&quot;, max),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用if let</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let config_max = Some(3u8);</span><br><span class="line">    if let Some(max) = config_max &#123;</span><br><span class="line">        println!(&quot;The maximum is configured to be &#123;&#125;&quot;, max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，模式是 Some(max)，max 绑定为 Some 中的值。接着可以在 if let 代码块中使用 max 了，就跟在对应的 match 分支中一样。模式不匹配时 if let 块中的代码不会执行。</p><p>放弃了穷举的可能性</p><p>可以把if let看作是match的语法糖</p><p><strong>搭配else使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mut count = 0;</span><br><span class="line">    if let Coin::Quarter(state) = coin &#123;</span><br><span class="line">        println!(&quot;State quarter from &#123;:?&#125;!&quot;, state);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        count += 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配中的变量遮蔽"><a href="#模式匹配中的变量遮蔽" class="headerlink" title="模式匹配中的变量遮蔽"></a>模式匹配中的变量遮蔽</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let age = Some(30);</span><br><span class="line">    if let Some(age) = age &#123; // 创建一个新的变量，该变量与之前的 `age` 变量同名</span><br><span class="line">       assert_eq!(age, 30);</span><br><span class="line">    &#125; // 新的 `age` 变量在这里超出作用域</span><br><span class="line">    </span><br><span class="line">    match age &#123;</span><br><span class="line">        // `match` 也能实现变量遮蔽</span><br><span class="line">        Some(age) =&gt;  println!(&quot;age 是一个新的变量，它的值是 &#123;&#125;&quot;,age),</span><br><span class="line">        _ =&gt; ()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">//output:</span><br><span class="line">//age 是一个新的变量，它的值是 30</span><br></pre></td></tr></table></figure><h1 id="Package-Crate-Module"><a href="#Package-Crate-Module" class="headerlink" title="Package,Crate,Module"></a>Package,Crate,Module</h1><ul><li><strong>包</strong>（<em>Packages</em>）： Cargo 的一个功能，它允许你构建、测试和分享 crate。</li><li><strong>Crate</strong> ：一个模块的树形结构，它形成了库或二进制项目。</li><li><strong>模块</strong>（<em>Modules</em>）和 <strong>use</strong>： 允许你控制作用域和路径的私有性。</li><li><strong>路径</strong>（<em>path</em>）：一个命名例如结构体、函数或模块等项的方式</li></ul><p><strong>Crate的类型</strong></p><ul><li>binary</li><li>library</li></ul><p><strong>Crate Root</strong></p><p>是源代码文件，Rust编译器从这里开始，组成你的Crate的根Module</p><p><strong>一个Package</strong></p><ul><li>包含1个Cargo.toml，它描述了如何构建这些Crates</li><li>只能包含0-1个library crate</li><li>可以包含任意数量的binary crate</li><li>但必须至少包含一个crate（library或者binary)</li></ul><h2 id="Cargo的惯例"><a href="#Cargo的惯例" class="headerlink" title="Cargo的惯例"></a>Cargo的惯例</h2><p>src/main.rs</p><ul><li>binary crate的crate root</li><li>crate名与package名相同</li></ul><p>src/lib.rs</p><ul><li>package包含一个Library crate</li><li>library crate的crate root</li><li>crate名与package名相同</li></ul><p>一个package可以同时包含src/main.rs和src/lib.rs</p><p>一个Package可以有多个binary crate：</p><p>文件放在src/bin下，每个文件都是单独的 binary crate</p><h2 id="定义module来控制作用域和私有性"><a href="#定义module来控制作用域和私有性" class="headerlink" title="定义module来控制作用域和私有性"></a>定义module来控制作用域和私有性</h2><p><strong>Module</strong></p><ul><li>在一个crate内，将diamagnetic进行分组</li><li>控制项目（item) 的私有性,public,private</li></ul><p><strong>建立module</strong></p><ul><li>mod关键字</li><li>可嵌套</li><li>可包含其他项的定义(struct,enum,常量,trait，函数等)的定义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    mod hosting &#123;</span><br><span class="line">        fn add_to_waitlist() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        fn seat_at_table() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mod serving &#123;</span><br><span class="line">        fn take_order() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        fn serve_order() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        fn take_payment() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的模块树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure><p>src/main.rs和src/lib.rs叫做crate roots</p><ul><li>这两个文件(任意一个)的内容形成了名为crate的模块，位于整个模块树的根部</li><li>整个模块树在隐式的crate模块下</li></ul><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>为了在Rust的模块中找到某个条目，需要使用<strong>路径</strong></p><ul><li><strong>绝对路径</strong>从crate root开始，使用crate名或字面值crate</li><li><strong>相对路径</strong>从当前模块开始，使用self，super或当前模块的标识符</li></ul><p>路径至少由一个标识符组成，标识符之间使用::</p><p>src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    mod hosting &#123;</span><br><span class="line">        fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;//共有的</span><br><span class="line">    // 绝对路径</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // 相对路径</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有边界（privacy-boundary"><a href="#私有边界（privacy-boundary" class="headerlink" title="私有边界（privacy boundary)"></a>私有边界（privacy boundary)</h2><ul><li>Rust的所有条目(函数，方法，struct,enum,模块,常量) <strong>默认都是私有的</strong></li><li><strong>父级模块无法访问所有子模块的私有条目</strong></li><li>子模块里可以使用<strong>所有</strong>祖先模块中的条目</li><li><strong>同级模块</strong>可以<strong>互相调用</strong></li><li>pub关键字可以标记为公共的</li></ul><h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><p>super:用来访问父级模块路径中的内容，类似于文件系统中的..</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn serve_order() &#123;&#125;</span><br><span class="line"></span><br><span class="line">mod back_of_house &#123;</span><br><span class="line">    fn fix_incorrect_order() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::serve_order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn cook_order() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-struct"><a href="#pub-struct" class="headerlink" title="pub struct"></a>pub struct</h2><p>pub放在struct前：</p><ul><li>struct是公共的</li><li>struct的字段默认是私有的，字段前面加pub就可以设为公有的</li></ul><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mod back_of_house &#123;</span><br><span class="line">    pub struct Breakfast &#123;</span><br><span class="line">        pub toast: String,</span><br><span class="line">        seasonal_fruit: String,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Breakfast &#123;</span><br><span class="line">        pub fn summer(toast: &amp;str) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: String::from(toast),</span><br><span class="line">                seasonal_fruit: String::from(&quot;peaches&quot;),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // 在夏天订购一个黑麦土司作为早餐</span><br><span class="line">    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);</span><br><span class="line">    // 改变主意更换想要面包的类型</span><br><span class="line">    meal.toast = String::from(&quot;Wheat&quot;);</span><br><span class="line">    println!(&quot;I&#x27;d like &#123;&#125; toast please&quot;, meal.toast);</span><br><span class="line"></span><br><span class="line">    // 如果取消下一行的注释代码不能编译；</span><br><span class="line">    // 不允许查看或修改早餐附带的季节水果</span><br><span class="line">    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-enum"><a href="#pub-enum" class="headerlink" title="pub enum"></a>pub enum</h2><p>把pub放在enum前：</p><ul><li>enum是公共的</li><li>enum的变体默认也都是公共的（不需要加pub关键字)</li></ul><h2 id="use关键字"><a href="#use关键字" class="headerlink" title="use关键字"></a>use关键字</h2><p>使用 use 关键字将路径引入作用域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>仍然遵循私有性规则</li><li>使用use来指定相对路径</li></ul><h2 id="use的习惯用法"><a href="#use的习惯用法" class="headerlink" title="use的习惯用法"></a>use的习惯用法</h2><ul><li>函数:将函数的父级模块引入到作用域(指定到父级)</li></ul><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use self::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct,enum,其他:指定完整路径(指定到本身)</li></ul><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut map = HashMap::new();</span><br><span class="line">    map.insert(1, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个具有相同名称的项带入作用域</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt;</span><br><span class="line">use std::io;</span><br><span class="line"></span><br><span class="line">fn function1() -&gt; fmt::Result &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn function2() -&gt; io::Result&lt;()&gt; &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-as-关键字提供新的名称"><a href="#使用-as-关键字提供新的名称" class="headerlink" title="使用 as 关键字提供新的名称"></a>使用 as 关键字提供新的名称</h2><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Result;</span><br><span class="line">use std::io::Result as IoResult;</span><br><span class="line"></span><br><span class="line">fn function1() -&gt; Result &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn function2() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h2><p>使用use将路径（名称）导入到作用域内后，<strong>该名称在此作用域内是私有的</strong></p><p>pub use：重导出</p><ul><li>将条目引入到作用域</li><li>该条目可以被<strong>外部代码</strong>引入到它们的作用域</li></ul><h2 id="pub-in-Crate"><a href="#pub-in-Crate" class="headerlink" title="pub(in Crate)"></a>pub(in Crate)</h2><p>有时我们希望某一个项只对特定的包可见，那么就可以使用 pub(in Crate) 语法.</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pub mod a &#123;</span><br><span class="line">    pub const I: i32 = 3;</span><br><span class="line"></span><br><span class="line">    fn semisecret(x: i32) -&gt; i32 &#123;</span><br><span class="line">        use self::b::c::J;</span><br><span class="line">        x + J</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn bar(z: i32) -&gt; i32 &#123;</span><br><span class="line">        semisecret(I) * z</span><br><span class="line">    &#125;</span><br><span class="line">    pub fn foo(y: i32) -&gt; i32 &#123;</span><br><span class="line">        semisecret(I) + y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mod b &#123;</span><br><span class="line">        pub(in crate::a) mod c &#123;</span><br><span class="line">            pub(in crate::a) const J: i32 = 4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用外部包-package"><a href="#使用外部包-package" class="headerlink" title="使用外部包(package)"></a>使用外部包(package)</h2><p>1.Cargo.toml添加依赖的包</p><p>2.use将特定条目引入到作用域</p><ul><li>标准库std也被当做外部包，但是不需要修改Cargo.toml来包含std</li><li>需要使用use将std中的特定条目引入当前作用域</li></ul><h2 id="使用嵌套路径清理大量的use语句"><a href="#使用嵌套路径清理大量的use语句" class="headerlink" title="使用嵌套路径清理大量的use语句"></a>使用嵌套路径清理大量的use语句</h2><p><strong>路径相同的部分::{路径差异的部分}</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use std::&#123;cmp::Ordering,io&#125;;</span><br><span class="line">fn main()</span><br></pre></td></tr></table></figure><p>如果两个use路径之一是另一个的子路径</p><p>使用self</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//use std::io;</span><br><span class="line">//use std::io::Write;</span><br><span class="line">use std::io::&#123;self,Write&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符*"></a>通配符*</h2><p>使用*可以把路径中所有的公共条目都引入到作用域</p><p>谨慎使用</p><p>应用场景：</p><ul><li>prelude</li><li>测试，将所有被测试代码引入到tests模块</li></ul><h2 id="将模块拆分为不同的文件"><a href="#将模块拆分为不同的文件" class="headerlink" title="将模块拆分为不同的文件"></a>将模块拆分为不同的文件</h2><p>模块定义时，如果模块名后面时”;”，而不是代码块</p><ul><li><strong>Rust会从模块同名的文件中加载内容</strong></li><li><strong>模块树不会发生变化</strong></li></ul><p>示例:</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mod front_of_house;</span><br><span class="line"></span><br><span class="line">pub use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 ：声明 front_of_house 模块，其内容将位于 <em>src/front_of_house.rs</em></p><p><em>src/front_of_house.rs</em> 会获取 front_of_house 模块的定义内容，如示例所示。</p><p>文件名: src/front_of_house.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub mod hosting &#123;</span><br><span class="line">    pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：在 <em>src/front_of_house.rs</em> 中定义 front_of_house 模块</p><p>把hosting也展开</p><p>文件名: src/front_of_house.rs</p><p>pub mod hosting;</p><p>接着我们创建一个 <em>src/front_of_house</em> 目录和一个包含 hosting 模块定义的 <em>src/front_of_house/hosting.rs</em> 文件：</p><p>文件名: src/front_of_house/hosting.rs</p><p>pub fn add_to_waitlist() {}</p><p>随着模块逐渐变大，该技术可以把模块的内容移动到其他文件中</p><h1 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vec<T> 叫做vector</p><h3 id="创建vector"><a href="#创建vector" class="headerlink" title="创建vector"></a>创建vector</h3><p><strong>Vec::new函数</strong></p><p>let v:Vec<i32>=Vec::new();</p><p>使用初始值创建Vec<T>,使用<strong>vec!</strong>宏</p><p>let v = vec![1,2,3];</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let arr: [u8; 3] = [1, 2, 3];</span><br><span class="line">    </span><br><span class="line">    let v = Vec::from(arr);</span><br><span class="line">    is_vec(v);</span><br><span class="line"></span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line">    is_vec(v);</span><br><span class="line"></span><br><span class="line">    // vec!(..) 和 vec![..] 是同样的宏，宏可以使用 []、()、&#123;&#125;三种形式，因此...</span><br><span class="line">    let v = vec!(1, 2, 3);</span><br><span class="line">    is_vec(v);</span><br><span class="line">    </span><br><span class="line">    // ...在下面的代码中, v 是 Vec&lt;[u8; 3]&gt; , 而不是 Vec&lt;u8&gt;</span><br><span class="line">    let v1 = vec!(arr);</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mut v:Vec&lt;i32&gt;=Vec::new();</span><br><span class="line">v.push(1);</span><br></pre></td></tr></table></figure><h3 id="删除Vector"><a href="#删除Vector" class="headerlink" title="删除Vector"></a>删除Vector</h3><p>类似于任何其他的 struct，vector 在其离开作用域时会被释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let v = vec![1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">        // 处理变量 v</span><br><span class="line">    &#125; // &lt;- 这里 v 离开作用域并被丢弃</span><br></pre></td></tr></table></figure><h3 id="读取Vector中的值"><a href="#读取Vector中的值" class="headerlink" title="读取Vector中的值"></a>读取Vector中的值</h3><ul><li>索引方式</li><li>get方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let v = vec![1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    let third: &amp;i32 = &amp;v[2];</span><br><span class="line">    println!(&quot;The third element is &#123;&#125;&quot;, third);</span><br><span class="line"></span><br><span class="line">    match v.get(2) &#123;</span><br><span class="line">        Some(third) =&gt; println!(&quot;The third element is &#123;&#125;&quot;, third),</span><br><span class="line">        None =&gt; println!(&quot;There is no third element.&quot;),</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用索引方法访问超出数组元素的值时，程序会panic</strong></li><li><strong>而使用get方法访问时程序会返回一个None</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = Vec::from([1, 2, 3]);</span><br><span class="line">    for i in 0..5 &#123;</span><br><span class="line">        println!(&quot;&#123;:?&#125;&quot;, v.get(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i in 0..5 &#123;</span><br><span class="line">        if let Some(x) = v.get(i) &#123;</span><br><span class="line">            v[i] = x + 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            v.push(i + 2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    assert_eq!(format!(&quot;&#123;:?&#125;&quot;,v), format!(&quot;&#123;:?&#125;&quot;, vec![2, 3, 4, 5, 6]));</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用借用规则"><a href="#引用借用规则" class="headerlink" title="引用借用规则"></a>引用借用规则</h3><p>当我们获取了 vector 的第一个元素的不可变引用并尝试在 vector 末尾增加一个元素的时候，如果尝试在函数的后面引用这个元素是行不通的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mut v = vec![1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">    let first = &amp;v[0];//不可变的借用</span><br><span class="line"></span><br><span class="line">    v.push(6);//可变的借用</span><br><span class="line"></span><br><span class="line">    println!(&quot;The first element is: &#123;&#125;&quot;, first);//不可变的借用</span><br></pre></td></tr></table></figure><p>为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中。这时，第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况。</p><h3 id="遍历Vector"><a href="#遍历Vector" class="headerlink" title="遍历Vector"></a>遍历Vector</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let v = vec![100, 32, 57];</span><br><span class="line">    for i in &amp;v &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mut v = vec![100, 32, 57];</span><br><span class="line">    for i in &amp;mut v &#123;</span><br><span class="line">        *i += 50;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了修改可变引用所指向的值，在使用 += 运算符之前必须使用解引用运算符（*）获取 i 中的值。</p><h3 id="扩展Vector"><a href="#扩展Vector" class="headerlink" title="扩展Vector"></a>扩展Vector</h3><p>Vec 可以使用 extend 方法进行扩展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v1 = Vec::from([1, 2, 4]);</span><br><span class="line">    v1.pop();</span><br><span class="line">    v1.push(3);</span><br><span class="line">    </span><br><span class="line">    let mut v2 = Vec::new();</span><br><span class="line">    v2.extend([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;&#123;:?&#125;&quot;,v1), format!(&quot;&#123;:?&#125;&quot;,v2));</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用enum来使Vec存储多种数据类型"><a href="#使用enum来使Vec存储多种数据类型" class="headerlink" title="使用enum来使Vec存储多种数据类型"></a>使用enum来使Vec存储多种数据类型</h3><p>定义一个枚举，以便能在 vector 中存放不同类型的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum SpreadsheetCell &#123;</span><br><span class="line">        Int(i32),</span><br><span class="line">        Float(f64),</span><br><span class="line">        Text(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let row = vec![</span><br><span class="line">        SpreadsheetCell::Int(3),</span><br><span class="line">        SpreadsheetCell::Text(String::from(&quot;blue&quot;)),</span><br><span class="line">        SpreadsheetCell::Float(10.12),</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><h2 id="使用特征对象来使Vec存储多种数据类型"><a href="#使用特征对象来使Vec存储多种数据类型" class="headerlink" title="使用特征对象来使Vec存储多种数据类型"></a>使用特征对象来使Vec存储多种数据类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">trait IpAddr &#123;</span><br><span class="line">    fn display(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct V4(String);</span><br><span class="line">impl IpAddr for V4 &#123;</span><br><span class="line">    fn display(&amp;self) &#123;</span><br><span class="line">        println!(&quot;ipv4: &#123;:?&#125;&quot;,self.0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct V6(String);</span><br><span class="line">impl IpAddr for V6 &#123;</span><br><span class="line">    fn display(&amp;self) &#123;</span><br><span class="line">        println!(&quot;ipv6: &#123;:?&#125;&quot;,self.0)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 填空</span><br><span class="line">    let v: Vec&lt;Box&lt;dyn IpAddr&gt;&gt; = vec![</span><br><span class="line">        Box::new(V4(&quot;127.0.0.1&quot;.to_string())),</span><br><span class="line">        Box::new(V6(&quot;::1&quot;.to_string())),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    for ip in v &#123;</span><br><span class="line">        ip.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将-X-类型转换-From-Into-特征-成-Vec"><a href="#将-X-类型转换-From-Into-特征-成-Vec" class="headerlink" title="将 X 类型转换(From/Into 特征)成 Vec"></a>将 X 类型转换(From/Into 特征)成 Vec</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // array -&gt; Vec</span><br><span class="line">    let arr = [1, 2, 3];</span><br><span class="line">    let v1 = Vec::from(arr);</span><br><span class="line">    let v2: Vec&lt;i32&gt; = arr.into();</span><br><span class="line"> </span><br><span class="line">    assert_eq!(v1, v2);</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    // String -&gt; Vec</span><br><span class="line">    let s = &quot;hello&quot;.to_string();</span><br><span class="line">    let v1: Vec&lt;u8&gt; = s.into();</span><br><span class="line"></span><br><span class="line">    let s = &quot;hello&quot;.to_string();</span><br><span class="line">    let v2 = s.into_bytes();</span><br><span class="line">    assert_eq!(v1, v2);</span><br><span class="line"></span><br><span class="line">    let s = &quot;hello&quot;;</span><br><span class="line">    let v3 = Vec::from(s);</span><br><span class="line">    assert_eq!(v2, v3);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>与 String 的切片类似， Vec 也可以使用切片。如果说 Vec 是可变的，那它的切片就是不可变或者说只读的，我们可以通过 &amp; 来获取切片。</p><p>在 Rust 中，将切片作为参数进行传递是更常见的使用方式，例如当一个函数只需要可读性时，那传递 Vec 或 String 的切片 &amp;[T] / &amp;str 会更加适合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let slice1 = &amp;v[..];</span><br><span class="line">    // 越界访问将导致 panic.</span><br><span class="line">    // 修改时必须使用 `v.len`</span><br><span class="line">    let slice2 = &amp;v[0..v.len()];</span><br><span class="line">    </span><br><span class="line">    assert_eq!(slice1, slice2);</span><br><span class="line">    </span><br><span class="line">    // 切片是只读的</span><br><span class="line">    // 注意：切片和 `&amp;Vec` 是不同的类型，后者仅仅是 `Vec` 的引用，并可以通过解引用直接获取 `Vec`</span><br><span class="line">    let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v;</span><br><span class="line">    (*vec_ref).push(4);</span><br><span class="line">    let slice3 = &amp;mut v[0..];</span><br><span class="line">    // slice3.push(4);</span><br><span class="line"></span><br><span class="line">    assert_eq!(slice3, &amp;[1, 2, 3, 4]);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p>容量 capacity 是已经分配好的内存空间，用于存储未来添加到 Vec 中的元素。而长度 len 则是当前 Vec 中已经存储的元素数量。如果要添加新元素时，长度将要超过已有的容量，那容量会自动进行增长：Rust 会重新分配一块更大的内存空间，然后将之前的 Vec 拷贝过去，因此，这里就会发生新的内存分配</p><p>若这段代码会频繁发生，那频繁的内存分配会大幅影响我们系统的性能，最好的办法就是提前分配好足够的容量，尽量减少内存分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut vec = Vec::with_capacity(10);</span><br><span class="line"></span><br><span class="line">    assert_eq!(vec.len(), 0);</span><br><span class="line">    assert_eq!(vec.capacity(), 10);</span><br><span class="line"></span><br><span class="line">    // 由于提前设置了足够的容量，这里的循环不会造成任何内存分配...</span><br><span class="line">    for i in 0..10 &#123;</span><br><span class="line">        vec.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    assert_eq!(vec.len(), 10);</span><br><span class="line">    assert_eq!(vec.capacity(), 10);</span><br><span class="line"></span><br><span class="line">    // ...但是下面的代码会造成新的内存分配</span><br><span class="line">    vec.push(11);</span><br><span class="line">    assert_eq!(vec.len(), 11);</span><br><span class="line">    assert!(vec.capacity() &gt;= 11);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 填写一个合适的值，在 `for` 循环运行的过程中，不会造成任何内存分配</span><br><span class="line">    let mut vec = Vec::with_capacity(100);</span><br><span class="line">    for i in 0..100 &#123;</span><br><span class="line">        vec.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(vec.len(), 100);</span><br><span class="line">    assert_eq!(vec.capacity(), 100);</span><br><span class="line">    </span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String只要为-Vec-实现了-From-特征，那么-T-就可以被转换成-Vec。"><a href="#String只要为-Vec-实现了-From-特征，那么-T-就可以被转换成-Vec。" class="headerlink" title="String只要为 Vec 实现了 From 特征，那么 T 就可以被转换成 Vec。"></a>String只要为 Vec 实现了 From<T> 特征，那么 T 就可以被转换成 Vec。</h2><ul><li>字符串是Byte的集合</li><li>UFT-8编码</li><li>一些方法能将byte解析为文本</li></ul><h3 id="字符串是什么？"><a href="#字符串是什么？" class="headerlink" title="字符串是什么？"></a>字符串是什么？</h3><p>Rust的核心语言层面，只有一个字符串类型:字符串切片str（或者&amp;str）</p><ul><li>字符串切片:对存储在其它地方,UTF-8编码的字符串引用</li><li>字符串的字面值：存储在二进制文件中，也是字符串切片</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, 世界&quot;);</span><br><span class="line">    let slice1 = &amp;s[0..1]; </span><br><span class="line">    //提示: `h` 在 UTF-8 编码中只占用 1 个字节</span><br><span class="line">    assert_eq!(slice1, &quot;h&quot;);</span><br><span class="line"></span><br><span class="line">    let slice2 = &amp;s[7..10];// 提示: `中` 在 UTF-8 编码中占用 3 个字节</span><br><span class="line">    assert_eq!(slice2, &quot;世&quot;);</span><br><span class="line">    </span><br><span class="line">    // 迭代 s 中的所有字符</span><br><span class="line">    for (i, c) in s.chars().enumerate() &#123;</span><br><span class="line">        if i == 7 &#123;</span><br><span class="line">            assert_eq!(c, &#x27;世&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上 String 是一个<strong>智能指针</strong>，它作为一个结构体存储在栈上，然后指向存储在堆上的字符串底层数据。</p><p>存储在栈上的智能指针结构体由三部分组成：一个指针只指向堆上的字节数组，已使用的长度以及已分配的容量 capacity (已使用的长度小于等于已分配的容量，当容量不够时，会重新分配内存空间)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::mem;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let story = String::from(&quot;Rust By Practice&quot;);</span><br><span class="line"></span><br><span class="line">    // 阻止 String 的数据被自动 drop</span><br><span class="line">    let mut story = mem::ManuallyDrop::new(story);</span><br><span class="line"></span><br><span class="line">    let ptr = story.as_mut_ptr();</span><br><span class="line">    let len = story.len();</span><br><span class="line">    let capacity = story.capacity();</span><br><span class="line"></span><br><span class="line">    assert_eq!(16, len);</span><br><span class="line"></span><br><span class="line">    // 我们可以基于 ptr 指针、长度和容量来重新构建 String. </span><br><span class="line">    // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的</span><br><span class="line">    let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;;</span><br><span class="line"></span><br><span class="line">    assert_eq!(*story, s);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>String类型</strong></p><p>来自标准库，也是UTF-8编码</p><p><strong>其它字符串类型</strong></p><p>OsString,OsStr,CString,CStr等等</p><p>String vs Str：拥有或借用的变体</p><p>可存储不同编码的文本或在内存中以不同的形式展现</p><p>Library crate针对存储字符串提供了共多的选项</p><h3 id="String与-amp-str的转换"><a href="#String与-amp-str的转换" class="headerlink" title="String与&amp;str的转换"></a>String与&amp;str的转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;hello, world&quot;.to_string();</span><br><span class="line">    greetings(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: String) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(&quot;hello, world&quot;);</span><br><span class="line">    greetings(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn greetings(s: String) &#123;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 你可以使用转义的方式来输出想要的字符，这里我们使用十六进制的值，例如 \x73 会被转义成小写字母 &#x27;s&#x27;</span><br><span class="line">    // 填空以输出 &quot;I&#x27;m writing Rust&quot;</span><br><span class="line">    let byte_escape = &quot;I&#x27;m writing Ru\x73__!&quot;;</span><br><span class="line">    println!(&quot;What are you doing\x3F (\\x3F means ?) &#123;&#125;&quot;, byte_escape);</span><br><span class="line"></span><br><span class="line">    // 也可以使用 Unicode 形式的转义字符</span><br><span class="line">    let unicode_codepoint = &quot;\u&#123;211D&#125;&quot;;</span><br><span class="line">    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;,</span><br><span class="line">                unicode_codepoint, character_name );</span><br><span class="line"></span><br><span class="line">    // 还能使用 \ 来连接多行字符串</span><br><span class="line">    let long_string = &quot;String literals</span><br><span class="line">                        can span multiple lines.</span><br><span class="line">                        The linebreak and indentation here \</span><br><span class="line">                         can be escaped too!&quot;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, long_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有时候需要转义的字符很多，我们会希望使用更方便的方式来书写字符串: raw string.</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let raw_str = r&quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, raw_str);</span><br><span class="line"></span><br><span class="line">    // 如果字符串包含双引号，可以在开头和结尾加 #</span><br><span class="line">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class="line"></span><br><span class="line">    // 如果还是有歧义，可以继续增加，没有限制</span><br><span class="line">    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, longer_delimiter);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let raw_str = &quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;;</span><br><span class="line">    assert_eq!(raw_str, &quot;Escapes don&#x27;t work here: ? ℝ&quot;);</span><br><span class="line"></span><br><span class="line">    // If you need quotes in a raw string, add a pair of #s</span><br><span class="line">    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, quotes);</span><br><span class="line"></span><br><span class="line">    // If you need &quot;# in your string, just use more #s in the delimiter.</span><br><span class="line">    // You can use up to 65535 #s.</span><br><span class="line">    let delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, delimiter);</span><br><span class="line"></span><br><span class="line">    // Fill the blank</span><br><span class="line">    let long_delimiter = r###&quot;Hello, &quot;##&quot;&quot;###;</span><br><span class="line">    assert_eq!(long_delimiter, &quot;Hello, \&quot;##\&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里r#”标记一个原始字符串的开始，”#标记一个字符串的结束，如果还是有歧义可以继续加#</p><h3 id="创建一个新的String"><a href="#创建一个新的String" class="headerlink" title="创建一个新的String"></a>创建一个新的String</h3><p>String::new()</p><p>let mut s = String::new();</p><p>使用to_string()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let data = &quot;initial contents&quot;;</span><br><span class="line"></span><br><span class="line">    let s = data.to_string();</span><br><span class="line"></span><br><span class="line">    // 该方法也可直接用于字符串字面值：</span><br><span class="line">    let s = &quot;initial contents&quot;.to_string();</span><br></pre></td></tr></table></figure><p>string::from()</p><p>let s = String::from(“initial contents”);</p><h3 id="更新String"><a href="#更新String" class="headerlink" title="更新String"></a>更新String</h3><h4 id="push-str"><a href="#push-str" class="headerlink" title="push_str()"></a><strong>push_str()</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;foo&quot;);</span><br><span class="line">    s.push_str(&quot;bar&quot;);</span><br></pre></td></tr></table></figure><p>push_str()方法不会获得参数的所有权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let mut s1 = String::from(&quot;foo&quot;);</span><br><span class="line">    let s2 = &quot;bar&quot;;</span><br><span class="line">    s1.push_str(s2);</span><br><span class="line">    println!(&quot;s2 is &#123;&#125;&quot;, s2);</span><br><span class="line">let mut s1 = String::from(&quot;foo&quot;);</span><br><span class="line">    let s2 = &quot;bar&quot;;</span><br><span class="line">    s1.push_str(&amp;s2);</span><br><span class="line">    println!(&quot;s2 is &#123;&#125;&quot;, s2);</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push()"></a><strong>push()</strong></h4><p>push 方法被定义为获取一个单独的字符作为参数，并附加到 String 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mut s = String::from(&quot;lo&quot;);</span><br><span class="line">    s.push(&#x27;l&#x27;);</span><br></pre></td></tr></table></figure><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="+连接字符串"></a><strong>+连接字符串</strong></h4><p><strong>只能将</strong> <strong>String</strong> <strong>跟</strong> <strong>&amp;str</strong> <strong>类型进行拼接，并且</strong> <strong>String</strong> <strong>的所有权在此过程中会被 move</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;Hello, &quot;);</span><br><span class="line">    let s2 = String::from(&quot;world!&quot;);</span><br><span class="line">    let s3 = s1 + &amp;s2; // 注意 s1 被移动了，不能继续使用</span><br></pre></td></tr></table></figure><p>+ 运算符使用了 add 函数，这个函数签名看起来像这样：</p><p>fn add(self, s: &amp;str) -&gt; String {</p><p>这并不是标准库中实际的签名；</p><p>但是&amp;s2 的类型是 &amp;String 而不是 &amp;str。那么为什么还能编译呢</p><p>之所以能够在 add 调用中使用 &amp;s2 是因为 &amp;String 可以被 <strong>强转</strong>（<em>coerced</em>）成 &amp;str。当add函数被调用时，Rust 使用了一个被称为 <strong>Deref 强制转换</strong>（<em>deref coercion</em>）的技术，你可以将其理解为它把 &amp;s2 变成了 &amp;s2[..]。</p><h4 id="format"><a href="#format" class="headerlink" title="format!"></a>format!</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let s1 = String::from(&quot;tic&quot;);</span><br><span class="line">    let s2 = String::from(&quot;tac&quot;);</span><br><span class="line">    let s3 = String::from(&quot;toe&quot;);</span><br><span class="line"></span><br><span class="line">    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;</span><br><span class="line">let s1 = String::from(&quot;tic&quot;);</span><br><span class="line">    let s2 = String::from(&quot;tac&quot;);</span><br><span class="line">    let s3 = String::from(&quot;toe&quot;);</span><br><span class="line"></span><br><span class="line">    let s = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, s1, s2, s3);</span><br></pre></td></tr></table></figure><p>宏 format! 生成的代码使用引用所以<strong>不会获取任何参数的所有权</strong></p><h3 id="按索引的形式进行访问String"><a href="#按索引的形式进行访问String" class="headerlink" title="按索引的形式进行访问String"></a>按索引的形式进行访问<strong>String</strong></h3><p>Rust的字符串<strong>不支持索引语法</strong>访问</p><p><strong>内部表现</strong></p><p>String 是一个 Vec<u8> 的封装。</p><p>​    let hello = String::from(“Hola”);</p><p>在这里，len 的值是 4 ，这意味着储存字符串 “Hola” 的 Vec 的长度是四个字节：这里每一个字母的 UTF-8 编码都占用一个字节。</p><p>（注意这个字符串中的首字母是西里尔字母的 Ze 而不是阿拉伯数字 3 。）</p><p>​    let hello = String::from(“Здравствуйте”);</p><p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。这是使用 UTF-8 编码 “Здравствуйте” 所需要的字节数，这是因为每个 Unicode 标量值需要两个字节存储。</p><p><strong>因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值</strong></p><h3 id="字节字符串"><a href="#字节字符串" class="headerlink" title="字节字符串"></a>字节字符串</h3><p>字节字符串或者说字节数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">use std::str;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 注意，这并不是 `&amp;str` 类型了！</span><br><span class="line">    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 字节数组没有实现 `Display` 特征，因此只能使用 `Debug` 的方式去打印</span><br><span class="line">    println!(&quot;A byte string: &#123;:?&#125;&quot;, bytestring);</span><br><span class="line"></span><br><span class="line">    // 字节数组也可以使用转义</span><br><span class="line">    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;</span><br><span class="line">    // ...但是不支持 unicode 转义</span><br><span class="line">    // let escaped = b&quot;\u&#123;211D&#125; is not allowed&quot;;</span><br><span class="line">    println!(&quot;Some escaped bytes: &#123;:?&#125;&quot;, escaped);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // raw string</span><br><span class="line">    let raw_bytestring = br&quot;\u&#123;211D&#125; is not escaped here&quot;;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, raw_bytestring);</span><br><span class="line"></span><br><span class="line">    // 将字节数组转成 `str` 类型可能会失败</span><br><span class="line">    if let Ok(my_str) = str::from_utf8(raw_bytestring) &#123;</span><br><span class="line">        println!(&quot;And the same as text: &#x27;&#123;&#125;&#x27;&quot;, my_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \</span><br><span class="line">                    like with normal raw strings&quot;#;</span><br><span class="line"></span><br><span class="line">    // 字节数组可以不是 UTF-8 格式</span><br><span class="line">    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ようこそ&quot; in SHIFT-JIS</span><br><span class="line"></span><br><span class="line">    // 但是它们未必能转换成 `str` 类型</span><br><span class="line">    match str::from_utf8(shift_jis) &#123;</span><br><span class="line">        Ok(my_str) =&gt; println!(&quot;Conversion successful: &#x27;&#123;&#125;&#x27;&quot;, my_str),</span><br><span class="line">        Err(e) =&gt; println!(&quot;Conversion failed: &#123;:?&#125;&quot;, e),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节-标量值-字型簇"><a href="#字节-标量值-字型簇" class="headerlink" title="字节,标量值,字型簇"></a>字节,标量值,字型簇</h3><p>Rust有三种看待字符串的方式：</p><ul><li>字节Byte</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let w = &quot;नमस्ते&quot;;</span><br><span class="line">    for b in w.bytes()&#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">224</span><br><span class="line">164</span><br><span class="line">168</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">174</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">184</span><br><span class="line">224</span><br><span class="line">165</span><br><span class="line">141</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">164</span><br><span class="line">224</span><br><span class="line">165</span><br><span class="line">135</span><br></pre></td></tr></table></figure><ul><li>标量值Scalar Values</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let w = &quot;नमस्ते&quot;;</span><br><span class="line">    for b in w.chars()&#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure><ul><li>字形簇Grapheme Clusters（最接近所谓的字母）</li></ul><p>获取比较复杂，标准库中已经不提供了</p><p>在crates.io网站上可以找到</p><p>Rust不允许对String进行索引的最后一个原因:</p><p>索引操作应该小号一个常量时间O(1)</p><p>而String无法保证：需要遍历所有的内容，来确定有多少个合法的字符</p><h3 id="切割String"><a href="#切割String" class="headerlink" title="切割String"></a>切割String</h3><p>字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。因此，如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串 slice，相比使用 [] 和单个值的索引，可以使用 [] 和一个 range 来创建含特定字节的字符串 slice：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let hello = &quot;Здравствуйте&quot;;</span><br><span class="line"></span><br><span class="line">let s = &amp;hello[0..4];</span><br></pre></td></tr></table></figure><p>s 会是一个 &amp;str，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 s 将会是 “Зд”。</p><p>如果获取 &amp;hello[0..1] 会发生什么呢？答案是：Rust 在运行时会 panic</p><p>因此<strong>切割时不能跨越字符串边界</strong></p><h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><p>无法通过索引的方式去访问字符串中的某个字符，但是可以使用切片的方式 &amp;s1[start..end] ，但是start 和 end 必须准确落在字符的边界处.</p><ul><li>对于标量值:chars()方法</li><li>对于字节:bytes()方法、</li><li>对于字形簇:很复杂，标准库未提供，中英文都不需要关注字符簇</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(&quot;hi,中国&quot;);</span><br><span class="line">    let h = &amp;s1[0..1]; </span><br><span class="line">    assert_eq!(h, &quot;h&quot;);</span><br><span class="line"></span><br><span class="line">    let h1 = &amp;s1[3..6];</span><br><span class="line">    assert_eq!(h1, &quot;中&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    for c in &quot;你好，世界&quot;.chars() &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//output:</span><br><span class="line">//你</span><br><span class="line">//好</span><br><span class="line">//，</span><br><span class="line">//世</span><br><span class="line">//界</span><br></pre></td></tr></table></figure><p>我们可以使用三方库 [utf8_slice]来访问 UTF-8 字符串的某个子串，但是与之前不同的是，该库索引的是字符，而不是字节.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">utf8_slice = &quot;1.0.0&quot;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;The 🚀 goes to the 🌑!&quot;;</span><br><span class="line"></span><br><span class="line">    let rocket = utf8_slice::slice(s, 4, 5);</span><br><span class="line">    // 结果是 &quot;🚀&quot;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,rocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 默认使用 SipHash 1-3 哈希算法，该算法对于抵抗 HashDos 攻击非常有效。在性能方面，如果你的 key 是中型大小的，那该算法非常不错，但是如果是小型的 key( 例如整数 )亦或是大型的 key ( 例如字符串 )，那你需要采用社区提供的其它算法来提高性能。</p><p>哈希表的算法是基于 Google 的 <a href="https://abseil.io/blog/20180927-swisstables">SwissTable</a>，你可以在<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h">这里</a>找到 C++ 的实现，同时在 <a href="https://www.youtube.com/watch?v=ncHmEUmJZf4">CppCon talk</a> 上也有关于算法如何工作的演讲。</p><h3 id="创建HashMap"><a href="#创建HashMap" class="headerlink" title="创建HashMap"></a>创建HashMap<K,V></h3><p><strong>创建空HashMap:new()函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">//let mut scores:HashMap&lt;String,i32&gt; = HashMap::new();</span><br><span class="line"></span><br><span class="line">    scores.insert(String::from(&quot;Blue&quot;), 10);</span><br><span class="line">    scores.insert(String::from(&quot;Yellow&quot;), 50);</span><br></pre></td></tr></table></figure><ul><li>HashMap用的较少，不在Prelude中</li><li>标准库对其支持较少，没有内置的宏来创建HashMap</li><li>数据存在heap中</li><li>同构的，即K必须为一种类型，V为另一种类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let teams = [</span><br><span class="line">        (&quot;Chinese Team&quot;, 100),</span><br><span class="line">        (&quot;American Team&quot;, 10),</span><br><span class="line">        (&quot;France Team&quot;, 50),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    let mut teams_map1 = HashMap::new();</span><br><span class="line">    for team in &amp;teams &#123;</span><br><span class="line">        teams_map1.insert(team.0, team.1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let teams_map2: HashMap&lt;_,_&gt; = teams.into_iter().collect();</span><br><span class="line">    // let teams_map2 = HashMap::from(teams);</span><br><span class="line">    assert_eq!(teams_map1, teams_map2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>collect方法创建HashMap</strong></p><p>collect方法可以将数据收集进一系列的集合类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];</span><br><span class="line">    let initial_scores = vec![10, 50];</span><br><span class="line"></span><br><span class="line">    let mut scores: HashMap&lt;_, _&gt; =</span><br><span class="line">        teams.into_iter().zip(initial_scores.into_iter()).collect();</span><br></pre></td></tr></table></figure><p>如果队伍的名字和初始分数分别在两个 vector 中，可以使用 zip 方法来创建一个元组的迭代器，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 collect 方法将这个元组的迭代器转换成一个 HashMap</p><h3 id="HashMap和所有权"><a href="#HashMap和所有权" class="headerlink" title="HashMap和所有权"></a>HashMap和所有权</h3><ul><li>对于实现了Copy trait的类型（如i32)，值会被复制到HashMap中</li><li>对于拥有所有权的值（例如String)，值会被移动，所有权会转移给HashMap</li><li>如果把引用插入到HashMap，值本身不会移动但是在HashMap有效的期间，被引用的值必须保持有效</li></ul><h3 id="访问HashMap中的值"><a href="#访问HashMap中的值" class="headerlink" title="访问HashMap中的值"></a>访问HashMap中的值</h3><p><strong>get方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">    scores.insert(String::from(&quot;Blue&quot;), 10);</span><br><span class="line">    scores.insert(String::from(&quot;Yellow&quot;), 50);</span><br><span class="line"></span><br><span class="line">    let team_name = String::from(&quot;Blue&quot;);</span><br><span class="line">    let score = scores.get(&amp;team_name);</span><br></pre></td></tr></table></figure><p><strong>for循环遍历HashMap</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">    scores.insert(String::from(&quot;Blue&quot;), 10);</span><br><span class="line">    scores.insert(String::from(&quot;Yellow&quot;), 50);</span><br><span class="line"></span><br><span class="line">    for (key, value) in &amp;scores &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这会以<strong>任意顺序</strong>打印出每一个键值对：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yellow: 50</span><br><span class="line">Blue: 10</span><br></pre></td></tr></table></figure><p><strong>索引与get方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(&quot;Sunface&quot;, 98);</span><br><span class="line">    scores.insert(&quot;Daniel&quot;, 95);</span><br><span class="line">    scores.insert(&quot;Ashley&quot;, 69);</span><br><span class="line">    scores.insert(&quot;Katie&quot;, 58);</span><br><span class="line"></span><br><span class="line">    // get 返回一个 Option&lt;&amp;V&gt; 枚举值</span><br><span class="line">    let score = scores.get(&quot;Sunface&quot;);</span><br><span class="line">    assert_eq!(score, Some(&amp;98));</span><br><span class="line"></span><br><span class="line">    if scores.contains_key(&quot;Daniel&quot;) &#123;</span><br><span class="line">        // 索引返回一个值 V</span><br><span class="line">        let score = scores[&quot;Daniel&quot;];</span><br><span class="line">        assert_eq!(score, 95);</span><br><span class="line">        scores.remove(&quot;Daniel&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert_eq!(scores.len(), 3);</span><br><span class="line"></span><br><span class="line">    for (name, score) in scores &#123;</span><br><span class="line">        println!(&quot;The score of &#123;&#125; is &#123;&#125;&quot;, name, score)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新HashMap"><a href="#更新HashMap" class="headerlink" title="更新HashMap"></a>更新HashMap</h3><h4 id="覆盖一个值"><a href="#覆盖一个值" class="headerlink" title="覆盖一个值"></a>覆盖一个值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">    scores.insert(String::from(&quot;Blue&quot;), 10);</span><br><span class="line">    scores.insert(String::from(&quot;Blue&quot;), 25);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, scores);</span><br></pre></td></tr></table></figure><p>这会打印出 {“Blue”: 25}。原始的值 10 则被覆盖了</p><h4 id="只在键没有对应值时插入"><a href="#只在键没有对应值时插入" class="headerlink" title="只在键没有对应值时插入"></a>只在键没有对应值时插入</h4><p>使用 entry 方法只在键没有对应一个值时插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(&quot;Blue&quot;), 10);</span><br><span class="line"></span><br><span class="line">let e=scoress.entry(String::from(&quot;Yellow&quot;));</span><br><span class="line">println!(&quot;&#123;:?&#125;&quot;,e)</span><br><span class="line">e.or_insert(50);</span><br><span class="line">    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, scores);</span><br></pre></td></tr></table></figure><p>Entry 的 or_insert 方法在键对应的值存在时就返回</p><p><strong>entry方法</strong></p><p>检查指定的K是否对应一个V</p><p>参数为K,返回enum Entry:代表值是否存在</p><p>Entry的<strong>or_insert()方法</strong>:</p><p>返回:</p><ul><li>如果K存在，返回到对应的V的一个可变引用</li><li>如果K不存在，将方法参数作为K的新值插进去，返回到这个值的可变引用</li></ul><h4 id="根据旧值更新一个值"><a href="#根据旧值更新一个值" class="headerlink" title="根据旧值更新一个值"></a>根据旧值更新一个值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let text = &quot;hello world wonderful world&quot;;</span><br><span class="line"></span><br><span class="line">    let mut map = HashMap::new();</span><br><span class="line"></span><br><span class="line">    for word in text.split_whitespace() &#123;</span><br><span class="line">        let count = map.entry(word).or_insert(0);</span><br><span class="line">        *count += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, map);</span><br></pre></td></tr></table></figure><p>这里or_insert返回的是一个可变引用</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>HashMap 默认使用一种叫做 SipHash 的哈希函数，它可以抵御涉及哈希表（hash table）<a href="https://kaisery.github.io/trpl-zh-cn/ch08-03-hash-maps.html#siphash">1</a> 的拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 <em>hasher</em> 来切换为其它函数。hasher 是一个实现了 BuildHasher trait 的类型。第十章会讨论 trait 和如何实现它们。你并不需要从头开始实现你自己的 hasher；<a href="https://crates.io/">crates.io</a> 有其他人分享的实现了许多常用哈希算法的 hasher 的库。</p><h3 id="HashMap-key的限制"><a href="#HashMap-key的限制" class="headerlink" title="HashMap key的限制"></a>HashMap key的限制</h3><p>任何实现了 Eq 和 Hash 特征的类型都可以用于 HashMap 的 key，包括:</p><ul><li>bool (虽然很少用到，因为它只能表达两种 key)</li><li>int, uint 以及它们的变体，例如 u8、i32 等</li><li>String 和 &amp;str (提示: HashMap 的 key 是 String 类型时，你其实可以使用 &amp;str 配合 get 方法进行查询</li></ul><p>需要注意的是，f32 和 f64 并没有实现 Hash，原因是 <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems">浮点数精度</a> 的问题会导致它们无法进行相等比较。</p><p>如果一个集合类型的所有字段都实现了 Eq 和 Hash,那该集合类型会自动实现 Eq 和 Hash。例如 Vect<T> 要实现 Hash，那么首先需要 T 实现 Hash。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 提示: `derive` 是实现一些常用特征的好办法</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">#[derive(Hash, Eq, PartialEq, Debug)]</span><br><span class="line">struct Viking &#123;</span><br><span class="line">    name: String,</span><br><span class="line">    country: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Viking &#123;</span><br><span class="line">    fn new(name: &amp;str, country: &amp;str) -&gt; Viking &#123;</span><br><span class="line">        Viking &#123;</span><br><span class="line">            name: name.to_string(),</span><br><span class="line">            country: country.to_string(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 使用 HashMap 来存储 viking 的生命值</span><br><span class="line">    let vikings = HashMap::from([</span><br><span class="line">        (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25),</span><br><span class="line">        (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24),</span><br><span class="line">        (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12),</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    // 使用 derive 的方式来打印 viking 的当前状态</span><br><span class="line">    for (viking, health) in &amp;vikings &#123;</span><br><span class="line">        println!(&quot;&#123;:?&#125; has &#123;&#125; hp&quot;, viking, health);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容量-1"><a href="#容量-1" class="headerlink" title="容量"></a>容量</h3><p>关于容量，我们在之前的 Vector中有详细的介绍，而 HashMap 也可以调整容量: 你可以通过 HashMap::with_capacity(uint) 使用指定的容量来初始化，或者使用 HashMap::new() ，后者会提供一个默认的初始化容量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use std::collections::HashMap;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut map: HashMap&lt;i32, i32&gt; = HashMap::with_capacity(100);</span><br><span class="line">    map.insert(1, 2);</span><br><span class="line">    map.insert(3, 4);</span><br><span class="line">    // 事实上，虽然我们使用了 100 容量来初始化，但是 map 的容量很可能会比 100 更多</span><br><span class="line">    assert!(map.capacity() &gt;= 100);</span><br><span class="line"></span><br><span class="line">    // 对容量进行收缩，你提供的值仅仅是一个允许的最小值，实际上，Rust 会根据当前存储的数据量进行自动设置，当然，这个值会尽量靠近你提供的值，同时还可能会预留一些调整空间</span><br><span class="line"></span><br><span class="line">    map.shrink_to(50);</span><br><span class="line">    assert!(map.capacity() &gt;= 50);</span><br><span class="line"></span><br><span class="line">    // 让 Rust  自行调整到一个合适的值，剩余策略同上</span><br><span class="line">    map.shrink_to_fit();</span><br><span class="line">    assert!(map.capacity() &gt;= 2);</span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>对于实现了 Copy 特征的类型，例如 i32，那类型的值会被拷贝到 HashMap 中。而对于有所有权的类型，例如 String，它们的值的所有权将被转移到 HashMap 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 修复错误，尽可能少的去修改代码</span><br><span class="line">// 不要移除任何代码行！</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">fn main() &#123;</span><br><span class="line">  let v1 = 10;</span><br><span class="line">  let mut m1 = HashMap::new();</span><br><span class="line">  m1.insert(v1, v1);</span><br><span class="line">  println!(&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;, v1);</span><br><span class="line"></span><br><span class="line">  let v2 = &quot;hello&quot;.to_string();</span><br><span class="line">  let mut m2 = HashMap::new();</span><br><span class="line">  // 所有权在这里发生了转移</span><br><span class="line">  m2.insert(v2, v1);</span><br><span class="line"></span><br><span class="line">  assert_eq!(v2, &quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">   println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方Hash库"><a href="#第三方Hash库" class="headerlink" title="第三方Hash库"></a>第三方Hash库</h3><p>在开头，我们提到过如果现有的 SipHash 1-3 的性能无法满足你的需求，那么可以使用社区提供的替代算法。</p><p>例如其中一个社区库的使用方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use std::hash::BuildHasherDefault;</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">// 引入第三方的哈希函数</span><br><span class="line">use twox_hash::XxHash64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let mut hash: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = Default::default();</span><br><span class="line">hash.insert(42, &quot;the answer&quot;);</span><br><span class="line">assert_eq!(hash.get(&amp;42), Some(&amp;&quot;the answer&quot;));</span><br></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>大部分情况下，在编译时提示错误，并处理</p><p><strong>错误的分类</strong></p><ul><li>可恢复:</li></ul><p>例如文件未找到，可再次尝试</p><ul><li>不可恢复</li></ul><p>bug,例如访问索引超出范围</p><p><strong>Rust没有类似异常的机制</strong></p><ul><li>可恢复的错误:Result<T,E></li><li>不可恢复:panic!宏</li></ul><h2 id="不可恢复的错误与panic"><a href="#不可恢复的错误与panic" class="headerlink" title="不可恢复的错误与panic!"></a>不可恢复的错误与panic!</h2><p>当panic!宏执行</p><ul><li><strong>程序打印一个错误信息</strong></li><li><strong>展开(unwind),清理调用栈(Stack)</strong></li><li><strong>退出程序</strong></li></ul><h2 id="为应对panic-展开或中止-abort-调用栈"><a href="#为应对panic-展开或中止-abort-调用栈" class="headerlink" title="为应对panic,展开或中止(abort)调用栈"></a>为应对panic,展开或中止(abort)调用栈</h2><p>默认情况下，当panic发生</p><ul><li>程序展开调用栈(工作量大)</li></ul><p>Rust沿着调用栈往回走</p><p>清理每个遇到的函数中的数据</p><ul><li>或立即中止调用栈</li></ul><p>不进行清理，直接停止程序</p><p>内存需要由OS进行清理</p><p><strong>想让二进制文件更小，把设置从“展开”改为“中止”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[profile.release]</span><br><span class="line">panic = &#x27;abort&#x27;</span><br></pre></td></tr></table></figure><p>自己写的代码中内panic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    panic!(&quot;crash and burn&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以依赖的代码中：外部panic</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let vector=vec![1,2,3];</span><br><span class="line">    vector[100];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Compiling demo v0.1.0 (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.18s</span><br><span class="line">     Running `target\debug\demo.exe`</span><br><span class="line">thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 100&#x27;, src\main.rs:3:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line">error: process didn&#x27;t exit successfully: `target\debug\demo.exe` (exit code: 101)</span><br></pre></td></tr></table></figure><h3 id="通过调用panic-的函数的回溯信息来定位引起问题的代码"><a href="#通过调用panic-的函数的回溯信息来定位引起问题的代码" class="headerlink" title="通过调用panic!的函数的回溯信息来定位引起问题的代码"></a>通过调用panic!的函数的回溯信息来定位引起问题的代码</h3><p>使用以下命令运行代码(Windows cmd)</p><p>set RUST_BACKTRACE=1 &amp;&amp; cargo run</p><p>Windows Poweshell </p><p>$Env:RUST_BACKTRACE=1 -and (cargo run)</p><p>linux下</p><p>export RUST_BACKTRACE=1 &amp;&amp; cargo run</p><p>更详细的信息</p><p><strong>RUST_BACKTRACE=full</strong></p><p>为了获取带有调试信息的回溯，必须启用调试符号(不带—release)</p><h2 id="Result枚举与可恢复的错误"><a href="#Result枚举与可恢复的错误" class="headerlink" title="Result枚举与可恢复的错误"></a>Result枚举与可恢复的错误</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T 代表成功时返回的 Ok 成员中的数据的类型，</p><p>而 E 代表失败时返回的 Err 成员中的错误的类型</p><p>Result及其变体也是由prelude带入作用域的</p><p>打开文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">    let f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(error) =&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配不同的错误"><a href="#匹配不同的错误" class="headerlink" title="匹配不同的错误"></a>匹配不同的错误</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">use std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">    let f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(error) =&gt; match error.kind() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) &#123;</span><br><span class="line">                Ok(fc) =&gt; fc,</span><br><span class="line">                Err(e) =&gt; panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, other_error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包（closure）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">use std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| &#123;</span><br><span class="line">        if error.kind() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| &#123;</span><br><span class="line">                panic!(&quot;Problem creating the file: &#123;:?&#125;&quot;, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a>unwrap</h3><p>match表达式的一个快捷方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">    let f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(error) =&gt; panic!(&quot;Problem opening the file: &#123;:?&#125;&quot;, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果Result结果是Ok，返回Ok里面的值</li><li>如果Result结果是Err,调用panic!宏</li></ul><h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><p>可自定义错误信息的unwrap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;).expect(&quot;无法打开文件&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h2><p>将错误传播给调用者</p><p><strong>自定义实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// src/main.rs</span><br><span class="line"></span><br><span class="line">use std::fs::File;</span><br><span class="line">use std::io::&#123;self, Read&#125;;</span><br><span class="line"></span><br><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;);</span><br><span class="line"></span><br><span class="line">    let mut f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(e) =&gt; return Err(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let mut s = String::new();</span><br><span class="line"></span><br><span class="line">    match f.read_to_string(&amp;mut s) &#123;</span><br><span class="line">        Ok(_) =&gt; Ok(s),</span><br><span class="line">        Err(e) =&gt; Err(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="？运算符"><a href="#？运算符" class="headerlink" title="？运算符"></a>？运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">use std::io;</span><br><span class="line">use std::io::Read;</span><br><span class="line"></span><br><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    let mut f = File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">    let mut s = String::new();</span><br><span class="line">    f.read_to_string(&amp;mut s)?;</span><br><span class="line">    Ok(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>? 被定义为与自定义传播错误的示例中定义的处理 Result 值的 match 表达式有着完全相同的工作方式。</p><p>如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将继续执行。</p><p>如果值是 Err，Err 中的值将作为整个函数的返回值，<strong>就好像使用了</strong> <strong>return</strong> <strong>关键字一样</strong>，这样错误值就被传播给了调用者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">use std::io::&#123;self, Read&#125;;</span><br><span class="line"></span><br><span class="line">fn read_file1() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;);</span><br><span class="line">    let mut f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(e) =&gt; return Err(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    let mut s = String::new();</span><br><span class="line">    match f.read_to_string(&amp;mut s) &#123;</span><br><span class="line">        Ok(_) =&gt; Ok(s),</span><br><span class="line">        Err(e) =&gt; Err(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn read_file2() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    let mut s = String::new();</span><br><span class="line"></span><br><span class="line">    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;</span><br><span class="line"></span><br><span class="line">    Ok(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string());</span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="？与-from-函数"><a href="#？与-from-函数" class="headerlink" title="？与 from 函数"></a>？与 from 函数</h2><p>Trait std::convert::From 上的from函数</p><ul><li>用于错误之间的转换</li><li>被？所应用的错误，会隐式地被from 函数处理</li><li>当? 调用from 函数时:</li></ul><p>它所接收地错误类型会被转化为当前函数返回类型所定义的错误类型</p><p>用于:针对不同的错误原因，返回同一种错误类型</p><p>只要每个错误类型实现了转换为所返回的错误类型的 from 函数</p><p>可以在 ? 之后直接使用<strong>链式方法调用</strong>来进一步缩短代码</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line">use std::io;</span><br><span class="line">use std::io::Read;</span><br><span class="line"></span><br><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    let mut s = String::new();</span><br><span class="line"></span><br><span class="line">    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;</span><br><span class="line"></span><br><span class="line">    Ok(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="？与main函数"><a href="#？与main函数" class="headerlink" title="？与main函数"></a>？与main函数</h2><p>main函数的返回类型为()类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">use std::error::Error;</span><br><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123;</span><br><span class="line">    let f = File::open(&quot;hello.txt&quot;)?;</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map，and-then"><a href="#map，and-then" class="headerlink" title="map，and_then"></a>map，and_then</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line">// With the return type rewritten, we use pattern matching without `unwrap()`.</span><br><span class="line">// But it&#x27;s so Verbose..</span><br><span class="line">fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123;</span><br><span class="line">    match n1_str.parse::&lt;i32&gt;() &#123;</span><br><span class="line">        Ok(n1)  =&gt; &#123;</span><br><span class="line">            match n2_str.parse::&lt;i32&gt;() &#123;</span><br><span class="line">                Ok(n2)  =&gt; &#123;</span><br><span class="line">                    Ok(n1 * n2)</span><br><span class="line">                &#125;,</span><br><span class="line">                Err(e) =&gt; Err(e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        Err(e) =&gt; Err(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Rewriting `multiply` to make it succinct</span><br><span class="line">// You  MUST USING `and_then` and `map` here</span><br><span class="line">fn multiply1(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123;</span><br><span class="line">    // IMPLEMENT...</span><br><span class="line">    n1_str.parse::&lt;i32&gt;().and_then(|n1| &#123;</span><br><span class="line">        n2_str.parse::&lt;i32&gt;().map(|n2| n1 * n2)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn print(result: Result&lt;i32, ParseIntError&gt;) &#123;</span><br><span class="line">    match result &#123;</span><br><span class="line">        Ok(n)  =&gt; println!(&quot;n is &#123;&#125;&quot;, n),</span><br><span class="line">        Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // This still presents a reasonable answer.</span><br><span class="line">    let twenty = multiply1(&quot;10&quot;, &quot;2&quot;);</span><br><span class="line">    print(twenty);</span><br><span class="line"></span><br><span class="line">    // The following now provides a much more helpful error message.</span><br><span class="line">    let tt = multiply(&quot;t&quot;, &quot;2&quot;);</span><br><span class="line">    print(tt);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="何时panic"><a href="#何时panic" class="headerlink" title="何时panic!"></a>何时panic!</h2><h3 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a><strong>总体原则</strong></h3><ul><li>在定义一个可能失败的函数时，优先考虑返回Result</li><li>否则就panic!</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>演示某些概念：unwrap</li><li>原型代码:unwrap,expect</li><li>测试:unwrap,expect</li></ul><p><strong>有时你比编译器掌握更多的信息</strong></p><p>你可以确定Result就是Ok:<strong>unwrap</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use std::net::IpAddr;</span><br><span class="line">  let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();</span><br></pre></td></tr></table></figure><p>调用你的代码，传入无意义的参数值:<strong>panic!</strong></p><p>调用外部不可控代码，返回非法状态，你无法修复:<strong>panic!</strong></p><p>如果失败是可预期的：<strong>Result</strong></p><p>当你的代码对值进行操作，首先应该验证这些值:<strong>panic!</strong></p><h3 id="创建自定义类型进行有效性验证"><a href="#创建自定义类型进行有效性验证" class="headerlink" title="创建自定义类型进行有效性验证"></a>创建自定义类型进行有效性验证</h3><p>一种实现方式是将猜测解析成 i32 而不仅仅是 u32，来默许输入负数，接着检查数字是否在范围内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">loop &#123;</span><br><span class="line">        // --snip--</span><br><span class="line"></span><br><span class="line">        let guess: i32 = match guess.trim().parse() &#123;</span><br><span class="line">            Ok(num) =&gt; num,</span><br><span class="line">            Err(_) =&gt; continue,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if guess &lt; 1 || guess &gt; 100 &#123;</span><br><span class="line">            println!(&quot;The secret number will be between 1 and 100.&quot;);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        match guess.cmp(&amp;secret_number) &#123;</span><br><span class="line">            // --snip--</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>if 表达式检查了值是否超出范围，告诉用户出了什么问题，并调用 continue 开始下一次循环，请求另一个猜测。if 表达式之后，就可以在知道 guess 在 1 到 100 之间的情况下与秘密数字作比较了。</p><p>相反我们可以创建一个新类型来将验证放入创建其实例的函数中，而不是到处重复这些检查。这样就可以安全的在函数签名中使用新类型并相信他们接收到的值。示例 中展示了一个定义 Guess 类型的方法，只有在 new 函数接收到 1 到 100 之间的值时才会创建 Guess 的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pub struct Guess &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Guess &#123;</span><br><span class="line">    pub fn new(value: i32) -&gt; Guess &#123;</span><br><span class="line">        if value &lt; 1 || value &gt; 100 &#123;</span><br><span class="line">            panic!(&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn value(&amp;self) -&gt; i32 &#123;</span><br><span class="line">        self.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实现了一个借用了 self 的方法 value，它没有任何其他参数并返回一个 i32。这类方法有时被称为 <em>getter</em>，因为它的目的就是返回对应字段的数据。这样的公有方法是必要的，因为 Guess 结构体的 value 字段是私有的。私有的字段 value 是很重要的，这样使用 Guess 结构体的代码将不允许直接设置 value 的值：调用者 <strong>必须</strong> 使用 Guess::new 方法来创建一个 Guess 的实例，这就确保了不会存在一个 value 没有通过 Guess::new 函数的条件检查的 Guess。</p><p>于是，一个接收（或返回） 1 到 100 之间数字的函数就可以声明为接收（或返回） Guess的实例，而不是 i32，同时其函数体中也无需进行任何额外的检查。</p><h2 id="在fn-main中使用Result"><a href="#在fn-main中使用Result" class="headerlink" title="在fn main中使用Result"></a>在fn main中使用Result</h2><p>一个典型的 main 函数长这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上 main 函数还可以返回一个 Result 类型：如果 main 函数内部发生了错误，那该错误会被返回并且打印出一条错误的 debug 信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line">fn main() -&gt; Result&lt;(), ParseIntError&gt; &#123;</span><br><span class="line">    let number_str = &quot;10&quot;;</span><br><span class="line">    let number = match number_str.parse::&lt;i32&gt;() &#123;</span><br><span class="line">        Ok(number)  =&gt; number,</span><br><span class="line">        Err(e) =&gt; return Err(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;, number);</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="函数中定义泛型"><a href="#函数中定义泛型" class="headerlink" title="函数中定义泛型"></a>函数中定义泛型</h2><p>寻找vec中的最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fn largest_i32(list: &amp;[i32]) -&gt; i32 &#123;</span><br><span class="line">    let mut largest = list[0];</span><br><span class="line">    for &amp;item in list &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn largest_char(list: &amp;[char]) -&gt; char &#123;</span><br><span class="line">    let mut largest = list[0];</span><br><span class="line">    for &amp;item in list &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number_list = vec![34, 50, 25, 100, 65];</span><br><span class="line">    let result = largest_i32(&amp;number_list);</span><br><span class="line">    println!(&quot;The largest number is &#123;&#125;&quot;, result);</span><br><span class="line">    let char_list = vec![&#x27;y&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;q&#x27;];</span><br><span class="line">    let result = largest_char(&amp;char_list);</span><br><span class="line">    println!(&quot;The largest char is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    let mut largest = list[0];</span><br><span class="line">    for &amp;item in list &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number_list = vec![34, 50, 25, 100, 65];</span><br><span class="line">    let result = largest(&amp;number_list);</span><br><span class="line">    println!(&quot;The largest number is &#123;&#125;&quot;, result);</span><br><span class="line">    let char_list = vec![&#x27;y&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;q&#x27;];</span><br><span class="line">    let result = largest(&amp;char_list);</span><br><span class="line">    println!(&quot;The largest char is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiling demo v0.1.0 (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to type `T`</span><br><span class="line"> --&gt; src\main.rs:5:17</span><br><span class="line">  |</span><br><span class="line">5 |         if item &gt; largest &#123;</span><br><span class="line">  |            ---- ^ ------- T</span><br><span class="line">  |            |</span><br><span class="line">  |            T</span><br><span class="line">  |</span><br><span class="line">help: consider restricting type parameter `T`</span><br><span class="line">  |</span><br><span class="line">1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">  |             ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0369`.</span><br><span class="line">error: could not compile `demo` due to previous error</span><br></pre></td></tr></table></figure><p>简单来说，这个错误表明 largest 的函数体不能适用于 T 的所有可能的类型</p><p>因为在函数体需要比较 T 类型的值，不过它只能用于我们知道如何排序的类型。为了开启比较功能，标准库中定义的 std::cmp::PartialOrd trait 可以实现类型的比较功能</p><h2 id="结构体中定义泛型"><a href="#结构体中定义泛型" class="headerlink" title="结构体中定义泛型"></a>结构体中定义泛型</h2><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let integer = Point &#123; x: 5, y: 10 &#125;;</span><br><span class="line">    let float = Point &#123; x: 1.0, y: 4.0 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举中定义泛型"><a href="#枚举中定义泛型" class="headerlink" title="枚举中定义泛型"></a>枚举中定义泛型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Option&lt;T&gt; &#123;</span><br><span class="line">    Some(T),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举也可以拥有多个泛型类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T, E&gt; &#123;</span><br><span class="line">    Ok(T),</span><br><span class="line">    Err(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法定义中的泛型"><a href="#方法定义中的泛型" class="headerlink" title="方法定义中的泛型"></a>方法定义中的泛型</h2><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    fn x(&amp;self) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;self.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Point&lt;i32&gt; &#123;</span><br><span class="line">    fn x(&amp;self) -&gt; &amp;i32 &#123;</span><br><span class="line">        &amp;self.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Point &#123; x: 5, y: 10 &#125;;</span><br><span class="line">    println!(&quot;p.x = &#123;&#125;&quot;, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把T放在impl关键字后,表示在类型T上实现方法:impl<T> Point<T></li><li>只针对具体类型实现方法:impl Point<f32></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Point&lt;f32&gt; &#123;</span><br><span class="line">    fn distance_from_origin(&amp;self) -&gt; f32 &#123;</span><br><span class="line">        (self.x.powi(2) + self.y.powi(2)).sqrt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Point&#123;x: 5.0_f32, y: 10.0_f32&#125;;</span><br><span class="line">    println!(&quot;&#123;&#125;&quot;,p.distance_from_origin())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct里的泛型类型参数可以和方法的泛型类型参数不同</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct Point&lt;X1, Y1&gt; &#123;</span><br><span class="line">    x: X1,</span><br><span class="line">    y: Y1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; &#123;</span><br><span class="line">    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: self.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p1 = Point &#123; x: 5, y: 10.4 &#125;;</span><br><span class="line">    let p2 = Point &#123; x: &quot;Hello&quot;, y: &#x27;c&#x27; &#125;;</span><br><span class="line"></span><br><span class="line">    let p3 = p1.mixup(p2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const泛型"><a href="#const泛型" class="headerlink" title="const泛型"></a>const泛型</h2><p>针对类型实现的泛型，所有的泛型都是为了抽象不同的类型，那有没有针对值的泛型？答案就是 Const 泛型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct ArrayPair&lt;T, const N: usize&gt; &#123;</span><br><span class="line">    left: [T; N],</span><br><span class="line">    right: [T; N],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T: Debug, const N: usize&gt; Debug for ArrayPair&lt;T, N&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line">fn foo&lt;const N: usize&gt;() &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn bar&lt;T, const M: usize&gt;() &#123;</span><br><span class="line">    foo::&lt;M&gt;(); // ok: 符合第一种</span><br><span class="line">    foo::&lt;2021&gt;(); // ok: 符合第二种</span><br><span class="line">    foo::&lt;&#123;20 * 100 + 20 * 10 + 1&#125;&gt;(); // ok: 符合第三种</span><br><span class="line">    </span><br><span class="line">    foo::&lt;&#123; M + 1 &#125;&gt;(); // error: 违背第三种，const 表达式中不能有泛型参数 M</span><br><span class="line">    foo::&lt;&#123; std::mem::size_of::&lt;T&gt;() &#125;&gt;(); // error: 泛型表达式包含了泛型参数 T</span><br><span class="line">    </span><br><span class="line">    let _: [u8; M]; // ok: 符合第一种</span><br><span class="line">    let _: [u8; std::mem::size_of::&lt;T&gt;()]; // error: 泛型表达式包含了泛型参数 T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>目前，const 泛型参数只能使用以下形式的实参:</li></ol><ul><li>一个单独的 const 泛型参数</li><li>一个字面量 (i.e. 整数, 布尔值或字符).</li><li>一个具体的 const 表达式( 表达式中不能包含任何 泛型参数)</li></ul><ol><li>const 泛型还能帮我们避免一些运行时检查，提升性能</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pub struct MinSlice&lt;T, const N: usize&gt; &#123;</span><br><span class="line">    pub head: [T; N],</span><br><span class="line">    pub tail: [T],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let slice: &amp;[u8] = b&quot;Hello, world&quot;;</span><br><span class="line">    let reference: Option&lt;&amp;u8&gt; = slice.get(6);</span><br><span class="line">    // 我们知道 `.get` 返回的是 `Some(b&#x27; &#x27;)`</span><br><span class="line">    // 但编译器不知道</span><br><span class="line">    assert!(reference.is_some());</span><br><span class="line"></span><br><span class="line">    let slice: &amp;[u8] = b&quot;Hello, world&quot;;</span><br><span class="line"></span><br><span class="line">    // 当编译构建 MinSlice 时会进行长度检查，也就是在编译期我们就知道它的长度是 12</span><br><span class="line">    // 在运行期，一旦 `unwrap` 成功，在 `MinSlice` 的作用域内，就再无需任何检查    </span><br><span class="line">    let minslice = MinSlice::&lt;u8, 12&gt;::from_slice(slice).unwrap();</span><br><span class="line">    let value: u8 = minslice.head[6];</span><br><span class="line">    assert_eq!(value, b&#x27; &#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`</p><p><T, const N: usize> 是结构体类型的一部分，和数组类型一样，这意味着长度不同会导致类型不同： Array<i32, 3> 和 Array<i32, 4> 是不同的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#[allow(unused)]</span><br><span class="line"></span><br><span class="line">struct Array&lt;T, const N: usize&gt; &#123;</span><br><span class="line">    data : [T; N]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let arrays = [</span><br><span class="line">        Array&#123;</span><br><span class="line">            data: [1, 2, 3],</span><br><span class="line">        &#125;,</span><br><span class="line">        Array &#123;</span><br><span class="line">            data: [1, 2, 3],</span><br><span class="line">        &#125;,</span><br><span class="line">        Array &#123;</span><br><span class="line">            data: [4,5,6]</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 填空</span><br><span class="line">fn print_array&lt;__&gt;(__) &#123;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, arr);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let arr = [1, 2, 3];</span><br><span class="line">    print_array(arr);</span><br><span class="line"></span><br><span class="line">    let arr = [&quot;hello&quot;, &quot;world&quot;];</span><br><span class="line">    print_array(arr);</span><br><span class="line">&#125;</span><br><span class="line">fn print_array&lt;T: std::fmt::Debug, const N: usize&gt;(arr: [T; N]) &#123;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, arr);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let arr = [1, 2, 3];</span><br><span class="line">    print_array(arr);</span><br><span class="line"></span><br><span class="line">    let arr = [&quot;hello&quot;, &quot;world&quot;];</span><br><span class="line">    print_array(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时我们希望能<strong>限制一个变量占用内存的大小</strong>，例如在嵌入式环境中，此时 const 泛型参数的第三种形式 const 表达式 就非常适合.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#![allow(incomplete_features)]</span><br><span class="line">#![feature(generic_const_exprs)]</span><br><span class="line"></span><br><span class="line">fn check_size&lt;T&gt;(val: T)</span><br><span class="line">where</span><br><span class="line">    Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; 768 &#125;&gt;: IsTrue,</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// fix the errors in main</span><br><span class="line">fn main() &#123;</span><br><span class="line">    check_size([0u8; 767]); </span><br><span class="line">    check_size([0i32; 191]);</span><br><span class="line">    check_size([&quot;hello你好&quot;; 47]); // &amp;str is a string reference, containing a pointer and string length in it, so it takes two word long, in x86-64, 1 word = 8 bytes</span><br><span class="line">    check_size([(); 31].map(|_| &quot;hello你好&quot;.to_string()));  // String is a smart pointer struct, it has three fields: pointer, length and capacity, each takes 8 bytes</span><br><span class="line">    check_size([&#x27;中&#x27;; 191]); // A char takes 4 bytes in Rust</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pub enum Assert&lt;const CHECK: bool&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">pub trait IsTrue &#123;&#125;</span><br><span class="line"></span><br><span class="line">impl IsTrue for Assert&lt;true&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型代码的性能"><a href="#泛型代码的性能" class="headerlink" title="泛型代码的性能"></a>泛型代码的性能</h2><p>Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。</p><p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>（<em>monomorphization</em>）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//fn main()&#123;</span><br><span class="line">//    let integer = Some(5);</span><br><span class="line">//    let float = Some(5.0);</span><br><span class="line">//&#125;</span><br><span class="line">enum Option_i32 &#123;</span><br><span class="line">    Some(i32),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Option_f64 &#123;</span><br><span class="line">    Some(f64),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let integer = Option_i32::Some(5);</span><br><span class="line">    let float = Option_f64::Some(5.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，rust会将Option泛型展开为Option<i32>和Option<i64>类型</p><h1 id="Trait：定义共同行为"><a href="#Trait：定义共同行为" class="headerlink" title="Trait：定义共同行为"></a>Trait：定义共同行为</h1><p>trait告诉Rust编译器，某种类型具有哪些并且可以与其他类型共享的功能</p><h2 id="定义一个trait"><a href="#定义一个trait" class="headerlink" title="定义一个trait"></a>定义一个trait</h2><p>把方法签名放在一起，来定义实现某种目的所必需的一组行为</p><ul><li>关键字：trait</li><li>只有方法签名，没有具体实现</li></ul><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String;</span><br><span class="line">    fn summarize1(&amp;self) -&gt; String;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在类型上实现trait"><a href="#在类型上实现trait" class="headerlink" title="在类型上实现trait"></a>在类型上实现trait</h2><p>与为类型实现方法类似</p><p>不同之处：impl Xxxx for Tweet{….}</p><p>文件: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub headline: String,</span><br><span class="line">    pub location: String,</span><br><span class="line">    pub author: String,</span><br><span class="line">    pub content: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary for NewsArticle &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub username: String,</span><br><span class="line">    pub content: String,</span><br><span class="line">    pub reply: bool,</span><br><span class="line">    pub retweet: bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary for Tweet &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;: &#123;&#125;&quot;, self.username, self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">use demo::&#123;Summary,Tweet&#125;;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let tweet = Tweet&#123;</span><br><span class="line">        username: String::from(&quot;horse_ebook&quot;),</span><br><span class="line">        content: String::from(&quot;of course,sa you probably...&quot;),</span><br><span class="line">        reply:false,</span><br><span class="line">        retweet:false,</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;1 new tweet:&#123;&#125;&quot;,tweet.summary());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo就是Cargo.toml文件中的[package]项的name</p><h2 id="实现trait的约束"><a href="#实现trait的约束" class="headerlink" title="实现trait的约束"></a>实现trait的约束</h2><p>可以在某个类型上实现某个trait的前提条件是:</p><ul><li>整个类型 <strong>或</strong> 这个trait是在本地crate里定义的</li></ul><p><strong>无法为外部类型实现外部trait</strong></p><p>这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p><h2 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h2><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        String::from(&quot;(Read more...)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub headline: String,</span><br><span class="line">    pub location: String,</span><br><span class="line">    pub author: String,</span><br><span class="line">    pub content: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary for NewsArticle &#123;</span><br><span class="line">    //fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">    //    format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location)</span><br><span class="line">    //&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub username: String,</span><br><span class="line">    pub content: String,</span><br><span class="line">    pub reply: bool,</span><br><span class="line">    pub retweet: bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary for Tweet &#123;</span><br><span class="line">    //默认实现的重写的实现</span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;&#123;&#125;: &#123;&#125;&quot;, self.username, self.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认实现允许调用相同 trait 中的其他方法</strong>，<strong>哪怕这些方法没有默认实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize_author(&amp;self) -&gt; String;</span><br><span class="line"></span><br><span class="line">    fn summarize(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;(Read more from &#123;&#125;...)&quot;, self.summarize_author())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:无法从方法的重写实现里面调用默认的实现</p><h2 id="trait作为参数"><a href="#trait作为参数" class="headerlink" title="trait作为参数"></a>trait作为参数</h2><h3 id="impl-triat语法："><a href="#impl-triat语法：" class="headerlink" title="impl triat语法："></a>impl triat语法：</h3><p>适用于简单情况,是trait bound的语法糖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify(item: &amp;impl Summary) &#123;</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait-bound语法："><a href="#trait-bound语法：" class="headerlink" title="trait bound语法："></a>trait bound语法：</h3><p>适用于复杂情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn notify&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    println!(&quot;Breaking news! &#123;&#125;&quot;, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较</p><p>pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {</p><p>这适用于 item1 和 item2 允许是不同类型的情况（只要它们都实现了 Summary）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p><p>pub fn notify<T: Summary>(item1: &amp;T, item2: &amp;T) {</p><h3 id="使用-指定多个traint-bound"><a href="#使用-指定多个traint-bound" class="headerlink" title="使用+指定多个traint bound"></a>使用+指定多个traint bound</h3><p>pub fn notify(item: &amp;(impl Summary + Display)) {pub fn notify<T: Summary + Display>(item: &amp;T) {</p><h3 id="使用where简化trait-bound"><a href="#使用where简化trait-bound" class="headerlink" title="使用where简化trait bound"></a>使用where简化trait bound</h3><p>fn some_function<T: Display + Clone, U: Clone + Debug>(t: &amp;T, u: &amp;U) -&gt; i32 {</p><p>使用where从句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32</span><br><span class="line">    where T: Display + Clone,</span><br><span class="line">          U: Clone + Debug</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><h2 id="返回实现了trait的类型"><a href="#返回实现了trait的类型" class="headerlink" title="返回实现了trait的类型"></a>返回实现了trait的类型</h2><p>也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn returns_summarizable() -&gt; impl Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: String::from(&quot;horse_ebooks&quot;),</span><br><span class="line">        content: String::from(</span><br><span class="line">            &quot;of course, as you probably already know, people&quot;,</span><br><span class="line">        ),</span><br><span class="line">        reply: false,</span><br><span class="line">        retweet: false,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这只适用于<strong>返回单一类型的情况</strong>。例如，这段代码的返回值类型指定为返回 impl Summary，但是返回了 NewsArticle 或 Tweet 就行不通：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fn returns_summarizable(switch: bool) -&gt; impl Summary &#123;</span><br><span class="line">    if switch &#123;</span><br><span class="line">        NewsArticle &#123;</span><br><span class="line">            headline: String::from(</span><br><span class="line">                &quot;Penguins win the Stanley Cup Championship!&quot;,</span><br><span class="line">            ),</span><br><span class="line">            location: String::from(&quot;Pittsburgh, PA, USA&quot;),</span><br><span class="line">            author: String::from(&quot;Iceburgh&quot;),</span><br><span class="line">            content: String::from(</span><br><span class="line">                &quot;The Pittsburgh Penguins once again are the best \</span><br><span class="line">                 hockey team in the NHL.&quot;,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Tweet &#123;</span><br><span class="line">            username: String::from(&quot;horse_ebooks&quot;),</span><br><span class="line">            content: String::from(</span><br><span class="line">                &quot;of course, as you probably already know, people&quot;,</span><br><span class="line">            ),</span><br><span class="line">            reply: false,</span><br><span class="line">            retweet: false,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尝试返回 NewsArticle 或 Tweet。这不能编译，因为 impl Trait 工作方式的限制。</p><p>可以使用dyn trait对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">struct Sheep &#123;&#125;</span><br><span class="line">struct Cow &#123;&#125;</span><br><span class="line"></span><br><span class="line">trait Animal &#123;</span><br><span class="line">    fn noise(&amp;self) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Animal for Sheep &#123;</span><br><span class="line">    fn noise(&amp;self) -&gt; String &#123;</span><br><span class="line">        &quot;baaaaah!&quot;.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Animal for Cow &#123;</span><br><span class="line">    fn noise(&amp;self) -&gt; String &#123;</span><br><span class="line">        &quot;moooooo!&quot;.to_string()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回一个类型，该类型实现了 Animal 特征，但是我们并不能在编译期获知具体返回了哪个类型</span><br><span class="line">// 修复这里的错误，你可以使用虚假的随机，也可以使用特征对象</span><br><span class="line">fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; &#123;</span><br><span class="line">    if random_number &lt; 0.5 &#123;</span><br><span class="line">        Box::new(Sheep &#123;&#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Box::new(Cow &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let random_number = 0.234;</span><br><span class="line">    let animal = random_animal(random_number);</span><br><span class="line">    println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特征对象-在数组中使用特征对象"><a href="#特征对象-在数组中使用特征对象" class="headerlink" title="特征对象,在数组中使用特征对象"></a>特征对象,在数组中使用特征对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">trait Bird &#123;</span><br><span class="line">    fn quack(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Duck;</span><br><span class="line">impl Duck &#123;</span><br><span class="line">    fn fly(&amp;self) &#123;</span><br><span class="line">        println!(&quot;Look, the duck is flying&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Swan;</span><br><span class="line">impl Swan &#123;</span><br><span class="line">    fn fly(&amp;self) &#123;</span><br><span class="line">        println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Bird for Duck &#123;</span><br><span class="line">    fn quack(&amp;self) &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, &quot;duck duck&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Bird for Swan &#123;</span><br><span class="line">    fn quack(&amp;self) &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, &quot;swan swan&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // 填空</span><br><span class="line">    let birds :[Box&lt;dyn Bird&gt;;2]=[Box::new(Duck&#123;&#125;),Box::new(Swan&#123;&#125;)];</span><br><span class="line"></span><br><span class="line">    for bird in birds &#123;</span><br><span class="line">        bird.quack();</span><br><span class="line">        // 当 duck 和 swan 变成 bird 后，它们都忘了如何翱翔于天际，只记得该怎么叫唤了。。</span><br><span class="line">        // 因此，以下代码会报错</span><br><span class="line">        // bird.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-dyn-和Box"><a href="#amp-dyn-和Box" class="headerlink" title="&amp;dyn 和Box"></a>&amp;dyn 和Box<dyn></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">trait Draw &#123;</span><br><span class="line">    fn draw(&amp;self) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Draw for u8 &#123;</span><br><span class="line">    fn draw(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;u8: &#123;&#125;&quot;, *self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Draw for f64 &#123;</span><br><span class="line">    fn draw(&amp;self) -&gt; String &#123;</span><br><span class="line">        format!(&quot;f64: &#123;&#125;&quot;, *self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 1.1f64;</span><br><span class="line">    let y = 8u8;</span><br><span class="line"></span><br><span class="line">    // draw x</span><br><span class="line">    draw_with_box(Box::new(x));</span><br><span class="line"></span><br><span class="line">    // draw y</span><br><span class="line">    draw_with_ref(&amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn draw_with_box(x: Box&lt;dyn Draw&gt;) &#123;</span><br><span class="line">    x.draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn draw_with_ref(x: &amp;dyn Draw) &#123;</span><br><span class="line">    x.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态分发和动态分发Static-and-Dynamic-dispatch"><a href="#静态分发和动态分发Static-and-Dynamic-dispatch" class="headerlink" title="静态分发和动态分发Static and Dynamic dispatch"></a>静态分发和动态分发Static and Dynamic dispatch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">trait Foo &#123;</span><br><span class="line">    fn method(&amp;self) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Foo for u8 &#123;</span><br><span class="line">    fn method(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Foo for String &#123;</span><br><span class="line">    fn method(&amp;self) -&gt; String &#123; format!(&quot;string: &#123;&#125;&quot;, *self) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// implement below with generics</span><br><span class="line">fn static_dispatch&lt;T: Foo&gt;(x: T) &#123;</span><br><span class="line">    x.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// implement below with trait objects</span><br><span class="line">fn dynamic_dispatch(x: &amp;dyn Foo) &#123;</span><br><span class="line">    x.method();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5u8;</span><br><span class="line">    let y = &quot;Hello&quot;.to_string();</span><br><span class="line"></span><br><span class="line">    static_dispatch(x);</span><br><span class="line">    dynamic_dispatch(&amp;y);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-trait-bounds-来修复-largest-函数"><a href="#使用-trait-bounds-来修复-largest-函数" class="headerlink" title="使用 trait bounds 来修复 largest 函数"></a>使用 trait bounds 来修复 largest 函数</h2><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    let mut largest = list[0];</span><br><span class="line"></span><br><span class="line">    for &amp;item in list &#123;</span><br><span class="line">        if item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number_list = vec![34, 50, 25, 100, 65];</span><br><span class="line"></span><br><span class="line">    let result = largest(&amp;number_list);</span><br><span class="line">    println!(&quot;The largest number is &#123;&#125;&quot;, result);</span><br><span class="line"></span><br><span class="line">    let char_list = vec![&#x27;y&#x27;, &#x27;m&#x27;, &#x27;a&#x27;, &#x27;q&#x27;];</span><br><span class="line"></span><br><span class="line">    let result = largest(&amp;char_list);</span><br><span class="line">    println!(&quot;The largest char is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果并不希望限制 largest 函数只能用于实现了 Copy trait 的类型，我们可以在 T 的 trait bounds 中指定 Clone 而不是 Copy。并克隆 slice 的每一个值使得 largest 函数拥有其所有权。使用 clone 函数意味着对于类似 String 这样拥有堆上数据的类型，会潜在的分配更多堆上空间，而堆分配在涉及大量数据时可能会相当缓慢。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T: PartialOrd + Clone&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    let mut largest = list[0].clone();</span><br><span class="line"></span><br><span class="line">    for item in list &#123;</span><br><span class="line">        if item &gt; &amp;largest &#123;</span><br><span class="line">            largest = item.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let str_list = vec![String::from(&quot;hello&quot;),String::from(&quot;world&quot;)];</span><br><span class="line">    let result = largest(&amp;str_list)</span><br><span class="line">    println!(&quot;The largest word is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者largest直接返回一个引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fn largest&lt;T: PartialOrd + Clone&gt;(list: &amp;[T]) -&gt; &amp;T &#123;</span><br><span class="line">    let mut largest = &amp;list[0];</span><br><span class="line"></span><br><span class="line">    for item in list &#123;</span><br><span class="line">        if item &gt; &amp;largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let str_list = vec![String::from(&quot;hello&quot;),String::from(&quot;world&quot;)];</span><br><span class="line">    let result = largest(&amp;str_list)</span><br><span class="line">    println!(&quot;The largest word is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-trait-bound-有条件地实现方法"><a href="#使用-trait-bound-有条件地实现方法" class="headerlink" title="使用 trait bound 有条件地实现方法"></a>使用 trait bound 有条件地实现方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Display;</span><br><span class="line"></span><br><span class="line">struct Pair&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    fn new(x: T, y: T) -&gt; Self &#123;</span><br><span class="line">        Self &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    fn cmp_display(&amp;self) &#123;</span><br><span class="line">        if self.x &gt;= self.y &#123;</span><br><span class="line">            println!(&quot;The largest member is x = &#123;&#125;&quot;, self.x);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;The largest member is y = &#123;&#125;&quot;, self.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为满足trait bound的所有类型上实现trait叫做覆盖实现(blanket implementations)</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T: Display&gt; ToString for T &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为标准库有了这些 blanket implementation，我们可以对任何实现了 Display trait 的类型调用由 ToString 定义的 to_string 方法。例如，可以将整型转换为对应的 String 值，因为整型实现了 Display：</p><p>let s = 3.to_string();</p><h2 id="Derive派生"><a href="#Derive派生" class="headerlink" title="Derive派生"></a>Derive派生</h2><p>我们可以使用 #[derive] 属性来派生一些特征，对于这些特征编译器会自动进行默认实现，对于日常代码开发而言，这是非常方便的，例如大家经常用到的 Debug 特征，就是直接通过派生来获取默认实现，而无需我们手动去完成这个工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// `Centimeters`, 一个元组结构体，可以被比较大小</span><br><span class="line">#[derive(PartialEq, PartialOrd)]</span><br><span class="line">struct Centimeters(f64);</span><br><span class="line"></span><br><span class="line">// `Inches`, 一个元组结构体可以被打印</span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct Inches(i32);</span><br><span class="line"></span><br><span class="line">impl Inches &#123;</span><br><span class="line">    fn to_centimeters(&amp;self) -&gt; Centimeters &#123;</span><br><span class="line">        let &amp;Inches(inches) = self;</span><br><span class="line"></span><br><span class="line">        Centimeters(inches as f64 * 2.54)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加一些属性让代码工作</span><br><span class="line">// 不要修改其它代码！</span><br><span class="line">#[derive(Debug,PartialEq,PartialOrd)]</span><br><span class="line">struct Seconds(i32);</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let _one_second = Seconds(1);</span><br><span class="line"></span><br><span class="line">    println!(&quot;One second looks like: &#123;:?&#125;&quot;, _one_second);</span><br><span class="line">    let _this_is_true = _one_second == _one_second;</span><br><span class="line">    let _this_is_true = _one_second &gt; _one_second;</span><br><span class="line"></span><br><span class="line">    let foot = Inches(12);</span><br><span class="line"></span><br><span class="line">    println!(&quot;One foot equals &#123;:?&#125;&quot;, foot);</span><br><span class="line"></span><br><span class="line">    let meter = Centimeters(100.0);</span><br><span class="line"></span><br><span class="line">    let cmp =</span><br><span class="line">        if foot.to_centimeters() &lt; meter &#123;</span><br><span class="line">            &quot;smaller&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &quot;bigger&quot;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;One foot is &#123;&#125; than one meter.&quot;, cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul><li>Rust的每个引用都有自己的生命周期</li><li>生命周期：引用保持有效的作用域</li><li>大多数情况下：生命周期是隐式的，可被推断的</li><li>当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期</li></ul><p>生命周期存在的目标是:<strong>避免悬空引用</strong></p><p>尝试使用离开作用域的值的引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let r;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            let x = 5;</span><br><span class="line">            r = &amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println!(&quot;r: &#123;&#125;&quot;, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="借用检查器"><a href="#借用检查器" class="headerlink" title="借用检查器"></a>借用检查器</h2><p>Rust 编译器有一个 <strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let r;                // ---------+-- &#x27;a</span><br><span class="line">                              //          |</span><br><span class="line">        &#123;                     //          |</span><br><span class="line">            let x = 5;        // -+-- &#x27;b  |</span><br><span class="line">            r = &amp;x;           //  |       |</span><br><span class="line">        &#125;                     // -+       |</span><br><span class="line">                              //          |</span><br><span class="line">        println!(&quot;r: &#123;&#125;&quot;, r); //          |</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里将 r 的生命周期标记为 ‘a 并将 x 的生命周期标记为 ‘b。如你所见，内部的 ‘b 块要比外部的生命周期 ‘a 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 r 拥有生命周期 ‘a，不过它引用了一个拥有生命周期 ‘b 的对象。程序被拒绝编译，因为生命周期 ‘b 比生命周期 ‘a 要小：被引用的对象比它的引用者存在的时间更短。</p><h2 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(&quot;abcd&quot;);</span><br><span class="line">    let string2 = &quot;xyz&quot;;</span><br><span class="line"></span><br><span class="line">    let result = longest(string1.as_str(), string2);</span><br><span class="line">    println!(&quot;The longest string is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src\main.rs:1:33</span><br><span class="line">  |</span><br><span class="line">1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |               ----     ----     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">1 | fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">  |           ++++     ++          ++          ++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `demo` due to previous error</span><br></pre></td></tr></table></figure><p>标识生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(&quot;abcd&quot;);</span><br><span class="line">    let string2 = &quot;xyz&quot;;</span><br><span class="line"></span><br><span class="line">    let result = longest(string1.as_str(), string2);</span><br><span class="line">    println!(&quot;The longest string is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h2><ul><li>生命周期的标注不会改变引用的生命周期的长度</li><li>当制定了泛型生命周期参数，函数可以接受带有任何生命周期的引用</li><li>生命周期的标注：<strong>描述了多个引用的生命周期的关系，但不影响生命周期</strong></li><li>生命周期的参数名:</li></ul><p>以 ‘ 开头，通常全小写且非常短，很多人使用 ‘a</p><ul><li>生命周期标注的位置</li></ul><p><strong>在引用的&amp;符号后</strong>，使用空格将标注和引用类型分开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;i32        // 引用</span><br><span class="line">&amp;&#x27;a i32     // 带有显式生命周期的引用</span><br><span class="line">&amp;&#x27;a mut i32 // 带有显式生命周期的可变引用</span><br></pre></td></tr></table></figure><p>泛型生命周期参数声明在:<strong>函数名和参数列表之间的&lt;&gt;里</strong></p><p>fn longest&lt;’a&gt;(x: &amp;’a str, y: &amp;’a str) -&gt; &amp;’a str {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实际含义是 longest 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致。</p><p>记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 longest 函数并不需要知道 x 和 y 具体会存在多久，而只需要知道有某个可以被 ‘a 替代的作用域将会满足这个签名。</p><p>当具体的引用被传递给 longest 时，被 ‘a 所替代的具体生命周期是 x 的作用域与 y 的作用域<strong>相重叠的那一部分</strong>。换一种说法就是泛型生命周期 ‘a 的具体生命周期等同于 x 和 y 的生命周期中<strong>较小的那一个</strong>。因为我们用相同的生命周期参数 ‘a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。</p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(&quot;long string is long&quot;);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let string2 = String::from(&quot;xyz&quot;);</span><br><span class="line">        let result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">        println!(&quot;The longest string is &#123;&#125;&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，string1 直到外部作用域结束都是有效的，string2 则在内部作用域中是有效的，而 result 则引用了一些直到内部作用域结束都是有效的值。借用检查器认可这些代码；它能够编译和运行，并打印出 The longest string is long string is long。</p><p>修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(&quot;long string is long&quot;);</span><br><span class="line">    let result;</span><br><span class="line">    &#123;</span><br><span class="line">        let string2 = String::from(&quot;xyz&quot;);</span><br><span class="line">        result = longest(string1.as_str(), string2.as_str());</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;The longest string is &#123;&#125;&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行出错</p><p>错误表明为了保证 println! 中的 result 是有效的，string2 需要直到外部作用域结束都是有效的。Rust 知道这些是因为（longest）函数的参数和返回值都使用了相同的生命周期参数 ‘a。</p><h2 id="深入理解声明周期"><a href="#深入理解声明周期" class="headerlink" title="深入理解声明周期"></a>深入理解声明周期</h2><ul><li><strong>指定生命周期参数的正确方式依赖函数实现的具体功能</strong></li></ul><p>如果将 longest 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 y 指定一个生命周期。如下代码将能够编译：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。</strong></li></ul><p>如果返回的引用 <strong>没有</strong> 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn longest&lt;&#x27;a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;&#x27;a str &#123;</span><br><span class="line">    let result = String::from(&quot;really long string&quot;);</span><br><span class="line">    result.as_str()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错</p><p>综上，生命周期语法是用于<strong>将函数的多个参数与其返回值的生命周期进行关联的</strong>。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。</p><h2 id="结构体定义中的生命周期注解"><a href="#结构体定义中的生命周期注解" class="headerlink" title="结构体定义中的生命周期注解"></a>结构体定义中的生命周期注解</h2><p>struct 里可包括：</p><ul><li>自持有类型</li><li>引用:需要在每个引用上添加声明周期标注</li></ul><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#x27;a&gt; &#123;</span><br><span class="line">    part: &amp;&#x27;a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);</span><br><span class="line">    let first_sentence = novel.split(&#x27;.&#x27;).next().expect(&quot;Could not find a &#x27;.&#x27;&quot;);</span><br><span class="line">    let i = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期的省略"><a href="#生命周期的省略" class="headerlink" title="生命周期的省略"></a>生命周期的省略</h2><p><strong>Lifetime Elision</strong></p><p>在Rust引用分析中所编入的模式称为<strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）</p><p>这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。</p><p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p><p>编译器采用<strong>三条规则</strong>来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则<strong>适用于</strong> <strong>fn</strong> <strong>定义，以及</strong> <strong>impl</strong> <strong>块</strong>。</p><ul><li><strong>规则1</strong>：每个引用类型的参数都有自己的声明周期</li><li><strong>规则2</strong>：如果只有1个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数</li><li><strong>规则3</strong>：如果有多个输入生命周期参数，但其中一个是&amp;self或&amp;mut self(是方法)，那么self的生命周期就会被赋给所有的输出生命周期参数</li></ul><p>例子:</p><p>假设我们自己就是编译器。</p><p>fn first_word(s: &amp;str) -&gt; &amp;str {</p><p>接着编译器应用第一条规则，也就是<strong>每个引用参数都有其自己的生命周期</strong>。</p><p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;str {</p><p>对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样：</p><p>fn first_word&lt;’a&gt;(s: &amp;’a str) -&gt; &amp;’a str {</p><p>现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期。</p><p>fn longest(x:&amp;str,y:&amp;str)-&gt;&amp;str{</p><p>应用第一条规则</p><p>fn longest&lt;’a,’b&gt;(x:&amp;’a str,y:&amp;’b str)-&gt;&amp;str{</p><p>第二条规则不适用，第三条不适用，所以编译器报错</p><h2 id="方法定义中的生命周期标注"><a href="#方法定义中的生命周期标注" class="headerlink" title="方法定义中的生命周期标注"></a>方法定义中的生命周期标注</h2><p>当为带有生命周期的结构体实现方法时，其语法依然类似泛型类型参数的语法。</p><p>在哪里声明生命周期参数，依赖于：</p><ul><li>生命周期参数是否同结构体字段或方法参数和返回值相关。</li></ul><p>struct字段的生命周期名:</p><ul><li>在impl后声明</li><li>在struct名后使用</li><li>这些生命周期是struct类型的一部分</li></ul><p>impl块内的方法签名中:</p><ul><li>引用必须绑定于struct字段引用的声明周期，或者引用是独立的也可以</li><li>生命周期省略规则经常使得方法中的生命周期标注不是必须的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;&#x27;a&gt;&#123;</span><br><span class="line">    part: &amp;&#x27;a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123;</span><br><span class="line">    fn level(&amp;self) -&gt; i32 &#123;</span><br><span class="line">        3</span><br><span class="line">    &#125;</span><br><span class="line">    //这里是一个适用于第三条生命周期省略规则的例子</span><br><span class="line">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">        println!(&quot;Attention please: &#123;&#125;&quot;, announcement);</span><br><span class="line">        self.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    let novel = String::from(&quot;Call me Ishmael.Some year ago...&quot;);</span><br><span class="line">    let first_sentence = novel.split(&#x27;.&#x27;).next().expect(&quot;Could not found a &#x27;.&#x27;&quot;);</span><br><span class="line">    let i = ImportantExcerpt&#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>announce_and_return_part这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 &amp;self 和 announcement 他们各自的生命周期。接着，因为其中一个参数是 &amp;self，返回值类型被赋予了 &amp;self 的生命周期，这样所有的生命周期都被计算出来了。</p><h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p>‘static，其生命周期<strong>能够</strong>存活于整个程序期间。</p><p><strong>所有的字符串字面值都拥有</strong> <strong>‘static</strong> <strong>生命周期</strong></p><p>let s: &amp;’static str = “I have a static lifetime.”;</p><p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 ‘static 的。</p><h2 id="结合泛型类型参数、trait-bounds-和生命周期"><a href="#结合泛型类型参数、trait-bounds-和生命周期" class="headerlink" title="结合泛型类型参数、trait bounds 和生命周期"></a>结合泛型类型参数、trait bounds 和生命周期</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::Display;</span><br><span class="line"></span><br><span class="line">fn longest_with_an_announcement&lt;&#x27;a, T&gt;(</span><br><span class="line">    x: &amp;&#x27;a str,</span><br><span class="line">    y: &amp;&#x27;a str,</span><br><span class="line">    ann: T,</span><br><span class="line">) -&gt; &amp;&#x27;a str</span><br><span class="line">where</span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    println!(&quot;Announcement! &#123;&#125;&quot;, ann);</span><br><span class="line">    if x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编写自动化测试"><a href="#编写自动化测试" class="headerlink" title="编写自动化测试"></a>编写自动化测试</h1><p>Rust 中的测试函数是用来验证非测试代码是否是按照期望的方式运行的。测试函数体通常执行如下三种操作：</p><ol><li>设置任何所需的数据或状态(Arrange)</li><li>运行需要测试的代码(Act)</li><li>断言（Assert）其结果是我们所期望的</li></ol><h2 id="测试函数剖析"><a href="#测试函数剖析" class="headerlink" title="测试函数剖析"></a>测试函数剖析</h2><h3 id="编写测试函数"><a href="#编写测试函数" class="headerlink" title="编写测试函数"></a>编写测试函数</h3><p>Rust 中的测试就是一个带有 test 属性注解的函数。属性（attribute）是关于 Rust 代码片段的元数据</p><p>为了将一个函数变成测试函数，需要在 fn 行之前加上 <strong>#[test]</strong></p><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><ul><li>使用cargo test命令运行所有测试函数</li></ul><p>Rust Hui构建一个Test Runner的可执行文件，它会运行标注了test的函数，并报告其运行是否成功</p><ul><li>当使用cargo创建library项目时，会生成一个test module,里面有一个test函数</li></ul><p>可以添加任意数量的test module或函数</p><p>cargo new 项目名 —lib</p><p>src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pub fn add(left: usize, right: usize) -&gt; usize &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_works() &#123;</span><br><span class="line">        let result = add(2, 2);</span><br><span class="line">        assert_eq!(result, 4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cargo run test</p><h3 id="测试失败"><a href="#测试失败" class="headerlink" title="测试失败"></a>测试失败</h3><ul><li>测试函数panic就表示失败</li><li>每个测试运行在一个新线程</li><li>当主线程看见某个测试线程挂掉了，那个测试标记为失败了</li></ul><h2 id="断言（Assert）"><a href="#断言（Assert）" class="headerlink" title="断言（Assert）"></a>断言（Assert）</h2><h3 id="使用assert-宏检查测试结果"><a href="#使用assert-宏检查测试结果" class="headerlink" title="使用assert!宏检查测试结果"></a>使用assert!宏检查测试结果</h3><p>assert!宏，来自标准库，用来确定某个状态是否为true</p><ul><li>true，测试通过</li><li>false, 调用panic！，测试失败</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123;</span><br><span class="line">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn larger_can_hold_smaller() &#123;</span><br><span class="line">        let larger = Rectangle &#123;</span><br><span class="line">            width: 8,</span><br><span class="line">            height: 7,</span><br><span class="line">        &#125;;</span><br><span class="line">        let smaller = Rectangle &#123;</span><br><span class="line">            width: 5,</span><br><span class="line">            height: 1,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        assert!(larger.can_hold(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-assert-eq-和-assert-ne-宏来测试相等"><a href="#使用-assert-eq-和-assert-ne-宏来测试相等" class="headerlink" title="使用 assert_eq! 和 assert_ne! 宏来测试相等"></a>使用 assert_eq! 和 assert_ne! 宏来测试相等</h3><ul><li>都来自于标准库</li><li>判断两个参数是否相等或不等</li><li>实际上，它们使用的就是==和！=运算符的assert!</li><li>断言失败，会自动打印出两个参数的值</li></ul><p>使用debug格式打印参数：要求参数实现了PartialEq和Debug Traits（所有基本类型和标准库大部分类型都实现了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pub fn add_two(a: i32) -&gt; i32 &#123;</span><br><span class="line">    a + 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_adds_two() &#123;</span><br><span class="line">        assert_eq!(4, add_two(2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><p>可以向 assert!、assert_eq! 和 assert_ne! 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息一同打印出来。</p><ul><li>assert! 宏的第一个参数必填，自定义消息作为第二个参数</li><li>assert_eq!和assert_ne! 前两个参数必填，自定义消息作为第3个参数</li><li>自定义消息参数会被传递给format!宏，可以使用{}占位符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pub fn greeting(name: &amp;str) -&gt; String &#123;</span><br><span class="line">    format!(&quot;Hello &#123;&#125;!&quot;, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn greeting_contains_name() &#123;</span><br><span class="line">        let result = greeting(&quot;Carol&quot;);</span><br><span class="line">        assert!(result.contains(&quot;Carol&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义错误信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#[test]</span><br><span class="line">    fn greeting_contains_name() &#123;</span><br><span class="line">        let result = greeting(&quot;Carol&quot;);</span><br><span class="line">        assert!(</span><br><span class="line">            result.contains(&quot;Carol&quot;),</span><br><span class="line">            &quot;Greeting did not contain name, value was `&#123;&#125;`&quot;,</span><br><span class="line">            result</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="验证错误处理的情况"><a href="#验证错误处理的情况" class="headerlink" title="验证错误处理的情况"></a>验证错误处理的情况</h2><p>可验证代码在特定情况下是否发生了panic</p><p>should_panic属性(attribute):</p><ul><li>函数panic：测试通过</li><li>函数没有panic：测试失败</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pub struct Guess &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Guess &#123;</span><br><span class="line">    pub fn new(value: i32) -&gt; Guess &#123;</span><br><span class="line">        if value &lt; 1 || value &gt; 100 &#123;</span><br><span class="line">            panic!(&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    #[should_panic]</span><br><span class="line">    fn greater_than_100() &#123;</span><br><span class="line">        Guess::new(200);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让should-panic更精确"><a href="#让should-panic更精确" class="headerlink" title="让should_panic更精确"></a>让should_panic更精确</h3><p>可以给 should_panic 属性增加一个可选的 expected 参数。测试工具会确保错误信息中包含其提供的文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// --snip--</span><br><span class="line">impl Guess &#123;</span><br><span class="line">    pub fn new(value: i32) -&gt; Guess &#123;</span><br><span class="line">        if value &lt; 1 &#123;</span><br><span class="line">            panic!(</span><br><span class="line">                &quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125; else if value &gt; 100 &#123;</span><br><span class="line">            panic!(</span><br><span class="line">                &quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]</span><br><span class="line">    fn greater_than_100() &#123;</span><br><span class="line">        Guess::new(200);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在测试中使用Result"><a href="#在测试中使用Result" class="headerlink" title="在测试中使用Result"></a>在测试中使用Result<T,E></h2><p>无需panic，可以使用Result<T,E>作为返回类型编写测试</p><ul><li>返回Ok:测试通过</li><li>返回Err:测试失败</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    #[test]</span><br><span class="line">    fn it_works() -&gt; Result&lt;(), String&gt; &#123;</span><br><span class="line">        if 2 + 2 == 4 &#123;</span><br><span class="line">            Ok(())</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Err(String::from(&quot;two plus two does not equal four&quot;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不能对这些使用 Result<T, E> 的测试使用 #[should_panic] 注解。</p><p>因为运行失败时会返回Err而不会发生panic</p><h2 id="控制测试运行"><a href="#控制测试运行" class="headerlink" title="控制测试运行"></a>控制测试运行</h2><p>改变cargo test的行为:添加命令行参数</p><p>默认行为:</p><ul><li>并行运行</li><li>所有测试</li><li>捕获（不显示）所有输出，是读取与测试结果相关的输出更容易</li></ul><p>命令行参数:</p><ul><li>针对cargo test的参数: 紧跟cargo test后 </li></ul><p>cargo test —help</p><ul><li>针对测试可执行程序: 放在—之后</li></ul><p>cargo test — —help</p><h3 id="并行运行测试"><a href="#并行运行测试" class="headerlink" title="并行运行测试"></a>并行运行测试</h3><p>默认使用多个线程并行运行</p><p>要确保测试之间：</p><ul><li>不会相互依赖</li><li>不依赖于某个共享状态(环境，工作目录，环境变量等)</li></ul><h4 id="—test-threads-参数"><a href="#—test-threads-参数" class="headerlink" title="—test-threads 参数"></a>—test-threads 参数</h4><p>如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 —test-threads 参数和希望使用线程的数量给测试二进制文件。例如：</p><p>$ cargo test — —test-threads=1</p><p>这里将测试线程设置为 1，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p><h3 id="显式函数输出"><a href="#显式函数输出" class="headerlink" title="显式函数输出"></a>显式函数输出</h3><p>默认，如果测试通过，Rust的test库会捕获所有打印到标准输出的内容</p><p>比如println!:</p><ul><li>如果测试成功，我们将不会在终端看到 println! 的输出：只会看到说明测试通过的提示行。</li><li>如果测试失败了，则会看到所有标准输出和其他错误信息。</li></ul><p>如果你希望也能看到通过的测试中打印的值，也可以在结尾加上 —show-output 告诉 Rust 显示成功测试的输出。</p><p>$ cargo test — —show-output</p><h3 id="按名称运行测试的子集"><a href="#按名称运行测试的子集" class="headerlink" title="按名称运行测试的子集"></a>按名称运行测试的子集</h3><p>如果没有传递任何参数就运行测试，所有测试都会并行运行：</p><h4 id="运行单个测试"><a href="#运行单个测试" class="headerlink" title="运行单个测试"></a>运行单个测试</h4><p>可以向 cargo test 传递任意测试的名称来只运行这个测试：</p><p>$ cargo test one_hundred</p><h4 id="过滤运行多个测试"><a href="#过滤运行多个测试" class="headerlink" title="过滤运行多个测试"></a>过滤运行多个测试</h4><p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 add，可以通过 cargo test add 来运行这两个测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo test add</span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished test [unoptimized + debuginfo] target(s) in 0.61s</span><br><span class="line">     Running unittests (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line">test tests::add_three_and_two ... ok</span><br><span class="line">test tests::add_two_and_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure><p>这运行了所有名字中带有 add 的测试，也过滤掉了名为 one_hundred 的测试。</p><h4 id="忽略某些测试"><a href="#忽略某些测试" class="headerlink" title="忽略某些测试"></a>忽略某些测试</h4><p>有时一些特定的测试执行起来是非常耗费时间的，所以在大多数运行 cargo test 的时候希望能排除他们</p><p>可以使用 ignore 属性来标记耗时的测试并排除他们，如下所示：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#[test]</span><br><span class="line">fn it_works() &#123;</span><br><span class="line">    assert_eq!(2 + 2, 4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">#[ignore]</span><br><span class="line">fn expensive_test() &#123;</span><br><span class="line">    // 需要运行一个小时的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于想要排除的测试，我们在 #[test] 之后增加了 #[ignore] 行。现在如果运行测试，就会发现 it_works 运行了，而 expensive_test 没有运行：</p><p>如果我们只希望运行被忽略的测试，可以使用 cargo test — —ignored：</p><p>$ cargo test — —ignored</p><h2 id="测试组织"><a href="#测试组织" class="headerlink" title="测试组织"></a>测试组织</h2><p>Rust 社区倾向于根据测试的两个主要分类来考虑问题：</p><p><strong>单元测试</strong>（<em>unit tests</em>）与 <strong>集成测试</strong>（<em>integration tests</em>）</p><ul><li>元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口。</li><li>而集成测试对于你的库来说则完全是外部的。它们与其他外部代码一样，通过相同的方式使用你的代码，只测试公有接口而且每个测试都有可能会测试多个模块。</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><strong>#[cfg(test)]标注test模块</strong></p><ul><li>只有运行cargo test才编译和运行代码</li><li>运行cargo build则不会</li><li>集成测试在不同的目录，它不需要#[cfg(test)]标注</li></ul><p><strong>cfg: configuration配置</strong></p><p>告诉Rust下面的条目只有在指定的配置选项下才被包含</p><h4 id="测试私有函数"><a href="#测试私有函数" class="headerlink" title="测试私有函数"></a>测试私有函数</h4><p>测试社区中一直存在关于是否应该对私有函数直接进行测试的论战，而在其他语言中想要测试私有函数是一件困难的，甚至是不可能的事。不过无论你坚持哪种测试意识形态，<strong>Rust 的私有性规则确实允许你测试私有函数</strong>。</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pub fn add_two(a: i32) -&gt; i32 &#123;</span><br><span class="line">    internal_adder(a, 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn internal_adder(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn internal() &#123;</span><br><span class="line">        assert_eq!(4, internal_adder(2, 2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 11-12：测试私有函数</p><p>注意 internal_adder 函数并没有标记为 pub。测试也不过是 Rust 代码，同时 tests 也仅仅是另一个模块。正如 “路径用于引用模块树中的项”部分所说，子模块的项可以使用其上级模块的项。在测试中，我们通过 use super::* 将 test 模块的父模块的所有项引入了作用域，接着测试调用了 internal_adder。</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>在Rust里，启程测试完全位于测试库的外部</p><p>同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以<strong>集成测试的覆盖率</strong>也是很重要的。</p><h4 id="tests目录"><a href="#tests目录" class="headerlink" title="tests目录"></a>tests目录</h4><ul><li>创建集成测试:tests目录</li><li>tests目录下的每个测试文件都是单独的一个crate</li></ul><p>创建一个集成测试。保留示例adder中 <em>src/lib.rs</em> 的代码。创建一个 <em>tests</em> 目录，新建一个文件 <em>tests/integration_test.rs</em>，并输入示例中的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use adder;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn it_adds_two() &#123;</span><br><span class="line">    assert_eq!(4, adder::add_two(2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>并不需要将 <em>tests/integration_test.rs</em> 中的任何代码标注为 #[cfg(test)]。 tests 文件夹在 Cargo 中是一个特殊的文件夹， Cargo 只会在运行 cargo test 时编译这个目录中的文件。</li><li>需要将被测试库导入</li></ul><h4 id="运行指定的集成测试"><a href="#运行指定的集成测试" class="headerlink" title="运行指定的集成测试"></a>运行指定的集成测试</h4><p>运行一个特定的集成测试</p><p>cargo test 函数名</p><p>运行某个测试文件内的所有测试</p><p>cargo test —test 文件名</p><h4 id="集成测试中的子模块"><a href="#集成测试中的子模块" class="headerlink" title="集成测试中的子模块"></a>集成测试中的子模块</h4><p>随着集成测试的增加，你可能希望在 tests 目录增加更多文件以便更好的组织他们，例如根据测试的功能来将测试分组。正如我们之前提到的，每一个 <em>tests</em> 目录中的文件都被编译为单独的 crate。</p><p>将每个集成测试文件当作其自己的 crate 来对待，这更有助于创建单独的作用域，这种单独的作用域能提供更类似与最终使用者使用 crate 的环境。</p><p>例如，如果我们可以创建 一个<em>tests/common.rs</em> 文件并创建一个名叫 setup 的函数，我们希望这个函数能被多个测试文件的测试函数调用：</p><p>文件名: tests/common.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub fn setup() &#123;</span><br><span class="line">    // setup code specific to your library&#x27;s tests would go here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果再次运行测试，将会在测试结果中看到一个新的对应 <em>common.rs</em> 文件的测试结果部分，即便这个文件并没有包含任何测试函数，也没有任何地方调用了 setup 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cargo test</span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished test [unoptimized + debuginfo] target(s) in 0.89s</span><br><span class="line">     Running unittests (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test tests::internal ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test it_adds_two ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line">test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span><br></pre></td></tr></table></figure><p>我们并不想要common 出现在测试结果中显示 running 0 tests 。我们只是希望其能被其他多个集成测试文件中调用罢了。</p><p>为了不让 common 出现在测试输出中，我们将<strong>创建</strong> <strong><em>tests/common/mod.rs</em></strong> ，<strong>而不是创建</strong> <strong><em>tests/common.rs</em></strong> 。这是一种 Rust 的命名规范，这样命名<strong>告诉 Rust 不要将</strong> <strong>common</strong> <strong>看作一个集成测试文件</strong>。将 setup 函数代码移动到 <em>tests/common/mod.rs</em> 并删除 <em>tests/common.rs</em> 文件之后，测试输出中将不会出现这一部分。<em>tests</em> 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中。</p><p>一旦拥有了 <em>tests/common/mod.rs</em>，就可以将其作为模块以便在任何集成测试文件中使用。这里是一个 <em>tests/integration_test.rs</em> 中调用 setup 函数的 it_adds_two 测试的例子：</p><p>文件名: tests/integration_test.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use adder;</span><br><span class="line"></span><br><span class="line">mod common;</span><br><span class="line"></span><br><span class="line">#[test]</span><br><span class="line">fn it_adds_two() &#123;</span><br><span class="line">    common::setup();</span><br><span class="line">    assert_eq!(4, adder::add_two(2));</span><br><span class="line">&#125;接着在测试函数中就可以调用 `common::setup()` 了。</span><br></pre></td></tr></table></figure><h4 id="针对binary-crate的集成测试"><a href="#针对binary-crate的集成测试" class="headerlink" title="针对binary crate的集成测试"></a>针对binary crate的集成测试</h4><ul><li>如果项目时binary crate 只有含有src/main.rs 没有src/lib.rs：</li></ul><p>不能在tests目录下创建集成测试</p><p>无法把main.rs的函数导入作用域</p><ul><li>只有library crate在能暴露函数给其它crate使用</li><li>binary crate意味着独立运行</li></ul><h1 id="IO项目-构建命令行程序"><a href="#IO项目-构建命令行程序" class="headerlink" title="IO项目:构建命令行程序"></a>IO项目:构建命令行程序</h1><h2 id="接收命令行参数"><a href="#接收命令行参数" class="headerlink" title="接收命令行参数"></a>接收命令行参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use std::env;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let args: Vec&lt;String&gt; = env::args().collect();</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><p>注意 std::env::args 在其任何参数包含无效 Unicode 字符时会 panic。如果你需要接受包含无效 Unicode 字符的参数，使用 std::env::args_os 代替。这个函数返回 OsString 值而不是 String 值。这里出于简单考虑使用了 std::env::args，因为 OsString 值每个平台都不一样而且比 String 值处理起来更为复杂。</p><h2 id="二进制项目的关注与分离"><a href="#二进制项目的关注与分离" class="headerlink" title="二进制项目的关注与分离"></a>二进制项目的关注与分离</h2><p>main 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区开发出一类在 main 函数开始变得庞大时进行二进制程序的关注分离的指导性过程。这些过程有如下步骤：</p><ul><li>将程序拆分成 <em>main.rs</em> 和 <em>lib.rs</em> 并将程序的逻辑放入 <em>lib.rs</em> 中。</li><li>当命令行解析逻辑比较小时，可以保留在 <em>main.rs</em> 中。</li><li>当命令行解析开始变得复杂时，也同样将其从 <em>main.rs</em> 提取到 <em>lib.rs</em> 中。</li></ul><p>经过这些过程之后保留在 main 函数中的责任应该被限制为：</p><ul><li>使用参数值调用命令行解析逻辑</li><li>设置任何其他的配置</li><li>调用 <em>lib.rs</em> 中的 run 函数</li><li>如果 run 返回错误，则处理这个错误</li></ul><p>这个模式的一切就是为了关注分离：<em>main.rs</em> 处理程序运行，而 <em>lib.rs</em> 处理所有的真正的任务逻辑。因为不能直接测试 main 函数，这个结构通过将所有的程序逻辑移动到 <em>lib.rs</em> 的函数中使得我们可以测试他们。仅仅保留在 <em>main.rs</em> 中的代码将足够小以便阅读就可以验证其正确性。</p><h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h2><p>遵循测试驱动开发（Test Driven Development, TDD）的模式来逐步增加 minigrep 的搜索逻辑。这是一个软件开发技术，它遵循如下步骤：</p><ol><li>编写一个失败的测试，并运行它以确保它失败的原因是你所期望的。</li><li>编写或修改足够的代码来使新的测试通过。</li><li>重构刚刚增加或修改的代码，并确保测试仍然能通过。</li><li>从步骤 1 开始重复！</li></ol><p>这只是众多编写软件的方法之一，不过 TDD 有助于驱动代码的设计。在编写能使测试通过的代码之前编写测试有助于在开发过程中保持高测试覆盖率。</p><h2 id="编写minigrep代码"><a href="#编写minigrep代码" class="headerlink" title="编写minigrep代码"></a>编写minigrep代码</h2><p>src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">use std::env;</span><br><span class="line">use std::error::Error;</span><br><span class="line">use std::fs;</span><br><span class="line"></span><br><span class="line">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123;</span><br><span class="line">    //读取文件</span><br><span class="line">    let contents = fs::read_to_string(&amp;config.filename)?;</span><br><span class="line">    // println!(&quot;With text:\n&#123;&#125;&quot;, contents);</span><br><span class="line">    let results = if config.case_sensitive &#123;</span><br><span class="line">        search(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        search_case_insensitive(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    for line in results &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, line);</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line">pub struct Config &#123;</span><br><span class="line">    pub query: String,</span><br><span class="line">    pub filename: String,</span><br><span class="line">    pub case_sensitive: bool,</span><br><span class="line">&#125;</span><br><span class="line">impl Config &#123;</span><br><span class="line">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;&#x27;static str&gt; &#123;</span><br><span class="line">        if args.len() &lt; 3 &#123;</span><br><span class="line">            return Err(&quot;not enough arguments&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        let query = args[1].clone();</span><br><span class="line">        let filename = args[2].clone();</span><br><span class="line">        // println!(&quot;Search for &#123;&#125;&quot;, query);</span><br><span class="line">        // println!(&quot;In file &#123;&#125;&quot;, filename);</span><br><span class="line">        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();</span><br><span class="line">        Ok(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn search&lt;&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123;</span><br><span class="line">    let mut result = Vec::new();</span><br><span class="line">    for line in contents.lines() &#123;</span><br><span class="line">        if line.contains(query) &#123;</span><br><span class="line">            result.push(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line">pub fn search_case_insensitive&lt;&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123;</span><br><span class="line">    let mut result = Vec::new();</span><br><span class="line">    let query = query.to_lowercase();</span><br><span class="line">    for line in contents.lines() &#123;</span><br><span class="line">        if line.to_lowercase().contains(&amp;query) &#123;</span><br><span class="line">            result.push(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line">    #[test]</span><br><span class="line">    fn case_sensitive() &#123;</span><br><span class="line">        let query = &quot;duct&quot;;</span><br><span class="line">        let contents = &quot;\</span><br><span class="line">Rust:</span><br><span class="line">safe,fast,productive.</span><br><span class="line">Pick three.&quot;;</span><br><span class="line">        assert_eq!(vec![&quot;safe,fast,productive.&quot;], search(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn case_insensitive() &#123;</span><br><span class="line">        let query = &quot;duct&quot;;</span><br><span class="line">        let contents = &quot;\</span><br><span class="line">Rust:</span><br><span class="line">safe,fast,productive.</span><br><span class="line">Pick three.&quot;;</span><br><span class="line">        assert_eq!(</span><br><span class="line">            vec![&quot;safe,fast,productive.&quot;],</span><br><span class="line">            search_case_insensitive(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use std::env;</span><br><span class="line">use std::process;</span><br><span class="line">use minigrep::Config;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let args: Vec&lt;String&gt; = env::args().collect();</span><br><span class="line">    // println!(&quot;&#123;:?&#125;&quot;,args);</span><br><span class="line">    let config = Config::new(&amp;args).unwrap_or_else(|err| &#123;</span><br><span class="line">        eprintln!(&quot;Problem parsing arguments:&#123;&#125;&quot;, err);</span><br><span class="line">        process::exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    if let Err(e) = minigrep::run(config)&#123;</span><br><span class="line">        eprintln!(&quot;Application error: &#123;&#125;&quot;,e);</span><br><span class="line">        process::exit(1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数式语言特性-迭代器和闭包"><a href="#函数式语言特性-迭代器和闭包" class="headerlink" title="函数式语言特性:迭代器和闭包"></a>函数式语言特性:迭代器和闭包</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Rust 的 <strong>闭包</strong>（<em>closures</em>）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数</p><ul><li>匿名函数</li><li>保存为变量,作为参数</li><li>可以在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</li><li>可从其定义的作用域捕获值</li></ul><p>文件名: src/main.rs</p><p>一个用来代替假定计算的函数，它大约会执行两秒钟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn simulated_expensive_calculation(intensity: u32) -&gt; u32 &#123;</span><br><span class="line">    println!(&quot;calculating slowly...&quot;);</span><br><span class="line">    thread::sleep(Duration::from_secs(2));</span><br><span class="line">    intensity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件名: src/main.rs</p><p>程序的业务逻辑，它根据输入并调用 simulated_expensive_calculation 函数来打印出健身计划</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn generate_workout(intensity: u32, random_number: u32) &#123;</span><br><span class="line">    if intensity &lt; 25 &#123;</span><br><span class="line">        println!(</span><br><span class="line">            &quot;Today, do &#123;&#125; pushups!&quot;,</span><br><span class="line">            simulated_expensive_calculation(intensity)</span><br><span class="line">        );</span><br><span class="line">        println!(</span><br><span class="line">            &quot;Next, do &#123;&#125; situps!&quot;,</span><br><span class="line">            simulated_expensive_calculation(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if random_number == 3 &#123;</span><br><span class="line">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(</span><br><span class="line">                &quot;Today, run for &#123;&#125; minutes!&quot;,</span><br><span class="line">                simulated_expensive_calculation(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件名: src/main.rs</p><p>main 函数包含了用于 generate_workout 函数的模拟用户输入和模拟随机数输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let simulated_user_specified_value = 10;</span><br><span class="line">    let simulated_random_number = 7;</span><br><span class="line"></span><br><span class="line">    generate_workout(simulated_user_specified_value, simulated_random_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let expensive_closure = |num| &#123;</span><br><span class="line">        println!(&quot;calculating slowly...&quot;);</span><br><span class="line">        thread::sleep(Duration::from_secs(2));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><ul><li>闭包定义是 expensive_closure 赋值的 = 之后的部分。闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数；</li><li>如果有多于一个参数，可以使用逗号分隔，比如 |param1, param2|。</li><li>参数之后是存放闭包体的大括号 —— 如果闭包体只有一行则大括号是可以省略的。大括号之后闭包的结尾，需要用于 let 语句的分号。因为闭包体的最后一行没有分号（正如函数体一样），所以闭包体（num）最后一行的返回值作为调用闭包时的返回值 。</li></ul><p>注意:</p><p>这个 let 语句意味着 expensive_closure 包含一个匿名函数的 <strong>定义</strong>，不是调用匿名函数的 <strong>返回值</strong>。</p><p><strong>重构代码</strong></p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn generate_workout(intensity: u32, random_number: u32) &#123;</span><br><span class="line">    let expensive_closure = |num| &#123;</span><br><span class="line">        println!(&quot;calculating slowly...&quot;);</span><br><span class="line">        thread::sleep(Duration::from_secs(2));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if intensity &lt; 25 &#123;</span><br><span class="line">        println!(&quot;Today, do &#123;&#125; pushups!&quot;, expensive_closure(intensity));</span><br><span class="line">        println!(&quot;Next, do &#123;&#125; situps!&quot;, expensive_closure(intensity));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if random_number == 3 &#123;</span><br><span class="line">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(</span><br><span class="line">                &quot;Today, run for &#123;&#125; minutes!&quot;,</span><br><span class="line">                expensive_closure(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包的类型推断"><a href="#闭包的类型推断" class="headerlink" title="闭包的类型推断"></a>闭包的类型推断</h3><ul><li>闭包不要求标注参数和返回值的类型</li><li>闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型</li><li>可以手动添加类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let expensive_closure = |num: u32| -&gt; u32 &#123;</span><br><span class="line">        println!(&quot;calculating slowly...&quot;);</span><br><span class="line">        thread::sleep(Duration::from_secs(2));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>与函数的比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn  add_one_v1   (x: u32) -&gt; u32 &#123; x + 1 &#125;//函数</span><br><span class="line">let add_one_v2 = |x: u32| -&gt; u32 &#123; x + 1 &#125;;//闭包</span><br><span class="line">let add_one_v3 = |x|             &#123; x + 1 &#125;;//闭包</span><br><span class="line">let add_one_v4 = |x|               x + 1  ;//闭包</span><br></pre></td></tr></table></figure><p>src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let example_closure = |x| x;</span><br><span class="line">    let s = example_closure(String::from(&quot;hello&quot;));</span><br><span class="line">    let n = example_closure(5);</span><br></pre></td></tr></table></figure><p>这个闭包在执行第二行代码时，编译器就能确定该闭包的类型是String了，而在执行第三行时就会报错</p><h3 id="泛型参数闭包"><a href="#泛型参数闭包" class="headerlink" title="泛型参数闭包"></a>泛型参数闭包</h3><p>在上面的代码仍然把慢计算闭包调用了比所需更多的次数。解决这个问题的一个方法是在全部代码中的每一个需要多个慢计算闭包结果的地方，可以将结果保存进变量以供复用，这样就可以使用变量而不是再次调用闭包。但是这样就会有很多重复的保存结果变量的地方。</p><p>幸运的是，还有另一个可用的方案。可以<strong>创建一个存放闭包和调用闭包结果的结构体</strong>。该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值。你可能见过这种模式被称 <strong><em>memoization\</em></strong> 或 <strong><em>lazy evaluation*</em></strong>（惰性求值）*。</p><h4 id="如何让struct持有闭包"><a href="#如何让struct持有闭包" class="headerlink" title="如何让struct持有闭包"></a>如何让struct持有闭包</h4><ul><li>struct的定义需要知道所有字段的类型，即需要指明闭包的类型</li><li>每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样</li><li>所以需要使用:泛型和Trait Bound</li></ul><p><strong>Fn Trait</strong></p><ul><li>由标准库提供</li><li>所有的闭包都至少实现了以下trait之一: </li></ul><p>​            Fn FnMut FnOnce</p><p>注意：<strong>函数也都实现了这三个</strong> <strong>Fn</strong> <strong>trait</strong>。如果不需要捕获环境中的值，则可以使用实现了 Fn trait 的函数而不是闭包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct Cacher&lt;T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Fn(u32) -&gt; u32,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: Option&lt;u32&gt;,</span><br><span class="line">&#125;</span><br><span class="line">impl&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Fn(u32) -&gt; u32,</span><br><span class="line">&#123;</span><br><span class="line">    fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: None,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn value(&amp;mut self, arg: u32) -&gt; u32 &#123;</span><br><span class="line">        match self.value &#123;</span><br><span class="line">            Some(v) =&gt; v,</span><br><span class="line">            None =&gt; &#123;</span><br><span class="line">                let v = (self.calculation)(arg);</span><br><span class="line">                self.value = Some(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体 Cacher 有一个泛型 T 的字段 calculation。T 的 trait bound 指定了 T 是一个使用 Fn 的闭包。任何我们希望储存到 Cacher 实例的 calculation 字段的闭包必须有一个 u32 参数（由 Fn 之后的括号的内容指定）并必须返回一个 u32（由 -&gt; 之后的内容）。</p><p>字段 value 是 Option<u32> 类型的。在执行闭包之前，value 将是 None。如果使用 Cacher 的代码请求闭包的结果，这时会执行闭包并将结果储存在 value 字段的 Some 成员中。接着如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 Some 成员中的结果。</p><p>重构代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn generate_workout(intensity: u32, random_number: u32) &#123;</span><br><span class="line">    let mut expensive_result = Cacher::new(|num| &#123;</span><br><span class="line">        println!(&quot;calculating slowly...&quot;);</span><br><span class="line">        thread::sleep(Duration::from_secs(2));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if intensity &lt; 25 &#123;</span><br><span class="line">        println!(&quot;Today, do &#123;&#125; pushups!&quot;, expensive_result.value(intensity));</span><br><span class="line">        println!(&quot;Next, do &#123;&#125; situps!&quot;, expensive_result.value(intensity));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if random_number == 3 &#123;</span><br><span class="line">            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(</span><br><span class="line">                &quot;Today, run for &#123;&#125; minutes!&quot;,</span><br><span class="line">                expensive_result.value(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cacher实现的限制"><a href="#Cacher实现的限制" class="headerlink" title="Cacher实现的限制"></a>Cacher实现的限制</h4><ol><li>第一个问题是 Cacher 实例假设对于 value 方法的任何 arg 参数值总是会返回相同的值。</li></ol><p><strong>解决方案</strong>：</p><p>可以使用HashMap代替单个值:</p><p>​    key: arg参数</p><p>​    value: 执行闭包的结果</p><ol><li>第二个问题是只能接收一个u32类型的参数和u32类型的返回值</li></ol><p><strong>解决方案:</strong></p><p>引入两个或多个泛型参数</p><h3 id="闭包会捕获其环境"><a href="#闭包会捕获其环境" class="headerlink" title="闭包会捕获其环境"></a>闭包会捕获其环境</h3><ul><li>可以捕获其环境并访问其被定义的作用域的变量,而普通函数则不能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 4;</span><br><span class="line"></span><br><span class="line">    let equal_to_x = |z| z == x;</span><br><span class="line"></span><br><span class="line">    let y = 4;</span><br><span class="line"></span><br><span class="line">    assert!(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会产生内存开销</li></ul><h4 id="闭包从所在环境捕获值的方式"><a href="#闭包从所在环境捕获值的方式" class="headerlink" title="闭包从所在环境捕获值的方式"></a>闭包从所在环境捕获值的方式</h4><p>与函数获得参数的三种方式一样:</p><ul><li>取得所有权: <strong>FnOnce</strong></li><li>可变借用: <strong>FnMut</strong></li><li>不可变借用: <strong>Fn</strong></li><li>FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 <strong>环境</strong>，<em>environment</em>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li><li>FnMut 获取可变的借用值所以可以改变其环境</li><li>Fn 从其环境获取不可变的借用值</li></ul><p>创建闭包时，通过闭包对环境值的使用，Rust推断出具体使用哪个trait：</p><ul><li>所有的闭包都实现了FnOnce</li><li>没有移动捕获变量的实现了FnMut</li><li>无需可变访问捕获变量的闭包实现了Fn</li></ul><p>实际上有一个层级关系，所有实现了Fn的都实现了FnMut，所有实现了FnMut的，都实现了FnOnce</p><h4 id="move关键字"><a href="#move关键字" class="headerlink" title="move关键字"></a>move关键字</h4><p>在参数列表前使用move关键字，可以强制闭包取得它所使用的环境值得所有权</p><ul><li>当将闭包传递给新线程以移动数据使其归新线程所有时，此技术最为有用</li></ul><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let equal_to_x = move |z| z == x;</span><br><span class="line"></span><br><span class="line">    println!(&quot;can&#x27;t use x here: &#123;:?&#125;&quot;, x);</span><br><span class="line"></span><br><span class="line">    let y = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    assert!(equal_to_x(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x 被移动进了闭包，因为闭包使用 move 关键字定义。接着闭包获取了 x 的所有权，同时 main 就不再允许在 println! 语句中使用 x 了。去掉 println! 即可修复问题。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>当指定Fn trait bound之一时，首先用Fn,基于闭包体里得情况，如果需要FnOnce或FnMut，编译器会再告诉你</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器模式允许你对一个序列的项进行某些处理。<strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑。当使用迭代器时，我们无需重新实现这些逻辑。</p><p>在 Rust 中，迭代器是 <strong>惰性的</strong>（<em>lazy</em>），这意味着在调用方法使用迭代器之前它都不会有效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let v1 = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let v1_iter = v1.iter();</span><br></pre></td></tr></table></figure><h3 id="Iterator-trait"><a href="#Iterator-trait" class="headerlink" title="Iterator trait"></a>Iterator trait</h3><ul><li>所有迭代器都实现了这个trait</li><li>定义于标准库</li></ul><p>这个 trait 的定义看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line"></span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</span><br><span class="line"></span><br><span class="line">    // 此处省略了方法的默认实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type Item 和 Self::Item，他们定义了 trait 的 <strong>关联类型</strong>（<em>associated type</em>）。</p><p>这段代码表明实现 Iterator trait 要求同时<strong>定义一个</strong> <strong>Item</strong> <strong>类型</strong>，这个 Item 类型被用作 <strong>next</strong> <strong>方法的返回值类型</strong>。换句话说，Item 类型将是迭代器返回元素的类型。</p><p>Iterator trait仅要求实现一个方法：next</p><p>next:</p><ul><li>每次返回迭代中的一项</li><li>返回结果包裹在Some里</li><li>迭代结束，返回None</li></ul><p>可直接在迭代器上调用next方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#[test]</span><br><span class="line">    fn iterator_demonstration() &#123;</span><br><span class="line">        let v1 = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">        let mut v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">        assert_eq!(v1_iter.next(), Some(&amp;1));</span><br><span class="line">        assert_eq!(v1_iter.next(), Some(&amp;2));</span><br><span class="line">        assert_eq!(v1_iter.next(), Some(&amp;3));</span><br><span class="line">        assert_eq!(v1_iter.next(), None);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>v1_iter 需要是可变的：在迭代器上调用 next 方法改变了迭代器中用来记录序列位置的状态。换句话说，代码 <strong>消费</strong>（consume）了，或使用了迭代器。每一个 next 调用都会从迭代器中消费一个项。</li><li>使用 for 循环时无需使 v1_iter 可变因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变。</li></ul><h4 id="几个迭代方法"><a href="#几个迭代方法" class="headerlink" title="几个迭代方法"></a>几个迭代方法</h4><ul><li>iter方法：在不可变引用上创建迭代器（元素的不可变引用）</li><li>into_iter方法：创建的迭代器会获得所有权</li><li>iter_mut方法: 迭代可变的引用</li></ul><h3 id="消耗迭代器的方法"><a href="#消耗迭代器的方法" class="headerlink" title="消耗迭代器的方法"></a>消耗迭代器的方法</h3><ul><li>在标准库中，Iterator trait由一些带默认实现的方法</li><li>其中有一些方法会调用next方法</li></ul><p>实现Iterator trait时必须实现next方法的原因之一</p><ul><li>调用next的叫做“<strong>消耗型适配器</strong>”</li></ul><p>因为调用它们会把迭代器耗尽</p><p>一个消费适配器的例子是 sum 方法。这个方法获取迭代器的所有权并反复调用 next 来遍历迭代器，因而会消费迭代器。当其遍历每一个项时，它将每一个项加总到一个总和并在迭代完成时返回总和。</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#[test]</span><br><span class="line">    fn iterator_sum() &#123;</span><br><span class="line">        let v1 = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">        let v1_iter = v1.iter();</span><br><span class="line"></span><br><span class="line">        let total: i32 = v1_iter.sum();</span><br><span class="line"></span><br><span class="line">        assert_eq!(total, 6);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="产生其它迭代器的方法"><a href="#产生其它迭代器的方法" class="headerlink" title="产生其它迭代器的方法"></a>产生其它迭代器的方法</h3><p>Iterator trait 中定义了另一类方法，被称为 <strong>迭代器适配器</strong>（<em>iterator adaptors</em>），</p><ul><li>他们允许将当前迭代器变为不同类型的迭代器。</li><li>可以链式调用多个迭代器适配器。</li><li>不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。</li></ul><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let v1: Vec&lt;i32&gt; = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    v1.iter().map(|x| x + 1);</span><br></pre></td></tr></table></figure><p>该 map 方法使用闭包来调用每个元素以生成新的迭代器。 这里的闭包创建了一个新的迭代器，对其中 vector 中的每个元素都被加 1。</p><p>不过这些代码会产生一个警告：</p><p> = note: iterators are lazy and do nothing unless consumed</p><p>代码实际上并没有做任何事；所指定的闭包从未被调用过。警告提醒了我们为什么：迭代器适配器是惰性的，而这里我们需要消费迭代器。</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let v1: Vec&lt;i32&gt; = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();</span><br><span class="line"></span><br><span class="line">    assert_eq!(v2, vec![2, 3, 4]);</span><br></pre></td></tr></table></figure><p>第二行代码的下划线实际上是让编译器去推断他的类型</p><p>collect方法是一个<strong>消耗型适配器</strong>，把结果收集到一个集合类型中</p><p>因为 map 获取一个闭包，可以指定任何希望在遍历的每个元素上执行的操作。这是一个展示如何使用闭包来自定义行为同时又复用 Iterator trait 提供的迭代行为的绝佳例子。</p><p>### </p><h3 id="使用闭包捕获环境"><a href="#使用闭包捕获环境" class="headerlink" title="使用闭包捕获环境"></a>使用闭包捕获环境</h3><p>filter方法</p><ul><li>迭代器的 filter 方法获取一个使用迭代器的每一个项并返回布尔值的闭包。</li><li>如果闭包返回 true，其值将会包含在 filter 提供的新迭代器中。</li><li>如果闭包返回 false，其值不会包含在结果迭代器中。</li></ul><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#[derive(PartialEq, Debug)]</span><br><span class="line">struct Shoe &#123;</span><br><span class="line">    size: u32,</span><br><span class="line">    style: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.into_iter().filter(|s| s.size == shoe_size).collect()</span><br><span class="line">    //闭包从环境中捕获了 `shoe_size` 变量并使用其值与每一只鞋的大小作比较</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn filters_by_size() &#123;</span><br><span class="line">        let shoes = vec![</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: 10,</span><br><span class="line">                style: String::from(&quot;sneaker&quot;),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: 13,</span><br><span class="line">                style: String::from(&quot;sandal&quot;),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: 10,</span><br><span class="line">                style: String::from(&quot;boot&quot;),</span><br><span class="line">            &#125;,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        let in_my_size = shoes_in_size(shoes, 10);</span><br><span class="line"></span><br><span class="line">        assert_eq!(</span><br><span class="line">            in_my_size,</span><br><span class="line">            vec![</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: 10,</span><br><span class="line">                    style: String::from(&quot;sneaker&quot;)</span><br><span class="line">                &#125;,</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: 10,</span><br><span class="line">                    style: String::from(&quot;boot&quot;)</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shoes_in_my_size 函数获取一个鞋子 vector 的所有权和一个鞋子大小作为参数。它返回一个只包含指定大小鞋子的 vector。</p><p>shoes_in_my_size 函数体中调用了 into_iter 来创建一个获取 vector 所有权的迭代器。接着调用 filter 将这个迭代器适配成一个只含有那些闭包返回 true 的元素的新迭代器。</p><p>闭包从环境中捕获了 shoe_size 变量并使用其值与每一只鞋的大小作比较，只保留指定大小的鞋子。最终，调用 collect 将迭代器适配器返回的值收集进一个 vector 并返回。</p><h3 id="创建自定义迭代器"><a href="#创建自定义迭代器" class="headerlink" title="创建自定义迭代器"></a>创建自定义迭代器</h3><p>，定义中唯一要求提供的方法就是 next 方法。一旦定义了它，就可以使用所有其他由 Iterator trait 提供的拥有默认实现的方法来创建自定义迭代器了！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct Counter &#123;</span><br><span class="line">    count: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Counter &#123;</span><br><span class="line">    fn new() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Iterator for Counter &#123;</span><br><span class="line">    type Item = u32;</span><br><span class="line">    //这里将迭代器的关联类型 Item 设置为 u32，意味着迭代器会返回 u32 值集合。</span><br><span class="line"></span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">        if self.count &lt; 5 &#123;</span><br><span class="line">            self.count += 1;</span><br><span class="line">            Some(self.count)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            None</span><br><span class="line">        &#125;</span><br><span class="line">        //如果 count 值小于 6，next 会返回封装在 Some 中的当前值，</span><br><span class="line">        //不过如果 count 大于或等于 6，迭代器会返回 None。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  #[test]</span><br><span class="line">    fn calling_next_directly() &#123;</span><br><span class="line">        let mut counter = Counter::new();</span><br><span class="line"></span><br><span class="line">        assert_eq!(counter.next(), Some(1));</span><br><span class="line">        assert_eq!(counter.next(), Some(2));</span><br><span class="line">        assert_eq!(counter.next(), Some(3));</span><br><span class="line">        assert_eq!(counter.next(), Some(4));</span><br><span class="line">        assert_eq!(counter.next(), Some(5));</span><br><span class="line">        assert_eq!(counter.next(), None);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过定义 next 方法实现 Iterator trait，我们现在就可以使用任何标准库定义的拥有默认实现的 Iterator trait 方法了，因为他们都使用了 next 方法的功能。</p><p>例如，出于某种原因我们希望获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在<strong>省略了第一个值</strong>之后产生的值配对，<strong>将每一对值相乘</strong>，<strong>只保留那些可以被三整除的结果</strong>，<strong>然后将所有保留的结果相加</strong>，这可以如示例 13-23 中的测试这样做：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#[test]</span><br><span class="line">    fn using_other_iterator_trait_methods() &#123;</span><br><span class="line">        let sum: u32 = Counter::new()</span><br><span class="line">            .zip(Counter::new().skip(1))</span><br><span class="line">            .map(|(a, b)| a * b)</span><br><span class="line">            .filter(|x| x % 3 == 0)</span><br><span class="line">            .sum();</span><br><span class="line">        assert_eq!(18, sum);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>示例 13-23：使用自定义的 Counter 迭代器的多种方法</p><p>注意 zip 只产生四对值；理论上第五对值 (5, None) 从未被产生，因为 zip 在任一输入迭代器返回 None 时也返回 None。</p><p>所有这些方法调用都是可能的，因为我们指定了 next 方法如何工作，而标准库则提供了其它调用 next 的方法的默认实现。</p><h3 id="改进I-O项目"><a href="#改进I-O项目" class="headerlink" title="改进I/O项目"></a>改进I/O项目</h3><h4 id="使用迭代器并去掉clone"><a href="#使用迭代器并去掉clone" class="headerlink" title="使用迭代器并去掉clone"></a>使用迭代器并去掉clone</h4><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">impl Config &#123;</span><br><span class="line">    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;&#x27;static str&gt; &#123;</span><br><span class="line">        if args.len() &lt; 3 &#123;</span><br><span class="line">            return Err(&quot;not enough arguments&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        let query = args[1].clone();</span><br><span class="line">        let filename = args[2].clone();</span><br><span class="line"></span><br><span class="line">        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();</span><br><span class="line"></span><br><span class="line">        Ok(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接使用env-args返回的迭代器"><a href="#直接使用env-args返回的迭代器" class="headerlink" title="直接使用env::args返回的迭代器"></a>直接使用env::args返回的迭代器</h4><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    //let args: Vec&lt;String&gt; = env::args().collect();</span><br><span class="line"></span><br><span class="line">    let config = Config::new(env::args()).unwrap_or_else(|err| &#123;</span><br><span class="line">        eprintln!(&quot;Problem parsing arguments: &#123;&#125;&quot;, err);</span><br><span class="line">        process::exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">use std::env;</span><br><span class="line">use std::error::Error;</span><br><span class="line">use std::fs;</span><br><span class="line"></span><br><span class="line">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; &#123;</span><br><span class="line">    //读取文件</span><br><span class="line">    let contents = fs::read_to_string(&amp;config.filename)?;</span><br><span class="line">    // println!(&quot;With text:\n&#123;&#125;&quot;, contents);</span><br><span class="line">    let results = if config.case_sensitive &#123;</span><br><span class="line">        search(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        search_case_insensitive(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    for line in results &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;, line);</span><br><span class="line">    &#125;</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line">pub struct Config &#123;</span><br><span class="line">    pub query: String,</span><br><span class="line">    pub filename: String,</span><br><span class="line">    pub case_sensitive: bool,</span><br><span class="line">&#125;</span><br><span class="line">impl Config &#123;</span><br><span class="line">    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;&#x27;static str&gt; &#123;</span><br><span class="line">        // if args.len() &lt; 3 &#123;</span><br><span class="line">        //     return Err(&quot;not enough arguments&quot;);</span><br><span class="line">        // &#125;</span><br><span class="line">        args.next();</span><br><span class="line">        let query = match args.next() &#123;</span><br><span class="line">            Some(arg) =&gt; arg,</span><br><span class="line">            None =&gt; return Err(&quot;Didn&#x27;t get a query string&quot;),</span><br><span class="line">        &#125;;</span><br><span class="line">        let filename = match args.next() &#123;</span><br><span class="line">            Some(arg) =&gt; arg,</span><br><span class="line">            None =&gt; return Err(&quot;Didn&#x27;t get a file name&quot;),</span><br><span class="line">        &#125;;</span><br><span class="line">        // println!(&quot;Search for &#123;&#125;&quot;, query);</span><br><span class="line">        // println!(&quot;In file &#123;&#125;&quot;, filename);</span><br><span class="line">        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();</span><br><span class="line">        Ok(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn search&lt;&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123;</span><br><span class="line">    // let mut result = Vec::new();</span><br><span class="line">    // for line in contents.lines() &#123;</span><br><span class="line">    //     if line.contains(query) &#123;</span><br><span class="line">    //         result.push(line);</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // result</span><br><span class="line"></span><br><span class="line">    contents</span><br><span class="line">        .lines()</span><br><span class="line">        .filter(|line| line.contains(query))</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br><span class="line">pub fn search_case_insensitive&lt;&#x27;a&gt;(query: &amp;str, contents: &amp;&#x27;a str) -&gt; Vec&lt;&amp;&#x27;a str&gt; &#123;</span><br><span class="line">    // let mut result = Vec::new();</span><br><span class="line">    // let query = query.to_lowercase();</span><br><span class="line">    // for line in contents.lines() &#123;</span><br><span class="line">    //     if line.to_lowercase().contains(&amp;query) &#123;</span><br><span class="line">    //         result.push(line);</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // result</span><br><span class="line">    contents</span><br><span class="line">        .lines()</span><br><span class="line">        .filter(|line| line.to_lowercase().contains(query.to_lowercase().as_str()))</span><br><span class="line">        .collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line">    #[test]</span><br><span class="line">    fn case_sensitive() &#123;</span><br><span class="line">        let query = &quot;duct&quot;;</span><br><span class="line">        let contents = &quot;\</span><br><span class="line">Rust:</span><br><span class="line">safe,fast,productive.</span><br><span class="line">Pick three.&quot;;</span><br><span class="line">        assert_eq!(vec![&quot;safe,fast,productive.&quot;], search(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn case_insensitive() &#123;</span><br><span class="line">        let query = &quot;duct&quot;;</span><br><span class="line">        let contents = &quot;\</span><br><span class="line">Rust:</span><br><span class="line">safe,fast,productive.</span><br><span class="line">Pick three.&quot;;</span><br><span class="line">        assert_eq!(</span><br><span class="line">            vec![&quot;safe,fast,productive.&quot;],</span><br><span class="line">            search_case_insensitive(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use std::env;</span><br><span class="line">use std::process;</span><br><span class="line">use minigrep::Config;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // println!(&quot;&#123;:?&#125;&quot;,args);</span><br><span class="line">    let config = Config::new(env::args()).unwrap_or_else(|err| &#123;</span><br><span class="line">        eprintln!(&quot;Problem parsing arguments:&#123;&#125;&quot;, err);</span><br><span class="line">        process::exit(1);</span><br><span class="line">    &#125;);</span><br><span class="line">    if let Err(e) = minigrep::run(config)&#123;</span><br><span class="line">        eprintln!(&quot;Application error: &#123;&#125;&quot;,e);</span><br><span class="line">        process::exit(1);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能比较-循环-迭代器"><a href="#性能比较-循环-迭代器" class="headerlink" title="性能比较 循环/迭代器"></a>性能比较 循环/迭代器</h3><p>代器是 Rust 的 <strong>零成本抽象</strong>（<em>zero-cost abstractions</em>）之一，它意味着抽象并不会引入运行时开销，它与本贾尼·斯特劳斯特卢普（C++ 的设计和实现者）在 “Foundations of C++”（2012） 中所定义的 <strong>零开销</strong>（<em>zero-overhead</em>）如出一辙：</p><p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</p><ul><li>Bjarne Stroustrup “Foundations of C++”</li></ul><p>从整体来说，C++ 的实现遵循了零开销原则：你不需要的，无需为他们买单。更有甚者的是：你需要的时候，也不可能找到其他更好的代码了。</p><ul><li>本贾尼·斯特劳斯特卢普 “Foundations of C++”</li></ul><h1 id="Cargo-和crates-io"><a href="#Cargo-和crates-io" class="headerlink" title="Cargo 和crates.io"></a>Cargo 和crates.io</h1><h2 id="采用发布配置自定义构建"><a href="#采用发布配置自定义构建" class="headerlink" title="采用发布配置自定义构建"></a>采用发布配置自定义构建</h2><p><strong>release profile</strong></p><ul><li>是预定义的</li><li>可自定义</li><li>每个profile配置独立于其它profile</li></ul><p>cargo主要的两个profile</p><ul><li><strong>dev profile</strong>: 适用于开发 cargo build</li><li><strong>release profile</strong>: 适用于发布 cargo build —release</li></ul><h3 id="自定义profile"><a href="#自定义profile" class="headerlink" title="自定义profile"></a>自定义profile</h3><p>在Cargo.toml中添加[profile.xxxx]区域，在里面覆盖某人配置的子集</p><p>文件名: Cargo.toml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[profile.dev]</span><br><span class="line">opt-level = 0</span><br><span class="line"></span><br><span class="line">[profile.release]</span><br><span class="line">opt-level = 3</span><br></pre></td></tr></table></figure><p>opt-level 设置控制 Rust 会对代码进行何种程度的优化。这个配置的值从 0 到 3。越高的优化级别需要更多的时间编译，所以如果你在进行开发并经常编译，可能会希望在牺牲一些代码性能的情况下编译得快一些。这就是为什么 dev 的 opt-level 默认为 0。</p><h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ul><li>生成HTML文档</li><li>显示公共Api的文档注释: 如何使用API</li><li>使用///</li><li>支持Markdown</li><li>放置在说明条目前</li></ul><h3 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h3><p>运行rustdoc工具</p><p>cargo doc</p><p>把生成的文档放到target/doc下</p><h3 id="生成文档并浏览"><a href="#生成文档并浏览" class="headerlink" title="生成文档并浏览"></a>生成文档并浏览</h3><p>cargo doc —open</p><h3 id="常用章节"><a href="#常用章节" class="headerlink" title="常用章节"></a>常用章节</h3><p>#Examples</p><p>其它常用章节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Panics: 函数可能发生panic的场景</span><br><span class="line">Errors: 如果函数返回Result,描述可能的错误种类，以及可导致错误的条件</span><br><span class="line">Safety: 如果函数处于unsafe调用，就应该解释函数unsafe的原因，以及调用者确保的使用前提</span><br></pre></td></tr></table></figure><h3 id="文档注释作为测试"><a href="#文档注释作为测试" class="headerlink" title="文档注释作为测试"></a>文档注释作为测试</h3><p>运行cargo test： 把文档注释中的示例代码作为测试来运行</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// Adds one to the number given.</span><br><span class="line">///</span><br><span class="line">/// # Examples</span><br><span class="line">///</span><br><span class="line">/// ```</span><br><span class="line">/// let arg = 5;</span><br><span class="line">/// let answer = my_crate::add_one(arg);</span><br><span class="line">///</span><br><span class="line">/// assert_eq!(6, answer);</span><br><span class="line">/// ```</span><br><span class="line">pub fn add_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">    x + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试 cargo test 运行像示例中 add_one 函数的文档；应该在测试结果中看到像这样的部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Doc-tests my_crate</span><br><span class="line"></span><br><span class="line">running 1 test</span><br><span class="line">test src/lib.rs - add_one (line 5) ... ok</span><br><span class="line"></span><br><span class="line">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s</span><br></pre></td></tr></table></figure><p>现在尝试改变函数或例子来使例子中的 assert_eq! 产生 panic。再次运行 cargo test，你将会看到文档测试捕获到了例子与代码不再同步！</p><h3 id="为包含注释的项添加文档注释"><a href="#为包含注释的项添加文档注释" class="headerlink" title="为包含注释的项添加文档注释"></a>为包含注释的项添加文档注释</h3><ul><li>符号: //!</li><li>这类注释通常描述crate和模块</li></ul><p>crate root (按惯例src/lib.rs)</p><p>一个模块内，将crate或模块作为一个整体进行记录</p><p>例子：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//! # My Crate</span><br><span class="line">//!</span><br><span class="line">//! `my_crate` is a collection of utilities to make performing certain</span><br><span class="line">//! calculations more convenient.</span><br><span class="line"></span><br><span class="line">/// Adds one to the number given.</span><br><span class="line">// --snip--</span><br></pre></td></tr></table></figure><h2 id="使用pub-use导出方便使用的公共API"><a href="#使用pub-use导出方便使用的公共API" class="headerlink" title="使用pub use导出方便使用的公共API"></a>使用pub use导出方便使用的公共API</h2><p>你开发时候使用的文件架构可能并不方便用户。你的结构可能是一个包含多个层级的分层结构，不过这对于用户来说并不方便。这是因为想要使用被定义在很深层级中的类型的人可能很难发现这些类型的存在。他们也可能会厌烦要使用 use my_crate::some_module::another_module::UsefulType; 而不是 use my_crate::UsefulType; 来使用类型。</p><p><strong>使用</strong> <strong>pub use</strong> <strong>重导出（re-export）项来使公有结构不同于私有结构</strong></p><p>src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//! # Art</span><br><span class="line">//!</span><br><span class="line">//! A library for modeling artistic concepts.</span><br><span class="line"></span><br><span class="line">pub mod kinds &#123;</span><br><span class="line">    /// The primary colors according to the RYB color model.</span><br><span class="line">    pub enum PrimaryColor &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// The secondary colors according to the RYB color model.</span><br><span class="line">    pub enum SecondaryColor &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub mod utils &#123;</span><br><span class="line">    use crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    /// Combines two primary colors in equal amounts to create</span><br><span class="line">    /// a secondary color.</span><br><span class="line">    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor &#123;</span><br><span class="line">        // --snip--</span><br><span class="line">        SecondaryColor::Green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use art::kinds::PrimaryColor;</span><br><span class="line">use art::utils::mix;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let red = PrimaryColor::Red;</span><br><span class="line">    let yellow = PrimaryColor::Yellow;</span><br><span class="line">    mix(red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了从公有 API 中去掉 crate 的内部组织，我们可以采用示例 中的 art crate 并增加 pub use 语句来重导出项到顶层结构，如示例 14-5 所示：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//! # Art</span><br><span class="line">//!</span><br><span class="line">//! A library for modeling artistic concepts.</span><br><span class="line"></span><br><span class="line">pub use self::kinds::PrimaryColor;</span><br><span class="line">pub use self::kinds::SecondaryColor;</span><br><span class="line">pub use self::utils::mix;</span><br><span class="line"></span><br><span class="line">pub mod kinds &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub mod utils &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use art::mix;</span><br><span class="line">use art::PrimaryColor;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>### </p><h2 id="发布Crate"><a href="#发布Crate" class="headerlink" title="发布Crate"></a>发布Crate</h2><p>有了唯一的名称、版本号、由 cargo new 新建项目时增加的作者信息、描述和所选择的 license，已经准备好发布的项目的 <em>Cargo.toml</em> 文件可能看起来像这样：</p><p>文件名: Cargo.toml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;guessing_game&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2021&quot;</span><br><span class="line">description = &quot;A fun game where you guess what number the computer has chosen.&quot;</span><br><span class="line">license = &quot;MIT OR Apache-2.0&quot;</span><br><span class="line">author = &quot;cyberboy&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br></pre></td></tr></table></figure><p>Cargo 的文档 描述了其他可以指定的元信息，他们可以帮助你的 crate 更容易被发现和使用！</p><p>发布：</p><p>cargo publish</p><p><strong>crate 一旦发布，就是永久性的:该版本无法覆盖，代码无法删除</strong></p><ul><li>目的：依赖于该版本的项目可继续正常工作</li></ul><h2 id="发布已存在crate的新版本"><a href="#发布已存在crate的新版本" class="headerlink" title="发布已存在crate的新版本"></a>发布已存在crate的新版本</h2><p>修改version重新发布</p><h2 id="使用cargo-yank从Crates-io撤回版本"><a href="#使用cargo-yank从Crates-io撤回版本" class="headerlink" title="使用cargo yank从Crates.io撤回版本"></a>使用cargo yank从Crates.io撤回版本</h2><ul><li>不可以删除crate之前的版本</li></ul><p>撤回某个版本会阻止新项目开始依赖此版本，不过所有现存此依赖的项目仍然能够下载和依赖这个版本。从本质上说，撤回意味着所有带有 <em>Cargo.lock</em> 的项目的依赖不会被破坏，同时任何新生成的 <em>Cargo.lock</em> 将不能使用被撤回的版本。</p><p>为了撤回一个 crate，运行 cargo yank 并指定希望撤回的版本：</p><p>$ cargo yank —vers 1.0.1</p><p>也可以撤销撤回操作，并允许项目可以再次开始依赖某个版本，通过在命令上增加 —undo：</p><p>$ cargo yank —vers 1.0.1 —undo</p><p>撤回 <strong>并没有</strong> 删除任何代码。举例来说，撤回功能并不意在删除不小心上传的秘密信息。如果出现了这种情况，请立即重新设置这些秘密信息。</p><h2 id="Cargo-工作空间（Workspaces）"><a href="#Cargo-工作空间（Workspaces）" class="headerlink" title="Cargo 工作空间（Workspaces）"></a>Cargo 工作空间（Workspaces）</h2><ul><li>cargo 工作空间： 帮助管理多个相互关联且需要协同开发的crate</li><li>cargo 工作空间是一套共享同一个Cargo.lock和输出文件夹的包</li></ul><h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><p><a href="https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html#cargo-工作空间">https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html#cargo-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4</a></p><p>为了在顶层 <em>add</em> 目录运行二进制 crate，可以通过 -p 参数和包名称来运行 cargo run 指定工作空间中我们希望使用的包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -p adder</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.0s</span><br><span class="line">     Running `target/debug/adder`</span><br><span class="line">Hello, world! 10 plus one is 11!</span><br></pre></td></tr></table></figure><p>这会运行 <em>adder/src/main.rs</em> 中的代码，其依赖 add_one crate</p><h2 id="从CRATES-IO安装二进制crate"><a href="#从CRATES-IO安装二进制crate" class="headerlink" title="从CRATES.IO安装二进制crate"></a>从CRATES.IO安装二进制crate</h2><ul><li>命令: cargo install</li><li>来源 <a href="https://crates.io">https://crates.io</a></li><li>限制: 只能安装具有二进制目标 (binary target) 的crate</li></ul><p>二进制目标binary target:是一个可运行的程序</p><ul><li>拥有src/main.rs或其它被指定为二进制文件的crate生成</li></ul><p>通常: READEME里面有关于crate的描述:</p><ul><li>拥有library target</li><li>拥有library target</li><li>两者兼备</li></ul><h3 id="cargo-install"><a href="#cargo-install" class="headerlink" title="cargo install"></a>cargo install</h3><p>cargo install 安装的二进制存放在根目录的bin文件夹</p><h2 id="使用自定义命令扩展cargo"><a href="#使用自定义命令扩展cargo" class="headerlink" title="使用自定义命令扩展cargo"></a>使用自定义命令扩展cargo</h2><ul><li>cargo被设计成可以使用子命令来扩展</li><li>例：如果$PATH中的某个二进制是cargo-something，你可以像子命令一样运行:</li></ul><p>cargo something</p><ul><li>类似这样的自定义命令可以通过该命令列出: cargo —list</li><li>优点: 可以使用cargo install来安装扩展，像内置工具一样来运行</li></ul><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul><li><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量的通用概念。</li></ul><p>这个地址引用，或 “指向”（points at）一些其他数据。</p><ul><li>Rust 中最常见的指针是 <strong>引用</strong>（<em>reference</em>）。</li></ul><p>引用以 &amp; 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也<strong>没有任何额外开销</strong>，所以应用得最多。</p><ul><li><strong>智能指针</strong>（<em>smart pointers</em>）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。</li></ul><h2 id="引用和智能指针的其它不同"><a href="#引用和智能指针的其它不同" class="headerlink" title="引用和智能指针的其它不同"></a>引用和智能指针的其它不同</h2><ul><li>引用：只借用数据</li><li>智能指针：很多时候都拥有它所指向的数据</li></ul><p><strong>智能指针的例子：</strong></p><ul><li>String 和 Vec<T></li><li>都拥有一片内存区域，且允许用户对其操作</li><li>还拥有元数据（例如容量等）</li><li>提供额外的功能或保障（String保障其数据是合法的UTF-8编码）</li></ul><p><strong>智能指针的实现</strong></p><ul><li>智能指针通常使用struct实现，并且实现了：</li></ul><p>Deref和Drop这两个trait</p><ul><li>Deref trait 允许智能指针struct的实例像引用一样使用</li><li>Drop trait 允许你自定义当智能指针实例走出作用域时的代码</li></ul><h2 id="使用Box指向堆上的数据"><a href="#使用Box指向堆上的数据" class="headerlink" title="使用Box指向堆上的数据"></a>使用Box<T>指向堆上的数据</h2><ul><li><p>Box<T>是最简单的智能指针：</p></li><li><ul><li>允许你在heap上存储数据（而不是stack）</li><li>stack上是指向heap数据的指针</li><li>没有性能开销</li><li>没有其它额外功能</li></ul></li><li><p>Box<T>实现了Deref trait和Drop trait</p></li></ul><p>多用于如下场景：</p><ul><li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li><li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li><li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let b = Box::new(5);</span><br><span class="line">    println!(&quot;b = &#123;&#125;&quot;,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Box赋能递归类型"><a href="#使用Box赋能递归类型" class="headerlink" title="使用Box赋能递归类型"></a>使用Box赋能递归类型</h2><ul><li>在编译时,Rust需要知道一个类型所占的空间大小</li><li>而递归类型的大小无法在编译时确定</li><li>但Box类型的大小确定</li><li>在递归类型中使用Box就可以解决上述问题</li><li>函数式语言的Cons List</li></ul><h2 id="Cons-List"><a href="#Cons-List" class="headerlink" title="Cons List"></a>Cons List</h2><p><em>cons list</em> 是一个来源于 Lisp 编程语言及其方言的数据结构。在 Lisp 中，cons 函数（“construct function” 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。</p><p>cons 函数的概念涉及到更常见的函数式编程术语；“将 <em>x</em> 与 <em>y</em> 连接” 通常意味着构建一个新的容器而将 <em>x</em> 的元素放在新容器的开头，其后则是容器 <em>y</em> 的元素。</p><p>cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 Nil 的值且没有下一项。cons list 通过递归调用 cons 函数产生。代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。</p><p>代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。注意这不同于 “null” 或 “nil” 的概念，他们代表无效或缺失的值。</p><p>Cons List并不是Rust的常用集合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use crate::List::&#123;Cons,Nil&#125;;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let list = Cons(1, Cons(2, Cons(3, Nil)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32,List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiling my_box v0.1.0 (C:\Users\cauchy\Desktop\rust\my_box)</span><br><span class="line">error[E0072]: recursive type `List` has infinite size</span><br><span class="line"> --&gt; src\main.rs:6:1</span><br><span class="line">  |</span><br><span class="line">6 | enum List &#123;</span><br><span class="line">  | ^^^^^^^^^</span><br><span class="line">7 |     Cons(i32,List),</span><br><span class="line">  |              ---- recursive without indirection</span><br><span class="line">  |</span><br><span class="line">help: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle</span><br><span class="line">  |</span><br><span class="line">7 |     Cons(i32,Box&lt;List&gt;),</span><br><span class="line">  |              ++++    +</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0072`.</span><br><span class="line">error: could not compile `my_box` due to previous error</span><br></pre></td></tr></table></figure><h2 id="计算非递归类型的大小"><a href="#计算非递归类型的大小" class="headerlink" title="计算非递归类型的大小"></a>计算非递归类型的大小</h2><p>Message 枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Rust 需要知道要为 Message 值分配多少空间时，它可以检查每一个成员并发现 </p><ul><li>Message::Quit 并不需要任何空间，</li><li>Message::Move 需要足够储存两个 i32 值的空间，依此类推。</li><li>因为 enum 实际上只会使用其中的一个成员，所以 Message 值所需的空间等于储存其最大成员的空间大小。</li></ul><p>与此相对当 Rust 编译器检查像上例的 List 这样的递归类型时会发生什么呢。编译器尝试计算出储存一个 List 枚举需要多少内存，并开始检查 Cons 成员，那么 Cons 需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，它检查其成员，从 Cons 成员开始。Cons成员储存了一个 i32 值和一个List值，这样的计算将无限进行下去</p><h2 id="使用Box给递归类型一个已知的大小"><a href="#使用Box给递归类型一个已知的大小" class="headerlink" title="使用Box给递归类型一个已知的大小"></a>使用Box<T>给递归类型一个已知的大小</h2><ul><li>因为 Box<T> 是一个指针，我们总是知道它需要多少空间</li></ul><p>——- 指针的大小并不会根据其指向的数据量而改变。</p><ul><li>Box<T></li></ul><ol><li>只提供了”间接”存储和heap内存分配的功能</li><li>没有其它额外功能</li><li>没有性能开销</li><li>适用于需要间接存储的场景，例如Cons List</li><li>实现了Deref trait和Drop trait</li></ol><h2 id="Dref-Trait"><a href="#Dref-Trait" class="headerlink" title="Dref Trait"></a>Dref Trait</h2><ul><li>实现Deref Trait使我们可以<strong>自定义解引用运算符*的行为</strong></li><li>通过实现Deref，智能指针可<strong>像引用一样来处理</strong></li></ul><h2 id="解引用运算符"><a href="#解引用运算符" class="headerlink" title="解引用运算符"></a>解引用运算符</h2><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;x;</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把Box当作引用"><a href="#把Box当作引用" class="headerlink" title="把Box当作引用"></a>把Box<T>当作引用</h2><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = Box::new(x);</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义自己的智能指针"><a href="#定义自己的智能指针" class="headerlink" title="定义自己的智能指针"></a>定义自己的智能指针</h2><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct MyBox&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    fn new(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的编译错误是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling deref-example v0.1.0 (file:///projects/deref-example)</span><br><span class="line">error[E0614]: type `MyBox&lt;&#123;integer&#125;&gt;` cannot be dereferenced</span><br><span class="line">  --&gt; src/main.rs:14:19</span><br><span class="line">   |</span><br><span class="line">14 |     assert_eq!(5, *y);</span><br><span class="line">   |                   ^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0614`.</span><br><span class="line">error: could not compile `deref-example` due to previous error</span><br></pre></td></tr></table></figure><p>MyBox<T> 类型不能解引用，因为我们尚未在该类型实现这个功能。为了启用 * 运算符的解引用功能，需要实现 Deref trait。</p><h2 id="通过实现-Deref-trait-将某类型像引用一样处理"><a href="#通过实现-Deref-trait-将某类型像引用一样处理" class="headerlink" title="通过实现 Deref trait 将某类型像引用一样处理"></a>通过实现 Deref trait 将某类型像引用一样处理</h2><ul><li>标准库中的Deref trait要求我们实现一个deref方法：</li></ul><p>— 该方法借用self</p><p>— 返回一个指向内部数据的引用</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Deref;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Deref for MyBox&lt;T&gt; &#123;</span><br><span class="line">    type Target = T;</span><br><span class="line"></span><br><span class="line">    fn deref(&amp;self) -&gt; &amp;Self::Target &#123;</span><br><span class="line">        &amp;self.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line">    assert_eq!(5, x);</span><br><span class="line">    assert_eq!(5, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入 *y 时，Rust 事实上在底层运行了如下代码：</p><p>*(y.deref())</p><h2 id="函数和方法的隐式解引用转化（Deref-Coercion）"><a href="#函数和方法的隐式解引用转化（Deref-Coercion）" class="headerlink" title="函数和方法的隐式解引用转化（Deref Coercion）"></a>函数和方法的隐式解引用转化（Deref Coercion）</h2><ul><li>Deref Coercion 是为<strong>函数和方法</strong>提供的一种便捷特性</li><li>假设T实现了Deref trait: Deref Coercion可以把T的引用转化为T经过Deref操作后生成的引用</li><li>当把某类型的引用传递给函数或方法时，但它的类型于定义的参数类型不匹配:</li></ul><ol><li>Deref Coercion就会自动发生</li><li>编译器会对deref进行一系列调用，来把它转为所需的参数类型</li><li>它在编译时完成，没有额外性能开销</li></ol><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn hello(name: &amp;str) &#123;</span><br><span class="line">    println!(&quot;Hello, &#123;&#125;!&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let m = MyBox::new(String::from(&quot;Rust&quot;));</span><br><span class="line">    //&amp;m &amp;MyBox&lt;String&gt;</span><br><span class="line">    //deref &amp;String</span><br><span class="line">    //&amp;String &amp;str</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这里使用 &amp;m 调用 hello 函数，其为 MyBox<String> 值的引用</li><li>因为示例 中在 MyBox<T> 上实现了 Deref trait，Rust 可以通过 deref 调用将 &amp;MyBox<String> 变为 &amp;String。</li><li>标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。Rust 再次调用 deref 将 &amp;String 变为 &amp;str，这就符合 hello 函数的定义了。</li></ol><p>如果 Rust 没有实现 Deref 强制转换，为了使用 &amp;MyBox<String> 类型的值调用 hello，则不得不编写以下的代码</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let m = MyBox::new(String::from(&quot;Rust&quot;));</span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解引用与可变性"><a href="#解引用与可变性" class="headerlink" title="解引用与可变性"></a>解引用与可变性</h2><ul><li>可使用DerefMut trait重载可变引用的*运算符</li><li>在类型和trait在下列三种情况发生时，Rust会执行deref coercion:</li></ul><ol><li>当T: Deref<Target=U>，允许&amp;T 转换为&amp;U</li><li>当T: Deref<Target=U>，允许&amp;mut T转换为&amp;mut U</li><li>当T: Deref<Target=U>，允许&amp;mut T转换为&amp;U</li></ol><h2 id="Drop-Trait"><a href="#Drop-Trait" class="headerlink" title="Drop Trait"></a>Drop Trait</h2><ul><li>实现Drop Trait 可以让我们自定义<strong>当值将要离开作用域时发生的动作</strong></li></ul><ol><li>例如：文件，网络资源释放等</li><li>任何类型都可以实现Drop trait</li></ol><ul><li>Drop Trait只要求你实现drop 方法</li></ul><ol><li>参数： 对self的可变引用</li></ol><ul><li>Drop trait 在预导入模块里</li></ul><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct CustomSmartPointer &#123;</span><br><span class="line">    data: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Drop for CustomSmartPointer &#123;</span><br><span class="line">    fn drop(&amp;mut self) &#123;</span><br><span class="line">        println!(&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;, self.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let c = CustomSmartPointer &#123;</span><br><span class="line">        data: String::from(&quot;my stuff&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    let d = CustomSmartPointer &#123;</span><br><span class="line">        data: String::from(&quot;other stuff&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;CustomSmartPointers created.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行这个程序，会出现如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling drop-example v0.1.0 (file:///projects/drop-example)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.60s</span><br><span class="line">     Running `target/debug/drop-example`</span><br><span class="line">CustomSmartPointers created.</span><br><span class="line">Dropping CustomSmartPointer with data `other stuff`!</span><br><span class="line">Dropping CustomSmartPointer with data `my stuff`!</span><br></pre></td></tr></table></figure><h3 id="使用std-mem-drop来提前drop值"><a href="#使用std-mem-drop来提前drop值" class="headerlink" title="使用std::mem::drop来提前drop值"></a>使用std::mem::drop来提前drop值</h3><ul><li>很难直接禁用自动的drop功能，也没必要</li></ul><ol><li>Drop trait的目的就是进行自动的释放处理逻辑</li></ol><ul><li>Rust 不允许手动调用Drop trait的drop方法</li><li>但可以调用标准库的std::mem::drop函数(prelude)，来提前drop值</li></ul><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let c = CustomSmartPointer &#123;</span><br><span class="line">        data: String::from(&quot;some data&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    println!(&quot;CustomSmartPointer created.&quot;);</span><br><span class="line">    drop(c);</span><br><span class="line">    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码会打印出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling drop-example v0.1.0 (file:///projects/drop-example)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.73s</span><br><span class="line">     Running `target/debug/drop-example`</span><br><span class="line">CustomSmartPointer created.</span><br><span class="line">Dropping CustomSmartPointer with data `some data`!</span><br><span class="line">CustomSmartPointer dropped before the end of main.</span><br></pre></td></tr></table></figure><p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 drop 只会在值不再被使用时被调用一次。</p><h2 id="Rc引用计数智能指针"><a href="#Rc引用计数智能指针" class="headerlink" title="Rc引用计数智能指针"></a>Rc<T>引用计数智能指针</h2><ul><li>有时一个值会有多个所有者</li><li>为了支持多重所有权: Rt<T></li></ul><ol><li>reference counting(引用计数)</li><li>追踪到值得引用</li><li>0个引用:该值可以被清理掉</li></ol><ul><li>需要在heap上分配数据，这些数据被程序得多个部分读取（只读），但在编译时无法确定哪个部分最后使用完这些数据</li><li>注意 Rc<T> 只能用于单线程场景；</li></ul><p>我们希望创建两个共享第三个列表所有权的列表，其概念将会看起来如图所示：</p><p>文件名: src/main.rs</p><p>不能用两个 Box<T> 的列表尝试共享第三个列表的所有权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, Box&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));</span><br><span class="line">    let b = Cons(3, Box::new(a));</span><br><span class="line">    let c = Cons(4, Box::new(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们修改 List 的定义为使用 Rc<T> 代替 Box<T>，如列表 所示。现在每一个 Cons 变量都包含一个值和一个指向 List 的 Rc<T>。当创建 b 时，不同于获取 a 的所有权，这里会克隆 a 所包含的 Rc<List>，这会将引用计数从 1 增加到 2 并允许 a 和 b 共享 Rc<List> 中数据的所有权。创建 c 时也会克隆 a，这会将引用计数从 2 增加为 3。每次调用 Rc::clone，Rc<List> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));</span><br><span class="line">    let b = Cons(3, Rc::clone(&amp;a));</span><br><span class="line">    let c = Cons(4, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以调用 a.clone() 而不是 Rc::clone(&amp;a)，不过在这里 Rust 的习惯是使用 Rc::clone。</p><ul><li>Rc::clone 的实现并不像大部分类型的 clone 实现那样对所有数据进行深拷贝。</li><li>Rc::clone 只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间。</li></ul><h2 id="克隆Rc会增加引用计数"><a href="#克隆Rc会增加引用计数" class="headerlink" title="克隆Rc会增加引用计数"></a>克隆Rc<T>会增加引用计数</h2><p>文件名: src/main.rs</p><p>Rc::strong_count获得引用计数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));</span><br><span class="line">    println!(&quot;count after creating a = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    let b = Cons(3, Rc::clone(&amp;a));</span><br><span class="line">    println!(&quot;count after creating b = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        let c = Cons(4, Rc::clone(&amp;a));</span><br><span class="line">        println!(&quot;count after creating c = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;count after c goes out of scope = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.45s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">count after creating a = 1</span><br><span class="line">count after creating b = 2</span><br><span class="line">count after creating c = 3</span><br><span class="line">count after c goes out of scope = 2</span><br></pre></td></tr></table></figure><p>我们能够看到 a 中 Rc<List> 的初始引用计数为1，接着每次调用 clone，计数会增加1。当 c 离开作用域时，计数减1。不必像调用 Rc::clone 增加引用计数那样调用一个函数来减少计数；Drop trait 的实现当 Rc<T> 值离开作用域时自动减少引用计数。</p><p>从这个例子我们所不能看到的是，在 main 的结尾当 b 然后是 a 离开作用域时，此处计数会是 0，同时 Rc<List> 被完全清理。使用 Rc<T> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。</p><ul><li>Rc<T>通过<strong>不可变引用</strong>， Rc<T> 允许在程序的多个部分之间只读地共享数据。</li><li>如果 Rc<T> 也允许多个可变引用，则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。</li></ul><h2 id="RefCell和内部可变性"><a href="#RefCell和内部可变性" class="headerlink" title="RefCell和内部可变性"></a>RefCell<T>和内部可变性</h2><h3 id="内部可变性（interior-mutability"><a href="#内部可变性（interior-mutability" class="headerlink" title="内部可变性（interior mutability)"></a>内部可变性（interior mutability)</h3><ul><li>interior mutability是Rust的设计模式之一</li><li>它允许你在支持有不可变引用的前提下对数据进行修改</li></ul><p>数据结构中使用了unsafe代码来绕过Rust正常的可变性和借用规则</p><ul><li>与Rc<T>不同，RefCell<T>类型代表了其持有数据的唯一所有权</li></ul><p>回忆借用规则：</p><ol><li>在任何给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用</li><li>引用总是有效的</li></ol><h3 id="RefCell与Box的区别"><a href="#RefCell与Box的区别" class="headerlink" title="RefCell与Box的区别"></a>RefCell<T>与Box<T>的区别</h3><div class="table-container"><table><thead><tr><th><strong>Box**</strong>&lt;<strong><strong>T</strong></strong>&gt;**</th><th><strong>RefCell**</strong>&lt;<strong><strong>T</strong></strong>&gt;**</th></tr></thead><tbody><tr><td><strong>编译阶段</strong>强制代码遵守借用规则</td><td>只会在<strong>运行时</strong>检查借用规则</td></tr><tr><td>否则出现错误</td><td>否则触发panic</td></tr></tbody></table></div><h3 id="借用规则在不同阶段进行检查的比较"><a href="#借用规则在不同阶段进行检查的比较" class="headerlink" title="借用规则在不同阶段进行检查的比较"></a>借用规则在不同阶段进行检查的比较</h3><div class="table-container"><table><thead><tr><th><strong>编译阶段</strong></th><th><strong>运行时</strong></th></tr></thead><tbody><tr><td>尽早暴露问题</td><td>问题暴露延后，甚至到生产环境</td></tr><tr><td>没有任何运行时开销</td><td>因借用计数产生些许性能损失</td></tr><tr><td>对大多数场景是最佳选择</td><td>实现某些特定的内存安全场景(不可变环境中修改自身数据)</td></tr><tr><td>是Rust的默认行为</td></tr></tbody></table></div><ul><li>与Rc<T>类似，只能用于<strong>单线程</strong>场景</li></ul><h3 id="选择Box，Rc，RefCell的依据"><a href="#选择Box，Rc，RefCell的依据" class="headerlink" title="选择Box，Rc，RefCell的依据"></a>选择Box<T>，Rc<T>，RefCell<T>的依据</h3><div class="table-container"><table><thead><tr><th></th><th><strong>Box**</strong>&lt;<strong><strong>T</strong></strong>&gt;**</th><th><strong>Rc**</strong>&lt;<strong><strong>T</strong></strong>&gt;**</th><th><strong>RefCell**</strong>&lt;<strong><strong>T</strong></strong>&gt;**</th></tr></thead><tbody><tr><td>同一数据的所有者</td><td>一个</td><td>多个</td><td>一个</td></tr><tr><td>可变性,借用检查</td><td>可变，不可变借用(编译时检查)</td><td>不可变借用(编译时检查)</td><td>可变，不可变借用（运行时检查）</td></tr></tbody></table></div><h3 id="内部可变性：可变的借用一个不可变的值"><a href="#内部可变性：可变的借用一个不可变的值" class="headerlink" title="内部可变性：可变的借用一个不可变的值"></a>内部可变性：可变的借用一个不可变的值</h3><p>借用规则的一个推论是当有一个不可变值时，不能可变地借用它。例如，如下代码不能编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x = 5;</span><br><span class="line">    let y = &amp;mut x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果尝试编译，会得到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling borrowing v0.1.0 (file:///projects/borrowing)</span><br><span class="line">error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable</span><br><span class="line"> --&gt; src/main.rs:3:13</span><br></pre></td></tr></table></figure><p>如下是一个我们想要测试的场景：我们在编写一个记录某个值与最大值的差距的库，并根据当前值与最大值的差距来发送消息。例如，这个库可以用于记录用户所允许的 API 调用数量限额。</p><p>该库只提供记录与最大值的差距，以及何种情况发送什么消息的功能。使用此库的程序则期望提供实际发送消息的机制：程序可以选择记录一条消息、发送 email、发送短信等等。库本身无需知道这些细节；只需实现其提供的 Messenger trait 即可。示例 15-20 展示了库代码：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">pub trait Messenger &#123;</span><br><span class="line">    fn send(&amp;self, msg: &amp;str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct LimitTracker&lt;&#x27;a, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;&#x27;a T,</span><br><span class="line">    value: usize,</span><br><span class="line">    max: usize,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;&#x27;a, T&gt; LimitTracker&lt;&#x27;a, T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: 0,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn set_value(&amp;mut self, value: usize) &#123;</span><br><span class="line">        self.value = value;</span><br><span class="line"></span><br><span class="line">        let percentage_of_max = self.value as f64 / self.max as f64;</span><br><span class="line"></span><br><span class="line">        if percentage_of_max &gt;= 1.0 &#123;</span><br><span class="line">            self.messenger.send(&quot;Error: You are over your quota!&quot;);</span><br><span class="line">        &#125; else if percentage_of_max &gt;= 0.9 &#123;</span><br><span class="line">            self.messenger</span><br><span class="line">                .send(&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;);</span><br><span class="line">        &#125; else if percentage_of_max &gt;= 0.75 &#123;</span><br><span class="line">            self.messenger</span><br><span class="line">                .send(&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    struct MockMessenger &#123;</span><br><span class="line">        sent_messages: Vec&lt;String&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl MockMessenger &#123;</span><br><span class="line">        fn new() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: vec![],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Messenger for MockMessenger &#123;</span><br><span class="line">        fn send(&amp;self, message: &amp;str) &#123;</span><br><span class="line">            self.sent_messages.push(String::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_sends_an_over_75_percent_warning_message() &#123;</span><br><span class="line">        let mock_messenger = MockMessenger::new();</span><br><span class="line">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(80);</span><br><span class="line"></span><br><span class="line">        assert_eq!(mock_messenger.sent_messages.len(), 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码中一个重要部分是拥有一个方法 send 的 Messenger trait，其获取一个 self 的<strong>不可变引用</strong>和文本信息。这个 trait 是 mock 对象所需要实现的接口库，这样 mock 就能像一个真正的对象那样使用了。另一个重要的部分是我们需要测试 LimitTracker 的 set_value 方法的行为。可以改变传递的 value 参数的值，不过 set_value 并没有返回任何可供断言的值。也就是说，如果使用某个实现了 Messenger trait 的值和特定的 max 创建 LimitTracker，当传递不同 value 值时，消息发送者应被告知发送合适的消息。</p><p>我们所需的 mock 对象是，调用 send 并不实际发送 email 或消息，而是只记录信息被通知要发送了。可以新建一个 mock 对象实例，用其创建 LimitTracker，调用 LimitTracker 的 set_value 方法，然后检查 mock 对象是否有我们期望的消息。示例 15-21 展示了一个如此尝试的 mock 对象实现，不过借用检查器并不允许：</p><p>然而，这个测试是有问题的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo test</span><br><span class="line">   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)</span><br><span class="line">error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</span><br><span class="line">  --&gt; src/lib.rs:58:13</span><br><span class="line">   |</span><br><span class="line">2  |     fn send(&amp;self, msg: &amp;str);</span><br><span class="line">   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`</span><br><span class="line">...</span><br><span class="line">58 |             self.sent_messages.push(String::from(message));</span><br><span class="line">   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `limit-tracker` due to previous error</span><br><span class="line">warning: build failed, waiting for other jobs to finish...</span><br><span class="line">error: build failed</span><br></pre></td></tr></table></figure><p>不能修改 MockMessenger 来记录消息，因为 send 方法获取了 self 的不可变引用。我们也不能参考错误文本的建议使用 &amp;mut self 替代，因为这样 send 的签名就不符合 Messenger trait 定义中的签名了（可以试着这么改，看看会出现什么错误信息）。</p><p>这正是内部可变性的用武之地！我们将通过 RefCell 来储存 sent_messages，然后 send 将能够修改 sent_messages 并储存消息。</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line">    use std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    struct MockMessenger &#123;</span><br><span class="line">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl MockMessenger &#123;</span><br><span class="line">        fn new() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::new(vec![]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Messenger for MockMessenger &#123;</span><br><span class="line">        fn send(&amp;self, message: &amp;str) &#123;</span><br><span class="line">            self.sent_messages.borrow_mut().push(String::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn it_sends_an_over_75_percent_warning_message() &#123;</span><br><span class="line">        // --snip--</span><br><span class="line"></span><br><span class="line">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用RefCell在运行时记录借用信息"><a href="#使用RefCell在运行时记录借用信息" class="headerlink" title="使用RefCell在运行时记录借用信息"></a>使用RefCell<T>在运行时记录借用信息</h3><ul><li>两个方法（安全接口）</li></ul><ol><li>borrow 方法：返回智能指针Ref<T>，它实现了Deref</li><li>borrow_mut方法：返回RefMut<T>，它实现了Deref</li></ol><ul><li>RefCell<T>会记录当前存在多少个活跃的Ref<T>和RefMut<T>智能指针</li></ul><ol><li>每次调用borrow：不可变借用计数+1</li><li>任何一个Ref<T>的值离开作用域被释放时：不可变借用计数-1</li><li>每次调用borrow_mut: 可变借用计数+1</li><li>任何一个RefMut<T>的值利开作用域被释放时：可变借用计数-1</li></ol><ul><li>Rust以此计数来维护借用检查规则：</li></ul><p>任何一个给定时间里，只允许拥有多个不可变借用或一个可变借用</p><h3 id="结合-Rc-和-RefCell-来拥有多个可变数据所有者"><a href="#结合-Rc-和-RefCell-来拥有多个可变数据所有者" class="headerlink" title="结合 Rc 和 RefCell 来拥有多个可变数据所有者"></a>结合 Rc 和 RefCell 来拥有多个可变数据所有者</h3><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let value = Rc::new(RefCell::new(5));</span><br><span class="line"></span><br><span class="line">    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));</span><br><span class="line">    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += 10;</span><br><span class="line"></span><br><span class="line">    println!(&quot;a after = &#123;:?&#125;&quot;, a);</span><br><span class="line">    println!(&quot;b after = &#123;:?&#125;&quot;, b);</span><br><span class="line">    println!(&quot;c after = &#123;:?&#125;&quot;, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们打印出 a、b 和 c 时，可以看到他们都拥有修改后的值 15 而不是 5：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.63s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">a after = Cons(RefCell &#123; value: 15 &#125;, Nil)</span><br><span class="line">b after = Cons(RefCell &#123; value: 3 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br><span class="line">c after = Cons(RefCell &#123; value: 4 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br></pre></td></tr></table></figure><h2 id="其它可实现内部可变性的类型"><a href="#其它可实现内部可变性的类型" class="headerlink" title="其它可实现内部可变性的类型"></a>其它可实现内部可变性的类型</h2><ul><li>Cell<T>：通过复制来访问数据</li><li>Mutex<T>：用于实现跨线程的情形下的内部可变性模式</li></ul><h2 id="循环引用导致内存泄漏"><a href="#循环引用导致内存泄漏" class="headerlink" title="循环引用导致内存泄漏"></a>循环引用导致内存泄漏</h2><p>Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 <strong>内存泄漏</strong>（<em>memory leak</em>）），但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的。这一点可以通过 Rc<T> 和 RefCell<T> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">use crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">enum List &#123;</span><br><span class="line">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl List &#123;</span><br><span class="line">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        match self &#123;</span><br><span class="line">            Cons(_, item) =&gt; Some(item),</span><br><span class="line">            Nil =&gt; None,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));</span><br><span class="line"></span><br><span class="line">    println!(&quot;a initial rc count = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span><br><span class="line"></span><br><span class="line">    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));</span><br><span class="line"></span><br><span class="line">    println!(&quot;a rc count after b creation = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line">    println!(&quot;b initial rc count = &#123;&#125;&quot;, Rc::strong_count(&amp;b));</span><br><span class="line">    println!(&quot;b next item = &#123;:?&#125;&quot;, b.tail());</span><br><span class="line"></span><br><span class="line">    if let Some(link) = a.tail() &#123;</span><br><span class="line">        *link.borrow_mut() = Rc::clone(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;b rc count after changing a = &#123;&#125;&quot;, Rc::strong_count(&amp;b));</span><br><span class="line">    println!(&quot;a rc count after changing a = &#123;&#125;&quot;, Rc::strong_count(&amp;a));</span><br><span class="line"></span><br><span class="line">    // Uncomment the next line to see that we have a cycle;</span><br><span class="line">    // it will overflow the stack</span><br><span class="line">    // println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果保持最后的 println! 行注释并运行代码，会得到如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.53s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">a initial rc count = 1</span><br><span class="line">a next item = Some(RefCell &#123; value: Nil &#125;)</span><br><span class="line">a rc count after b creation = 2</span><br><span class="line">b initial rc count = 1</span><br><span class="line">b next item = Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)</span><br><span class="line">b rc count after changing a = 2</span><br><span class="line">a rc count after changing a = 2</span><br></pre></td></tr></table></figure><p>如果取消最后 println! 的注释并运行程序，Rust 会尝试打印出 a 指向 b 指向 a 这样的循环直到栈溢出。</p><p><strong>防止内存泄漏的解决办法</strong></p><ul><li>依靠开发者来保证，不能依靠Rust</li><li>重新组织数据结构：一些引用来表达所有权，一些引用不表达所有权</li></ul><ol><li>循环引用中的一部分具有所有权关系，另一部分不涉及所有权关系</li><li>而只有所有权关系才影响值的清理</li></ol><h3 id="避免引用循环：将-Rc-变为-Weak"><a href="#避免引用循环：将-Rc-变为-Weak" class="headerlink" title="避免引用循环：将 Rc 变为 Weak"></a>避免引用循环：将 Rc<T> 变为 Weak<T></h3><ul><li>Rc::clone为Rc<T>实例的strong_count加1，Rc<T>的实例只有在strong_count为0时才会被清理</li><li>Rc<T>实例通过调用Rc::downgrade方法可以创建值的Weak Reference（弱引用）</li></ul><ol><li>返回类型是Weak<T>（智能指针）</li><li>调用Rc::downgrade会为weak_count加1</li></ol><ul><li>Rc<T>使用weak_count来追踪存在多少Weak<T></li><li>weak_count不为0并不影响Rc<T>实例的清理</li></ul><h3 id="Strong-VS-Weak"><a href="#Strong-VS-Weak" class="headerlink" title="Strong VS Weak"></a>Strong VS Weak</h3><ul><li>Strong Reference 是关于如何分享Rc<T>实例的所有权</li><li>Weak Reference 并不表达上述意思</li><li>使用Weak Reference并不会创建循环引用：</li></ul><p>当Strong Reference数量为0的时候，Weak Reference会自动断开</p><ul><li>在使用Weak<T>前，需保证它指向的值仍然存在：</li></ul><p>在Weak<T>实例上调用upgrade方法，返回Option<Rc<T>&gt;</p><h4 id="创建树形数据结构：带有子节点的-Node"><a href="#创建树形数据结构：带有子节点的-Node" class="headerlink" title="创建树形数据结构：带有子节点的 Node"></a>创建树形数据结构：带有子节点的 Node</h4><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::Rc;</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct Node &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let leaf = Rc::new(Node &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        children: RefCell::new(vec![]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let branch = Rc::new(Node &#123;</span><br><span class="line">        value: 5,</span><br><span class="line">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这里克隆了 leaf 中的 Rc<Node> 并储存在了 branch 中，这意味着 leaf 中的 Node 现在有两个所有者：leaf和branch。可以通过 branch.children 从 branch 中获得 leaf，不过无法从 leaf 到 branch。leaf 没有到 branch 的引用且并不知道他们相互关联。我们希望 leaf 知道 branch 是其父节点。稍后我们会这么做</p><h4 id="增加从子到父的引用"><a href="#增加从子到父的引用" class="headerlink" title="增加从子到父的引用"></a>增加从子到父的引用</h4><p>为了使子节点知道其父节点，需要在 Node 结构体定义中增加一个 parent 字段。问题是 parent 的类型应该是什么。我们知道其不能包含 Rc<T>，因为这样 leaf.parent 将会指向 branch 而 branch.children 会包含 leaf 的指针，这会形成引用循环，会造成其 strong_count 永远也不会为 0。</p><p>现在换一种方式思考这个关系:</p><ul><li>父节点应该拥有其子节点：</li><li>如果父节点被丢弃了，其子节点也应该被丢弃。</li><li>然而子节点不应该拥有其父节点：</li><li>如果丢弃子节点，其父节点应该依然存在。</li></ul><p>这正是弱引用的例子！</p><p>所以 parent 使用 Weak<T> 类型而不是 Rc<T>，具体来说是 RefCell<Weak<Node>&gt;。现在 Node 结构体定义看起来像这样：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">use std::cell::RefCell;</span><br><span class="line">use std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line">#[derive(Debug)]</span><br><span class="line">struct Node &#123;</span><br><span class="line">    value: i32,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let leaf = Rc::new(Node &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(vec![]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;leaf parent = &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    let branch = Rc::new(Node &#123;</span><br><span class="line">        value: 5,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    println!(&quot;leaf parent = &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 leaf 节点类似于示例 15-27 中如何创建 leaf 节点的，除了 parent 字段有所不同：leaf 开始时没有父节点，所以我们新建了一个空的 Weak 引用实例。</p><p>此时，当尝试使用 upgrade 方法获取 leaf 的父节点引用时，会得到一个 None 值。如第一个 println! 输出所示：</p><p>leaf parent = None</p><p>当创建 branch 节点时，其也会新建一个 Weak<Node> 引用，因为 branch 并没有父节点。leaf 仍然作为 branch 的一个子节点。一旦在 branch 中有了 Node 实例，就可以修改 leaf 使其拥有指向父节点的 Weak<Node> 引用。这里使用了 leaf 中 parent 字段里的 RefCell<Weak<Node>&gt; 的 borrow_mut 方法，接着使用了 Rc::downgrade 函数来从 branch 中的 Rc<Node> 值创建了一个指向 branch 的 Weak<Node> 引用。</p><p>当再次打印出 leaf 的父节点时，这一次将会得到存放了 branch 的 Some 值：现在 leaf 可以访问其父节点了！当打印出 leaf 时，我们也避免了如示例 15-26 中最终会导致栈溢出的循环：Weak<Node> 引用被打印为 (Weak)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;,</span><br><span class="line">children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;,</span><br><span class="line">children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span><br></pre></td></tr></table></figure><p>没有无限的输出表明这段代码并没有造成引用循环。这一点也可以从观察 Rc::strong_count 和 Rc::weak_count 调用的结果看出。</p><p><strong>可视化strong_count和weak_count的改变</strong>让我们通过创建了一个新的内部作用域并将 branch 的创建放入其中，来观察 Rc<Node> 实例的 strong_count 和 weak_count 值的变化。这会展示当 branch 创建和离开作用域被丢弃时会发生什么。这些修改如示例 15-29 所示：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let leaf = Rc::new(Node &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(vec![]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println!(</span><br><span class="line">        &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;,</span><br><span class="line">        Rc::strong_count(&amp;leaf),</span><br><span class="line">        Rc::weak_count(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let branch = Rc::new(Node &#123;</span><br><span class="line">            value: 5,</span><br><span class="line">            parent: RefCell::new(Weak::new()),</span><br><span class="line">            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">        println!(</span><br><span class="line">            &quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;,</span><br><span class="line">            Rc::strong_count(&amp;branch),</span><br><span class="line">            Rc::weak_count(&amp;branch),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        println!(</span><br><span class="line">            &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;,</span><br><span class="line">            Rc::strong_count(&amp;leaf),</span><br><span class="line">            Rc::weak_count(&amp;leaf),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;leaf parent = &#123;:?&#125;&quot;, leaf.parent.borrow().upgrade());</span><br><span class="line">    println!(</span><br><span class="line">        &quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;,</span><br><span class="line">        Rc::strong_count(&amp;leaf),</span><br><span class="line">        Rc::weak_count(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 15-29：在内部作用域创建 branch 并检查其强弱引用计数</p><p>一旦创建了 leaf，其 Rc<Node> 的强引用计数为 1，弱引用计数为 0。在内部作用域中创建了 branch 并与 leaf 相关联，此时 branch 中 Rc<Node> 的强引用计数为 1，弱引用计数为 1（因为 leaf.parent 通过 Weak<Node> 指向 branch）。这里 leaf 的强引用计数为 2，因为现在 branch 的 branch.children 中储存了 leaf 的 Rc<Node> 的拷贝，不过弱引用计数仍然为 0。</p><p>当内部作用域结束时，branch 离开作用域，Rc<Node> 的强引用计数减少为 0，所以其 Node 被丢弃。来自 leaf.parent 的弱引用计数 1 与 Node 是否被丢弃无关，所以并没有产生任何内存泄漏！</p><p>如果在内部作用域结束后尝试访问 leaf 的父节点，会再次得到 None。在程序的结尾，leaf 中 Rc<Node> 的强引用计数为 1，弱引用计数为 0，因为现在 leaf 又是 Rc<Node> 唯一的引用了。</p><p>所有这些管理计数和值的逻辑都内建于 Rc<T> 和 Weak<T> 以及它们的 Drop trait 实现中。通过在 Node 定义中指定从子节点到父节点的关系为一个Weak<T>引用，就能够拥有父节点和子节点之间的双向引用而不会造成引用循环和内存泄漏。</p><h1 id="无畏并发"><a href="#无畏并发" class="headerlink" title="无畏并发"></a>无畏并发</h1><ul><li><strong>并发编程</strong>（<em>Concurrent programming</em>），代表程序的不同部分相互独立的执行，</li><li><strong>并行编程</strong>（<em>parallel programming</em>）代表程序不同部分于同时执行</li></ul><h2 id="使用线程同时运行代码"><a href="#使用线程同时运行代码" class="headerlink" title="使用线程同时运行代码"></a>使用线程同时运行代码</h2><p>在大部分现代操作系统中，已执行程序的代码在一个 <strong>进程</strong>（<em>process</em>）中运行，操作系统则负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。运行这些独立部分的功能被称为 <strong>线程</strong>（<em>threads</em>）。</p><p>将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p><ul><li>竞态条件（Race conditions），多个线程以不一致的顺序访问数据或资源</li><li>死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行</li><li>只会发生在特定情况且难以稳定重现和修复的 bug</li></ul><p>编程语言有一些不同的方法来实现线程。</p><ul><li>很多操作系统提供了创建新线程的 API。这种由编程语言调用操作系统 API 创建线程的模型有时被称为 <em>1:1</em>，一个 OS 线程对应一个语言线程。<strong>Rust 标准库只提供了 1:1 线程实现</strong>；需要较小的运行时</li><li>有一些 crate 实现了其他有着不同取舍的线程模型，即语言自己实现的线程（绿色线程）：M:N模型。需要较大的运行时</li></ul><h2 id="通过spawn创建新线程"><a href="#通过spawn创建新线程" class="headerlink" title="通过spawn创建新线程"></a>通过spawn创建新线程</h2><p>为了创建一个新线程，需要调用 thread::spawn 函数并传递一个闭包，并在其中包含希望在新线程运行的代码</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        for i in 1..10 &#123;</span><br><span class="line">            println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for i in 1..5 &#123;</span><br><span class="line">        println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主线程结束时，新线程也会结束，而不管其是否执行完毕。</p><h2 id="通过join-Handle来等待所有线程的完成"><a href="#通过join-Handle来等待所有线程的完成" class="headerlink" title="通过join Handle来等待所有线程的完成"></a>通过join Handle来等待所有线程的完成</h2><ul><li>thread::spawn 的返回值类型是 JoinHandle。</li><li>JoinHandle 是一个拥有所有权的值</li><li>当对其调用 join 方法时，会阻止当前运行线程的执行，直到handle所表示的这些线程的终结。</li></ul><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let handle = thread::spawn(|| &#123;</span><br><span class="line">        for i in 1..10 &#123;</span><br><span class="line">            println!(&quot;hi number &#123;&#125; from the spawned thread!&quot;, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for i in 1..5 &#123;</span><br><span class="line">        println!(&quot;hi number &#123;&#125; from the main thread!&quot;, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束。<strong>阻塞</strong>（<em>Blocking</em>） 线程意味着阻止该线程执行工作或退出。因为我们将 join 调用放在了主线程的 for 循环之后，</p><h2 id="使用move闭包"><a href="#使用move闭包" class="headerlink" title="使用move闭包"></a>使用move闭包</h2><ul><li>move闭包通常和thread::spawn函数一起使用，它允许你使用其他线程的数据</li><li>创建线程时，把值得所有权从一个线程转移到另一个线程</li></ul><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let handle = thread::spawn(|| &#123;</span><br><span class="line">        println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-3: 尝试在另一个线程使用主线程创建的 vector</p><p>闭包使用了 v，所以闭包会捕获 v 并使其成为闭包环境的一部分。因为 thread::spawn 在一个新线程中运行这个闭包，所以可以在新线程中访问 v。然而当编译这个例子时，会得到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling threads v0.1.0 (file:///projects/threads)</span><br><span class="line">error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</span><br><span class="line"> --&gt; src/main.rs:6:32</span><br><span class="line">  |</span><br><span class="line">6 |     let handle = thread::spawn(|| &#123;</span><br><span class="line">  |                                ^^ may outlive borrowed value `v`</span><br><span class="line">7 |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">  |                                           - `v` is borrowed here</span><br><span class="line">  |</span><br><span class="line">note: function requires argument type to outlive `&#x27;static`</span><br><span class="line"> --&gt; src/main.rs:6:18</span><br><span class="line">  |</span><br><span class="line">6 |       let handle = thread::spawn(|| &#123;</span><br><span class="line">  |  __________________^</span><br><span class="line">7 | |         println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">8 | |     &#125;);</span><br><span class="line">  | |______^</span><br><span class="line">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword</span><br><span class="line">  |</span><br><span class="line">6 |     let handle = thread::spawn(move || &#123;</span><br><span class="line">  |                                ++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0373`.</span><br><span class="line">error: could not compile `threads` due to previous error</span><br></pre></td></tr></table></figure><p>Rust 会 <strong>推断</strong> 如何捕获 v，因为 println! 只需要 v 的引用，闭包尝试借用 v。然而这有一个问题：Rust 不知道这个新建线程会执行多久，所以无法知晓 v 的引用是否一直有效。</p><p>示例 16-4 展示了一个 v 的引用很有可能不再有效的场景：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let handle = thread::spawn(|| &#123;</span><br><span class="line">        println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    drop(v); // oh no!</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在闭包之前增加 move 关键字，我们强制闭包获取其使用的值的所有权，而不是任由 Rust 推断它应该借用值。示例 16-5 中展示的对示例 16-3 代码的修改，可以按照我们的预期编译并运行：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    let handle = thread::spawn(move || &#123;</span><br><span class="line">        println!(&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-5: 使用 move 关键字强制获取它使用的值的所有权</p><h2 id="使用消息传递来跨线程传递数据"><a href="#使用消息传递来跨线程传递数据" class="headerlink" title="使用消息传递来跨线程传递数据"></a>使用消息传递来跨线程传递数据</h2><p>一个日益流行的确保安全并发的方式是 <strong>消息传递</strong>（<em>message passing</em>），这里线程或 actor 通过发送包含数据的消息来相互沟通。这个思想来源于 [Go 编程语言文档中]的口号：“不要通过共享内存来通讯；而是通过通讯来共享内存。”（“Do not communicate by sharing memory; instead, share memory by communicating.”）</p><ul><li>线程（或Actor）通过彼此发送消息（数据）来进行通信</li><li>Rust: Channel(标准库提供)</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul><li>Channel包含：发送端，接收端</li><li>调用发送端的方法，发送数据</li><li>接收端会检查和接收到达的数据</li><li>如果发送端，接收端中任意一端被丢弃了，那么Channel就被“关闭”了</li></ul><h3 id="创建Channel"><a href="#创建Channel" class="headerlink" title="创建Channel"></a>创建Channel</h3><ul><li>使用<strong>mpsc::channel</strong> 函数来创建Channel</li></ul><ol><li>mpsc表示multiple producer,single consumer(多个生产者，一个消费者)</li><li>返回一个tuple(元组):里面元素分别是发送端，接收端</li></ol><p>让我们将发送端移动到一个新建线程中并发送一个字符串，这样新建线程就可以和主线程通讯了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let val = String::from(&quot;hi&quot;);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">    let received = rx.recv().unwrap();</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-7: 将 tx 移动到一个新建的线程中并发送 “hi”</p><p>这里再次使用 thread::spawn 来创建一个新线程并使用 move 将 tx 移动到闭包中这样新建线程就拥有 tx 了。新建线程需要拥有信道的发送端以便能向信道发送消息。</p><p>信道的发送端有一个 send 方法用来获取需要放入信道的值。send 方法返回一个 Result<T, E> 类型，所以<strong>如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误</strong>。在这个例子中，出错的时候调用 unwrap 产生 panic。不过对于一个真实程序，需要合理地处理它</p><p><strong>接收端的recv方法</strong></p><ul><li>信道的接收端有两个有用的方法：recv 和 try_recv。</li><li>这里，我们使用了 recv，它是 <em>receive</em> 的缩写。这个方法会<strong>阻塞主线程执行直到从信道中接收一个值</strong>。一旦发送了一个值，recv 会在一个 Result<T, E> 中返回它。当信道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了。</li><li>try_recv 不会阻塞，相反它立刻返回一个 Result<T, E>：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用 try_recv 很有用：可以编写一个循环来频繁调用 try_recv，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。</li></ul><h3 id="信道与所有权转移"><a href="#信道与所有权转移" class="headerlink" title="信道与所有权转移"></a>信道与所有权转移</h3><p>现在让我们做一个试验来看看信道与所有权如何一同协作以避免产生问题：我们将尝试在新建线程中的信道中发送完 val 值 <strong>之后</strong> 再使用它。尝试编译示例 16-9 中的代码并看看为何这是不允许的：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let val = String::from(&quot;hi&quot;);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        println!(&quot;val is &#123;&#125;&quot;, val);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    let received = rx.recv().unwrap();</span><br><span class="line">    println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-9: 在我们已经发送到信道中后，尝试使用 val 引用</p><p>这里尝试在通过 tx.send 发送 val 到信道中之后将其打印出来。允许这么做是一个坏主意：</p><p><strong>一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前就将其修改或者丢弃。其他线程对值可能的修改会由于不一致或不存在的数据而导致错误或意外的结果</strong>。</p><p>然而，尝试编译示例 16-9 的代码时，Rust 会给出一个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling message-passing v0.1.0 (file:///projects/message-passing)</span><br><span class="line">error[E0382]: borrow of moved value: `val`</span><br><span class="line">  --&gt; src/main.rs:10:31</span><br><span class="line">   |</span><br><span class="line">8  |         let val = String::from(&quot;hi&quot;);</span><br><span class="line">   |             --- move occurs because `val` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">9  |         tx.send(val).unwrap();</span><br><span class="line">   |                 --- value moved here</span><br><span class="line">10 |         println!(&quot;val is &#123;&#125;&quot;, val);</span><br><span class="line">   |                               ^^^ value borrowed here after move</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `message-passing` due to previous error</span><br></pre></td></tr></table></figure><p>我们的并发错误会造成一个编译时错误。send 函数获取其参数的所有权并移动这个值归接收者所有。这可以防止在发送后再次意外地使用这个值；所有权系统检查一切是否合乎规则。</p><h3 id="发送多个值并观察接收者的等待"><a href="#发送多个值并观察接收者的等待" class="headerlink" title="发送多个值并观察接收者的等待"></a>发送多个值并观察接收者的等待</h3><p>示例 16-8 中的代码可以编译和运行，不过它并没有明确的告诉我们两个独立的线程通过信道相互通讯。</p><p>示例 16-10 则有一些改进会证明示例 16-8 中的代码是并发执行的</p><p>新建线程现在会发送多个消息并在每个消息之间暂停一秒钟。</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::mpsc;</span><br><span class="line">use std::thread;</span><br><span class="line">use std::time::Duration;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;hi&quot;),</span><br><span class="line">            String::from(&quot;from&quot;),</span><br><span class="line">            String::from(&quot;the&quot;),</span><br><span class="line">            String::from(&quot;thread&quot;),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for received in rx &#123;</span><br><span class="line">        println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-10: 发送多个消息，并在每次发送后暂停一段时间</p><p>这一次，在新建线程中有一个字符串 vector 希望发送到主线程。我们遍历他们，单独的发送每一个字符串并通过一个 Duration 值调用 thread::sleep 函数来暂停一秒。</p><p>在主线程中，不再显式调用 recv 函数：而是将 rx 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当信道被关闭时，迭代器也将结束。</p><p>当运行示例 16-10 中的代码时，将看到如下输出，每一行都会暂停一秒：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br><span class="line">Got: from</span><br><span class="line">Got: the</span><br><span class="line">Got: thread</span><br></pre></td></tr></table></figure><p>因为主线程中的 for 循环里并没有任何暂停或等待的代码，所以可以说主线程是在等待从新建线程中接收值。</p><h3 id="通过克隆发送者来创建多个生产者"><a href="#通过克隆发送者来创建多个生产者" class="headerlink" title="通过克隆发送者来创建多个生产者"></a>通过克隆发送者来创建多个生产者</h3><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// --snip--</span><br><span class="line"></span><br><span class="line">    let (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    let tx1 = tx.clone();</span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;hi&quot;),</span><br><span class="line">            String::from(&quot;from&quot;),</span><br><span class="line">            String::from(&quot;the&quot;),</span><br><span class="line">            String::from(&quot;thread&quot;),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx1.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::spawn(move || &#123;</span><br><span class="line">        let vals = vec![</span><br><span class="line">            String::from(&quot;more&quot;),</span><br><span class="line">            String::from(&quot;messages&quot;),</span><br><span class="line">            String::from(&quot;for&quot;),</span><br><span class="line">            String::from(&quot;you&quot;),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        for val in vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    for received in rx &#123;</span><br><span class="line">        println!(&quot;Got: &#123;&#125;&quot;, received);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // --snip--</span><br></pre></td></tr></table></figure><p>示例 16-11: 从多个生产者发送多个消息</p><p>这一次，在创建新线程之前，我们对信道的发送端调用了 clone 方法。这会给我们一个<strong>可以传递给第一个新建线程的发送端句柄</strong>。我们会将原始的信道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向信道的接收端发送不同的消息。</p><p>如果运行这些代码，你 <strong>可能</strong> 会看到这样的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br><span class="line">Got: more</span><br><span class="line">Got: from</span><br><span class="line">Got: messages</span><br><span class="line">Got: for</span><br><span class="line">Got: the</span><br><span class="line">Got: thread</span><br><span class="line">Got: you</span><br></pre></td></tr></table></figure><p>虽然你可能会看到这些值以不同的顺序出现；这依赖于你的系统。这也就是并发既有趣又困难的原因。如果通过 thread::sleep 做实验，在不同的线程中提供不同的值，就会发现他们的运行更加不确定，且每次都会产生不同的输出。</p><h2 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h2><ul><li>在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。</li><li>共享内存类似于多所有权：多个线程可以同时访问相同的内存位置</li></ul><h3 id="互斥器一次只允许一个线程访问数据"><a href="#互斥器一次只允许一个线程访问数据" class="headerlink" title="互斥器一次只允许一个线程访问数据"></a>互斥器一次只允许一个线程访问数据</h3><p><strong>互斥器</strong>（<em>mutex</em>）是 <em>mutual exclusion</em> 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 <strong>锁</strong>（<em>lock</em>）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 <strong>保护</strong>（<em>guarding</em>）其数据。</p><p>互斥器以难以使用著称，因为你不得不记住：</p><ol><li>在使用数据之前尝试获取锁。</li><li>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。</li></ol><p>在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。</p><h3 id="Mutex的-API"><a href="#Mutex的-API" class="headerlink" title="Mutex的 API"></a>Mutex的 API</h3><p>作为展示如何使用互斥器的例子，让我们从在单线程上下文使用互斥器开始，如示例 16-12 所示：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::Mutex;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let m = Mutex::new(5);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let mut num = m.lock().unwrap();</span><br><span class="line">        *num = 6;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;m = &#123;:?&#125;&quot;, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-12: 出于简单的考虑，在一个单线程上下文中探索 Mutex<T> 的 API</p><p>像很多类型一样，我们使用关联函数 new 来创建一个 Mutex<T>。使用 lock 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。</p><p>一旦获取了锁，就可以将返回值（在这里是num）<strong>视为一个其内部数据的可变引用</strong>了。类型系统确保了我们在使用 m 中的值之前获取锁：Mutex<i32> 并不是一个 i32，所以 <strong>必须</strong> 获取锁才能使用这个 i32 值。我们是不会忘记这么做的，因为反之类型系统不允许访问内部的 i32 值。</p><p>Mutex<T> 是一个智能指针。更准确的说，lock 调用 <strong>返回</strong> 一个叫做 MutexGuard 的智能指针。这个智能指针实现了 Deref 来指向其内部数据；其也提供了一个 Drop 实现当 MutexGuard 离开作用域时自动释放锁，这正发生于示例 16-12 内部作用域的结尾。为此，我们不会忘记释放锁并阻塞互斥器为其它线程所用的风险，因为<strong>锁的释放是自动发生的</strong>。</p><h3 id="在线程间共享-Mutex"><a href="#在线程间共享-Mutex" class="headerlink" title="在线程间共享 Mutex"></a>在线程间共享 Mutex</h3><p>现在让我们尝试使用 Mutex<T> 在多个线程间共享值。我们将启动十个线程，并在各个线程中对同一个计数器值加一，这样计数器将从 0 变为 10。示例 16-13 中的例子会出现编译错误，而我们将通过这些错误来学习如何使用 Mutex<T>，以及 Rust 又是如何帮助我们正确使用的。</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::Mutex;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let counter = Mutex::new(0);</span><br><span class="line">    let mut handles = vec![];</span><br><span class="line"></span><br><span class="line">    for _ in 0..10 &#123;</span><br><span class="line">        let handle = thread::spawn(move || &#123;</span><br><span class="line">            let mut num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-13: 程序启动了 10 个线程，每个线程都通过 Mutex<T> 来增加计数器的值</p><p>这里创建了一个 counter 变量来存放内含 i32 的 Mutex<T>，类似示例 16-12 那样。接下来遍历 range 创建了 10 个线程。使用了 thread::spawn 并对所有线程使用了相同的闭包：他们每一个都将调用 lock 方法来获取 Mutex<T> 上的锁，接着将互斥器中的值加一。当一个线程结束执行，num 会离开闭包作用域并释放锁，这样另一个线程就可以获取它了。</p><p>在主线程中，我们像示例 16-2 那样收集了所有的 join 句柄，调用它们的 join 方法来确保所有线程都会结束。这时，主线程会获取锁并打印出程序的结果。</p><p>编译失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.1.0 (file:///projects/shared-state)</span><br><span class="line">error[E0382]: use of moved value: `counter`</span><br><span class="line">  --&gt; src/main.rs:9:36</span><br><span class="line">   |</span><br><span class="line">5  |     let counter = Mutex::new(0);</span><br><span class="line">   |         ------- move occurs because `counter` has type `Mutex&lt;i32&gt;`, which does not implement the `Copy` trait</span><br><span class="line">...</span><br><span class="line">9  |         let handle = thread::spawn(move || &#123;</span><br><span class="line">   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop</span><br><span class="line">10 |             let mut num = counter.lock().unwrap();</span><br><span class="line">   |                           ------- use occurs due to use in closure</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `shared-state` due to previous error</span><br></pre></td></tr></table></figure><p>错误信息表明 counter 值在上一次循环中被移动了。所以 Rust 告诉我们<strong>不能将</strong> <strong>counter</strong> <strong>锁的所有权移动到多个线程中</strong>。</p><h3 id="多线程和多所有权"><a href="#多线程和多所有权" class="headerlink" title="多线程和多所有权"></a>多线程和多所有权</h3><p>通过使用智能指针 Rc<T> 来创建引用计数的值，可以拥有多所有者。</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">use std::rc::Rc;</span><br><span class="line">use std::sync::Mutex;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let counter = Rc::new(Mutex::new(0));</span><br><span class="line">    let mut handles = vec![];</span><br><span class="line"></span><br><span class="line">    for _ in 0..10 &#123;</span><br><span class="line">        let counter = Rc::clone(&amp;counter);</span><br><span class="line">        let handle = thread::spawn(move || &#123;</span><br><span class="line">            let mut num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-14: 尝试使用 Rc<T> 来允许多个线程拥有 Mutex<T></p><p>再一次编译并…出现了不同的错误！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.1.0 (file:///projects/shared-state)</span><br><span class="line">error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">   --&gt; src/main.rs:11:22</span><br><span class="line">    |</span><br><span class="line">11  |           let handle = thread::spawn(move || &#123;</span><br><span class="line">    |  ______________________^^^^^^^^^^^^^_-</span><br><span class="line">    | |                      |</span><br><span class="line">    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">12  | |             let mut num = counter.lock().unwrap();</span><br><span class="line">13  | |</span><br><span class="line">14  | |             *num += 1;</span><br><span class="line">15  | |         &#125;);</span><br><span class="line">    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">    |</span><br><span class="line">    = help: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`</span><br><span class="line">    = note: required because it appears within the type `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">note: required by a bound in `spawn`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `shared-state` due to previous error</span><br></pre></td></tr></table></figure><p>第一行错误表明 Rc<Mutex<i32>&gt;<code>cannot be sent between threads safely</code>。编译器也告诉了我们原因 <code>the trait</code>Send<code>is not implemented for</code>Rc<Mutex<i32>&gt;。下一部分会讲到 Send：这是确保所使用的类型可以用于并发环境的 trait 之一。</p><p>不幸的是，<strong>Rc<T></strong> <strong>并不能安全的在线程间共享</strong>。当 Rc<T> 管理引用计数时，它必须在每一个 clone 调用时增加计数，并在每一个克隆被丢弃时减少计数。<strong>Rc<T></strong> <strong>并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断</strong>。在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个完全类似 Rc<T>，又以一种线程安全的方式改变引用计数的类型。</p><h3 id="原子引用计数Arc"><a href="#原子引用计数Arc" class="headerlink" title="原子引用计数Arc"></a>原子引用计数Arc<T></h3><p>Arc<T><strong>正是</strong> 这么一个类似 Rc<T> 并可以安全的用于并发环境的类型。字母 “a” 代表 <strong>原子性</strong>（<em>atomic</em>），所以这是一个 <strong>原子引用计数</strong>（<em>atomically reference counted</em>）类型.</p><p>为什么不是所有的原始类型都是原子性的？为什么不是所有标准库中的类型都默认使用 Arc<T> 实现？</p><p>原因在于线程安全带有性能惩罚，我们希望只在必要时才为此买单。如果只是在单线程中对值进行操作，原子性提供的保证并无必要，代码可以因此运行的更快。</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">use std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line">use std::thread;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let counter = Arc::new(Mutex::new(0));</span><br><span class="line">    let mut handles = vec![];</span><br><span class="line"></span><br><span class="line">    for _ in 0..10 &#123;</span><br><span class="line">        let counter = Arc::clone(&amp;counter);</span><br><span class="line">        let handle = thread::spawn(move || &#123;</span><br><span class="line">            let mut num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += 1;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for handle in handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(&quot;Result: &#123;&#125;&quot;, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 16-15: 使用 Arc<T> 包装一个 Mutex<T> 能够实现在多线程之间共享所有权</p><p>这会打印出：</p><p>Result: 10</p><h3 id="RefCell-Rc-与-Mutex-Arc-的相似性"><a href="#RefCell-Rc-与-Mutex-Arc-的相似性" class="headerlink" title="RefCell/Rc 与 Mutex/Arc 的相似性"></a>RefCell/Rc 与 Mutex/Arc 的相似性</h3><ul><li>因为 counter 是不可变的，不过可以获取其内部值的可变引用；这意味着 Mutex<T> 提供了内部可变性，就像 Cell 系列类型那样。正如使用 RefCell<T> 可以改变 Rc<T> 中的内容那样，同样的可以使用 Mutex<T> 来改变 Arc<T> 中的内容。</li><li>Rust 不能避免使用 Mutex<T> 的全部逻辑错误。回忆一下使用 Rc<T> 就有造成引用循环的风险，这时两个 Rc<T> 值相互引用，造成内存泄漏。同理，Mutex<T> 也有造成 <strong>死锁</strong>（<em>deadlock</em>） 的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。</li></ul><h2 id="使用Sync和Send-trait的可扩展并发"><a href="#使用Sync和Send-trait的可扩展并发" class="headerlink" title="使用Sync和Send trait的可扩展并发"></a>使用Sync和Send trait的可扩展并发</h2><p>Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 <strong>甚少</strong>。我们之前讨论的几乎所有内容，都属于标准库，而不是语言本身的内容。由于不需要语言提供并发相关的基础设施，并发方案不受标准库或语言所限：我们可以编写自己的或使用别人编写的并发功能。</p><p>然而有两个并发概念是<strong>内嵌于语言中</strong>的：std::marker 中的 Sync 和 Send trait。</p><h3 id="通过Send允许在线程间转移所有权"><a href="#通过Send允许在线程间转移所有权" class="headerlink" title="通过Send允许在线程间转移所有权"></a>通过Send允许在线程间转移所有权</h3><ul><li>Send 标记 trait 表明实现了 Send 的类型值的所有权可以在线程间传送。</li><li>几乎所有的 Rust 类型都是Send 的，</li><li>不过有一些例外，包括 Rc<T>：这是不能 Send 的，</li></ul><p>因为如果克隆了 Rc<T> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。为此，Rc<T> 被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价。</p><ul><li>Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 Rc<T> 在线程间发送。当尝试在示例 16-14 中这么做的时候，会得到错误 the trait Send is not implemented for Rc<Mutex<i32>&gt;。而使用标记为 Send 的 Arc<T> 时，就没有问题了。</li><li>任何完全由 Send 的类型组成的类型也会自动被标记为 Send。几乎所有基本类型都是 Send 的，除了裸指针（raw pointer）。</li></ul><h3 id="Sync允许多线程访问"><a href="#Sync允许多线程访问" class="headerlink" title="Sync允许多线程访问"></a>Sync允许多线程访问</h3><ul><li>Sync 标记 trait 表明一个实现了 Sync 的类型可以<strong>安全的在多个线程中拥有其值的引用</strong>。</li><li>换一种方式来说，对于任意类型 T，如果 &amp;T（T 的不可变引用）是 Send 的话 T 就是 Sync 的，这意味着其引用就可以安全的发送到另一个线程。</li><li>类似于 Send 的情况，基本类型是 Sync 的，完全由 Sync 的类型组成的类型也是 Sync 的。</li><li>智能指针 Rc<T> 也不是 Sync 的，出于其不是 Send 相同的原因。RefCell<T>和 Cell<T> 系列类型不是 Sync 的。RefCell<T> 在运行时所进行的借用检查也不是线程安全的。</li><li>Mutex<T> 是 Sync 的，正如 “在线程间共享 Mutex”部分所讲的它可以被用来在多线程中共享访问。</li></ul><h3 id="手动实现Send和Sync是不安全的"><a href="#手动实现Send和Sync是不安全的" class="headerlink" title="手动实现Send和Sync是不安全的"></a>手动实现Send和Sync是不安全的</h3><ul><li>通常并不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync 的。</li><li>因为他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。</li><li>手动实现这些标记 trait 涉及到编写不安全的 Rust 代码，</li></ul><p>当前重要的是，在创建新的由不是 Send 和 Sync 的部分构成的并发类型时需要多加小心，以确保维持其安全保证。<a href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a> 中有更多关于这些保证以及如何维持他们的信息。</p><h1 id="Rust的面向对象特性"><a href="#Rust的面向对象特性" class="headerlink" title="Rust的面向对象特性"></a>Rust的面向对象特性</h1><h2 id="面向对象语言的特点"><a href="#面向对象语言的特点" class="headerlink" title="面向对象语言的特点"></a>面向对象语言的特点</h2><ul><li><strong>对象包含数据和行为</strong></li></ul><p>在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。虽然带有方法的结构体和枚举并不被 <strong>称为</strong> 对象，但是他们提供了与对象相同的功能，</p><ul><li><strong>封装隐藏了实现细节</strong></li></ul><p><strong>封装</strong>（<em>encapsulation</em>）的思想：对象的实现细节不能被使用对象的代码获取到。所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。</p><p>Rust中可以使用 pub 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的。</p><p>举例：</p><p>比如，我们可以定义一个包含一个 i32 类型 vector 的结构体 AveragedCollection。结构体也可以有一个字段，该字段保存了 vector 中所有值的平均值。这样，希望知道结构体中的 vector 的平均值的人可以随时获取它，而无需自己计算。换句话说，AveragedCollection 会为我们缓存平均值结果。示例 17-1 有 AveragedCollection 结构体的定义：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub struct AveragedCollection &#123;</span><br><span class="line">    list: Vec&lt;i32&gt;,</span><br><span class="line">    average: f64,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-1: AveragedCollection 结构体维护了一个整型列表和集合中所有元素的平均值。</p><p>注意，结构体自身被标记为 pub，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 add、remove 和 average 方法来做到这一点，如示例 17-2 所示：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">impl AveragedCollection &#123;</span><br><span class="line">    pub fn add(&amp;mut self, value: i32) &#123;</span><br><span class="line">        self.list.push(value);</span><br><span class="line">        self.update_average();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">        let result = self.list.pop();</span><br><span class="line">        match result &#123;</span><br><span class="line">            Some(value) =&gt; &#123;</span><br><span class="line">                self.update_average();</span><br><span class="line">                Some(value)</span><br><span class="line">            &#125;</span><br><span class="line">            None =&gt; None,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pub fn average(&amp;self) -&gt; f64 &#123;</span><br><span class="line">        self.average</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn update_average(&amp;mut self) &#123;</span><br><span class="line">        let total: i32 = self.list.iter().sum();</span><br><span class="line">        self.average = total as f64 / self.list.len() as f64;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-2: 在AveragedCollection 结构体上实现了add、remove 和 average 公有方法</p><p>公有方法 add、remove 和 average 是修改 AveragedCollection 实例的唯一方式。当使用 add 方法把一个元素加入到 list 或者使用 remove 方法来删除时，这些方法的实现同时会调用私有的 update_average 方法来更新 average 字段。</p><p>list 和 average 是私有的，所以没有其他方式来使得外部的代码直接向 list 增加或者删除元素，否则 list 改变时可能会导致 average 字段不同步。average 方法返回 average 字段的值，这使得外部的代码只能读取 average 而不能修改它。</p><p>因为我们已经封装好了 AveragedCollection 的实现细节，将来可以轻松改变类似数据结构这些方面的内容。例如，可以使用 HashSet<i32> 代替 Vec<i32> 作为 list 字段的类型。只要 add、remove 和 average 公有函数的签名保持不变，使用 AveragedCollection 的代码就无需改变。相反如果使得 list 为公有，就未必都会如此了： HashSet<i32> 和 Vec<i32> 使用不同的方法增加或移除项，所以如果要想直接修改 list 的话，外部的代码可能不得不做出修改。</p><p>如果封装是一个语言被认为是面向对象语言所必要的方面的话，那么 Rust 满足这个要求。在代码中不同的部分使用 pub 与否可以封装其实现细节。</p><ul><li><strong>继承，作为类型系统与代码共享</strong></li></ul><p><strong>继承</strong>（<em>Inheritance</em>）是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。</p><p><strong>如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的。**</strong>无法定义一个结构体继承父结构体的成员和方法**。然而，如果你过去常常在你的编程工具箱使用继承，根据你最初考虑继承的原因，Rust 也提供了其他的解决方案。</p><p>选择继承有两个主要的原因。</p><ol><li>第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现。相反 Rust 代码可以使用默认 trait 方法实现来进行共享，</li><li>第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 <strong>多态</strong>（<em>polymorphism</em>），这意味着如果多种对象共享特定的属性，则可以相互替代使用。</li></ol><p>近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。</p><h2 id="顾及不同类型值得trait对象"><a href="#顾及不同类型值得trait对象" class="headerlink" title="顾及不同类型值得trait对象"></a>顾及不同类型值得trait对象</h2><p>vector 只能存储同种类型元素的局限。示例 8-10 中提供了一个定义 SpreadsheetCell 枚举来储存整型，浮点型和文本成员的替代方案。这意味着可以在每个单元中储存不同类型的数据，并仍能拥有一个代表一排单元的 vector。这在当编译代码时就知道希望可以交替使用的类型为固定集合的情况下是完全可行的。</p><p><strong>然而有时我们希望库用户在特定情况下能够扩展有效的类型集合。</strong></p><p>为了展示如何实现这一点，这里将创建一个图形用户接口（Graphical User Interface， GUI）工具的例子，它通过遍历列表并调用每一个项目的 draw 方法来将其绘制到屏幕上 —— 此乃一个 GUI 工具的常见技术。我们将要创建一个叫做 gui 的库 crate，它含一个 GUI 库的结构。这个 GUI 库包含一些可供开发者使用的类型，比如 Button 或 TextField。在此之上，gui 的用户希望创建自定义的可以绘制于屏幕上的类型：比如，一个程序员可能会增加 Image，另一个可能会增加 SelectBox。</p><p>这个例子中并不会实现一个功能完善的 GUI 库，不过会展示其中各个部分是如何结合在一起的。编写库的时候，我们不可能知晓并定义所有其他程序员希望创建的类型。我们所知晓的是 gui 需要记录一系列不同类型的值，并需要能够对其中每一个值调用 draw 方法。这里无需知道调用 draw 方法时具体会发生什么，只要该值会有那个方法可供我们调用。</p><p>在拥有继承的语言中，可以定义一个名为 Component 的类，该类上有一个 draw 方法。其他的类比如 Button、Image 和 SelectBox 会从 Component 派生并因此继承 draw 方法。它们各自都可以覆盖 draw 方法来定义自己的行为，但是框架会把所有这些类型当作是 Component 的实例，并在其上调用 draw。</p><p>不过 Rust 并没有继承，我们得另寻出路。</p><h2 id="定义通用行为的trait"><a href="#定义通用行为的trait" class="headerlink" title="定义通用行为的trait"></a>定义通用行为的trait</h2><p>为了实现 gui 所期望的行为，让我们定义一个 Draw trait，其中包含名为 draw 的方法。接着可以定义一个存放 <strong>trait 对象</strong>（<strong><em>trait object\</em></strong>） 的 vector。trait 对象指向一个实现了我们指定 trait 的类型的实例，以及一个用于在运行时查找该类型的trait方法的表。我们通过指定某种指针来创建 trait 对象，例如 &amp; 引用或 Box<T> 智能指针，还有 dyn keyword， 以及指定相关的 trait（ [“动态大小类型和 Sized trait”] 部分会介绍 trait 对象必须使用指针的原因）。我们可以使用 trait 对象代替泛型或具体类型。任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。如此便无需在编译时就知晓所有可能的类型。</p><p>Rust 刻意不将结构体与枚举称为 “对象”，以便与其他语言中的对象相区别。在结构体或枚举中，结构体字段中的数据和 impl 块中的行为是分开的，不同于其他语言中将数据和行为组合进一个称为对象的概念中。</p><p>trait 对象将数据和行为两者相结合，从这种意义上说 <strong>则</strong> 其更类似其他语言中的对象。不过 trait 对象不同于传统的对象，因为不能向 trait 对象增加数据。trait 对象并不像其他语言中的对象那么通用：其（trait 对象）具体的作用是允许对通用行为进行抽象。</p><p>示例 17-3 展示了如何定义一个带有 draw 方法的 trait Draw：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub trait Draw &#123;</span><br><span class="line">    fn draw(&amp;self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-3：Draw trait 的定义</p><p>示例 17-4 定义了一个存放了名叫 components 的 vector 的结构体 Screen。这个 vector 的类型是 Box<dyn Draw>，此为一个 trait 对象：它是 Box 中任何实现了 Draw trait 的类型的替身。</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub struct Screen &#123;</span><br><span class="line">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-4: 一个 Screen 结构体的定义，它带有一个字段 components，其包含实现了 Draw trait 的 trait 对象的 vector</p><p>在 Screen 结构体上，我们将定义一个 run 方法，该方法会对其 components 上的每一个组件调用 draw 方法，如示例 17-5 所示：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">impl Screen &#123;</span><br><span class="line">    pub fn run(&amp;self) &#123;</span><br><span class="line">        for component in self.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-5：在 Screen 上实现一个 run 方法，该方法在每个 component 上调用 draw 方法</p><p>这与定义使用了带有 trait bound 的泛型类型参数的结构体不同。<strong>泛型类型参数一次只能替代一个具体类型</strong>，而 <strong>trait 对象则允许在运行时替代多种具体类型</strong>。例如，可以定义 Screen 结构体来使用泛型和 trait bound，如示例 17-6 所示：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pub trait Draw &#123;</span><br><span class="line">    fn draw(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line">pub struct Screen&lt;T: Draw&gt; &#123;</span><br><span class="line">    pub components: Vec&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line">where</span><br><span class="line">    T: Draw,</span><br><span class="line">&#123;</span><br><span class="line">    pub fn run(&amp;self) &#123;</span><br><span class="line">        for component in self.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-6: 一种 Screen 结构体的替代实现，其 run 方法使用泛型和 trait bound</p><p>这<strong>限制了</strong>Screen 实例必须拥有一个全是 Button 类型或者全是 TextField 类型的组件列表。如果只需要<strong>同质（相同类型）集合</strong>，则倾向于使用泛型和 trait bound，因为其定义会在编译时采用具体类型进行单态化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pub trait Draw &#123;</span><br><span class="line">    fn draw(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line">pub struct Screen &#123;</span><br><span class="line">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line">impl Screen &#123;</span><br><span class="line">    pub fn run(&amp;self) &#123;</span><br><span class="line">        for component in self.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一方面，通过使用 trait 对象的方法，一个 Screen 实例可以存放一个既能包含 Box<Button>，也能包含 Box<TextField> 的 Vec<T>。</p><p><strong>实现trait</strong></p><p>现在来增加一些实现了 Draw trait 的类型。我们将提供 Button 类型。再一次重申，真正实现 GUI 库超出了范畴，所以 draw 方法体中不会有任何有意义的实现。为了想象一下这个实现看起来像什么，一个 Button 结构体可能会拥有 width、height 和 label 字段，如示例 17-7 所示：</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pub struct Button &#123;</span><br><span class="line">    pub width: u32,</span><br><span class="line">    pub height: u32,</span><br><span class="line">    pub label: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Draw for Button &#123;</span><br><span class="line">    fn draw(&amp;self) &#123;</span><br><span class="line">        // code to actually draw a button</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-7: 一个实现了 Draw trait 的 Button 结构体</p><p>在 Button 上的 width、height 和 label 字段会和其他组件不同，比如 TextField 可能有 width、height、label 以及 placeholder 字段。每一个我们希望能在屏幕上绘制的类型都会使用不同的代码来实现 Draw trait 的 draw 方法来定义如何绘制特定的类型，像这里的 Button 类型（并不包含任何实际的 GUI 代码，这超出了本章的范畴）。除了实现 Draw trait 之外，比如 Button 还可能有另一个包含按钮点击如何响应的方法的 impl 块。这类方法并不适用于像 TextField 这样的类型。</p><p>如果一些库的使用者决定实现一个包含 width、height 和 options 字段的结构体 SelectBox，并且也为其实现了 Draw trait，如示例 17-8 所示：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use gui::Draw;</span><br><span class="line"></span><br><span class="line">struct SelectBox &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">    options: Vec&lt;String&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Draw for SelectBox &#123;</span><br><span class="line">    fn draw(&amp;self) &#123;</span><br><span class="line">        // code to actually draw a select box</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-8: 另一个使用 gui 的 crate 中，在 SelectBox 结构体上实现 Draw trait</p><p>库使用者现在可以在他们的 main 函数中创建一个 Screen 实例。至此可以通过将 SelectBox 和 Button 放入 Box<T> 转变为 trait 对象来增加组件。接着可以调用 Screen 的 run 方法，它会调用每个组件的 draw 方法。示例 17-9 展示了这个实现：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">use gui::&#123;Button, Screen&#125;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let screen = Screen &#123;</span><br><span class="line">        components: vec![</span><br><span class="line">            Box::new(SelectBox &#123;</span><br><span class="line">                width: 75,</span><br><span class="line">                height: 10,</span><br><span class="line">                options: vec![</span><br><span class="line">                    String::from(&quot;Yes&quot;),</span><br><span class="line">                    String::from(&quot;Maybe&quot;),</span><br><span class="line">                    String::from(&quot;No&quot;),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            Box::new(Button &#123;</span><br><span class="line">                width: 50,</span><br><span class="line">                height: 10,</span><br><span class="line">                label: String::from(&quot;OK&quot;),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-9: 使用 trait 对象来存储实现了相同 trait 的不同类型的值</p><p>当编写库的时候，我们不知道何人会在何时增加 SelectBox 类型，不过 Screen 的实现能够操作并绘制这个新类型，因为 SelectBox 实现了 Draw trait，这意味着它实现了 draw 方法。</p><p>这个概念 —— 只关心值所反映的信息而不是其具体类型 —— 类似于动态类型语言中称为 <strong>鸭子类型</strong>（<em>duck typing</em>）的概念：如果它走起来像一只鸭子，叫起来像一只鸭子，那么它就是一只鸭子！在示例 17-5 中 Screen 上的 run 实现中，run 并不需要知道各个组件的具体类型是什么。<strong>它并不检查组件是</strong> <strong>Button</strong> <strong>或者</strong> <strong>SelectBox</strong> <strong>的实例</strong>。<strong>通过指定</strong> <strong>Box<dyn Draw></strong> <strong>作为</strong> <strong>components</strong> <strong>vector 中值的类型</strong>，我们就定义了 Screen 为需要可以在其上调用 draw 方法的值。</p><p>使用 trait 对象和 Rust 类型系统来进行类似鸭子类型操作的优势是无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。如果值没有实现 trait 对象所需的 trait 则 Rust 不会编译这些代码。</p><p>例如，示例 17-10 展示了当创建一个使用 String 做为其组件的 Screen 时发生的情况：</p><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use gui::Screen;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let screen = Screen &#123;</span><br><span class="line">        components: vec![Box::new(String::from(&quot;Hi&quot;))],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 17-10: 尝试使用一种没有实现 trait 对象的 trait 的类型</p><p>我们会遇到这个错误，因为 String 没有实现 rust_gui::Draw trait：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling gui v0.1.0 (file:///projects/gui)</span><br><span class="line">error[E0277]: the trait bound `String: Draw` is not satisfied</span><br><span class="line"> --&gt; src/main.rs:5:26</span><br><span class="line">  |</span><br><span class="line">5 |         components: vec![Box::new(String::from(&quot;Hi&quot;))],</span><br><span class="line">  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Draw` is not implemented for `String`</span><br><span class="line">  |</span><br><span class="line">  = note: required for the cast to the object type `dyn Draw`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `gui` due to previous error</span><br></pre></td></tr></table></figure><p>这告诉了我们，要么是我们传递了并不希望传递给 Screen 的类型并应该提供其他类型，要么应该在 String 上实现 Draw 以便 Screen 可以调用其上的 draw。</p><h2 id="trait对象执行动态分发"><a href="#trait对象执行动态分发" class="headerlink" title="trait对象执行动态分发"></a>trait对象执行动态分发</h2><ul><li>对泛型使用 trait bound 时编译器所执行的单态化处理：编译器为每一个被泛型类型参数代替的具体类型生成了函数和方法的非泛型实现。单态化产生的代码在执行 <strong>静态分发</strong>（<em>static dispatch</em>）。</li><li>静态分发发生于编译器在编译时就知晓调用了什么方法的时候。</li><li><strong>动态分发</strong> （<em>dynamic dispatch</em> 编译器在编译时无法知晓调用了什么方法。</li><li>在动态分发的场景下，编译器生成的代码到运行时才能确定调用了什么方法。</li></ul><p><strong>当使用 trait 对象时，Rust 必须使用动态分发</strong>。编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。<strong>动态分发也阻止编译器有选择的内联方法代码</strong>，这会相应的<strong>禁用一些优化</strong>。尽管在编写示例 17-5 和可以支持示例 17-9 中的代码的过程中确实获得了额外的灵活性，但仍然需要权衡取舍。</p><h2 id="trait对象需要类型安全"><a href="#trait对象需要类型安全" class="headerlink" title="trait对象需要类型安全"></a>trait对象需要类型安全</h2><p><strong>只有对象安全（object-safe）的trait可以实现为 特征(dyn)对象</strong> 。</p><p>这里有一些复杂的规则来实现trait的对象安全，但在实践中，只有两个相关的规则。</p><p><strong>如果一个 trait 中定义的所有方法都符合以下规则，则该 trait 是对象安全的：</strong></p><ul><li>返回值不是 Self</li><li>没有泛型类型的参数</li></ul><p>Self 关键字是我们在 trait 与方法上的实现的别称，trait 对象必须是对象安全的，因为一旦使用 trait 对象，Rust 将不再知晓该实现的返回类型。如果一个 trait 的方法返回了一个 Self 类型，但是该 trait 对象忘记了 Self 的确切类型，那么该方法将不能使用原本的类型。当 trait 使用具体类型填充的泛型类型时也一样：具体类型成为实现 trait 的对象的一部分，当使用 trait 对象却忘了类型是什么时，无法知道应该用什么类型来填充泛型类型。</p><p><strong>一个非对象安全的 trait 例子是标准库中的</strong> <strong>Clone</strong> <strong>trait</strong>。Clone trait 中的 clone 方法的声明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub trait Clone &#123;</span><br><span class="line">    fn clone(&amp;self) -&gt; Self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型实现了 Clone trait，当我们在 String 的实例对象上调用 clone 方法时，我们会得到一个 String 类型实例对象。相似地，如果我们调用 Vec<T> 实例对象上的 clone 方法，我们会得到一个 Vec<T> 类型的实例对象。clone 方法的标签需要知道哪个类型是 Self 类型，因为 Self 是它的返回类型。</p><p>当我们尝试编译一些违反 trait 对象的对象安全规则的代码时，我们会收到编译器的提示。例如，我们想实现17-4的 Screen 结构体来保存一个实现了 Clone trait 而不是 Draw trait 的类型，如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pub struct Screen &#123;</span><br><span class="line">    pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会收到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">   Compiling gui v0.1.0 (file:///projects/gui)</span><br><span class="line">error[E0038]: the trait `Clone` cannot be made into an object</span><br><span class="line"> --&gt; src/lib.rs:2:29</span><br><span class="line">  |</span><br><span class="line">2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,</span><br><span class="line">  |                             ^^^^^^^^^ `Clone` cannot be made into an object</span><br><span class="line">  |</span><br><span class="line">  = note: the trait cannot be made into an object because it requires `Self: Sized`</span><br><span class="line">  = note: for a trait to be &quot;object safe&quot; it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety&gt;</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0038`.</span><br><span class="line">error: could not compile `gui` due to previous error</span><br></pre></td></tr></table></figure><p>这个错误意味着我们不能将此 trait 用于 trait 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 使用至少两种方法让代码工作</span><br><span class="line">// 不要添加/删除任何代码行</span><br><span class="line">trait MyTrait &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for u32 &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Self &#123; 42 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for String &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Self &#123; self.clone() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn my_function(x: Box&lt;dyn MyTrait&gt;)  &#123;</span><br><span class="line">    x.f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    my_function(Box::new(13_u32));</span><br><span class="line">    my_function(Box::new(String::from(&quot;abc&quot;)));</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方式修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trait MyTrait &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for u32 &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; u32 &#123; 42 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for String &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; String &#123; self.clone() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn my_function(x: impl MyTrait) -&gt; impl MyTrait  &#123;</span><br><span class="line">    x.f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    my_function(13_u32);</span><br><span class="line">    my_function(String::from(&quot;abc&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trait MyTrait &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for u32 &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt; &#123; Box::new(42) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl MyTrait for String &#123;</span><br><span class="line">    fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt; &#123; Box::new(self.clone()) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn my_function(x: Box&lt;dyn MyTrait&gt;) -&gt; Box&lt;dyn MyTrait&gt; &#123;</span><br><span class="line">    x.f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    my_function(Box::new(13_u32));</span><br><span class="line">    my_function(Box::new(String::from(&quot;abc&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象设计模式的实现"><a href="#面向对象设计模式的实现" class="headerlink" title="面向对象设计模式的实现"></a>面向对象设计模式的实现</h2><ul><li><strong>状态模式</strong>（<em>state pattern</em>）是一个面向对象设计模式。该模式的关键在于一个值有某些内部状态，体现为一系列的 <strong>状态对象</strong>，同时值的行为随着其内部状态而改变</li><li>状态对象共享功能：在 Rust 中使用结构体和 trait 而不是对象和继承。每一个状态对象负责其自身的行为，以及该状态何时应当转移至另一个状态。持有一个状态对象的值对于不同状态的行为以及何时状态转移毫不知情。</li><li>使用状态模式意味着当程序的业务需求改变时，无需改变值持有状态或者使用值的代码。我们只需更新某个状态对象中的代码来改变其规则，或者是增加更多的状态对象。</li></ul><p><a href="https://kaisery.github.io/trpl-zh-cn/ch17-03-oo-design-patterns.html#面向对象设计模式的实现">https://kaisery.github.io/trpl-zh-cn/ch17-03-oo-design-patterns.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0</a></p><h1 id="模式与模式匹配"><a href="#模式与模式匹配" class="headerlink" title="模式与模式匹配"></a>模式与模式匹配</h1><p><strong>模式：</strong></p><ul><li>模式是Rust中的一种特殊语法，用于匹配复杂和简单类型的结构</li><li>将模式与匹配表达式和其它构造结合使用，可以更好地控制程序的控制流</li><li>模式由以下元素(的一些组合)组成：</li></ul><p>—— 字面值</p><p>—— 解构的数组，enum,struct和tuple</p><p>—— 变量</p><p>—— 通配符</p><p>—— 占位符</p><h2 id="match的Arm"><a href="#match的Arm" class="headerlink" title="match的Arm"></a>match的Arm</h2><ul><li>match VALUE{PARTTERN=&gt;EXPRESSION,PARTTERN=&gt;EXPRESSION,PARTTERN=&gt;EXPRESSION,}</li><li>表达式的要求：</li></ul><p>—— 详尽（包含所有的可能性）</p><ul><li>一个特殊的模式：_ (下划线)—— 它不会匹配任何东西—— 不会绑定到变量—— 通常用于match的最后一个arm，或用于忽略某些值</li></ul><h2 id="条件if-let表达式"><a href="#条件if-let表达式" class="headerlink" title="条件if let表达式"></a>条件if let表达式</h2><ul><li>if let表达式主要是作为一种简短的方式来等价的替代只有一个匹配项的match</li><li>if let可选的可以拥有else，包括：</li></ul><p>—— else if</p><p>—— else if let</p><ul><li>但，if let不会检查穷举性例子：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let favorite_color: Option&lt;&amp;str&gt; = None;</span><br><span class="line">    let is_tuesday = false;</span><br><span class="line">    let age: Result&lt;u8,_&gt; = &quot;34&quot;.parse();</span><br><span class="line"></span><br><span class="line">    if let Some(color) = favorite_color&#123;</span><br><span class="line">        print!(&quot;Using your favorite color,&#123;&#125;,as the background&quot;,color);</span><br><span class="line">    &#125; else if is_tuesday&#123;</span><br><span class="line">        println!(&quot;Tuesday is green day!&quot;);</span><br><span class="line">    &#125; else if let Ok(age) = age &#123;</span><br><span class="line">        if age &gt; 30 &#123;</span><br><span class="line">            println!(&quot;Using purple as the background color&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            println!(&quot;Using orange as the background color&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        println!(&quot;Using blue as the background color&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-let-条件循环"><a href="#while-let-条件循环" class="headerlink" title="while let 条件循环"></a>while let 条件循环</h2><ul><li>只要模式继续满足匹配的条件，那它允许while循环一直运行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut stack = Vec::new();</span><br><span class="line">    stack.push(1);</span><br><span class="line">    stack.push(2);</span><br><span class="line">    stack.push(3);</span><br><span class="line"></span><br><span class="line">    while let Some(top) = stack.pop() &#123;</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul><li>for 循环是Rust中最常见的循环</li><li>for循环中，模式就是紧随for关键字后的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">   let v = vec![&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];</span><br><span class="line">   for (index,value) in v.iter().enumerate()&#123;</span><br><span class="line">        println!(&quot;&#123;&#125; is at index &#123;&#125;&quot;,value,index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iter().enumerate()返回的是一个元组</p><h2 id="let语句"><a href="#let语句" class="headerlink" title="let语句"></a>let语句</h2><ul><li>let语句也是模式</li><li>let PARTTERN = EXPRESSION</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 5;</span><br><span class="line">let (x,y,z) = (1,2,3);</span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ul><li>函数的参数也可以是模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn foo(x: i32)&#123;</span><br><span class="line">    println!(&quot;function foo&quot;);</span><br><span class="line">&#125;</span><br><span class="line">fn print_coordinates(&amp;(x,y): &amp;(i32,i32)) &#123;</span><br><span class="line">    println!(&quot;Current location: (&#123;&#125;,&#123;&#125;)&quot;,x,y);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let point = (3,5);</span><br><span class="line">    print_coordinates(&amp;point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可辨驳性：模式是否会无法匹配"><a href="#可辨驳性：模式是否会无法匹配" class="headerlink" title="可辨驳性：模式是否会无法匹配"></a>可辨驳性：模式是否会无法匹配</h2><ul><li>模式的两种形式：可辨驳的，无可辩驳的</li><li>能匹配任何可能传值的模式：无可辩驳的 入let x= 4;</li><li>对某些可能的值，无法进行匹配的模式:可辨驳的 例如：if let Some(x) = a_value</li><li><strong>函数参数，let语句，for循环只接受无可辩驳的模式</strong></li><li><strong>if let和while let接受可辨驳和无可辩驳的模式</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a: Option&lt;i32&gt; = Some(5);</span><br><span class="line">    let Some(x) = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0005]: refutable pattern in local binding: `None` not covered</span><br><span class="line">   --&gt; src\main.rs:3:9</span><br><span class="line">    |</span><br><span class="line">3   |     let Some(x) = a;</span><br><span class="line">    |         ^^^^^^^ pattern `None` not covered</span><br><span class="line">    |</span><br><span class="line">    = note: `let` bindings require an &quot;irrefutable pattern&quot;, like a `struct` or an `enum` with only one variant</span><br><span class="line">    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html</span><br></pre></td></tr></table></figure><p>无法匹配，因为模式没有覆盖None这种情况</p><p>修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let a: Option&lt;i32&gt; = Some(5);</span><br><span class="line">    if let Some(x) = a&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match除了最后一个分支，其它的分支都是可辨驳的，最后一个分支是不可辩驳的，因为它需要匹配所有剩余的情况</p><h2 id="匹配字面值"><a href="#匹配字面值" class="headerlink" title="匹配字面值"></a>匹配字面值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let x = 1;</span><br><span class="line">    match x &#123;</span><br><span class="line">        1 =&gt; println!(&quot;one&quot;),</span><br><span class="line">        2 =&gt; println!(&quot;two&quot;),</span><br><span class="line">        3 =&gt; println!(&quot;three&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;anything&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h2><ul><li>命名的变量是可匹配任何值的无可辩驳模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let x = Some(5);</span><br><span class="line">    let y = 10;</span><br><span class="line">    match x &#123;</span><br><span class="line">        Some(50) =&gt; println!(&quot;Got 50&quot;),</span><br><span class="line">        Some(y) =&gt; println!(&quot;Matched,y=&#123;:?&#125;&quot;,y),</span><br><span class="line">        _ =&gt; println!(&quot;Default Case,x=&#123;:?&#125;&quot;,x),</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;at the end: x=&#123;:?&#125;,y=&#123;:?&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里match的第二个arm中<strong>y是一个新的变量</strong>，存在于该arm的作用域</p><h2 id="匹配一个可变引用"><a href="#匹配一个可变引用" class="headerlink" title="匹配一个可变引用"></a>匹配一个可变引用</h2><p>使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V<strong>是一个值</strong>，而<strong>不是可变引用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = String::from(&quot;hello,&quot;);</span><br><span class="line">    let r = &amp;mut v;</span><br><span class="line"></span><br><span class="line">    match r &#123;</span><br><span class="line">        // The type of value is &amp;mut String</span><br><span class="line">       value =&gt; value.push_str(&quot; world!&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重模式"><a href="#多重模式" class="headerlink" title="多重模式"></a>多重模式</h2><ul><li>在match表达式中，使用 | 语法（就是或的意思）可以匹配多种模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let x= 1;</span><br><span class="line">    match x &#123;</span><br><span class="line">        1 | 2 =&gt; println!(&quot;one or two&quot;),</span><br><span class="line">        3 =&gt; println!(&quot;three&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;anything&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-来匹配某个范围的值"><a href="#使用-来匹配某个范围的值" class="headerlink" title="使用..=来匹配某个范围的值"></a>使用..=来匹配某个范围的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let x= 5;</span><br><span class="line">    match x&#123;</span><br><span class="line">        1..=5 =&gt; println!(&quot;one through five&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;something else&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">    let x = &#x27;c&#x27;;</span><br><span class="line">    match x &#123;</span><br><span class="line">        &#x27;a&#x27;..=&#x27;j&#x27; =&gt; println!(&quot;early ASCII letter&quot;),</span><br><span class="line">        &#x27;k&#x27;..=&#x27;z&#x27; =&gt; println!(&quot;late ASCII letter&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;something else&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字或字符都可以</p><h2 id="解构以分解值"><a href="#解构以分解值" class="headerlink" title="解构以分解值"></a>解构以分解值</h2><ul><li>可以使用模式来结构struct,enum,tuple，从而引用这些类型值的不同部分</li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let (x, y);</span><br><span class="line">    (x,..) = (3, 4);</span><br><span class="line">    [.., y] = [1, 2];</span><br><span class="line">    assert_eq!([x,y],[3,2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构元组"><a href="#解构元组" class="headerlink" title="解构元组"></a>解构元组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let (mut x, y) = (1, 2);</span><br><span class="line">    x += 2;</span><br><span class="line"></span><br><span class="line">    assert_eq!(x, 3);</span><br><span class="line">    assert_eq!(y, 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#[derive(Debug)]</span><br><span class="line">struct Point&#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let p = Point&#123;x:0,y:7&#125;;</span><br><span class="line">    let Point &#123;x:a,y:b&#125;=p;</span><br><span class="line">    assert_eq!(0,a);</span><br><span class="line">    assert_eq!(7,b);</span><br><span class="line"></span><br><span class="line">    //简写形式</span><br><span class="line">    let Point&#123;x,y&#125; = p;</span><br><span class="line">    assert_eq!(0,x);</span><br><span class="line">    assert_eq!(7,y);</span><br><span class="line"></span><br><span class="line">    match p &#123;</span><br><span class="line">        Point &#123;x,y:0&#125;=&gt; println!(&quot;On the x axis at &#123;&#125;&quot;,x),//要求y必须为0</span><br><span class="line">        Point &#123;x:0,y&#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;,y),//要求x必须为0</span><br><span class="line">        Point &#123;x,y&#125; =&gt; println!(&quot;On neither axis:(&#123;&#125;,&#123;&#125;)&quot;,x,y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">enum Message&#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:i32,y:i32&#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32,i32,i32),</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let msg = Message::ChangeColor(0, 160, 255);</span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            println!(&quot;The Quit variant has no data to destructure&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125;=&gt;&#123;</span><br><span class="line">            println!(&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Write(text)=&gt;&#123;</span><br><span class="line">            println!(&quot;Text message:&#123;&#125;&quot;,text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::ChangeColor(r, g, b)=&gt;&#123;</span><br><span class="line">            println!(&quot;rgb is (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;,r,g,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;</span><br><span class="line">    Rgb(i32,i32,i32),</span><br><span class="line">    Hsv(i32,i32,i32),</span><br><span class="line">&#125;</span><br><span class="line">enum Message&#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:i32,y:i32&#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(Color),</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));</span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::ChangeColor(Color::Rgb(r, g, b))=&gt;&#123;</span><br><span class="line">            println!(&quot;Change the color to red &#123;&#125;,green &#123;&#125;,and blue &#123;&#125;&quot;,r,g,b);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::ChangeColor(Color::Hsv(h, s, v))=&gt;&#123;</span><br><span class="line">            println!(&quot;Change the color to hue &#123;&#125;,saturation &#123;&#125;,and value &#123;&#125;&quot;,h,s,v);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let ((feet,inches),Point&#123;x,y&#125;) = ((3,10),Point&#123;x:3,y:-10&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在模式中忽略值"><a href="#在模式中忽略值" class="headerlink" title="在模式中忽略值"></a>在模式中忽略值</h2><ul><li>有几种方式可以在模式中忽略整个值或部分值:</li></ul><h3 id="忽略整个值"><a href="#忽略整个值" class="headerlink" title="_ 忽略整个值"></a><strong>_ 忽略整个值</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn foo(_:i32,y:i32)&#123;</span><br><span class="line">    println!(&quot;y is &#123;&#125;&quot;,y);</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    foo(3, 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用嵌套-忽略值的一部分"><a href="#使用嵌套-忽略值的一部分" class="headerlink" title="使用嵌套_忽略值的一部分"></a><strong>使用嵌套_忽略值的一部分</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let mut setting_value = Some(5);</span><br><span class="line">    let new_setting_value = Some(10);</span><br><span class="line">    match (setting_value,new_setting_value) &#123;</span><br><span class="line">        (Some(_),Some(_))=&gt;&#123;</span><br><span class="line">            println!(&quot;Can&#x27;t overwrite an existing customized value&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt;&#123;</span><br><span class="line">            setting_value = new_setting_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;setting is &#123;:?&#125;&quot;,setting_value);</span><br><span class="line"></span><br><span class="line">    let numbers = (3,4,8,16,32);</span><br><span class="line">    match numbers &#123;</span><br><span class="line">        (first,_,third,_,fifth)=&gt;&#123;</span><br><span class="line">            println!(&quot;Some numbers:&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;,first,third,fifth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用以-开头命名来忽略未使用的变量"><a href="#使用以-开头命名来忽略未使用的变量" class="headerlink" title="使用以_开头命名来忽略未使用的变量"></a><strong>使用以_开头命名来忽略未使用的变量</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let _x = 5;</span><br><span class="line">    let y = 10;//编译器警告未使用的变量</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let s = Some(String::from(&quot;Hello!&quot;));</span><br><span class="line">    if let Some(_s) = s &#123;</span><br><span class="line">        println!(&quot;found a string&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式匹配中_s是一个新的变量，模式匹配把s所有权移动到_s,后面再访问s就会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let s = Some(String::from(&quot;Hello!&quot;));</span><br><span class="line">    if let Some(_) = s &#123;</span><br><span class="line">        println!(&quot;found a string&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;&#123;:?&#125;&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_ ，不会发生绑定，不会移动所有权</p><h3 id="忽略值的剩余部分"><a href="#忽略值的剩余部分" class="headerlink" title="..(忽略值的剩余部分)"></a><strong>..(忽略值的剩余部分)</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct Point&#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">    z: i32,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let origin = Point&#123;x:0,y:0,z:0&#125;;</span><br><span class="line">    match origin &#123;</span><br><span class="line">        Point &#123;x,..&#125; =&gt; println!(&quot;x is &#123;&#125;&quot;,x),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let numbers = (2,4,8,16,32);</span><br><span class="line">    match numbers &#123;</span><br><span class="line">        (first,..,last)=&gt;&#123;</span><br><span class="line">            println!(&quot;Some numbers: &#123;&#125;,&#123;&#125;&quot;,first,last)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要加逗号,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);</span><br><span class="line"></span><br><span class="line">    match numbers &#123;</span><br><span class="line">        (first,..,last) =&gt; &#123;</span><br><span class="line">           assert_eq!(first, 2);</span><br><span class="line">           assert_eq!(last, 2048);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用match守卫来提供额外的条件"><a href="#使用match守卫来提供额外的条件" class="headerlink" title="使用match守卫来提供额外的条件"></a>使用match守卫来提供额外的条件</h2><ul><li>match 守卫就是match arm模式后额外的if 条件，想要匹配该条件也必须满足</li><li>match 守卫适合更复杂的场景</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let num = Some(4);</span><br><span class="line">    match num &#123;</span><br><span class="line">        Some(x) if x &lt; 5 =&gt; println!(&quot;less than five:&#123;&#125;&quot;,x),</span><br><span class="line">        Some(x) =&gt; println!(&quot;&#123;&#125;&quot;,x),</span><br><span class="line">        None =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let x = Some(5);</span><br><span class="line">    let y = 10;</span><br><span class="line">    </span><br><span class="line">    match x &#123;</span><br><span class="line">        Some(50) =&gt; println!(&quot;Got 50&quot;),</span><br><span class="line">        Some(n) if n==y =&gt; println!(&quot;Matched,n = &#123;:?&#125;&quot;,n),//这里if n==y不是一个模式，不会引用新的变量</span><br><span class="line">        _ =&gt;println!(&quot;Default case,x =&#123;:?&#125;&quot;,x),</span><br><span class="line">    &#125;</span><br><span class="line">    println!(&quot;at the end:x=&#123;:?&#125;,y=&#123;:?&#125;&quot;,x,y);</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let x= 4;</span><br><span class="line">    let y = false;</span><br><span class="line">    match x &#123;</span><br><span class="line">        4 | 5 | 6 if y=&gt; println!(&quot;yes&quot;),</span><br><span class="line">        _ =&gt; println!(&quot;no&quot;),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a>@绑定</h2><ul><li>@ 符号可以让我们可以创建一个变量，该变量可以在测试某个值是否与模式匹配的同时保存该值</li></ul><p>就相当于一个等号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">enum Message&#123;</span><br><span class="line">    Hello &#123;id:i32&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let msg = Message::Hello &#123; id: 5 &#125;;</span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Hello &#123; id: id_variable @ 3..=7, &#125;=&gt;&#123;</span><br><span class="line">            println!(&quot;Found an id in range:&#123;&#125;&quot;,id_variable);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id: 10..=12 &#125;=&gt;&#123;</span><br><span class="line">            println!(&quot;Found an id in another range&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125;=&gt;&#123;</span><br><span class="line">            println!(&quot;Found some other id:&#123;&#125;&quot;,id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Point &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    // fill in the blank to let p match the second arm</span><br><span class="line">    let p = Point &#123; x: 2, y: 20 &#125;; // x can be [0, 5], y can be 10 20 or 30</span><br><span class="line"></span><br><span class="line">    match p &#123;</span><br><span class="line">        Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x),</span><br><span class="line">        // second arm</span><br><span class="line">        Point &#123; x: 0..=5, y: y@ (10 | 20 | 30) &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>下面这段代码会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Hello &#123; id: i32 &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let msg = Message::Hello &#123; id: 5 &#125;;</span><br><span class="line"></span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id:  3..=7,</span><br><span class="line">        &#125; =&gt; println!(&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;, id),//Error cannot find value `id` in this scope</span><br><span class="line">        Message::Hello &#123; id: newid@10 | 11 | 12 &#125; =&gt; &#123;//Error variable `newid` is not bound in all patterns pattern doesn&#x27;t bind `newid`</span><br><span class="line">            println!(&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;, newid)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">    Hello &#123; id: i32 &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let msg = Message::Hello &#123; id: 5 &#125;;</span><br><span class="line"></span><br><span class="line">    match msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id: id @3..=7,</span><br><span class="line">        &#125; =&gt; println!(&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;, id),</span><br><span class="line">        Message::Hello &#123; id: newid@(10 | 11 | 12) &#125; =&gt; &#123;</span><br><span class="line">            println!(&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;, newid)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unsafe-Rust"><a href="#unsafe-Rust" class="headerlink" title="unsafe Rust"></a>unsafe Rust</h1><ul><li>隐藏着第二个语言，它没有强制内存安全保证：unsafe Rust(不安全的Rust)</li></ul><p>和普通的Rust一样，但提供了额外的超能力</p><ul><li>Unsafe Rust存在的原因:</li></ul><ol><li>静态分析是保守的，使用unsafe rust就相当于告诉编译器：我知道自己在做什么，并承担相应的风险</li><li>计算机硬件本身就是不安全的，Rust需要能够进行底层系统编程</li></ol><h2 id="unsafe超能力"><a href="#unsafe超能力" class="headerlink" title="unsafe超能力"></a>unsafe超能力</h2><ul><li>使用unsafe关键字来切换到unsafe Rust，开启一个块，里面放着unsafe代码</li><li>unsafe Rust里执行的四个动作（unsafe超能力):</li></ul><ol><li>解引用原始指针</li><li>调用unsafe函数或方法</li><li>访问或修改可变的静态变量</li><li>实现unsafe trait</li></ol><ul><li>注意：</li></ul><p>unsafe并没有关系借用检查或停用其它安全的安全检查</p><p>任何内存安全相关的而错误必须留在unsafe块里</p><p>尽可能隔离unsafe代码，最好将其封装在安全的抽象里，提供安全的API</p><h2 id="解引用原始指针"><a href="#解引用原始指针" class="headerlink" title="解引用原始指针"></a>解引用原始指针</h2><ul><li>原始指针</li></ul><p>可变的： *mut T</p><p>不可变的： *const T，意味着指针在解引用后不能直接对其进行赋值</p><p>注意：这里的*不是解引用符号，它是类型名的一部分</p><ul><li>与引用不同，原始指针:</li></ul><ol><li><strong>允许通过同时具有可变和不可变指针或指向同一位置的可变指针来忽略借用规则</strong></li><li>无法保证能指向合理的内存</li><li>允许为null</li><li>不实现任何自动清理</li></ol><ul><li>放弃保证的安全，换取更好的性能/与其它语言或硬件接口的能力</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let mut num=5;</span><br><span class="line">    let r1 = &amp;num as *const i32;</span><br><span class="line">    let r2 = &amp;mut num as *mut i32;</span><br><span class="line">    let address = 0x012345usize;</span><br><span class="line">    let r = address as *const i32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在安全代码块里创建原始指针，但不能够解引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let mut num=5;</span><br><span class="line">    let r1 = &amp;num as *const i32;</span><br><span class="line">    let r2 = &amp;mut num as *mut i32;</span><br><span class="line"></span><br><span class="line">    unsafe&#123;</span><br><span class="line">        println!(&quot;r1:&#123;&#125;&quot;,*r1);</span><br><span class="line">        println!(&quot;r2:&#123;&#125;&quot;,*r2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let address = 0x012345usize;</span><br><span class="line">    let r = address as *const i32;</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        println!(&quot;r:&#123;&#125;&quot;,*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要使用原始指针？</p><ul><li>与C语言进行接口</li><li>构建借用检查器无法理解的安全抽象</li></ul><h2 id="调用unsafe函数或方法"><a href="#调用unsafe函数或方法" class="headerlink" title="调用unsafe函数或方法"></a>调用unsafe函数或方法</h2><ul><li>unsafe函数或方法：在定义前加上了unsafe关键字</li></ul><p>——调用前需手动满足一些条件（主要靠看文档），因为Rust无法对这些条件进行验证</p><p>——需要在unsafe块里进行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsafe fn dangerous()&#123;&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        dangerous();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建unsafe代码的安全抽象"><a href="#创建unsafe代码的安全抽象" class="headerlink" title="创建unsafe代码的安全抽象"></a>创建unsafe代码的安全抽象</h2><ul><li>函数包含unsafe代码并不意味着需要将整个函数标记为unsafe</li><li>将unsafe代码包裹在安全函数中是一个常见的抽象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use std::vec;</span><br><span class="line"></span><br><span class="line">fn split_at_mut(slice:&amp;mut[i32],mid:usize)-&gt;(&amp;mut [i32],&amp;mut[i32])&#123;</span><br><span class="line">    let len = slice.len();</span><br><span class="line">    assert!(mid&lt;=len);</span><br><span class="line">    (&amp;mut slice[..mid],&amp;mut slice[mid..])</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let mut v= vec![1,2,3,4,5,6];</span><br><span class="line">    let r = &amp;mut v[..];</span><br><span class="line">    let (a,b) = r.split_at_mut(3);</span><br><span class="line">    assert_eq!(a,&amp;mut [1,2,3]);</span><br><span class="line">    assert_eq!(b,&amp;mut [4,5,6]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `*slice` as mutable more than once at a time  </span><br><span class="line"> --&gt; src\main.rs:6:29</span><br><span class="line">  |</span><br><span class="line">3 | fn split_at_mut(slice:&amp;mut[i32],mid:usize)-&gt;(&amp;mut [i32],&amp;mut[i32])&#123;   </span><br><span class="line">  |                       - let&#x27;s call the lifetime of this reference `&#x27;1`</span><br><span class="line">...</span><br><span class="line">6 |     (&amp;mut slice[..mid],&amp;mut slice[mid..])</span><br><span class="line">  |     ------------------------^^^^^--------</span><br><span class="line">  |     |     |                 |</span><br><span class="line">  |     |     |                 second mutable borrow occurs here</span><br><span class="line">  |     |     first mutable borrow occurs here</span><br><span class="line">  |     returning this value requires that `*slice` is borrowed for `&#x27;1`  </span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br></pre></td></tr></table></figure><p>使用unfase代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">use std::slice;</span><br><span class="line">fn split_at_mut(slice: &amp;mut [i32],mid: usize)-&gt;(&amp;mut [i32],&amp;mut [i32])&#123;</span><br><span class="line">    let len = slice.len();</span><br><span class="line">    let ptr = slice.as_mut_ptr();</span><br><span class="line">    assert!(mid&lt;=len);</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        (</span><br><span class="line">            slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">            slice::from_raw_parts_mut(ptr.add(mid), len-mid)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let mut v= vec![1,2,3,4,5,6];</span><br><span class="line">    let r = &amp;mut v[..];</span><br><span class="line">    let (a,b) = r.split_at_mut(3);</span><br><span class="line">    assert_eq!(a,&amp;mut [1,2,3]);</span><br><span class="line">    assert_eq!(b,&amp;mut [4,5,6]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用extern函数调用外部代码"><a href="#使用extern函数调用外部代码" class="headerlink" title="使用extern函数调用外部代码"></a>使用extern函数调用外部代码</h2><ul><li>extern 关键字：简化创建和使用外部函数接口（FFI）的过程</li><li>外部函数接口(FFI，Foreign Function Interface) : 它允许一种编程语言定义函数，并让其它编程语言能调用这些函数</li><li>extern 块中声明的函数在 Rust 代码中总是不安全的。因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;&#123;//&quot;C&quot;指明外部函数应用的二进制接口abi(application binary interface)</span><br><span class="line">    fn abs(input: i32) -&gt;i32;//想要调用的外部函数的签名</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    unsafe&#123;</span><br><span class="line">        println!(&quot;Absolute value of -3 according to C:&#123;&#125;&quot;,abs(-3));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用二进制接口(ABI，Application Binary Interface):定义函数在汇编层的调用方式</li><li>“C” ABI是最常见的ABI,它遵循C语言的ABI</li></ul><h2 id="从其它语言调用Rust函数"><a href="#从其它语言调用Rust函数" class="headerlink" title="从其它语言调用Rust函数"></a>从其它语言调用Rust函数</h2><ul><li>可以使用extern创建接口，其它语言通过它们可以调用Rust函数</li><li>在fn前添加extern关键字，并指定ABI</li><li>还需添加#[no_mangle]注解：避免Rust在编译时改变它的名称</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#[no_mangle]</span><br><span class="line">pub extern &quot;C&quot; fn call_from_c()&#123;</span><br><span class="line">    println!(&quot;Just called a Rust function from C!&quot;);//编译链接后就可被c语言访问了，extern 的使用无需 unsafe。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问或修改一个可变的静态变量"><a href="#访问或修改一个可变的静态变量" class="headerlink" title="访问或修改一个可变的静态变量"></a>访问或修改一个可变的静态变量</h2><ul><li>Rust支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争</li><li>在Rust里，全局变量叫做静态(static)变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;name is: &#123;&#125;&quot;, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态（static）变量类似常量。</li><li>通常静态变量的名称采用 SCREAMING_SNAKE_CASE 写法。</li><li>静态变量只能储存拥有 ‘static 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。</li><li>访问<strong>不可变静态变量</strong>是安全的。</li></ul><p>静态变量和常量的区别：</p><ul><li>静态变量中的值<strong>有一个固定的内存地址</strong>。使用这个值总是会访问相同的地址。常量则允许在任何被用到的时候<strong>复制其数据</strong>。</li><li>静态变量可以是可变的。访问和修改可变静态变量都是 <strong>不安全</strong> 的。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static mut COUNTER: u32 = 0;</span><br><span class="line"></span><br><span class="line">fn add_to_count(inc: u32) &#123;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    add_to_count(3);</span><br><span class="line"></span><br><span class="line">    unsafe &#123;</span><br><span class="line">        println!(&quot;COUNTER: &#123;&#125;&quot;, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何读写 COUNTER 的代码都必须位于 unsafe 块中。这段代码可以编译并如期打印出 COUNTER: 3，因为这是单线程的。拥有多个线程访问 COUNTER 则可能导致数据竞争。</p><p>拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，优先使用智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的。</p><h2 id="实现不安全trait"><a href="#实现不安全trait" class="headerlink" title="实现不安全trait"></a>实现不安全trait</h2><ul><li>当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。</li><li>可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsafe trait Foo &#123;</span><br><span class="line">    // methods go here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsafe impl Foo for i32 &#123;</span><br><span class="line">    // method implementations go here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br></pre></td></tr></table></figure><p>Sync 和 Send 标记 trait，编译器会自动为完全由 Send 和 Sync 类型组成的类型自动实现他们。如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync，则必须使用 unsafe。Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程间访问，所以需要我们自己进行检查并通过 unsafe 表明。</p><h2 id="访问联合体中的字段"><a href="#访问联合体中的字段" class="headerlink" title="访问联合体中的字段"></a>访问联合体中的字段</h2><p>仅适用于 unsafe 的最后一个操作是访问 <strong>联合体</strong> 中的字段，union 和 struct 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互。访问联合体的字段是不安全的，因为 Rust 无法保证当前存储在联合体实例中数据的类型。可以查看 (<a href="https://doc.rust-lang.org/reference/items/unions.html">https://doc.rust-lang.org/reference/items/unions.html</a>) 了解有关联合体的更多信息。</p><h2 id="何时使用不安全的代码"><a href="#何时使用不安全的代码" class="headerlink" title="何时使用不安全的代码"></a>何时使用不安全的代码</h2><p>使用 unsafe 来进行这五个操作（超能力）之一是没有问题的，甚至是不需要深思熟虑的，不过使得 unsafe 代码正确也实属不易，因为编译器不能帮助保证内存安全。当有理由使用 unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注可以更容易地在错误发生时追踪问题的源头。</p><h1 id="高级trait"><a href="#高级trait" class="headerlink" title="高级trait"></a>高级trait</h1><h2 id="在trait定义中使用关联类型来指定占位类型"><a href="#在trait定义中使用关联类型来指定占位类型" class="headerlink" title="在trait定义中使用关联类型来指定占位类型"></a>在trait定义中使用关联类型来指定占位类型</h2><ul><li>关联类型(associate type)是trait中的类型占位符，它可以用于trait的方法签名中：</li></ul><p>——可以定义出包含某些类型的trait，而在实现前无需知道这些类型是什么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line">    fn next(&amp;mut self)-&gt;Option&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联类型与泛型的区别"><a href="#关联类型与泛型的区别" class="headerlink" title="关联类型与泛型的区别"></a>关联类型与泛型的区别</h2><div class="table-container"><table><thead><tr><th><strong>泛型</strong></th><th><strong>关联类型</strong></th></tr></thead><tbody><tr><td>每次实现Trait时标注类型</td><td>无需标注类型</td></tr><tr><td>可以为一个类型多次实现某个Trait(不同的泛型参数)</td><td>无法为单个类型多次实现某个Trait</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">pub trait Iterator &#123;</span><br><span class="line">    type Item;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line">pub trait Iterator2&lt;T&gt;&#123;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line">struct Counter&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">impl Iterator for Counter&#123;//只能实现一次</span><br><span class="line">    type Item=u32;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// impl Iterator for Counter&#123;//只能实现一次,第二次为String实现报错</span><br><span class="line">//     type Item=String;</span><br><span class="line">//     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="line">//         None</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">impl Iterator2&lt;String&gt; for Counter &#123;</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;String&gt; &#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Iterator2&lt;u32&gt; for Counter &#123;//可以为不同的类型实现多次</span><br><span class="line">    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; &#123;</span><br><span class="line">        None</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关联类型主要用于提升代码的可读性，例如以下代码 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable &#123;</span><br><span class="line">  type Address: AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash;</span><br><span class="line">  fn is_null(&amp;self) -&gt; bool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash， Address 的使用可以极大的减少其它类型在实现该特征时所需的模版代码.</p><p>例子：使用关联类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct Container(i32, i32);</span><br><span class="line"></span><br><span class="line">// 使用关联类型实现重新实现以下特征</span><br><span class="line">// trait Contains &#123;</span><br><span class="line">//    type A;</span><br><span class="line">//    type B;</span><br><span class="line"></span><br><span class="line">trait Contains&lt;A, B&gt; &#123;</span><br><span class="line">    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool;</span><br><span class="line">    fn first(&amp;self) -&gt; i32;</span><br><span class="line">    fn last(&amp;self) -&gt; i32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Contains&lt;i32, i32&gt; for Container &#123;</span><br><span class="line">    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123;</span><br><span class="line">        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)</span><br><span class="line">    &#125;</span><br><span class="line">    // Grab the first number.</span><br><span class="line">    fn first(&amp;self) -&gt; i32 &#123; self.0 &#125;</span><br><span class="line"></span><br><span class="line">    // Grab the last number.</span><br><span class="line">    fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn difference&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) -&gt; i32 &#123;</span><br><span class="line">    container.last() - container.first()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number_1 = 3;</span><br><span class="line">    let number_2 = 10;</span><br><span class="line"></span><br><span class="line">    let container = Container(number_1, number_2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;,</span><br><span class="line">        &amp;number_1, &amp;number_2,</span><br><span class="line">        container.contains(&amp;number_1, &amp;number_2));</span><br><span class="line">    println!(&quot;First number: &#123;&#125;&quot;, container.first());</span><br><span class="line">    println!(&quot;Last number: &#123;&#125;&quot;, container.last());</span><br><span class="line">    </span><br><span class="line">    println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct Container(i32, i32);</span><br><span class="line"></span><br><span class="line">// A trait which checks if 2 items are stored inside of container.</span><br><span class="line">// Also retrieves first or last value.</span><br><span class="line">trait Contains &#123;</span><br><span class="line">    // Define generic types here which methods will be able to utilize.</span><br><span class="line">    type A;</span><br><span class="line">    type B;</span><br><span class="line"></span><br><span class="line">    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;</span><br><span class="line">    fn first(&amp;self) -&gt; i32;</span><br><span class="line">    fn last(&amp;self) -&gt; i32;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Contains for Container &#123;</span><br><span class="line">    // Specify what types `A` and `B` are. If the `input` type</span><br><span class="line">    // is `Container(i32, i32)`, the `output` types are determined</span><br><span class="line">    // as `i32` and `i32`.</span><br><span class="line">    type A = i32;</span><br><span class="line">    type B = i32;</span><br><span class="line"></span><br><span class="line">    // `&amp;Self::A` and `&amp;Self::B` are also valid here.</span><br><span class="line">    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123;</span><br><span class="line">        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)</span><br><span class="line">    &#125;</span><br><span class="line">    // Grab the first number.</span><br><span class="line">    fn first(&amp;self) -&gt; i32 &#123; self.0 &#125;</span><br><span class="line"></span><br><span class="line">    // Grab the last number.</span><br><span class="line">    fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 &#123;</span><br><span class="line">    container.last() - container.first()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let number_1 = 3;</span><br><span class="line">    let number_2 = 10;</span><br><span class="line"></span><br><span class="line">    let container = Container(number_1, number_2);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;,</span><br><span class="line">        &amp;number_1, &amp;number_2,</span><br><span class="line">        container.contains(&amp;number_1, &amp;number_2));</span><br><span class="line">    println!(&quot;First number: &#123;&#125;&quot;, container.first());</span><br><span class="line">    println!(&quot;Last number: &#123;&#125;&quot;, container.last());</span><br><span class="line">    </span><br><span class="line">    println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认泛型参数和运算符重载"><a href="#默认泛型参数和运算符重载" class="headerlink" title="默认泛型参数和运算符重载"></a>默认泛型参数和运算符重载</h2><ul><li>可以在使用泛型参数时为泛型指定一个默认的具体类型</li><li>语法：<PlaceholderType=ConcreteType></li><li>这种结束常用于运算符重载（operator overloading）</li><li>Rust不允许创建自己的运算符及重载任意的运算符</li><li>但可以通过实现std::ops中列出的那些trait来重载一部分相应的运算符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Add;</span><br><span class="line"></span><br><span class="line">#[derive(Debug, PartialEq)]</span><br><span class="line">struct Point &#123;</span><br><span class="line">    x: i32,</span><br><span class="line">    y: i32,</span><br><span class="line">&#125;</span><br><span class="line">impl Add for Point &#123;</span><br><span class="line">    type Output = Point;</span><br><span class="line">    fn add(self, other: Point) -&gt; Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: self.x + other.x,</span><br><span class="line">            y: self.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    assert_eq!(</span><br><span class="line">        Point &#123; x: 1, y: 0 &#125; + Point &#123; x: 2, y: 3 &#125;,</span><br><span class="line">        Point &#123; x: 3, y: 3 &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是add的默认泛型参数self</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Add;</span><br><span class="line">struct Millimeters(u32);</span><br><span class="line">struct Meter(u32);</span><br><span class="line">impl Add&lt;Meter&gt; for Millimeters &#123;</span><br><span class="line">    type Output = Millimeters;</span><br><span class="line">    fn add(self, rhs: Meter) -&gt; Self::Output &#123;</span><br><span class="line">        Millimeters(self.0+(other.0*1000))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定泛型参数</p><h2 id="默认泛型参数的主要应用场景"><a href="#默认泛型参数的主要应用场景" class="headerlink" title="默认泛型参数的主要应用场景"></a>默认泛型参数的主要应用场景</h2><ul><li>扩展一个类型而不破坏现有的代码</li><li>允许在大部分用户都不需要的特定场景下进行自定义</li></ul><h2 id="完全限定语法-Fully-Qualified-Syntax"><a href="#完全限定语法-Fully-Qualified-Syntax" class="headerlink" title="完全限定语法(Fully Qualified Syntax)"></a>完全限定语法(Fully Qualified Syntax)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">trait Pilot &#123;</span><br><span class="line">    fn fly(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line">trait Wizard &#123;</span><br><span class="line">    fn fly(&amp;self);</span><br><span class="line">&#125;</span><br><span class="line">struct Human;</span><br><span class="line"></span><br><span class="line">impl Pilot for Human &#123;</span><br><span class="line">    fn fly(&amp;self) &#123;</span><br><span class="line">        println!(&quot;This is your captain speaking&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Wizard for Human &#123;</span><br><span class="line">    fn fly(&amp;self) &#123;</span><br><span class="line">        println!(&quot;Up!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Human &#123;</span><br><span class="line">    fn fly(&amp;self)&#123;</span><br><span class="line">        println!(&quot;*waving arms furiously*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let person = Human;</span><br><span class="line">    person.fly();//调用本身的方法</span><br><span class="line">    Pilot::fly(&amp;person);//调用Pilot trait中的方法</span><br><span class="line">    Wizard::fly(&amp;person);//调用Wizard trait中的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trait Animal &#123;</span><br><span class="line">    fn baby_name()-&gt;String;</span><br><span class="line">&#125;</span><br><span class="line">struct Dog;</span><br><span class="line"></span><br><span class="line">impl Dog &#123;</span><br><span class="line">    fn baby_name()-&gt;String&#123;</span><br><span class="line">        String::from(&quot;Spot&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Animal for Dog &#123;</span><br><span class="line">    fn baby_name()-&gt;String &#123;</span><br><span class="line">        String::from(&quot;puppy&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;A baby dog is called a&#123;&#125;&quot;,Dog::baby_name());</span><br><span class="line">    println!(&quot;A baby dog is called a&#123;&#125;&quot;,Animal::baby_name());//报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的baby_name没有参数，编译器不知道是哪个Dog调用</p><ul><li>完全限定语法：<Type as Trait>::function(receiver_if_method,netx_arg,..) ;</li><li>可以在任何调用函数或方法的地方使用</li><li>允许忽略那些从其他上下文能推导出来的部分</li><li>当Rust无法区分你期望调用哪个具体实现的时候，才需要使用这种语法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">trait Animal &#123;</span><br><span class="line">    fn baby_name()-&gt;String;</span><br><span class="line">&#125;</span><br><span class="line">struct Dog;</span><br><span class="line"></span><br><span class="line">impl Dog &#123;</span><br><span class="line">    fn baby_name()-&gt;String&#123;</span><br><span class="line">        String::from(&quot;Spot&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">impl Animal for Dog &#123;</span><br><span class="line">    fn baby_name()-&gt;String &#123;</span><br><span class="line">        String::from(&quot;puppy&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    println!(&quot;A baby dog is called a&#123;&#125;&quot;,Dog::baby_name());</span><br><span class="line">    println!(&quot;A baby dog is called a&#123;&#125;&quot;,&lt;Dog as Animal&gt;::baby_name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用supertrait来要求trait附带其它trait的功能"><a href="#使用supertrait来要求trait附带其它trait的功能" class="headerlink" title="使用supertrait来要求trait附带其它trait的功能"></a>使用supertrait来要求trait附带其它trait的功能</h2><ul><li>需要在一个trait中使用其它trait的功能</li></ul><p>——需要被依赖的trait也被实现</p><p>——那个被间接以来的trait就是当前trait的supertrait</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt::&#123;self, write&#125;;</span><br><span class="line">trait OutlinePrint: fmt::Display&#123;</span><br><span class="line">    fn outline_print(&amp;self)&#123;</span><br><span class="line">        let output = self.to_string();</span><br><span class="line">        let len = output.len();</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,&quot;*&quot;.repeat(len+4));</span><br><span class="line">        println!(&quot;*&#123;&#125;*&quot;,&quot; &quot;.repeat(len+2));</span><br><span class="line">        println!(&quot;* &#123;&#125; *&quot;,output);</span><br><span class="line">        println!(&quot;*&#123;&#125;*&quot;,&quot; &quot;.repeat(len+2));</span><br><span class="line">        println!(&quot;&#123;&#125;&quot;,&quot;*&quot;.repeat(len+4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Point&#123;</span><br><span class="line">    x:i32,</span><br><span class="line">    y:i32,</span><br><span class="line">&#125;</span><br><span class="line">impl OutlinePrint for Point &#123;</span><br><span class="line">&#125;</span><br><span class="line">impl fmt::Display for Point &#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f, &quot;(&#123;&#125;,&#123;&#125;)&quot;,self.x,self.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用newtype模式在外部类型上实现外部trait"><a href="#使用newtype模式在外部类型上实现外部trait" class="headerlink" title="使用newtype模式在外部类型上实现外部trait"></a>使用newtype模式在外部类型上实现外部trait</h2><ul><li>孤儿类型：只有当trait或类型定义在本地包时，才能为该类型实现这个trait</li><li>可以通过newtype模式来绕过这一规则</li></ul><p>——利用tuple struct（元组结构体）创建一个新的类型</p><p>（例子）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use std::fmt;</span><br><span class="line">struct Wrapper(Vec&lt;String&gt;);</span><br><span class="line"></span><br><span class="line">impl fmt::Display for Wrapper&#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#x27;_&gt;) -&gt; fmt::Result &#123;</span><br><span class="line">        write!(f,&quot;[&#123;&#125;]&quot;,self.0.join(&quot;, &quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let w = Wrapper(vec![String::from(&quot;hello&quot;),String::from(&quot;world&quot;)]);</span><br><span class="line">    println!(&quot;w=&#123;&#125;&quot;,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="使用newtype模式实现类型安全和抽象"><a href="#使用newtype模式实现类型安全和抽象" class="headerlink" title="使用newtype模式实现类型安全和抽象"></a>使用newtype模式实现类型安全和抽象</h2><ul><li>newtype模式可以：</li></ul><p>——用来静态的保证各种值之间不会混淆并表明值的单位</p><p>——为类型的某些细节提供抽象能力</p><p>——通过轻量级的封装来隐藏内部实现细节</p><h2 id="适用类型别名创建类型同义词"><a href="#适用类型别名创建类型同义词" class="headerlink" title="适用类型别名创建类型同义词"></a>适用类型别名创建类型同义词</h2><ul><li>Rust提供了类型别名的功能：——为现有的类型生产另外的名称（同义词）——并不是一个独立的类型——使用type关键字</li><li>主要用途：减少代码的字符重复</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn takes_long_type(f: Box&lt;dyn Fn()+Send+&#x27;static&gt;)&#123;</span><br><span class="line">    //snip</span><br><span class="line">&#125;</span><br><span class="line">fn returns_long_type()-&gt;Box&lt;dyn Fn()+Send+&#x27;static&gt;&#123;</span><br><span class="line">    Box::new(|| println!(&quot;hi&quot;))</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let f:Box&lt;dyn Fn()+Send+&#x27;static&gt; = Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类型别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">type Thunk = Box&lt;dyn Fn()+Send+&#x27;static&gt;;</span><br><span class="line">fn takes_long_type(f: Thunk)&#123;</span><br><span class="line">    //snip</span><br><span class="line">&#125;</span><br><span class="line">fn returns_long_type()-&gt;Thunk&#123;</span><br><span class="line">    Box::new(|| println!(&quot;hi&quot;))</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let f:Thunk = Box::new(|| println!(&quot;hi&quot;));</span><br><span class="line">&#125;</span><br><span class="line">use std::io::Error;</span><br><span class="line">use std::fmt;</span><br><span class="line">pub trait Write &#123;</span><br><span class="line">    fn write(&amp;mut self,buf: &amp;[u8])-&gt;Result&lt;usize,Error&gt;;</span><br><span class="line">    fn flush(&amp;mut self)-&gt;Result&lt;(),Error&gt;;</span><br><span class="line">    fn write_all(&amp;mut self,buf: &amp;[u8])-&gt;Result&lt;(),Error&gt;;</span><br><span class="line">    fn write_fmt(&amp;mut self,fmt: fmt::Arguments)-&gt;Result&lt;(),Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类型别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">use std::io::Error;</span><br><span class="line">use std::fmt;</span><br><span class="line">// type Result&lt;T&gt; = Result&lt;T,std::io::Error&gt;;标准库中定义了这个</span><br><span class="line">type Result&lt;T&gt; = std::io::Result&lt;T&gt;;</span><br><span class="line">pub trait Write &#123;</span><br><span class="line">    fn write(&amp;mut self,buf: &amp;[u8])-&gt;Result&lt;usize&gt;;</span><br><span class="line">    fn flush(&amp;mut self)-&gt;Result&lt;()&gt;;</span><br><span class="line">    fn write_all(&amp;mut self,buf: &amp;[u8])-&gt;Result&lt;()&gt;;</span><br><span class="line">    fn write_fmt(&amp;mut self,fmt: fmt::Arguments)-&gt;Result&lt;()&gt;;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h2><ul><li>有一个名为！的特殊类型：</li></ul><p>——它没有任何值，行话成为空类型（empty type）</p><p>——我们倾向于叫它never类型，因为它在不反悔的函数中充当返回类型</p><ul><li>不返回值的函数也被称作发散函数（diverging fuction)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fn bar() -&gt; !&#123;</span><br><span class="line">    //return (),返回了单元类型,但是不可能创建出返回!类型的函数</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let guess = &quot;&quot;;</span><br><span class="line">    loop&#123;</span><br><span class="line">        let guess:u32 = match guess.trim().parse() &#123;</span><br><span class="line">            Ok(num) =&gt; num,</span><br><span class="line">            Err(_) =&gt; continue,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match表达式要求各个分支返回的类型是相同的，而continue会返回never类型，该类型可以安全地强制转换为num所对应的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T&gt; Option&lt;T&gt;&#123;</span><br><span class="line">    pub fn unwrap(self) -&gt; T&#123;</span><br><span class="line">        match self&#123;</span><br><span class="line">            Some(val) =&gt; val,</span><br><span class="line">            None=&gt;panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic！返回never类型</p><h2 id="动态大小和Sized-Trait"><a href="#动态大小和Sized-Trait" class="headerlink" title="动态大小和Sized Trait"></a>动态大小和Sized Trait</h2><ul><li>Rust 需要在编译时确定为一个特定类型的值分配多少空间</li><li>动态大小的类型（Dynamically Sized Types,DST）的概念:</li></ul><p>—— 编写代码时使用只有在运行时才能确定大小的值</p><ul><li>str是动态大小的类型（注意不是&amp;str）:只有运行时才能确定字符串的长度</li></ul><p>—— 以下代码无法正常工作:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let s1:str = &quot;Hello therel&quot;;</span><br><span class="line">let s2:str = &quot;How is it going&quot;;</span><br></pre></td></tr></table></figure><p>因为他们都是同一个类型，需要的空间应该一样，但是这里声明时没有确定共同的空间</p><p>解决办法: 使用&amp;str字符串切片类型</p><h2 id="Rust使用动态大小类型的通用方式"><a href="#Rust使用动态大小类型的通用方式" class="headerlink" title="Rust使用动态大小类型的通用方式"></a>Rust使用动态大小类型的通用方式</h2><ul><li>附带一些额外的元数据来存储动态信息的大小—— 使用动态大小类型时总会把它的值放在某种指针后面</li></ul><h2 id="另外一种动态大小的类型：trait"><a href="#另外一种动态大小的类型：trait" class="headerlink" title="另外一种动态大小的类型：trait"></a>另外一种动态大小的类型：trait</h2><ul><li>每个trait都是一个动态大小的类型，可以通过名称对其进行引用</li><li>为了将trait用作trait对象，必须将它放置在某种指针之后</li></ul><p>—— 例如 &amp;dyn Trait 或 Box<dyn Trait> (Rc<dyn Trait>) 之后</p><h2 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a>Sized trait</h2><ul><li>为了处理动态大小的类型，Rust提供了一个Sized trait来确定一个类型的大小在编译时是否已知——<strong>编译时可计算出大小的类型会自动实现这一trait</strong>——<strong>Rust还会为每一个泛型函数隐式的添加Sized约束</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T&gt;(t:T)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">fn generic&lt;T: Sized&gt;(t:T)&#123;</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，泛型函数只能被用于编译时已经知道大小的类型，可以通过特殊语法来解除这一限制</li></ul><h2 id="Sized-trait约束"><a href="#Sized-trait约束" class="headerlink" title="?Sized trait约束"></a>?Sized trait约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T: ?Sized&gt;(t:&amp;T)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T可能是也可能不是Sized</li><li>这个语法只能用在Sized上面，不能被用于其它trait</li></ul><h1 id="高级函数和闭包"><a href="#高级函数和闭包" class="headerlink" title="高级函数和闭包"></a>高级函数和闭包</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li>可以将函数传递给其它函数</li><li>函数在传递过程中会被强制转换为fn类型</li><li>fn类型就是 <strong>函数指针(function pointer)</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn add_one(x:i32)-&gt;i32&#123;</span><br><span class="line">    x+1</span><br><span class="line">&#125;</span><br><span class="line">fn do_twice(f: fn(i32)-&gt;i32,arg:i32)-&gt;i32&#123;</span><br><span class="line">    f(arg) + f(arg)</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    let answer = do_twice(add_one, 5);</span><br><span class="line">    println!(&quot;The answer is:&#123;&#125;&quot;,answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针与闭包的不同"><a href="#函数指针与闭包的不同" class="headerlink" title="函数指针与闭包的不同"></a>函数指针与闭包的不同</h2><ul><li>fn是一个类型而不是一个trait</li></ul><p>——可以直接指定fn为参数类型，不用声明一个以Fn trait为约束的泛型参数</p><ul><li>函数指针实现了全部3种闭包trait（Fn,FnMut,FnOnce）:</li></ul><p>——总是可以把函数指针用作参数传递给一个接受闭包的参数</p><p>——所以，倾向于搭配闭包trait的泛型来编写函数：可以同时接收闭包和普通函数</p><ul><li>某些情景，只想接收fn而不接收闭包</li></ul><p>——与外部不支持闭包的代码交互：C函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fn main()&#123;</span><br><span class="line">    let list_of_numbers = vec![1,2,3];</span><br><span class="line">    let list_of_strings:Vec&lt;String&gt; = list_of_numbers</span><br><span class="line">    .iter()</span><br><span class="line">    .map(|i| i.to_string())</span><br><span class="line">    .collect();</span><br><span class="line"></span><br><span class="line">    let list_of_numbers = vec![1,2,3];</span><br><span class="line">    let list_of_strings: Vec&lt;String&gt; = list_of_numbers</span><br><span class="line">    .iter()</span><br><span class="line">    .map(ToString::to_string)</span><br><span class="line">    .collect();</span><br><span class="line">&#125;</span><br><span class="line">fn main()&#123;</span><br><span class="line">    enum Status&#123;</span><br><span class="line">        Value(u32),</span><br><span class="line">        Stop,</span><br><span class="line">    &#125;</span><br><span class="line">    let v = Status::Value(3);</span><br><span class="line">    let list_of_statuses:Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h2><ul><li>闭包使用trait进行表达，无法在函数中直接返回一个闭包，可以将一个实现了该trait的具体类型作为返回值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// fn returns_closure()-&gt;Fn(i32)-&gt;i32&#123;//返回类型大小不固定</span><br><span class="line">//     |x| x+1</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">fn returns_closure() -&gt; Box&lt;dyn Fn(i32)-&gt;i32&gt;&#123;</span><br><span class="line">    Box::new(|x| x+1)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">fn main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p><a href="https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html#宏">https://kaisery.github.io/trpl-zh-cn/ch19-06-macros.html#%E5%AE%8F</a></p><h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice</span><br><span class="line">    assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 1, 2), &quot;21&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;1&#125;&#123;&#125;&#123;0&#125;&#123;&#125;&quot;, 1, 2), &quot;2112&quot;);</span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;&#123;argument&#125;&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot;</span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;&#123;name&#125;&#123;&#125;&quot;, 1, name = 2), &quot;21&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;,a = &quot;a&quot;, b = &#x27;b&#x27;, c = 3 ), &quot;a 3 b&quot;);</span><br><span class="line">    </span><br><span class="line">    // named argument must be placed after other arguments</span><br><span class="line">    println!(&quot;&#123;abc&#125; &#123;0&#125;&quot;, 2, abc = &quot;def&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h2><p>默认情况下，通过空格来填充字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // the following two are padding with 5 spaces</span><br><span class="line">    println!(&quot;Hello &#123;:5&#125;!&quot;, &quot;x&quot;); // =&gt;  &quot;Hello x    !&quot;  </span><br><span class="line">    println!(&quot;Hello &#123;:1$&#125;!&quot;, &quot;x&quot;, 5); // =&gt;  &quot;Hello x    !&quot;</span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;1:0$&#125;!&quot;, 5, &quot;x&quot;), &quot;Hello x    !&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;:width$&#125;!&quot;, &quot;x&quot;, width = 5), &quot;Hello x    !&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左对齐, 右对齐, 使用指定的字符填充</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // left align</span><br><span class="line">    println!(&quot;Hello &#123;:&lt;5&#125;!&quot;, &quot;x&quot;); // =&gt; Hello x    !</span><br><span class="line">    // right align</span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;:&gt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello     x!&quot;);</span><br><span class="line">    // center align</span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;:^5&#125;!&quot;, &quot;x&quot;), &quot;Hello   x  !&quot;);</span><br><span class="line"></span><br><span class="line">    // left align, pad with &#x27;&amp;&#x27;</span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x&amp;&amp;&amp;&amp;!&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还能使用 0 来填充数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Hello &#123;:5&#125;!&quot;, 5); // =&gt; Hello     5!</span><br><span class="line">    println!(&quot;Hello &#123;:+&#125;!&quot;, 5); // =&gt;  Hello +5!</span><br><span class="line">    println!(&quot;Hello &#123;:05&#125;!&quot;, 5); // =&gt; Hello 00005!</span><br><span class="line">    println!(&quot;Hello &#123;:05&#125;!&quot;, -5); // =&gt; Hello -0005!</span><br><span class="line"></span><br><span class="line">    assert!(format!(&quot;&#123;number:0&gt;width$&#125;&quot;, number=1, width=6) == &quot;000001&quot;);</span><br><span class="line">    </span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h2><p>浮点数精度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = 3.1415926;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:.1$&#125;&quot;, v, 4); // same as &#123;:.4&#125; =&gt; 3.1416 </span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;&#123;:.2&#125;&quot;, v), &quot;3.14&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:+.2&#125;&quot;, v), &quot;+3.14&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:.0&#125;&quot;, v), &quot;3&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = &quot;Hello, world!&quot;;</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;0:.5&#125;&quot;, s); // =&gt; Hello</span><br><span class="line"></span><br><span class="line">    assert_eq!(format!(&quot;Hello &#123;1:.0$&#125;!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制，八进制，十六进制"><a href="#二进制，八进制，十六进制" class="headerlink" title="二进制，八进制，十六进制"></a>二进制，八进制，十六进制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:#b&#125;&quot;, 27), &quot;0b11011&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:#o&#125;&quot;, 27), &quot;0o33&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:#x&#125;&quot;, 27), &quot;0x1b&quot;);</span><br><span class="line">    assert_eq!(format!(&quot;&#123;:#X&#125;&quot;, 27), &quot;0x1B&quot;);</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:x&#125;!&quot;, 27); // hex with no prefix =&gt; 1b</span><br><span class="line"></span><br><span class="line">    println!(&quot;&#123;:#010b&#125;&quot;, 27); // pad binary with 0, width = 10,  =&gt; 0b00011011</span><br><span class="line"></span><br><span class="line">   println!(&quot;Success!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="捕获环境中的值"><a href="#捕获环境中的值" class="headerlink" title="捕获环境中的值"></a>捕获环境中的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fn get_person() -&gt; String &#123;</span><br><span class="line">    String::from(&quot;sunface&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn get_format() -&gt; (usize, usize) &#123;</span><br><span class="line">    (4, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let person = get_person();</span><br><span class="line">    println!(&quot;Hello, &#123;person&#125;!&quot;);</span><br><span class="line"></span><br><span class="line">    let (width, precision) = get_format();</span><br><span class="line">    let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)];</span><br><span class="line">    /* Make it print:</span><br><span class="line">    sunface:   99.1</span><br><span class="line">    jack:   60.3</span><br><span class="line">    */</span><br><span class="line">    for (name, score) in scores &#123;</span><br><span class="line">        println!(&quot;&#123;name&#125;: &#123;score:width$.precision$&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指数，指针地址，转义"><a href="#指数，指针地址，转义" class="headerlink" title="指数，指针地址，转义"></a>指数，指针地址，转义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    // 指数</span><br><span class="line">    println!(&quot;&#123;:2e&#125;&quot;, 1000000000); // =&gt; 1e9</span><br><span class="line">    println!(&quot;&#123;:2E&#125;&quot;, 1000000000); // =&gt; 1E9</span><br><span class="line"></span><br><span class="line">    // 指针地址</span><br><span class="line">    let v= vec![1, 2, 3];</span><br><span class="line">    println!(&quot;&#123;:p&#125;&quot;, v.as_ptr()); // =&gt; 0x600002324050</span><br><span class="line"></span><br><span class="line">    // 转义</span><br><span class="line">    println!(&quot;Hello &#123;&#123;&#125;&#125;&quot;); // =&gt; Hello &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="1-错误处理："><a href="#1-错误处理：" class="headerlink" title="1.错误处理："></a>1.错误处理：</h2><h3 id="unreachable"><a href="#unreachable" class="headerlink" title="unreachable!()"></a>unreachable!()</h3><p>这是标记程序不应输入的路径的标准宏。如果程序进入这些路径，程序将panicked并返回”‘internal error: entered unreachable code’”错误消息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">level</span> = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stage</span> = <span class="keyword">match</span> level &#123;</span><br><span class="line">        <span class="number">1</span>...<span class="number">5</span> =&gt; <span class="string">&quot;beginner&quot;</span>,</span><br><span class="line">        <span class="number">6</span>...<span class="number">10</span> =&gt; <span class="string">&quot;intermediate&quot;</span>,</span><br><span class="line">        <span class="number">11</span>...<span class="number">20</span> =&gt; <span class="string">&quot;expert&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, stage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- Compile time error --------------</span></span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code<span class="string">&#x27;, src/main.rs:7:20</span></span><br></pre></td></tr></table></figure><p>我们也可以为此设置自定义错误消息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- with a custom message ---</span></span><br><span class="line">_ =&gt; <span class="built_in">unreachable!</span>(<span class="string">&quot;Custom message&quot;</span>),</span><br><span class="line"><span class="comment">// -------------- Compile time error --------------</span></span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code: Custom message<span class="string">&#x27;, src/main.rs:7:20</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// --- with debug data ---</span></span><br><span class="line"><span class="string">_ =&gt; unreachable!(&quot;level is &#123;&#125;&quot;, level),</span></span><br><span class="line"><span class="string">// -------------- Compile time error --------------</span></span><br><span class="line"><span class="string">thread &#x27;</span>main<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code: level is <span class="number">22</span><span class="string">&#x27;, src/main.rs:7:14</span></span><br></pre></td></tr></table></figure><h2 id="2-misconception-corollaries"><a href="#2-misconception-corollaries" class="headerlink" title="2.misconception corollaries"></a>2.misconception corollaries</h2><h3 id="2-1-if-T-39-static-then-T-must-be-valid-for-the-entire-program"><a href="#2-1-if-T-39-static-then-T-must-be-valid-for-the-entire-program" class="headerlink" title="2.1 if T: &#39;static then T must be valid for the entire program"></a>2.1 if <code>T: &#39;static</code> then <code>T</code> must be valid for the entire program</h3><p><strong>Misconception Corollaries</strong></p><ul><li><code>T: &#39;static</code> should be read as <em>“<code>T</code> has a <code>&#39;static</code> lifetime”</em></li><li><code>&amp;&#39;static T</code> and <code>T: &#39;static</code> are the same thing</li><li>if <code>T: &#39;static</code> then <code>T</code> must be immutable</li><li>if <code>T: &#39;static</code> then <code>T</code> can only be created at compile time</li></ul><p>Most Rust beginners get introduced to the <code>&#39;static</code> lifetime for the first time in a code example that looks something like this:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_literal</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;str literal&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>They get told that <code>&quot;str literal&quot;</code> is hardcoded into the compiled binary and is loaded into read-only memory at run-time so it’s immutable and valid for the entire program and that’s what makes it <code>&#39;static</code>. These concepts are further reinforced by the rules surrounding defining <code>static</code> variables using the <code>static</code> keyword.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: This example is purely for illustrative purposes.</span></span><br><span class="line"><span class="comment">// Never use `static mut`. It&#x27;s a footgun. There are</span></span><br><span class="line"><span class="comment">// safe patterns for global mutable singletons in Rust but</span></span><br><span class="line"><span class="comment">// those are outside the scope of this article.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> MUT_BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// ❌ - mutating static is unsafe</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">99</span>, MUT_BYTES[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Regarding <code>static</code> variables</p><ul><li>they can only be created at compile-time</li><li>they should be immutable, mutating them is unsafe</li><li>they’re valid for the entire program</li></ul><p>The <code>&#39;static</code> lifetime was probably named after the default lifetime of <code>static</code> variables, right? So it makes sense that the <code>&#39;static</code> lifetime has to follow all the same rules, right?</p><p>Well yes, but a type <em>with</em> a <code>&#39;static</code> lifetime is different from a type <em>bounded by</em> a <code>&#39;static</code> lifetime. The latter can be dynamically allocated at run-time, can be safely and freely mutated, can be dropped, and can live for arbitrary durations.</p><p>It’s important at this point to distinguish <code>&amp;&#39;static T</code> from <code>T: &#39;static</code>.</p><p><code>&amp;&#39;static T</code> is an immutable reference to some <code>T</code> that can be safely held indefinitely long, including up until the end of the program. This is only possible if <code>T</code> itself is immutable and does not move <em>after the reference was created</em>. <code>T</code> does not need to be created at compile-time. It’s possible to generate random dynamically allocated data at run-time and return <code>&#39;static</code> references to it at the cost of leaking memory, e.g.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate random &#x27;static str refs at run-time</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rand_str_generator</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(rand_string.<span class="title function_ invoke__">into_boxed_str</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T: &#39;static</code> is some <code>T</code> that can be safely held indefinitely long, including up until the end of the program. <code>T: &#39;static</code> includes all <code>&amp;&#39;static T</code> however it also includes all owned types, like <code>String</code>, <code>Vec</code>, etc. The owner of some data is guaranteed that data will never get invalidated as long as the owner holds onto it, therefore the owner can safely hold onto the data indefinitely long, including up until the end of the program. <code>T: &#39;static</code> should be read as <em>“<code>T</code> is bounded by a <code>&#39;static</code> lifetime”</em> not <em>“<code>T</code> has a <code>&#39;static</code> lifetime”</em>. A program to help illustrate these concepts:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">drop_static</span>&lt;T: <span class="symbol">&#x27;static</span>&gt;(t: T) &#123;</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand::<span class="title function_ invoke__">random</span>() &#123;</span><br><span class="line">            <span class="comment">// all the strings are randomly generated</span></span><br><span class="line">            <span class="comment">// and dynamically allocated at run-time</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            strings.<span class="title function_ invoke__">push</span>(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strings are owned types so they&#x27;re bounded by &#x27;static</span></span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">mut</span> string <span class="keyword">in</span> strings &#123;</span><br><span class="line">        <span class="comment">// all the strings are mutable</span></span><br><span class="line">        string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;a mutation&quot;</span>);</span><br><span class="line">        <span class="comment">// all the strings are droppable</span></span><br><span class="line">        <span class="title function_ invoke__">drop_static</span>(string); <span class="comment">// ✅</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all the strings have been invalidated before the end of the program</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I am the end of the program&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Key Takeaways</strong></p><ul><li><p><code>T: &#39;static</code> should be read as <em>“<code>T</code> is bounded by a <code>&#39;static</code> lifetime”</em></p></li><li><p>if <code>T: &#39;static</code> then <code>T</code> can be a borrowed type with a <code>&#39;static</code> lifetime <em>or</em> an owned type</p></li><li><p>since</p></li></ul>  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">T:</span> <span class="comment">&#x27;static</span></span><br></pre></td></tr></table></figure><p>  includes owned types that means</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">T</span></span><br></pre></td></tr></table></figure><ul><li>can be dynamically allocated at run-time</li><li>does not have to be valid for the entire program</li><li>can be safely and freely mutated</li><li>can be dynamically dropped at run-time</li><li>can have lifetimes of different durations</li></ul>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2785 将字符串中的元音字母排序</title>
      <link href="/posts/2785/"/>
      <url>/posts/2785/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-11</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2785将字符串中的元音字母排序" href="https://leetcode.cn/problems/sort-vowels-in-a-string/description/?envType=daily-question&envId=2025-09-11"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2785将字符串中的元音字母排序</p><p class="url">https://leetcode.cn/problems/sort-vowels-in-a-string/description/?envType=daily-question&envId=2025-09-11</p></div></a></div></p><p>我采用先提取再排序，最后覆盖的方法，算法复杂度为 O(nlogn)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">      c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递增</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">comparefunc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">char</span> *)a - *(<span class="type">char</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">sortVowels</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> vowel_count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *str, *vowels;</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="comment">// 注意要复制len + 1个字节</span></span><br><span class="line">  str = <span class="built_in">malloc</span>((len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  <span class="built_in">strcpy</span>(str, s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVowel(str[i])) &#123;</span><br><span class="line">      vowel_count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vowels = (<span class="type">char</span> *)<span class="built_in">malloc</span>(vowel_count * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; index &lt; vowel_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVowel(str[i])) &#123;</span><br><span class="line">      vowels[index] = str[i];</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(vowels, vowel_count, <span class="keyword">sizeof</span>(<span class="type">char</span>), comparefunc);</span><br><span class="line">  index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; index &lt; vowel_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVowel(str[i])) &#123;</span><br><span class="line">      str[i] = vowels[index];</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(vowels);</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 常量字符串不可修改</span></span><br><span class="line">  <span class="type">char</span> *s = <span class="string">&quot;lEetcOde&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *str;</span><br><span class="line">  str = sortVowels(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>推荐方法，利用计数排序的思想，即开辟一个将要排序的数的区间大小的数组，将要排序的数放入对应下标的数组元素中计数，然后累加和可以求得每个数前面有多少个数，从而直接确定这个数在排序后的数组中的位置，算法复杂度在 O(n)</p><div class="tag link"><a class="link-card" title="ASCII码表" href="https://www.runoob.com/w3cnote/ascii.html"><div class="left"><img src="https://static.char123.com/images/favicon.ico"/></div><div class="right"><p class="text">ASCII码表</p><p class="url">https://www.runoob.com/w3cnote/ascii.html</p></div></a></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">sortVowels</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> vowels[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">58</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">58</span>; i++) &#123;</span><br><span class="line">        cnt[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> idx = vowels[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        cnt[idx] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">// cnt数组中不为-1的即为元音字母</span></span><br><span class="line">        <span class="type">int</span> idx = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[idx] != <span class="number">-1</span>) &#123;</span><br><span class="line">            cnt[idx]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *res = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(res, s);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> pos = res[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[pos] != <span class="number">-1</span>) &#123;<span class="comment">//如果是元音字母</span></span><br><span class="line">            <span class="keyword">while</span> (cnt[idx] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                idx++;<span class="comment">//找到下一个元音字母</span></span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = idx + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            cnt[idx]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="计数排序" href="https://www.runoob.com/w3cnote/counting-sort.html"><div class="left"><img src="https://static.char123.com/images/favicon.ico"/></div><div class="right"><p class="text">计数排序</p><p class="url">https://www.runoob.com/w3cnote/counting-sort.html</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C</title>
      <link href="/posts/42882/"/>
      <url>/posts/42882/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-07-19</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="常见整数的范围"><a href="#常见整数的范围" class="headerlink" title="常见整数的范围"></a>常见整数的范围</h2><div class="table-container"><table><thead><tr><th>数据类型</th><th>字节数</th><th>十进制取值范围</th><th>科学计数法表示（约）</th></tr></thead><tbody><tr><td><code>char</code></td><td>1</td><td>-128 ~ 127</td><td>-1.28×10² ~ 1.27×10²</td></tr><tr><td><code>unsigned char</code></td><td>1</td><td>0 ~ 255</td><td>0 ~ 2.55×10²</td></tr><tr><td><code>short</code></td><td>2</td><td>-32,768 ~ 32,767</td><td>-3.28×10⁴ ~ 3.27×10⁴</td></tr><tr><td><code>unsigned short</code></td><td>2</td><td>0 ~ 65,535</td><td>0 ~ 6.55×10⁴</td></tr><tr><td><code>int</code></td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td><td>-2.15×10⁹ ~ 2.15×10⁹</td></tr><tr><td><code>unsigned int</code></td><td>4</td><td>0 ~ 4,294,967,295</td><td>0 ~ 4.29×10⁹</td></tr><tr><td><code>long</code> (Linux 64 位)</td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td><td>±9.22×10¹⁸</td></tr><tr><td><code>unsigned long</code></td><td>8</td><td>0 ~ 18,446,744,073,709,551,615</td><td>0 ~ 1.84×10¹⁹</td></tr><tr><td><code>long long</code></td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td><td>±9.22×10¹⁸</td></tr><tr><td><code>unsigned long long</code></td><td>8</td><td>0 ~ 18,446,744,073,709,551,615</td><td>0 ~ 1.84×10¹⁹</td></tr></tbody></table></div><ul><li>long 的字节数在 不同平台上可能不同，如在 64 位 Linux 系统上通常为 8 字节。</li><li>实际大小和范围由编译器及目标平台的 data model 决定，如 LP64（Linux）/LLP64（Windows）</li></ul><h2 id="ASCII-表"><a href="#ASCII-表" class="headerlink" title="ASCII 表"></a>ASCII 表</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509121053858.png" alt="ASCII可显示字符"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509121053206.png" alt="ASCII控制字符"></p><h1 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>%c 和空白的区别</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br></pre></td></tr></table></figure><p>会 原封不动 读取一个字符，包括空格、制表符、换行 \n。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch);</span><br></pre></td></tr></table></figure><p>因为格式字符串里有个 空格，scanf 会先跳过所有 空白字符（space、\t、\n），再读一个有效字符。</p><p>总结：</p><ul><li>%d、%f 等数字格式符号：默认自动跳过空白。</li><li>%c：不会跳过空白，需要 “ %c” 才能忽略空格、换行。</li><li>原理：scanf 的格式字符串里，空白符（空格、\n、\t）意味着“匹配任意数量的空白”。</li></ul><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><p>getline() 的返回值是读取的字符数(包括换行符)</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>char **lineptr</code></td><td>指向一个 <code>char*</code> 指针（用来存储读入的字符串，函数内部会自动分配/扩展内存）</td></tr><tr><td><code>size_t *n</code></td><td>指向缓冲区大小（初始为 0），函数根据需要动态分配/扩展内存</td></tr><tr><td><code>FILE *stream</code></td><td>输入流，例如 <code>stdin</code>、文件句柄等</td></tr></tbody></table></div><p>返回值</p><ul><li>成功：返回读取到的字符数（包括换行符 <code>\n</code>，但不包括终止符 <code>\0</code>）</li><li>失败：返回 <code>-1</code>，并设置 <code>errno</code></li></ul><p>使用 getline 需要包含 GNU 扩展定义的 <stdio.h> 和 <stdlib.h>，但更关键的是在 某些非 POSIX 平台（如 Windows 或老标准 C 编译器） 中，getline() 并不是标准 C 函数。<br>综合解决方法（适用于 Linux/GCC 环境）：<br>确保你包含了以下头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选：启用 GNU 扩展</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用strcspn</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了 ssize_t 类型（带符号的 size_t），常用于 read, write, getline, readlink 等函数的返回值</span></span><br><span class="line"><span class="comment">// 是 POSIX 标准的一部分，不是 C 标准库的一部分，所以在 GNU/Linux 平台使用 POSIX API 时必须包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">// 启用 getline 所需的 GNU 扩展</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>          <span class="comment">// 提供 errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>         <span class="comment">// 提供 strerror()</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一行文本（按 Ctrl+D 或 Ctrl+Z + Enter 结束）：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;  <span class="comment">// 使用前清零</span></span><br><span class="line">    nread = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入结束（EOF）\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 打印 errno 的值和对应信息</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getline 失败，errno = %d: %s\n&quot;</span>, errno, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取了 %zd 字符：%s&quot;</span>, nread, line);</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>printf 函数详解：<br>下面是 printf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure><p>参数</p><ul><li>format — 这是字符串，包含了要被写入到标准输出 stdout 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li><li>format 标签属性是</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-attr">[flags]</span><span class="selector-attr">[width]</span><span class="selector-attr">[.precision]</span><span class="selector-attr">[length]</span>specifier</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">格式字符</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">a, A</td><td style="text-align:left">以十六进制形式输出浮点数(C99 新增)。实例 <strong>printf(“pi=%a\n”, 3.14);</strong> 输出 <strong>pi=0x1.91eb86p+1</strong>。</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">以八进制形式输出无符号整数(不输出前缀 0)</td></tr><tr><td style="text-align:left">x,X</td><td style="text-align:left">以十六进制形式输出无符号整数(不输出前缀 Ox)</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">以十进制形式输出无符号整数</td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">以小数形式输出单、双精度实数</td></tr><tr><td style="text-align:left">e,E</td><td style="text-align:left">以指数形式输出单、双精度实数</td></tr><tr><td style="text-align:left">g,G</td><td style="text-align:left">以%f 或%e 中较短的输出宽度输出单、双精度实数</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">输出单个字符</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">输出字符串</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">输出指针地址</td></tr><tr><td style="text-align:left">lu</td><td style="text-align:left">32 位无符号整数</td></tr><tr><td style="text-align:left">llu</td><td style="text-align:left">64 位无符号整数</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">flags（标识）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-</td><td style="text-align:left">在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td></tr><tr><td style="text-align:left">空格</td><td style="text-align:left">如果没有写入任何符号，则在该值前面插入一个空格。</td></tr><tr><td style="text-align:left">#</td><td style="text-align:left">与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">width（宽度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">(number)</td><td style="text-align:left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">.precision（精度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">.number</td><td style="text-align:left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。</td></tr><tr><td style="text-align:left">.*</td><td style="text-align:left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">length（长度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">h</td><td style="text-align:left">参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。</td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</td></tr></tbody></table></div><ul><li><p>附加参数</p><blockquote><p>根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p></blockquote></li><li><p>返回值</p><blockquote><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p></blockquote></li></ul><h2 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h2><h3 id="错误状态宏定义"><a href="#错误状态宏定义" class="headerlink" title="错误状态宏定义"></a>错误状态宏定义</h3><p>在 <code>&lt;math.h&gt;</code> 中，有一些宏用于表示数学函数的错误状态：</p><div class="table-container"><table><thead><tr><th style="text-align:left">宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>HUGE_VAL</code></td><td style="text-align:left">当函数结果溢出时返回的值（正无穷大）。此宏代表一个非常大的双精度浮点数，通常用来作为某些数学函数在结果超出可表示范围时的返回值。当一个函数的结果太大以至于无法用正常的浮点数表示（即发生上溢）时，会设置 errno 为 ERANGE（范围错误），并返回 HUGE_VAL 或其负值（对于负无穷大）。</td></tr><tr><td style="text-align:left"><code>HUGE_VALF</code></td><td style="text-align:left">当函数结果溢出时返回的值（正无穷大，浮点型）</td></tr><tr><td style="text-align:left"><code>HUGE_VALL</code></td><td style="text-align:left">当函数结果溢出时返回的值（正无穷大，长双精度）</td></tr><tr><td style="text-align:left"><code>INFINITY</code></td><td style="text-align:left">正无穷大</td></tr><tr><td style="text-align:left"><code>NAN</code></td><td style="text-align:left">非数字值（Not-A-Number）</td></tr><tr><td style="text-align:left"><code>FP_INFINITE</code></td><td style="text-align:left">表示无穷大</td></tr><tr><td style="text-align:left"><code>FP_NAN</code></td><td style="text-align:left">表示非数字值</td></tr><tr><td style="text-align:left"><code>FP_NORMAL</code></td><td style="text-align:left">表示正常的浮点数</td></tr><tr><td style="text-align:left"><code>FP_SUBNORMAL</code></td><td style="text-align:left">表示次正规数</td></tr><tr><td style="text-align:left"><code>FP_ZERO</code></td><td style="text-align:left">表示零</td></tr></tbody></table></div><h3 id="库函数-1"><a href="#库函数-1" class="headerlink" title="库函数"></a>库函数</h3><p>下面列出了头文件 math.h 中定义的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">double acos(double x)</td><td style="text-align:left">返回以弧度表示的 x 的反余弦。</td></tr><tr><td style="text-align:left">double asin(double x)</td><td style="text-align:left">返回以弧度表示的 x 的反正弦。</td></tr><tr><td style="text-align:left">double atan(double x)</td><td style="text-align:left">返回以弧度表示的 x 的反正切。</td></tr><tr><td style="text-align:left">double atan2(double y, double x)</td><td style="text-align:left">返回以弧度表示的 y/x 的反正切。y 和 x 的值的符号决定了正确的象限。</td></tr><tr><td style="text-align:left">double cos(double x)</td><td style="text-align:left">返回弧度角 x 的余弦。</td></tr><tr><td style="text-align:left">double cosh(double x)</td><td style="text-align:left">返回 x 的双曲余弦。</td></tr><tr><td style="text-align:left">double sin(double x)</td><td style="text-align:left">返回弧度角 x 的正弦。</td></tr><tr><td style="text-align:left">double sinh(double x)</td><td style="text-align:left">返回 x 的双曲正弦。</td></tr><tr><td style="text-align:left">double tanh(double x)</td><td style="text-align:left">返回 x 的双曲正切。</td></tr><tr><td style="text-align:left">double exp(double x)</td><td style="text-align:left">返回 e 的 x 次幂的值。</td></tr><tr><td style="text-align:left">double frexp(double x, int *exponent)</td><td style="text-align:left">把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x = mantissa * 2 ^ exponent。</td></tr><tr><td style="text-align:left">double ldexp(double x, int exponent)</td><td style="text-align:left">返回 x 乘以 2 的 exponent 次幂。</td></tr><tr><td style="text-align:left">double log(double x)</td><td style="text-align:left">返回 x 的自然对数（基数为 e 的对数）。</td></tr><tr><td style="text-align:left">double log10(double x)</td><td style="text-align:left">返回 x 的常用对数（基数为 10 的对数）。</td></tr><tr><td style="text-align:left">double modf(double x, double *integer)</td><td style="text-align:left">返回值为小数部分（小数点后的部分），并设置 integer 为整数部分。</td></tr><tr><td style="text-align:left">double pow(double x, double y)</td><td style="text-align:left">返回 x 的 y 次幂。</td></tr><tr><td style="text-align:left">double sqrt(double x)</td><td style="text-align:left">返回 x 的平方根。</td></tr><tr><td style="text-align:left">double ceil(double x)</td><td style="text-align:left">返回大于或等于 x 的最小的整数值。</td></tr><tr><td style="text-align:left">double fabs(double x)</td><td style="text-align:left">返回 x 的绝对值。</td></tr><tr><td style="text-align:left">double floor(double x)</td><td style="text-align:left">返回小于或等于 x 的最大的整数值。</td></tr><tr><td style="text-align:left">double fmod(double x, double y)</td><td style="text-align:left">返回 x 除以 y 的余数。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>函数名</th><th>作用</th><th>向哪边取整</th></tr></thead><tbody><tr><td><code>round()</code></td><td>四舍五入</td><td>到最近整数</td></tr><tr><td><code>floor()</code></td><td>向下取整（不大于原数的最大整数）</td><td>向 -∞</td></tr><tr><td><code>ceil()</code></td><td>向上取整（不小于原数的最小整数）</td><td>向 +∞</td></tr><tr><td><code>trunc()</code></td><td>去除小数部分（直接截断）</td><td>向 0</td></tr></tbody></table></div><h3 id="常用数学常量"><a href="#常用数学常量" class="headerlink" title="常用数学常量"></a>常用数学常量</h3><p>以下是 <code>&lt;math.h&gt;</code> 中定义的一些常用数学常量：</p><div class="table-container"><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>M_PI</code></td><td style="text-align:left">3.14159265358979323846</td><td style="text-align:left">圆周率 π</td></tr><tr><td style="text-align:left"><code>M_E</code></td><td style="text-align:left">2.71828182845904523536</td><td style="text-align:left">自然对数的底数 e</td></tr><tr><td style="text-align:left"><code>M_LOG2E</code></td><td style="text-align:left">1.44269504088896340736</td><td style="text-align:left">log2(e)</td></tr><tr><td style="text-align:left"><code>M_LOG10E</code></td><td style="text-align:left">0.43429448190325182765</td><td style="text-align:left">log10(e)</td></tr><tr><td style="text-align:left"><code>M_LN2</code></td><td style="text-align:left">0.69314718055994530942</td><td style="text-align:left">ln(2)</td></tr><tr><td style="text-align:left"><code>M_LN10</code></td><td style="text-align:left">2.30258509299404568402</td><td style="text-align:left">ln(10)</td></tr><tr><td style="text-align:left"><code>M_PI_2</code></td><td style="text-align:left">1.57079632679489661923</td><td style="text-align:left">π/2</td></tr><tr><td style="text-align:left"><code>M_PI_4</code></td><td style="text-align:left">0.78539816339744830962</td><td style="text-align:left">π/4</td></tr><tr><td style="text-align:left"><code>M_1_PI</code></td><td style="text-align:left">0.31830988618379067154</td><td style="text-align:left">1/π</td></tr><tr><td style="text-align:left"><code>M_2_PI</code></td><td style="text-align:left">0.63661977236758134308</td><td style="text-align:left">2/π</td></tr><tr><td style="text-align:left"><code>M_2_SQRTPI</code></td><td style="text-align:left">1.12837916709551257390</td><td style="text-align:left">2/√π</td></tr><tr><td style="text-align:left"><code>M_SQRT2</code></td><td style="text-align:left">1.41421356237309504880</td><td style="text-align:left">√2</td></tr><tr><td style="text-align:left"><code>M_SQRT1_2</code></td><td style="text-align:left">0.70710678118654752440</td><td style="text-align:left">1/√2</td></tr></tbody></table></div><h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><h3 id="strdup"><a href="#strdup" class="headerlink" title="strdup"></a>strdup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>相当于strcpy但是会自动分配内存</p><h3 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span></span><br></pre></td></tr></table></figure><p>参数<br>str: 要分割的字符串。在第一次调用时，传入要分割的字符串；后续调用时，传入 NULL，表示继续分割同一个字符串。<br>delim: 分隔符字符串。strtok() 会根据这个字符串中的任意一个字符来分割 str。</p><p>返回值<br>返回指向下一个标记的指针。如果没有更多的标记，则返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">token = strtok(str, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line"><span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;%s\n&quot;</span>, token );</span><br><span class="line"></span><br><span class="line">   token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>修改原字符串: strtok() 会修改传入的字符串，将分隔符替换为 \0（空字符）。因此，原始字符串会被破坏。</li><li>不可重入: strtok() 使用静态缓冲区来保存状态，因此它不是线程安全的。如果在多线程环境中使用，可以考虑使用 strtok_r()（可重入版本）。</li><li>连续分隔符: 如果字符串中有连续的分隔符，strtok() 会忽略它们，并返回下一个有效的标记。</li></ol><p>可重入版本：strtok_r()<br>strtok_r() 是 strtok() 的可重入版本，它允许你在多线程环境中安全地使用。它的原型如下：</p><p>char <em>strtok_r(char </em>str, const char <em>delim, char **saveptr);<br>saveptr: 是一个指向 char</em> 的指针，用于保存分割的状态。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;This is a sample string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *token;</span><br><span class="line">    <span class="type">char</span> *saveptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次调用 strtok_r，传入要分割的字符串</span></span><br><span class="line">    token = strtok_r(str, <span class="string">&quot; &quot;</span>, &amp;saveptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续调用 strtok_r，直到返回 NULL</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line">        token = strtok_r(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>, &amp;saveptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcspn"><a href="#strcspn" class="headerlink" title="strcspn"></a>strcspn</h3><p>strcspn 是 C 标准库 <string.h> 中的一个字符串处理函数，用于查找目标字符串中第一个匹配指定字符集合的字符的位置。</p><ul><li>函数原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *reject)</span>;</span><br></pre></td></tr></table></figure><ul><li>功能说明</li></ul><p>它返回字符串 s 中第一个包含 reject 中任意字符的位置（索引），如果 s 中不包含 reject 中的任何字符，就返回 strlen(s)。</p><blockquote><p>💡 “cspn” 全称是 complement span，意思是：返回“不是 reject 的最长前缀”长度</p></blockquote><ul><li>示例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> pos = <span class="built_in">strcspn</span>(str, <span class="string">&quot;,!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个 &#x27;,&#x27; 或 &#x27;!&#x27; 的位置是：%zu\n&quot;</span>, pos);  <span class="comment">// 输出 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strspn"><a href="#strspn" class="headerlink" title="strspn"></a>strspn</h3><p>strspn 是 C 语言标准库 <string.h> 中的函数，用来计算一个字符串开头有多少字符全部属于指定的字符集合。<br>strspn 这个函数名来自 “string span” 的缩写，意思是“字符串的跨度”或“字符串中连续满足条件的前缀长度”。</p><p>对比 strcspn</p><div class="table-container"><table><thead><tr><th>函数名</th><th>含义说明</th></tr></thead><tbody><tr><td><code>strspn</code></td><td>span of characters <strong>in</strong> accept</td></tr><tr><td><code>strcspn</code></td><td>span of characters <strong>not in</strong> reject</td></tr></tbody></table></div><p>也就是说：</p><ul><li><p>strspn(s, accept)：从开头开始，统计多少字符在 accept 中</p></li><li><p>strcspn(s, reject)：从开头开始，统计多少字符不在 reject 中</p></li><li><p>函数原型</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *accept)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>功能说明</li></ul><p>strspn(s, accept) 会返回字符串 s 开头连续有多少个字符，全部都出现在 accept 中。</p><ol><li>它不会跳过字符，也不会检查整个字符串；</li><li>一旦遇到一个不属于 accept 的字符，就停止统计；</li><li>返回值是一个 size_t 类型（即无符号整数），表示匹配的长度。</li></ol><ul><li>示例</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;abcabc123&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *accept = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strspn</span>(s, accept);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前缀长度为：%zu\n&quot;</span>, len);  <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>✨ 分析：<br>字符串 s = “abcabc123”<br>以 “a”, “b”, “c” 开头，刚好连着 6 个字符都在 “abc” 中<br>第 7 个字符是 ‘1’，不在 “abc” 中 → 统计停止<br>所以返回 6</p></li><li><p>应用场景<br>📌 检查字符串开头是否只包含某些字符</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strspn</span>(s, <span class="string">&quot;0123456789&quot;</span>) == <span class="built_in">strlen</span>(s)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s 是纯数字\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📌 跳过前缀中所有合法字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot; \t\n hello&quot;</span>;</span><br><span class="line">s += <span class="built_in">strspn</span>(s, <span class="string">&quot; \t\n&quot;</span>);  <span class="comment">// 跳过所有空白字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;剩下：%s\n&quot;</span>, s);  <span class="comment">// 输出 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><p>你可以在标准库函数调用失败时，通过读取 <code>errno</code> 的值来判断失败的<strong>具体原因</strong>，然后使用 <code>perror()</code> 或 <code>strerror(errno)</code> 获取对应的错误描述。</p><hr><p>示例：使用 <code>errno</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;no-such-file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印错误编号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno = %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error code = %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印错误描述</span></span><br><span class="line">        perror(<span class="string">&quot;fopen 失败&quot;</span>);           <span class="comment">// 推荐：自动添加前缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者手动打印错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误信息: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">errno = 2</span><br><span class="line"><span class="keyword">error </span>code = 2</span><br><span class="line">fopen 失败: No such file or directory</span><br><span class="line">错误信息: No such file or directory</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP BombLab AArch64</title>
      <link href="/posts/42881/"/>
      <url>/posts/42881/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>win11 WSL2：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/CCECAA6776058E5E7B3BD5CD47C415D9.png" alt="硬件环境"></p><p>环境搭建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/SJTU-IPADS/OS-Course-Lab.git</span><br><span class="line"><span class="built_in">cd</span> OS-Course-Lab/Lab0</span><br><span class="line"><span class="built_in">sudo</span> apt-get install qemu-user gdb-multiarch</span><br></pre></td></tr></table></figure><p>terminal1<br>可以把答案写在 ans.txt 上，这样已经解过的就不用再敲了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-aarch64 -g 1234 ./bomb &lt; ans.txt</span><br></pre></td></tr></table></figure><p>terminal2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch -ex <span class="string">&quot;set architecture aarch64&quot;</span> -ex <span class="string">&quot;target remote localhost:1234&quot;</span> -ex <span class="string">&quot;file bomb&quot;</span></span><br></pre></td></tr></table></figure><h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>main 函数是有 C 代码的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;phases.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span>* input;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Type in your defuse password!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_0(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_1(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_2(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_3(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_4(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_5(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Congrats! You have defused all phases!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 read_line 的返回值作为参数传递给 phase_x</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225404452.png" alt="image-20250629225404452"></p><p>可以看到，main 函数每次调用 read_line 读取输入，随后调用 phase_x 函数，随后调用 phase_defused 打印信息</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225341441.png" alt="image-20250629225341441"></p><p>函数开头（栈帧设置）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400b10: a9bf7bfd    stp x29, x30, [sp, #-16]!    // 保存帧指针和返回地址到栈上，sp -= 16</span><br><span class="line">400b14: 910003fd    mov x29, sp                  // 设置新的帧指针 x29 = sp</span><br></pre></td></tr></table></figure><p>获取 fgets 的目标缓冲区（x0），准备调用 <code>_IO_fgets</code>：</p><p>该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>可以看到第一个参数是 char*（x0），第二个参数为 int（w1），第三个参数为一个结构体指针（x2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400b18: f00004e0    adrp x0, 49f000</span><br><span class="line">400b1c: f946d000    ldr x0, [x0, #3488]</span><br><span class="line">400b20: f9400002    ldr x2, [x0]                 // FILE *stream</span><br><span class="line"></span><br><span class="line">400b24: 52800a21    mov w1, #0x51                // w1 = 81，最多读取 81 字节</span><br><span class="line"></span><br><span class="line">400b28: d0000500    adrp x0, 4a2000</span><br><span class="line">400b2c: 9104e000    add x0, x0, #0x138           // x0 = 0x4a2000 + 0x138，x0 是目标 buffer 指针</span><br><span class="line"></span><br><span class="line">400b30: 94004a78    bl  413510 &lt;_IO_fgets&gt;       // 调用 _IO_fgets(buffer, 81, stream)</span><br></pre></td></tr></table></figure><blockquote><p>到这里，函数已经从输入中读取了一行字符串到 <code>0x4a2138</code> 地址。</p></blockquote><p>处理 fgets 结果：遍历字符串查找换行符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">400b34: d2800000    mov x0, #0                   // x0 = 0，作为字符串偏移索引</span><br><span class="line"></span><br><span class="line">// 再次构造 x2 = buffer 基址</span><br><span class="line">400b38: d0000502    adrp x2, 4a2000</span><br><span class="line">400b3c: 9104e042    add x2, x2, #0x138           // x2 = buffer</span><br><span class="line"></span><br><span class="line">400b40: 38626801    ldrb w1, [x0, x2]            // w1 = buffer[x0]</span><br><span class="line">400b44: 34000141    cbz w1, 400b6c               // 如果 w1 == 0，字符串结束，跳到 return</span><br><span class="line">400b48: 7100283f    cmp w1, #0xa                 // 检查是否是换行符 &#x27;\n&#x27;</span><br><span class="line">400b4c: 540000a0    b.eq 400b60                  // 是换行符，跳转到去掉换行符</span><br><span class="line">400b50: 91000400    add x0, x0, #1               // x0++，继续检查下一个字符</span><br><span class="line">400b54: f101401f    cmp x0, #0x50                // 最多检查 0x50 字节（最多 80 字节）</span><br><span class="line">400b58: 54ffff41    b.ne 400b40                  // 没到头就继续循环</span><br></pre></td></tr></table></figure><p>如果没有在前 80 字节找到 ‘\n’，调用 <code>explode</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400b5c: 97ffffe6    bl 400af4 &lt;explode&gt;          // 没有 &#x27;\n&#x27;，爆炸</span><br></pre></td></tr></table></figure><p>如果找到了换行符 <code>\n</code>，把它替换为 <code>\0</code>（字符串结束）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">400b60: d0000501    adrp x1, 4a2000</span><br><span class="line">400b64: 9104e021    add x1, x1, #0x138           // x1 = buffer</span><br><span class="line">400b68: 3820c83f    strb wzr, [x1, w0, sxtw]     // buffer[x0] = 0（wzr是0寄存器）</span><br></pre></td></tr></table></figure><p>返回前恢复现场：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">400b6c: d0000500    adrp x0, 4a2000</span><br><span class="line">400b70: 9104e000    add x0, x0, #0x138           // x0 = buffer，作为返回值</span><br><span class="line"></span><br><span class="line">400b74: a8c17bfd    ldp x29, x30, [sp], #16      // 恢复帧指针和返回地址，sp += 16</span><br><span class="line">400b78: d65f03c0    ret                          // 返回</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225645707.png" alt="image-20250629225645707"></p><p>可以看到 phase_defused 函数读取一个全局变量值，然后减一</p><p>随后加载一个全局地址 0x464000+0x7c0 = 0x4647c0 作为参数调用 printf 打印</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630125413000.png" alt="image-20250630125413000"></p><p>而 w1 存的是最开始减一的全局变量的值，地址是 0x4a0000+ 80 = 0x4a0000 + 0x50 = 0x4a0050。</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630125539188.png" alt="image-20250630125539188"></p><h1 id="phase-0"><a href="#phase-0" class="headerlink" title="phase_0"></a>phase_0</h1><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624203514602.png" alt="image-20250624203514602"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stpx29, x30, [sp, #-16]!</span><br></pre></td></tr></table></figure><ul><li>作用：将 x29（frame pointer，帧指针）和 x30（link register，返回地址）压入栈中。这一步保存了调用者的帧指针和返回地址，便于后续恢复。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movx29, sp</span><br></pre></td></tr></table></figure><ul><li>作用：将当前的栈指针 sp 赋值给帧指针 x29，即建立当前函数的新栈帧。</li></ul><p>从现在开始，x29 就指向这个函数调用的栈底，方便以后访问局部变量或传递参数。</p><p>随后，函数先是调用 read_int 函数读取一个 int 值，将返回值存入 w0，然后对比 0x4a0000 + 0x54(84) = 0x4a0054 的值看是否相等。可通过 gdb examine 命令查看内存这个位置的值：</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624204122130.png" alt="image-20250624204122130"></p><p>可以看到是 2022</p><p>随后是 cmp 指令对比输入的值(存储在 x0)和 2022(存储在 x1)，如果不相等则跳到调用 explode 函数的那行，所以必须要相等。即输入值必须是 2022</p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>phase_1 和 phase_0 差不多</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624205525968.png" alt="image-20250624205525968"></p><p>可以看到函数把 0x4a0000+0x58(88) = 0x4a0058 地址的值装入 x1，然后调用 strcmp，其参数应该是 x0，x1，而 x0 是我们输入的值，也就是说让我们输入的字符串和这个 0x4a0058 地址的字符串进行比较，看返回值 w0 是否为 0，不为 0 就跳转到调用 explode 的那一行</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624205829889.png" alt="image-20250624205829889"></p><p>里需要注意的是 0x4a0058 地址存放的不是字符串，而是字符串的地址，所以要先读出这个地址，然后读字符串地址的字符串</p><p>答案为：”Fault Tolerance: Reliable Systems from Unreliable Components.”</p><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629223737226.png" alt="image-20250629223737226"></p><p>第一行开辟了 64 字节的栈空间，共可存放 64/8=8 个 64 位值，第一行将 x29 放在 sp，将 x30 放在 sp+8</p><p>随后保存 sp 到 x29 寄存器</p><p>随后将 x19, x20 寄存器的值放在 sp+16, sp+24 的位置，即</p><ul><li>sp —-&gt; x29</li><li>sp+8 —-&gt; x30</li><li>sp+16 —-&gt; x19</li><li>sp+24 —-&gt; x20</li></ul><p>随后 x1 = sp+ 0x20 = sp+32，作为 read_8_numbers 的第二个参数，随后调用 read_8_numbers 这个函数</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629224840291.png" alt="image-20250629224840291"></p><p>可以看到，该函数首先开辟 0x20 即 32 字节的栈空间 sp= sp-32，随后将 x29 存入 sp+16，x30 存入 sp+24</p><p>随后设置栈帧指针 x29 为 sp+0x10 即 sp+16</p><p>随后将 x1 放入 x2，x1 是 read_8_numbers 的第二个参数</p><p>随后，x1 = x1+0x1c = x1+ 28</p><p>将 x1 存入 sp+8</p><p>x1 = x2 + 0x18 =x1 + 24</p><p>将 x1 存入 sp</p><p>随后</p><ul><li><p>x7 = x2+ 0x14</p></li><li><p>x6 = x2 + 0x10</p></li><li>x5 = x2+0xc</li><li>x4 = x2+ 0x8</li><li>x3 = x2+0x4</li></ul><p>x1 是地址 0x464000+0x858 的值，是一个指针，这里可以明显看出来是一个数组起始地址，可以看到是格式化字符串，作为__isoc99_scanf 的第二个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是 x0，即从 read_line 返回后一直未变</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630140224444.png" alt="image-20250630140224444"></p><p>函数调用结束后比较返回值和 0x7 的大小，如果小于等于就爆炸，因此必须要输入 8 个数字。</p><p>函数返回后恢复原来的栈结构</p><ul><li>sp —-&gt; x29</li><li>sp+8 —-&gt; x30</li><li>sp+16 —-&gt; x19</li><li>sp+24 —-&gt; x20</li><li>sp+32 —-&gt; array 的首地址，共 8 个数字，也是第一个数字的地址 array[0]</li><li>sp+36 —-&gt; array[1]</li><li>sp+40 —-&gt; array[2]</li><li>sp+44 —-&gt; array[3]</li><li>sp+48 —-&gt; array[4]</li><li>sp+52 —-&gt; array[5]</li><li>sp+56 —-&gt; array[6]</li><li>sp+60 —-&gt; array[7]</li></ul><p>刚好占满 phase_2 最初开辟的 64 字节</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630142117435.png" alt="image-20250630142117435"></p><p>然后是对输入的 8 个数字的判断了，这里很容易看出第一个数字和第二个数字都必须为 1</p><p>随后是一个循环</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630142644664.png" alt="image-20250630142644664"></p><p>x19 = sp+0x20 = sp+32 即 array[0]</p><p>x20 = sp+0x38 = sp+56 即终止条件即(56-32)/4=6，即到第六个就停止</p><p>首先 b 0x4007d0 跳过一次 x19 的自增与和 x20 的比较</p><p>如果 x19 == x20 则跳到 phase_2+108 结束</p><p>否则，首先将 x19 作为地址加载到 w0（array[i]），将它下一个加载到 w1（array[i+1]）</p><p>令 w0 = array[i]+array[i+1] +4</p><p>w1 = array[i+2]</p><p>比较 w0 是否等于 w1,如果相等则跳到 phase_2+60，将 i++</p><p>如果不相等则爆炸</p><p>第一个数和第二个数必须为 1</p><p>那么第三个数字为 1+1+4=6</p><p>第四个数字为 1+6+4=11</p><p>第五个数字为 6+11+4=21</p><p>第六个数字为 11+21+4=36</p><p>第七个数字为 21+36+4=61</p><p>第八个数字为 61+36+4=101</p><p>故答案为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">6</span> <span class="number">11</span> <span class="number">21</span> <span class="number">36</span> <span class="number">61</span> <span class="number">101</span></span><br></pre></td></tr></table></figure><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB</title>
      <link href="/posts/42870/"/>
      <url>/posts/42870/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="gdb-配置"><a href="#gdb-配置" class="headerlink" title="gdb 配置"></a>gdb 配置</h1><h2 id="tui-模式下显示混乱"><a href="#tui-模式下显示混乱" class="headerlink" title="tui 模式下显示混乱"></a>tui 模式下显示混乱</h2><p>参考：<br><div class="tag link"><a class="link-card" title="CSAPP环境搭建" href="https://blog.csdn.net/u012772347/article/details/142598998"><div class="left"><img src="https://g.csdnimg.cn/static/logo/favicon32.ico"/></div><div class="right"><p class="text">CSAPP环境搭建</p><p class="url">https://blog.csdn.net/u012772347/article/details/142598998</p></div></a></div></p><h2 id="gdb-看不到程序-printf-输出"><a href="#gdb-看不到程序-printf-输出" class="headerlink" title="gdb 看不到程序 printf 输出"></a>gdb 看不到程序 printf 输出</h2><p>这是因为输出存在缓冲区，使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call fflush(stdout)</span><br></pre></td></tr></table></figure><h2 id="使用不同的终端"><a href="#使用不同的终端" class="headerlink" title="使用不同的终端"></a>使用不同的终端</h2><p>缺省情况，gdb 和程序的输入输出使用同一终端，可以为程序指定单独的输入输出终端，先打开一个终端输入 tty 命令获取当前终端名称<br>然后启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -<span class="built_in">tty</span> /dev/pts/3 ./a.out</span><br></pre></td></tr></table></figure><h1 id="启动-gdb"><a href="#启动-gdb" class="headerlink" title="启动 gdb"></a>启动 gdb</h1><h2 id="编译阶段：加入调试信息"><a href="#编译阶段：加入调试信息" class="headerlink" title="编译阶段：加入调试信息"></a>编译阶段：加入调试信息</h2><p>为了让 GDB 能看到函数名、变量名、源码行号，<strong>编译时必须加上 <code>-g</code> 参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello        <span class="comment"># 对 C 程序</span></span><br><span class="line">g++ -g hello.cpp -o hello      <span class="comment"># 对 C++ 程序</span></span><br></pre></td></tr></table></figure><p>否则 GDB 只能看到汇编和内存地址，无法进行源码级调试。</p><hr><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><h3 id="调试一个程序"><a href="#调试一个程序" class="headerlink" title="调试一个程序"></a><strong>调试一个程序</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program</span><br></pre></td></tr></table></figure><h4 id="设置程序运行参数"><a href="#设置程序运行参数" class="headerlink" title="设置程序运行参数"></a><strong>设置程序运行参数</strong></h4><ul><li><p><strong>设置运行参数（如命令行参数）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> args 10 20 30</span><br></pre></td></tr></table></figure></li><li><p><strong>查看当前设置的参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show args</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="设置运行环境变量"><a href="#设置运行环境变量" class="headerlink" title="设置运行环境变量"></a><strong>设置运行环境变量</strong></h4><ul><li><p><strong>设置程序运行路径（用于找可执行文件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path /your/bin/dir</span><br></pre></td></tr></table></figure></li><li><p><strong>查看运行路径设置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show paths</span><br></pre></td></tr></table></figure></li><li><p><strong>设置环境变量</strong>（例如传给 <code>main()</code> 程序用的环境）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> environment USER=yourname</span><br></pre></td></tr></table></figure></li><li><p><strong>查看环境变量</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show environment</span><br><span class="line">show environment USER</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="设置工作目录"><a href="#设置工作目录" class="headerlink" title="设置工作目录"></a><strong>设置工作目录</strong></h4><p>设置工作目录指的是程序运行时的当前目录</p><ul><li><p><strong>切换当前目录</strong>（等同于 shell 的 <code>cd</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/dir</span><br></pre></td></tr></table></figure></li><li><p><strong>查看当前目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="控制程序的输入输出"><a href="#控制程序的输入输出" class="headerlink" title="控制程序的输入输出"></a><strong>控制程序的输入输出</strong></h4><ul><li><p><strong>查看程序绑定的终端信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info terminal</span><br></pre></td></tr></table></figure></li><li><p><strong>重定向输出（如保存输出到文件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run &gt; output.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>指定程序输入输出使用的终端设备</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tty</span> /dev/pts/1</span><br></pre></td></tr></table></figure></li></ul><h3 id="调试-core-dump-文件"><a href="#调试-core-dump-文件" class="headerlink" title="调试 core dump 文件"></a><strong>调试 core dump 文件</strong></h3><p>core dump 是程序崩溃后的转储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program core</span><br></pre></td></tr></table></figure><h4 id="打开-core-文件生成功能"><a href="#打开-core-文件生成功能" class="headerlink" title="打开 core 文件生成功能"></a>打开 core 文件生成功能</h4><p>Linux <strong>默认没有打开 core 文件生成功能</strong>，也就是发生段错误时不会<code>core dumped</code>。可以通过以下命令打开<code>core</code>文件的生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不限制产生 core 的大小</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p><code>unlimited</code> 意思是系统<strong>不限制 core 文件的大小</strong>，只要有足够的磁盘空间，会转存程序所占用的全部内存，如果需要限制系统产生 <code>core</code>的大小，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core 最大限制大小为 409600 字节</span></span><br><span class="line"><span class="built_in">ulimit</span> -c 409600</span><br></pre></td></tr></table></figure><h4 id="关闭-core-文件生成功能"><a href="#关闭-core-文件生成功能" class="headerlink" title="关闭 core 文件生成功能"></a>关闭 core 文件生成功能</h4><p>把核心转储功能关闭，只需要将限制大小设为<code>0</code> 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c 0</span><br></pre></td></tr></table></figure><p><strong>注意，如果只是输入命令“<code>ulimit -c unlimited</code>”，这只会在当前终端有效，退出终端或者打开一个新的终端时是无效的</strong>。</p><p>例子：</p><p>编写一个简单的 C 程序，人为制造一个<code>Segmentation fault</code>错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给一个NULL指令赋值，会产生 Segmentation fault 错误</span></span><br><span class="line">  *p = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中定义了一个空指针变量 P，然后给空指针 P 赋值，运行程序就会<strong>产生一个段错误</strong>。</p><p>开启了<strong>核心转储</strong>后，就会产生一个<code>core</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译 hello.c 生成 hello 程序</span></span><br><span class="line">gcc -o hello hello.c -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行该程序</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>运行后，我们可以看到 <code>Segmentation fault (core dumped)</code> 提示信息，表示已经在当前目录下产生了一个<code>core</code>文件：</p><h3 id="调试正在运行的程序"><a href="#调试正在运行的程序" class="headerlink" title="调试正在运行的程序"></a><strong>调试正在运行的程序</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program &lt;PID&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>直接指定 PID 启动 GDB</strong>（需要有可执行程序路径）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program &lt;PID&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>在 GDB 内 attach 到某个 PID</strong>：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach &lt;PID&gt;</span><br><span class="line">(gdb) detach   # 取消 attach</span><br></pre></td></tr></table></figure><hr><h2 id="常用启动参数"><a href="#常用启动参数" class="headerlink" title="常用启动参数"></a>常用启动参数</h2><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-s</code> 或 <code>-symbols &lt;file&gt;</code></td><td>指定符号表文件</td></tr><tr><td><code>-se &lt;file&gt;</code></td><td>指定符号表文件，并关联到可执行文件</td></tr><tr><td><code>-c</code> 或 <code>-core &lt;file&gt;</code></td><td>指定 core dump 文件用于调试</td></tr><tr><td><code>-d</code> 或 <code>-directory &lt;dir&gt;</code></td><td>添加源码搜索路径（默认用 <code>$PATH</code>）</td></tr></tbody></table></div><p>退出输入 quit(q)即可</p><h2 id="gdb-中运行-Shell"><a href="#gdb-中运行-Shell" class="headerlink" title="gdb 中运行 Shell"></a>gdb 中运行 Shell</h2><p>在 GDB 中可以直接运行操作系统的命令，方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell &lt;命令字符串&gt;</span><br></pre></td></tr></table></figure><p>example</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell <span class="built_in">ls</span> -l</span><br><span class="line">(gdb) shell <span class="built_in">cat</span> input.txt</span><br></pre></td></tr></table></figure><p>这会在 GDB 内部启动你系统的 shell（由环境变量 <code>SHELL</code> 决定），然后执行你写的命令。</p><p>GDB 也内置了一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) make &lt;参数&gt;</span><br></pre></td></tr></table></figure><p>它本质上等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell make &lt;参数&gt;</span><br></pre></td></tr></table></figure><p>也就是说，它会调用系统的 <code>make</code> 工具来重新编译程序，非常方便调试时快速修改代码后重新 build。</p><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><h2 id="断点-breakpoint"><a href="#断点-breakpoint" class="headerlink" title="断点 (breakpoint)"></a>断点 (breakpoint)</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h4 id="按函数名设置断点"><a href="#按函数名设置断点" class="headerlink" title="按函数名设置断点"></a>按函数名设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> <span class="keyword">function</span></span><br></pre></td></tr></table></figure><ul><li>在指定函数的<strong>入口</strong>处停下。</li><li>对于 C++ 可以写成：<ul><li><code>break ClassName::Function</code></li><li><code>break function(type1, type2)</code>（如果重载）</li></ul></li></ul><h4 id="按行号设置断点"><a href="#按行号设置断点" class="headerlink" title="按行号设置断点"></a>按行号设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> 42</span><br></pre></td></tr></table></figure><ul><li>在当前源文件的第 <strong>42 行</strong> 设断点。</li></ul><h4 id="相对当前行设置断点"><a href="#相对当前行设置断点" class="headerlink" title="相对当前行设置断点"></a>相对当前行设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> +5     // 当前行之后5行</span><br><span class="line"><span class="built_in">break</span> -3     // 当前行之前3行</span><br></pre></td></tr></table></figure><h4 id="指定文件-行号"><a href="#指定文件-行号" class="headerlink" title="指定文件 + 行号"></a>指定文件 + 行号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> filename.c:42</span><br></pre></td></tr></table></figure><ul><li>在 <code>filename.c</code> 的第 42 行设置断点。</li></ul><h4 id="指定文件-函数名"><a href="#指定文件-函数名" class="headerlink" title="指定文件 + 函数名"></a>指定文件 + 函数名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> filename.c:func</span><br></pre></td></tr></table></figure><ul><li>在 <code>filename.c</code> 中 <code>func</code> 函数的入口处设置断点。</li></ul><h4 id="按地址设置断点"><a href="#按地址设置断点" class="headerlink" title="按地址设置断点"></a>按地址设置断点</h4><p>常用于汇编调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> *0x4007d0</span><br></pre></td></tr></table></figure><ul><li>在程序内存地址 <code>0x4007d0</code> 处设置断点。</li></ul><h4 id="设置条件断点"><a href="#设置条件断点" class="headerlink" title="设置条件断点"></a>设置条件断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> func <span class="keyword">if</span> i == 100</span><br></pre></td></tr></table></figure><ul><li>当变量 <code>i == 100</code> 且执行到 <code>func</code> 函数时才停下。</li></ul><h4 id="设置下一条语句的断点（无参数）"><a href="#设置下一条语句的断点（无参数）" class="headerlink" title="设置下一条语句的断点（无参数）"></a>设置下一条语句的断点（无参数）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span></span><br></pre></td></tr></table></figure><ul><li>在“下一条将要执行”的语句处设断点。</li></ul><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><h4 id="查看所有断点"><a href="#查看所有断点" class="headerlink" title="查看所有断点"></a>查看所有断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure><h4 id="查看指定编号的断点"><a href="#查看指定编号的断点" class="headerlink" title="查看指定编号的断点"></a>查看指定编号的断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info <span class="built_in">break</span> 3</span><br></pre></td></tr></table></figure><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><h4 id="删除某一个断点"><a href="#删除某一个断点" class="headerlink" title="删除某一个断点"></a>删除某一个断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &lt;编号&gt;</span><br></pre></td></tr></table></figure><ul><li>例如：<code>delete 1</code> 表示删除编号为 1 的断点。</li></ul><h4 id="删除多个断点"><a href="#删除多个断点" class="headerlink" title="删除多个断点"></a>删除多个断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete 1 2 3</span><br></pre></td></tr></table></figure><ul><li>同时删除断点 1、2 和 3。</li></ul><h4 id="删除所有断点"><a href="#删除所有断点" class="headerlink" title="删除所有断点"></a>删除所有断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure><ul><li><strong>不加参数</strong>表示删除所有断点。GDB 会提示你确认（输入 <code>y</code>）。</li></ul><h2 id="观察点-watchpoint"><a href="#观察点-watchpoint" class="headerlink" title="观察点 (watchpoint)"></a>观察点 (watchpoint)</h2><h3 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h3><h4 id="watch-lt-expr-gt"><a href="#watch-lt-expr-gt" class="headerlink" title="watch &lt;expr&gt;"></a><code>watch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 的 <strong>值被改变</strong> 时，程序会暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch x</span><br></pre></td></tr></table></figure><p>当变量 <code>x</code> 的值发生变化时暂停。</p></li></ul><h4 id="rwatch-lt-expr-gt"><a href="#rwatch-lt-expr-gt" class="headerlink" title="rwatch &lt;expr&gt;"></a><code>rwatch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 被<strong>读取</strong>时，程序暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwatch y</span><br></pre></td></tr></table></figure><p>当变量 <code>y</code> 被读取时暂停程序。</p></li></ul><h4 id="awatch-lt-expr-gt"><a href="#awatch-lt-expr-gt" class="headerlink" title="awatch &lt;expr&gt;"></a><code>awatch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 被<strong>读取或写入</strong>时，程序暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awatch z</span><br></pre></td></tr></table></figure><p>当变量 <code>z</code> 被读取或写入时都暂停。</p></li></ul><h3 id="查看当前观察点"><a href="#查看当前观察点" class="headerlink" title="查看当前观察点"></a>查看当前观察点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info watchpoints</span><br></pre></td></tr></table></figure><ul><li>显示所有设置的观察点（类似 <code>info breakpoints</code>）。</li></ul><h3 id="删除观察点"><a href="#删除观察点" class="headerlink" title="删除观察点"></a>删除观察点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &lt;编号&gt;</span><br></pre></td></tr></table></figure><ul><li>与删除断点的方式一样。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>观察点依赖于 <strong>目标架构是否支持硬件观察点</strong>（大多数支持）。</li><li>不支持的情况下，GDB 可能无法设置 <code>watch</code>、<code>rwatch</code> 等。</li><li>观察点数量受限，一般比断点少（通常是 4 个）。</li></ul><h2 id="捕捉点-catchpoint"><a href="#捕捉点-catchpoint" class="headerlink" title="捕捉点 (catchpoint)"></a>捕捉点 (catchpoint)</h2><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch &lt;event&gt;</span><br></pre></td></tr></table></figure><p>也可以使用一次性的捕捉点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcatch &lt;event&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="常见-catchpoint-类型"><a href="#常见-catchpoint-类型" class="headerlink" title="常见 catchpoint 类型"></a>常见 catchpoint 类型</h3><div class="table-container"><table><thead><tr><th>事件类型</th><th>描述说明</th></tr></thead><tbody><tr><td><code>throw</code></td><td>捕捉 C++ 程序抛出异常的位置。</td></tr><tr><td><code>catch</code></td><td>捕捉 C++ 程序捕获异常的位置。</td></tr><tr><td><code>exec</code></td><td>捕捉程序调用 <code>exec()</code> 系统调用（替换进程映像）。</td></tr><tr><td><code>fork</code></td><td>捕捉程序调用 <code>fork()</code> 系统调用（创建子进程）。</td></tr><tr><td><code>vfork</code></td><td>捕捉 <code>vfork()</code> 调用（特殊类型的 <code>fork()</code>）。</td></tr><tr><td><code>load</code></td><td>捕捉动态链接库的加载事件。</td></tr><tr><td><code>unload</code></td><td>捕捉动态链接库的卸载事件。</td></tr></tbody></table></div><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch throw</span><br></pre></td></tr></table></figure><blockquote><p>在 C++ 抛出异常时中断程序。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch fork</span><br></pre></td></tr></table></figure><blockquote><p>在程序调用 <code>fork()</code> 时中断。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcatch <span class="built_in">exec</span></span><br></pre></td></tr></table></figure><blockquote><p>设置一次性的捕捉点，在程序调用 <code>exec()</code> 系统调用时暂停，之后自动移除。</p></blockquote><h2 id="程序停止点清除"><a href="#程序停止点清除" class="headerlink" title="程序停止点清除"></a>程序停止点清除</h2><h3 id="清除停止点（clear）"><a href="#清除停止点（clear）" class="headerlink" title="清除停止点（clear）"></a>清除停止点（clear）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clear                    <span class="comment"># 清除当前位置所有停止点</span></span><br><span class="line">clear &lt;<span class="keyword">function</span>&gt;         <span class="comment"># 清除函数上的所有停止点</span></span><br><span class="line">clear &lt;filename:<span class="keyword">function</span>&gt;# 指定源文件和函数</span><br><span class="line">clear &lt;linenum&gt;          <span class="comment"># 清除当前文件某行的断点</span></span><br><span class="line">clear &lt;filename:linenum&gt; <span class="comment"># 指定文件+行号清除</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：<code>clear</code> 是基于“<strong>位置</strong>”清除，而非编号。</p></blockquote><h3 id="删除断点（delete）"><a href="#删除断点（delete）" class="headerlink" title="删除断点（delete）"></a>删除断点（delete）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete                   <span class="comment"># 删除所有断点</span></span><br><span class="line">delete &lt;bnum&gt;            <span class="comment"># 删除指定编号的断点</span></span><br><span class="line">delete &lt;range&gt;           <span class="comment"># 如 delete 3-5，删除编号 3 到 5 的断点</span></span><br><span class="line">d                        <span class="comment"># delete 的简写</span></span><br></pre></td></tr></table></figure><h3 id="禁用-启用断点（disable-enable）"><a href="#禁用-启用断点（disable-enable）" class="headerlink" title="禁用/启用断点（disable / enable）"></a>禁用/启用断点（disable / enable）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span>                  <span class="comment"># 禁用所有断点</span></span><br><span class="line"><span class="built_in">disable</span> &lt;bnum&gt; [range]   <span class="comment"># 禁用特定断点</span></span><br><span class="line">dis                      <span class="comment"># disable 的简写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">enable</span>                   <span class="comment"># 启用所有断点</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt;            <span class="comment"># 启用某个断点</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt; once       <span class="comment"># 执行一次后自动 disable</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt; delete     <span class="comment"># 执行一次后自动删除</span></span><br></pre></td></tr></table></figure><blockquote><p>推荐使用 <code>disable/enable</code> 管理调试状态，灵活又不丢失断点信息。</p></blockquote><hr><h3 id="设置-修改-条件（condition）"><a href="#设置-修改-条件（condition）" class="headerlink" title="设置 / 修改 条件（condition）"></a>设置 / 修改 条件（condition）</h3><h4 id="设置条件断点（设置时）"><a href="#设置条件断点（设置时）" class="headerlink" title="设置条件断点（设置时）"></a>设置条件断点（设置时）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> foo <span class="keyword">if</span> x &gt; 5</span><br><span class="line">watch var <span class="keyword">if</span> var == 0</span><br></pre></td></tr></table></figure><h4 id="修改断点条件（维护时）"><a href="#修改断点条件（维护时）" class="headerlink" title="修改断点条件（维护时）"></a>修改断点条件（维护时）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">condition &lt;bnum&gt; x &gt; 100     <span class="comment"># 修改断点编号为 bnum 的条件</span></span><br><span class="line">condition &lt;bnum&gt;            <span class="comment"># 清除断点条件</span></span><br></pre></td></tr></table></figure><hr><h3 id="忽略断点次数（ignore）"><a href="#忽略断点次数（ignore）" class="headerlink" title="忽略断点次数（ignore）"></a>忽略断点次数（ignore）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignore &lt;bnum&gt; &lt;count&gt;   <span class="comment"># 忽略断点号 bnum 的触发 count 次</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignore 2 3</span><br></pre></td></tr></table></figure><blockquote><p>忽略断点 2 的前三次命中，第 4 次才真正中断。</p></blockquote><h4 id="为断点添加命令序列"><a href="#为断点添加命令序列" class="headerlink" title="为断点添加命令序列"></a>为断点添加命令序列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands &lt;bnum&gt;</span><br><span class="line">...gdb命令序列...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> foo <span class="keyword">if</span> x &gt; 0</span><br><span class="line">commands</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;x is %d\n&quot;</span>, x</span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>作用：x &gt; 0 时断点命中，打印后自动继续，不用手动按 <code>c</code>。</p></blockquote><h4 id="清除已有命令"><a href="#清除已有命令" class="headerlink" title="清除已有命令"></a>清除已有命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands &lt;bnum&gt;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>example</p><ul><li><p>调试循环或大函数中的问题时，建议使用：<br><code>break &lt;line&gt; if i == 9999</code><br>或<br><code>ignore &lt;bnum&gt; 9998</code></p></li><li><p>在你定位 bug 后，不要删断点，直接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> &lt;bnum&gt;  <span class="comment"># 保留断点以后复用</span></span><br></pre></td></tr></table></figure></li><li><p>想测试多个变量变化时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch a</span><br><span class="line">watch b</span><br></pre></td></tr></table></figure></li><li><p>想搞自动化调试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">silent</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;Reached here\n&quot;</span></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><h2 id="调试程序执行"><a href="#调试程序执行" class="headerlink" title="调试程序执行"></a>调试程序执行</h2><h3 id="恢复程序运行（继续执行）"><a href="#恢复程序运行（继续执行）" class="headerlink" title="恢复程序运行（继续执行）"></a>恢复程序运行（继续执行）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>continue</code> / <code>c</code> / <code>fg</code></td><td>从当前断点处继续运行</td></tr><tr><td><code>continue &lt;ignore-count&gt;</code></td><td>忽略接下来的 <code>&lt;count&gt;</code> 次断点命中</td></tr><tr><td><code>run</code> / <code>r</code></td><td>重新启动程序（从头开始）</td></tr></tbody></table></div><blockquote><p>适用于程序刚停下，想跳过一些断点或继续往下执行。</p></blockquote><h3 id="单步调试（源代码级）"><a href="#单步调试（源代码级）" class="headerlink" title="单步调试（源代码级）"></a>单步调试（源代码级）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>step</code> / <code>s</code></td><td>单步执行，会进入函数（Step Into）</td></tr><tr><td><code>next</code> / <code>n</code></td><td>单步执行，不进入函数（Step Over）</td></tr><tr><td><code>step &lt;count&gt;</code> / <code>next &lt;count&gt;</code></td><td>连续执行 <code>&lt;count&gt;</code> 步</td></tr></tbody></table></div><blockquote><p>用于逐行查看程序逻辑，<code>step</code> 会进函数内部，<code>next</code> 则略过。</p></blockquote><h3 id="退出当前函数（函数级跳出）"><a href="#退出当前函数（函数级跳出）" class="headerlink" title="退出当前函数（函数级跳出）"></a>退出当前函数（函数级跳出）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>finish</code></td><td>继续运行到当前函数返回，并打印返回值和返回地址</td></tr></tbody></table></div><blockquote><p>非常实用，适合跟踪完某个函数后退出它。</p></blockquote><h3 id="跳出循环体-块（until）"><a href="#跳出循环体-块（until）" class="headerlink" title="跳出循环体 / 块（until）"></a>跳出循环体 / 块（until）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>until &lt;location&gt;</code> / <code>u</code></td><td>执行直到某个位置或当前块结束（适合退出循环）</td></tr></tbody></table></div><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> 42            <span class="comment"># 运行到当前文件的第 42 行</span></span><br><span class="line"><span class="keyword">until</span> main.c:100    <span class="comment"># 运行到 main.c 第 100 行</span></span><br></pre></td></tr></table></figure><blockquote><p>用于快速跳出 for/while 循环等结构块。</p></blockquote><h3 id="汇编级单步（指令级调试）"><a href="#汇编级单步（指令级调试）" class="headerlink" title="汇编级单步（指令级调试）"></a>汇编级单步（指令级调试）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>stepi</code> / <code>si</code></td><td>单步执行一条机器指令（Step Into）</td></tr><tr><td><code>nexti</code> / <code>ni</code></td><td>单步执行一条机器指令（Step Over）</td></tr></tbody></table></div><blockquote><p>用于底层跟踪，比如跟踪系统调用、libc 内部逻辑或 boot code。</p></blockquote><p>汇编查看建议：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display/i <span class="variable">$pc</span>     <span class="comment"># 实时显示当前执行指令</span></span><br></pre></td></tr></table></figure><h3 id="设置-step-mode-模式"><a href="#设置-step-mode-模式" class="headerlink" title="设置 step-mode 模式"></a>设置 step-mode 模式</h3><p>主要用于控制是否进入无符号函数</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>set step-mode on</code></td><td>即使没有 debug 符号也停住（默认 off）</td></tr><tr><td><code>set step-mode off</code></td><td>遇到无符号函数就跳过（默认）</td></tr></tbody></table></div><blockquote><p>对调试汇编或只含部分符号的库文件时很有用。</p></blockquote><h1 id="查看运行时数据"><a href="#查看运行时数据" class="headerlink" title="查看运行时数据"></a>查看运行时数据</h1><p>程序暂停时，使用 print 命令（简写 p）或者用同义命令 inspect 查看当前程序的运行数据，格式为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="symbol">&lt;expr&gt;</span></span><br><span class="line"><span class="keyword">print</span>/<span class="symbol">&lt;f&gt;</span> <span class="symbol">&lt;expr&gt;</span></span><br></pre></td></tr></table></figure><ul><li><expr>为要调试的程序语言的表达式</li><li><f>是 format 的意思，比如按 16 进制输出就是/x</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一般来说，GDB 会根据变量的类型输出变量的值。但你也可以自定义 GDB 的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整<br>型变量的中的位的情况。要做到这样，你可以使用 GDB 的数据显示格式：</p><ul><li>x 按十六进制格式显示变量。 (hex)</li><li>d 按十进制格式显示变量。 (decimal)</li><li>u 按十六进制格式显示无符号整型。 (unsinged hex)</li><li>o 按八进制格式显示变量。 (octal)</li><li>t 按二进制格式显示变量。 (two)</li><li>a 按十六进制格式显示变量。 (address)</li><li>c 按字符格式显示变量。 (char)</li><li>f 按浮点数格式显示变量。 (float)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p i</span><br><span class="line"><span class="variable">$21</span> = 101</span><br><span class="line">(gdb) p/a i</span><br><span class="line"><span class="variable">$22</span> = 0x65</span><br><span class="line">(gdb) p/c i</span><br><span class="line"><span class="variable">$23</span> = 101 <span class="string">&#x27;e&#x27;</span></span><br><span class="line">(gdb) p/f i</span><br><span class="line"><span class="variable">$24</span> = 1.41531145e-43 (gdb) p/x i</span><br><span class="line"><span class="variable">$25</span> = 0x65</span><br><span class="line">(gdb) p/t i</span><br><span class="line"><span class="variable">$26</span> = 1100101</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式可以是当前程序运行中的 const 常量，变量，函数等内容，但不能是程序中定义的宏</p><h3 id="程序变量"><a href="#程序变量" class="headerlink" title="程序变量"></a>程序变量</h3><p>在 GDB 中，你可以随时查看以下三种变量的值：</p><ol><li>全局变量（所有文件可见的）</li><li>静态全局变量（当前文件可见的）</li><li>局部变量（当前 Scope 可见的）</li></ol><p>用 print 显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>::<span class="keyword">variable</span></span><br><span class="line"><span class="keyword">function</span>::<span class="keyword">variable</span></span><br></pre></td></tr></table></figure><p>example</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb) p <span class="string">&#x27;f2.c&#x27;</span>::x</span><br></pre></td></tr></table></figure><div class="tip warning faa-horizontal animated"><p>注意：如果你的程序编译时开启了优化选项，那么在用 GDB 调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在 GDB 调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU 的 C/C++编译器 GCC，你可以使用“-gstabs”选项来解决这个问题。</p></div><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="built_in">array</span> = (<span class="type">int</span> *) <span class="built_in">malloc</span> (len * <span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>在 GDB 调试过程中，你可以以如下命令显示出这个动态数组的取值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> *array<span class="keyword">@len</span></span><br></pre></td></tr></table></figure><p>@的左边是数组的首地址的值，也就是变量 array 所指向的内容，右边则是数据的长度，其保存在变量 len 中，其输出结果，大约是下面这个样子的：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p <span class="number">*a</span>rray@len</span><br><span class="line"><span class="variable">$1</span> = &#123;2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40&#125; 如果是静态数组的话，可以直接用 <span class="built_in">print</span> 数组名，就可以显示数组中所有数据的内容了。</span><br></pre></td></tr></table></figure><p>如果是静态数组的话，可以直接用 print 数组名，就可以显示数组中所有数据的内容了。</p><h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><p>使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="attribute">&lt;n/f/u&gt;</span> <span class="attribute">&lt;addr&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>n：显示的个数，即从内存地址 <addr> 开始，显示几个单位（默认为 1）。</p></li><li><p>f：显示格式，比如：</p><ul><li>x 十六进制</li><li>d 十进制</li><li>t 二进制</li><li>c 字符</li><li>f 浮点数</li><li>s 字符串</li><li>i 指令</li></ul></li><li><p>u：读取单位的大小，决定每次读取多少字节：</p><ul><li>b = 1 字节（byte）</li><li>h = 2 字节（half word）</li><li>w = 4 字节（word，默认）</li><li>g = 8 字节（giant/quad word）</li></ul></li></ul><h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><p>要查看寄存器的值，很简单，可以使用 info registers (i r)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看寄存器的情况。（除了浮点寄存器）</span></span><br><span class="line"><span class="built_in">info</span> all-registers</span><br><span class="line"><span class="comment"># 查看所有寄存器的情况。（包括浮点寄存器）</span></span><br><span class="line"><span class="built_in">info</span> registers &lt;regname <span class="built_in">..</span>.&gt;</span><br></pre></td></tr></table></figure><p>也可以使用 print 命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">p</span> <span class="variable">$eip</span>。</span><br></pre></td></tr></table></figure><p>查看所指定的寄存器的情况。<br>寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用 print 命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。</p><h2 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h2><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的 GDB 命令是 display。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">display</span> <span class="symbol">&lt;expr&gt;</span></span><br><span class="line"><span class="keyword">display</span>/<span class="symbol">&lt;fmt&gt;</span> <span class="symbol">&lt;expr&gt;</span></span><br><span class="line"><span class="keyword">display</span>/<span class="symbol">&lt;fmt&gt;</span> <span class="symbol">&lt;addr&gt;</span></span><br></pre></td></tr></table></figure><ul><li>expr 是一个表达式</li><li>fmt 表示显示的格式</li><li>addr 表示内存地址<br>当你用 display 设定好了一个或多个表达式后，只要你的程序被停下来，GDB 会自动显示你所设置的这些表达式的值。</li></ul><p>格式 i 和 s 同样被 display 支持，一个非常有用的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display/i <span class="variable">$pc</span></span><br></pre></td></tr></table></figure><p>$pc 是 GDB 的环境变量，表示着指令的地址，/i 则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形</p><h3 id="删除自动显示"><a href="#删除自动显示" class="headerlink" title="删除自动显示"></a>删除自动显示</h3><p>要删除自动显示可以用下面的命令</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undisplay &lt;dnums...&gt;</span><br><span class="line"><span class="keyword">delete</span> display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><ul><li>dnums 意为所设置好了的自动显式的编号。<br>如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</li></ul><h3 id="隐藏自动显示"><a href="#隐藏自动显示" class="headerlink" title="隐藏自动显示"></a>隐藏自动显示</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> display &lt;dnums<span class="built_in">..</span>.&gt;</span><br><span class="line"><span class="built_in">enable</span> display &lt;dnums<span class="built_in">..</span>.&gt;</span><br></pre></td></tr></table></figure><p>disable 和 enalbe 不删除自动显示的设置，而只是让其失效和恢复。</p><h3 id="查看设置的自动显示的信息"><a href="#查看设置的自动显示的信息" class="headerlink" title="查看设置的自动显示的信息"></a>查看设置的自动显示的信息</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">info</span> display</span><br></pre></td></tr></table></figure><p>查看 display 设置的自动显示的信息。GDB 会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否 enable。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小Linux系统编译与运行</title>
      <link href="/posts/42869/"/>
      <url>/posts/42869/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>win11 WSL2：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/CCECAA6776058E5E7B3BD5CD47C415D9.png" alt="环境"></p><h1 id="busybox编译"><a href="#busybox编译" class="headerlink" title="busybox编译"></a>busybox编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.busybox.net/downloads/busybox-1.37.0.tar.bz2</span><br><span class="line">bzip2 -d busybox-1.37.0.tar.bz2</span><br><span class="line">tar xvf busybox-1.37.0.tar</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> busybox-1.37.0</span><br></pre></td></tr></table></figure><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>这个版本直接编译aarch64有点问题，需要打一个补丁：</p>   <div class="tag link"><a class="link-card" title="libbb/sha: add missing sha-NI guard" href="https://lists.busybox.net/pipermail/busybox/2024-September/090899.html"><div class="left"><img src="https://www.busybox.net/favicon.ico"/></div><div class="right"><p class="text">libbb/sha: add missing sha-NI guard</p><p class="url">https://lists.busybox.net/pipermail/busybox/2024-September/090899.html</p></div></a></div><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- clean</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"><span class="comment"># Settings</span></span><br><span class="line"><span class="comment"># --- Build Option</span></span><br><span class="line"><span class="comment">#   [*] Build static binary (no shared libs)</span></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- install</span><br></pre></td></tr></table></figure><h2 id="创建inittab-rcS和fstab文件"><a href="#创建inittab-rcS和fstab文件" class="headerlink" title="创建inittab,rcS和fstab文件"></a>创建inittab,rcS和fstab文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> _install</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p dev etc home lib mnt proc root sys tmp var</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> etc/inittab</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d/</span><br><span class="line"><span class="built_in">touch</span> etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 755 etc/inittab</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/init.d/rcS</span><br></pre></td></tr></table></figure><p>inittab语法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt;<span class="symbol">:&lt;runlevels&gt;</span><span class="symbol">:&lt;action&gt;</span><span class="symbol">:&lt;process&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>id : /dev/id</li><li>runlevels : 忽略</li><li>action : 何时执行，有以下选项 sysinit, respawn, askfirst, wait, once,restart, ctrlaltdel, and shutdown</li><li>process : 应用程序或脚本</li></ul><p>etc/inittab 写入以下内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure></p><p>etc/init.d/rcS写入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/bin/mount -a </span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="keyword">if</span> [ -e /proc/sys/kernel/hotplug ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure><br>etc/fstab写入如下内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#device mount-point type option dump fsck</span></span><br><span class="line">proc  /proc proc  defaults 0 0</span><br><span class="line">tmpfs /tmp tmpfs defaults 0 0</span><br><span class="line">none  /tmp  ramfs defaults 0 0</span><br><span class="line">sysfs /sys  sysfs defaults 0 0</span><br><span class="line">mdev  /dev  ramfs defaults 0 0</span><br></pre></td></tr></table></figure></p><h2 id="添加设备文件"><a href="#添加设备文件" class="headerlink" title="添加设备文件"></a>添加设备文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dev</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> console c 5 1</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> null c 1 3</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> busybox-1.37.0/_install</span><br><span class="line">find . | cpio -o -H newc | gzip -c &gt; ../initramfs.cpio.gz</span><br><span class="line"><span class="built_in">cp</span> ../initramfs.cpio.gz ~/tftp</span><br></pre></td></tr></table></figure><h1 id="Linux-内核编译"><a href="#Linux-内核编译" class="headerlink" title="Linux 内核编译"></a>Linux 内核编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install gcc-aarch64-linux-gnu</span><br><span class="line"><span class="built_in">sudo</span> apt install libssl-dev</span><br><span class="line"></span><br><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.238.tar.xz</span><br><span class="line">tar xvf linux-5.10.238.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.10.238</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- clean</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm64/boot/Image ~/tftp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="qemu运行"><a href="#qemu运行" class="headerlink" title="qemu运行"></a>qemu运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">  -cpu cortex-a57 \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -machine <span class="built_in">type</span>=virt \</span><br><span class="line">  -nographic \</span><br><span class="line">  -smp 2 \</span><br><span class="line">  -kernel ~/tftp/Image  \</span><br><span class="line">  -initrd ~/tftp/initramfs.cpio.gz   \</span><br><span class="line">  -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">  -device virtio-scsi-device</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">zhaohang@ZhaoHang:~/kernel/my_arm64_programming$ qemu-system-aarch64 \</span><br><span class="line">  -cpu cortex-a57 \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -machine <span class="built_in">type</span>=virt \</span><br><span class="line">  -nographic \</span><br><span class="line">  -smp 2 \</span><br><span class="line">  -kernel ~/tftp/Image  \</span><br><span class="line">  -initrd ~/tftp/initramfs.cpio.gz   \</span><br><span class="line">  -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">  -device virtio-scsi-device</span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd070]</span><br><span class="line">[    0.000000] Linux version 5.10.238 (zhaohang@ZhaoHang) (aarch64-linux-gnu-gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils <span class="keyword">for</span> Ubuntu) 2.38) <span class="comment">#2 SMP PREEMPT Mon Jun 23 13:01:18 CST 2025</span></span><br><span class="line">[    0.000000] random: crng init <span class="keyword">done</span></span><br><span class="line">[    0.000000] Machine model: linux,dummy-virt</span><br><span class="line">[    0.000000] efi: UEFI not found.</span><br><span class="line">[    0.000000] NUMA: No NUMA configuration found</span><br><span class="line">[    0.000000] NUMA: Faking a node at [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] NUMA: NODE_DATA [mem 0x5fef4b00-0x5fef6fff]</span><br><span class="line">[    0.000000] Zone ranges:</span><br><span class="line">[    0.000000]   DMA      [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000]   DMA32    empty</span><br><span class="line">[    0.000000]   Normal   empty</span><br><span class="line">[    0.000000] Movable zone start <span class="keyword">for</span> each node</span><br><span class="line">[    0.000000] Early memory node ranges</span><br><span class="line">[    0.000000]   node   0: [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] Initmem setup node 0 [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] cma: Reserved 32 MiB at 0x000000005c000000</span><br><span class="line">[    0.000000] psci: probing <span class="keyword">for</span> conduit method from DT.</span><br><span class="line">[    0.000000] psci: PSCIv1.1 detected <span class="keyword">in</span> firmware.</span><br><span class="line">[    0.000000] psci: Using standard PSCI v0.2 <span class="keyword">function</span> IDs</span><br><span class="line">[    0.000000] psci: Trusted OS migration not required</span><br><span class="line">[    0.000000] psci: SMC Calling Convention v1.0</span><br><span class="line">[    0.000000] percpu: Embedded 23 pages/cpu s56664 r8192 d29352 u94208</span><br><span class="line">[    0.000000] Detected PIPT I-cache on CPU0</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 832075</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 834220</span><br><span class="line">[    0.000000] CPU features: detected: EL2 vector hardening</span><br><span class="line">[    0.000000] CPU features: kernel page table isolation forced ON by KASLR</span><br><span class="line">[    0.000000] CPU features: detected: Kernel page table isolation (KPTI)</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-v2</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-v4</span><br><span class="line">[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or 1530923</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-BHB</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 1742098</span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 129024</span><br><span class="line">[    0.000000] Policy zone: DMA</span><br><span class="line">[    0.000000] Kernel <span class="built_in">command</span> line: rdinit=/linuxrc console=ttyAMA0</span><br><span class="line">[    0.000000] Dentry cache <span class="built_in">hash</span> table entries: 65536 (order: 7, 524288 bytes, linear)</span><br><span class="line">[    0.000000] Inode-cache <span class="built_in">hash</span> table entries: 32768 (order: 6, 262144 bytes, linear)</span><br><span class="line">[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span><br><span class="line">[    0.000000] Memory: 439372K/524288K available (14464K kernel code, 2810K rwdata, 7632K rodata, 5952K init, 512K bss, 52148K reserved, 32768K cma-reserved)</span><br><span class="line">[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=2, Nodes=1</span><br><span class="line">[    0.000000] rcu: Preemptible hierarchical RCU implementation.</span><br><span class="line">[    0.000000] rcu:     RCU event tracing is enabled.</span><br><span class="line">[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=256 to nr_cpu_ids=2.</span><br><span class="line">[    0.000000]  Trampoline variant of Tasks RCU enabled.</span><br><span class="line">[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.</span><br><span class="line">[    0.000000] rcu: Adjusting geometry <span class="keyword">for</span> rcu_fanout_leaf=16, nr_cpu_ids=2</span><br><span class="line">[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0</span><br><span class="line">[    0.000000] GICv2m: range[mem 0x08020000-0x08020fff], SPI[80:143]</span><br><span class="line">[    0.000000] arch_timer: cp15 timer(s) running at 62.50MHz (virt).</span><br><span class="line">[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x1cd42e208c, max_idle_ns: 881590405314 ns</span><br><span class="line">[    0.000135] sched_clock: 56 bits at 62MHz, resolution 16ns, wraps every 4398046511096ns</span><br><span class="line">[    0.005145] Console: colour dummy device 80x25</span><br><span class="line">[    0.006576] Calibrating delay loop (skipped), value calculated using timer frequency.. 125.00 BogoMIPS (lpj=250000)</span><br><span class="line">[    0.006668] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.007333] LSM: Security Framework initializing</span><br><span class="line">[    0.008050] Mount-cache <span class="built_in">hash</span> table entries: 1024 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.008075] Mountpoint-cache <span class="built_in">hash</span> table entries: 1024 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.025711] /cpus/cpu-map: empty cluster</span><br><span class="line">[    0.030337] rcu: Hierarchical SRCU implementation.</span><br><span class="line">[    0.032757] EFI services will not be available.</span><br><span class="line">[    0.033350] smp: Bringing up secondary CPUs ...</span><br><span class="line">[    0.036124] Detected PIPT I-cache on CPU1</span><br><span class="line">[    0.036589] CPU1: Booted secondary processor 0x0000000001 [0x411fd070]</span><br><span class="line">[    0.038611] smp: Brought up 1 node, 2 CPUs</span><br><span class="line">[    0.038641] SMP: Total of 2 processors activated.</span><br><span class="line">[    0.038684] CPU features: detected: 32-bit EL0 Support</span><br><span class="line">[    0.038732] CPU features: detected: CRC32 instructions</span><br><span class="line">[    0.038761] CPU features: detected: 32-bit EL1 Support</span><br><span class="line">[    0.087011] CPU: All CPU(s) started at EL1</span><br><span class="line">[    0.087320] alternatives: patching kernel code</span><br><span class="line">[    0.100786] devtmpfs: initialized</span><br><span class="line">[    0.106839] KASLR enabled</span><br><span class="line">[    0.107566] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns</span><br><span class="line">[    0.107783] futex <span class="built_in">hash</span> table entries: 512 (order: 3, 32768 bytes, linear)</span><br><span class="line">[    0.110482] pinctrl core: initialized pinctrl subsystem</span><br><span class="line">[    0.117149] DMI not present or invalid.</span><br><span class="line">[    0.123022] NET: Registered protocol family 16</span><br><span class="line">[    0.130687] DMA: preallocated 128 KiB GFP_KERNEL pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.130888] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.131032] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA32 pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.131170] audit: initializing netlink subsys (disabled)</span><br><span class="line">[    0.132726] audit: <span class="built_in">type</span>=2000 audit(0.124:1): state=initialized audit_enabled=0 res=1</span><br><span class="line">[    0.135229] thermal_sys: Registered thermal governor <span class="string">&#x27;step_wise&#x27;</span></span><br><span class="line">[    0.135284] thermal_sys: Registered thermal governor <span class="string">&#x27;power_allocator&#x27;</span></span><br><span class="line">[    0.135718] cpuidle: using governor menu</span><br><span class="line">[    0.136329] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.</span><br><span class="line">[    0.136815] ASID allocator initialised with 32768 entries</span><br><span class="line">[    0.139125] Serial: AMBA PL011 UART driver</span><br><span class="line">[    0.165966] 9000000.pl011: ttyAMA0 at MMIO 0x9000000 (irq = 47, base_baud = 0) is a PL011 rev1</span><br><span class="line">[    0.256055] printk: console [ttyAMA0] enabled</span><br><span class="line">[    0.275753] HugeTLB registered 1.00 GiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.276425] HugeTLB registered 32.0 MiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.278075] HugeTLB registered 2.00 MiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.279114] HugeTLB registered 64.0 KiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.287377] cryptd: max_cpu_qlen <span class="built_in">set</span> to 1000</span><br><span class="line">[    0.295509] ACPI: Interpreter disabled.</span><br><span class="line">[    0.298412] iommu: Default domain <span class="built_in">type</span>: Translated</span><br><span class="line">[    0.299715] vgaarb: loaded</span><br><span class="line">[    0.300806] SCSI subsystem initialized</span><br><span class="line">[    0.302702] usbcore: registered new interface driver usbfs</span><br><span class="line">[    0.303416] usbcore: registered new interface driver hub</span><br><span class="line">[    0.303948] usbcore: registered new device driver usb</span><br><span class="line">[    0.305361] pps_core: LinuxPPS API ver. 1 registered</span><br><span class="line">[    0.305774] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;</span><br><span class="line">[    0.306671] PTP clock support registered</span><br><span class="line">[    0.307422] EDAC MC: Ver: 3.0.0</span><br><span class="line">[    0.311302] FPGA manager framework</span><br><span class="line">[    0.312553] Advanced Linux Sound Architecture Driver Initialized.</span><br><span class="line">[    0.320481] clocksource: Switched to clocksource arch_sys_counter</span><br><span class="line">[    0.321721] VFS: Disk quotas dquot_6.6.0</span><br><span class="line">[    0.322248] VFS: Dquot-cache <span class="built_in">hash</span> table entries: 512 (order 0, 4096 bytes)</span><br><span class="line">[    0.325830] pnp: PnP ACPI: disabled</span><br><span class="line">[    0.352101] NET: Registered protocol family 2</span><br><span class="line">[    0.353501] IP idents <span class="built_in">hash</span> table entries: 8192 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.357091] tcp_listen_portaddr_hash <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes, linear)</span><br><span class="line">[    0.357844] TCP established <span class="built_in">hash</span> table entries: 4096 (order: 3, 32768 bytes, linear)</span><br><span class="line">[    0.358536] TCP <span class="built_in">bind</span> <span class="built_in">hash</span> table entries: 4096 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.359240] TCP: Hash tables configured (established 4096 <span class="built_in">bind</span> 4096)</span><br><span class="line">[    0.360804] UDP <span class="built_in">hash</span> table entries: 256 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.361461] UDP-Lite <span class="built_in">hash</span> table entries: 256 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.362658] NET: Registered protocol family 1</span><br><span class="line">[    0.366482] RPC: Registered named UNIX socket transport module.</span><br><span class="line">[    0.366894] RPC: Registered udp transport module.</span><br><span class="line">[    0.367151] RPC: Registered tcp transport module.</span><br><span class="line">[    0.367596] RPC: Registered tcp NFSv4.1 backchannel transport module.</span><br><span class="line">[    0.368532] PCI: CLS 0 bytes, default 64</span><br><span class="line">[    0.371336] Unpacking initramfs...</span><br><span class="line">[    0.423234] Freeing initrd memory: 1156K</span><br><span class="line">[    0.425734] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available</span><br><span class="line">[    0.426386] kvm [1]: HYP mode not available</span><br><span class="line">[    0.438866] Initialise system trusted keyrings</span><br><span class="line">[    0.441323] workingset: timestamp_bits=42 max_order=17 bucket_order=0</span><br><span class="line">[    0.449648] squashfs: version 4.0 (2009/01/31) Phillip Lougher</span><br><span class="line">[    0.451781] NFS: Registering the id_resolver key <span class="built_in">type</span></span><br><span class="line">[    0.452635] Key <span class="built_in">type</span> id_resolver registered</span><br><span class="line">[    0.452872] Key <span class="built_in">type</span> id_legacy registered</span><br><span class="line">[    0.453347] nfs4filelayout_init: NFSv4 File Layout Driver Registering...</span><br><span class="line">[    0.453801] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...</span><br><span class="line">[    0.454953] 9p: Installing v9fs 9p2000 file system support</span><br><span class="line">[    0.485329] Key <span class="built_in">type</span> asymmetric registered</span><br><span class="line">[    0.486010] Asymmetric key parser <span class="string">&#x27;x509&#x27;</span> registered</span><br><span class="line">[    0.486459] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 245)</span><br><span class="line">[    0.486881] io scheduler mq-deadline registered</span><br><span class="line">[    0.487275] io scheduler kyber registered</span><br><span class="line">[    0.498447] pl061_gpio 9030000.pl061: PL061 GPIO chip registered</span><br><span class="line">[    0.501854] pci-host-generic 4010000000.pcie: host bridge /pcie@10000000 ranges:</span><br><span class="line">[    0.502917] pci-host-generic 4010000000.pcie:       IO 0x003eff0000..0x003effffff -&gt; 0x0000000000</span><br><span class="line">[    0.503846] pci-host-generic 4010000000.pcie:      MEM 0x0010000000..0x003efeffff -&gt; 0x0010000000</span><br><span class="line">[    0.504662] pci-host-generic 4010000000.pcie:      MEM 0x8000000000..0xffffffffff -&gt; 0x8000000000</span><br><span class="line">[    0.505854] pci-host-generic 4010000000.pcie: ECAM at [mem 0x4010000000-0x401fffffff] <span class="keyword">for</span> [bus 00-ff]</span><br><span class="line">[    0.507028] pci-host-generic 4010000000.pcie: PCI host bridge to bus 0000:00</span><br><span class="line">[    0.507648] pci_bus 0000:00: root bus resource [bus 00-ff]</span><br><span class="line">[    0.508176] pci_bus 0000:00: root bus resource [io  0x0000-0xffff]</span><br><span class="line">[    0.509569] pci_bus 0000:00: root bus resource [mem 0x10000000-0x3efeffff]</span><br><span class="line">[    0.511529] pci_bus 0000:00: root bus resource [mem 0x8000000000-0xffffffffff]</span><br><span class="line">[    0.513307] pci 0000:00:00.0: [1b36:0008] <span class="built_in">type</span> 00 class 0x060000</span><br><span class="line">[    0.515919] pci 0000:00:01.0: [1af4:1000] <span class="built_in">type</span> 00 class 0x020000</span><br><span class="line">[    0.517340] pci 0000:00:01.0: reg 0x10: [io  0x0000-0x001f]</span><br><span class="line">[    0.517754] pci 0000:00:01.0: reg 0x14: [mem 0x00000000-0x00000fff]</span><br><span class="line">[    0.518388] pci 0000:00:01.0: reg 0x20: [mem 0x00000000-0x00003fff 64bit pref]</span><br><span class="line">[    0.518923] pci 0000:00:01.0: reg 0x30: [mem 0x00000000-0x0003ffff pref]</span><br><span class="line">[    0.521212] pci 0000:00:01.0: BAR 6: assigned [mem 0x10000000-0x1003ffff pref]</span><br><span class="line">[    0.522137] pci 0000:00:01.0: BAR 4: assigned [mem 0x8000000000-0x8000003fff 64bit pref]</span><br><span class="line">[    0.523076] pci 0000:00:01.0: BAR 1: assigned [mem 0x10040000-0x10040fff]</span><br><span class="line">[    0.523801] pci 0000:00:01.0: BAR 0: assigned [io  0x1000-0x101f]</span><br><span class="line">[    0.528448] EINJ: ACPI disabled.</span><br><span class="line">[    0.542283] virtio-pci 0000:00:01.0: enabling device (0000 -&gt; 0003)</span><br><span class="line">[    0.554485] Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled</span><br><span class="line">[    0.558302] SuperH (H)SCI(F) driver initialized</span><br><span class="line">[    0.559486] msm_serial: driver initialized</span><br><span class="line">[    0.561993] cacheinfo: Unable to detect cache hierarchy <span class="keyword">for</span> CPU 0</span><br><span class="line">[    0.575536] loop: module loaded</span><br><span class="line">[    0.577188] megasas: 07.714.04.00-rc1</span><br><span class="line">[    0.581247] physmap-flash 0.flash: physmap platform flash device: [mem 0x00000000-0x03ffffff]</span><br><span class="line">[    0.583156] 0.flash: Found 2 x16 devices at 0x0 <span class="keyword">in</span> 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000</span><br><span class="line">[    0.584568] Intel/Sharp Extended Query Table at 0x0031</span><br><span class="line">[    0.585746] Using buffer write method</span><br><span class="line">[    0.586466] physmap-flash 0.flash: physmap platform flash device: [mem 0x04000000-0x07ffffff]</span><br><span class="line">[    0.587833] 0.flash: Found 2 x16 devices at 0x0 <span class="keyword">in</span> 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000</span><br><span class="line">[    0.589950] Intel/Sharp Extended Query Table at 0x0031</span><br><span class="line">[    0.590679] Using buffer write method</span><br><span class="line">[    0.591154] Concatenating MTD devices:</span><br><span class="line">[    0.591566] (0): <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.591870] (1): <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.592172] into device <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.639324] tun: Universal TUN/TAP device driver, 1.6</span><br><span class="line">[    0.648697] thunder_xcv, ver 1.0</span><br><span class="line">[    0.649091] thunder_bgx, ver 1.0</span><br><span class="line">[    0.649532] nicpf, ver 1.0</span><br><span class="line">[    0.651118] hclge is initializing</span><br><span class="line">[    0.651699] hns3: Hisilicon Ethernet Network Driver <span class="keyword">for</span> Hip08 Family - version</span><br><span class="line">[    0.652969] hns3: Copyright (c) 2017 Huawei Corporation.</span><br><span class="line">[    0.654822] e1000: Intel(R) PRO/1000 Network Driver</span><br><span class="line">[    0.655566] e1000: Copyright (c) 1999-2006 Intel Corporation.</span><br><span class="line">[    0.656421] e1000e: Intel(R) PRO/1000 Network Driver</span><br><span class="line">[    0.657100] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.</span><br><span class="line">[    0.657828] igb: Intel(R) Gigabit Ethernet Network Driver</span><br><span class="line">[    0.658543] igb: Copyright (c) 2007-2014 Intel Corporation.</span><br><span class="line">[    0.659076] igbvf: Intel(R) Gigabit Virtual Function Network Driver</span><br><span class="line">[    0.659905] igbvf: Copyright (c) 2009 - 2012 Intel Corporation.</span><br><span class="line">[    0.661636] sky2: driver version 1.30</span><br><span class="line">[    0.663482] VFIO - User Level meta-driver version: 0.3</span><br><span class="line">[    0.666363] ehci_hcd: USB 2.0 <span class="string">&#x27;Enhanced&#x27;</span> Host Controller (EHCI) Driver</span><br><span class="line">[    0.666801] ehci-pci: EHCI PCI platform driver</span><br><span class="line">[    0.667200] ehci-platform: EHCI generic platform driver</span><br><span class="line">[    0.667555] ehci-orion: EHCI orion driver</span><br><span class="line">[    0.668162] ehci-exynos: EHCI Exynos driver</span><br><span class="line">[    0.669422] ohci_hcd: USB 1.1 <span class="string">&#x27;Open&#x27;</span> Host Controller (OHCI) Driver</span><br><span class="line">[    0.670008] ohci-pci: OHCI PCI platform driver</span><br><span class="line">[    0.670583] ohci-platform: OHCI generic platform driver</span><br><span class="line">[    0.671027] ohci-exynos: OHCI Exynos driver</span><br><span class="line">[    0.672066] usbcore: registered new interface driver usb-storage</span><br><span class="line">[    0.678548] rtc-pl031 9010000.pl031: registered as rtc0</span><br><span class="line">[    0.679438] rtc-pl031 9010000.pl031: setting system clock to 2025-06-23T05:12:11 UTC (1750655531)</span><br><span class="line">[    0.680812] i2c /dev entries driver</span><br><span class="line">[    0.687138] sdhci: Secure Digital Host Controller Interface driver</span><br><span class="line">[    0.687486] sdhci: Copyright(c) Pierre Ossman</span><br><span class="line">[    0.688175] Synopsys Designware Multimedia Card Interface Driver</span><br><span class="line">[    0.689770] sdhci-pltfm: SDHCI platform and OF driver helper</span><br><span class="line">[    0.691932] ledtrig-cpu: registered to indicate activity on CPUs</span><br><span class="line">[    0.694429] usbcore: registered new interface driver usbhid</span><br><span class="line">[    0.694654] usbhid: USB HID core driver</span><br><span class="line">[    0.700987] NET: Registered protocol family 17</span><br><span class="line">[    0.702090] 9pnet: Installing 9P2000 support</span><br><span class="line">[    0.702525] Key <span class="built_in">type</span> dns_resolver registered</span><br><span class="line">[    0.703492] registered taskstats version 1</span><br><span class="line">[    0.703776] Loading compiled-in X.509 certificates</span><br><span class="line">[    0.710892] input: gpio-keys as /devices/platform/gpio-keys/input/input0</span><br><span class="line">[    0.714806] clk: Disabling unused clocks</span><br><span class="line">[    0.715339] ALSA device list:</span><br><span class="line">[    0.715654]   No soundcards found.</span><br><span class="line">[    0.718941] uart-pl011 9000000.pl011: no DMA platform data</span><br><span class="line">[    0.752373] Freeing unused kernel memory: 5952K</span><br><span class="line">[    0.753454] Run /linuxrc as init process</span><br><span class="line"></span><br><span class="line">Please press Enter to activate this console.</span><br><span class="line">~ <span class="comment">#</span></span><br><span class="line">~ <span class="comment"># ls</span></span><br><span class="line">bin      etc      lib      mnt      root     sys      usr</span><br><span class="line">dev      home     linuxrc  proc     sbin     tmp      var</span><br></pre></td></tr></table></figure><br>ctrl-a x退出qemu</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AArch64 ASM</title>
      <link href="/posts/42868/"/>
      <url>/posts/42868/</url>
      
        <content type="html"><![CDATA[<h1 id="preknowledge"><a href="#preknowledge" class="headerlink" title="preknowledge"></a>preknowledge</h1><p>1 <strong>byte</strong> has 8 <strong>bits</strong></p><ul><li><strong>char</strong> has 1 <strong>byte</strong></li><li><strong>short</strong> has 2 <strong>byte</strong></li><li><strong>int</strong> has 4 <strong>byte</strong></li></ul><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/v2-b9e8babf753b1691039458592667121a_1440w.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><ul><li><p><strong>All</strong> AARCH64 instructions are 4 bytes in width.</p></li><li><p><strong>All</strong> AARCH64 pointers are 8 bytes in width†.</p><blockquote><p>While this is technically true, typically only the lower 39, 42 or 48 bits of addresses in Linux systems are used - i.e. the virtual address space of an ARM Linux process is smaller than 64 bits. The upper bits are set to zero when considering the address as an 8-byte value.</p></blockquote></li></ul><h1 id="register"><a href="#register" class="headerlink" title="register"></a>register</h1><h2 id="register-access-speed"><a href="#register-access-speed" class="headerlink" title="register access speed"></a>register access speed</h2><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/latency.png" alt="Latency"></p><blockquote><p>This says that if we liken accessing a register (which can be done at <em>least</em> once per CPU Clock Cycle) to one second, accessing RAM would be like a 3.5 to 5.5 minute wait.</p></blockquote><h2 id="register-type"><a href="#register-type" class="headerlink" title="register type"></a>register type</h2><ul><li>rn means register “of some type” number n.</li></ul><p>The kind of register is specified by a letter. Which register within a given type is specified by a number. There are some exceptions to this. Here is an introductory summary:</p><div class="table-container"><table><thead><tr><th>Letter</th><th>Type</th></tr></thead><tbody><tr><td>x</td><td>64 bit integer or pointer</td></tr><tr><td>w</td><td>32 bit <em>or smaller</em> integer</td></tr><tr><td>d</td><td>64 bit floats (doubles)</td></tr><tr><td>s</td><td>32 bit floats</td></tr></tbody></table></div><p>Some register types have been left out.</p><p>（Chapter 9.1）（Cortex-A Series Programmer’s Guide for ARMv8-A）</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511155518113.png" alt="image-20250511155518113"></p><ul><li>x29是栈帧指针（FP）</li><li>x30是链接寄存器（LR，即返回地址）</li></ul><p>The registers used for floating point types (and vector operations) are coincident:</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210301586.png" alt="image-20250511210301586"></p><ul><li><code>q</code> registers are a massive 16 bytes wide - quad words.(vn的别名，主要用于<strong>SIMD/Neon</strong> 指令中)</li><li><code>v</code> registers are also 16 bytes wide and are synonyms for the <code>q</code> registers.</li><li><code>d</code> registers for <code>doubles</code> which are 8 bytes wide - <strong>double precision</strong>. 2 per <code>v</code>.</li><li><code>s</code> registers for <code>floats</code> which are 4 bytes wide - <strong>single precisio</strong>n. 4 per <code>v</code>.</li><li><code>h</code> registers for <code>half precisions floats</code> which are 2 bytes wide. 8 per <code>v</code>.</li><li><code>b</code> registers for byte operations. 16 per <code>v</code>.</li></ul><h2 id="register-and-C-type"><a href="#register-and-C-type" class="headerlink" title="register and C type"></a>register and C type</h2><h3 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h3><div class="table-container"><table><thead><tr><th>This declares an integer</th><th>This IS an integer</th></tr></thead><tbody><tr><td>char</td><td>wn</td></tr><tr><td>short</td><td>wn</td></tr><tr><td>int</td><td>wn</td></tr><tr><td>long</td><td>xn</td></tr></tbody></table></div><h3 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h3><div class="table-container"><table><thead><tr><th>This declares a pointer</th><th>This IS a pointer</th></tr></thead><tbody><tr><td><em>type</em> *</td><td>xn</td></tr></tbody></table></div><p>All pointers are stored in x registers. X registers are 64 bits long but many operating systems do not support 64 bit address spaces because keeping track of that big of an address space itself would use a lot of space. Instead <strong>OS’s typically have 48 to 52 bit address spaces</strong>. </p><h3 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating Point"></a>Floating Point</h3><div class="table-container"><table><thead><tr><th>This declares a float</th><th>This IS a float</th></tr></thead><tbody><tr><td><code>float</code></td><td><code>sn</code></td></tr><tr><td><code>double</code></td><td><code>dn</code></td></tr><tr><td><code>__fp16</code> (half)</td><td><code>hn</code></td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210512600.png" alt="image-20250511210512600"></p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210539205.png" alt="image-20250511210539205"></p><p>vn是真正的物理寄存器名，<strong>推荐使用</strong>, 支持最多类型的访问（浮点 + SIMD）</p><p>qn是vn的别名，主要用于<strong>SIMD/Neon</strong> 指令中(<em>Single Instruction - Multiple Data</em>)</p><h1 id="instructions"><a href="#instructions" class="headerlink" title="instructions"></a>instructions</h1><h2 id="preknowledge-1"><a href="#preknowledge-1" class="headerlink" title="preknowledge"></a>preknowledge</h2><p><strong>EVERY</strong> AARCH64 instruction is 4 bytes wide. Everything the CPU needs to know about what the instruction is and what variation it might be plus what data it will use will be found in those 4 bytes.</p><ul><li>Most (but not all) AARCH64 instructions have three <em>operands</em>. These are read in the following way:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op     ra, rb, rc</span><br></pre></td></tr></table></figure><p>means:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ra</span> <span class="operator">=</span> rb op rc</span><br></pre></td></tr></table></figure><p>examples:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span>    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">1</span> <span class="comment">; means x0 = x0 - x1</span></span><br><span class="line">mov    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">1</span>     <span class="comment">; means x0 = x1</span></span><br></pre></td></tr></table></figure><ul><li><strong>[ ]</strong></li></ul><p>the <code>[</code> and <code>]</code> serve the same purpose of the asterisk in C and C++ indicating “dereference.” It means <strong>use what’s inside the brackets as an address for going out to memory</strong>.</p><p>when a  <strong>!</strong> is at the end of <strong>[]</strong> , for example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stp     x21, x30, [sp, -16]!  </span><br><span class="line"></span><br><span class="line">stp     x29, x30, [sp, -16]!    </span><br></pre></td></tr></table></figure><blockquote><p>Lastly, the exclamation point means that the stack pointer should be changed (i.e. the -16 applied to it) <em>before</em> the value of the stack pointer is used as the address in memory to which the registers will be copied. Again, this is a <strong>predecrement</strong>.</p></blockquote><p>it means:</p><ol><li><code>sp = sp - 16</code>（栈指针向下移动 16 字节）</li><li>把 <code>x29</code> 存入 <code>[sp]</code>，把 <code>x30</code> 存入 <code>[sp + 8]</code></li></ol><p>对应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldp     x29, x30, [sp], 16</span><br></pre></td></tr></table></figure><p>it means:</p><ol><li>从 <code>[sp]</code> 读取 8 字节给 <code>x29</code>，从 <code>[sp + 8]</code> 读取 8 字节给 <code>x30</code></li><li><code>sp = sp + 16</code>（释放栈帧空间）</li></ol><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><blockquote><p>x29是栈帧寄存器，但不是必须保存的</p></blockquote><h2 id="memory-access"><a href="#memory-access" class="headerlink" title="memory access"></a>memory access</h2><h3 id="ldr"><a href="#ldr" class="headerlink" title="ldr"></a>ldr</h3><blockquote><p><strong>load register</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr    x0, [sp]   // load 8 bytes from address specified by sp</span><br><span class="line">ldr    w0, [sp]   // load 4 bytes from address specified by sp</span><br><span class="line">ldrh   w0, [sp]   // load 2 bytes from address specified by sp</span><br><span class="line">ldrb   w0, [sp]   // load 1 byte  from address specified by sp</span><br></pre></td></tr></table></figure><p><strong>When misaligned accesses to RAM are made, the processor must slow down and access each byte individually. This is a big performance hit. Properly aligned access is critical to performance.</strong></p><h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><blockquote><p><strong>store register</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str    x0, [sp]   // store 8 bytes to address specified by sp</span><br><span class="line">str    w0, [sp]   // store 4 bytes to address specified by sp</span><br><span class="line">strh   w0, [sp]   // store 2 bytes to address specified by sp</span><br><span class="line">strb   w0, [sp]   // store 1 byte  to address specified by sp</span><br></pre></td></tr></table></figure><blockquote><p>Casting between integer types is in some cases accomplished by <code>anding</code> with <code>255</code> and <code>65535</code> (for <code>char</code> and <code>short</code>) or :</p><p>Whenever a narrower portion of a register is written to, the remainder of the register is zero’d out. That is: <code>ldrb</code> overwrites the least significant byte of an <code>x</code> register and zeros out the upper 7 bytes.</p></blockquote><h3 id="ldp"><a href="#ldp" class="headerlink" title="ldp"></a>ldp</h3><blockquote><p><strong>load pair, same as ldr but load a pair of value</strong></p></blockquote><h3 id="stp"><a href="#stp" class="headerlink" title="stp"></a>stp</h3><blockquote><p><strong>store pair, same as str but load a pair of value</strong></p></blockquote><p><strong>offsets</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) LDR Xt, [Xn|SP&#123;, #pimm&#125;] ; 64-bit general registers</span><br><span class="line">2) LDR Xt, [Xn|SP], #simm ; 64-bit general registers, Post-index</span><br><span class="line">3) LDR Xt, [Xn|SP, #simm]! ; 64-bit general registers, Pre-index</span><br></pre></td></tr></table></figure><ul><li><code>simm</code> can be in the range of -256 to 255 (10 byte signed value).</li><li><code>pimm</code> can be in the range of 0 to 32760 in multiples of 8.</li></ul><h3 id="three-patterns"><a href="#three-patterns" class="headerlink" title="three patterns"></a><strong>three patterns</strong></h3><ol><li>普通偏移模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn, #pimm]</span><br></pre></td></tr></table></figure><blockquote><p>从 <code>Xn + pimm</code> 的地址加载数据到 <code>Xt</code>；<strong>地址寄存器 <code>Xn</code> 不变</strong>；</p><p><code>pimm</code> 是一个 <strong>正的立即数（positive immediate）</strong>，必须是 8 的倍数，最大为 32760。</p></blockquote><ol><li>后变基模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn], #simm</span><br></pre></td></tr></table></figure><blockquote><p>先用 <code>Xn</code> 的原始值作为地址加载数据到 <code>Xt</code>，然后再用 <code>simm</code> 更新 <code>Xn</code>；<strong>地址寄存器 <code>Xn</code> 改变</strong>；</p></blockquote><ol><li>前变基模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn, #simm]!</span><br></pre></td></tr></table></figure><blockquote><p>先用 <code>Xn + simm</code> 作为地址加载数据到 <code>Xt</code>，并将更新后的地址写回 <code>Xn</code>；<strong>地址寄存器 <code>Xn</code> 改变</strong>；</p></blockquote><h3 id="pseudo-instruction"><a href="#pseudo-instruction" class="headerlink" title="pseudo instruction"></a>pseudo instruction</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr     x1, =label</span><br></pre></td></tr></table></figure><ul><li><p>the assembler puts the address of the label into a special region of memory called a “<strong>literal pool</strong>.” What matters is <strong>this region of memory is placed immediately after (therefore nearby) your code</strong>.</p></li><li><p>Then, the assembler computes the difference between the address of the current instruction (the <code>ldr</code> itself) and the address of the data in the literal pool made from the labeled data.</p></li><li><p>The assembler generates a different <code>ldr</code> instruction which uses the difference (or offset) of the data relative to the program counter (<code>pc</code>). The <code>pc</code> is non-other the address of the current instruction.</p></li><li><p>Because the literal pool for your code is located nearby your code, the offset from the current instruction to the data in the pool is a relatively <strong>small</strong> number. Small enough, to fit inside a four byte <code>ldr</code> instruction.</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr    x1, [pc, offset to data in literal pool]</span><br></pre></td></tr></table></figure><blockquote><p><em>A downside of this approach is that the literal pool, from which the address is loaded, resides in RAM. This means each of these <code>ldr</code> pseudo instructions incurs a memory reference.</em></p></blockquote><h3 id="literal-pool"><a href="#literal-pool" class="headerlink" title="literal pool"></a>literal pool</h3><p>compare</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr x1, =q</span><br><span class="line">ldr x1, q</span><br></pre></td></tr></table></figure><p>aarch64 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .global     main       // expose main to linker                                        </span><br><span class="line">        .text                  // begin to write code                 </span><br><span class="line">        .align      2          // the code should certainly begin on an even address                    </span><br><span class="line">                                                                       </span><br><span class="line">main:   str         x30, [sp, -16]!                                     </span><br><span class="line">                                                                       </span><br><span class="line">        ldr         x0, =fmt          </span><br><span class="line">        ldr         x1, =q                     </span><br><span class="line">        ldr         x2, [x1]                 </span><br><span class="line">        bl          printf               </span><br><span class="line">                                                                       </span><br><span class="line">        ldr         x0, =fmt                   </span><br><span class="line">        ldr         x1, q                    </span><br><span class="line">        ldr         x2, [x1]                   </span><br><span class="line">        bl          printf            </span><br><span class="line">                                    </span><br><span class="line">        ldr         x30, [sp], 16           </span><br><span class="line">        mov         w0, wzr                                             </span><br><span class="line">        ret                                                             </span><br><span class="line">                                                                       </span><br><span class="line">        .data                                                           </span><br><span class="line">q:      .quad       0x1122334455667788                                 </span><br><span class="line">fmt:    .asciz      &quot;address: %p value: %lx\n&quot;                         </span><br><span class="line">                                                                       </span><br><span class="line">        .end                                                           </span><br><span class="line">                                                                       </span><br></pre></td></tr></table></figure><p>disasembling the binary machine code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000000007a0 &lt;main&gt;:</span><br><span class="line"> 7a0:   f81f0ffe   str  x30, [sp, #-16]!</span><br><span class="line"> 7a4:   58000160   ldr  x0, 7d0 &lt;main+0x30&gt;</span><br><span class="line"> 7a8:   58000181   ldr  x1, 7d8 &lt;main+0x38&gt;</span><br><span class="line"> 7ac:   f9400022   ldr  x2, [x1]</span><br><span class="line"> 7b0:   97ffffb4   bl   680 &lt;printf@plt&gt;</span><br><span class="line"> 7b4:   580000e0   ldr  x0, 7d0 &lt;main+0x30&gt;</span><br><span class="line"> 7b8:   580842c1   ldr  x1, 11010 &lt;q&gt;</span><br><span class="line"> 7bc:   f9400022   ldr  x2, [x1]</span><br><span class="line"> 7c0:   97ffffb0   bl   680 &lt;printf@plt&gt;</span><br><span class="line"> 7c4:   f84107fe   ldr  x30, [sp], #16</span><br><span class="line"> 7c8:   2a1f03e0   mov  w0, wzr</span><br><span class="line"> 7cc:   d65f03c0   ret</span><br></pre></td></tr></table></figure><p>and</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000000000011010 &lt;q&gt;:</span><br><span class="line">   11010:   55667788</span><br><span class="line">   11014:   11223344</span><br></pre></td></tr></table></figure><ul><li><p>It says <code>000000000011010 &lt;q&gt;:</code>. This means that what comes next is the data corresponding to what is labeled <code>q</code> in our source code. Notice the relocatable address of <code>11010</code>. We will explain “relocatable address” below.</p></li><li><p>Now, look at the disassembled code on the line beginning with <code>7b8</code>. It reads <code>ldr x1, 11010</code>. So the disassembled executable is saying “go to address 11010 and fetch its contents” which are our <code>1122334455667788</code>.</p></li></ul><div class="table-container"><table><thead><tr><th>Instruction</th><th>Meaning</th></tr></thead><tbody><tr><td>ldr r, =label</td><td>Load the address of the label into r</td></tr><tr><td>ldr r, label</td><td>Load the value found at the label into r</td></tr></tbody></table></div><h3 id="relocation-of-address-when-executing"><a href="#relocation-of-address-when-executing" class="headerlink" title="relocation of address when executing"></a>relocation of address when executing</h3><blockquote><p>None of the addresses we have seen so far are the final addresses that will be used once the program is actually running. <strong>All addresses will be <em>relocated</em></strong>.</p></blockquote><p>One reason for this is a guard against malware. A technique called <strong>Address Space Layout Randomization (ASLR)</strong> prevents malware writers from being able to know ahead where to modify your executable in order to accomplish their nefarious purposes.</p><p><strong>64 bit ARM Linux kernels allocate 39, 42 or 48 bits for the size of a process’s virtual address space</strong>. Notice 42 and 48 bit values require 6 bytes to hold them. A virtual address space is all of the addresses a process can generate / use. Further, all addresses used by processes are virtual addresses.</p><p>using this can avoid literal pool</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp    x0, s</span><br><span class="line">add     x0, x0, :lo12:s</span><br></pre></td></tr></table></figure><h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><h4 id="loading-storing-various-sizes-of-integers"><a href="#loading-storing-various-sizes-of-integers" class="headerlink" title="loading (storing) various sizes of integers"></a>loading (storing) various sizes of integers</h4><div class="table-container"><table><thead><tr><th>Instruction</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td><code>ldr x0, [x1]</code></td><td style="text-align:left">Fetches a 64 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr><tr><td><code>ldr w0, [x1]</code></td><td style="text-align:left">Fetches a 32 bit value from the address specified by <code>x1</code> and places it in <code>w0</code></td></tr><tr><td><code>ldrh w0, [x1]</code></td><td style="text-align:left">Fetches a 16 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr><tr><td><code>ldrb w0, [x1]</code></td><td style="text-align:left">Fetches an 8 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr></tbody></table></div><ul><li>Pointers and longs use <code>x</code> registers.</li><li>All other integer sizes use <code>w</code> registers where the instruction itself specifies the size.</li></ul><h4 id="array-indexing"><a href="#array-indexing" class="headerlink" title="array indexing"></a>array indexing</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Sum</span><span class="params">(<span class="type">long</span> * values, <span class="type">long</span> length)</span>   </span><br><span class="line">&#123;                                          </span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;                          </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; length; i++)            </span><br><span class="line">    &#123;                                           </span><br><span class="line">        sum += values[i];                         </span><br><span class="line">    &#125;                                                   </span><br><span class="line">    <span class="keyword">return</span> sum;                                            </span><br><span class="line">&#125;                                                                                                     </span><br></pre></td></tr></table></figure><p>Notice we’re using the index variable <code>i</code> for nothing more than traipsing through the array. This is fantastically inefficient (in this case).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Sum</span><span class="params">(<span class="type">long</span> * values, <span class="type">long</span> length)</span>         </span><br><span class="line">&#123;                                     </span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;                           </span><br><span class="line">    <span class="type">long</span> * end = values + length;                   </span><br><span class="line">    <span class="keyword">while</span> (values &lt; end)                     </span><br><span class="line">    &#123;                                              </span><br><span class="line">        sum += *(values++);                            </span><br><span class="line">    &#125;                                                </span><br><span class="line">    <span class="keyword">return</span> sum;                                           </span><br><span class="line">&#125;                                                            </span><br></pre></td></tr></table></figure><p>Notice we don’t use an index variable any longer. Instead, we use the pointer itself for both the dereferencing <em>and</em> to tell us when to stop the loop.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    .global Sum                                           </span><br><span class="line">    .text                                                </span><br><span class="line">    .align  4                                           </span><br><span class="line"></span><br><span class="line">//  x0 is the pointer to data                         </span><br><span class="line">//  x1 is the length and is reused as `end`           </span><br><span class="line">//  x2 is the sum                                  </span><br><span class="line">//  x3 is the current dereferenced value                    </span><br><span class="line"></span><br><span class="line">Sum:                                                     </span><br><span class="line">    mov     x2, xzr              // x2 = 0                     </span><br><span class="line">    add     x1, x0, x1, lsl 3    //  x1 = x0+x1*8              </span><br><span class="line">    b       2f                                   </span><br><span class="line"></span><br><span class="line">1:  ldr     x3, [x0], 8                          </span><br><span class="line">    add     x2, x2, x3                             </span><br><span class="line">2:  cmp     x0, x1                               </span><br><span class="line">    blt     1b                                        </span><br><span class="line"></span><br><span class="line">    mov     x0, x2                                  </span><br><span class="line">    ret                                             </span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure><h4 id="faster-memory-copy"><a href="#faster-memory-copy" class="headerlink" title="faster memory copy"></a>faster memory copy</h4><p>Suppose you needed to <strong>copy 16 bytes of memory</strong> from one place to another. You might do it like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SillyCopy16</span><span class="params">(<span class="type">uint8_t</span> * dest, <span class="type">uint8_t</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        *(dest++) = *(src++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is especially silly as why would you go through 16 loops when you could have simply:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SillyCopy16</span><span class="params">(<span class="type">uint64_t</span> * dest, <span class="type">uint64_t</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(dest++) = *(src++); <span class="comment">// 3</span></span><br><span class="line">    *dest = *src;         <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:              // 1</span><br><span class="line">    ldr    x2, [x0], 8    // 2</span><br><span class="line">    str    x2, [x1], 8    // 3</span><br><span class="line">    ldr    x2, [x0]       // 4</span><br><span class="line">    str    x2, [x1]       // 5</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>using ldp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:</span><br><span class="line">    ldp    x2, x3, [x0]</span><br><span class="line">    stp    x2, x3, [x1]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>using q register</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:</span><br><span class="line">    ldr    q2, [x0]</span><br><span class="line">    str    q2, [x1]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h4 id="indexing-through-an-array-of-struct"><a href="#indexing-through-an-array-of-struct" class="headerlink" title="indexing through an array of struct"></a>indexing through an array of struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>                                       </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>                                       </span></span><br><span class="line"><span class="class">&#123;</span>                                                   </span><br><span class="line">    <span class="type">char</span> * fname;                                </span><br><span class="line">    <span class="type">char</span> * lname;                                      </span><br><span class="line">    <span class="type">int</span> age;                                        </span><br><span class="line">&#125;;                                                         </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rand</span><span class="params">()</span>;                                          </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> Person * <span class="title function_">FindOldestPerson</span><span class="params">(<span class="keyword">struct</span> Person *, <span class="type">int</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person * <span class="title function_">OriginalFindOldestPerson</span><span class="params">(<span class="keyword">struct</span> Person * people, <span class="type">int</span> length)</span></span><br><span class="line">&#123;                                                     </span><br><span class="line">    <span class="type">int</span> oldest_age = <span class="number">0</span>;                        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">oldest_ptr</span> =</span> <span class="literal">NULL</span>;               </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (people)                                        </span><br><span class="line">    &#123;                                                     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">end_ptr</span> =</span> people + length;       </span><br><span class="line">        <span class="keyword">while</span> (people &lt; end_ptr)                           </span><br><span class="line">        &#123;                                                   </span><br><span class="line">            <span class="keyword">if</span> (people-&gt;age &gt; oldest_age)             </span><br><span class="line">            &#123;                                      </span><br><span class="line">                oldest_age = people-&gt;age;            </span><br><span class="line">                oldest_ptr = people;                   </span><br><span class="line">            &#125;                               </span><br><span class="line">            people++;                          </span><br><span class="line">        &#125;                                         </span><br><span class="line">    &#125;                                             </span><br><span class="line">    <span class="keyword">return</span> oldest_ptr;                             </span><br><span class="line">&#125;                                                  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH  20                                </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                                            </span><br><span class="line">&#123;                                                   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">array</span>[<span class="title">LENGTH</span>];</span>                          </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)                     </span><br><span class="line">    &#123;                                               </span><br><span class="line">        <span class="built_in">array</span>[i].age = rand() % <span class="number">5000</span>;                   </span><br><span class="line">    &#125;                                                       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">oldest</span> =</span> FindOldestPerson(<span class="built_in">array</span>, LENGTH);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)                  </span><br><span class="line">    &#123;                                                   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">array</span>[i].age);               </span><br><span class="line">        <span class="keyword">if</span> (oldest == &amp;<span class="built_in">array</span>[i])                </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);                           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                                 </span><br><span class="line">    &#125;                                                  </span><br><span class="line">&#125;                                                           </span><br></pre></td></tr></table></figure><p><code>Line 11</code> tells us that somewhere else, there is a function called <code>FindOldestPerson</code>. That function must have a <code>.global</code> specifying the same name so that the linker can reconcile the reference to <code>FindOldestPerson</code>.</p><p><code>gcc</code> with <code>-O2</code> or <code>-O3</code> optimization rendered <code>OriginalFindOldestPerson()</code> into 18 lines of assembly language.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">        .global FindOldestPerson                                        // 1 </span><br><span class="line">        .text                                                           // 2 </span><br><span class="line">        .align  2                                                       // 3 </span><br><span class="line">                                                                        // 4 </span><br><span class="line">//  x0  has struct Person * people                                      // 5 </span><br><span class="line">//      will be used for oldest_ptr as this is the return value         // 6 </span><br><span class="line">//  w1  has int length                                                  // 7 </span><br><span class="line">//  w2  used for oldest_age                                             // 8 </span><br><span class="line">//  x3  used for Person *                                               // 9 </span><br><span class="line">//  x4  used for end_ptr                                                // 10 </span><br><span class="line">//  w5  used for scratch                                                // 11 </span><br><span class="line">                                                                        // 12 </span><br><span class="line">FindOldestPerson:                                                       // 13 </span><br><span class="line">        cbz     x0, 99f             // short circuit                    // 14 </span><br><span class="line">        mov     w2, wzr             // initial oldest age is 0          // 15 </span><br><span class="line">        mov     x3, x0              // initialize loop pointer          // 16 </span><br><span class="line">        mov     x0, xzr             // initialize return value          // 17 </span><br><span class="line">        mov     w5, 24              // struct is 24 bytes wide          // 18 </span><br><span class="line">        smaddl  x4, w1, w5, x3      // initialize end_ptr               // 19 </span><br><span class="line">        b       10f                 // enter loop                       // 20 </span><br><span class="line">                                                                        // 21 </span><br><span class="line">1:      ldr     w5, [x3, p.age]     // fetch loop ptr -&gt; age            // 22 </span><br><span class="line">        cmp     w2, w5              // compare to oldest_age            // 23 </span><br><span class="line">        csel    w2, w2, w5, gt      // update based on cmp              // 24 </span><br><span class="line">        csel    x0, x0, x3, gt      // update based on cmp              // 25 </span><br><span class="line">        add     x3, x3, 24          // increment loop ptr               // 26 </span><br><span class="line">10:     cmp     x3, x4              // has loop ptr reached end_ptr?    // 27 </span><br><span class="line">        blt     1b                  // no, not yet                      // 28 </span><br><span class="line">                                                                        // 29 </span><br><span class="line">99:     ret                                                             // 30 </span><br><span class="line">                                                                        // 31 </span><br><span class="line">        .data                                                           // 32 </span><br><span class="line">        .struct 0                                                       // 33 </span><br><span class="line">p.fn:   .skip   8                                                       // 34 </span><br><span class="line">p.ln:   .skip   8                                                       // 35 </span><br><span class="line">p.age:  .skip   4                                                       // 36 </span><br><span class="line">p.pad:  .skip   4                                                       // 37 </span><br><span class="line">                                                                        // 38 </span><br><span class="line">        .end                                                            // 39 </span><br></pre></td></tr></table></figure><h2 id="control-flow"><a href="#control-flow" class="headerlink" title="control flow"></a>control flow</h2><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><blockquote><p><strong>compare</strong></p></blockquote><p>discards the result of the subtraction but keeps a record of whether or not the result was less than, equal to or greater than zero. It sets the condition bits</p><h3 id="br"><a href="#br" class="headerlink" title="br"></a>br</h3><blockquote><p>Branch to Register</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br &lt;register&gt;</span><br></pre></td></tr></table></figure><p>无条件跳转，类似于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> *(ptr)</span><br></pre></td></tr></table></figure><h3 id="ble"><a href="#ble" class="headerlink" title="ble"></a>ble</h3><blockquote><p><strong>Branch less or equal</strong></p></blockquote><h3 id="bl"><a href="#bl" class="headerlink" title="bl"></a>bl</h3><blockquote><p><strong>Branch with Link</strong></p></blockquote><p>跳转到一个函数（子程序）地址，并且保存返回地址到 <code>x30</code> 寄存器中（也叫 <code>lr</code>，Link Register）</p><h3 id="cbz"><a href="#cbz" class="headerlink" title="cbz"></a>cbz</h3><blockquote><p>Compare and Branch if Zero</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbz &lt;register&gt;, &lt;label&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>&lt;register&gt;</code> 中的值为 0，就跳转到 <code>&lt;label&gt;</code>。</p><p>否则继续执行下一条指令。</p><h3 id="csel"><a href="#csel" class="headerlink" title="csel"></a>csel</h3><blockquote><p>Conditional Select</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csel &lt;dest&gt;, &lt;src1&gt;, &lt;src2&gt;, &lt;condition&gt;</span><br></pre></td></tr></table></figure><p>如果满足 <code>&lt;condition&gt;</code>，则将 <code>&lt;src1&gt;</code> 的值赋给 <code>&lt;dest&gt;</code>；</p><p>否则将 <code>&lt;src2&gt;</code> 的值赋给 <code>&lt;dest&gt;</code>。</p><p>examples:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp w2, w5</span><br><span class="line">csel w2, w2, w5, gt    // 如果 w2 &gt; w5，则 w2 保持不变；否则更新为 w5</span><br></pre></td></tr></table></figure><p>这是<strong>无分支的条件赋值</strong>，比 <code>if-else</code> 更高效。</p><p>this is equal to </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w2 = (w2 &gt; w5) ? w2 : w5;</span><br></pre></td></tr></table></figure><h3 id="calculate"><a href="#calculate" class="headerlink" title="calculate"></a>calculate</h3><h2 id="shift-Opertations"><a href="#shift-Opertations" class="headerlink" title="shift Opertations"></a>shift Opertations</h2><h3 id="lsl"><a href="#lsl" class="headerlink" title="lsl"></a>lsl</h3><blockquote><p>Logical Shift Left</p></blockquote><p>The LSL instruction performs multiplication by a power of 2.</p><h3 id="lsr"><a href="#lsr" class="headerlink" title="lsr"></a>lsr</h3><blockquote><p>Logical Shift Right</p></blockquote><p>The LSR instruction performs division by a power of 2.</p><h3 id="asr"><a href="#asr" class="headerlink" title="asr"></a>asr</h3><blockquote><p>Arithmetic Shift Right</p></blockquote><p>The ASR instruction performs division by a power of 2, preserving the sign bit.</p><h3 id="ror"><a href="#ror" class="headerlink" title="ror"></a>ror</h3><blockquote><p>rotate right</p></blockquote><p>The ROR instruction performs a bitwise rotation, wrapping the bits rotated from the LSB into the MSB.<br>即：<code>ROR</code> 指令执行<strong>按位右旋转</strong>操作：<strong>从最低有效位（LSB）被旋转出来的位，会重新被放入到最高有效位（MSB）的位置中。</strong></p><h2 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h2><h3 id="mvn"><a href="#mvn" class="headerlink" title="mvn"></a>mvn</h3><p>mvn (Move Not) 作用是 将操作数按位取反（bitwise NOT）后，放入目标寄存器。</p><h3 id="orr"><a href="#orr" class="headerlink" title="orr"></a>orr</h3><p>orr (bitwise inclusive OR) 对两个操作数执行<strong>按位或（bitwise OR）</strong>运算，然后将结果写入目标寄存器</p><h3 id="bfi"><a href="#bfi" class="headerlink" title="bfi"></a>bfi</h3><p>bfi (Bit Field Insert) 即“位字段插入”。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfi &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;</span><br></pre></td></tr></table></figure></p><p><Xd>：目标寄存器（结果写到这里）</p><p><Xn>：源寄存器（从这里取低位的值）</p><p><lsb>：目标寄存器中开始插入的起始位（least significant bit 起始位）</p><p><width>：要插入多少位（宽度）</p><p>假设：</p><p>Xd = 0b1111 0000<br>Xn = 0b1011 (只用低4位)<br>lsb=1<br>width=3</p><p>执行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfi Xd, Xn, #1, #3</span><br></pre></td></tr></table></figure><br>结果：<br>将 Xn 的低3位 011 插入 Xd 的位1~3上，替换原值<br>结果是 Xd = 1111 0110 </p><h3 id="ubfm"><a href="#ubfm" class="headerlink" title="ubfm"></a>ubfm</h3><p>ubfm = Unsigned BitField Move</p><p>基本格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfm &lt;dst&gt;, &lt;src&gt;, #lsb, #msb</span><br></pre></td></tr></table></figure></p><p><dst>：目标寄存器</p><p><src>：源寄存器<br>lsb：起始位（low bit index）<br>msb：结束位（high bit index）<br>这条指令从 src 中 提取一个无符号位字段（即一段连续的比特位），把它放到 dst 的低位（bit 0 开始），其他位清零或忽略<br>也就是说：</p><ol><li>从 src 的第 lsb 位开始，取到 msb 位</li><li>将这段 bit 字段提取出来</li><li>右对齐放到 dst 的低位（bit 0）<br>其他位全部清零<br>实例：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfm    w1, w2, #8, #15</span><br></pre></td></tr></table></figure><ol><li>从 w2 中提取 bit 8 到 bit 15（共 8 位）</li><li>把它放到 w1 的 bit 0~7</li></ol><h3 id="ubfiz"><a href="#ubfiz" class="headerlink" title="ubfiz"></a>ubfiz</h3><p>ubfiz (Unsigned Bit Field Insert Zeroed) 将一个无符号数的低位字段插入到另一个寄存器的指定位置，但目标寄存器在插入之前会被清零。<br>它其实是 ubfm（Unsigned Bit Field Move）的一个特化形式，和 UBFM 的语义类似。</p><p>指令格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfiz  &lt;dst&gt;, &lt;src&gt;, #lsb, #width</span><br></pre></td></tr></table></figure><br>简单来讲就是：ubfiz = 把 src 的低 width 位 插入到 dst 的 bit lsb 开始的位置，其余位置全部清零。</p><p>其中：</p><p><src>：来源寄存器（如 w1）</p><p><dst>：目标寄存器（如 w2），最终结果放在这里<br>lsb：目标中插入位置的起始 bit 位（从0开始）<br>width：要插入的位数（从 <src> 的最低位开始数）</p><p>目标寄存器其他位都会被清零。</p><p>举例说明：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfiz   w1, w1, #3, #5</span><br></pre></td></tr></table></figure><br>含义如下：</p><ol><li>从 w1 的 最低 5 位（bit 0 到 bit 4）提取出来</li><li>插入到目标（w1）寄存器的 bit 3 到 bit 7</li><li>w1 的其他所有位（02 和 831）清零</li></ol><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="adr"><a href="#adr" class="headerlink" title="adr"></a>adr</h3><blockquote><p>Address</p></blockquote><h3 id="adrp"><a href="#adrp" class="headerlink" title="adrp"></a>adrp</h3><blockquote><p>Address of page</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line"></span><br><span class="line">adrp x0, fmt</span><br><span class="line">add  x0, x0, :lo12:fmt    // 汇编器会自动提取 fmt 的低12位作为立即数,计算页偏移</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：把符号 <code>fmt</code> 所在的 <strong>4KB 对齐页的页地址</strong>加载到 <code>x0</code> 中。</li><li><code>adrp</code> = <em>Address of Page</em>。</li><li>它会忽略符号地址的低 12 位，只保留高位。</li><li>举例：如果 <code>fmt</code> 地址是 <code>0x400123</code>，那么 <code>adrp x0, fmt</code> 会将 <code>0x400000</code> 加载到 <code>x0</code>。</li><li><code>adrp x0, fmt</code> 会将 <code>fmt</code> 地址向下取整到最近的 <strong>4KB 边界</strong>（即清除低12位）</li></ul><blockquote><p>为什么不直接用 <code>ldr x0, =fmt</code>？</p></blockquote><ul><li>在 ARM64 下，使用 <code>ldr x0, =fmt</code> 可能隐式引入 <strong>文字常量池（literal pool）</strong>，不利于可重定位代码，尤其是在动态链接或 PIE (Position Independent Executable) 环境下。</li><li><code>adrp</code> + <code>add</code> 是 <strong>推荐的可重定位代码写法（relocatable and PIC-compliant）</strong>。</li><li>Linux 下的动态链接器（ld.so）支持这种模式更好。</li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>含义</th><th>支持的偏移范围</th><th>常用于</th></tr></thead><tbody><tr><td><code>adr</code></td><td>获取<strong>当前指令附近</strong>的地址</td><td>±1MB</td><td>局部跳转、临时变量等</td></tr><tr><td><code>adrp</code></td><td>获取<strong>4KB 页对齐的高地址部分</strong></td><td>±4GB（页对齐偏移）</td><td>获取全局变量地址、字符串、常量表地址等</td></tr></tbody></table></div><h3 id="smaddl"><a href="#smaddl" class="headerlink" title="smaddl"></a>smaddl</h3><blockquote><p>Signed Multiply Add Long</p><p>两个 <strong>32位整数（有符号）</strong> 相乘后，加上一个 <strong>64位整数</strong>，结果保存在一个 <strong>64位寄存器</strong>中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smaddl &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</span><br></pre></td></tr></table></figure><p>执行如下操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xd = (<span class="type">int64_t</span>)(<span class="type">int32_t</span>)Wn * (<span class="type">int64_t</span>)(<span class="type">int32_t</span>)Wm + Xa;</span><br></pre></td></tr></table></figure></p><h1 id="programming"><a href="#programming" class="headerlink" title="programming"></a>programming</h1><h2 id="if-statement"><a href="#if-statement" class="headerlink" title="if statement"></a>if statement</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)                                                              </span><br><span class="line">&#123;                                                                       </span><br><span class="line">    <span class="comment">// CODE BLOCK                                                       </span></span><br><span class="line">&#125;                                                                       </span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0                                       </span><br><span class="line">    // Assume value of b is in x1                                       </span><br><span class="line">    cmp     x0, x1                                                      </span><br><span class="line">    ble     1f                                                          </span><br><span class="line">    // CODE BLOCK                                                       </span><br><span class="line">1:                                                                     </span><br></pre></td></tr></table></figure><p>If <code>a &gt; b</code> then <code>x0 - x1</code> will be <em>greater than zero</em>.</p><p>If <code>a == b</code> then <code>x0 - x1</code> will be <em>equal to zero</em>.</p><p>If <code>a &lt; b</code> then <code>x0 - x1</code> will be <em>less than zero</em>.</p><p><strong>ble</strong> means <strong>branch (a jump or goto) if the previous computation shows <code>less than or equal to</code> zero</strong></p><h4 id="a-rule-of-thumb"><a href="#a-rule-of-thumb" class="headerlink" title="a rule of thumb"></a>a rule of thumb</h4><ul><li><p><strong>In the higher level language, you want to <em>enter</em> the following code block if the condition is true. </strong></p></li><li><p><strong>In assembly language, you want to <em>avoid</em> the following code block if the condition is false.</strong></p></li></ul><h4 id="temporary-label"><a href="#temporary-label" class="headerlink" title="temporary label"></a>temporary label</h4><p>The target of the branch instruction is given as <code>1f</code>. This is an example of a <strong><em>temporary label</em></strong>.</p><p><strong>There are a lot of braces used in C and C++. Since labels frequently function as equivalents to <code>&#123;</code> and <code>&#125;</code>, there can be a lot of labels used in assembly language. But label is only a position label, it is not a scope </strong></p><p>A temporary label is a label made using just a number. Such labels can appear over and over again (i.e. they can be reused). They are made unique by virtue of their placement relative to where they are being used. </p><ul><li><code>1f</code> looks <code>f</code>orward in the code for the next label <code>1</code>. </li><li><code>1b</code> looks in the <code>b</code>ackward direction for the most recent label <code>1</code>.</li></ul><h3 id="if-else"><a href="#if-else" class="headerlink" title="if / else"></a>if / else</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)                                                          </span><br><span class="line">&#123;                                                                   </span><br><span class="line">    <span class="comment">// CODE BLOCK IF TRUE                                           </span></span><br><span class="line">&#125;                                                          </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;                                                                   </span><br><span class="line">    <span class="comment">// CODE BLOCK IF FALSE                                         </span></span><br><span class="line">&#125;                                                                   </span><br></pre></td></tr></table></figure><p><strong>There are two branches built into this code!</strong></p><p>in aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0                                       </span><br><span class="line">    // Assume value of b is in x1                                       </span><br><span class="line">    cmp     x0, x1                                                      </span><br><span class="line">    ble     1f                                                          </span><br><span class="line">    // CODE BLOCK IF TRUE                                               </span><br><span class="line">    b       2f                                                         </span><br><span class="line">1:                                                                      </span><br><span class="line">    // CODE BLOCK IF FALSE                                             </span><br><span class="line">2:                                                                     </span><br></pre></td></tr></table></figure><h4 id="a-complete-example"><a href="#a-complete-example" class="headerlink" title="a complete example"></a>a complete example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    .global main                                                       </span><br><span class="line">    .text                                                               </span><br><span class="line">                                                                       </span><br><span class="line">main:                                                                   </span><br><span class="line">    stp     x29, x30, [sp, -16]!                                       </span><br><span class="line">    mov     x1, 10                                                     </span><br><span class="line">    mov     x0, 5                                                       </span><br><span class="line">    cmp     x0, x1                                                     </span><br><span class="line">    ble     1f                                                         </span><br><span class="line">    ldr     x0, =T                     //Pseudo Instruction 伪指令</span><br><span class="line">    bl      puts                                                       </span><br><span class="line">    b       2f                                                         </span><br><span class="line"></span><br><span class="line">1:  ldr     x0, =F                                                     </span><br><span class="line">    bl      puts                                                       </span><br><span class="line">                                                                       </span><br><span class="line">2:  ldp     x29, x30, [sp], 16                                         </span><br><span class="line">    mov     x0, xzr                                                     </span><br><span class="line">    ret                                                                 </span><br><span class="line">                                                                    </span><br><span class="line">    .data                                                               </span><br><span class="line">F:  .asciz  &quot;FALSE&quot;                                                     </span><br><span class="line">T:  .asciz  &quot;TRUE&quot;                                                     </span><br><span class="line">    .end                                                               </span><br></pre></td></tr></table></figure><p><code>Line 11</code> is one way of loading the address represented by a label. In this case, the label <code>T</code> corresponds to the address to the first letter of the C string “TRUE”. <code>Line 15</code> loads the address of the C string containing “FALSE”.</p><p>The occurrences of <code>.asciz</code> on <code>line 23</code> and <code>line 24</code> are invocations of an <em>assembler directive</em> the creates a C string. Recall that <strong>C strings are NULL terminated</strong>. The NULL termination is indicated by the <code>z</code> which ends <code>.asciz</code>.</p><p>There is a similar directive <code>.ascii</code> that <em>does not NULL terminate</em> the string.</p><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><h3 id="while-loop"><a href="#while-loop" class="headerlink" title="while loop"></a>while loop</h3><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/while.jpeg" alt="while loop"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (a &gt;= b) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0                                       </span><br><span class="line">    // Assume value of b is in x1                                       </span><br><span class="line">                                                                        </span><br><span class="line"> 1: cmp     x0, x1                                                     </span><br><span class="line">    blt     2f                                                          </span><br><span class="line">    // CODE BLOCK                                                       </span><br><span class="line">    b       1b                                                          </span><br><span class="line"></span><br><span class="line">2:                                                                     </span><br></pre></td></tr></table></figure><h3 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span> up; decision; post step)                                   </span><br><span class="line">&#123;                                                                    </span><br><span class="line">    <span class="comment">// CODE BLOCK                                                   </span></span><br><span class="line">&#125;                                                                   </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/for.jpeg" alt="for"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)                                     </span><br><span class="line">&#123;                                                                  </span><br><span class="line">    <span class="comment">// CODE BLOCK                                                    </span></span><br><span class="line">&#125;                                                                   </span><br></pre></td></tr></table></figure><p>aarch64 (the flow chart on the left)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Assume i is implemented using x0                                                                                        </span></span><br><span class="line">    mov     x0, xzr                                                     </span><br><span class="line">                                                                      </span><br><span class="line"><span class="number">1</span>:  cmp     x0, <span class="number">10</span>                                                     </span><br><span class="line">    bge     <span class="number">2f</span>                                                         </span><br><span class="line">                                                                       </span><br><span class="line">    <span class="comment">// CODE BLOCK                                                       </span></span><br><span class="line">                                                                       </span><br><span class="line">    add     x0, x0, <span class="number">1</span>                                                   </span><br><span class="line">    b       <span class="number">1b</span>                                                         </span><br><span class="line">                                                                       </span><br><span class="line"><span class="number">2</span>:                                                                     </span><br></pre></td></tr></table></figure><p>aarch64 (the flow chart on the right)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0                                 </span><br><span class="line">                                                                       </span><br><span class="line">    mov     x0, xzr                                                     </span><br><span class="line">    b       2f</span><br><span class="line">                                                                       </span><br><span class="line">1:                                                                     </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK                                                       </span><br><span class="line">                                                                       </span><br><span class="line">    add     x0, x0, 1                                                   </span><br><span class="line">2:  cmp     x0, 10                                                     </span><br><span class="line">    blt     1b                                                         </span><br></pre></td></tr></table></figure><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;A&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;B&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0                                 </span><br><span class="line">                                                                       </span><br><span class="line">    mov x0, xzr                                                         </span><br><span class="line"></span><br><span class="line">1:  cmp x0, 10                                                         </span><br><span class="line">    bge 3f                                                                                                                      </span><br><span class="line">    // CODE BLOCK &quot;A&quot;.                                                              </span><br><span class="line">    // if (i == 5)                                                     </span><br><span class="line">    //      continue                                                   </span><br><span class="line">    </span><br><span class="line">    cmp x0, 5                                                           </span><br><span class="line">    beq 2f                                                                                                                      </span><br><span class="line">    // CODE BLOCK &quot;B&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">2:  add x0, x0, 1                                                       </span><br><span class="line">    b   1b                                                             </span><br><span class="line"></span><br><span class="line">3:                                                                     </span><br></pre></td></tr></table></figure><p>another one</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0                                 </span><br><span class="line">                                                                       </span><br><span class="line">    mov x0, xzr                                                         </span><br><span class="line">    b   3f                                                             </span><br><span class="line">                                                                       </span><br><span class="line">1:                                                                     </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK &quot;A&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">    // if (i == 5)                                                     </span><br><span class="line">    //      continue                                                   </span><br><span class="line">                                                                       </span><br><span class="line">    cmp x0, 5                                                           </span><br><span class="line">    beq 2f                                                             </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK &quot;B&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">2:  add x0, x0, 1                                                       </span><br><span class="line">3:  cmp x0, 10                                                         </span><br><span class="line">    blt 1b                                                             </span><br></pre></td></tr></table></figure><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>The implementation of <code>break</code> is very similar to that of <code>continue</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;A&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;B&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0                                 </span><br><span class="line">                                                                       </span><br><span class="line">    mov x0, xzr                                                         </span><br><span class="line">    b   3f                                                             </span><br><span class="line"> </span><br><span class="line">1:                                                                     </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK &quot;A&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">    // if (i == 5)                                                     </span><br><span class="line">    //      break;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">    cmp x0, 5                                                           </span><br><span class="line">    beq 4f                                                             </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK &quot;B&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">2:  add x0, x0, 1                                                       </span><br><span class="line">3:  cmp x0, 10                                                         </span><br><span class="line">    blt 1b                                                             </span><br><span class="line">                                                                       </span><br><span class="line">4:                                                                     </span><br></pre></td></tr></table></figure><h2 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h2><h3 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h3><p><em>Data members exhibit <strong>natural alignment</strong>.</em></p><p>That is:</p><ul><li>a <code>long</code> will be found at addresses which are a multiple of 8.</li><li>an <code>int</code> will be found at addresses which are a multiple of 4.</li><li>a <code>short</code> will be found at addresses which are even.</li><li>a <code>char</code> can be found anywhere.</li></ul><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>布局：</p><div class="table-container"><table><thead><tr><th>Offset</th><th>Width</th><th>Member</th></tr></thead><tbody><tr><td>0</td><td>8byte</td><td>a</td></tr><tr><td>8</td><td>2byte</td><td>b</td></tr><tr><td>10</td><td>2</td><td>— gap —</td></tr><tr><td>12</td><td>4byte</td><td>c</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaaaaaaaaaaaaaa</span>, <span class="number">0xbbbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>A hex dump will show:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa aaaa aaaa aaaa bbbb 0000 cccc cccc</span><br></pre></td></tr></table></figure><p>Notice the gap filled in which zeros. Note, if this were a local variable, the zeros might be garbage.</p><p>change the order:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaa</span>, <span class="number">0xbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>A hex dump will show:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa 00bb cccc cccc</span><br></pre></td></tr></table></figure><p>Notice there is only one byte of gap before the <code>int c</code> starts.</p><p><em>why are the zeros to the left of the b’s?</em></p><p>This ARM processor is running as a <em>little endian</em> machine.</p><h3 id="defining-structs"><a href="#defining-structs" class="headerlink" title="defining structs"></a>defining structs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaa</span>, <span class="number">0xbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>Here is one way of defining and accessing the struct:</p><p><strong>硬编码字段偏移量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">bar:</span><br><span class="line">    .short 0xaaaa        // a: short 2 byte</span><br><span class="line">    .byte  0xbb          // b: char  1 byte</span><br><span class="line">    .byte  0x00          // padding</span><br><span class="line">    .word  0xcccccccc    // c: int   4 byte</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line">    .global main</span><br><span class="line">    .align 2</span><br><span class="line">main:</span><br><span class="line">    stp x29, x30, [sp, -16]!    // 保存栈帧</span><br><span class="line">    mov x29, sp</span><br><span class="line"></span><br><span class="line">    adrp x0, fmt</span><br><span class="line">    add  x0, x0, :lo12:fmt      // printf 格式字符串地址</span><br><span class="line"></span><br><span class="line">    adrp x1, bar</span><br><span class="line">    add  x1, x1, :lo12:bar      // bar 的地址</span><br><span class="line"></span><br><span class="line">    ldrh w2, [x1, 0]            // short a</span><br><span class="line">    ldrb w3, [x1, 2]            // char b</span><br><span class="line">    ldr  w4, [x1, 4]            // int  c</span><br><span class="line"></span><br><span class="line">    bl printf                   // 调用 printf(&amp;bar, a, b, c)</span><br><span class="line">    </span><br><span class="line">    // 显式退出系统调用</span><br><span class="line">    mov     x8, #93       // syscall number for exit</span><br><span class="line">    mov     x0, xzr       // exit code 0</span><br><span class="line">    svc     0             // make syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>:lo12:fmt</code> 会被汇编器替换成 <code>fmt</code> 地址的低 12 位。</p><p><code>adrp x0, fmt</code> 会将 <code>fmt</code> 地址向下取整到最近的 <strong>4KB 边界</strong>（即清除低12位），然后加载这个“页基址”到 <code>x0</code>。</p><p>例如：<br> 如果 <code>fmt = 0x12345678</code>，那么：</p><ul><li><code>adrp x0, fmt</code> 会得到 <code>0x12345000</code>（低 12 位清零）</li></ul><p>another way to define a structs is </p><p><strong>使用 <code>.equ</code> 伪指令定义符号常量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    .global main                // main 函数声明</span><br><span class="line">    .text</span><br><span class="line">    .p2align 2</span><br><span class="line"></span><br><span class="line">    .equ foo_a, 0               // like #define foo_a 0</span><br><span class="line">    .equ foo_b, 2               // like #define foo_b 2</span><br><span class="line">    .equ foo_c, 4               // like #define foo_c 4</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    stp     x29, x30, [sp, -16]!  // 保存 x29, x30 到栈上</span><br><span class="line">    mov     x29, sp               // 设置新的帧指针</span><br><span class="line"></span><br><span class="line">    // 加载 fmt 和 bar 的地址</span><br><span class="line">    ldr     x0, =fmt              // fmt 字符串的地址</span><br><span class="line">    ldr     x1, =bar              // bar 的地址</span><br><span class="line">    ldrh    w2, [x1, foo_a]       // 加载 bar.a 到 w2</span><br><span class="line">    ldrb    w3, [x1, foo_b]       // 加载 bar.b 到 w3</span><br><span class="line">    ldr     w4, [x1, foo_c]       // 加载 bar.c 到 w4</span><br><span class="line"></span><br><span class="line">    // 调用 printf，传递参数</span><br><span class="line">    mov     x0, x0               // 第一个参数：fmt 地址</span><br><span class="line">    mov     x1, w2               // 第二个参数：a 的值</span><br><span class="line">    mov     x2, w3               // 第三个参数：b 的值</span><br><span class="line">    mov     x3, w4               // 第四个参数：c 的值</span><br><span class="line">    bl      printf               // 调用 printf</span><br><span class="line"></span><br><span class="line">    // 恢复栈和寄存器</span><br><span class="line">    ldp     x29, x30, [sp], #16  // 恢复 x29 和 x30</span><br><span class="line">    ret                          // 返回</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">fmt:    </span><br><span class="line">.asciz      &quot;%p a: 0x%lx b: %x c: %x\n&quot;   // printf 格式字符串</span><br><span class="line">bar:    </span><br><span class="line">.short      0xaaaa                        // a</span><br><span class="line">    .byte       0xbb                          // b</span><br><span class="line">    .byte       0                               // padding</span><br><span class="line">    .word       0xcccccccc                    // c</span><br><span class="line"></span><br><span class="line">    .end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>the third way:(<strong>Linux only</strong>)</p><p> <strong>使用 <code>.struct</code> 和字段标签自动推导偏移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    // 用 .struct 模拟 struct Foo 的字段偏移</span><br><span class="line">    .set  Foo, 0</span><br><span class="line">    .struct 0</span><br><span class="line">Foo_a:  .struct Foo_a + 2      // short a: 2字节</span><br><span class="line">Foo_b:  .struct Foo_b + 1      // char b: 1字节</span><br><span class="line">        .struct Foo_b + 1      // padding: 1字节</span><br><span class="line">Foo_c:  .struct Foo_b + 2      // int c: 从 offset 4 开始</span><br><span class="line">    // 现在 Foo_c 是偏移量 4</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">bar:</span><br><span class="line">    .short 0xaaaa              // a: short 2 byte</span><br><span class="line">    .byte  0xbb                // b: char  1 byte</span><br><span class="line">    .byte  0x00                // padding</span><br><span class="line">    .word  0xcccccccc          // c: int   4 byte</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line">    .global main</span><br><span class="line">    .align 2</span><br><span class="line">main:</span><br><span class="line">    stp x29, x30, [sp, -16]!   // 保存栈帧</span><br><span class="line">    mov x29, sp</span><br><span class="line"></span><br><span class="line">    adrp x0, fmt</span><br><span class="line">    add  x0, x0, :lo12:fmt     // printf 格式字符串地址</span><br><span class="line"></span><br><span class="line">    adrp x1, bar</span><br><span class="line">    add  x1, x1, :lo12:bar     // bar 的地址</span><br><span class="line"></span><br><span class="line">    ldrh w2, [x1, Foo_a]       // 加载 bar.a（short）</span><br><span class="line">    ldrb w3, [x1, Foo_b]       // 加载 bar.b（char）</span><br><span class="line">    ldr  w4, [x1, Foo_c]       // 加载 bar.c（int）</span><br><span class="line"></span><br><span class="line">    bl printf                  // printf(bar, a, b, c)</span><br><span class="line"></span><br><span class="line">    // 显式退出</span><br><span class="line">    mov     x8, #93            // syscall number for exit</span><br><span class="line">    mov     x0, xzr            // exit code 0</span><br><span class="line">    svc     0                  // syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="using-structs"><a href="#using-structs" class="headerlink" title="using structs"></a>using structs</h4><p>To summarize using <code>structs</code>:</p><ul><li>All <code>structs</code> have a base address</li><li><strong>The base address corresponds to the beginning of the first data member</strong></li><li>All subsequent data members are offsets relative to the first</li><li>In order to use a <code>struct</code> correctly, you must have first calculated the offsets of each data member</li><li>Sometimes there will be padding between data members due to the need to align all data members on natural boundaries.</li></ul><h4 id="this-pointer-in-c"><a href="#this-pointer-in-c" class="headerlink" title="this pointer in c++"></a>this pointer in c++</h4><ul><li><strong>Every non-static method call employs a hidden first parameter. That’s it. That’s the slight of hand. The hidden argument is the this pointer.</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestClass tc;</span><br><span class="line">tc.<span class="built_in">SetString</span>(test_string);</span><br></pre></td></tr></table></figure><p>看起来我们只传入了一个参数 test_string。但实际上编译器传入了两个参数：</p><ol><li><p>第一个是 this 指针：也就是 tc 的地址，传给寄存器 x0</p></li><li><p>第二个是 test_string，传给寄存器 x1</p></li></ol><p>在汇编里看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adrp x1, _test_string</span><br><span class="line">adrp x0, _tc         // 把 tc 对象地址放到 x0 —— 也就是 this 指针</span><br><span class="line">bl __ZN9TestClass9SetStringEPc</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><blockquote><p>The meaning and function of <code>const</code> only <code>partially</code> translates to assembly language.</p></blockquote><ul><li><code>const</code> local variables and <code>const</code> parameters are just like any other data to assembly language. </li><li><p>The constant nature of <code>const</code> local variables and parameters is implemented solely in the compiler.</p></li><li><p><strong><code>const</code> globals are made constant by the hardware</strong>. Attempting to modify a variable protected in this manner will be like poking a dragon. Best not to poke dragons.</p></li></ul><h2 id="switch-and-jump-table"><a href="#switch-and-jump-table" class="headerlink" title="switch and jump table"></a>switch and jump table</h2><blockquote><p>When the C++ optimizer is enabled, it will look at your cases and choose between three different constructs for implementing your <code>switch</code>.</p><p>And, it can use any combination of the following! Compiler writers are smart!</p></blockquote><ol><li>It may emit a long string of <code>if / else</code> constructs.</li><li>It may find the right <code>case</code> using a <em>binary search</em>.</li><li>Finally, it might use a <strong>jump table</strong>.</li></ol><p>Suppose our cases are largely consecutive. Given that all branch instructions are the same length in bytes, we can do math on the switch variable to somehow derive the address of the case we want.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>                                              </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>                                                 </span></span><br><span class="line">                                                                   </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                                                        </span><br><span class="line">&#123;                                                                   </span><br><span class="line">    <span class="type">int</span> r;                                                         </span><br><span class="line">                                                                    </span><br><span class="line">    srand(time(<span class="number">0</span>));                                                </span><br><span class="line">    r = rand() &amp; <span class="number">7</span>;                                                 </span><br><span class="line">    <span class="keyword">switch</span> (r)                                                      </span><br><span class="line">    &#123;                                                              </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:                                                    </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0 returned&quot;</span>);                                    </span><br><span class="line">            <span class="keyword">break</span>;                                                 </span><br><span class="line">                                                                 </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:                                                  </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1 returned&quot;</span>);                                   </span><br><span class="line">            <span class="keyword">break</span>;                                                  </span><br><span class="line">                                                                    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:                                                     </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;2 returned&quot;</span>);                                     </span><br><span class="line">            <span class="keyword">break</span>;                                                 </span><br><span class="line">                                                                    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:                                                   </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;3 returned&quot;</span>);                                  </span><br><span class="line">            <span class="keyword">break</span>;                                                </span><br><span class="line">                                                                   </span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:                                                    </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;4 returned&quot;</span>);                                     </span><br><span class="line">            <span class="keyword">break</span>;                                                 </span><br><span class="line">                                                                   </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:                                                     </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;5 returned&quot;</span>);                                  </span><br><span class="line">            <span class="keyword">break</span>;                                             </span><br><span class="line">                                                                    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:                                                    </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;6 returned&quot;</span>);                                    </span><br><span class="line">            <span class="keyword">break</span>;                                                  </span><br><span class="line">                                                                  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:                                                     </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;7 returned&quot;</span>);                                     </span><br><span class="line">            <span class="keyword">break</span>;                                                  </span><br><span class="line">    &#125;                                                               </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                     </span><br><span class="line">&#125;                                                                  </span><br></pre></td></tr></table></figure><p>Notice that the <code>case</code> values are all, in this case, consecutive.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jt:     b       0f</span><br><span class="line">        b       1f</span><br><span class="line">        b       2f</span><br><span class="line">        b       3f</span><br><span class="line">        b       4f</span><br><span class="line">        b       5f</span><br><span class="line">        b       6f</span><br><span class="line">        b       7f</span><br></pre></td></tr></table></figure><p><code>f</code> means forward, <code>b</code> means backward</p><p>At address <code>jt</code> there are a sequence of branch statements… jumps if you will. Being in a sequence, this is an example of a jump table. We’ll compute the index into this <em>array of instructions</em> and then branch to it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsl     x0, x0, 2     </span><br><span class="line">ldr     x1, =jt          </span><br><span class="line">add     x1, x1, x0        </span><br><span class="line">br      x1                    </span><br></pre></td></tr></table></figure><ul><li><p>Line 2 loads the base address of the “instruction array” starting at address <code>jt</code>.</p><p>complete example</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        .align  4</span><br><span class="line">        .global main</span><br><span class="line"></span><br><span class="line">main:   str     x30, [sp, -16]!</span><br><span class="line">        mov     x0, xzr             // set up call to time(nullptr)</span><br><span class="line">        bl      time                // call time setting up srand</span><br><span class="line">        bl      srand               // call srand setting up rand</span><br><span class="line">        bl      rand                // get a random number</span><br><span class="line">        and     x0, x0, 7           // ensure its range is 0 to 7</span><br><span class="line">                                    // note use of x register is on purpose</span><br><span class="line">        lsl     x0, x0, 2           // multiply by 4</span><br><span class="line">        ldr     x1, =jt             // load base address of jump table</span><br><span class="line">        add     x1, x1, x0          // add offset to base address</span><br><span class="line">        br      x1</span><br><span class="line"></span><br><span class="line">// If, as in this case, all the &quot;cases&quot; have the same number of </span><br><span class="line">// instructions then this intermediate jump table can be omitted saving</span><br><span class="line">// some space and a tiny amount of time. To omit the intermediate jump</span><br><span class="line">// table, you&#x27;d multiply by 12 above and not 4. Twelve because each </span><br><span class="line">// &quot;case&quot; has 3 instructions (3 x 4 == 12).</span><br><span class="line"></span><br><span class="line">// Question for you: If you did omit the jump table, relative to what</span><br><span class="line">// would you jump (since &quot;jt&quot; would be gone).</span><br><span class="line"></span><br><span class="line">jt:     b       0f</span><br><span class="line">        b       1f</span><br><span class="line">        b       2f</span><br><span class="line">        b       3f</span><br><span class="line">        b       4f</span><br><span class="line">        b       5f</span><br><span class="line">        b       6f</span><br><span class="line">        b       7f</span><br><span class="line"></span><br><span class="line">0:      ldr     x0, =ZR</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">1:      ldr     x0, =ON</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">2:      ldr     x0, =TW</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">3:      ldr     x0, =TH</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">4:      ldr     x0, =FR</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">5:      ldr     x0, =FV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">6:      ldr     x0, =SX</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">7:      ldr     x0, =SV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">99:     mov     w0, wzr</span><br><span class="line">        ldr     x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">        .section    .rodata</span><br><span class="line"></span><br><span class="line">ZR:     .asciz      &quot;0 returned&quot;</span><br><span class="line">ON:     .asciz      &quot;1 returned&quot;</span><br><span class="line">TW:     .asciz      &quot;2 returned&quot;</span><br><span class="line">TH:     .asciz      &quot;3 returned&quot;</span><br><span class="line">FR:     .asciz      &quot;4 returned&quot;</span><br><span class="line">FV:     .asciz      &quot;5 returned&quot;</span><br><span class="line">SX:     .asciz      &quot;6 returned&quot;</span><br><span class="line">SV:     .asciz      &quot;7 returned&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><h3 id="implement-falling-through"><a href="#implement-falling-through" class="headerlink" title="implement falling through"></a>implement falling through</h3><p>If there is no break falling the code for a case, control will simply fall through to the next case</p><p>Here is a snippet from the program linked just above</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:      ldr     x0, =ZR  </span><br><span class="line">        bl      puts   </span><br><span class="line">        b       99f </span><br><span class="line">                  </span><br><span class="line">1:      ldr     x0, =ON </span><br><span class="line">        bl      puts    </span><br><span class="line">        b       99f     </span><br></pre></td></tr></table></figure><h3 id="implementing-gaps"><a href="#implementing-gaps" class="headerlink" title="implementing gaps"></a>implementing gaps</h3><p>The example above present shows 8 consecutive cases. What if there was no code for case 4? In other words,  what if case 4 didn’t exit?</p><p>Here is the result:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2:      ldr     x0, =TW</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">3:      ldr     x0, =TH</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">4:      b       99f</span><br><span class="line"></span><br><span class="line">5:      ldr     x0, =FV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br></pre></td></tr></table></figure><h3 id="other-strategies-for-implementing-switch"><a href="#other-strategies-for-implementing-switch" class="headerlink" title="other strategies for implementing switch"></a>other strategies for implementing switch</h3><p>As indicated above, an optimizer has at least three tools available to it to implement complex <code>switch</code> statements. And, it can combine these tools.</p><ol><li>For example, suppose your cases boil down to two ranges of fairly consecutive values. For example, you have cases 0 to 9 and also cases 50 to 59. You can implement this as <strong>two jump tables with an <code>if / else</code> to select</strong> which one you use.</li></ol><p>假设你的 <code>switch</code> 语句中，<code>case</code> 值主要集中在<strong>两个小的连续范围内</strong>，例如：一组是 <code>case 0</code> 到 <code>case 9</code>,另一组是 <code>case 50</code> 到 <code>case 59</code>,那么可以用 <strong>两个跳转表</strong> 来处理这两个范围，再用一个 <code>if / else</code> 来决定使用哪一个跳转表。</p><ol><li>Suppose you have a large <code>switch</code> statement with widely ranging <code>case</code> values. In this case, you can implement a binary search to narrow down to a small range in which another technique becomes viable to narrow down to a single <code>case</code>.</li></ol><p>假设你有一个包含很多 <code>case</code> 分支的 <code>switch</code> 语句，而且这些 <code>case</code> 值之间的<strong>数值范围差异很大</strong>,比如 case 10, case 1000, case 50000…，那么可以<strong>先用二分查找法缩小查找范围</strong>，把目标值限制在一个<strong>较小的范围内</strong>，然后在这个范围内再用其他技术（比如跳转表、线性比较等）来确定最终对应哪个 <code>case</code> 分支。</p><ol><li>You might have need to implement <strong>hierarchical jump tables（分层跳转表）</strong>, for example.</li></ol><p>“分层跳转表”是一种优化结构，适用于以下情况：</p><ul><li><code>case</code> 值非常<strong>稀疏</strong>、<strong>范围极广</strong>（例如 <code>case 0, case 1000, case 2000...</code>)</li><li>但它们在<strong>局部范围内是稠密的</strong>（比如 <code>1000~1009</code>, <code>2000~2009</code>）</li></ul><p>你可以：</p><ol><li><strong>先用一个“一级跳转表”根据高位或区段跳转</strong>到一个子跳转表（子范围）。</li><li><strong>再在子跳转表中做具体跳转</strong>。<br> 这就构成了一个“分层结构”——像树一样的跳转过程。</li></ol><h3 id="strategies-for-implementing-if-else"><a href="#strategies-for-implementing-if-else" class="headerlink" title="strategies for implementing if-else"></a>strategies for implementing if-else</h3><p>If you do choose to implement a long chain of <code>if / else</code> statements, consider how frequently a given case might be chosen. <strong>Put the most common cases at the top of the <code>if / else</code> sequence</strong>.</p><p><strong>This is known as making the common case fast.</strong></p><p>Making the common case fast is one of the Great Ideas in Computer Science. One, you would do well to remember no matter what language you’re working with.</p><h2 id="fucntions"><a href="#fucntions" class="headerlink" title="fucntions"></a>fucntions</h2><h3 id="bottom-line-concept"><a href="#bottom-line-concept" class="headerlink" title="bottom line concept"></a>bottom line concept</h3><p>The <code>bl</code> instruction is stands for Branch with Link. The Link concept is what enables a function (or method) to return to the instruction after the call.</p><p>Branch-with-link computes the address of the instruction following it.</p><blockquote><p>It places this address into register <code>x30</code> and then branches to the label provided. It makes one link of a trail of breadcrumbs to follow to get back following a <code>ret</code>.</p></blockquote><p><strong>This is why it is absolutely essential to backup <code>x30</code> inside your functions if they call other functions themselves.</strong></p><h4 id="a-example"><a href="#a-example" class="headerlink" title="a example"></a>a example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        .text                                      </span><br><span class="line">        .global main                       </span><br><span class="line">        .align  2                           </span><br><span class="line">                                 </span><br><span class="line">main:   ldr     x0, =hw                </span><br><span class="line">        bl      puts             </span><br><span class="line">        ret</span><br><span class="line">                      </span><br><span class="line">        .data                        </span><br><span class="line">hw:     .asciz  &quot;Hello World!&quot;               </span><br><span class="line">                                                 </span><br><span class="line">        .end  </span><br></pre></td></tr></table></figure><p><strong>The program hung and had to be killed with ^C.</strong> </p><p>Somebody called <code>main()</code> - it’s a function and someone called it with a <code>bl</code> instruction. At the moment <code>main()</code> entered, the address to which it needed to return was sitting in <code>x30</code>.</p><p>Then, <code>main()</code> called a function - in this case <code>puts()</code> but which function is called doesn’t matter - it called a function. In doing so, it overwrote the address to which <code>main()</code> needed to return with the address of line 7 in the code. That is where <code>puts()</code> needs to return.</p><p>So, when line 7 executes it puts the contents of <code>x30</code> into the program counter and branches to it.</p><p>Here is a fixed version of the code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        .text                                   </span><br><span class="line">        .global main                           </span><br><span class="line">        .align  2                         </span><br><span class="line">                                          </span><br><span class="line">main:   str     x30, [sp, -16]!            </span><br><span class="line">        ldr     x0, =hw                     </span><br><span class="line">        bl      puts                 </span><br><span class="line">        ldr     x30, [sp], 16         </span><br><span class="line">        ret                             </span><br><span class="line">                        </span><br><span class="line">        .data                       </span><br><span class="line">hw:     .asciz  &quot;Hello World!&quot;                   </span><br><span class="line">                                             </span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><p>In the AARCH64 Linux style calling convention, values are returned in <code>x0</code> and sometimes also returned in other scratch registers though this is uncommon.(Note that <code>x0</code> could also be <code>w0</code> or the first floating point register if the function is returning a <code>float</code> or <code>double</code>.)</p><p>If your functions call <em>any</em> other functions, <code>x30</code> must be backed up on the stack and then restored into <code>x30</code> before returning.</p><p>A function with more than one return value is not supported by C or C++ but they can be written in assembly language where the rules are yours to break.</p><h3 id="inline-functions"><a href="#inline-functions" class="headerlink" title="inline functions"></a>inline functions</h3><p>Functions that are declared as <em>inline</em> don’t actually make function calls. Instead, the code from the function is type checked and inserted directly where the “call” is made after adjusting for parameter names.</p><h3 id="passing-parameters-to-functions"><a href="#passing-parameters-to-functions" class="headerlink" title="passing parameters to functions"></a>passing parameters to functions</h3><p><strong>How parameters are passed to functions can be different from OS to OS.</strong> This chapter is written to the standard implemented for Linux. </p><p>For the purposes of the present discussion, we assume all parameters are <code>long int</code> and are therefore stored in <code>x</code> registers.</p><ul><li><p><strong>Up to 8 parameters can be passed directly via scratch registers.</strong>（These are <code>x0</code> through <code>x7</code>） Each parameter can be up to the size of an address, long or double (8 bytes).</p><ul><li><p><strong><em>Scratch</em> means the value of the register can be changed at will without any need to backup or restore their values across function calls.</strong></p></li><li><p><strong>This means that you cannot count on the contents of the scratch registers maintaining their value if your function makes any function calls.</strong></p></li></ul></li></ul><h4 id="a-example-1"><a href="#a-example-1" class="headerlink" title="a example"></a>a example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> p1, <span class="type">long</span> p2)</span>              </span><br><span class="line">&#123;                                              </span><br><span class="line">    <span class="keyword">return</span> p1 + p2;                           </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure><p>is implemented as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func:   add x0, x0, x1  </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>If you are the author of both the caller and the callee and both are in assembly language, you can play loosey goosey with how you return values. Specifically, you can return more than one value. <strong>But</strong> if you do so, you give up the possibility of calling these functions from C or C++.</p><h3 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">long</span> p1, <span class="type">const</span> <span class="type">long</span> p2)</span>              </span><br><span class="line">&#123;                                  </span><br><span class="line">    <span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;                                                 </span><br></pre></td></tr></table></figure><p>how would the assembly language change?</p><p>Answer: no change at all!</p><p><code>const</code> is an instruction to the compiler ordering it to prohibit changing the values of <code>p1</code> and <code>p2</code>. We’re smart humans and realize that our assembly language makes no attempt to change <code>p1</code> and <code>p2</code> so no changes are warranted.</p><h3 id="passing-pointers"><a href="#passing-pointers" class="headerlink" title="passing pointers"></a>passing pointers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> * p1, <span class="type">long</span> * p2)</span>               </span><br><span class="line">&#123;                                                </span><br><span class="line">    *p1 = *p1 + *p2;                           </span><br><span class="line">&#125;                                         </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func:   ldr x2, [x0]                     </span><br><span class="line">        ldr x3, [x1]                            </span><br><span class="line">        add x2, x2, x3                       </span><br><span class="line">        str x2, [x0]                            </span><br><span class="line">        ret                                   </span><br></pre></td></tr></table></figure><p>The value of <code>x0</code> on return is, in the general sense, undefined because this is a <code>void</code> function.</p><h3 id="passing-reference"><a href="#passing-reference" class="headerlink" title="passing reference"></a>passing reference</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">func</span><span class="params">(<span class="type">long</span> &amp; p1, <span class="type">long</span> &amp; p2)</span>                     </span></span><br><span class="line"><span class="function"></span>&#123;                                              </span><br><span class="line">    <span class="keyword">return</span> p1 + p2;                               </span><br><span class="line">&#125;                                      </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func:   ldr x0, [x0]                     </span><br><span class="line">        ldr x1, [x1]                </span><br><span class="line">        add x0, x0, x1      </span><br><span class="line">        ret                </span><br></pre></td></tr></table></figure><p>Passing by reference is also an instruction to the compiler to treat pointers a little differently - the differences don’t show up here so there the only change to our pointer passing version is how we return the answer.</p><h3 id="more-than-eight-parameters"><a href="#more-than-eight-parameters" class="headerlink" title="more than eight parameters"></a>more than eight parameters</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SillyFunction</span><span class="params">(<span class="type">long</span> p1, <span class="type">long</span> p2, <span class="type">long</span> p3, <span class="type">long</span> p4, </span></span><br><span class="line"><span class="params">                   <span class="type">long</span> p5, <span class="type">long</span> p6, <span class="type">long</span> p7, <span class="type">long</span> p8, </span></span><br><span class="line"><span class="params">                   <span class="type">long</span> p9)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This example hurts: %ld %ld\n&quot;</span>, p8, p9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SillyFunction(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">        .text                                                            </span><br><span class="line">        .global    main                                                </span><br><span class="line">                                                                        </span><br><span class="line">/*  Demonstration of using  more than 8 arguments to  a function.  This  </span><br><span class="line">    demo is LINUX only as APPLE will put all arguments beyond the first  </span><br><span class="line">    one on the stack anyway.                                             </span><br><span class="line">                                                                         </span><br><span class="line">    On LINUX, all parameters to a function beyond  the  eight go on the </span><br><span class="line">    stack.  The first 8 go in registers  x0  through  x7 as normal (for </span><br><span class="line">    LINUX).                                                              </span><br><span class="line">*/                                                                    </span><br><span class="line">                                                                       </span><br><span class="line">SillyFunction:                                                        </span><br><span class="line">        stp        x29, x30, [sp, -16]!    // Changes sp.               </span><br><span class="line">        mov        x29, sp                 // set new sp                    </span><br><span class="line">        ldr        x0, =fmt                                 </span><br><span class="line">        mov        x1, x7                  // 第八个参数</span><br><span class="line">        ldr        x2, [sp, 16]            // This does not alter the sp，第九个参数</span><br><span class="line">        bl         printf                                                </span><br><span class="line">        ldp        x29, x30, [sp], 16      // Undoes change to sp.     </span><br><span class="line">        ret                                                          </span><br><span class="line">                                                                          </span><br><span class="line">main:                                                                   </span><br><span class="line">        stp        x29, x30, [sp, -16]!    // sp down total of 16.      </span><br><span class="line">        mov        x29, sp                                                </span><br><span class="line">        mov        x0, 9                                                </span><br><span class="line">        str        x0, [sp, -16]!          // sp down total of 32.     </span><br><span class="line">        mov        x0, 1                                                </span><br><span class="line">        mov        x1, 2                                                  </span><br><span class="line">        mov        x2, 3                                            </span><br><span class="line">        mov        x3, 4                                               </span><br><span class="line">        mov        x4, 5                                              </span><br><span class="line">        mov        x5, 6                                                  </span><br><span class="line">        mov        x6, 7                                                   </span><br><span class="line">        mov        x7, 8                                                   </span><br><span class="line">        bl         SillyFunction                                           </span><br><span class="line">        add        sp, sp, 16           // undoes change of sp by 16 due   </span><br><span class="line">                                        // to function call.              </span><br><span class="line">        ldp        x29, x30, [sp], 16   // undoes change to sp of 16.    </span><br><span class="line">        ret                                                             </span><br><span class="line">                                                                        </span><br><span class="line">        .data                                                            </span><br><span class="line">fmt:    .asciz    &quot;This example hurts my brain: %ld %ld\n&quot;           </span><br><span class="line">                                                                       </span><br><span class="line">        .end                                                         </span><br></pre></td></tr></table></figure><p>After executing <code>Line 24</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    former contents of frame pointer</span><br><span class="line">sp + 8    return address for main</span><br></pre></td></tr></table></figure><p>After executing <code>Line 27</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    9</span><br><span class="line">sp + 8    garbage</span><br><span class="line">sp + 16   former contents of frame pointer</span><br><span class="line">sp + 24   return address for main</span><br></pre></td></tr></table></figure><p>After executing <code>Line 14</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    return address for SillyFunction</span><br><span class="line">sp + 8    garbage</span><br><span class="line">sp + 16   9</span><br><span class="line">sp + 24   garbage</span><br><span class="line">sp + 32   former contents of frame pointer</span><br><span class="line">sp + 40   return address for main</span><br></pre></td></tr></table></figure><p>This means that <code>Line 18</code> fetches <code>p9</code> from memory and puts its value into x2 (where it becomes the third argument to <code>printf()</code>).</p><blockquote><p>在 AArch64 中，栈空间常常是 <strong>以 16 字节为单位对齐</strong>分配的，但你可能 <strong>只写了其中的一部分数据</strong>，剩下的就没有被初始化，于是我们称它为 <strong>“garbage”（未定义的内容）</strong>。</p></blockquote><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><h3 id="examples-of-calling-some-common-C-runtime-functions"><a href="#examples-of-calling-some-common-C-runtime-functions" class="headerlink" title="examples of calling some common C runtime functions"></a>examples of calling some common C runtime functions</h3><p>There are, by the way, two broad types of functions within the C runtime. </p><ul><li><p>Some are implemented largely in the C runtime itself. </p></li><li><p>Others that exist in the C runtime act as wrappers for functions implemented within the OS itself. These are called “system calls”.</p></li></ul><p>For the purposes of calling functions in the C runtime, there is no practical difference between these two types. Note however, there are ways of calling system calls directly using the <code>svc</code> instruction.</p><p>“C runtime”（<strong>C 运行时</strong>）指的是一组在程序运行时提供支持的函数、变量和基础机制，<strong>主要用于支持 C 语言标准库和程序的初始化/终止</strong>。这套系统通常被称为 <strong>C runtime library（C 运行时库）</strong>，在不同平台中常见的实现有：</p><ul><li>GNU/Linux 下的 <strong>glibc</strong></li><li>Windows 下的 <strong>MSVCRT</strong></li><li>macOS 下的 <strong>libSystem.dylib（包含 libc）</strong></li></ul><p>C runtime 做了哪些事？</p><ol><li><strong>程序初始化</strong><ul><li>在 <code>main()</code> 执行之前，C runtime 会设置好堆栈、初始化全局变量、调用构造函数等。</li><li>典型入口点是 <code>_start</code> → <code>__libc_start_main()</code> → <code>main()</code>。</li></ul></li><li><strong>提供标准库函数</strong><ul><li>如 <code>printf()</code>, <code>malloc()</code>, <code>exit()</code>, <code>fopen()</code> 等，这些函数由 C runtime 实现或封装。</li></ul></li><li><strong>管理资源</strong><ul><li>比如内存分配、文件句柄、线程等的生命周期管理。</li></ul></li><li><strong>提供系统调用封装</strong><ul><li>比如你调用 <code>write()</code>，它其实是调用了一个 <strong>C runtime 提供的 wrapper</strong>，最终通过 <code>syscall</code> 或 <code>svc</code> 指令访问内核。</li></ul></li></ol><h3 id="system-calls"><a href="#system-calls" class="headerlink" title="system calls"></a>system calls</h3><p>Many C runtime functions are just wrappers for system calls. For example if you call open() from the C runtime, the function will perform a few bookkeeping operations and then make the actual system call.</p><h4 id="What-IS-a-system-call"><a href="#What-IS-a-system-call" class="headerlink" title="What IS a system call?"></a>What IS a system call?</h4><p>The short answer is a system call is a sort-of function call that is serviced by the operating system itself, within its own private region of memory and with access to internal features and data structures.</p><p>Our programs run in “userland”. The technical name for userland on the ARM64 processor is EL0 (Exception Level 0).</p><p>We can operate within the kernel’s space only through carefully controlled mechanisms - such as system calls. The technical name for where the kernel (or system) generally operates is called EL1.</p><p>There are two higher Exception Levels (EL2 and EL3) which are beyond the scope of this book.</p><h4 id="Mechanism-of-making-a-system-call"><a href="#Mechanism-of-making-a-system-call" class="headerlink" title="Mechanism of making a system call"></a>Mechanism of making a system call</h4><p>First, like any function call, parameters need to be set up. The first parameter goes in the first register, etc.</p><p>Second, a number associated with the specific system call we wish to make is loaded in a specific register (w8).</p><p>Finally, a special instruction svc causes a trap which elevates us out of userland into kernel space. Said differently, svc causes a transition from EL0 to EL1. There, various checks are done and the actual code for the system call is run.</p><p>A description of returning from a system call is beyond the scope of this book. Hint: just as there’s a special instruction that escalates from EL0 to EL1, there is a special instruction that does the reverse.</p><h4 id="the-number-associated-with-a-particular-system-call"><a href="#the-number-associated-with-a-particular-system-call" class="headerlink" title="the number associated with a particular system call"></a>the number associated with a particular system call</h4><p>reference:</p>   <div class="tag link"><a class="link-card" title="syscalls" href="https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html"><div class="left"><img src="/img/avatar.jpg"/></div><div class="right"><p class="text">syscalls</p><p class="url">https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html</p></div></a></div><h4 id="example-getpid"><a href="#example-getpid" class="headerlink" title="example getpid()"></a>example getpid()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                                               </span></span><br><span class="line">                                                                  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;                                                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Greetings from: %d\n&quot;</span>, getpid());                     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                     </span><br><span class="line">&#125;                                                                 </span><br></pre></td></tr></table></figure><p>Written in assembly language using C runtime<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        .global main                                              </span><br><span class="line">        .text                                                     </span><br><span class="line">        .align  2                                                 </span><br><span class="line">                                                                  </span><br><span class="line">main:   stp     x29, x30, [sp, -16]!                              </span><br><span class="line">        bl      getpid                                            </span><br><span class="line">        mov     w1, w0                                            </span><br><span class="line">        ldr     x0, =fmt                                          </span><br><span class="line">        bl      printf                                            </span><br><span class="line">        ldp     x29, x30, [sp], 16                                </span><br><span class="line">        mov     w0, wzr                                           </span><br><span class="line">        ret                                                       </span><br><span class="line">                                                                  </span><br><span class="line">        .data                                                     </span><br><span class="line">fmt:    .asciz  &quot;Greetings from: %d\n&quot;                            </span><br><span class="line">                                                                  </span><br><span class="line">        .end                                                      </span><br></pre></td></tr></table></figure><br>And finally: calling the system call directly<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        .global main                                              </span><br><span class="line">        .text                                                     </span><br><span class="line">        .align  2                                                 </span><br><span class="line">                                                                  </span><br><span class="line">main:   stp     x29, x30, [sp, -16]!                              </span><br><span class="line">        mov     x8, 172                 // getpid on ARM64        </span><br><span class="line">        svc     0                       // trap to EL1            </span><br><span class="line">        mov     w1, w0                                            </span><br><span class="line">        ldr     x0, =fmt                                          </span><br><span class="line">        bl      printf                                            </span><br><span class="line">        ldp     x29, x30, [sp], 16                                </span><br><span class="line">        mov     w0, wzr                                           </span><br><span class="line">        ret                                                       </span><br><span class="line">                                                                  </span><br><span class="line">        .data                                                     </span><br><span class="line">fmt:    .asciz  &quot;Greetings from: %d\n&quot;                            </span><br><span class="line">                                                                  </span><br><span class="line">        .end                                                      </span><br></pre></td></tr></table></figure><br>We chose getpid() because it doesn’t require any parameters. Using the C runtime, we simply bl to it. <strong>Calling the system call directly is different in that we must first load x8 with the number that corresponds to getpid() for the AARCH64 architecture</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">/*  Perry Kivolowitz</span><br><span class="line">    Example of file operations.</span><br><span class="line">*/</span><br><span class="line">        .text</span><br><span class="line">        .global main</span><br><span class="line">        .align  2</span><br><span class="line"></span><br><span class="line">/*  This program will</span><br><span class="line">    * open() a file in the current directory,</span><br><span class="line">    * write() some text to it, </span><br><span class="line">    * seek back to the beginning of the file,</span><br><span class="line">    * read() each line, printing it</span><br><span class="line">    * close() the file</span><br><span class="line">*/</span><br><span class="line">// 使用 .req 给寄存器取别名，便于阅读。例如，fd 其实就是 w28，代表文件描述符。</span><br><span class="line">retval  .req    w27</span><br><span class="line">fd .reqw28</span><br><span class="line"></span><br><span class="line">main:   stp     x29, x30, [sp, -16]!</span><br><span class="line">        stp     x27, x28, [sp, -16]!</span><br><span class="line">        bl      open_file</span><br><span class="line"></span><br><span class="line">        // w0 will contain either the file descriptor of the new</span><br><span class="line">        // file or -1 for a failure. Note that the value in w0</span><br><span class="line">        // has also been copied to &quot;fd&quot; - a register alias.</span><br><span class="line">        cmp w0, wzr</span><br><span class="line">        bge 1f</span><br><span class="line"></span><br><span class="line">        // If we get here, the open has failed. Use perror() to</span><br><span class="line">        // print a meaningful error and branch to exit. The return</span><br><span class="line">        // code of the program will be set to non-zero inside fail.</span><br><span class="line">        ldr     x0, =fname</span><br><span class="line">        bl      fail</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">1:// When we get here, the file is open. Write some data to it.</span><br><span class="line">        // If write_file returns non-zero, it signifies an error. If</span><br><span class="line">        // so, branch to the file closing code since the file is open</span><br><span class="line">        // after printing an error message.</span><br><span class="line">        blwrite_data</span><br><span class="line">        cbz    w0, 10f</span><br><span class="line"></span><br><span class="line">        // If we get here, there was an error in write_data. Print</span><br><span class="line">        // a reasonable error message then branch to the clean usleep</span><br><span class="line">        // code.</span><br><span class="line">        ldr     x0, =wf     // load legend</span><br><span class="line">        bl      fail        // print error</span><br><span class="line">        b       50f         // branch to clean up.</span><br><span class="line"></span><br><span class="line">        // Seek back to position zero preparing to read the file back.</span><br><span class="line">        // The return value in x0 (off_t) is the return value of</span><br><span class="line">        // lseek(). </span><br><span class="line">10:     bl      seek_zero</span><br><span class="line">        cbz     x0, 20f</span><br><span class="line"></span><br><span class="line">        // If we get here, the seek failed. Cause a reasonable</span><br><span class="line">        // message to be printed then branch to the clean up code.</span><br><span class="line">        ldr     x0, =sf</span><br><span class="line">        bl      fail</span><br><span class="line">        b       50f</span><br><span class="line"></span><br><span class="line">20:     // When we get here, we have to read from the file and print</span><br><span class="line">        // the results. To ignore the complexity of memory allocation</span><br><span class="line">        // and buffer overrun potential, we&#x27;ll read one character at a </span><br><span class="line">        // time looking the end-of-file.</span><br><span class="line"></span><br><span class="line">        // ssize_t read(int fildes, void *buf, size_t nbyte);</span><br><span class="line">        mov     w0, fd</span><br><span class="line">        ldr     x1, =buffer</span><br><span class="line">        mov     x2, 1</span><br><span class="line">        bl      read</span><br><span class="line">        // Check the return value - should be 1.</span><br><span class="line">        cbz     x0,50f      // zero means EOF - that&#x27;s OK.</span><br><span class="line">        // If x0 is negative, that IS a problem.</span><br><span class="line">        cmp     x0, xzr</span><br><span class="line">        bge     25f</span><br><span class="line">        // The return value is negative - this is an error.</span><br><span class="line">        ldr     x0, =rf</span><br><span class="line">        bl      fail</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">25:     // Write the character sitting in buffer to the console.</span><br><span class="line">        mov     w0, 1</span><br><span class="line">        ldr     x1, =buffer</span><br><span class="line">        mov     x2, 1</span><br><span class="line">        bl      write</span><br><span class="line">        // We will ignore the return value for the sake of brevity.</span><br><span class="line">        // There are plenty of examples of handling a potential error</span><br><span class="line">        // elsewhere in this code.</span><br><span class="line">        // --</span><br><span class="line">        b       20b</span><br><span class="line"></span><br><span class="line">        // When we get here, we are done. Close the file.</span><br><span class="line">50:movw0, fd</span><br><span class="line">        bl close</span><br><span class="line">        mov retval, wzr</span><br><span class="line"></span><br><span class="line">99:     ldp     x27, x28, [sp], 16</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        mov     w0, retval</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*open_file()</span><br><span class="line">    This function attempts to open a file for both reading and</span><br><span class="line">    writing. Return values will be checked to ensure the file is</span><br><span class="line">    opened. If successful, the fd is returned (and is squirreled</span><br><span class="line">    away in register &quot;fd&quot;). If unsuccessful, the -1 returned by</span><br><span class="line">    open() is passed back to the caller.</span><br><span class="line"></span><br><span class="line">    Explanation of the magic numbers:</span><br><span class="line"></span><br><span class="line">    int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">    octal 102 for flags is O_RDRW | O_CREAT</span><br><span class="line">    octal 600 for mode is rw------- i.e. read and write for</span><br><span class="line">        the owner but no permissions for anyone else.</span><br><span class="line"></span><br><span class="line">There is a version of open() that takes two parameters. However,</span><br><span class="line">if O_CREAT is specified, the three parameter version is required.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">        .equ    O_FLAGS, 0102</span><br><span class="line">        .equ    O_MODE, 0600</span><br><span class="line"></span><br><span class="line">open_file:</span><br><span class="line">        stp      x29, x30, [sp, -16]!</span><br><span class="line">        ldr      x0, =fname</span><br><span class="line">        mov      w1, O_FLAGS</span><br><span class="line">        mov      w2, O_MODE</span><br><span class="line">        bl       open</span><br><span class="line">        mov      fd, w0</span><br><span class="line">        ldp      x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*  This function uses perror() to print a meaningful error</span><br><span class="line">    message in the event of a failure. The string value</span><br><span class="line">    passed to perror() arrives to us as a pointer in x0.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        bl perror</span><br><span class="line">        movretval, 1</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*  ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">This function will write a string to the file descriptor contained</span><br><span class="line">in &quot;fd&quot; (a register alias).</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">write_data:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        str     x20, [sp, -16]!</span><br><span class="line">        mov     w0, fd              // file descriptor</span><br><span class="line">        ldr     x1, =txt            // address to print from</span><br><span class="line">        ldr     x2, =txt_s          // load pointer to size</span><br><span class="line">        ldr     x2, [x2]            // dereference the pointer</span><br><span class="line">        mov     w20, w2             // need this value for error check.</span><br><span class="line">        bl      write</span><br><span class="line">        cmp     x0, x20             // Did we write the expected amount?</span><br><span class="line">        bne     90f</span><br><span class="line">        // successful write - return 0</span><br><span class="line">        mov     x0, xzr</span><br><span class="line">        b       99f</span><br><span class="line">90:     // failure - ensure we return non-zero!</span><br><span class="line">        mov     x0, 1</span><br><span class="line">99:     ldr     x20, [sp], 16</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*  off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">*/</span><br><span class="line">seek_zero:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        mov     w0, fd          // file descriptor</span><br><span class="line">        mov     x1, xzr         // beginning of file</span><br><span class="line">        mov     w2, wzr         // SEEK_SET - absolute offset</span><br><span class="line">        bl      lseek</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">prog:.asciz&quot;file_ops&quot;</span><br><span class="line">wf:     .asciz  &quot;write failed&quot;</span><br><span class="line">rf:     .asciz  &quot;read failed&quot;</span><br><span class="line">sf:     .asciz  &quot;lseek failed&quot;</span><br><span class="line">fname:.asciz&quot;test.txt&quot;</span><br><span class="line">txt:.asciz&quot;some data\n&quot;</span><br><span class="line">txt_s:.wordtxt_s - txt - 1// strlen(txt)，txt：“some data”的总长度</span><br><span class="line">buffer: .word   0</span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><h2 id="floating-point"><a href="#floating-point" class="headerlink" title="floating point"></a>floating point</h2><h3 id="what-are-floating-points-numbers"><a href="#what-are-floating-points-numbers" class="headerlink" title="what are floating points numbers?"></a>what are floating points numbers?</h3><p>reference<br>   <div class="tag link"><a class="link-card" title="CSAPP DataLab" href="https://even629.com/posts/42856/"><div class="left"><img src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">CSAPP DataLab</p><p class="url">https://even629.com/posts/42856/</p></div></a></div></p><p><strong>IEEE 754</strong></p><h3 id="register-1"><a href="#register-1" class="headerlink" title="register"></a>register</h3><p>There are four highest level ideas relating to floating point operations on AARCH64.</p><ul><li>There is another complete register set for floating point values.</li><li>There are alternative instructions just for floating point values.</li><li>There are exotic instructions that operate on sets of floating point values (SIMD).</li><li>There are instructions to go back and forth to and from the integer registers.</li></ul><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/simdlanes.jpg" alt="regs"></p><p>上图展示了 <strong>ARM64 架构中 SIMD（Single Instruction, Multiple Data）寄存器 V0 的不同视图与访问方式</strong>，包括<strong>不同位宽的排列方式（Arrangement Specifiers）与 Lane（通道）索引</strong>。</p><p> <strong>图解说明</strong></p><p>这个图以 <strong>V0 寄存器为例</strong>，展示了 <strong>如何用不同的排列方式访问其内容</strong>：</p><div class="table-container"><table><thead><tr><th>层级</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>最底层</td><td><code>V0</code></td><td>整个 128-bit 的 V0 寄存器</td></tr><tr><td>向上</td><td><code>V0.2D</code>, <code>V0.4S</code>, <code>V0.8H</code>, <code>V0.16B</code></td><td>以不同大小的数据视图访问 V0：<br/>- D = 64-bit（2 × 64bit）<br/>- S = 32-bit（4 × 32bit）<br/>- H = 16-bit（8 × 16bit）<br/>- B = 8-bit（16 × 8bit）</td></tr><tr><td>再上</td><td><code>V0.2D[0]</code>, <code>V0.4S[0]</code> 等</td><td>每个 lane 的索引，比如：<br/>- <code>V0.4S[2]</code> 表示第 3 个 32-bit 单元<br/>- <code>V0.16B[15]</code> 表示第 16 个 8-bit 字节</td></tr><tr><td>最上层</td><td><code>B0</code>, <code>H0</code>, <code>S0</code>, <code>D0</code></td><td>是对 <code>V0</code> 的 alias，按位宽访问（只访问最低位的数据）</td></tr></tbody></table></div><h3 id="truncation-towards-zero"><a href="#truncation-towards-zero" class="headerlink" title="truncation towards zero"></a>truncation towards zero</h3><p>truncate(截断)</p><p>In C and C++, truncation is what we get from:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">integer_variable = <span class="type">int</span>(floating_variable);  <span class="comment">// C++</span></span><br><span class="line">integer_variable = (<span class="type">int</span>) floating_variable; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><blockquote><p>The instruction is <strong>fcvtz</strong> - convert towards zero. Then, the choice as to whether to produce a signed or unsigned result is defined by the final letterL u or s.</p></blockquote><div class="table-container"><table><thead><tr><th>Mnemonic</th><th>Meaning</th></tr></thead><tbody><tr><td>fcvtzu</td><td>Truncate (always towards 0) producing an unsigned int</td></tr><tr><td>fcvtzs</td><td>Truncate (always towards 0) producing a signed int</td></tr></tbody></table></div><ul><li>fcvtzu: <strong>F</strong>loat <strong>C</strong>onvert to <strong>U</strong>nsigned integer, with truncation toward zero</li><li>fcvtzs: <strong>F</strong>loat <strong>C</strong>onvert to <strong>S</strong>igned integer, with truncation toward zero</li></ul><p>this instruction which completely discards the fractional value is said by the ARM documentation as doing rounding not truncating.</p><p>The the choice of source register defined whether you are converting a double or single precision floating point value.</p><div class="table-container"><table><thead><tr><th>Source Register</th><th>Converts a</th></tr></thead><tbody><tr><td>dX</td><td><code>double</code> to an integer</td></tr><tr><td>sX</td><td><code>float</code> to an integer</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Destination Register</th><th>Converts a</th></tr></thead><tbody><tr><td>xX</td><td>64 bit integer</td></tr><tr><td>wX</td><td>32 bit or less integer</td></tr></tbody></table></div><p>Examples where <code>d</code> is a <code>double</code> and <code>f</code> is a <code>float</code>:</p><div class="table-container"><table><thead><tr><th>C++</th><th>Instruction</th></tr></thead><tbody><tr><td><code>int32_t(d)</code></td><td><code>fcvtzs    w0, d0</code></td></tr><tr><td><code>uint32_t(d)</code></td><td><code>fcvtzu    w0, d0</code></td></tr><tr><td><code>int64_t(d)</code></td><td><code>fcvtzs    x0, d0</code></td></tr><tr><td><code>uint64_t(d)</code></td><td><code>fcvtzu    x0, d0</code></td></tr></tbody></table></div><h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">    .section .text</span><br><span class="line">    .global main</span><br><span class="line">    .type main, @function // 表示 告诉汇编器和链接器：main 是一个函数符号（symbol）</span><br><span class="line">    //.type &lt;symbol&gt;, @&lt;type&gt; 是 GAS（GNU Assembler）的一条伪指令，用于给符号指定类型。</span><br><span class="line">    // &lt;symbol&gt;：符号名，比如 main</span><br><span class="line">    // @&lt;type&gt;：符号类型，这里是 @function，表示这是一个函数，而不是变量或标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    stp     x29, x30, [sp, -16]!     // 保存 frame pointer 和 link register</span><br><span class="line">    mov     x29, sp</span><br><span class="line"></span><br><span class="line">    // 保存浮点寄存器</span><br><span class="line">    stp     d20, d21, [sp, -16]!</span><br><span class="line">    stp     d22, d23, [sp, -16]!</span><br><span class="line"></span><br><span class="line">    // 加载提示信息</span><br><span class="line">    ldr     x0, =leg</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // 加载 vless 数据到 d20-d23</span><br><span class="line">    ldr     x0, =vless</span><br><span class="line">    ldr     d20, [x0]            // dless = 5.49</span><br><span class="line">    ldr     d21, [x0, #8]        // dmore = 5.51</span><br><span class="line">    ldr     d22, [x0, #16]       // ndless = -5.49</span><br><span class="line">    ldr     d23, [x0, #24]       // ndmore = -5.51</span><br><span class="line"></span><br><span class="line">    // fcvtps: 向上取整（+∞）</span><br><span class="line">    fcvtps  x1, d20</span><br><span class="line">    fcvtps  x2, d21</span><br><span class="line">    ldr     x0, =fmt1</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtps  x1, d22</span><br><span class="line">    fcvtps  x2, d23</span><br><span class="line">    ldr     x0, =fmt1</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtns: 四舍五入 (tie to even)</span><br><span class="line">    fcvtns  x1, d20</span><br><span class="line">    fcvtns  x2, d21</span><br><span class="line">    ldr     x0, =fmt2</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtns  x1, d22</span><br><span class="line">    fcvtns  x2, d23</span><br><span class="line">    ldr     x0, =fmt2</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtzs: 向 0 取整</span><br><span class="line">    fcvtzs  x1, d20</span><br><span class="line">    fcvtzs  x2, d21</span><br><span class="line">    ldr     x0, =fmt4</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtzs  x1, d22</span><br><span class="line">    fcvtzs  x2, d23</span><br><span class="line">    ldr     x0, =fmt4</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtas: 四舍五入 (tie away from zero)</span><br><span class="line">    fcvtas  x1, d20</span><br><span class="line">    fcvtas  x2, d21</span><br><span class="line">    ldr     x0, =fmt3</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtas  x1, d22</span><br><span class="line">    fcvtas  x2, d23</span><br><span class="line">    ldr     x0, =fmt3</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // 恢复浮点寄存器和返回地址</span><br><span class="line">    ldp     d22, d23, [sp], #16</span><br><span class="line">    ldp     d20, d21, [sp], #16</span><br><span class="line">    ldp     x29, x30, [sp], #16</span><br><span class="line">    mov     w0, wzr</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .section .rodata</span><br><span class="line">vless:</span><br><span class="line">    .double 5.49</span><br><span class="line">    .double 5.51</span><br><span class="line">    .double -5.49</span><br><span class="line">    .double -5.51</span><br><span class="line"></span><br><span class="line">fmt1:</span><br><span class="line">    .asciz &quot;fcvtps less: %ld more: %ld\n&quot;</span><br><span class="line">fmt2:</span><br><span class="line">    .asciz &quot;fcvtns less: %ld more: %ld\n&quot;</span><br><span class="line">fmt3:</span><br><span class="line">    .asciz &quot;fcvtas less: %ld more: %ld\n&quot;</span><br><span class="line">fmt4:</span><br><span class="line">    .asciz &quot;fcvtzs less: %ld more: %ld\n&quot;</span><br><span class="line">leg:</span><br><span class="line">    .asciz &quot;less values are +/- 5.49. more values are +/- 5.51.\n&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Notice all the values were truncated to the whole number that is closer to zero.</p><h3 id="Truncation-Away-From-Zero"><a href="#Truncation-Away-From-Zero" class="headerlink" title="Truncation Away From Zero"></a>Truncation Away From Zero</h3><p>Truncation away from zero is not as easy. In fact, it cannot be performed with a single instruction.</p><p>In C (and C++):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iv = (<span class="type">int</span>(fv) == fv) ? <span class="type">int</span>(fv) : <span class="type">int</span>(fv) + ((fv &lt; <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>If the fv is already equal to a whole number, the integer value will be that whole number. Other wise the iv is the whole number further away from zero.</p><p>In C++, a more sophisticated version would require <cmath> and could look like:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyTruncate</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((x &lt; <span class="number">0</span>) ? <span class="built_in">floor</span>(x) : <span class="built_in">ceil</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>floor() always truncates downward (towards more negative).<br>ceil() always truncates upwards (towards more positive).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RoundAwayFromZero:</span><br><span class="line">        fcmp    d0, 0</span><br><span class="line">        ble     1f</span><br><span class="line">        // Value is positive, truncate towards positive infinity (ceil)</span><br><span class="line">        frintp  d0, d0</span><br><span class="line">        b       2f</span><br><span class="line">1:      // Value is negative, truncate towards negative infinity (floor)</span><br><span class="line">        frintm  d0, d0</span><br><span class="line">2:      fcvtzs  x0, d0</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><ul><li><p>frintp（<strong>R</strong>ound toward +∞）</p></li><li><p>frintm（<strong>R</strong>ound toward -∞）</p></li><li><p>frintz（<strong>R</strong>ound toward 0）</p></li><li><p>frinta（<strong>R</strong>ound to nearest, tie away from 0）</p></li><li><p>frintn（<strong>R</strong>ound to nearest, tie to even）</p></li></ul><h3 id="rounding-conversion"><a href="#rounding-conversion" class="headerlink" title="rounding conversion"></a>rounding conversion</h3><p>rounding(四舍五入)<br>An instruction which does what we normally think of as rounding is frinta. This is the conversion “to nearest with ties going away.” So, 5.5 goes to 6 as one would expect from “rounding.”</p><h3 id="converting-an-integer-to-a-float-point-value"><a href="#converting-an-integer-to-a-float-point-value" class="headerlink" title="converting an integer to a float point value"></a>converting an integer to a float point value</h3><p>In C / C++:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double_var = <span class="built_in">double</span>(integer_var); <span class="comment">// C++</span></span><br><span class="line">double_var = (<span class="type">double</span>)integer_var; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><br>Is handled by two instructions:</p><ul><li><strong>scvtf</strong> converts a signed integer to a floating point value</li><li><strong>ucvtf</strong> converts an unsigned integer to a floating point value<br>The name of the destination register controls which kind of floating point value is made. For example, specifying dX makes a double etc.</li></ul><p>The name of the destination register controls which kind of floating point value is made. For example, specifying dX makes a double etc.</p><h3 id="floating-point-literals"><a href="#floating-point-literals" class="headerlink" title="floating point literals"></a>floating point literals</h3><p>Recall that all AARCH64 instructions are 4 bytes long. Recall also that this means that there are constraints on what can be specified as a literal since the literal must be encoded into the 4 byte instruction. If the literal is too large, an assembler error will result.</p><p>Given that floating point values are always at least 4 bytes long themselves, using floating point literals is extremely constrained. For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmov    d0, 1     // 1</span><br><span class="line">fmov    d0, 1.1   // 2</span><br></pre></td></tr></table></figure><p>Line 1 will pass muster but Line 2 will cause an error.</p><p>To load a float, you could translate the value to binary and do as the following:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        .text                                                   </span><br><span class="line">        .global main                                            </span><br><span class="line">        .align    2                                             </span><br><span class="line">                                                                </span><br><span class="line">main:   str        x30, [sp, -16]!                              </span><br><span class="line">        ldr        s0, =0x3fc00000                              </span><br><span class="line">        fcvt       d0, s0                                       </span><br><span class="line">        ldr        x0, =fmt                                     </span><br><span class="line">        bl         printf                                       </span><br><span class="line">        ldr        x30, [sp], 16                                </span><br><span class="line">        mov        w0, wzr                                      </span><br><span class="line">        ret                                                     </span><br><span class="line">                                                                </span><br><span class="line">        .data                                                   </span><br><span class="line">fmt:    .asciz    &quot;%f\n&quot;                                        </span><br><span class="line">        .end                                                    </span><br></pre></td></tr></table></figure></p><blockquote><p>printf() only knows how to print double precision values. When you specify a float, it will convert it to a double before emitting it.</p></blockquote><p>Translating floats and doubles by hand isn’t a common practice for humans, though compilers are happy to do so.</p><p>Instead for us humans, the assembler directives .float and .double are used more frequently to specify float and double values putting them into RAM.<br>a example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        .global main                                            </span><br><span class="line">        .text                                                   </span><br><span class="line">        .align  2                                               </span><br><span class="line">                                                                </span><br><span class="line">counter .req    x20                                             </span><br><span class="line">dptr    .req    x21                                             </span><br><span class="line">fptr    .req    x22                                             </span><br><span class="line">        .equ    max, 4                                              </span><br><span class="line">                                                                    </span><br><span class="line">main:   stp     counter, x30, [sp, -16]!                            </span><br><span class="line">        stp     dptr, fptr, [sp, -16]!                              </span><br><span class="line">        ldr     dptr, =d                                            </span><br><span class="line">        ldr     fptr, =f                                            </span><br><span class="line">        mov     counter, xzr                                        </span><br><span class="line">                                                                    </span><br><span class="line">1:      cmp     counter, max                                        </span><br><span class="line">        beq     2f                                                  </span><br><span class="line">                                                                    </span><br><span class="line">        ldr     d0, [dptr, counter, lsl 3]                          </span><br><span class="line">        ldr     s1, [fptr, counter, lsl 2]                          </span><br><span class="line">        fcvt    d1, s1                                              </span><br><span class="line">        ldr     x0, =fmt                                            </span><br><span class="line">        add     counter, counter, 1                                 </span><br><span class="line">        mov     x1, counter                                         </span><br><span class="line">        bl      printf                                              </span><br><span class="line">        b       1b                                                  </span><br><span class="line">                                                                    </span><br><span class="line">2:      ldp     dptr, fptr, [sp], 16                                </span><br><span class="line">        ldp     counter, x30, [sp], 16                              </span><br><span class="line">        mov     w0, wzr                                             </span><br><span class="line">        ret                                                         </span><br><span class="line">                                                                    </span><br><span class="line">        .data                                                       </span><br><span class="line">fmt:    .asciz  &quot;%d %f %f\n&quot;                                       </span><br><span class="line">d:      .double 1.111111, 2.222222, 3.333333, 4.444444              </span><br><span class="line">f:      .float  1.111111, 2.222222, 3.333333, 4.444444             </span><br><span class="line">                                                                    </span><br><span class="line">        .end                                                        </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>指令</th><th>全称/缩写</th><th>作用</th><th>常见用法示例</th></tr></thead><tbody><tr><td><code>.req</code></td><td><strong>register require</strong>（非官方缩写）</td><td>给<strong>寄存器起别名</strong></td><td><code>foo .req x0</code> 表示以后写 <code>foo</code> 就等于 <code>x0</code></td></tr><tr><td><code>.equ</code></td><td><strong>equate</strong></td><td>定义一个<strong>常量符号</strong></td><td><code>BUF_SIZE .equ 64</code> 表示 <code>BUF_SIZE = 64</code></td></tr></tbody></table></div><p>On Linux, just as w/x0 through w/x7 are scratch registers and used to pass parameters, s/d0 and s/d7 are as well beginning with the 0 register.</p><p>即：</p><p>📥 整数参数传递：<br>x0 ~ x7（或 32 位的 w0 ~ w7）用于传递前 8 个整数类参数（int、pointer、long 等）。</p><p>超过 8 个就通过栈传递。</p><p>📥 浮点参数传递：<br>d0 ~ d7（64 位 double 类型）或 s0 ~ s7（32 位 float 类型）用于传递前 8 个浮点参数。</p><p>超过 8 个浮点参数也是通过栈传递。</p><h4 id="Fitting-32-bits-into-a-32-bit-bag"><a href="#Fitting-32-bits-into-a-32-bit-bag" class="headerlink" title="Fitting 32 bits into a 32 bit bag"></a>Fitting 32 bits into a 32 bit bag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr s0, =0x3fc00000  // 伪指令！我们以为它直接把 0x3fc00000 加载进 s0</span><br></pre></td></tr></table></figure><p>编译器不能直接把任意 32 位值硬编码进指令中（因为一条 ARM 指令本身就只有 32 位）。</p><p>所以它实际上是：</p><ol><li>将字面量值 0x3fc00000 写到内存的某个地方（通常靠近当前函数底部）。</li><li>生成一条 ldr 指令，用 PC-relative load 的方式从这个地址加载该值。<br>这块被称为一个 literal pool，它是一些常量的集合。</li></ol><p>We expected line 6 to read:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr        s0, =0x3fc00000</span><br></pre></td></tr></table></figure><br>Instead we find:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b+ 0x784 &lt;main+4&gt;          ldr     s0, 0x7a0 &lt;main+32&gt;</span><br></pre></td></tr></table></figure><br>Scan downward to find 0x7a0:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7a0 &lt;main+32&gt;         .inst   0x3fc00000 ; undefined  </span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th>伪指令</th><th>实际效果</th><th>GDB中看到的实际汇编</th></tr></thead><tbody><tr><td><code>ldr s0, =0x3fc00000</code></td><td>把常量加载进 <code>s0</code> 寄存器</td><td><code>ldr s0, #literal_addr</code><br><code>literal_addr: .inst 0x3fc00000</code></td></tr><tr><td><code>ldr x0, =fmt</code></td><td>加载字符串指针地址</td><td><code>ldr x0, #literal_addr</code><br><code>literal_addr: .inst 地址值</code></td></tr><tr><td><code>.inst 0x3fc00000</code></td><td>手动插入一个 32 位数据（不一定是有效指令）</td><td>存放常量（不是执行）</td></tr></tbody></table></div><p>.inst 的含义<br>全称：.inst = insert instruction<br>用途：直接插入一条 ARM 指令的机器码（通常是 32 位十六进制值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.inst 0xd65f03c0   // 实际是 ret 指令</span><br></pre></td></tr></table></figure><p>这个例子中，.inst 后的机器码 0xd65f03c0 是 ret 指令的 32 位编码。也就是说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure><p>等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.inst 0xd65f03c0</span><br></pre></td></tr></table></figure><br>在上面的例子中，可以用.inst定义一个地址，从该地址中加载</p><p>为什么不用 mov reg, #imm ？</p><ul><li>mov 有立即数编码限制，不能加载任意 32 位值。</li><li>超过范围时，必须用 ldr 从内存加载。<h3 id="fmov"><a href="#fmov" class="headerlink" title="fmov"></a>fmov</h3><blockquote><p>The fmov instruction is used to move floating point values in and out of floating point registers and to some degree, moving data between integer and floating point registers.</p></blockquote></li></ul><p><strong>loading floating point numbers as immediate values</strong></p><p>Just as we saw with integer registers, some values can be used as immediate values and some cannot. It comes down to how many bits are necessary to encode the value. Too many bits… not enough room to fit in a 4 byte instruction plus the opcode.</p><p>For example, this works:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    x0, 65535</span><br></pre></td></tr></table></figure><br>but this does not:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    x0, 65537</span><br></pre></td></tr></table></figure></p><p>The constraints placed on immediate values for fmov are much tighter because floating point numbers are far more complex than integers.</p><p>fmov d0, #imm 能否工作，取决于该浮点数是否能在8位编码空间内被精确表示：</p><div class="table-container"><table><thead><tr><th>结构</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>符号位</td><td>1 bit</td><td>表示正或负</td></tr><tr><td>指数部分</td><td>3 bits</td><td>控制大小（乘以 2 的幂）</td></tr><tr><td>尾数部分</td><td>4 bits</td><td>仅能由 1/2、1/4、1/8、1/16 组合构成</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmov d0, 1.0        // ✅ OK：整数 1 是 2⁰，指数可编码</span><br><span class="line">fmov d0, 1.5        // ✅ OK：1 + 0.5 = 2⁰ + 2⁻¹，指数/尾数都能编码</span><br><span class="line">fmov d0, 1.75       // ✅ OK：1 + 0.5 + 0.25 = 2⁰ + 2⁻¹ + 2⁻²</span><br><span class="line">fmov d0, 1.875      // ✅ OK：+ 2⁻³</span><br><span class="line">fmov d0, 1.9375     // ✅ OK：+ 2⁻⁴</span><br><span class="line">fmov d0, 1.96875    // ❌ 不行：需要 2⁻⁵，尾数超出 4 位</span><br></pre></td></tr></table></figure><p>大浮点不能用 fmov，改用 ldr。</p><p>fmov 是“位复制器”，不是“精度转换器”。你要改数值精度，就必须用 fcvt 系列。</p><h3 id="half-precision"><a href="#half-precision" class="headerlink" title="half precision"></a>half precision</h3><blockquote><p>Support for half precision (16 bit) floating point values does exist but there is no complete agreement on how different compilers support them. Indeed, there are not one but two competing half precision formats out there. These are the IEEE and GOOGLE types. Further still, many open source developers have created their own implementations with potentially clashing naming conventions.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__fp16 <span class="title function_">Foo</span><span class="params">(__fp16 g, __fp16 f)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> g + f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compiles to:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fcvt    s1, h1</span><br><span class="line">fcvt    s0, h0</span><br><span class="line">fadd    s0, s0, s1</span><br><span class="line">fcvt    h0, s0</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>Notice each half precision value is converted to single precision. So, from C and C++ working with half precision values can be inefficient.</p><p>On the other hand, if you are willing to use intrinsics and one of the SIMD instruction sets offered by ARM, then knock yourself out. Be aware that doing so ties your code to the ARM processor in ways which you might regret later.</p><h3 id="bit-manipulation-1"><a href="#bit-manipulation-1" class="headerlink" title="bit manipulation"></a>bit manipulation</h3><p>Bit fields are a feature of the C and C++ language which completely hide what is often called “bit bashing”.</p><blockquote><p>the ordering of bits in a bit field is not guaranteed to be the same on different platforms and even between different compilers on the same platform.</p></blockquote><p>位域是一种用来在结构体内 精确控制成员所占二进制位数 的语法，通常用于硬件寄存器、协议头等空间敏感的场景。<br>语法格式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    类型 成员名 : 位宽;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>example:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>a 用 1 位，能表示 0 或 1</li><li>b 用 2 位，能表示 0 ~ 3</li><li>c 用 5 位，能表示 0 ~ 31<br>三个成员总共占 1 + 2 + 5 = 8 位，即 1 字节</li></ul><ol><li>虽然每个成员是个位宽，但整体大小通常向整型对齐（这里是 1 字节，因为 8 位正好一字节）。</li><li>不同编译器对位域对齐和填充细节可能略有差异。</li><li>访问时可以像普通成员一样：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BF</span> <span class="title">bf</span>;</span></span><br><span class="line">bf.a = <span class="number">1</span>;</span><br><span class="line">bf.b = <span class="number">3</span>;</span><br><span class="line">bf.c = <span class="number">31</span>;</span><br></pre></td></tr></table></figure><p>编译器会自动对位域进行掩码和移位处理。</p><p>Consider a data structure for which there will be potentially millions of instances in RAM. Or, perhaps billions of instances on disc. Suppose you need 8 boolean members in every instance. The C++ standard does not define the size of a bool instead leaving it to be implementation dependent. Some implementations equate bool to int, four bytes in length. Some implement bool with a char, or 1 byte in length.</p><p>Let’s assume the smallest case and equate a bool with char. Our struct, for which there may be millions or billions of instances requires 8 bool so therefore 8 bytes. Times millions or billions.</p><p>Bit fields can come to your aid here by using a single bit per boolean value. In the best case, 8 bytes collapse to 1 byte. In a worse case, 8 x 4 = 32 bytes collapsed into 1.</p><p>假设使用最小单位，即每个 bool 是 1 字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> b0;</span><br><span class="line">    <span class="type">bool</span> b1;</span><br><span class="line">    <span class="type">bool</span> b2;</span><br><span class="line">    <span class="type">bool</span> b3;</span><br><span class="line">    <span class="type">bool</span> b4;</span><br><span class="line">    <span class="type">bool</span> b5;</span><br><span class="line">    <span class="type">bool</span> b6;</span><br><span class="line">    <span class="type">bool</span> b7;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体大小为 8 字节（1 字节 × 8 个 bool）。<br>如果有百万个实例，占用的内存就是 8MB，如果有十亿个实例，则是 8GB。<br>对于 4 字节的 bool 实现，则大小直接变成 32 字节，每亿实例就是 3.2GB。</p><p>解决方案：使用位域压缩布尔值<br>用位域，将 8 个布尔值定义为 1 位大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b0 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b3 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b4 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b5 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b6 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b7 : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>8 个 1-bit 成员 合起来正好占 1 字节。</p><p>这样 8 字节压缩成 1 字节，节省了大量空间。</p><p>In Computer Science there is an eternal tension between space and time. The following is a law:</p><p>If you want something to go faster, it will cost more memory.</p><p>If you want to save memory, what you’re doing will take more time.</p><p>This law shows up here… recall the example of where we wanted to save memory by collapsing 8 bool into 1 byte? To save that memory we will slow down because accessing the right bits takes a couple of instructions where overwriting a bool implemented as an int takes just one instruction.</p><p>As for the assembly language that bit field will produce, it depends upon optimization level. Unoptimized, the code produced will be much longer and cumbersome than the “sophisticated” assembly language.</p><h3 id="endian"><a href="#endian" class="headerlink" title="endian"></a>endian</h3><p>the ARM swing both ways: the litte-endian and the big-endian. But:</p><p>The standard toolchain emits little endian code. It is a big task to install the big-endian version of the toolchain.</p><p>Here is a quote from Wikipedia:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARM, C-Sky, <span class="keyword">and </span>RISC-V have no relevant <span class="keyword">big-endian </span>deployments, <span class="keyword">and </span>can <span class="keyword">be </span>considered little-endian in practice.</span><br></pre></td></tr></table></figure><br>The common Intel processors are also little-endian.</p><h2 id="assembly-macros"><a href="#assembly-macros" class="headerlink" title="assembly macros"></a>assembly macros</h2><p>An early innovation in assemblers was the introduction of a macro capability. Given what could be considered a certain amount of tedium in coding in asm, macros provide a simple form of meta programming where a series of statements can be encapsulated by a single macro. Think of a macro as an early form of C++ templated function (kinda but not really).</p><p>Here’s an example of an assembly language macro:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.macro LLD_ADDR xreg, label </span><br><span class="line">        adrp    \xreg, \label@PAGE</span><br><span class="line">        add     \xreg, \xreg, \label@PAGEOFF</span><br><span class="line">.endm</span><br><span class="line">```asm</span><br><span class="line">Here&#x27;s how it might be used:</span><br><span class="line">```asm</span><br><span class="line">        LLD_ADDR x0, fmt</span><br></pre></td></tr></table></figure><br>This gets expanded to:<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> fmt<span class="title">@PAGE</span></span><br><span class="line"><span class="keyword">add</span>     <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> fmt<span class="title">@PAGEOFF</span></span><br></pre></td></tr></table></figure></p><p>gcc on Linux does not run assembly language files through the C pre-processor if the asm file ends in .s but WILL if the file ends in .S</p><h3 id="Genaral-Use"><a href="#Genaral-Use" class="headerlink" title="Genaral Use"></a>Genaral Use</h3><h4 id="AASCIZ"><a href="#AASCIZ" class="headerlink" title="AASCIZ"></a>AASCIZ</h4><p>AASCIZ    label, string</p><p>This macro invokes .asciz with the string set to string and the label set to label. In addition, this macro ensures that the string begins on a 4-byte-aligned boundary.</p><h4 id="PUSH-P-PUSH-R-POP-P-and-POP-R"><a href="#PUSH-P-PUSH-R-POP-P-and-POP-R" class="headerlink" title="PUSH_P, PUSH_R, POP_P and POP_R"></a>PUSH_P, PUSH_R, POP_P and POP_R</h4><p>These macros save some repetitive typing. For example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_P  x29, x30</span><br></pre></td></tr></table></figure><br>resolves to:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stp     x29, x30, [sp, -16]!</span><br></pre></td></tr></table></figure></p><h4 id="START-PROC-and-END-PROC"><a href="#START-PROC-and-END-PROC" class="headerlink" title="START_PROC and END_PROC"></a>START_PROC and END_PROC</h4><p>Place START_PROC after the label introducing a function.</p><p>Place END_PROC after the last ret of the function.</p><p>These resolve to: .cfi_startproc and .cfi_endproc respectively.</p><h4 id="MIN-and-MAX"><a href="#MIN-and-MAX" class="headerlink" title="MIN and MAX"></a>MIN and MAX</h4><p>Handy more readable macros for determining minima and maxima. Note that the macro performs a cmp which subtracts src_b from src_a (discarding the results) in order to set the flags to be interpreted by the following csel.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIN     src_a, src_b, dest</span><br></pre></td></tr></table></figure><br>The smaller of src_a and src_b is put into dest.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX     src_a, src_b, dest</span><br></pre></td></tr></table></figure><br>The larger of src_a and src_b is put into dest.</p><h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p>MOD macro used above is defined as:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.macro  MOD         src_a, src_b, dest, scratch</span><br><span class="line">        sdiv        \scratch, \src_a, \src_b</span><br><span class="line">        msub        \dest, \scratch, \src_b, \src_a</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></p><h4 id="GLABEL"><a href="#GLABEL" class="headerlink" title="GLABEL"></a>GLABEL</h4><p>Mark a label as global, Makes a label available externally.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLABEL label</span><br></pre></td></tr></table></figure><br>An underscore is prepended.</p><h4 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h4><p>Calling CRT(C runtime) functions<br>If you create your own function without an underscore, just call it as usual.<br>If you need to call a function such as those found in the C runtime library, use this macro in this way:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRT     strlen</span><br></pre></td></tr></table></figure><h4 id="MAIN"><a href="#MAIN" class="headerlink" title="MAIN"></a>MAIN</h4><p>Declaring main()<br>Put MAIN on a line by itself. Notice there is no colon.</p><h4 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h4><p>The externally defined errno is accessed via a CRT function which isn’t seen when coding in C and C++. The function is named differently on Mac versus Linux. To get the address of errno use:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRNO_ADDR</span><br></pre></td></tr></table></figure><br>This macro makes the correct CRT call and leaves the address of errno in x0.</p><h3 id="Loads-and-Stores"><a href="#Loads-and-Stores" class="headerlink" title="Loads and Stores"></a>Loads and Stores</h3><h4 id="GLD-PTR"><a href="#GLD-PTR" class="headerlink" title="GLD_PTR"></a>GLD_PTR</h4><p>Loads the address of a label and then dereferences it where, on Apple the label is in the global space and on Linux is a relatively close label.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLD_PTR     xreg, label</span><br></pre></td></tr></table></figure><br>When this macro finishes, the specified x register contains what 64 bit value lives at the specified label.</p><h4 id="GLD-ADDR"><a href="#GLD-ADDR" class="headerlink" title="GLD_ADDR"></a>GLD_ADDR</h4><p>Loads the address of the label into the specified x register. No dereferencing takes place. On Apple machines, the label will be found in the global space.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLD_ADDR    xreg, label</span><br></pre></td></tr></table></figure><br>When this macro completes, the address of the label is in the x register.</p><h4 id="LLD-ADDR"><a href="#LLD-ADDR" class="headerlink" title="LLD_ADDR"></a>LLD_ADDR</h4><p>Similar to GLD_ADDR this macro loads the address of a “local” label.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_ADDR xreg, label</span><br></pre></td></tr></table></figure><br>When this macro completes, the address of the label is in the x register.</p><h4 id="LLD-DBL"><a href="#LLD-DBL" class="headerlink" title="LLD_DBL"></a>LLD_DBL</h4><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_DBL xreg, dreg, label</span><br></pre></td></tr></table></figure><br>When this macro completes, a double that lives at the specified local label will sit in the specified double register.</p><h4 id="LLD-FLT"><a href="#LLD-FLT" class="headerlink" title="LLD_FLT"></a>LLD_FLT</h4><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_FLT xreg, sreg, label</span><br></pre></td></tr></table></figure><br>When this macro completes, a float that lives at the specified local label will sit in the specified single precision register.</p><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><h3 id="Undoing-Stack-Pointer-Changes"><a href="#Undoing-Stack-Pointer-Changes" class="headerlink" title="Undoing Stack Pointer Changes"></a>Undoing Stack Pointer Changes</h3><p>A small tip concerning undoing changes to the stack pointer. You might think that changes to the stack made by str or stp and their cousins must be undone with ldr or ldp and their cousins.</p><p>This depends.</p><p>If you need to get back the original contents of a register pushed onto the stack, then an ldr or ldp is appropriate. However, if you don’t need to get the original contents of a register back, then it is faster to undo a change to the stack using addition.</p><p>Take for example the use of printf(). On Apple Silicon systems, you must send arguments to printf() by pushing them onto the stack. However, when printf() completes, you have no need for the values that you pushed. As shown above, simply add the right (multiple of 16) to the stack pointer. This is faster as the addition makes no reference to RAM (or caches) as the ldr would.</p><h3 id="other-stuff"><a href="#other-stuff" class="headerlink" title="other stuff"></a>other stuff</h3><h4 id="let-the-assembler-itself-calculate-the-length-for-you"><a href="#let-the-assembler-itself-calculate-the-length-for-you" class="headerlink" title="let the assembler itself calculate the length for you"></a>let the assembler itself calculate the length for you</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">        .global        main                                             </span><br><span class="line">        .align         2                                                </span><br><span class="line">        .text                                                           </span><br><span class="line">                                                                        </span><br><span class="line">main:   str            x30, [sp, -16]!                                  </span><br><span class="line">        mov            w0, 1             // stdout                      </span><br><span class="line">        ldr            x1, =s            // pointer to string           </span><br><span class="line">        ldr            x2, =ssize        // pointer to computed length  </span><br><span class="line">        ldr            w2, [x2]          // actual length of string     </span><br><span class="line">        bl             write                                            </span><br><span class="line">                                                                        </span><br><span class="line">        ldr            x0, =fmt                                         </span><br><span class="line">        ldr            x1, =s                                           </span><br><span class="line">        ldr            x2, =ssize                                       </span><br><span class="line">        ldr            w2, [x2]                                         </span><br><span class="line">        bl             printf                                           </span><br><span class="line">                                                                        </span><br><span class="line">        ldr            x30, [sp], 16                                    </span><br><span class="line">        mov            w0, wzr                                          </span><br><span class="line">        ret                                                             </span><br><span class="line">                                                                        </span><br><span class="line">        .data                                                           </span><br><span class="line">                                                                        </span><br><span class="line">s:      .asciz         &quot;Hello, World!\n&quot;                                </span><br><span class="line">ssize:  .word          ssize - s - 1        // accounts for null at end </span><br><span class="line">fmt:    .asciz         &quot;str: %slen: %d\n&quot;   // accounts for newline     </span><br><span class="line">                                                                        </span><br><span class="line">        .end                                                            </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="atomic-operations"><a href="#atomic-operations" class="headerlink" title="atomic operations"></a>atomic operations</h2><h3 id="Load-Linked-Store-Condition"><a href="#Load-Linked-Store-Condition" class="headerlink" title="Load Linked, Store Condition"></a>Load Linked, Store Condition</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        .text                                                 </span><br><span class="line">        .p2align    2                                         </span><br><span class="line">                                                              </span><br><span class="line">#if defined(__APPLE__)                                        </span><br><span class="line">        .global     _LoadLinkedStoreConditional               </span><br><span class="line">_LoadLinkedStoreConditional:                                  </span><br><span class="line">#else                                                         </span><br><span class="line">        .global     LoadLinkedStoreConditional                </span><br><span class="line">LoadLinkedStoreConditional:                                   </span><br><span class="line">#endif                                                        </span><br><span class="line">1:      ldaxr       w1, [x0]                                  </span><br><span class="line">        add         w1, w1, 1                                 </span><br><span class="line">        stlxr       w2, w1, [x0]                              </span><br><span class="line">        cbnz        w2, 1b                                    </span><br><span class="line">        ret                                                   </span><br></pre></td></tr></table></figure><p>LL/SC 是一种乐观并发控制机制。它大致逻辑是：</p><ul><li><p>Load-Linked（LDAXR）：加载一个地址的值，并“观察”该地址是否被改动。<br>你可以修改这个值（如加1）。</p></li><li><p>Store-Conditional（STLXR）：尝试写回这个新值，如果在这之间地址内容没有被别人改过，则写入成功；否则失败。<br>成功与否会通过 STLXR 的返回值告诉你（0 表示成功，非 0 表示失败）。</p></li></ul><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/llsc.png" alt="llsc"></p><p>Implementations of operations on atomic variables were improved in the second version of ARMv8, called ARMv8.1. The load linked and store conditional instructions are still available but several new instructions were added which perform certain operations such as addition, subtraction and various bitwise operations in a single atomic instruction.</p><p>For example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    mov       w1, 1</span><br><span class="line">    ldaddal   w1, w0, [x0]</span><br><span class="line">``</span><br><span class="line">does the same work of atomically adding one to the value in memory pointed to by x0.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### spin-lock</span><br><span class="line"></span><br><span class="line">Here is the source code to the spin-lock for ARM V8.</span><br><span class="line"></span><br><span class="line">Lock</span><br><span class="line"></span><br><span class="line">```asm</span><br><span class="line">Lock:                                                              </span><br><span class="line">        START_PROC                                                 </span><br><span class="line">        mov         w3, 1           // 准备存储的值：1 表示“加锁”  </span><br><span class="line">1:      ldaxr       w1, [x0]        // 原子加载并标记 exclusive 访问                      </span><br><span class="line">        cbnz        w1, 1b          // 如果锁不为 0（被别人持有），继续自旋           </span><br><span class="line">        stlxr       w2, w3, [x0]    // 尝试原子写入，成功则 w2=0                  </span><br><span class="line">        cbnz        w2, 1b          // 如果失败（有竞争），继续自旋</span><br><span class="line">        ret                                                        </span><br><span class="line">        END_PROC                                                   </span><br></pre></td></tr></table></figure><br>stlxr: 如果 exclusive tag 还有效（没人抢走锁），那么将 w3 的值写入 *x0，并将结果放入 w2（0 表示成功）</p><ol><li>ldaxr dereferencing the lock itself (once again an int32_t) and marks the location of the lock as being hopefully, exclusive.</li><li>Having gotten the value of the lock, its value is inspected and if found to be non-zero, we branch back to attempting to get it again - this is the spin.</li><li>If the contents of the lock is 0, its value in w1 is changed to non-zero. Note, this could be made a bit better if a value of 1 was stored in another w register and simply used directly on line 10.</li><li><code>stlxr w2, w3, [x0]</code> conditionally stores the changed value back to the location of the lock. If the stlxr returns 0, we got the lock. If not, we start over - somebody else got in there ahead of us. Perhaps this happened because we were descheduled. Perhaps we lost the lock to another thread running on a different core.</li></ol><p>unlock<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unlock:                                                           </span><br><span class="line">        START_PROC                                                </span><br><span class="line">        str         wzr, [x0]       // 写 0 表示释放锁                            </span><br><span class="line">        dmb         ish             // 内存屏障，跨核同步                    </span><br><span class="line">        ret                                              </span><br><span class="line">        END_PROC                       </span><br></pre></td></tr></table></figure></p><ol><li><p>All it does is set to value of the lock to zero. The correct operation of the lock requires that no bad actor simply stomps on the lock by calling Unlock without first owning the lock. Just say no to lock stompers.</p></li><li><p><code>dmb ish</code> sets up a data memory barrier across each processor - it makes sure threads running on different cores see the update correctly. This code seemed to work without this line but intuition suggests it could be important. In Lock() the stlxr instruction has an implied data memory barrier.</p></li></ol><p>总结（伪代码角度）<br>🔒 Lock(x0):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    w1 = *x0;      <span class="comment">// atomic exclusive load</span></span><br><span class="line">    <span class="keyword">if</span> (w1 != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    result = atomic_store_exclusive(x0, <span class="number">1</span>);  <span class="comment">// try to set lock</span></span><br><span class="line">&#125; <span class="keyword">while</span> (result != <span class="number">0</span>);  <span class="comment">// someone else beat us</span></span><br></pre></td></tr></table></figure><br>🔓 Unlock(x0):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*x0 = <span class="number">0</span>;       <span class="comment">// unlock</span></span><br><span class="line">dmb(ISH);      <span class="comment">// ensure all cores see the update</span></span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/pkivolowitz/asm_book">asm_book</a></div>]]></content>
      
      
      <categories>
          
          <category> arm64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SR-IOV原理与实现</title>
      <link href="/posts/42860/"/>
      <url>/posts/42860/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-05-22</p></div></div><div class='timeline-item-content'><ol><li>init</li></ol></div></div></div><hr><h1 id="I-O-虚拟化（IOV）"><a href="#I-O-虚拟化（IOV）" class="headerlink" title="I/O 虚拟化（IOV）"></a>I/O 虚拟化（IOV）</h1><p><strong>I/O 虚拟化（IOV）</strong> 是指多个虚拟机之间共享单一的 I/O 资源。实现 IOV 的方法包括：</p><ul><li><strong>纯软件实现</strong>的共享方式，</li><li><strong>硬件支持</strong>的共享方式，</li><li>以及 <strong>软硬结合的混合方式</strong>。</li></ul><h2 id="基于纯软件实现的共享"><a href="#基于纯软件实现的共享" class="headerlink" title="基于纯软件实现的共享"></a>基于纯软件实现的共享</h2><ol><li><strong>device emulation（完全虚拟化）</strong>：<br> 设备仿真模式会模仿那些被广泛支持的真实硬件设备（例如 Intel 的 1Gb 网卡），从而使虚拟机中的操作系统可以继续使用它原本就支持的驱动程序。虚拟机管理程序（VMM，Virtual Machine Monitor）会模拟这个 I/O 设备，以确保兼容性，并在实际 I/O 操作前处理这些操作，然后再把它们转发给实际的物理设备（这个物理设备可能和模拟的设备不一样）。<br> ⚠️ 问题：这样一来，I/O 操作就必须经过两层 I/O 栈——一层在虚拟机内部，另一层在虚拟机管理程序中，这会增加开销，降低性能。</li><li><strong>the split-driver model（半虚拟化）</strong>：<br> 这种方法和设备仿真类似，但它<strong>不再模拟一个传统设备</strong>。而是采用一种<strong>前后端驱动配合的方式</strong>：<ul><li>前端驱动运行在虚拟机的客户操作系统中；</li><li>后端驱动运行在虚拟机管理程序中。<br> 两者配合工作，专门为资源共享进行了优化。相比设备仿真，这种方法的优势在于：<strong>不需要模拟整个设备</strong>，从而性能更好、开销更小。后端驱动会直接与实际物理设备进行通信。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>device emulation</td><td>兼容性好，可使用现有驱动</td><td>性能较差，要经过两层 I/O 栈</td></tr><tr><td>the split-driver model</td><td>性能更好，优化了共享</td><td>需要专门为前后端编写驱动</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522224910146.png" alt="image-20250522224910146"></p><p><strong>基于软件的共享的缺点</strong></p><p>无论是<strong>设备仿真</strong>还是<strong>分离驱动（即半虚拟化驱动）</strong>，它们通常只能提供物理硬件功能的一部分，因此可能<strong>无法利用物理设备提供的高级功能</strong>。</p><p>此外，虚拟机管理程序（VMM）在实现一个虚拟的软件交换机（用于将数据包在多个虚拟机之间转发）时，可能会消耗<strong>大量的 CPU 资源</strong>。这种 CPU 开销会（而且通常确实会）<strong>降低 I/O 设备的最大吞吐量</strong>。</p><p>举个例子：如果只使用设备仿真方式，10Gbps 的以太网控制器<strong>最大只能达到 4.5 到 6.5Gbps 的吞吐量</strong>（这个范围依赖于具体测试服务器的架构）。<br>其中一个主要原因是：<strong>每个数据包都必须通过软件交换机</strong>，而这就需要使用 CPU 来处理这些数据包，造成性能瓶颈，无法达到线速（Line Rate）或接近线速的传输能力。</p><p>基于软件的 I/O 虚拟化方式虽然兼容性好，但也存在一些明显的<strong>性能瓶颈和功能限制</strong>，这些缺陷在对性能要求较高的场景（如高频交易、数据中心、网络功能虚拟化等）中尤其明显：</p><div class="table-container"><table><thead><tr><th>缺点</th><th>说明</th></tr></thead><tbody><tr><td>功能不完整</td><td>无法访问设备的全部高级特性，如硬件加速、QoS、SR-IOV等。</td></tr><tr><td>高 CPU 开销</td><td>每个 I/O 操作都需要 VMM 介入处理，特别是在网络场景下，包处理要通过软件交换机，会消耗大量 CPU。</td></tr><tr><td>吞吐量受限</td><td>理论 10Gbps 的网卡实际只有 4.5~6.5Gbps 的吞吐，远低于线速。</td></tr></tbody></table></div><h2 id="直接分配（Direct-Assignment）"><a href="#直接分配（Direct-Assignment）" class="headerlink" title="直接分配（Direct Assignment）"></a>直接分配（Direct Assignment）</h2><p>也称<strong>设备直通</strong></p><p>基于软件的共享方式在每次 I/O 操作中都增加了额外开销，因为在客户机驱动和 I/O 硬件之间存在一个<strong>仿真层</strong>。这种中间层的存在还带来了另一个影响：<strong>无法使用物理设备提供的硬件加速功能</strong>。<br> 为了解决这些问题，可以将物理硬件<strong>直接暴露给客户操作系统（Guest OS）</strong>，并让它运行<strong>原生设备驱动</strong>，从而减少中间层带来的性能损失。</p><p>硬件厂商（如Intel）为此引入了一些增强功能，用于<strong>支持内存地址转换</strong>并<strong>确保内存保护</strong>，使得设备能够<strong>直接进行主机内存的 DMA 操作</strong>。这些增强功能可以<strong>绕过虚拟机管理程序（VMM）的 I/O 仿真层</strong>，从而<strong>提升虚拟机的 I/O 吞吐性能</strong>。</p><p>Intel® VT-x 技术的一个特性是：如果由 VMM 进行配置，虚拟机可以<strong>直接访问物理地址</strong>。这样，虚拟机中的设备驱动就可以<strong>直接写入 I/O 设备的寄存器</strong>（例如配置 DMA 描述符等）。</p><p>而 Intel® VT-d 技术则提供了类似的能力，使 I/O 设备可以<strong>直接写入虚拟机的内存空间</strong>，例如进行 DMA 操作。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522230514903.png" alt="image-20250522230514903"></p><p>实现直接分配的机制<strong>在不同厂商之间有所差异</strong>，但其基本思路相同：虚拟机管理程序利用并配置诸如 Intel® VT-x 和 VT-d 这类技术，在数据收发过程中完成地址转换，确保数据可以安全、高效地在虚拟机与 I/O 设备之间传输。</p><p>✅ 优势：</p><ul><li><strong>绕过中间的仿真层</strong>，减少 CPU 开销；</li><li><strong>支持原生驱动</strong>，可以启用设备的全部功能（包括硬件加速）；</li><li><strong>大幅提升性能</strong>，尤其是吞吐量和延迟方面的改进明显；</li><li><strong>适合高性能场景</strong>，如网络功能虚拟化（NFV）、GPU 加速计算等。</li></ul><p>⚠️ 问题：</p><p>直接分配的一个主要问题是其<strong>可扩展性有限</strong>：一个物理设备<strong>只能分配给一个虚拟机</strong>。</p><blockquote><p>例如，一个双端口的网卡（NIC）只能同时提供给两个虚拟机使用（每个虚拟机占用一个端口）。然而，系统中可插入的 I/O 设备数量存在<strong>根本性的限制</strong>。</p></blockquote><p>设想一下不久将来的一个相对强大的服务器：<br> 它可能拥有 4 个物理 CPU，每个 CPU 有 12 个核心，总共有 48 个核心。按照“一核一虚拟机”的经验规则，这台服务器可能运行 <strong>48 个虚拟机</strong>。如果你希望为每个虚拟机都使用 Direct Assignment 的方式分配设备，就<strong>需要 48 个物理端口</strong>。</p><h1 id="单根-I-O-虚拟化（SR-IOV）"><a href="#单根-I-O-虚拟化（SR-IOV）" class="headerlink" title="单根 I/O 虚拟化（SR-IOV）"></a>单根 I/O 虚拟化（SR-IOV）</h1><blockquote><p>以上架构问题根源在于硬件底层原生不支持共享，需要一种新型的<strong>原生可共享设备</strong>（<strong>Navitely Shared Devices</strong>），这些设要能为每个虚拟机复制必要的资源，使得<strong>虚拟机可以直接连接到 I/O 设备</strong>，并且<strong>无需 VMM 参与</strong>即可完成主要的数据传输。</p></blockquote><p><strong>原生可共享设备</strong>通常会为每个虚拟接口提供<strong>独立的内存空间、工作队列、中断和命令处理机制</strong>，而在主机接口之后共享一些<strong>公共资源</strong>。这些共享资源仍然需要管理，通常会将一组管理寄存器暴露给 VMM 中的<strong>可信分区（Trusted Partition）</strong>，为每个虚拟机提供独立的工作队列和命令处理能力，这类设备能够<strong>同时接收多个来源的指令</strong>，并在发送给二级互连（如 Ethernet 或 SAS 链路）之前将其整合，而不再需要虚拟化软件将多个 I/O 请求串行化处理。</p><p>这种原生可共享设备可以通过多种方式实现，既有标准化的，也有专有的。由于大多数这类设备是通过 PCI 接口访问的，PCI-SIG（PCI Special Interest Group）决定制定一个标准机制来支持这一功能。</p><p>这个标准就是：<strong>PCI-SIG 单根 I/O 虚拟化和共享规范（SR-IOV，Single Root I/O Virtualization）</strong></p><p>SR-IOV 定义了一个标准机制，使设备能实现原生共享。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522231842281.png" alt="image-20250522231842281"></p><h2 id="PCI-SIG-SR-IOV-规范"><a href="#PCI-SIG-SR-IOV-规范" class="headerlink" title="PCI-SIG SR-IOV 规范"></a>PCI-SIG SR-IOV 规范</h2><p>PCI-SIG SR-IOV规范的目标可以总结为一句话：<strong>规范化一种绕过虚拟机管理程序（VMM）参与数据传输的方式</strong>，通过为每台虚拟机提供<strong>独立的内存空间、中断通道和 DMA 通道</strong>，以实现高效的 I/O 虚拟化。</p><p>SR-IOV 的体系结构设计允许一个设备支持多个<strong>虚拟功能（VF, Virtual Functions）</strong>，并在此过程中重点关注每个额外功能的硬件成本最小化。</p><p>SR-IOV 引入了两种新的 PCIe 功能类型：</p><ul><li><p><strong>物理功能（PF, Physical Functions）</strong>：<br> 完整的 PCIe 功能，包含 <strong>SR-IOV 扩展能力（Extended Capability）</strong>。该能力用于配置和管理 SR-IOV 的相关功能。</p></li><li><p><strong>虚拟功能（VF, Virtual Functions）</strong>：<br> 轻量级 PCIe 功能，包含完成数据传输所需的资源，但其<strong>配置资源经过精简设计</strong>，以降低硬件开销。</p></li></ul><p><strong>SR-IOV</strong> 提供了一种机制，使得一个单一的物理功能（例如一个以太网端口）<strong>可以表现为多个独立的“物理设备”</strong>。</p><p>一个支持 SR-IOV 的设备可以被配置（通常由 VMM 完成），使其在 <strong>PCI 配置空间</strong> 中<strong>呈现为多个功能（Function）</strong>，每个功能都拥有独立的 <strong>配置空间</strong>，包括自己的 <strong>基地址寄存器（BARs）</strong>。SR-IOV 设备可以配置为支持<strong>多个独立的虚拟功能（VF）</strong>，每个 VF 都有独立的 PCI 配置空间。VMM 会将这些 VF 分配给不同的虚拟机。</p><p>虚拟机管理程序（VMM）会将一个或多个虚拟功能（VF）分配给某个虚拟机，这个过程涉及将 VF 的真实配置空间<strong>映射为该 VM 所能看到的 PCI 配置空间</strong>。同时，诸如 Intel® VT-x 和 VT-d 之类的<strong>内存地址转换技术</strong>提供了<strong>硬件加速机制</strong>，可以使 DMA 数据直接在 VM 和设备之间传输，从而<strong>绕过 VMM 中的软件交换开销</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522233027661.png" alt="image-20250522233027661"></p><h2 id="生态系统依赖"><a href="#生态系统依赖" class="headerlink" title="生态系统依赖"></a>生态系统依赖</h2><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><ul><li>BIOS 在系统启动时负责分配 <strong>内存映射I/O（MMIO）空间</strong> 和 <strong>PCI Express总线号（Bus Numbers）</strong> 给主机桥（host bridges）。</li><li>许多系统中 PCI 资源分配缺乏标准化，软件依赖 BIOS 配置设备，确保有足够的内存空间和总线范围，支持主机桥下面的所有 I/O 设备。</li><li>需要增强 BIOS 的枚举代码，使其能识别 <strong>SR-IOV设备</strong>，并分配足够的 MMIO 空间给所有虚拟功能（Virtual Functions，VFs）。</li><li>具体如何解析 PCI 配置空间并计算 VF 所需最大 MMIO 空间，详见 PCI-SIG SR-IOV 规范。</li></ul><h3 id="虚拟机监控器（VMM）"><a href="#虚拟机监控器（VMM）" class="headerlink" title="虚拟机监控器（VMM）"></a>虚拟机监控器（VMM）</h3><ul><li>SR-IOV 定义了两种函数类型：<ul><li><strong>PF</strong>：完整的 PCIe 功能，包含 SR-IOV 扩展能力，用于管理和配置虚拟功能。</li><li><strong>VFs</strong>：轻量级的 PCIe 功能，包含仅用于数据传输的最小配置资源。</li></ul></li><li>SR-IOV 引入了一个新的软件实体：<strong>单根 PCI 配置管理器（Single Root PCI Configuration Manager, SR-PCIM 或 PCIM）</strong>。<ul><li>PCIM 负责管理和配置 VFs，处理所有对配置空间的访问请求。</li><li>它基于物理函数的信息，向虚拟机中的客户操作系统呈现完整的 PCI 配置模型。</li><li>PCIM 是一个概念模型，具体实现由各 VMM 厂商负责集成。</li></ul></li><li>Linux 内核自 2.6.30 版本（2009 年 6 月）开始支持 SR-IOV，多个发行版均已集成。</li></ul><h4 id="虚拟功能（VF）创建"><a href="#虚拟功能（VF）创建" class="headerlink" title="虚拟功能（VF）创建"></a>虚拟功能（VF）创建</h4><ul><li>在设备上电后，VFs 默认不存在，也无法访问其配置空间。</li><li>VFs 必须通过物理函数上的 SR-IOV 功能配置和启用后才能访问。</li><li>物理函数的 PCI 配置空间内有 SR-IOV 能力结构，其中包含一个 <strong>系统页大小字段（System Page Size）</strong>，由 VMM 设定为平台支持的大小。</li><li>所有 VF 的内存空间被连续映射在由 VF 基址寄存器（VF Base Address Register）指定的内存范围内。</li><li>为确保内存空间隔离，VF 的内存资源必须对齐到系统提供的页保护边界。</li><li>ARI（替代路由 ID 解释）能力标志会影响最大 VF 数量的分布，VMM 应启用根端口和交换机上的 ARI，并在 SR-IOV 能力中设置 ARI 能力层级位。BIOS 可能已预先启用 ARI。</li></ul><h4 id="VF-发现"><a href="#VF-发现" class="headerlink" title="VF 发现"></a>VF 发现</h4><ul><li>设置 VF 启用字段后，VFs 被创建并响应配置事务。</li><li>旧有的枚举软件不会自动发现这些 VF。</li><li>SR-IOV 引入一种新机制：通过物理函数中的 <strong>First VF Offset</strong> 和 <strong>VF Stride</strong> 字段形成链表，软件可定位与该物理函数关联的所有 VF。</li><li>SR-IOV 设备可能要求软件分配多个 PCI 总线号以支持超过 256 个功能。</li></ul><h4 id="VF-驱动与物理函数驱动通信支持"><a href="#VF-驱动与物理函数驱动通信支持" class="headerlink" title="VF 驱动与物理函数驱动通信支持"></a>VF 驱动与物理函数驱动通信支持</h4><ul><li>VMM 可以支持创建共享内存页，促进虚拟机中的 VF 驱动与主驱动（Master Driver）之间的通信（详细内容在第 6 节）。</li></ul><h4 id="VF-分配给虚拟机"><a href="#VF-分配给虚拟机" class="headerlink" title="VF 分配给虚拟机"></a>VF 分配给虚拟机</h4><ul><li>VFs 创建配置后，可被分配给虚拟机，实现虚拟机与硬件设备的直接 I/O 交互。</li><li>SR-IOV 设计假定设备上的所有 VF 是相同的，PCI 配置中均呈现相同的功能。</li><li>但通过主驱动介入分配，硬件可以根据系统管理员需求，提供不同的功能特性或性能等级（例如，为某些 VF 提供 2Gbps 的以太网性能保证）。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>BIOS 需要支持 SR-IOV 设备的识别和资源分配，尤其是 MMIO 和总线号管理。</li><li>VMM 引入 PCIM 模型管理 VFs，负责配置访问透明化和虚拟化资源管理。</li><li>VF 需要显式创建和启用，且支持大规模虚拟化场景（成百上千 VF）。</li><li>SR-IOV 支持高性能、低延迟的 I/O 直通，同时具备灵活的资源分配和管理能力。</li></ul><h2 id="主驱动程序（MD-Master-Driver）"><a href="#主驱动程序（MD-Master-Driver）" class="headerlink" title="主驱动程序（MD, Master Driver）"></a>主驱动程序（MD, Master Driver）</h2><p>主驱动（Master Driver，简称 MD；也称为物理功能驱动 PFD 或 PF Driver）是一个专门的驱动程序，用于管理 SR-IOV 设备的全局功能，并负责配置共享资源。MD 是特定于虚拟机监控器（VMM）的，运行在比一般虚拟机驱动更高权限的环境中。它包含了传统驱动的全部功能，以便 VMM 访问 I/O 资源；同时它还能执行影响整个设备的操作。</p><p>MD 必须在一个持续存在的环境中运行，在任何虚拟机驱动加载之前加载，并在所有虚拟机驱动卸载之后才能卸载。所有会影响整个设备的操作只能被 MD 接收和处理。</p><p>为了实现这种控制能力，虚拟机中的 VF 驱动需要与 MD 通信。比如，以太网设备的链路状态变化或最大传输单元（MTU）改变，就需要这种通信机制。VF 驱动通过通信通道询问链路状态时，MD 可以返回任意状态。当物理设备的 MTU 发生改变时，MD 可通知所有 VF 驱动，以便网络栈作出相应调整。</p><h3 id="VF-Drivers"><a href="#VF-Drivers" class="headerlink" title="VF Drivers"></a>VF Drivers</h3><p>VF 是“轻量级”的 PCIe 功能，只包含执行数据传输所必需的资源，它并不是一个完整的 PCIe 设备，仅提供数据进出机制。</p><p>VF 驱动运行于虚拟机中，应为半虚拟化驱动（即意识到它在虚拟化环境中），只能执行其允许的操作。通常，VF 具备发送/接收数据和执行自身复位的能力。该复位操作仅影响该 VF，而不会影响整个物理设备。超出其权限范围的操作需通过与 MD 通信实现。</p><p>VF 驱动是一个专门化驱动，它“知道”自身只能执行特定的功能，如配置 DMA 描述符、设置 MAC 地址、VLAN 标签等。每个 VF 都有在 I/O 设备中分配的独立资源。以太网 VF 通常具备独立的发送/接收队列，绑定到对应的 BAR（基地址寄存器）及描述符。</p><h3 id="VF-驱动与主驱动的通信"><a href="#VF-驱动与主驱动的通信" class="headerlink" title="VF 驱动与主驱动的通信"></a>VF 驱动与主驱动的通信</h3><p>设备共享的关键在于 VF 驱动能够与 MD 通信，请求那些影响全局的操作。这个通信通道需要传递消息并能生成中断。</p><p>SR-IOV 并未定义这一通信机制，因此需由主驱动、物理功能驱动和 VMM 设计者共同构建。最简单的方式是使用 VF 专属的设备内邮箱（mailbox）和门铃（doorbell）机制（Intel SR-IOV 网络控制器支持该方式）。目前，各家 VMM 厂商正在实现各自的通信机制，尚未形成统一标准。</p><h3 id="workflow-示例"><a href="#workflow-示例" class="headerlink" title="workflow 示例"></a>workflow 示例</h3><p>以下是一个接收以太网数据包并通过 VF 转发到虚拟机的典型流程：</p><ol><li>数据包到达 Intel® 网卡。</li><li>包被送入由主驱动配置的二层分类器（Layer 2 sorter）。</li><li>分类后，数据包进入目标 VF 的接收队列。</li><li>启动 DMA 操作，其目标地址由 VF 驱动配置的描述符决定。</li><li>DMA 到达芯片组。VMM 配置的 Intel® VT-d 将虚拟地址映射为主机物理地址，完成 DMA。</li><li>NIC 发出中断，VMM 捕获。</li><li>VMM 发出虚拟中断通知 VM 数据到达</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522234850850.png" alt="image-20250522234850850"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><p>平台必须支持地址转换（如 Intel® VT-d），才能使设备将数据 DMA 直接写入 VM 的内存。</p></li><li><p>BIOS 和 VMM 需能解析 PCI 配置空间，尤其是 SR-IOV 的 VF 定位机制。</p></li><li><p>VMM、PF 驱动、VF 驱动三者必须配合，为 VM 提供完整的 PCI 空间映射和 VF 操作能力。</p></li></ul><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h3><h4 id="PCI（Perpheral-Component-Interconnect）"><a href="#PCI（Perpheral-Component-Interconnect）" class="headerlink" title="PCI（Perpheral Component Interconnect）"></a>PCI（Perpheral Component Interconnect）</h4><p>PCI曾经是个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽。目前该总线已经逐渐被PCI Express总线所取代。PCI总线是由ISA(Industy Standard Architecture)总线发展而来的，是一种同步的独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPU的供应商和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传送。</p><p><strong>注：</strong>ISA并行总线有8位和16位两种模式，时钟频率为8MHz，工作频率为33MHz/66MHz。</p><p>PCI总线是一种树型结构，并且独立于CPU总线，可以和CPU总线并行操作。PCI总线上可以挂接PCI设备和PCI桥，PCI总线上只允许有一个PCI主设备（同一时刻），其他的均为PCI 从设备，而且读写操作只能在主从设备之间进行，从设备之间的数据交换需要通过主设备中转。</p><p><strong>注：</strong>这并不意味着所有的读写操作都需要通过北桥中转，因为PCI总线上的主设备和从设备属性是可以变化的。比如Ethernet和SCSI需要传输数据，可以通过一种叫做Peer-to-Peer的方式来完成，此时Ethernet或者SCSI则作为主机，其它的设备则为从机。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655222482740534418391.png" alt=""></p><p>一个典型的33MHz的PCI总线系统如上图所示，处理器通过<strong>FSB</strong>（<strong>Front Side Bus</strong>，前端总线，是早期计算机体系结构中，<strong>处理器（CPU）与北桥芯片之间通信的主要总线</strong>，用于连接 CPU 和内存控制器、显卡、PCI 总线等系统核心组件）与北桥相连接，北桥上挂载着图形加速器（显卡）、SDRAM（内存）和PCI总线。PCI总线上挂载着南桥、以太网、SCSI总线（一种老式的小型机总线）和若干个PCI插槽。CD和硬盘则通过IDE连接至南桥，音频设备以及打印机、鼠标和键盘等也连接至南桥，此外南桥还提供若干的USB接口。</p><p>PCI总线是一种共享总线，所以需要特定的<strong>仲裁器</strong>（<strong>Arbiter</strong>）来决定当前时刻的总线的控制权。一般该仲裁器位于北桥中，而仲裁器（主机）则通过一对引脚，<strong>REQ#</strong>（<strong>request</strong>） 和<strong>GNT#</strong> （<strong>grant</strong>）来与各个从机连接。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655215521250613180895.png" alt="image.png"></p><p>需要注意的是，并不是所有的设备都有能力成为仲裁器（Arbiter）或者initiator 。</p><p>最初的PCI总线的时钟频率为33MHz，但是随着版本的更新，时钟频率也逐渐的提高。但是由于PCI采用的是一种<strong>Reflected-Wave Signaling</strong>信号模型，导致了时钟频率越高，总线的最大负载越少。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655345775545777449405.png" alt="1000019445-6365655345775545777449405"></p><h3 id="Alternative-Routing-ID"><a href="#Alternative-Routing-ID" class="headerlink" title="Alternative Routing-ID"></a>Alternative Routing-ID</h3><h3 id="Address-Translation-Services（ATS）"><a href="#Address-Translation-Services（ATS）" class="headerlink" title="Address Translation Services（ATS）"></a>Address Translation Services（ATS）</h3><h4 id="Intel®-Virtualization-Technology-for-Directed-I-O-Intel®-VT-d"><a href="#Intel®-Virtualization-Technology-for-Directed-I-O-Intel®-VT-d" class="headerlink" title="Intel® Virtualization Technology for Directed I/O (Intel® VT-d)"></a>Intel® Virtualization Technology for Directed I/O (Intel® VT-d)</h4><h3 id="Access-Control-Services-ACS"><a href="#Access-Control-Services-ACS" class="headerlink" title="Access Control Services (ACS)"></a>Access Control Services (ACS)</h3>]]></content>
      
      
      <categories>
          
          <category> virtualization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RustDesk远程桌面自建服务器</title>
      <link href="/posts/42858/"/>
      <url>/posts/42858/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-14</p></div></div><div class='timeline-item-content'><p>  init</p></div></div></div><hr><p>ToDesk使用了几天后因为一直没关机，在当月中旬用完了所有额度，不让继续免费使用了，直接卸载告别切换到rustdesk，使用Self-host，免费而且帧率，分辨率都比ToDesk免费版高多了，下面是搭建的记录。</p><h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><p>我是使用两台windows(win10)和一台Ubuntu(配置如下图)，通过Ubuntu作为ID/中继服务器，让一台Windows连接到另一台Windows，Ubuntu需要安装Docker，两台windows需要安装rustdesk并进行一些配置。<br><div class="tip warning faa-horizontal animated"><p>注意：我的三台机器是在同一局域网下的。</p></div></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/pc_environment.png" alt="硬件环境"></p><h2 id="安装-Docker-和-docker-compose-plugin"><a href="#安装-Docker-和-docker-compose-plugin" class="headerlink" title="安装 Docker 和 docker-compose-plugin"></a>安装 Docker 和 docker-compose-plugin</h2><p>参考：<br>   <div class="tag link"><a class="link-card" title="Docker在Ubuntu安装" href="https://docs.docker.com/engine/install/ubuntu/"><div class="left"><img src="https://docs.docker.com/favicons/docs@2x.ico"/></div><div class="right"><p class="text">Docker在Ubuntu安装</p><p class="url">https://docs.docker.com/engine/install/ubuntu/</p></div></a></div><br>安装完成后，可以把当前用户加入到docker用户组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加docker用户组，一般已存在，不需要执行</span></span><br><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="comment"># 添加当前用户到docker用户组</span></span><br><span class="line"><span class="built_in">sudo</span> gpasswd -a <span class="variable">$USER</span> docker</span><br><span class="line"><span class="comment"># 更新用户组</span></span><br><span class="line">newgrp docker</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure></p><h2 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="headerlink" title="docker-compose.yaml"></a>docker-compose.yaml</h2><p>参考官方文档：<br>   <div class="tag link"><a class="link-card" title="RustDesk自建服务器" href="https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/docker/"><div class="left"><img src="https://rustdesk.com/docs/images/favicon.png"/></div><div class="right"><p class="text">RustDesk自建服务器</p><p class="url">https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/docker/</p></div></a></div></p><p>如果开启了ufw，需要打开这些端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw status</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 21114:21119/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 8000/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 21116/udp</span><br></pre></td></tr></table></figure><br>选一个目录用来存放ID/中继服务器数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/rustdesk</span><br><span class="line"><span class="built_in">cd</span> ~/rustdesk</span><br><span class="line"><span class="built_in">touch</span> docker-compose.yaml</span><br></pre></td></tr></table></figure><br>下面是docker-compose.yaml文件，是上面的rustdesk官方文档的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hbbs:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">hbbr:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><br>然后启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 进入~/rustdesk/data文件夹中</span></span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line"><span class="comment"># 查看key</span></span><br><span class="line"><span class="built_in">cat</span> id_*.pub</span><br></pre></td></tr></table></figure></p><h2 id="rustdesk安装配置"><a href="#rustdesk安装配置" class="headerlink" title="rustdesk安装配置"></a>rustdesk安装配置</h2><p>安装访问以下链接：<br><div class="tag link"><a class="link-card" title="RustDesk安装" href="https://github.com/rustdesk/rustdesk/releases"><div class="left"><img src="https://github.githubassets.com/favicons/favicon.png"/></div><div class="right"><p class="text">RustDesk安装</p><p class="url">https://github.com/rustdesk/rustdesk/releases</p></div></a></div><br>安装好后，打开网络设置，将ID/中继服务器的IP也就是跑Docker的那个服务器IP地址填写到ID服务器和中继服务器中，被控端可以不填写中继服务器，控制端建议填写，然后控制端填写key（上面data文件下的.pub文件的内容）。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250314214834213.png" alt="windows rustdesk网络配置"></p><p>最后输入被控端的ID和密码连接即可。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Data Lab</title>
      <link href="/posts/42856/"/>
      <url>/posts/42856/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-07</p></div></div><div class='timeline-item-content'><p>写到howManyBits</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-07</p></div></div><div class='timeline-item-content'><p>写完了，再一次感觉这个实验不错</p></div></div></div><hr><p>最近担任计算机系统助教要验收这个CSAPP的实验，这个实验本科的时候就做过，但过了这么久基本忘完了，遂重新做一遍记录于此。</p><h1 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h1><p>我是在win10 WSL2环境下做的：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250304165220672.png" alt="实验环境"></p><p>具体如何搭建环境参考下面这个链接，有脚本一键搭建运行环境，非常方便：<br><div class="tag link"><a class="link-card" title="CSAPP环境搭建" href="https://zhuanlan.zhihu.com/p/505497911"><div class="left"><img src="https://static.zhihu.com/heifetz/favicon.ico"/></div><div class="right"><p class="text">CSAPP环境搭建</p><p class="url">https://zhuanlan.zhihu.com/p/505497911</p></div></a></div></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在bits.c中完成函数实现，但对代码有一定的限制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测代码是否符合要求的规范</span></span><br><span class="line">./dlc bits.c</span><br><span class="line"><span class="comment"># 查看分数</span></span><br><span class="line">make clean </span><br><span class="line">make </span><br><span class="line">./btest</span><br></pre></td></tr></table></figure></p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要求只用~(按位取反)和&amp;(按位与)实现异或，可以使用离散数学中的等值演算，异或即“相同为0，不同为1”：</p><script type="math/tex; mode=display">x \oplus y = \lnot (\lnot x \land \lnot y) \land \lnot ( x \land y)</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ( ~(~x &amp; ~y)) &amp; (~(x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>返回最小的二进制补码整数，关于原码，反码，补码定义如下：</p><div class="table-container"><table><thead><tr><th>表示方法</th><th>定义</th></tr></thead><tbody><tr><td>原码</td><td>最高位为符号位（0 表示正数，1 表示负数），其余位表示数值的绝对值</td></tr><tr><td>反码</td><td>正数的反码与原码相同；负数的反码是符号位不变，其余位按位取反</td></tr><tr><td>补码</td><td>正数的补码与原码相同；负数的补码是其反码加 1</td></tr></tbody></table></div><p>补码的编码具有不对称性，除了最小的负数其他负数都其正数与之对应，在 64 位系统中，整数的补码表示范围是：</p><ul><li>最小负数：0x8000000000000000（即 -2^63）。</li><li>最大正数：0x7FFFFFFFFFFFFFFF（即 2^63 - 1）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果x是二进制补码最大值则返回1,否则返回0。</li><li>最大值是0x7FFFFFFF，它的特点是最高位为0其余为1，那么0x7FFFFFFF+0x1后变为0x800000000，最高位为1其余为0，其特点正好相反。</li><li>这里需要用到异或的特性，如x^target，x取反后与target异或，由于异或是不同为1相同为0，则只有当x与target完全相同时，x^target才会为0x0，那么加上!操作符就能得到!(x^target)即x与target相同时为1,不同时为0。<br>对于0x7FFFFFFF，它加1后为0x80000000，由于特点正好相反，取反后有变为0x7FFFFFFF,故可以利用异或判断是否相同即：!(~(x+1)^x) 。</li><li>继续思考，是不是只有0x7FFFFFFF才满足这样的特性：+1后相当于按位取反？显然0xFFFFFFFF也满足这个特性，这是因为溢出时最高位被丢弃变为0x0。所以我们还需要构造一个表达式与!(~(x+1)^x) 相与记为expression1，即!(~(x+1)^x) &amp; expression1。当x为0x7FFFFFFF时expression1为1，当x为0xFFFFFFFF时为0。</li><li>排除的方法必定需要利用0x7FFFFFFF有而0xFFFFFFFF没有的特点0，即这两个数的区别，而最简单的区别就是0x7FFFFFFF+0x1后变为0x8FFFFFFF是个非零数，而0xFFFFFFFF+0x1后变为0。故!(x+1)在x为0x7FFFFFFF时为0，在x为0xFFFFFFFF时为1，!(x+1)与需要的正好相反，再加上一个!运算即可，即：<p class='p center logo small'>!( ~(x + 1) ^ x) & !!(x + 1)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !( ~(x + <span class="number">1</span>) ^ x) &amp; !!(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果所有奇数位的比特位是1返回1，否则返回0，即一个数只要其1,3,5,7…位为1（其余位不用管）返回1，否则返回0。</li><li>我们可以去除所有的偶数位的影响，看奇数位，比如让x与0xAAAAAAAA相与，则所有的偶数位都为0，再看其是否和0xAAAAAAAA相同（利用isTmax中阐述的通过按位与判断两个数是否相同）。也可以让x与0x55555555相或，则所有的偶数位为1，再看其是否和0xFFFFFFFF相同。即：<p class='p center logo small'>!((x|0x55555555)^0xFFFFFFFF)</p><p class='p center logo small'>!((x&0xAAAAAAAA)^(0xAAAAAAAA))</p></li><li>但是由于实验要求的限制条件，不只直接写0xAAAAAAAA这种，只能写0xAA，通过位运算得到0xAAAAAAAA</li></ul><div class="tip warning faa-horizontal animated"><p>注意：根据C规范移位运算优先级低于加减</p></div><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250307163658185.png" alt="https://en.cppreference.com/w/c/language/operator_precedence"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// return !((x|0x55555555)^0xFFFFFFFF);</span></span><br><span class="line">  <span class="comment">// return !((x&amp;0xAAAAAAAA)^(0xAAAAAAAA));</span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>;<span class="comment">//0x00AA</span></span><br><span class="line">  <span class="type">int</span> b = a | <span class="number">0xAA</span>;<span class="comment">//0xAAAA</span></span><br><span class="line">  <span class="type">int</span> c = b&lt;&lt;<span class="number">16</span> | b;<span class="comment">//0xAAAAAAAA</span></span><br><span class="line">  <span class="keyword">return</span> !((x&amp;c)^c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>返回x的负数</li><li>我们知道：<p class='p center logo small'>x+(-x)=0</p><p class='p center logo small'>x+(~x)=-1</p></li><li>两式子相减得到：<p class='p center logo small'>-x=~x+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2>题目：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>检测x是否属于ascii的数字，简单来说是判断x是否在0x30和0x39之间。</li><li>在汇编中判断大小是通过减法置标志位来完成的，因此我们可以通过让0x30和0x39分别减去x再取符号位，看是否满足：0x30-x应该小于0符号位为1，0x39-x&gt;0符号位为0，但是若是x落在边界时,如x==0x30，0x30-x为0符号位为0也是满足要求的，因此我们可以把&lt;=变为&lt;：<p class='p center logo small'>0x30<= x <= 0x39</p>上式等价于：<p class='p center logo small'>0x2F< x <= 0x39</p>那么右边x<0x39是否需要等价转换?0x39-x应该大于或等于0，符号位为0，0x39-x<0符号位为1，经分析边界条件是囊括的所以不需要等价转换（转换后会把边界条件排出）。让0x2F-x符号位为1，0x39-x符号位为0，必须同时满足这两个条件，首先先看0x2F< x，相减后如何提取符号位？可以通过算数右移，移动31位符号位占满整个32位，即若0x2F-x<0，则(0x2F+(~x+1))>&gt;31为0xFFFFFFFF，若0x2F-x&gt;=0,(0x2F+(~x+1))&gt;&gt;31为0;<p class='p center logo small'>(0x2F+(~x+1))>>31</p>再看x &lt;= 0x39，同样的方法，若0x39-x<0，则(0x39+(~x+1))>&gt;31为0xFFFFFFFF，若0x39-x&gt;=0,(0x39+(~x+1))&gt;&gt;31为0;我们取个反就可以满足<p class='p center logo small'>~((0x39+(~x+1))>>31)</p>需要同时满足上述两个条件，故<p class='p center logo small'>(0x2F + (~x + 1)) >> 31 & ~((0x39 + (~x + 1)) >> 31)</p>由于最后返回1或0，我们取最低位即可：<p class='p center logo small'>(0x2F + (~x + 1)) >> 31 & ~((0x39 + (~x + 1)) >> 31) & 0x1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low = (<span class="number">0x2F</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;  <span class="comment">// 0x2F - x &lt; 0 =&gt; x &gt; 0x2F (即 x &gt;= 0x30)</span></span><br><span class="line">  <span class="type">int</span> high = ~((<span class="number">0x39</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>);  <span class="comment">// 0x39 - x &gt;= 0 =&gt; x &lt;= 0x39</span></span><br><span class="line">  <span class="keyword">return</span> low &amp; high &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>conditional的表达式和 x ? y : z 相同</li><li>要实现这种根据x的值判断返回y还是返回z，仅仅使用位运算非常难，因为虽然我们很容易判断x是否为0，但我们很难将x与yz同时关联起来，所以我们把希望留给加法运算，假设返回这样的式子：<p class='p center logo small'>a+y+z</p>当x!=0时，让a=-z=~z+1；当x==0时，让a=-y=~y+1就可以满足要求，但是这个要求同样难以满足，因为a既与y有关又与z有关，而a又由x是否为0来决定，因此我们考虑将a拆分：<p class='p center logo small'>b+c+y+z</p>当x为非0时，让b=0，c=-z=~z+1；当x为0时，让b=-y=~y+1，c=0。这样可以让b只与y有关，c只与z有关。<br>首先我们要判断x是否为0，这个不难，使用!运算即可，当x为非零则为0，当x为0则为1，我们首先关注b，!x==0时，b要为0，!x!=0时，b要为~z+1，显然与运算可以满足：<p class='p center logo small'>b = !x&(~y+1)</p>但是当!x!=0时，!x==1，而它与~z+1按位与只会留下最低位不一定是~z+1，因此我们需要让x!=0时得到0xFFFFFFFF，x==0时得到0，因此我们定义a：<p class='p center logo small'>a = ~(!x)+1</p>当x为0时,!x==1,~(!x)==0xFFFFFFFE,a==0xFFFFFFFF；当x为非零时，!x==0，~(!x)==0xFFFFFFFF，a==0，因此b的表达式应为<p class='p center logo small'>b = a&(~y+1)</p>再关注c，c的情况刚好与b相反，那么只需要给a再加一个~即可<p class='p center logo small'>c = ~a&(~z+1)</p>这里不用担心加法溢出问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = ~(!x)+<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = a&amp;(~y+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> c = ~a&amp;(~z+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> b+y+c+z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果x&lt;=y那么返回 1，否则返回0</li><li>比大小利用减法，让y-x如果y-x&gt;=0即符号位为0则返回1，如果y-x&lt;0即符号位为1则返回0，y-x=y+~x+1，然后右移31位后取符号位,我们需要一个取反操作以满足符号位为0返回1，符号位为1则返回0:<p class='p center logo small'>~((y+(~x+1))>>31) & 0x1</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~((y+(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>) &amp;<span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>实现!运算符，即对于!x，当x为0时返回1，当x为非0时返回0</li><li>0和非零最直观的区别就在与0的每一位都是0，而非零至少有一位为1，但因为我们无法利用循环移位操作来判断，故只能另辟蹊径</li><li>0的和非零的另一个不同特点在于0的负数还是0，即~0+1=0，而非零数的负数不是0，我们可以利用这点，看x的负数是否与它自己相同，前面我们用到过一个技巧通过异或来判断两数是否相同：这个表达式在x等于0时返回0，x等于非零时返回非零，但是这样等于没做<p class='p center logo small'>(~x+1)^x</p>我们可以利用另一点，非零数的负数和原来这个数的符号位肯定相反，一个必是1，一个必是0，而0的负数的符号位和0的符号位都是0，因此我们只需要将两者相与就能得到：非零时该表达式符号位为1，为0时该表达式符号位0<p class='p center logo small'>(~x+1)|x</p>接下来就是提取符号位了，顺便取个反，因为我们要求为0时返回1，为1时返回0，这个技巧我们在上面的题目用到过：即将其向右算数移位31位并取反，然后与0x1相与取最低位：<p class='p center logo small'>~(((~x+1)|x)>>31) & 0x1</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> ~(((~x+<span class="number">1</span>)|x)&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>返回以二进制补码的形式表示x需要几个比特数，其实就是看这个数的最高位1在第几位，然后加上1位符号位，这个问题有点难度，主要是有点难想到，下面是别人的实现方法。</li><li>这里用到二分法：<br>先考虑正数和0</li></ul><ol><li>高 16 位：检查高 16 位是否有 1，如果有，则至少需要 16 位。</li><li>高 8 位：在剩下的 16 位中，检查高 8 位是否有 1。</li><li>高 4 位：在剩下的 8 位中，检查高 4 位是否有 1。</li><li>高 2 位：在剩下的 4 位中，检查高 2 位是否有 1。</li><li>高 1 位：在剩下的 2 位中，检查高 1 位是否有 1。</li><li>最低位：最后剩下的 1 位。<br>最终，将所有部分的位数相加，并加 1（符号位）。</li></ol><ul><li>对负数的处理：<br>flag 是 x &gt;&gt; 31，即符号位。如果 x 是负数，flag 为 1；否则为 0。</li></ul><ol><li>如果 x 是负数（flag == 1），则 x 被取反：x = ~x。</li><li>如果 x 是非负数（flag == 0），则 x 保持不变。<br>负数的补码表示中，符号位和数值部分是混合在一起的。如果直接计算负数的有效位数，符号位会导致结果错误。例如：<br>-1 的补码是 11111111 11111111 11111111 11111111，如果直接计算位数，会得到 32 位，但实际上我们只关心其有效位数。<br>通过取反操作，负数的补码表示会被转换为正数，其二进制表示中的有效位数与原来的负数相同。例如：</li></ol><ul><li>-1 的补码是 11111111 11111111 11111111 11111111，取反后为 00000000 00000000 00000000 00000000，有效位数为 1。</li><li>-2 的补码是 11111111 11111111 11111111 11111110，取反后为 00000000 00000000 00000000 00000001，有效位数为 2。</li></ul><div class="tag link"><a class="link-card" title="howManyBits" href="https://zhuanlan.zhihu.com/p/559005736"><div class="left"><img src="https://static.zhihu.com/heifetz/favicon.ico"/></div><div class="right"><p class="text">howManyBits</p><p class="url">https://zhuanlan.zhihu.com/p/559005736</p></div></a></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> flag = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  x = (flag &amp; ~x) | (~flag &amp; x);  <span class="comment">// x符号位为0不变 ,x符号位为1按位取反</span></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>; </span><br><span class="line">  x &gt;&gt;= b16;  </span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x &gt;&gt;= b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x &gt;&gt;= b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x &gt;&gt;= b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x &gt;&gt;= b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b0 + b1 + b2 + b4 + b8 + b16 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>将一个单精度浮点数（float）乘以 2，并返回结果的二进制表示。函数的输入和输出都是 unsigned int 类型，但它们实际上表示的是单精度浮点数的二进制位模式，当输入是NaN时返回这个输入即可，另外，终于可以用if while了😭😭😭</p></li><li><p>先回顾下<strong>IEEE 754</strong>浮点数的知识：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-53-54.png" alt="IEEE 754的表示形式"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-54-47.png" alt="单精度float 双精度double"></p><p>对于IEEE 754表示的浮点数，一共有三种类别<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-12.png" alt="类别1：规格化数"></p><p>非规格化数用于表示接近零的极小数值，防止浮点下溢（Underflow），保证浮点运算的连续性。<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-34.png" alt="类别2：非规格化数"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-43.png" alt="类别3：特殊值"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_16-38-57.png" alt="IEEE 754 表示范围"></p><p>首先我们先提取符号位sign，尾数frac，阶码exp：<br><p class='p center logo small'>sign=uf>>31&0x1</p><br><p class='p center logo small'>frac=uf&0x7FFFFF</p><br><p class='p center logo small'>exp = (uf&0x7f800000)>>23</p></p><p>根据阶码判断这个浮点数是规格化数，非规格化数还是特殊情况中的哪一种<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123; </span><br><span class="line">  <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> sign=uf&gt;&gt;<span class="number">31</span>&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac=uf&amp;<span class="number">0x7FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span>)&#123;<span class="comment">//非规格化数，阶码为0，直接让frac乘以2即可</span></span><br><span class="line">    frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">0xFF</span>)&#123;<span class="comment">//特殊情况，非数</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">exp</span>++;<span class="comment">//乘2,相当于E+1,相当于</span></span><br><span class="line">    <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>用int表示输入的IEEE 754浮点数，如果超过表示范围则返回0x80000000u。</li><li>如果是非规格化数，直接返回0，如果是特殊情况直接返回0x80000000u</li><li>如果是规格化数，我们需要先判断是否超出int表示范围，int一共32位，一位表示符号位，最大表示2^31，最小表示-(2^31+1)，因此阶码E不能超过30（当E为31时左移E位会覆盖符号位）；当阶码E小于0时，说明是个小于1的数，直接返回0；又：</li><li>sign <strong>1位</strong></li><li>exp <strong>8位</strong></li><li>frac <strong>23位</strong></li></ul><script type="math/tex; mode=display">V = (-1)^{sign} \times 2^{exp - 127} \times (1 + frac)</script><p>我们可以可以看成<strong>1frac</strong>（第24位为1，第1~23位构成frac）而此时相当于由<strong>1.frac</strong>（整数部分位1，小数部分为frac）左移了23位，此时阶码为E，即要乘以E个2，也就是左移E位，所以，当E小于23时，应该右移（23-E）位以截断frac后面的(23-E)位；当E大于23时，由于此时相当于已经左移了23位，所以只需再左移(E-23)位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> sign = uf &gt;&gt; <span class="number">31</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac = uf &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>) &#123;  <span class="comment">// 特殊情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000u</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;  <span class="comment">// 非规格化数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                   <span class="comment">// 规格化数</span></span><br><span class="line">    <span class="type">int</span> E = <span class="built_in">exp</span> - <span class="number">127</span>;  <span class="comment">// 阶码，注意不要设置为unsigned</span></span><br><span class="line">    <span class="keyword">if</span> (E &gt;= <span class="number">31</span>) &#123;           <span class="comment">// 超范围</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000u</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(E&lt;<span class="number">0</span>)&#123;<span class="comment">//如果E&lt;0说明是个比1小的数，返回0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    frac = frac | (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);  <span class="comment">// 填上frac的1</span></span><br><span class="line">    <span class="keyword">if</span> (E &lt; <span class="number">23</span>) &#123;</span><br><span class="line">      frac = frac &gt;&gt; (<span class="number">23</span> - E);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      frac = frac &lt;&lt; (E - <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;<span class="comment">//根据符号位返回正负</span></span><br><span class="line">      <span class="keyword">return</span> frac;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -frac;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>计算2.0^x，并返回IEEE 754下的unsigned表示，如果结果太小，小到非规格化数都不能表示则返回0，如果结果太大返回+INF，很明显这题主要考察IEEE 754的表示范围。</li></ul><p>对于<strong>float单精度</strong></p><ul><li>符号位sign：1位</li><li>阶码exp: 8位</li><li>尾数frac：23位</li></ul><p><strong>表示范围</strong></p><ul><li><p>规格化数：阶码exp既不全为0，也不全为1，</p><script type="math/tex; mode=display">V = (-1)^S \times 2^E \times M = (-1)^{sign} \times 2^{exp - bias} \times (1 + frac)</script><p>exp范围为1~254,E=Exp-Bias=Exp-127，E的范围为-126&gt;=E&gt;=127;而对于frac，最小值为0，最大值为1-2^(-23),因此，不考虑S的情况下</p><script type="math/tex; mode=display">V_{max} =  (-1)^S \times 2^{127} \times (2-2^{-23}) = (-1)^S \times 2^{127} \times (2-2^{-23})</script><script type="math/tex; mode=display">V_{min} = (-1)^S \times 2^{-126} \times (1+0) = (-1)^S \times 2^{-126}</script></li><li><p>非规格化数：阶码全为0</p><script type="math/tex; mode=display">V = (-1)^S \times 2^E \times M = (-1)^{sign} \times 2^{1-Bias} \times (0 + frac)</script><p>阶码exp全为0,E=1-Bias=1-127=-126，因此：</p><script type="math/tex; mode=display">V = (-1)^{sign} \times 2^{- 126} \times (0 + frac)</script><p>对于frac来说，最小值为0，但能表示的最小非零是2^(-23),0~2^(-23)无法表示,最大值为1-2^(-23)，因此，当frac取0时，值为0，但要计算表示的最小非零时要令frac=2^(-23)，在不考虑S的情况下</p><script type="math/tex; mode=display">V_{max} =  (-1)^S \times 2^{-126} \times (0+1-2^{-23}) = (-1)^S \times 2^{-126} \times (1-2^{-23})</script><script type="math/tex; mode=display">V_{min} = (-1)^S \times 2^{-126} \times (0+2^{-23}) = (-1)^S \times 2^{-149}</script><ul><li>特殊值</li></ul></li></ul><ol><li>+infinity：exp所有位全为1，frac为0，S为0</li><li>-infinity：exp所有位全为1，frac为0，S为1</li><li>NaN：exp所有位全为1，frac不为0</li></ol><p>因此，经上述分析:</p><ul><li>当x&gt;127时返回+NaN</li><li>当-126&lt;=x&lt;=127时为规格化数</li><li>当 -149 &lt;= x &lt; -126时为非规格化数</li><li>当 x &lt; -149时，太小了无法表示返回0<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">127</span>) &#123;  <span class="comment">// 返回+infinity,S=0,exp=0xFF,frac=0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-126</span> &lt;= x &amp;&amp; x &lt;= <span class="number">127</span>) &#123;  <span class="comment">// 规格化数,exp=E+Bias=E+127</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-149</span> &lt;= x &amp;&amp; x &lt; <span class="number">-126</span>) &#123;  <span class="comment">// 非规格化数,exp=0,E=1-Bias=-126,2^(-126)*frac</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">23</span>-(-x<span class="number">-126</span>));<span class="comment">//E已经有了2^(-126),当frac为0x1时表示2^(-23),假设输入x为-127,则frac要为2^(-1),即1向左移动22位</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//x&lt; -149,太小了返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDK2获取Protocol总结</title>
      <link href="/posts/42855/"/>
      <url>/posts/42855/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-02-25</p></div></div><div class='timeline-item-content'><ol><li>添加了OpenProtocol,HandleProtocol,LocateProtocol,OpenProtocolInfomation,CloseProtocol</li></ol></div></div></div><hr><p>UefiSpec.h 中定义了Protocol相关的接口:<br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_HANDLE_PROTOCOL HandleProtocol;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_REGISTER_PROTOCOL_NOTIFY RegisterProtocolNotify;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_HANDLE LocateHandle;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_DEVICE_PATH LocateDevicePath;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_OPEN_PROTOCOL OpenProtocol;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_CLOSE_PROTOCOL CloseProtocol;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_OPEN_PROTOCOL_INFORMATION OpenProtocolInformation;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_PROTOCOLS_PER_HANDLE ProtocolsPerHandle;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_HANDLE_BUFFER LocateHandleBuffer;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_LOCATE_PROTOCOL LocateProtocol;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_INSTALL_PROTOCOL_INTERFACE InstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;</p>            </div></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// EFI Boot Services Table.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// The table header for the EFI Boot Services Table.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  EFI_TABLE_HEADER                              Hdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Task Priority Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_RAISE_TPL                                 RaiseTPL;</span><br><span class="line">  EFI_RESTORE_TPL                               RestoreTPL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Memory Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_ALLOCATE_PAGES                            AllocatePages;</span><br><span class="line">  EFI_FREE_PAGES                                FreePages;</span><br><span class="line">  EFI_GET_MEMORY_MAP                            GetMemoryMap;</span><br><span class="line">  EFI_ALLOCATE_POOL                             AllocatePool;</span><br><span class="line">  EFI_FREE_POOL                                 FreePool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Event &amp; Timer Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CREATE_EVENT                              CreateEvent;</span><br><span class="line">  EFI_SET_TIMER                                 SetTimer;</span><br><span class="line">  EFI_WAIT_FOR_EVENT                            WaitForEvent;</span><br><span class="line">  EFI_SIGNAL_EVENT                              SignalEvent;</span><br><span class="line">  EFI_CLOSE_EVENT                               CloseEvent;</span><br><span class="line">  EFI_CHECK_EVENT                               CheckEvent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Protocol Handler Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_INSTALL_PROTOCOL_INTERFACE                InstallProtocolInterface;</span><br><span class="line">  EFI_REINSTALL_PROTOCOL_INTERFACE              ReinstallProtocolInterface;</span><br><span class="line">  EFI_UNINSTALL_PROTOCOL_INTERFACE              UninstallProtocolInterface;</span><br><span class="line">  EFI_HANDLE_PROTOCOL                           HandleProtocol;</span><br><span class="line">  VOID                                          *Reserved;</span><br><span class="line">  EFI_REGISTER_PROTOCOL_NOTIFY                  RegisterProtocolNotify;</span><br><span class="line">  EFI_LOCATE_HANDLE                             LocateHandle;</span><br><span class="line">  EFI_LOCATE_DEVICE_PATH                        LocateDevicePath;</span><br><span class="line">  EFI_INSTALL_CONFIGURATION_TABLE               InstallConfigurationTable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Image Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_IMAGE_LOAD                                LoadImage;</span><br><span class="line">  EFI_IMAGE_START                               StartImage;</span><br><span class="line">  EFI_EXIT                                      Exit;</span><br><span class="line">  EFI_IMAGE_UNLOAD                              UnloadImage;</span><br><span class="line">  EFI_EXIT_BOOT_SERVICES                        ExitBootServices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Miscellaneous Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_GET_NEXT_MONOTONIC_COUNT                  GetNextMonotonicCount;</span><br><span class="line">  EFI_STALL                                     Stall;</span><br><span class="line">  EFI_SET_WATCHDOG_TIMER                        SetWatchdogTimer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// DriverSupport Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CONNECT_CONTROLLER                        ConnectController;</span><br><span class="line">  EFI_DISCONNECT_CONTROLLER                     DisconnectController;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Open and Close Protocol Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_OPEN_PROTOCOL                             OpenProtocol;</span><br><span class="line">  EFI_CLOSE_PROTOCOL                            CloseProtocol;</span><br><span class="line">  EFI_OPEN_PROTOCOL_INFORMATION                 OpenProtocolInformation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Library Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_PROTOCOLS_PER_HANDLE                      ProtocolsPerHandle;</span><br><span class="line">  EFI_LOCATE_HANDLE_BUFFER                      LocateHandleBuffer;</span><br><span class="line">  EFI_LOCATE_PROTOCOL                           LocateProtocol;</span><br><span class="line">  EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES      InstallMultipleProtocolInterfaces;</span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES    UninstallMultipleProtocolInterfaces;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 32-bit CRC Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CALCULATE_CRC32                           CalculateCrc32;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Miscellaneous Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_COPY_MEM                                  CopyMem;</span><br><span class="line">  EFI_SET_MEM                                   SetMem;</span><br><span class="line">  EFI_CREATE_EVENT_EX                           CreateEventEx;</span><br><span class="line">&#125; EFI_BOOT_SERVICES;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="OpenProtocol"><a href="#OpenProtocol" class="headerlink" title="OpenProtocol"></a>OpenProtocol</h1><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250207181806644.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250207182821554.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144030827.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144054460.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144113071.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144141665.png" alt="OpenProtocol"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MdePkg/Include/Uefi/UefiSpec.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL   0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_GET_PROTOCOL         0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_TEST_PROTOCOL        0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER  0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_DRIVER            0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_EXCLUSIVE            0x00000020</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Queries a handle to determine if it supports a specified protocol. If the protocol is supported by the</span></span><br><span class="line"><span class="comment">  handle, it opens the protocol on behalf of the calling agent.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle for the protocol interface that is being opened.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol</span></span><br><span class="line"><span class="comment">                                Interface is returned.</span></span><br><span class="line"><span class="comment">  @param[in]   AgentHandle      The handle of the agent that is opening the protocol interface</span></span><br><span class="line"><span class="comment">                                specified by Protocol and Interface.</span></span><br><span class="line"><span class="comment">  @param[in]   ControllerHandle If the agent that is opening a protocol is a driver that follows the</span></span><br><span class="line"><span class="comment">                                UEFI Driver Model, then this parameter is the controller handle</span></span><br><span class="line"><span class="comment">                                that requires the protocol interface. If the agent does not follow</span></span><br><span class="line"><span class="comment">                                the UEFI Driver Model, then this parameter is optional and may</span></span><br><span class="line"><span class="comment">                                be NULL.</span></span><br><span class="line"><span class="comment">  @param[in]   Attributes       The open mode of the protocol </span></span><br><span class="line"><span class="comment">  interface specified by Handle</span></span><br><span class="line"><span class="comment">                                and Protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           An item was added to the open list for the protocol interface, and the</span></span><br><span class="line"><span class="comment">                                protocol interface was returned in Interface.</span></span><br><span class="line"><span class="comment">  @retval EFI_UNSUPPORTED       Handle does not support Protocol.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.</span></span><br><span class="line"><span class="comment">  @retval EFI_ACCESS_DENIED     Required attributes can&#x27;t be supported in current environment.</span></span><br><span class="line"><span class="comment">  @retval EFI_ALREADY_STARTED   Item on the open list already has requierd attributes whose agent</span></span><br><span class="line"><span class="comment">                                handle is the same as AgentHandle.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_OPEN_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                  *Protocol,</span></span><br><span class="line"><span class="params">  OUT VOID                      **Interface  OPTIONAL,</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                AgentHandle,</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                ControllerHandle,</span></span><br><span class="line"><span class="params">  IN  UINT32                    Attributes</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Guid/FileInfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/BaseMemoryLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/CacheMaintenanceLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/MemoryAllocationLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SimpleFileSystem.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">ReadFileByName</span><span class="params">(IN CHAR16 *FileName, OUT UINT8 **FileData, OUT UINTN *FileSize)</span> &#123;</span><br><span class="line">  EFI_FILE_INFO *FileInfo;</span><br><span class="line">  UINTN FileInfoSize;</span><br><span class="line">  EFI_FILE_PROTOCOL *FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *SimpleFileSystem;</span><br><span class="line">  EFI_FILE_PROTOCOL *Root;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  UINTN HandleCount = <span class="number">0</span>;</span><br><span class="line">  UINTN HandleIndex = <span class="number">0</span>;</span><br><span class="line">  EFI_HANDLE *HandleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// find all handles of SimpleFileSystemProtocol</span></span><br><span class="line">  Status =</span><br><span class="line">      gBS-&gt;LocateHandleBuffer(ByProtocol, &amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line">                              <span class="literal">NULL</span>, &amp;HandleCount, &amp;HandleBuffer);</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR(Status) || HandleCount == <span class="number">0</span>) &#123;</span><br><span class="line">    Print(<span class="string">L&quot;Locate SimpleFileSystemProtocolHandle Buffer error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (HandleIndex = <span class="number">0</span>; HandleIndex &lt; HandleCount; HandleIndex++) &#123;</span><br><span class="line">    Status = gBS-&gt;OpenProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                               &amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line">                               (VOID **)&amp;SimpleFileSystem, gImageHandle, <span class="literal">NULL</span>,</span><br><span class="line">                               EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open SimpleFileSystemProtocol error,at HandleIndex %d&quot;</span>,</span><br><span class="line">            HandleIndex);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Status = SimpleFileSystem-&gt;OpenVolume(SimpleFileSystem, &amp;Root);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open Root Volume error at HandleIndex%d&quot;</span>, HandleIndex);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.打开文件，获取文件句柄FileHandle</span></span><br><span class="line">    Status = Root-&gt;Open(Root, &amp;FileHandle, FileName, EFI_FILE_MODE_READ, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((FileHandle == <span class="literal">NULL</span>) || (EFI_ERROR(Status))) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open file %s failed at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else find the target handle</span></span><br><span class="line">    Print(<span class="string">L&quot;FileHandle: 0x%p at HandleIndex%d\n&quot;</span>, FileHandle, HandleIndex);</span><br><span class="line">    <span class="comment">// 2.分配文件信息大小</span></span><br><span class="line">    FileInfoSize = <span class="keyword">sizeof</span>(EFI_FILE_INFO) + <span class="number">1024</span>;</span><br><span class="line">    FileInfo = AllocateZeroPool(FileInfoSize);</span><br><span class="line">    <span class="keyword">if</span> (FileInfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;can not allocate %d size for FineInfo at HandleIndex%d\n&quot;</span>,</span><br><span class="line">            FileInfoSize, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.打开文件信息</span></span><br><span class="line">    Status = FileHandle-&gt;GetInfo(FileHandle, &amp;gEfiFileInfoGuid, &amp;FileInfoSize,</span><br><span class="line">                                 FileInfo);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Get FileInfo failed at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Print(<span class="string">L&quot;FileInfo: 0x%p\n&quot;</span>, FileInfo);</span><br><span class="line">    <span class="comment">// 4.预先分配文件大小</span></span><br><span class="line">    *FileSize = (UINTN)FileInfo-&gt;FileSize + <span class="keyword">sizeof</span>(CHAR16);</span><br><span class="line">    *FileData = AllocateZeroPool(*FileSize);</span><br><span class="line">    <span class="keyword">if</span> (*FileData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;locate file data size %d failed at HandleIndex%d\n&quot;</span>, *FileSize,</span><br><span class="line">            HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Print(<span class="string">L&quot;size of %s is %d\n&quot;</span>, FileName, *FileSize);</span><br><span class="line">      Print(<span class="string">L&quot;FileData: 0x%p\n&quot;</span>, *FileData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.读取文件</span></span><br><span class="line">    Status = FileHandle-&gt;Read(FileHandle, FileSize, (VOID *)*FileData);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;open %s file failed at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">// gBS-&gt;FreePool((VOID *)FileData);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Print(<span class="string">L&quot;open %s file success at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    FileHandle-&gt;Close(FileHandle);</span><br><span class="line">    Print(<span class="string">L&quot;FileHandle is freed normally at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">    Print(<span class="string">L&quot;FileInfo is freed normally at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    Root-&gt;Close(Root);</span><br><span class="line">    gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                       &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">    Print(<span class="string">L&quot;Operation Success at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HandleBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    gBS-&gt;FreePool(HandleBuffer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="HandleProtocol"><a href="#HandleProtocol" class="headerlink" title="HandleProtocol"></a>HandleProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250201214538747.png" alt="HandleProtocol的原型"></p><p>相比于OpenProtocol，不需要指定参数AgentHandle,ControllerHandle和Attributes</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Queries a handle to determine if it supports a specified protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle being queried.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol</span></span><br><span class="line"><span class="comment">                                Interface is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The interface information for the specified protocol was returned.</span></span><br><span class="line"><span class="comment">  @retval EFI_UNSUPPORTED       The device does not support the specified protocol.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Protocol is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Interface is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_HANDLE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE               Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                 *Protocol,</span></span><br><span class="line"><span class="params">  OUT VOID                     **Interface</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/DevicePathLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/LoadedImage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS EFIAPI <span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="params">                           IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  EFI_LOADED_IMAGE_PROTOCOL *LoadedImage;</span><br><span class="line">  Status = gBS-&gt;HandleProtocol(ImageHandle, &amp;gEfiLoadedImageProtocolGuid,</span><br><span class="line">                               (VOID **)&amp;LoadedImage);</span><br><span class="line">  <span class="keyword">if</span> (Status == EFI_SUCCESS) &#123;</span><br><span class="line">    EFI_DEVICE_PATH_PROTOCOL *DevicePath;</span><br><span class="line">    Status =</span><br><span class="line">        gBS-&gt;HandleProtocol(ImageHandle, &amp;gEfiLoadedImageDevicePathProtocolGuid,</span><br><span class="line">                            (VOID **)&amp;DevicePath);</span><br><span class="line">    <span class="keyword">if</span>(Status == EFI_SUCCESS)&#123;</span><br><span class="line">      Print(<span class="string">L&quot;Image device: %s\n&quot;</span>,ConvertDevicePathToText(DevicePath,FALSE,TRUE));</span><br><span class="line">      Print(<span class="string">L&quot;Image file: %s\n&quot;</span>, ConvertDevicePathToText(LoadedImage-&gt;FilePath,FALSE,TRUE));</span><br><span class="line">      Print(<span class="string">L&quot;Image Base: %X\n&quot;</span>,LoadedImage-&gt;ImageBase);</span><br><span class="line">      Print(<span class="string">L&quot;Image Size: %X\n&quot;</span>,LoadedImage-&gt;ImageSize);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      Print(<span class="string">L&quot;Can&#x27;t get EFI_LOADED_IMAGE_PROTOCOL, Status=%r\n&quot;</span>,Status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Print(<span class="string">L&quot;Can&#x27;t get EFI_DEVICE_PATH_PROTOCOL, Status=%r\n&quot;</span>,Status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="ProtocolsPerHandle"><a href="#ProtocolsPerHandle" class="headerlink" title="ProtocolsPerHandle"></a>ProtocolsPerHandle</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250202231208653.png" alt="ProtocolsPerHandle"></p><p>通过Protocol GUID检索安装在设备句柄上的接口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Retrieves the list of protocol interface GUIDs that are installed on a handle in a buffer allocated</span></span><br><span class="line"><span class="comment">  from pool.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle              The handle from which to retrieve the list of protocol interface</span></span><br><span class="line"><span class="comment">                                   GUIDs.</span></span><br><span class="line"><span class="comment">  @param[out]  ProtocolBuffer      A pointer to the list of protocol interface GUID pointers that are</span></span><br><span class="line"><span class="comment">                                   installed on Handle.</span></span><br><span class="line"><span class="comment">  @param[out]  ProtocolBufferCount A pointer to the number of GUID pointers present in</span></span><br><span class="line"><span class="comment">                                   ProtocolBuffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The list of protocol interface GUIDs installed on Handle was returned in</span></span><br><span class="line"><span class="comment">                                ProtocolBuffer. The number of protocol interface GUIDs was</span></span><br><span class="line"><span class="comment">                                returned in ProtocolBufferCount.</span></span><br><span class="line"><span class="comment">  @retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the results.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is not a valid EFI_HANDLE.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER ProtocolBuffer is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER ProtocolBufferCount is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_PROTOCOLS_PER_HANDLE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE      Handle,</span></span><br><span class="line"><span class="params">  OUT EFI_GUID        ***ProtocolBuffer,</span></span><br><span class="line"><span class="params">  OUT UINTN           *ProtocolBufferCount</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>例子:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/MemoryAllocationLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  Print(<span class="string">L&quot;_______________\n&quot;</span>);</span><br><span class="line">  EFI_GUID **ProtocolGuidArray;</span><br><span class="line">  UINTN ArrayCount;</span><br><span class="line">  EFI_STATUS Status = gBS-&gt;ProtocolsPerHandle(ImageHandle,&amp;ProtocolGuidArray,&amp;ArrayCount);</span><br><span class="line">  <span class="keyword">if</span>(Status==EFI_SUCCESS)&#123;</span><br><span class="line">    <span class="keyword">for</span>(UINTN i =<span class="number">0</span>;i&lt;ArrayCount;i++)&#123;</span><br><span class="line">      Print(<span class="string">L&quot;%g\n&quot;</span>,ProtocolGuidArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    FreePool(ProtocolGuidArray);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Print(<span class="string">L&quot;ProtocolsPerHandle error: %r\n&quot;</span>,Status);<span class="comment">//%r打印EFI_STATUS错误码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="LocateProtocol"><a href="#LocateProtocol" class="headerlink" title="LocateProtocol"></a>LocateProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225140716252.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225141031426.png" alt="LocateProtocol"></p><p>与HandleProtocol和OpenProtocol不同，LocateProtocol不关心Protocol在哪个设备上，它会在系统中顺序寻找句柄列表，返回找到的第一个Protocol实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Returns the first protocol instance that matches the given protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]  Protocol          Provides the protocol to search for.</span></span><br><span class="line"><span class="comment">  @param[in]  Registration      Optional registration key returned from</span></span><br><span class="line"><span class="comment">                                RegisterProtocolNotify().</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        On return, a pointer to the first interface that matches Protocol and</span></span><br><span class="line"><span class="comment">                                Registration.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           A protocol instance matching Protocol was found and returned in</span></span><br><span class="line"><span class="comment">                                Interface.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         No protocol instances were found that match Protocol and</span></span><br><span class="line"><span class="comment">                                Registration.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Interface is NULL.</span></span><br><span class="line"><span class="comment">                                Protocol is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_LOCATE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_GUID  *Protocol,</span></span><br><span class="line"><span class="params">  IN  VOID      *Registration  OPTIONAL,</span></span><br><span class="line"><span class="params">  OUT VOID      **Interface</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">LoadFileByName</span><span class="params">(</span></span><br><span class="line"><span class="params">IN CHAR16 *FileName,</span></span><br><span class="line"><span class="params">OUT UINT8 **FileData,</span></span><br><span class="line"><span class="params">OUT UINTN *FileSize)</span></span><br><span class="line">&#123;</span><br><span class="line">EFI_STATUS Status;</span><br><span class="line">EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *SimpleFileSystem;</span><br><span class="line">EFI_FILE_PROTOCOL *Root;</span><br><span class="line">EFI_FILE_PROTOCOL *FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">EFI_FILE_INFO *FileInfo;</span><br><span class="line">UINTN FileInfoSize;</span><br><span class="line">UINTN TempBufferSize;</span><br><span class="line">VOID *TempBuffer;</span><br><span class="line"></span><br><span class="line">Status = gBS-&gt;LocateProtocol(&amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line"> <span class="literal">NULL</span>, (VOID **)&amp;SimpleFileSystem);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Open the root directory</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = SimpleFileSystem-&gt;OpenVolume(SimpleFileSystem, &amp;Root);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Open the file</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = Root-&gt;Open(Root, &amp;FileHandle, FileName,</span><br><span class="line">EFI_FILE_MODE_READ, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ((FileHandle == <span class="literal">NULL</span>) || (EFI_ERROR(Status)))</span><br><span class="line">&#123;</span><br><span class="line">Print(<span class="string">L&quot;Open file %s failed !!\n&quot;</span>, FileName);</span><br><span class="line">Root-&gt;Close(Root);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get the file information</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">FileInfoSize = <span class="keyword">sizeof</span>(EFI_FILE_INFO) + <span class="number">1024</span>;</span><br><span class="line">FileInfo = AllocateZeroPool(FileInfoSize);</span><br><span class="line"><span class="keyword">if</span> (FileInfo == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status = FileHandle-&gt;GetInfo(FileHandle, &amp;gEfiFileInfoGuid,</span><br><span class="line"> &amp;FileInfoSize,</span><br><span class="line"> FileInfo);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate buffer for the file data. The last CHAR16 is for L&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">TempBufferSize = (UINTN)FileInfo-&gt;FileSize + <span class="keyword">sizeof</span>(CHAR16);</span><br><span class="line">TempBuffer = AllocateZeroPool(TempBufferSize);</span><br><span class="line"><span class="keyword">if</span> (TempBuffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Read the file data to the buffer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = FileHandle-&gt;Read(FileHandle, &amp;TempBufferSize, TempBuffer);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(TempBuffer);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line"></span><br><span class="line">*FileSize = TempBufferSize;</span><br><span class="line">*FileData = TempBuffer;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="OpenProtocolInformation"><a href="#OpenProtocolInformation" class="headerlink" title="OpenProtocolInformation"></a>OpenProtocolInformation</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225141817128.png" alt="OpenProtocolInformation"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// EFI Oprn Protocol Information Entry</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_HANDLE    AgentHandle;</span><br><span class="line">  EFI_HANDLE    ControllerHandle;</span><br><span class="line">  UINT32        Attributes;</span><br><span class="line">  UINT32        OpenCount;</span><br><span class="line">&#125; EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Retrieves the list of agents that currently have a protocol interface opened.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle for the protocol interface that is being queried.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  EntryBuffer      A pointer to a buffer of open protocol information in the form of</span></span><br><span class="line"><span class="comment">                                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY structures.</span></span><br><span class="line"><span class="comment">  @param[out]  EntryCount       A pointer to the number of entries in EntryBuffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The open protocol information was returned in EntryBuffer, and the</span></span><br><span class="line"><span class="comment">                                number of entries was returned EntryCount.</span></span><br><span class="line"><span class="comment">  @retval EFI_OUT_OF_RESOURCES  There are not enough resources available to allocate EntryBuffer.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         Handle does not support the protocol specified by Protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                          Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                            *Protocol,</span></span><br><span class="line"><span class="params">  OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,</span></span><br><span class="line"><span class="params">  OUT UINTN                               *EntryCount</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="CloseProtocol"><a href="#CloseProtocol" class="headerlink" title="CloseProtocol"></a>CloseProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225142227191.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225142316837.png" alt="CloseProtocol"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Closes a protocol on a handle that was opened using OpenProtocol().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]  Handle            The handle for the protocol interface that was previously opened</span></span><br><span class="line"><span class="comment">                                with OpenProtocol(), and is now being closed.</span></span><br><span class="line"><span class="comment">  @param[in]  Protocol          The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[in]  AgentHandle       The handle of the agent that is closing the protocol interface.</span></span><br><span class="line"><span class="comment">  @param[in]  ControllerHandle  If the agent that opened a protocol is a driver that follows the</span></span><br><span class="line"><span class="comment">                                UEFI Driver Model, then this parameter is the controller handle</span></span><br><span class="line"><span class="comment">                                that required the protocol interface.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The protocol instance was closed.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER 1) Handle is NULL.</span></span><br><span class="line"><span class="comment">                                2) AgentHandle is NULL.</span></span><br><span class="line"><span class="comment">                                3) ControllerHandle is not NULL and ControllerHandle is not a valid EFI_HANDLE.</span></span><br><span class="line"><span class="comment">                                4) Protocol is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         1) Handle does not support the protocol specified by Protocol.</span></span><br><span class="line"><span class="comment">                                2) The protocol interface specified by Handle and Protocol is not</span></span><br><span class="line"><span class="comment">                                   currently open by AgentHandle and ControllerHandle.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_CLOSE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               Handle,</span></span><br><span class="line"><span class="params">  IN EFI_GUID                 *Protocol,</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               AgentHandle,</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               ControllerHandle</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UEFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UEFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil安装</title>
      <link href="/posts/28522/"/>
      <url>/posts/28522/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-01-31</p></div></div><div class='timeline-item-content'><p>init</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-08-07</p></div></div><div class='timeline-item-content'><p>add tip warning</p></div></div></div><hr><div class="tip warning faa-horizontal animated"><p>最新的用下面的方法已经不行了，v6 版本的 ARMCC 可以正常使用，但 v5 版本提示没有 license</p></div><h1 id="C51-安装"><a href="#C51-安装" class="headerlink" title="C51 安装"></a>C51 安装</h1><p>1.首先进入官网点击下载 C51</p><div class="tag link"><a class="link-card" title="Keil下载" href="https://www.keil.com/download/product/"><div class="left"><img src="https://www.keil.com/images/icons/c51_dld.png"/></div><div class="right"><p class="text">Keil下载</p><p class="url">https://www.keil.com/download/product/</p></div></a></div><p>这里会要求填一个表单，简单填一下就好，然后点击下载的 exe 安装包进行安装</p><p>2.进入安装后一路确认，在选择安装位置这里我选择安装到 D 盘而不是默认的 C 盘。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131193502978.png" alt="C51安装位置"></p><p>3.最后点击 Finish 安装成功</p><h1 id="MDK-安装"><a href="#MDK-安装" class="headerlink" title="MDK 安装"></a>MDK 安装</h1><p>Keil 的 MDK 和 C51 这两个软件可以共存，安装步骤类似。</p><p>1.首先还是访问官网下载 MDK 的安装包<br><div class="tag link"><a class="link-card" title="Keil下载" href="https://www.keil.com/download/product/"><div class="left"><img src="https://www.keil.com/images/icons/mdk_dld_v2.png"/></div><div class="right"><p class="text">Keil下载</p><p class="url">https://www.keil.com/download/product/</p></div></a></div></p><p>2.进入安装后，安装位置这样填，根据 C51 的安装位置更改<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131194740287.png" alt="MDK安装位置"></p><p>3.最后点击 Finish 安装成功</p><div class="tip warning faa-horizontal animated"><p>注意：C51 和 MDK 的安装顺序不要反了</p></div><h1 id="v5-编译器"><a href="#v5-编译器" class="headerlink" title="v5 编译器"></a>v5 编译器</h1><p>首先下载 v5 编译器，因为现在官方好像不提供直接下载的渠道了，所以只能下载之前版本的 Keil 提取出 v5 版本的编译器，这里有已经提取出来的编译器可以直接下载</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">夸克网盘</button><button type="button" class="tab">百度网盘</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="tag link"><a class="link-card" title="v5编译器下载" href="https://pan.quark.cn/s/cd646c8d5b2b"><div class="left"><img src="https://image.quark.cn/s/uae/g/3o/broccoli/resource/202404/d94d93e0-03a2-11ef-be4c-79ebae2e18ac.vnd.microsoft.icon"/></div><div class="right"><p class="text">v5编译器下载</p><p class="url">https://pan.quark.cn/s/cd646c8d5b2b</p></div></a></div></div><div class="tab-item-content"><div class="tag link"><a class="link-card" title="v5编译器下载" href="https://pan.baidu.com/s/1zkUcPyKC5Z-Qda9jJb1Sjw?pwd=1234"><div class="left"><img src="https://nd-static.bdstatic.com/m-static/v20-main/favicon-main.ico"/></div><div class="right"><p class="text">v5编译器下载</p><p class="url">https://pan.baidu.com/s/1zkUcPyKC5Z-Qda9jJb1Sjw?pwd=1234</p></div></a></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>下载后解压到 D:\Keil_v5\ARM 目录下</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131200906926.png" alt="编译器解压目录"></p><p>打开 Keil，随便新建一个工程，然后点击这个按钮<strong>File Extensions, Books and Environment…</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201214187.png" alt="File Extensions, Books and Environment..."></p><p>然后点击<strong>Folder/Extensions</strong>，点击<strong>Use ARM Compiler</strong>旁边的这个按钮</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201435417.png" alt="Use ARM Compiler"></p><p>点击下面的<strong>Add another ARM Compiler Version to List</strong>, 选择刚才解压的 ARMCC 路径</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201751844.png" alt="Add another ARM Compiler Version to List"></p><p>保存后至此成功</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://zhuanlan.zhihu.com/p/561047339">MDK5.37不预安装Compiler Version5解决办法</a></div>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedded tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Emacs配置</title>
      <link href="/posts/28521/"/>
      <url>/posts/28521/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-01-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>使用 Windows Terminal + WSL2</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo//202508021037505.png" alt="WSL2 Arch Linux"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h2><p>Windows Terminal 中打开设置，选择打开 JSON 文件，在 schemes 中添加配色方案</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;schemes&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#0D1117&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;black&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#484F58&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;blue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#58A6FF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightBlack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#6E7681&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightBlue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#79C0FF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightCyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#56D4DD&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightGreen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#56D364&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightPurple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#D2A8FF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightRed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFA198&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightWhite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFFFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightYellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E3B341&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#2F81F7&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#39C5CF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E6EDF3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;green&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#3FB950&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GitHub-Dark-Default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;purple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#BC8CFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;red&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FF7B72&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;selectionBackground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E6EDF3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;white&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#B1BAC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;yellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#D29922&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 archlinux 的配置中选择 外观 选项卡<ul><li>配色方案选择 GitHub-Dark-Default</li><li>字体选择 FiraCode Nerd Font</li><li>背景不透明度 86%，选择启用亚克力材料</li></ul></li><li>在 archlinux 的配置中选择 高级 选项卡<ul><li>铃声通知样式取消勾选声音，选择闪烁窗口和闪烁任务栏</li></ul></li><li>安装 win32yank.exe 放入 C:\Winodws\System32 里</li></ul><h2 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h2><p>archlinux 需要下载一些软件包</p><p>下载 yay 参考</p><div class="tag link"><a class="link-card" title="archlinux安装yay" href="https://wiki.archlinuxcn.org/wiki/Yay"><div class="left"><img src="https://wiki.archlinuxcn.org/wzh/images/logo.svg"/></div><div class="right"><p class="text">archlinux安装yay</p><p class="url">https://wiki.archlinuxcn.org/wiki/Yay</p></div></a></div><p>注意下载后最好对 pacman 和 yay 进行换源，否则速度巨慢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/locale.gen</span><br><span class="line"><span class="comment"># 找到#en_US.UTF-8 UTF-8解除注释</span></span><br><span class="line"><span class="built_in">sudo</span> locale-gen</span><br><span class="line"><span class="built_in">sudo</span> pacman -Sy emacs-nox</span><br><span class="line"><span class="built_in">sudo</span> pacman -Sy clang rust-analyzer nvm ripgrep bear</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /usr/share/nvm/init-nvm.sh</span><br><span class="line">nvm list-remote</span><br><span class="line">nvm install v20.19.4</span><br><span class="line">nvm use v20.19.4</span><br><span class="line"><span class="comment"># npm换源</span></span><br><span class="line">npm i -g pyright bash-language-server</span><br><span class="line"></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"><span class="built_in">rm</span> ~/.cargo/bin/rust-analyzer</span><br><span class="line"><span class="built_in">ln</span> -s /usr/bin/rust-analyzer ~/.cargo/bin/rust-analyzer</span><br><span class="line"></span><br><span class="line">cargo install --git https://github.com/bergercookie/asm-lsp asm-lsp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件，也可以用默认配置</span></span><br><span class="line">asm-lsp gen-config</span><br><span class="line"><span class="comment"># 将FiraCode Nerd Font的ttf文件拷贝到 ~/.local/share/fonts/</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sebastiencs/icons-in-terminal.git</span><br><span class="line">./install.sh</span><br><span class="line"><span class="comment"># then Follow the instructions to edit ~/.config/fontconfig/conf.d/30-icons.conf</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> pacman -S exa</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias ll=&quot;ls -alF&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias ls=&quot;exa --icons&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Emacs-配置"><a href="#Emacs-配置" class="headerlink" title="Emacs 配置"></a>Emacs 配置</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;不显示menu-bar</span></span><br><span class="line">(<span class="name">menu-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line"><span class="comment">;;显示行号</span></span><br><span class="line">(<span class="name">global-display-line-numbers-mode</span> <span class="literal">t</span>)</span><br><span class="line"><span class="comment">;;在ModeLine显示列号</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;prog-mode-hook &#x27;column-number-mode)</span><br><span class="line"><span class="comment">;;代码的折叠</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;prog-mode-hook &#x27;hs-minor-mode)</span><br><span class="line"><span class="comment">;; 自动重载更改的文件</span></span><br><span class="line">(<span class="name">global-auto-revert-mode</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;;开启可视化换行，自动折行</span></span><br><span class="line">(<span class="name">global-visual-line-mode</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;; 括号匹配</span></span><br><span class="line">(<span class="name">electric-pair-mode</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;; 自动缩进</span></span><br><span class="line">(<span class="name">electric-indent-mode</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 中文显示</span></span><br><span class="line">(<span class="name">set-language-environment</span> <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">(<span class="name">set-buffer-file-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-terminal-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-keyboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-selection-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-default-coding-systems</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-clipboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">modify-coding-system-alist</span> &#x27;process <span class="string">&quot;*&quot;</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">prefer-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">setq-default</span> pathname-coding-system &#x27;utf-8)</span><br><span class="line">(<span class="name">setq</span> default-process-coding-system &#x27;(utf-8 . utf-8)</span><br><span class="line">      locale-coding-system &#x27;utf-8</span><br><span class="line">      file-name-coding-system &#x27;utf-8</span><br><span class="line">      default-buffer-file-coding-system &#x27;utf-8</span><br><span class="line">      slime-net-coding-system &#x27;utf-8-unix</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">setenv</span> <span class="string">&quot;LC_CTYPE&quot;</span> <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">(<span class="name">setenv</span> <span class="string">&quot;LC_ALL&quot;</span> <span class="string">&quot;en_US.UTF-8&quot;</span>)</span><br><span class="line">(<span class="name">setenv</span> <span class="string">&quot;LANG&quot;</span> <span class="string">&quot;en_US.UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> find-file-encoding &#x27;auto)</span><br><span class="line">(<span class="name">setq-default</span> coding-system-for-read &#x27;utf-8)</span><br><span class="line">(<span class="name">setq-default</span> coding-system-for-write &#x27;utf-8)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 基本设置</span></span><br><span class="line">(<span class="name">defalias</span> &#x27;yes-or-no-p &#x27;y-or-n-p)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq-default</span> window-combination-resize <span class="literal">t</span>                      <span class="comment">;; 新窗口平均其他左右窗口</span></span><br><span class="line">              x-stretch-cursor <span class="literal">t</span>                               <span class="comment">;; 将光标拉伸到字形宽度</span></span><br><span class="line">              indent-tabs-mode <span class="literal">nil</span>                             <span class="comment">;; 不使用 TAB 字符，使用空格</span></span><br><span class="line">              tab-width <span class="number">2</span>                                      <span class="comment">;; tab 宽度设为 2 空格</span></span><br><span class="line">              )</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> ring-bell-function &#x27;ignore</span><br><span class="line">      initial-scratch-message <span class="literal">nil</span></span><br><span class="line">      inhibit-startup-message <span class="literal">t</span></span><br><span class="line">      auto-save-file-name-transforms &#x27;((<span class="string">&quot;.*&quot;</span> <span class="string">&quot;~/.emacs.d/data/backup/&quot;</span> <span class="literal">t</span>)) <span class="comment">;; Write auto-save files to a separate directory</span></span><br><span class="line">      backup-directory-alist &#x27;((<span class="string">&quot;.&quot;</span> . <span class="string">&quot;~/.emacs.d/data/backup/&quot;</span>))          <span class="comment">;; Write backup files to a separate directory</span></span><br><span class="line">      create-lockfiles <span class="literal">nil</span>                                                 <span class="comment">;; Disable lockfiles</span></span><br><span class="line">      scroll-conservatively <span class="number">10000</span> <span class="comment">;;防止页面滚动时跳动</span></span><br><span class="line">      scroll-step <span class="number">1</span>               <span class="comment">;; 当光标移动到边缘时，窗口每次只滚动一行</span></span><br><span class="line">      undo-limit <span class="number">80000000</span>         <span class="comment">;; 提升撤销限制</span></span><br><span class="line">      display-time-default-load-average <span class="literal">nil</span> <span class="comment">;; 不显示系统负载</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 时间显示设置</span></span><br><span class="line"><span class="comment">;; (setq display-time-24hr-format t   ;; 时间使用24小时制</span></span><br><span class="line"><span class="comment">;;       display-time-day-and-date t   ;; 时间显示包括日期和具体时间</span></span><br><span class="line"><span class="comment">;;       display-time-interval 10   ;; 时间的变化频率</span></span><br><span class="line"><span class="comment">;;       display-time-format &quot;%Y-%m-%d %A %H:%M&quot;) ;; 显示完整日期</span></span><br><span class="line"><span class="comment">;; ;; 启用时间显示设置,在minibuffer上面的那个杠上</span></span><br><span class="line"><span class="comment">;; (display-time-mode 1)</span></span><br><span class="line"><span class="comment">;; ;; 立即强制刷新一次时间</span></span><br><span class="line"><span class="comment">;; (display-time-update)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 使用 Fira Code Nerd Font 字体</span></span><br><span class="line">(<span class="name">set-face-attribute</span> &#x27;default <span class="literal">nil</span></span><br><span class="line">                    <span class="symbol">:font</span> <span class="string">&quot;FiraCode Nerd Font&quot;</span></span><br><span class="line">                    <span class="symbol">:height</span> <span class="number">120</span>)  <span class="comment">;; 120=12pt，可根据需求调整</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; wsl与windos共享剪切版</span></span><br><span class="line">(<span class="name">defun</span> my/clipboard-to-windows (<span class="name">text</span> <span class="symbol">&amp;optional</span> push)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">process-connection-type</span> <span class="literal">nil</span>))</span><br><span class="line">    (<span class="name">with-temp-buffer</span></span><br><span class="line">      (<span class="name">insert</span> text)</span><br><span class="line">      (<span class="name">call-process-region</span> (<span class="name">point-min</span>) (<span class="name">point-max</span>) <span class="string">&quot;win32yank.exe&quot;</span> <span class="literal">nil</span> <span class="literal">nil</span> <span class="literal">nil</span> <span class="string">&quot;-i&quot;</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my/clipboard-from-windows ()</span><br><span class="line">  (<span class="name">string-trim-right</span></span><br><span class="line">   (<span class="name">with-output-to-string</span></span><br><span class="line">     (<span class="name">call-process</span> <span class="string">&quot;win32yank.exe&quot;</span> <span class="literal">nil</span> standard-output <span class="literal">nil</span> <span class="string">&quot;-o&quot;</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> interprogram-cut-function &#x27;my/clipboard-to-windows)</span><br><span class="line">(<span class="name">setq</span> interprogram-paste-function &#x27;my/clipboard-from-windows)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;设置镜像源</span></span><br><span class="line"><span class="comment">;; (setq package-archives</span></span><br><span class="line"><span class="comment">;;      &#x27;((&quot;melpa&quot; . &quot;https://melpa.org/packages/&quot;)</span></span><br><span class="line"><span class="comment">;;        (&quot;gnu&quot;   . &quot;https://elpa.gnu.org/packages/&quot;)))</span></span><br><span class="line">(<span class="name">setq</span> package-archives &#x27;((<span class="string">&quot;gnu&quot;</span>    . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;</span>)</span><br><span class="line">                         (<span class="string">&quot;nongnu&quot;</span> . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/nongnu/&quot;</span>)</span><br><span class="line">                         (<span class="string">&quot;melpa&quot;</span>  . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> package</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">unless</span> (<span class="name">bound-and-true-p</span> package--initialized)</span><br><span class="line">    (<span class="name">package-initialize</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> use-package-always-ensure <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;doom主题</span></span><br><span class="line">(<span class="name">use-package</span> doom-themes</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> doom-themes-enable-bold <span class="literal">t</span>    <span class="comment">; if nil, bold is universally disabled</span></span><br><span class="line">        doom-themes-enable-italic <span class="literal">t</span>) <span class="comment">; if nil, italics is universally disable</span></span><br><span class="line">  <span class="comment">;; 加载主题（例如 doom-one）</span></span><br><span class="line">  (<span class="name">load-theme</span> &#x27;doom-tomorrow-night <span class="literal">t</span>)</span><br><span class="line">  <span class="comment">;; 启用可选配置</span></span><br><span class="line">  <span class="comment">;; 高亮当前行</span></span><br><span class="line">  (<span class="name">doom-themes-visual-bell-config</span>)</span><br><span class="line">  <span class="comment">;; 改善 Org-mode 颜色</span></span><br><span class="line">  (<span class="name">doom-themes-org-config</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my/kill-scratch-buffer ()</span><br><span class="line">  <span class="string">&quot;在 Emacs 启动时关闭 *scratch* buffer.&quot;</span></span><br><span class="line">  (<span class="name">when</span> (<span class="name">get-buffer</span> <span class="string">&quot;*scratch*&quot;</span>)</span><br><span class="line">    (<span class="name">kill-buffer</span> <span class="string">&quot;*scratch*&quot;</span>)))</span><br><span class="line">(<span class="name">add-hook</span> &#x27;emacs-startup-hook #&#x27;my/kill-scratch-buffer)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;在执行操作（如撤销、替换、复制）时提供视觉反馈。</span></span><br><span class="line">(<span class="name">use-package</span> volatile-highlights</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">volatile-highlights-mode</span> <span class="literal">t</span>))  <span class="comment">;; 启用 volatile-highlights</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; tab栏显示buffer</span></span><br><span class="line">(<span class="name">use-package</span> centaur-tabs</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:demand</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">defun</span> centaur-tabs-hide-tab (<span class="name">x</span>)</span><br><span class="line">    <span class="string">&quot;自定义隐藏规则：隐藏特殊或无文件 buffer，但保留 vterm buffer.&quot;</span></span><br><span class="line">    (<span class="name">let</span> ((<span class="name">name</span> (<span class="name">format</span> <span class="string">&quot;%s&quot;</span> x)))</span><br><span class="line">      (<span class="name">or</span></span><br><span class="line">       <span class="comment">;; 隐藏无文件 buffer，但保留 *vterm* buffer</span></span><br><span class="line">       (<span class="name">and</span> (<span class="name">not</span> (<span class="name">buffer-file-name</span> x)))</span><br><span class="line">       <span class="comment">;; 专用窗口</span></span><br><span class="line">       (<span class="name">window-dedicated-p</span> (<span class="name">selected-window</span>))</span><br><span class="line">       <span class="comment">;; 临时 buffer</span></span><br><span class="line">       (<span class="name">string-prefix-p</span> <span class="string">&quot;*&quot;</span> name)</span><br><span class="line">       (<span class="name">string-prefix-p</span> <span class="string">&quot; &quot;</span> name)</span><br><span class="line">       <span class="comment">;; Magit 非文件 buffer</span></span><br><span class="line">       (<span class="name">and</span> (<span class="name">string-prefix-p</span> <span class="string">&quot;magit&quot;</span> name)</span><br><span class="line">            (<span class="name">not</span> (<span class="name">file-name-extension</span> name))))))</span><br><span class="line"></span><br><span class="line">  (<span class="name">setq</span> centaur-tabs-style <span class="string">&quot;bar&quot;</span></span><br><span class="line">        centaur-tabs-set-bar &#x27;over</span><br><span class="line">        centaur-tabs-enable-key-bindings <span class="literal">nil</span></span><br><span class="line">        centaur-tabs-set-icons <span class="literal">t</span></span><br><span class="line">        centaur-tabs-icon-type &#x27;nerd-icons</span><br><span class="line">        centaur-tabs-set-close-button <span class="literal">nil</span></span><br><span class="line">        centaur-tabs-show-new-tab-button <span class="literal">nil</span></span><br><span class="line">        centaur-tabs-cycle-scope &#x27;tabs)</span><br><span class="line">  <span class="comment">;;启用插件</span></span><br><span class="line">  (<span class="name">centaur-tabs-mode</span> <span class="literal">t</span>)</span><br><span class="line">  <span class="symbol">:bind</span></span><br><span class="line">  (<span class="string">&quot;C-&lt;left&gt;&quot;</span> . centaur-tabs-backward)</span><br><span class="line">  (<span class="string">&quot;C-&lt;right&gt;&quot;</span> . centaur-tabs-forward))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; a light that follows your cursor</span></span><br><span class="line">(<span class="name">use-package</span> beacon</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">beacon-mode</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; modeline主题</span></span><br><span class="line">(<span class="name">use-package</span> doom-modeline</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:after</span> nyan-mode</span><br><span class="line">  <span class="symbol">:custom</span></span><br><span class="line">  (<span class="name">doom-modeline-buffer-file-name-style</span> &#x27;truncate-all)</span><br><span class="line">  <span class="symbol">:init</span> (<span class="name">doom-modeline-mode</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;显示进度条</span></span><br><span class="line">(<span class="name">use-package</span> nyan-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">nyan-mode</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;文件导航栏</span></span><br><span class="line">(<span class="name">use-package</span> neotree</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;&lt;f8&gt;&quot;</span> . neotree-toggle))</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> neo-theme &#x27;nerd-icons)</span><br><span class="line">  (<span class="name">setq</span> neo-smart-open <span class="literal">t</span>)       <span class="comment">;;  打开时自动跳到当前文件路径</span></span><br><span class="line">  (<span class="name">setq</span> neo-show-hidden-files <span class="literal">t</span>)<span class="comment">;;  显示隐藏文件</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">;; neotree buffer 中强制截断长行</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;neo-after-create-hook</span><br><span class="line">          (<span class="name">lambda</span> (<span class="name">_</span>)</span><br><span class="line">            <span class="comment">;; 不换行，禁用 visual-line（你全局开了的话）</span></span><br><span class="line">            (<span class="name">visual-line-mode</span> <span class="number">-1</span>)</span><br><span class="line">            (<span class="name">setq-local</span> truncate-lines <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">;; 用 “…” 代替右侧的 $ 截断标记</span></span><br><span class="line">            (<span class="name">let</span> ((<span class="name">tbl</span> (<span class="name">or</span> buffer-display-table (<span class="name">make-display-table</span>))))</span><br><span class="line">              (<span class="name">set-display-table-slot</span> tbl &#x27;truncation (<span class="name">make-glyph-code</span> ?…))</span><br><span class="line">              (<span class="name">setq-local</span> buffer-display-table tbl))))</span><br><span class="line"><span class="comment">;; 允许 neotree 窗口宽度可调整</span></span><br><span class="line">(<span class="name">with-eval-after-load</span> &#x27;neotree</span><br><span class="line">  (<span class="name">setq</span> neo-window-fixed-size <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> nerd-icons</span><br><span class="line">  <span class="symbol">:custom</span></span><br><span class="line">  <span class="comment">;; The Nerd Font you want to use in GUI</span></span><br><span class="line">  <span class="comment">;; &quot;Symbols Nerd Font Mono&quot; is the default and is recommended</span></span><br><span class="line">  <span class="comment">;; but you can use any other Nerd Font if you want</span></span><br><span class="line">  (<span class="name">nerd-icons-font-family</span> <span class="string">&quot;FiraCode Nerd Font&quot;</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; use-package with package.el:</span></span><br><span class="line">(<span class="name">use-package</span> dashboard</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">dashboard-setup-startup-hook</span>)</span><br><span class="line">  <span class="comment">;; recentf mode 必须开启</span></span><br><span class="line">  (<span class="name">recentf-mode</span> <span class="number">1</span>)</span><br><span class="line">  <span class="comment">;; 快捷键</span></span><br><span class="line">  (<span class="name">setq</span> dashboard-navigation-cycle <span class="literal">t</span></span><br><span class="line">        dashboard-show-shortcuts <span class="literal">nil</span></span><br><span class="line">        dashboard-set-footer     <span class="literal">nil</span></span><br><span class="line">        dashboard-center-content <span class="literal">t</span><span class="comment">;; Content is not centered by default. To center, set</span></span><br><span class="line">        dashboard-vertically-center-content <span class="literal">t</span><span class="comment">;; vertically center content</span></span><br><span class="line">        dashboard-items &#x27;((recents   . <span class="number">5</span>)   ;; 显示的 widget: 最近文件、书签、项目、agenda</span><br><span class="line">                          (projects  . <span class="number">5</span>)</span><br><span class="line">                          (agenda    . <span class="number">5</span>))</span><br><span class="line">        dashboard-projects-backend &#x27;projectile <span class="comment">;; 设置项目列表使用 Projectile</span></span><br><span class="line">        dashboard-display-icons-p <span class="literal">t</span>        <span class="comment">;; 开启显示图标</span></span><br><span class="line">        dashboard-icon-type &#x27;nerd-icons    <span class="comment">;; 使用 nerd-icons</span></span><br><span class="line">        dashboard-set-file-icons <span class="literal">t</span>         <span class="comment">;; 文件图标</span></span><br><span class="line">        dashboard-set-heading-icons <span class="literal">nil</span>))      <span class="comment">;; 标题图标显示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; enhancement for amx</span></span><br><span class="line">(<span class="name">use-package</span> amx</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span> (<span class="name">amx-mode</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 保存最近打开的buffers到disk</span></span><br><span class="line">(<span class="name">use-package</span> perspective</span><br><span class="line">  <span class="symbol">:custom</span></span><br><span class="line">  (<span class="name">persp-mode-prefix-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c M-p&quot;</span>))  <span class="comment">; pick your own prefix key here</span></span><br><span class="line">  (<span class="name">persp-state-default-file</span> <span class="string">&quot;~/.emacs.d/persp-state.el&quot;</span>) <span class="comment">;; 默认保存位置</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">persp-mode</span>))</span><br><span class="line"><span class="comment">;; 退出 Emacs 时自动保存 session</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;kill-emacs-hook #&#x27;persp-state-save)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;预览要跳转的行</span></span><br><span class="line">(<span class="name">use-package</span> goto-line-preview <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;M-g g&quot;</span> . goto-line-preview)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;代码整行上移下移</span></span><br><span class="line">(<span class="name">use-package</span> move-dup</span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-M-p&quot;</span>   . move-dup-move-lines-up)</span><br><span class="line">         <span class="comment">;;    (&quot;C-M-p&quot; . move-dup-duplicate-up)</span></span><br><span class="line">         (<span class="string">&quot;C-M-n&quot;</span>   . move-dup-move-lines-down)</span><br><span class="line">         <span class="comment">;;    (&quot;C-M-n&quot; . move-dup-duplicate-down)</span></span><br><span class="line">         ))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> exec-path-from-shell</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">when</span> (<span class="name">memq</span> window-system &#x27;(mac ns x))</span><br><span class="line">    (<span class="name">exec-path-from-shell-initialize</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 保证在编程模式下缩进是主要行为</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;prog-mode-hook</span><br><span class="line">          (<span class="name">lambda</span> ()</span><br><span class="line">            (<span class="name">setq-local</span> indent-line-function #&#x27;indent-relative)))</span><br><span class="line"><span class="comment">;; Git工具</span></span><br><span class="line">(<span class="name">use-package</span> magit</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:defer</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-x g&quot;</span> . magit-log-all))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> markdown-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:mode</span> (<span class="string">&quot;\\.md\\&#x27;&quot;</span> . markdown-mode)</span><br><span class="line">  <span class="symbol">:init</span> (<span class="name">setq</span> markdown-command <span class="string">&quot;pandoc&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 语法解析</span></span><br><span class="line">(<span class="name">use-package</span> tree-sitter</span><br><span class="line">  <span class="symbol">:when</span> (<span class="name">and</span> (<span class="name">fboundp</span> &#x27;treesit-available-p)</span><br><span class="line">             (<span class="name">treesit-available-p</span>))</span><br><span class="line">  <span class="symbol">:config</span> (<span class="name">setq</span> treesit-font-lock-level <span class="number">4</span>)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> treesit-language-source-alist</span><br><span class="line">        &#x27;((bash       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-bash&quot;</span>))</span><br><span class="line">          (c          . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-c&quot;</span>))</span><br><span class="line">          (cpp        . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-cpp&quot;</span>))</span><br><span class="line">          (python     . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-python&quot;</span>))</span><br><span class="line">          (rust       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-rust&quot;</span>))</span><br><span class="line">          (toml       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-toml&quot;</span>))</span><br><span class="line">          (elisp      . (<span class="string">&quot;https://github.com/Wilfred/tree-sitter-elisp&quot;</span>))</span><br><span class="line">          (cmake      . (<span class="string">&quot;https://github.com/uyha/tree-sitter-cmake&quot;</span>))</span><br><span class="line">          (dockerfile . (<span class="string">&quot;https://github.com/camdencheek/tree-sitter-dockerfile&quot;</span>))</span><br><span class="line">          (make       . (<span class="string">&quot;https://github.com/alemuller/tree-sitter-make&quot;</span>))</span><br><span class="line">          (yaml       . (<span class="string">&quot;https://github.com/ikatyang/tree-sitter-yaml&quot;</span>))</span><br><span class="line">          (json       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-json&quot;</span>))</span><br><span class="line">          (java       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-java.git&quot;</span>))</span><br><span class="line">          ;;(markdown   . (<span class="string">&quot;https://github.com/MDeiml/tree-sitter-markdown&quot;</span> <span class="literal">nil</span> <span class="string">&quot;tree-sitter-markdown/src&quot;</span>))</span><br><span class="line">          ))</span><br><span class="line"></span><br><span class="line">  <span class="comment">;;没有内置&lt;languate&gt;-mode的需要添加</span></span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\.y[a]?ml\\&#x27;&quot;</span> . yaml-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\(?:Dockerfile\\(?:\\..*\\)?\\|\\.[Dd]ockerfile\\)\\&#x27;&quot;</span> . dockerfile-mode))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 安装 tree-sitter 语法解析器（仅 Emacs 29+）</span></span><br><span class="line">(<span class="name">dolist</span> (<span class="name">lang</span> &#x27;(bash c cpp python rust toml elisp cmake dockerfile make yaml json java))</span><br><span class="line">  (<span class="name">unless</span> (<span class="name">treesit-language-available-p</span> lang)</span><br><span class="line">    (<span class="name">treesit-install-language-grammar</span> lang)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 优先使用 Tree-sitter mode</span></span><br><span class="line">(<span class="name">setq</span> major-mode-remap-alist</span><br><span class="line">      &#x27;((bash-mode        . bash-ts-mode)</span><br><span class="line">        (c-mode           . c-ts-mode)</span><br><span class="line">        (c++-mode         . c++-ts-mode)</span><br><span class="line">        (python-mode      . python-ts-mode)</span><br><span class="line">        (rust-mode        . rust-ts-mode)</span><br><span class="line">        (conf-toml-mode   . toml-ts-mode)</span><br><span class="line">        (elisp-mode       . elisp-ts-mode)</span><br><span class="line">        (cmake-mode       . cmake-ts-mode)</span><br><span class="line">        (dockerfile-mode  . dockerfile-ts-mode)</span><br><span class="line">        (json-mode        . json-ts-mode)</span><br><span class="line">        (java-mode        . java-ts-mode)</span><br><span class="line">        (yaml-mode        . yaml-ts-mode)</span><br><span class="line">        (makefile-mode    . makefile-ts-mode)</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; lsp语言服务器配置</span></span><br><span class="line">(<span class="name">require</span> &#x27;eglot)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> eglot-server-programs</span><br><span class="line">      &#x27;(((c++-mode c-mode c++-ts-mode c-ts-mode)     . (<span class="string">&quot;clangd&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;-j=4&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--background-index&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--clang-tidy&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--completion-style=detailed&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--header-insertion=iwyu&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--all-scopes-completion&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--include-ineligible-results&quot;</span></span><br><span class="line">                                                        ))</span><br><span class="line">        ((rust-mode rust-ts-mode)                    . (<span class="string">&quot;rust-analyzer&quot;</span>))</span><br><span class="line">        ((asm-mode nasm-mode)                        . (<span class="string">&quot;asm-lsp&quot;</span>))</span><br><span class="line">        ((python-mode python-ts-mode)                . (<span class="string">&quot;pyright-langserver&quot;</span> <span class="string">&quot;--stdio&quot;</span>))</span><br><span class="line">        ;;((java-mode java-ts-mode)                    . (<span class="string">&quot;jdtls&quot;</span>))</span><br><span class="line">        ((bash-mode bash-ts-mode sh-mode sh-ts-mode) . (<span class="string">&quot;bash-language-server&quot;</span> <span class="string">&quot;start&quot;</span>))</span><br><span class="line">        ;;((markdown-mode)                             . (<span class="string">&quot;marksman&quot;</span>))</span><br><span class="line">        ;;((latex-mode LaTeX-mode)                     . (<span class="string">&quot;texlab&quot;</span>))</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> c-default-style <span class="string">&quot;stroustrup&quot;</span></span><br><span class="line">      c-basic-offset <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;关闭lsp自动格式化</span></span><br><span class="line">(<span class="name">setq</span> eglot-ignored-server-capabilities &#x27;(<span class="symbol">:documentFormattingProvider</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;自动打开eglot</span></span><br><span class="line">(<span class="name">dolist</span> (<span class="name">hook</span> &#x27;(c-mode-hook c-ts-mode-hook</span><br><span class="line">                            c++-mode-hook c++-ts-mode-hook</span><br><span class="line">                            rust-mode-hook rust-ts-mode-hook</span><br><span class="line">                            asm-mode-hook nasm-mode-hook</span><br><span class="line">                            python-mode-hook python-ts-mode-hook</span><br><span class="line">                            ;;                  java-mode-hook java-ts-mode-hook</span><br><span class="line">                            ;;                  markdown-mode-hook</span><br><span class="line">                            bash-mode-hook bash-ts-mode-hook</span><br><span class="line">                            sh-mode-hook sh-ts-mode-hook</span><br><span class="line">                            ;;                  latex-mode-hook LaTeX-mode-hook</span><br><span class="line">                            ))</span><br><span class="line">  (<span class="name">add-hook</span> hook &#x27;eglot-ensure))</span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-n&quot;</span>) #&#x27;flymake-goto-next-error)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-p&quot;</span>) #&#x27;flymake-goto-prev-error)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; eglot快捷键</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-,&quot;</span>) &#x27;xref-find-definitions)  <span class="comment">;; 跳转到定义</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-.&quot;</span>) &#x27;xref-pop-marker-stack)  <span class="comment">;; 跳回</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-?&quot;</span>) &#x27;xref-find-references)   <span class="comment">;; 查找引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 显示诊断信息（自动 hover 显示错误、警告等）</span></span><br><span class="line">(<span class="name">setq</span> eldoc-idle-delay <span class="number">0.1</span>)  <span class="comment">;; 光标停留 0.1 秒后显示提示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; comment</span></span><br><span class="line">(<span class="name">defun</span> my-cpp-line-comments ()</span><br><span class="line">  <span class="string">&quot;Use // comments instead of /* */ in C/C++.&quot;</span></span><br><span class="line">  (<span class="name">setq-local</span> comment-start <span class="string">&quot;// &quot;</span></span><br><span class="line">              comment-end <span class="string">&quot;&quot;</span></span><br><span class="line">              comment-start-skip <span class="string">&quot;//+\\s-*&quot;</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">dolist</span> (<span class="name">hook</span> &#x27;(c-mode-hook c++-mode-hook c-ts-mode-hook c++-ts-mode-hook</span><br><span class="line">                            rust-mode-hook rust-ts-mode-hook python-mode-hook python-ts-mode-hook java-mode-hook java-ts-mode-hook))</span><br><span class="line">  (<span class="name">add-hook</span> hook #&#x27;my-cpp-line-comments))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 自动补全</span></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> company</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:defer</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">after-init</span> . global-company-mode)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  <span class="comment">;; 光标停留 0 秒立即弹出补全</span></span><br><span class="line">  (<span class="name">setq</span> company-idle-delay <span class="number">0</span>)</span><br><span class="line">  <span class="comment">;; 后端</span></span><br><span class="line">  (<span class="name">setq</span> company-backends &#x27;((company-capf)))</span><br><span class="line">  <span class="comment">;; 最少 1 个字符触发补全，0 表示空白处也可以触发</span></span><br><span class="line">  (<span class="name">setq</span> company-minimum-prefix-length <span class="number">2</span>)</span><br><span class="line">  <span class="comment">;; 补全候选最多显示 20 个</span></span><br><span class="line">  (<span class="name">setq</span> company-tooltip-limit <span class="number">20</span>)</span><br><span class="line">  (<span class="name">setq</span> company-show-numbers <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">setq</span> company-dabbrev-downcase <span class="literal">nil</span>)</span><br><span class="line">  <span class="comment">;; 2023-01-13 From a Reddit post on mixed case issue.</span></span><br><span class="line">  (<span class="name">setq</span> company-dabbrev-ignore-case <span class="literal">nil</span>)</span><br><span class="line">  (<span class="name">setq</span> company-dabbrev-code-ignore-case <span class="literal">nil</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; company-quickhelp 配置（需要gui）</span></span><br><span class="line"><span class="comment">;; (use-package company-quickhelp</span></span><br><span class="line"><span class="comment">;;   :ensure t</span></span><br><span class="line"><span class="comment">;;   :after company</span></span><br><span class="line"><span class="comment">;;   :config</span></span><br><span class="line"><span class="comment">;;   ;; 启用 company-quickhelp</span></span><br><span class="line"><span class="comment">;;   (company-quickhelp-mode 1)</span></span><br><span class="line"><span class="comment">;;   ;; 设置弹出延迟（秒）</span></span><br><span class="line"><span class="comment">;;   (setq company-quickhelp-delay 0.1))</span></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> flx</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> company-fuzzy</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:after</span> company</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">company-mode</span> . company-fuzzy-mode)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> company-fuzzy-sorting-backend &#x27;flx         <span class="comment">;; 选择模糊匹配算法</span></span><br><span class="line">        company-fuzzy-reset-selection <span class="literal">t</span>           <span class="comment">;; 选中候选时重置到第一个</span></span><br><span class="line">        company-fuzzy-prefix-on-top <span class="literal">nil</span>           <span class="comment">;; 是否把 prefix 值置顶</span></span><br><span class="line">        company-fuzzy-trigger-symbols &#x27;(<span class="string">&quot;.&quot;</span> <span class="string">&quot;-&gt;&quot;</span>)  <span class="comment">;; 触发符号</span></span><br><span class="line">        company-fuzzy-show-annotation <span class="literal">t</span>           <span class="comment">;; 显示注释</span></span><br><span class="line">        company-fuzzy-passthrough-backends &#x27;(company-capf)) <span class="comment">;; 排除部分 backend</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  <span class="comment">;; 全局启用</span></span><br><span class="line">  (<span class="name">global-company-fuzzy-mode</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> imenu-list</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> imenu-list-focus-after-activation <span class="literal">t</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 格式化</span></span><br><span class="line">(<span class="name">use-package</span> format-all</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:commands</span> format-all-mode</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . format-all-mode)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  <span class="comment">;; 不在保存时自动格式化</span></span><br><span class="line">  (<span class="name">remove-hook</span> &#x27;before-save-hook &#x27;format-all-buffer <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">setq-default</span> format-all-formatters</span><br><span class="line">                &#x27;((<span class="string">&quot;C&quot;</span> (clang-format))</span><br><span class="line">                  (<span class="string">&quot;C++&quot;</span>     (clang-format))</span><br><span class="line">                  (<span class="string">&quot;rust&quot;</span> (rustfmt))</span><br><span class="line">                  )))</span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-x f&quot;</span>) &#x27;format-all-buffer)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 代码模板</span></span><br><span class="line"><span class="comment">;; YASnippet 配置</span></span><br><span class="line">(<span class="name">use-package</span> yasnippet</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . yas-minor-mode)  <span class="comment">;; 只在编程模式启用</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  <span class="comment">;; 启动时加载所有 snippet</span></span><br><span class="line">  (<span class="name">yas-reload-all</span>)</span><br><span class="line">  <span class="comment">;; 设置 snippet 目录</span></span><br><span class="line">  (<span class="name">setq</span> yas-snippet-dirs</span><br><span class="line">        &#x27;(<span class="string">&quot;~/.emacs.d/snippets&quot;</span>        ;; 个人片段</span><br><span class="line">          <span class="string">&quot;~/.emacs.d/elpa/yasnippet-snippets-*/snippets&quot;</span>))) <span class="comment">;; 社区合集</span></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> yasnippet-snippets</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:after</span> yasnippet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; which-key 显示键绑定提示</span></span><br><span class="line">(<span class="name">use-package</span> which-key</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">which-key-mode</span>))</span><br><span class="line"><span class="comment">;; 窗格切换</span></span><br><span class="line">(<span class="name">use-package</span> ace-window</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;M-o&quot;</span> . ace-window)))</span><br><span class="line"><span class="comment">;; 窗格移动</span></span><br><span class="line">(<span class="name">use-package</span> buffer-move</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-c &lt;up&gt;&quot;</span>    . buf-move-up)</span><br><span class="line">         (<span class="string">&quot;C-c &lt;down&gt;&quot;</span>  . buf-move-down)</span><br><span class="line">         (<span class="string">&quot;C-c &lt;left&gt;&quot;</span>  . buf-move-left)</span><br><span class="line">         (<span class="string">&quot;C-c &lt;right&gt;&quot;</span> . buf-move-right)))</span><br><span class="line"><span class="comment">;; 智能按键C-a C-c k</span></span><br><span class="line">(<span class="name">use-package</span> crux</span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-a&quot;</span> . &#x27;crux-move-beginning-of-line)</span><br><span class="line">         (<span class="string">&quot;C-c k&quot;</span> . &#x27;crux-smart-kill-line)))</span><br><span class="line"><span class="comment">;; 项目识别,通过创建.projectile文件识别为一个项目</span></span><br><span class="line">(<span class="name">use-package</span> projectile</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">projectile-mode</span> <span class="number">+1</span>)</span><br><span class="line">  <span class="symbol">:bind-keymap</span></span><br><span class="line">  (<span class="string">&quot;C-c p&quot;</span> . projectile-command-map)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> projectile-project-search-path &#x27;(<span class="string">&quot;~/repository&quot;</span>))</span><br><span class="line">  (<span class="name">setq</span> projectile-completion-system &#x27;auto) <span class="comment">;; 或 ivy / helm / default</span></span><br><span class="line">  (<span class="name">use-package</span> rg</span><br><span class="line">    <span class="symbol">:ensure</span> <span class="literal">t</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 快捷键定义必须放在后面否则容易被其他插件覆盖</span></span><br><span class="line"><span class="comment">;;enhancement for help</span></span><br><span class="line">(<span class="name">use-package</span> helpful</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span></span><br><span class="line">  ((<span class="string">&quot;C-h f&quot;</span> . helpful-callable)    <span class="comment">;; 替换 describe-function</span></span><br><span class="line">   (<span class="string">&quot;C-h v&quot;</span> . helpful-variable)    <span class="comment">;; 替换 describe-variable</span></span><br><span class="line">   (<span class="string">&quot;C-h k&quot;</span> . helpful-key)         <span class="comment">;; 替换 describe-key</span></span><br><span class="line">   (<span class="string">&quot;C-h x&quot;</span> . helpful-command)     <span class="comment">;; 替换 describe-command</span></span><br><span class="line">   (<span class="string">&quot;C-c C-d&quot;</span> . helpful-at-point)  <span class="comment">;; 光标下符号</span></span><br><span class="line">   (<span class="string">&quot;C-h F&quot;</span> . helpful-function)))  <span class="comment">;; 查看函数，不含宏</span></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> kill-other-buffers ()</span><br><span class="line">  <span class="string">&quot;Kill all buffers except the current one.&quot;</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">mapc</span> (<span class="name">lambda</span> (<span class="name">buf</span>)</span><br><span class="line">          (<span class="name">unless</span> (<span class="name">eq</span> buf (<span class="name">current-buffer</span>))</span><br><span class="line">            (<span class="name">kill-buffer</span> buf)))</span><br><span class="line">        (<span class="name">buffer-list</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 关闭其他buffers</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c k&quot;</span>) #&#x27;kill-other-buffers)</span><br><span class="line"><span class="comment">;;撤销</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-/&quot;</span>) &#x27;undo-only)</span><br><span class="line"><span class="comment">;;撤销刚才的撤销</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-?&quot;</span>) &#x27;undo-redo)</span><br><span class="line"><span class="comment">;; 快捷键绑定：使用调整窗口大小</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-&lt;up&gt;&quot;</span>)    &#x27;enlarge-window)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-&lt;down&gt;&quot;</span>)  &#x27;shrink-window)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-&lt;left&gt;&quot;</span>)  &#x27;shrink-window-horizontally)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-&lt;right&gt;&quot;</span>) &#x27;enlarge-window-horizontally)</span><br><span class="line"><span class="comment">;;全局搜索</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c C-s&quot;</span>) &#x27;projectile-ripgrep)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c i&quot;</span>) #&#x27;imenu-list-minor-mode)</span><br><span class="line"></span><br><span class="line">(<span class="name">custom-set-variables</span></span><br><span class="line"> <span class="comment">;; custom-set-variables was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won&#x27;t work right.</span></span><br><span class="line"> &#x27;(package-selected-packages nil))</span><br><span class="line">(<span class="name">custom-set-faces</span></span><br><span class="line"> <span class="comment">;; custom-set-faces was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won&#x27;t work right.</span></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo//202508032237463.png" alt="preview"></p><h1 id="快捷键配置总览"><a href="#快捷键配置总览" class="headerlink" title="快捷键配置总览"></a>快捷键配置总览</h1><div class="table-container"><table><thead><tr><th>快捷键</th><th>功能描述</th><th>来源配置</th></tr></thead><tbody><tr><td><strong>C-/</strong></td><td>撤销（undo-only）</td><td>手动绑定</td></tr><tr><td><strong>C-?</strong></td><td>重做（undo-redo）</td><td>手动绑定</td></tr><tr><td><strong>M-</strong></td><td>增大当前窗口高度</td><td>手动绑定</td></tr><tr><td><strong>M-</strong></td><td>减小当前窗口高度</td><td>手动绑定</td></tr><tr><td><strong>M-</strong></td><td>减小当前窗口宽度</td><td>手动绑定</td></tr><tr><td><strong>M-</strong></td><td>增大当前窗口宽度</td><td>手动绑定</td></tr><tr><td><strong>C-</strong></td><td>切换到前一个 Tab（Centaur Tabs）</td><td><code>centaur-tabs</code></td></tr><tr><td><strong>C-</strong></td><td>切换到下一个 Tab</td><td><code>centaur-tabs</code></td></tr><tr><td><strong>M-g g</strong></td><td>预览跳转到指定行（goto-line-preview）</td><td><code>goto-line-preview</code></td></tr><tr><td><strong>M-C-p</strong></td><td>将当前行上移</td><td><code>move-dup</code></td></tr><tr><td><strong>M-C-n</strong></td><td>将当前行下移</td><td><code>move-dup</code></td></tr><tr><td><strong>M-p</strong></td><td>下一个错误</td><td><code>flymake</code></td></tr><tr><td><strong>M-n</strong></td><td>上一个错误</td><td><code>flymake</code></td></tr><tr><td><strong>f8</strong></td><td>打开/关闭文件树侧边栏（neotree）</td><td><code>neotree</code></td></tr><tr><td><strong>C-x g</strong></td><td>查看当前 Git 仓库的所有提交</td><td><code>magit</code></td></tr><tr><td><strong>C-x f</strong></td><td>格式化当前 buffer（clang-format / rustfmt）</td><td><code>format-all</code></td></tr><tr><td><strong>M-,</strong></td><td>跳转到定义（xref-find-definitions，需 LSP 支持）</td><td>手动绑定</td></tr><tr><td><strong>M-.</strong></td><td>跳回上一个位置（xref-pop-marker-stack）</td><td>手动绑定</td></tr><tr><td><strong>M-?</strong></td><td>查找引用（xref-find-references，需 LSP 支持）</td><td>手动绑定</td></tr><tr><td><strong>M-o</strong></td><td>在多个窗口间切换焦点</td><td><code>ace-window</code></td></tr><tr><td><strong>C-c</strong></td><td>当前 buffer 上移到另一个窗口</td><td><code>buffer-move</code></td></tr><tr><td><strong>C-c</strong></td><td>当前 buffer 下移到另一个窗口</td><td><code>buffer-move</code></td></tr><tr><td><strong>C-c</strong></td><td>当前 buffer 左移到另一个窗口</td><td><code>buffer-move</code></td></tr><tr><td><strong>C-c</strong></td><td>当前 buffer 右移到另一个窗口</td><td><code>buffer-move</code></td></tr><tr><td><strong>C-a</strong></td><td>智能移动光标到行首（再次按可回到代码开始处）</td><td><code>crux</code></td></tr><tr><td><strong>C-c k</strong></td><td>智能删除一行（不会破坏缩进）</td><td><code>crux</code></td></tr><tr><td><strong>C-c p</strong></td><td>Projectile 项目命令前缀</td><td><code>projectile</code></td></tr><tr><td><strong>C-x SPC</strong></td><td>矩形选择模式，可以选择某些列</td><td>内置</td></tr></tbody></table></div><p><strong> M-X projectile-ripgrep</strong></p><ul><li>neotree<ul><li><strong>M-x neotree-create-node</strong> 创建文件，也可以用<strong>C-c n</strong></li><li><strong>M-x neotree-delete-node</strong> 删除文件</li><li><strong>M-x neotree-rename-node</strong> 重命名文件</li></ul></li><li><strong>M-x persp-state-load</strong> 打开上次打开的 buffer</li><li><strong>M-x recenter</strong> 把当前行放在窗口中间</li><li><strong>M-x eglot-code-actions</strong>对于 lsp 提示 fix available 的可以让 lsp 修改</li><li><strong>C-c C-s</strong> 项目里全局查找</li><li><strong>C-c i</strong> 展示 imenu</li></ul><h1 id="编程设置"><a href="#编程设置" class="headerlink" title="编程设置"></a>编程设置</h1><p>有 makefile 的 project</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">bear -- make</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下基于edk2的UEFI开发环境搭建</title>
      <link href="/posts/42853/"/>
      <url>/posts/42853/</url>
      
        <content type="html"><![CDATA[<h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><p>这是我的硬件环境及操作系统</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/pc_environment.png" alt="硬件环境"></p><h2 id="下载-edk2-源码"><a href="#下载-edk2-源码" class="headerlink" title="下载 edk2 源码"></a>下载 edk2 源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装需要的软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install git</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/UEFI</span><br><span class="line"><span class="built_in">cd</span> UEFI</span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://github.com/tianocore/edk2.git&quot;</span></span><br><span class="line"><span class="built_in">cd</span> edk2</span><br><span class="line"><span class="comment"># 使用这个分支</span></span><br><span class="line">git checkout origin/stable/202408</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">git branch</span><br><span class="line"><span class="comment"># 查看子模块是否都已正确初始化，如果子模块未下载完毕，编译时会有一些问题</span></span><br><span class="line">git submodule status</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="comment"># 下载edk2-libc的代码，这个主要是为了在UEFI开发中使用c标准库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tianocore/edk2-libc.git</span><br><span class="line"><span class="comment"># 创建code文件夹用于存放我们自己的代码</span></span><br><span class="line"><span class="built_in">mkdir</span> -p code</span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载一些基本软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install python3 python3-distutils uuid-dev build-essential bison flex nasm acpica-tools gcc</span><br><span class="line"><span class="comment"># 安装arm的编译器, 这里主要是为了编译aarch64的</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/UEFI/toolchain</span><br><span class="line"><span class="built_in">cd</span> ~/UEFI/toolchain</span><br><span class="line">wget https://developer.arm.com/-/media/Files/downloads/gnu-a/8.2-2019.01/gcc-arm-8.2-2019.01-x86_64-aarch64-elf.tar.xz</span><br><span class="line">tar -xf gcc-arm-8.2-2019.01-x86_64-aarch64-elf.tar.xz</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p>下面来通过一个例子 HelloWorld 来实现实现编译 UEFI 代码到目标平台为 x64 或 aarch64, 并支持在 Emulator 和 qemu 中运行, 最后用 gdb 调试程序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> HelloWorld.dsc</span><br><span class="line"><span class="built_in">touch</span> HelloWorld.inf</span><br><span class="line"><span class="built_in">touch</span> HelloWorld.c</span><br><span class="line"><span class="comment"># 这个命令行工具可以生成uuid, 后面的dsc和inf中的uuid都是这样生成的</span></span><br><span class="line">uuidgen</span><br></pre></td></tr></table></figure><p><strong>HelloWorld.dsc</strong></p><p>DSC文件是包描述文件，其中<strong>Defines</strong>中的所有字段都是强制性的。</p><p>对于LibraryClasses中的路径可以通过以下命令查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> edk2</span><br><span class="line"><span class="comment"># 以UefiApplicationEntryPoint为例</span></span><br><span class="line">grep UefiApplicationEntryPoint -r ./ --include=*.inf | grep LIBRARY_CLASS</span><br><span class="line"><span class="comment"># 通过GUID查找</span></span><br><span class="line">grep -i 752F3136 -r ./ --exclude-dir=Build</span><br></pre></td></tr></table></figure><p>LibraryClasses的格式是<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibraryClassName|Path/To/LibInstanceName.inf</span><br></pre></td></tr></table></figure></p><p>对于DSC文件的完整解释，参考以下链接：<br>   <div class="tag link"><a class="link-card" title="INF-Specification" href="https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/"><div class="left"><img src="https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/gitbook/images/favicon.ico"/></div><div class="right"><p class="text">INF-Specification</p><p class="url">https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/</p></div></a></div></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Defines]</span></span><br><span class="line">  <span class="attr">DSC_SPECIFICATION</span>         = <span class="number">0</span>x0001001A</span><br><span class="line">  <span class="attr">PLATFORM_GUID</span>             = c08977d4-<span class="number">6</span>e87-<span class="number">42</span>f6-bf5c-<span class="number">4</span>d41cfe7ba53</span><br><span class="line">  <span class="attr">PLATFORM_VERSION</span>          = <span class="number">0.01</span></span><br><span class="line">  <span class="attr">PLATFORM_NAME</span>             = HelloWorld</span><br><span class="line">  <span class="attr">SKUID_IDENTIFIER</span>          = DEFAULT</span><br><span class="line">  <span class="attr">SUPPORTED_ARCHITECTURES</span>   = AARCH64|X64</span><br><span class="line">  <span class="attr">BUILD_TARGETS</span>             = DEBUG|RELEASE|NOOPT</span><br><span class="line">  <span class="attr">OUTPUT_DIRECTORY</span>          = $(PKG_OUTPUT_DIR)</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses]</span></span><br><span class="line">  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf</span><br><span class="line">  BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf</span><br><span class="line">  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf</span><br><span class="line">  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf</span><br><span class="line">  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf</span><br><span class="line">  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf</span><br><span class="line">  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf</span><br><span class="line">  ShellCEntryLib|ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf</span><br><span class="line">  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf</span><br><span class="line">  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf</span><br><span class="line">  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf</span><br><span class="line"></span><br><span class="line">  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf</span><br><span class="line">  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses.ARM,LibraryClasses.AARCH64]</span></span><br><span class="line">  NULL|ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf</span><br><span class="line">  NULL|MdePkg/Library/BaseStackCheckLib/BaseStackCheckLib.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses.X64]</span></span><br><span class="line">  RegisterFilterLib|MdePkg/Library/RegisterFilterLibNull/RegisterFilterLibNull.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[Components]</span></span><br><span class="line">  HelloWorld.inf</span><br></pre></td></tr></table></figure><p><strong>HelloWorld.inf</strong></p><p>INF文件是edk2 app的配置文件，其中</p><ul><li>[Defines] 该节定义了一些模块的基本信息<ul><li>BASE_NAME app的名称</li><li>FILE_GUID 可以通过命令uuidgen生成，UEFI通过GUID来区分不同的模块</li><li>MODULE_TYPE 这里填UEFI_APPLICATION</li><li>ENTRY_POINT c代码中的主函数的名称</li></ul></li><li>[Sources] 模块的源代码，一般是.c,.h文件</li><li>[Packages] 需要使用到的包</li><li>[LibraryClasses] 需要使用到的库</li></ul><p>对于INF文件的完整解释，参考以下链接：<br>   <div class="tag link"><a class="link-card" title="INF-Specification" href="https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/"><div class="left"><img src="https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/gitbook/images/favicon.ico"/></div><div class="right"><p class="text">INF-Specification</p><p class="url">https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/</p></div></a></div></p><p>下面是定义的一个简单的模块<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Variables defined to be used during the build process</span></span><br><span class="line"><span class="section">[Defines]</span></span><br><span class="line">  <span class="attr">INF_VERSION</span>       = <span class="number">1.25</span></span><br><span class="line">  <span class="attr">BASE_NAME</span>         = HelloWorld</span><br><span class="line">  <span class="attr">FILE_GUID</span>         = <span class="number">5455334</span>b-dbd9-<span class="number">4</span>f95-b6ed-<span class="number">5</span>ae261a6a0c1</span><br><span class="line">  <span class="attr">MODULE_TYPE</span>       = UEFI_APPLICATION</span><br><span class="line">  <span class="attr">VERSION_STRING</span>    = <span class="number">1.0</span></span><br><span class="line">  <span class="attr">ENTRY_POINT</span>       = UefiMain</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source code</span></span><br><span class="line"><span class="section">[Sources]</span></span><br><span class="line">  HelloWorld.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required packages</span></span><br><span class="line"><span class="section">[Packages]</span></span><br><span class="line">  MdePkg/MdePkg.dec            <span class="comment"># Contains Uefi and UefiLib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Required Libraries</span></span><br><span class="line"><span class="section">[LibraryClasses]</span></span><br><span class="line">  UefiApplicationEntryPoint    <span class="comment"># Uefi application entry point</span></span><br><span class="line">  UefiLib                      <span class="comment"># UefiLib</span></span><br><span class="line">  UefiBootServicesTableLib</span><br></pre></td></tr></table></figure></p><p><strong>HelloWorld.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  Print(<span class="string">L&quot;Hello World!!!\n&quot;</span>);</span><br><span class="line">  SystemTable-&gt;BootServices-&gt;Stall(<span class="number">10000000</span>);</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h2><p>首先我们需要创建一个脚本，用于设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> env.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x env.sh</span><br></pre></td></tr></table></figure><p><strong>env.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 项目名称,也是源代码的源文件目录</span></span><br><span class="line"><span class="built_in">export</span> PROJ_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># dsc文件名</span></span><br><span class="line"><span class="built_in">export</span> DSC_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># inf文件名</span></span><br><span class="line"><span class="built_in">export</span> INF_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># 也是编译生成的*.efi的名字，在inf的BASE_NAME中定义</span></span><br><span class="line"><span class="built_in">export</span> INF_BASE_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># UEFI 工作目录</span></span><br><span class="line"><span class="built_in">export</span> UEFI_WORKSPACE=<span class="string">&quot;<span class="variable">$HOME</span>/UEFI&quot;</span></span><br><span class="line"><span class="comment"># EDK II 路径</span></span><br><span class="line"><span class="built_in">export</span> EDK_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/edk2&quot;</span></span><br><span class="line"><span class="comment"># EDK II libc路径</span></span><br><span class="line"><span class="built_in">export</span> EDK_LIBC_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/edk2-libc&quot;</span></span><br><span class="line"><span class="comment"># 应用代码路径</span></span><br><span class="line"><span class="built_in">export</span> APP_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/code/<span class="variable">$PROJ_NAME</span>&quot;</span></span><br><span class="line"><span class="comment"># 构建输出目录</span></span><br><span class="line"><span class="built_in">export</span> PKG_OUTPUT_DIR=<span class="string">&quot;<span class="variable">$APP_PATH</span>/Build&quot;</span></span><br><span class="line"><span class="comment"># 模拟器路径</span></span><br><span class="line"><span class="built_in">export</span> EMULATOR_PATH=<span class="string">&quot;<span class="variable">$EDK_PATH</span>/Build/EmulatorX64/DEBUG_GCC5/X64&quot;</span></span><br><span class="line"><span class="comment"># 包路径设置，支持多个路径，用冒号分隔</span></span><br><span class="line"><span class="built_in">export</span> PACKAGES_PATH=<span class="string">&quot;<span class="variable">$EDK_PATH</span>:<span class="variable">$EDK_LIBC_PATH</span>:<span class="variable">$APP_PATH</span>&quot;</span></span><br><span class="line"><span class="comment"># 指定 Python 解释器</span></span><br><span class="line"><span class="built_in">export</span> PYTHON_COMMAND=<span class="string">&quot;/usr/bin/python3&quot;</span></span><br><span class="line"><span class="comment"># 确认设置完成</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Environment variables for <span class="variable">$PROJ_NAME</span> project are configured.&quot;</span></span><br></pre></td></tr></table></figure><p>接下写一个脚本实现编译我们的代码到 x64 目标平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> build-x64.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x build-x64.sh</span><br></pre></td></tr></table></figure><p><strong>build-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"></span><br><span class="line"><span class="comment"># Building BaseTools</span></span><br><span class="line">make -C <span class="variable">$EDK_PATH</span>/BaseTools</span><br><span class="line"><span class="comment"># 这里设置-b参数为DEBUG，需要部署时用RELEASE</span></span><br><span class="line"><span class="comment"># -p --platform=</span></span><br><span class="line"><span class="comment"># -m --module=</span></span><br><span class="line"><span class="comment"># -a --arch=</span></span><br><span class="line"><span class="comment"># -b --buildtarget=</span></span><br><span class="line"><span class="comment"># -t --taggname=</span></span><br><span class="line">build -p <span class="variable">$APP_PATH</span>/<span class="variable">$DSC_NAME</span>.dsc -m <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>.inf -a X64 -t GCC5 -b DEBUG -D PKG_OUTPUT_DIR=<span class="variable">$PKG_OUTPUT_DIR</span></span><br></pre></td></tr></table></figure><p>编译到 aarch64 平台同理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> build-aarch64.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x build-aarch64.sh</span><br></pre></td></tr></table></figure><p><strong>build-aarch64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5_AARCH64_PREFIX=<span class="variable">$UEFI_WORKSPACE</span>/toolchain/gcc-arm-8.2-2019.01-x86_64-aarch64-elf/bin/aarch64-elf-</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"></span><br><span class="line"><span class="comment"># Building BaseTools</span></span><br><span class="line">make -C <span class="variable">$EDK_PATH</span>/BaseTools</span><br><span class="line"></span><br><span class="line">build -p <span class="variable">$APP_PATH</span>/<span class="variable">$DSC_NAME</span>.dsc -m <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>.inf -a AARCH64 -t GCC5 -b DEBUG -D PKG_OUTPUT_DIR=<span class="variable">$PKG_OUTPUT_DIR</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="Emulator-运行"><a href="#Emulator-运行" class="headerlink" title="Emulator 运行"></a>Emulator 运行</h3><p>最后我们写一个脚本在 edk2 自带的模拟器上运行一下, 注意<strong>这里需要你有 gui 环境</strong>, 如果是只有命令行则跳过这一步, 看下面一节用 qemu 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> run.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x run.sh</span><br></pre></td></tr></table></figure><p><strong>run.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="comment"># Emulator编译,编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -p <span class="variable">$EDK_PATH</span>/EmulatorPkg/EmulatorPkg.dsc -t GCC5 -a X64</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p <span class="variable">$EMULATOR_PATH</span>/UEFI_Disk</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.efi <span class="variable">$EMULATOR_PATH</span>/UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EMULATOR_PATH</span></span><br><span class="line">./Host</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="qemu-运行"><a href="#qemu-运行" class="headerlink" title="qemu 运行"></a>qemu 运行</h3><p>首先编译并安装 qemu,这里我选择 8.1.5 的版本, 如果你的没有达到预期的效果可以考虑使用这个版本的 qemu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/qemu-project/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout stable-8.1</span><br><span class="line"><span class="built_in">sudo</span> apt install python3-venv python3-pip python3-setuptools python3-sphinx ninja-build pkg-config libglib2.0-dev libpixman-1-dev</span><br><span class="line"><span class="comment"># x86_64</span></span><br><span class="line">./configure --target-list=x86_64-softmmu</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="comment"># aarch64</span></span><br><span class="line">./configure --target-list=aarch64-softmmu</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure><p>接下来写脚本用 qemu 运行, 这里一些参数是为下一节用 gdb 调试程序用的, 但如果你只是想用 qemu 运行一下也不影响</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> debug.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x debug.sh</span><br></pre></td></tr></table></figure><p><strong>debug-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="comment"># 编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -a X64 -p OvmfPkg/OvmfPkgX64.dsc -t GCC5 -b DEBUG <span class="comment">#-D SOURCE_DEBUG_ENABLE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$APP_PATH</span></span><br><span class="line"><span class="built_in">mkdir</span> -p _ovmf_dbg</span><br><span class="line"><span class="built_in">cd</span> _ovmf_dbg</span><br><span class="line"><span class="built_in">rm</span> -f debug.log</span><br><span class="line"><span class="comment"># 与ubuntu22.04软件源默认的qemu不兼容，需要升级qemu版本到v8.1.5</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$EDK_PATH</span>/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd ./</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p UEFI_Disk</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.efi ./UEFI_Disk/</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.debug ./UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 启用 GDB 调试，默认监听在 127.0.0.1:1234</span></span><br><span class="line"><span class="comment"># -bios OVMF.fd，指定 OVMF 固件文件，这是一个支持 UEFI 的 QEMU 固件。</span></span><br><span class="line"><span class="comment"># -debugcon file:debug.log 将调试输出重定向到 debug.log 文件。</span></span><br><span class="line"><span class="comment"># -global isa-debugcon.iobase=0x402 配置调试控制台的 I/O 基地址。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-s \</span><br><span class="line">-bios OVMF.fd \</span><br><span class="line">-drive format=raw,file=fat:rw:UEFI_Disk/ \</span><br><span class="line">-net none \</span><br><span class="line">-debugcon file:debug.log \</span><br><span class="line">-global isa-debugcon.iobase=0x402 \</span><br><span class="line">-nographic</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个脚本首先会编译OVMF(Open Virtual Machine Firmware)，OVMF 是一个基于 EDKII 的固件，可以在 qemu x86-64 虚拟机下运行。这使得调试和实验 UEFI 固件变得更加容易；无论是用于测试操作系统启动，还是使用（内置的）EFI shell。</p><p>OVMF 固件（用于 QEMU 的 UEFI 实现）被分为两个文件：</p><ul><li>OVMF_CODE.fd：包含实际的 UEFI 固件。</li><li>OVMF_VARS.fd：作为一个“模板”用于模拟持久化的 NVRAM 存储。<br>所有虚拟机实例可以共享来自 ovmf 包的系统范围内的只读 OVMF_CODE.fd 文件，但每个实例都需要一个私有的、可写的 OVMF_VARS.fd 副本。<br>在qemu中，可以分别指定OVMF_CODE.fd和OVMF_VARS.fd，也可以采用简化的写法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别指定</span></span><br><span class="line">qemu-system-x86_64 -drive <span class="keyword">if</span>=pflash,format=raw,<span class="built_in">readonly</span>,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF_CODE.fd \</span><br><span class="line">                     -drive <span class="keyword">if</span>=pflash,format=raw,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF_VARS.fd \</span><br><span class="line">                     -nographic \</span><br><span class="line">                     -net none</span><br><span class="line"><span class="comment"># 简化写法</span></span><br><span class="line">qemu-system-x86_64 -drive <span class="keyword">if</span>=pflash,format=raw,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd \</span><br><span class="line">                     -nographic \</span><br><span class="line">                     -net none</span><br></pre></td></tr></table></figure></li></ul><p>运行 debug-x64.sh, 不出意外会出现如下界面, 即 UEFI 的 Shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">Press ESC <span class="keyword">in</span> 2 seconds to skip startup.nsh or any other key to <span class="built_in">continue</span>.</span><br><span class="line">Shell&gt;</span><br></pre></td></tr></table></figure><p>在这个 shell 中输入 fs0:(注意这有一个英文冒号), 然后输入 HelloWorld.efi 运行我们的程序,预期输出”Hello World!!!”</p><div class="tip warning faa-horizontal animated"><p>在Shell如果按BackSpace没有反应，可以按Ctrl+H代替</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">Press ESC <span class="keyword">in</span> 2 seconds to skip startup.nsh or any other key to <span class="built_in">continue</span>.</span><br><span class="line">Shell&gt; fs0:</span><br><span class="line">FS0:\&gt; <span class="built_in">ls</span></span><br><span class="line">Directory of: FS0:\</span><br><span class="line">01/08/2025  22:23                  82  gdb_commands.txt</span><br><span class="line">01/10/2025  20:22             184,544  HelloWorld.debug</span><br><span class="line">01/10/2025  20:22               5,760  HelloWorld.efi</span><br><span class="line">01/10/2025  12:22               1,391  NvVars</span><br><span class="line">          4 File(s)     191,777 bytes</span><br><span class="line">          0 Dir(s)</span><br><span class="line">FS0:\&gt; HelloWorld.efi</span><br><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure><p>退出qemu按<strong>CTRL+A - X</strong></p><p>下面是aarch64版本的<br><strong>debug-aarch64.sh</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5_AARCH64_PREFIX=<span class="variable">$UEFI_WORKSPACE</span>/toolchain/gcc-arm-8.2-2019.01-x86_64-aarch64-elf/bin/aarch64-elf-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -a AARCH64 -p ArmVirtPkg/ArmVirtQemu.dsc -t GCC5 -b RELEASE </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span></span><br><span class="line"><span class="built_in">mkdir</span> -p _armvirt_dbg</span><br><span class="line"><span class="built_in">cd</span> _armvirt_dbg</span><br><span class="line"><span class="built_in">rm</span> -f debug.log</span><br><span class="line"><span class="comment"># 与ubuntu22.04软件源默认的qemu不兼容，需要升级qemu版本到v8.1.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$EDK_PATH</span>/Build/ArmVirtQemu-AARCH64/RELEASE_GCC5/FV/QEMU_EFI.fd ./</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p UEFI_Disk</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>/Build/DEBUG_GCC5/AARCH64/<span class="variable">$INF_BASE_NAME</span>.efi ./UEFI_Disk/</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>/Build/DEBUG_GCC5/AARCH64/<span class="variable">$INF_BASE_NAME</span>.debug ./UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="comment">#qemu命令</span></span><br><span class="line">qemu-system-aarch64 \</span><br><span class="line">-machine virt,kernel_irqchip=on,gic-version=3 \</span><br><span class="line">-cpu cortex-a57 -m 1G  \</span><br><span class="line">-drive format=raw,file=fat:rw:UEFI_Disk/ \</span><br><span class="line">-bios QEMU_EFI.fd \</span><br><span class="line">-net none \</span><br><span class="line">-nographic </span><br></pre></td></tr></table></figure></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>gdb 调试 UEFI 程序稍稍有点麻烦, 但可以用脚本自动化一些操作, 总体流程如下:</p><ol><li>运行 debug.sh, 然后进入 UEFI Shell 中运行一下代码(和上一小节用 qemu 运行一样的操作, 这里主要是为了在_ovmf_dbg/debug.log 中拿到 driver 启动的地址)</li><li>开另一个 terminal, 运行下面的脚本 addr.sh</li><li>在_ovmf_dbg/UEFI_Disk 目录下运行 gdb -x gdb_commands.txt</li><li>在 gdb 里面打断点, 比如 break UefiMain</li><li>添加 gdb 调试 target remote localhost:1234</li><li>运行,输入 c 跳到第一个断点位置</li><li>在 UEFI Shell 中运行你的代码</li></ol><p><strong>addr-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> _ovmf_dbg</span><br><span class="line"></span><br><span class="line">logfile=<span class="string">&quot;debug.log&quot;</span></span><br><span class="line"></span><br><span class="line">line=$(grep -oP <span class="string">&quot;Loading driver at 0x[0-9a-fA-F]+ EntryPoint=0x[0-9a-fA-F]+ <span class="variable">$INF_BASE_NAME</span>\.efi&quot;</span> <span class="string">&quot;<span class="variable">$logfile</span>&quot;</span> | <span class="built_in">tail</span> -n 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式提取两个地址</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$line</span> =~ Loading\ driver\ at\ (0x[0-9a-fA-F]+)\ EntryPoint=(0x[0-9a-fA-F]+)\ <span class="variable">$INF_BASE_NAME</span>\.efi ]]; <span class="keyword">then</span></span><br><span class="line">    address0=<span class="string">&quot;<span class="variable">$&#123;BASH_REMATCH[1]&#125;</span>&quot;</span></span><br><span class="line">    address1=<span class="string">&quot;<span class="variable">$&#123;BASH_REMATCH[2]&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Loading driver at <span class="variable">$address0</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;EntryPoint=<span class="variable">$address1</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: No matching line found, maybe you need to run <span class="variable">$INF_BASE_NAME</span> in qemu first&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> UEFI_Disk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 objdump 获取文件头信息并提取 .text 和 .data 的 File off</span></span><br><span class="line">text_offset=$(objdump -h <span class="string">&quot;<span class="variable">$INF_BASE_NAME</span>.efi&quot;</span> | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  /\.text/ &#123;print $6&#125;  # 提取 .text 的 File off</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data_offset=$(objdump -h <span class="string">&quot;<span class="variable">$INF_BASE_NAME</span>.efi&quot;</span> | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  /\.data/ &#123;print $6&#125;  # 提取 .data 的 File off</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出提取的结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;.text file off: <span class="variable">$text_offset</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;.data file off: <span class="variable">$data_offset</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算</span></span><br><span class="line">text_addr=$((<span class="number">0</span>x<span class="variable">$&#123;address0#0x&#125;</span> + <span class="number">0</span>x<span class="variable">$&#123;text_offset&#125;</span>))</span><br><span class="line">data_addr=$((<span class="number">0</span>x<span class="variable">$&#123;address0#0x&#125;</span> + <span class="number">0</span>x<span class="variable">$&#123;data_offset&#125;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果时使用16进制格式</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;text_addr: 0x%X   data_addr: 0x%X\n&quot;</span> <span class="variable">$text_addr</span> <span class="variable">$data_addr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf gdb_commands.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 gdb_commands.txt 文件并写入内容</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOL &gt; gdb_commands.txt</span></span><br><span class="line"><span class="string">file $&#123;INF_BASE_NAME&#125;.efi</span></span><br><span class="line"><span class="string">add-symbol-file $&#123;INF_BASE_NAME&#125;.debug 0x$(printf &quot;%X&quot; $text_addr) -s .data 0x$(printf &quot;%X&quot; $data_addr)</span></span><br><span class="line"><span class="string">EOL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出文件内容确认</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;gdb_commands.txt has been created with the following content:&quot;</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">cat</span> gdb_commands.txt</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run the following command to debug&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cd _ovmf_dgb/UEFI_Disk&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;gdb -x gdb_commands.txt&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;break UefiMain&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;target remote localhost:1234&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="HelloStd"><a href="#HelloStd" class="headerlink" title="HelloStd"></a>HelloStd</h1><p>另一个例子, 使用 edk-libc 实现在 UEFI 中调用标准 c 库程序</p><p>可以复制 HelloWorld.dsc，在此基础上修改 guid,然后记得修改[<strong>Components</strong>]为 HelloWorld.inf, 最后在 dsc 的[<strong>LibraryClasses</strong>]最后添加一行下面的代码</p><p><strong>HelloStd.dsc</strong></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!include StdLib/StdLib.inc</span><br></pre></td></tr></table></figure><p>接下来是 HelloStd.inf, 首先[<strong>Defines</strong>]中的 ENTRY_POINT 要改为 ShellCEntryLib, [<strong>Packages</strong>]中添加 StdLib/StdLib.dec 和 ShellPkg/ShellPkg.dec 这两个包, [<strong>LibraryClasses</strong>]中要去掉 UefiApplicationEntryPoint, 添加 LibC 和 LibStdio 这两个库, 下面是 HelloStd.inf 的声明</p><p><strong>HelloStd.inf</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Variables defined to be used during the build process</span></span><br><span class="line">[Defines]</span><br><span class="line">  INF_VERSION       = 1.25</span><br><span class="line">  BASE_NAME         = HelloStd</span><br><span class="line">  FILE_GUID         = d0956d2b-c033-45af-8ef2-76c9d30518ec</span><br><span class="line">  MODULE_TYPE       = UEFI_APPLICATION</span><br><span class="line">  VERSION_STRING    = 1.0</span><br><span class="line">  ENTRY_POINT       = ShellCEntryLib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source code</span></span><br><span class="line">[Sources]</span><br><span class="line">  HelloStd.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required packages</span></span><br><span class="line">[Packages]</span><br><span class="line">  MdePkg/MdePkg.dec            <span class="comment"># Contains Uefi and UefiLib</span></span><br><span class="line">  StdLib/StdLib.dec</span><br><span class="line">  ShellPkg/ShellPkg.dec</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required Libraries</span></span><br><span class="line">[LibraryClasses]</span><br><span class="line">  <span class="comment"># UefiApplicationEntryPoint    # Uefi application entry point</span></span><br><span class="line">  UefiLib                      <span class="comment"># UefiLib</span></span><br><span class="line">  LibC</span><br><span class="line">  LibStdio</span><br></pre></td></tr></table></figure><p>接着我们就可以在 UEFI 中调用标准库程序了</p><p><strong>HelloStd.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/ShellCEntryLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiRuntimeServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(IN <span class="type">int</span> Argc, IN <span class="type">char</span> **Argv)</span> &#123;</span><br><span class="line">  EFI_TIME curTime;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;HelloStd!!!\n&quot;</span>);</span><br><span class="line">  gBS-&gt;Stall(<span class="number">2000</span>);</span><br><span class="line">  gRT-&gt;GetTime(&amp;curTime, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Current Time: %d-%d-%d %02d:%02d:%02d\n&quot;</span>, curTime.Year, curTime.Month,</span><br><span class="line">         curTime.Day, curTime.Hour, curTime.Minute, curTime.Second);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着更改下 env.sh 中的 PROJ_NAME, DSC_NAME, INF_NAME, INF_BASE_NAME 即可编译，运行调试等在 HelloWorld 中描述的操作</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/Kostr/UEFI-Lessons">UEFI-Lessons</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/luobing/uefi-practical-programming">UEFI编程实践 罗冰</a></div>]]></content>
      
      
      <categories>
          
          <category> UEFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UEFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emacs</title>
      <link href="/posts/28520/"/>
      <url>/posts/28520/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-01-09</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h2 id="常用选中指令"><a href="#常用选中指令" class="headerlink" title="常用选中指令"></a>常用选中指令</h2><div class="table-container"><table><thead><tr><th>指令</th><th>名字</th><th>效果</th></tr></thead><tbody><tr><td>M - h</td><td>mark-paragraph</td><td>选中段落</td></tr><tr><td>C - x + C - p</td><td>mark-page</td><td>选中整个页面</td></tr><tr><td>C - x h</td><td>mark-whole-buffer</td><td>选中整个编辑窗口内容</td></tr><tr><td>M - y</td><td>yank-pop</td><td>在C - y 之后使用，粘贴剪贴板内以前的项目</td></tr></tbody></table></div><h1 id="emacs配置文件在windows上的位置"><a href="#emacs配置文件在windows上的位置" class="headerlink" title="emacs配置文件在windows上的位置"></a>emacs配置文件在windows上的位置</h1><p>On Windows, the .emacs file may be called _emacs for backward compatibility with DOS and FAT filesystems where filenames could not start with a dot. Some users prefer to continue using such a name, because Explorer cannot create a file with a name starting with a dot, even though the filesystem and most other programs can handle it. In Emacs 22 and later, the init file may also be called.emacs.d/init.el. Many of the other files that are created by lisp packages are now stored in the.emacs.ddirectory too, so this keeps all your Emacs related files in one place.</p><p>All the files mentioned above should go in your HOME directory. The HOME directory is determined by following the steps below:</p><ol><li>If the environment variableHOME is set, use the directory it indicates.</li><li>If the registry entry HKCU\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates.</li><li>If the registry entry HKLM\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates. Not recommended, as it results in users sharing the same HOME directory.</li><li>If C:.emacs exists, then use C:/. This is for backward compatibility, as previous versions defaulted to C:/ if HOME was not set.</li><li>Use the user’s AppData directory, usually a directory called Application Data under the user’s profile directory, the location of which varies according to Windows version and whether the computer is part of a domain.</li></ol><p>也就是说，Emacs的配置文件有三种格式：.emacs文件、_emacs文件或者.emacs.d目录下的init.el（22或者更高版本）文件，但是，不管哪种格式，必须放对正确的目录Emacs才能找到，这个正确的目录就是HOME目录。</p><p>熟悉Linux的朋友一般都知道home目录，简单的用~表示，或者用全路径表示为/home/<xxx>，其中xxx表示用户名字，所以，在Linux下将.emacs和.emacs.d放到这个目录下就行了，但windows没有home目录的概念，所以，Emacs就按如下方式来查找配置文件：</p><ol><li>如果设置了HOME环境变量，那么就用它的值作为home目录~</li><li>如果存在注册表键值HKCU\SOFTWARE\GNU\Emacs\HOME，就用它的值作为home目录~</li><li>如果存在注册表键值HKLM\SOFTWARE\GNU\Emacs\HOME，就用它的值作为home目录~（和2的区别是，2只是针对当前用户的注册表路径，3则是针对所有用户）</li><li>如果存在C:.emacs，就用C:\作为home目录~</li><li>如果以上都不存在的话，就使用<system root>\Users<user name>\AppData\Roaming作为home目录~（对于XP和较早windows用户，需要到Documents and Settings目录下去找）</li></ol><p><strong>从以上策略来看，1是比较好的做法，所以优先级也最高，应该是属于建议的方式，于是，新建一个HOME环境变量，将它的值设为想要放置Emacs配置文件的地方既可。</strong></p><p><strong>之前我是按以上方法设置的HOME目录，不过现在我后悔了，因为我发现不光是Emacs会使用HOME这个环境变量，会使用这个变量的至少还有以下程序或者插件：</strong></p><ol><li><strong>VIM，VIM会把_viminfo文件放在这个目录；</strong></li><li><strong>VIM的neocomplcache插件，它会放置一个.neocon目录进去；</strong></li><li><strong>firefox的pentadactyl插件，它会放一个pentadactyl目录进去。</strong></li></ol><p><strong>所以，个人建议：</strong></p><ol><li><strong>如果你希望有一个公共的目录存放这些配置，就像Linux下的~目录一样，那么设置HOME这个环境变量最适合不过；</strong></li><li><strong>如果你希望这个目录只存放Emacs的配置，那么，还是不要用HOME环境变量了，去注册表里面添加一个HOME键值吧。（至少我个人比较偏向于这个方式）</strong></li></ol><p>即：</p><p>在</p><p>HKEY_LOCAL_MACHINE\SOFTWARE下新建GNU项，在GNU项下新建Emacs项，然后Emacs新建一个字符串值，键为HOME,值为要存放的路径</p><h1 id="emacs-turials"><a href="#emacs-turials" class="headerlink" title="emacs turials"></a>emacs turials</h1><p>C：Ctrl</p><p>M: Alt</p><h2 id="退出Emacs"><a href="#退出Emacs" class="headerlink" title="退出Emacs"></a>退出Emacs</h2><p><strong>C-x C-c</strong></p><h2 id="退出一个正在运行中的命令"><a href="#退出一个正在运行中的命令" class="headerlink" title="退出一个正在运行中的命令"></a>退出一个正在运行中的命令</h2><p><strong>C-g</strong></p><h2 id="移动到下一屏"><a href="#移动到下一屏" class="headerlink" title="移动到下一屏"></a>移动到下一屏</h2><p><strong>C-v</strong></p><h2 id="移动到上一屏"><a href="#移动到上一屏" class="headerlink" title="移动到上一屏"></a>移动到上一屏</h2><p><strong>M-v</strong></p><h2 id="重绘屏幕，将光标所在的行置于屏幕的中央"><a href="#重绘屏幕，将光标所在的行置于屏幕的中央" class="headerlink" title="重绘屏幕，将光标所在的行置于屏幕的中央"></a>重绘屏幕，将光标所在的行置于屏幕的中央</h2><p><strong>C-l（这里是CTRL-L）</strong></p><h2 id="基本光标控制"><a href="#基本光标控制" class="headerlink" title="基本光标控制"></a>基本光标控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                   上一行 C-p</span><br><span class="line">                      :</span><br><span class="line">                      :</span><br><span class="line">向左移 C-b .... 目前光标位置 .... 向右移 C-f</span><br><span class="line">                      :</span><br><span class="line">                      :</span><br><span class="line">                 下一行 C-n</span><br></pre></td></tr></table></figure><p>每行文字都以一个“换行符”结束，“换行符”把行与行区分开来。（通常情况下，一个文件的最后一行会有一个换行符，但是 Emacs 不强制要求这一点。）</p><h3 id="上一行"><a href="#上一行" class="headerlink" title="上一行"></a>上一行</h3><p><strong>C-p</strong></p><p>previous</p><h3 id="下一行"><a href="#下一行" class="headerlink" title="下一行"></a>下一行</h3><p><strong>C-n</strong></p><p>next</p><h3 id="向左移一个字符"><a href="#向左移一个字符" class="headerlink" title="向左移一个字符"></a>向左移一个字符</h3><p><strong>C-b</strong></p><p>backward</p><h3 id="向右移一个字符"><a href="#向右移一个字符" class="headerlink" title="向右移一个字符"></a>向右移一个字符</h3><p><strong>C-f</strong></p><p>forward</p><h3 id="光标向前移动一个词"><a href="#光标向前移动一个词" class="headerlink" title="光标向前移动一个词"></a>光标向前移动一个词</h3><p>这里词对于英文来说是一个英文单词，对于中文来说是移动到下一个标点符号</p><p><strong>M-f</strong></p><h3 id="光标向后移动一个词"><a href="#光标向后移动一个词" class="headerlink" title="光标向后移动一个词"></a>光标向后移动一个词</h3><p><strong>M-b</strong></p><h3 id="将光标移动到行头"><a href="#将光标移动到行头" class="headerlink" title="将光标移动到行头"></a>将光标移动到行头</h3><p><strong>C-a</strong></p><p>ahead</p><h3 id="将光标移动到行尾"><a href="#将光标移动到行尾" class="headerlink" title="将光标移动到行尾"></a>将光标移动到行尾</h3><p><strong>C-e</strong></p><p>end</p><h3 id="将光标移动到一句的头部"><a href="#将光标移动到一句的头部" class="headerlink" title="将光标移动到一句的头部"></a>将光标移动到一句的头部</h3><p><strong>M-a</strong></p><h3 id="将光标移动到一句的尾部"><a href="#将光标移动到一句的尾部" class="headerlink" title="将光标移动到一句的尾部"></a>将光标移动到一句的尾部</h3><p><strong>M-e</strong></p><h3 id="将光标移动到所有文字的最开头"><a href="#将光标移动到所有文字的最开头" class="headerlink" title="将光标移动到所有文字的最开头"></a>将光标移动到所有文字的最开头</h3><p><strong>M-&lt;</strong>(实际上是alt+shift+,)</p><h3 id="将光标移动到所有文字的最末尾"><a href="#将光标移动到所有文字的最末尾" class="headerlink" title="将光标移动到所有文字的最末尾"></a>将光标移动到所有文字的最末尾</h3><p><strong>M-&gt;</strong>(实际上是alt+shift+.)</p><h3 id="光标选中多个文字"><a href="#光标选中多个文字" class="headerlink" title="光标选中多个文字"></a>光标选中多个文字</h3><p><strong>C-shift-r C-shift-f</strong></p><h2 id="移动行块"><a href="#移动行块" class="headerlink" title="移动行块"></a>移动行块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(use-package drag-stuff</span><br><span class="line">             :bind ((&quot;&lt;M-up&gt;&quot; . drag-stuff-up)</span><br><span class="line">                    (&quot;&lt;M-down&gt;&quot; . drag-stuff-down)))</span><br></pre></td></tr></table></figure><p><strong>M-向上箭头</strong></p><h2 id="互换顺序"><a href="#互换顺序" class="headerlink" title="互换顺序"></a>互换顺序</h2><h3 id="光标前后两个字符互换"><a href="#光标前后两个字符互换" class="headerlink" title="光标前后两个字符互换"></a>光标前后两个字符互换</h3><p><strong>C-t</strong></p><h3 id="光标前后两个单词互换"><a href="#光标前后两个单词互换" class="headerlink" title="光标前后两个单词互换"></a>光标前后两个单词互换</h3><p><strong>M-t</strong></p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><strong>M-w</strong></p><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p><strong>C-w</strong></p><h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><p><strong>C-y</strong></p><p>yank</p><h2 id="参数控制"><a href="#参数控制" class="headerlink" title="参数控制"></a>参数控制</h2><p>大部分的Emacs命令接受数字参数，并且对于多数命令而言，这些数字参数的作用是<strong>指定命令的重复次数</strong></p><p><strong>先输入C-u ，然后输入数字作为参数，最后再输入命令</strong></p><p>如： C-u 8 C-f 会向前移动8个字符</p><p>某些Emacs命令接收数字参数当作他用</p><p>比如： C-v 和 M-v</p><p>当给定一一个参数时，他们将滚动指定的行数而不是屏数</p><p>即C-u 8 C-v会将光标向下移动8行</p><h2 id="窗格"><a href="#窗格" class="headerlink" title="窗格"></a>窗格</h2><h3 id="关闭多余的窗格"><a href="#关闭多余的窗格" class="headerlink" title="关闭多余的窗格"></a>关闭多余的窗格</h3><p><strong>C-x 1</strong></p><p>只保留一个窗格，也就是关掉其它所有的窗格，将保留的窗格扩大到整个屏幕，同时关掉所有其它窗格</p><p>有一系列命令是以CONTROL-x开始的，这些命令许多都跟窗格，文件，缓冲区等等相关</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="插入多个相同字符"><a href="#插入多个相同字符" class="headerlink" title="插入多个相同字符"></a>插入多个相同字符</h3><p><strong>C-u 8</strong> <strong>*</strong></p><p>这将会插入<strong><strong>*</strong></strong></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除光标后的一个字符"><a href="#删除光标后的一个字符" class="headerlink" title="删除光标后的一个字符"></a>删除光标后的一个字符</h3><p><strong>C-d</strong></p><p>delete</p><p>相当于键盘的delete键</p><h3 id="删除光标后的一个词"><a href="#删除光标后的一个词" class="headerlink" title="删除光标后的一个词"></a>删除光标后的一个词</h3><p><strong>M-d</strong></p><h3 id="删除光标到行尾之间的字符"><a href="#删除光标到行尾之间的字符" class="headerlink" title="删除光标到行尾之间的字符"></a>删除光标到行尾之间的字符</h3><p><strong>C-k</strong></p><p>kill</p><h3 id="删除光标到句尾之间的字符"><a href="#删除光标到句尾之间的字符" class="headerlink" title="删除光标到句尾之间的字符"></a>删除光标到句尾之间的字符</h3><p><strong>M-k</strong></p><p>注意,“移除（kill）”和“删除（delete）”的不同在于被移除的东西可以被重新插入（在任何位置），而被删除的就不能使用相同的方法重新插入了（不过可以通过撤销一个删除命令来做到，后文会提到）。【实际上，移除掉的东西虽然看起来“消失”了，但实际上被 Emacs 记录了下来，因此还可以找回来；而删除掉的东西虽然也可能还在内存里，但是已经被 Emacs“抛弃”了，所以就找不回来了。】重新插入被移除的文字称为“召回（yank）”。一般而言，那些可能消除很多文字的命令会把消除掉的文字记录下来（它们被设定成了“可召回”），而那些只消除一个字符或者只消除空白的命令就不会记录被消除的内容（自然你也就无法召回了）。</p><p>注意，单独的 C-k 会把一行的内容移除，而第二个 C-k 则会移除换行符，并使其后所有的行都向上移动。C-k 处理数字参数的方式很特别，它会把参数指定的那么多行连同其后的换行符一起移除，而不仅仅是重复 C-k 而已。比如 C-u 2C-k 会把两行以及它们的换行符移除；而如果只是输入 C-k 两次显然不是这个结果。</p><h2 id="召回（粘贴）"><a href="#召回（粘贴）" class="headerlink" title="召回（粘贴）"></a>召回（粘贴）</h2><p>重新插入被移除的文字恢复的动作称为“召回（yanking）”。（就好像把别人从你身边移走的东西又猛力地拉回来。）你可以在你删除文字的地方召回，也可以在别的地方召回，还可以多次召回同样的文字以得到它的多个拷贝。很多其它的编辑器把移除和召回叫做“剪切”和“粘贴” </p><h3 id="召回最近一次移除的内容"><a href="#召回最近一次移除的内容" class="headerlink" title="召回最近一次移除的内容"></a>召回最近一次移除的内容</h3><p><strong>C-y</strong></p><p>yanking</p><h3 id="召回前几次移除的内容"><a href="#召回前几次移除的内容" class="headerlink" title="召回前几次移除的内容"></a>召回前几次移除的内容</h3><p><strong>M-y</strong></p><p>需要先C-y之后再M-y</p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p><strong>C-/</strong></p><p>或者 <strong>C-_</strong> 或者 <strong>C-x u</strong></p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>Emacs 可以向前或向后搜索字符串（“字符串”指的是一组连续的字符）。</p><p>搜索命令是一个<strong>移动光标的命令</strong>：搜索成功后，光标会停留在搜索目标出现的地方</p><h3 id="向前搜索"><a href="#向前搜索" class="headerlink" title="向前搜索"></a>向前搜索</h3><p><strong>C-s</strong></p><p>在一次渐进式搜索中，Emacs 会尝试跳到搜索目标出现的位置。要跳到下一个命中位置，就再按一次 C-s。如果找不到目标，Emacs 会发出“哔”的一声，告诉你搜索失败。在整个过程中，都可以用 C-g 来终止搜索。【你会发现 C-g 会让光标回到搜索开始的位置，而 <Return> 则让光标留在搜索结果上，这是很有用的功能】</p><h3 id="向后搜索"><a href="#向后搜索" class="headerlink" title="向后搜索"></a>向后搜索</h3><p><strong>C-r</strong></p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><strong>M-%</strong></p><p>替换时按下y确认替换，n跳过本处的替换，！全部替换</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="寻找一个文件"><a href="#寻找一个文件" class="headerlink" title="寻找一个文件"></a>寻找一个文件</h3><p><strong>C-x C-f</strong></p><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><p><strong>C-x C-s</strong></p><p>这条命令把 Emacs 中的文字存储到文件中。第一次存盘的时候 Emacs 会将原文件重命名以备份。重命名的规则通常是在原文件名之后添加一个“~”字符。可以关闭这个特性。</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>Emacs 把每个编辑中的文件都放在一个称为“缓冲区（buffer）”的地方。每寻找到一个文件，Emacs 就在其内部开辟一个缓冲区。用下面的命令可以列出当前所有的缓冲区：</p><p>   C-x C-b  列出缓冲区</p><p>输入 C-x 1 离开缓冲区列表</p><p>不管存在多少缓冲区，任何时候都只能有一个“当前”缓冲区，也就是你正在编辑的这个。如果你想编辑其它的缓冲区，就必须“切换”过去。上面讲过，用C-x C-f 是一种办法。不过还有一个更简单的办法，那就是用 C-x b。用这条命令，你必须输入缓冲区的名称。</p><p>大多数情况下，缓冲区与跟其对应的文件是同名的（不包括目录名），不过这也不是绝对的。用 C-x C-b 得到的缓冲区列表总是显示缓冲区名。</p><p>缓冲区未必有对应文件。显示缓冲区列表的缓冲区（叫做“<em>Buffer List</em>”）就是这样。这个 TUTORIAL.cn 缓冲区起初没有对应的文件，但是现在有了，因为在前一节你输入了 C-x C-s ， 将它保存成了一个文件。</p><p>“<em>Messages</em>”缓冲区也没有对应文件，这个缓冲区里存放的都是在 Emacs 底部出现的消息。</p><p>如果你对某个文件做了些修改，然后切换到另一个文件，这个动作并不会帮你把前一个文件存盘。对第一个文件的修改仍然仅存在于 Emacs 中，也就是在它对应的缓冲区里。并且，对第二个文件的修改也不会影响到第一个件。这很有用，但也意味着你需要一个简便的办法来保存第一个文件的缓冲区。先切换回那个缓冲区，再用 C-x C-s 存盘，太麻烦了。你需要一个更简便的方法，而 Emacs 已经为你准备好了：</p><p>   C-x s  保存多个缓冲区</p><p>C-x s 会找出所有已被修改但尚未存盘的缓冲区，然后向你逐个询问：是否需要存盘？</p><h2 id="命令集扩展"><a href="#命令集扩展" class="headerlink" title="命令集扩展"></a>命令集扩展</h2><p>Emacs 的命令就像天上的星星，数也数不清。把它们都对应到 CONTROL 和 META组合键上显然是不可能的。Emacs 用扩展（eXtend）命令来解决这个问题，扩展命令有两种风格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C-x     字符扩展。  C-x 之后输入另一个字符或者组合键。</span><br><span class="line">    M-x     命令名扩展。M-x 之后输入一个命令名</span><br></pre></td></tr></table></figure><h3 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h3><p><strong>M-x sort-lines</strong></p><h3 id="统计字数"><a href="#统计字数" class="headerlink" title="统计字数"></a>统计字数</h3><p>整个buffer统计</p><p><strong>M-x count-words-region</strong></p><p>选中区域统计</p><p><strong>M-x count-words</strong></p><h2 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h2><p>如果你已经修改了一个文件，但是还没来得及存盘你的计算机就罢工了，那么你所做的修改就很可能会丢失。为了避免这样的不幸发生，Emacs 会定期将正在编辑的文件写入一个“自动保存”文件中。自动保存文件的文件名的头尾各有一个“#”字符，比如你正在编辑的文件叫“hello.c”，那么它的自动保存文件就叫“#hello.c#”。这个文件会在常存盘之后被 Emacs 删除。</p><p>所以，假如不幸真的发生了，你大可以从容地打开原来的文件（注意不是自动保存文件）然后输入 M-x recover file <Return> 来恢复你的自动保存文件。在提示确认的时候，输入 yes<Return>。</p><h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>位于回显区正上方的一行被称为“状态栏”。状态栏上会显示一些信息，比如：</p><p>-:**- TUTORIAL.cn 63% L749 (Fundamental)</p><ul><li>状态栏显示了 Emacs 的状态和你正在编辑的文字的一些信息。</li><li>你应该知道文件名的意思吧？就是你找到的那个文件嘛。</li><li>-NN%— 显示的是光标在全文中的位置。如果位于文件的开头，那么就显示 —Top— 而不是 —00%—；如果位于文件的末尾，就显示 —Bot—。如果文件很小，一屏就足以显示全部内容，那么状态栏会显示 —All—。</li><li>“L” 和其后的数字给出了光标所在行的行号。</li><li>最开头的星号（*）表示你已经对文字做过改动。刚刚打开的文件肯定没有被改动过，所以状态栏上显示的不是星号而是短线（-）。</li><li>状态栏上小括号里的内容告诉你当前正在使用的编辑模式。缺省的模式是Fundamental，就是你现在正在使用的这个。它是一种“主模式”。</li></ul><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>主模式都是可以用 M-x 启动的扩展命令，M-x fundamental-mode 就可以切换到 Fundamental模式。</p><p>M-x text-mode <Return>。切换到文本模式</p><p>用 C-h m 可以查看当前主模式的文档，输入 C-x 1 关掉文档窗格</p><ul><li>主模式之所以称之为“主（major）”模式，是因为同时还有“辅模式”（minormode）存在。辅模式并不能替代主模式，而是提供一些辅助的功能。每个辅模式都可以独立地开启和关闭，跟其它辅模式无关，跟主模式也无关。所以你可以不使用辅模式，也可以只使用一个或同时使用多个辅模式。</li><li>有一个叫做自动折行（Auto Fill）的辅模式很有用，特别是在编辑自然语言文本的时候。启用自动折行后，Emacs 会在你打字超出一行边界时自动替你换行。</li><li>用 M-x auto-fill-mode <Return> 启动自动折行模式。再用一次这条命令，自动折行模式会被关闭。也就是说，如果自动折行模式没有被开启，这个命令会开启它；如果已经开启了，这个命令会关闭它。所以我们说，这个命令可以用来开关（toggle）”模式。</li><li>行边界通常被设定为 70 个字符【这里指英文字符】，你可以用 C-x f 命令配合数字参数来重新设定它。</li><li>如果你在段落的中间做了一些修改，那么自动折行模式不会替你把整个段落重新折行，你需要用 M-q 手动折行。注意，光标必须位于你需要折行的那一段里</li></ul><h2 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h2><p>Buffer切换</p><p>C-x b</p><p>杀死当前Buffer</p><p>C-x k</p><p>批量管理Buffer</p><p>C-x C-b ;; 进入Buffer列表</p><ul><li>d ;; 标记删除</li><li>u ;; 取消当前行标记</li><li>U ;; 取消全部标记</li><li>x ;; 执行操作</li><li>? ;; 查看按键帮助</li></ul><h2 id="多窗格（分屏）"><a href="#多窗格（分屏）" class="headerlink" title="多窗格（分屏）"></a>多窗格（分屏）</h2><h3 id="将屏幕划分为两个窗格"><a href="#将屏幕划分为两个窗格" class="headerlink" title="将屏幕划分为两个窗格"></a>将屏幕划分为两个窗格</h3><p><strong>C-x 0</strong></p><p>关闭当前分屏</p><p><strong>C-x 1</strong></p><p>只保留当前分屏</p><p><strong>C-x 2</strong></p><p>上下分屏</p><p><strong>C-x 3</strong></p><p>左右分屏</p><h3 id="分屏宽度调整"><a href="#分屏宽度调整" class="headerlink" title="分屏宽度调整"></a>分屏宽度调整</h3><p>增加高度 C-x ^</p><p>增加/减少宽度 C-x {C-x }</p><h3 id="将光标移动到其它窗格"><a href="#将光标移动到其它窗格" class="headerlink" title="将光标移动到其它窗格"></a>将光标移动到其它窗格</h3><p><strong>C-x o</strong></p><p>o指的是other</p><p>当你在一个窗格中编辑，但用另一个窗格作为参考的时候，C-M-v 是很有用的命令。无需离开被选中的窗格，你就可以用 C-M-v 命令滚动另外一个窗格中的文字。【比如翻译和校对就很适合用这种方式进行。】</p><p>（在上方窗格里）输入 C-x 1 关掉下方窗格</p><p>当分屏很多的时候效率非常低。通过ace-window可快速进行窗口间的跳转。类似的插件较多，但该款为最佳方案。</p><p><strong>M-o</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(use-package ace-window </span><br><span class="line">             :bind ((&quot;M-o&quot; . &#x27;ace-window)))</span><br></pre></td></tr></table></figure><p><img src="./emacs.assets/1673110725303-6cb4c6aa-b022-46d2-827b-1b7befb54e8b.png" alt="img"></p><h3 id="在新窗格里打开文件"><a href="#在新窗格里打开文件" class="headerlink" title="在新窗格里打开文件"></a>在新窗格里打开文件</h3><p><strong>C-x 4 C-f</strong></p><h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><h3 id="新建一个窗口"><a href="#新建一个窗口" class="headerlink" title="新建一个窗口"></a>新建一个窗口</h3><p><strong>M-x make-frame</strong></p><h3 id="关闭选中窗口"><a href="#关闭选中窗口" class="headerlink" title="关闭选中窗口"></a>关闭选中窗口</h3><p><strong>M-x delete-frame</strong></p><h2 id="获得更多帮助"><a href="#获得更多帮助" class="headerlink" title="获得更多帮助"></a>获得更多帮助</h2><p>Emacs 提供了一些命令来查看 Emacs 的命令文档，这些命令都以 CONTROL-h 开头，这个字符也因此被称为“帮助（Help）字符”</p><p>最基本的帮助功能是 C-h c。输入 C-h c 之后再输入一个组合键，Emacs 会给出这个命令的简要说明。</p><p>输入 C-h c C-p。</p><p>显示的消息应该会是这样：</p><p>​    C-p runs the command previous-line</p><p>这条消息显示了 C-p 命令对应的函数名。命令的功能由函数完成，所以函数名本身也可以被看成是最简单的文档――至少对于你已经学过的命令来说，它们的函数名足以解释它们的功能了。</p><p>想得到更多的信息，请把 C-h c 换成 C-h k 试试看。</p><p>输入 C-h k C-p。</p><p>上面的命令会新打开一个 Emacs 窗格以显示函数的名称及其文档。你读完之后可以用 C-x 1 关掉这个帮助窗格。当然你并不需要立即这样做，你完全可以先在编辑窗格里做点别的事情，然后再关掉帮助窗格。</p><p>C-h f 解释一个函数。需要输入函数名。</p><p>输入 C-h f previous-line <Return>。Emacs 会给出它所知道的所有有关“实现 C-p 命令功能的函数”的信息</p><p>C-h v 用来显示 Emacs 变量的文档。Emacs 变量可以被用来“定制 Emacs 的行为”。同样，你需要输入变量的名称。</p><p>C-h a 相关命令搜索（Command Apropos）。 输入一个关键词然后 Emacs 会列出所有命令名中包含此关键词 的命令。这些命令全都可以用 M-x 来启动。对于某些命令来说， 相关命令搜索还会列出一两个组合键。</p><p>输入 C-h a file <Return>。</p><p>Emacs 会在另一个窗格里显示一个 M-x 命令列表，这个列表包含了所有名称中含有“file”的命令。你可以看到像“C-x C-f”这样的组合键显示在“find-file”这样的命令名的旁边。</p><p>C-h i 阅读手册（也就是通常讲的 Info）。 这个命令会打开一个称为“<em>info</em>”的特殊缓冲区，在那里， 你可以阅读安装在系统里的软件包使用手册。要读 Emacs 的使 用手册，按 m emacs <Return> 就可以了。如果你之前从没用 过 Info 系统，那么请按“?”，Emacs 会带你进入 Info 的使 用指南。在看完本快速指南之后，Emacs Info 会成为你的主要 参考文档。</p>]]></content>
      
      
      <categories>
          
          <category> emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emacs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
