<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ARM Cache</title>
      <link href="/posts/2510250/"/>
      <url>/posts/2510250/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-25</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><p>参考文档：</p><div class="tag link"><a class="link-card" title="Arm Architecture Reference Manual Armv8" href="https://developer.arm.com/documentation/ddi0487/fc/"><div class="left"><img src="https://developer.arm.com/shared/common/img/favicon/favicon.ico"/></div><div class="right"><p class="text">Arm Architecture Reference Manual Armv8</p><p class="url">https://developer.arm.com/documentation/ddi0487/fc/</p></div></a></div><h2 id="Cache-基础知识"><a href="#Cache-基础知识" class="headerlink" title="Cache 基础知识"></a>Cache 基础知识</h2><p><strong>经典的cache架构</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921194233140.png" alt="经典cache架构"></p><h3 id="Cache内部架构图"><a href="#Cache内部架构图" class="headerlink" title="Cache内部架构图"></a>Cache内部架构图</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921194635709.png" alt="Cache内部架构图"></p><ul><li><strong>高速缓存行</strong>：高速缓存中的最小的访问单元</li><li><strong>索引(index)域</strong>: 用于索引和查找是在高速缓存中的哪一行</li><li><strong>标记(tag)</strong>：高速缓存地址编码的一部分，通常是高速缓存地址的高位部分，用来判断高速缓存行缓存的数据地址是否和处理器寻址地址一致</li><li><strong>偏移(offset) </strong>: 高速缓存行中的偏移。处理器可以按字(word)或者字节(Byte)来寻址高速缓存行的内容</li><li><strong>组(set)</strong>：相同索引域的高速缓存行组成一个组</li><li><strong>路(way)</strong>: 在组相联的高速缓存中，高速缓存被分成大小相同的几个块</li></ul><p>组的作用主要是防止cache的”颠簸”</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921195738818.png" alt="Cache内部划分"></p><h3 id="Cache的类型"><a href="#Cache的类型" class="headerlink" title="Cache的类型"></a>Cache的类型</h3><p>ARM64 架构上主要有：</p><ul><li><strong>Instruction Cache (I-Cache)</strong><br>专门缓存指令流，加快取指速度。</li><li><strong>Data Cache (D-Cache)</strong><br>缓存数据读写（Load/Store）。</li><li><strong>Unified Cache</strong><br>一些层级（如 L2、L3）往往是统一缓存（既存指令也存数据），不像 L1 那样严格分指令/数据。</li></ul><p>有时称既有I-Cache也有D-Cache的为Separate Cache，它是分离缓存结构：既有独立的 I-Cache，又有独立的 D-Cache。典型于 <strong>L1 Cache</strong>。</p><h3 id="Cache映射方式"><a href="#Cache映射方式" class="headerlink" title="Cache映射方式"></a>Cache映射方式</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><blockquote><p>每个组只有一行高速缓存行时，称为直接映射高速缓存(direct-mapping)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922151547275.png" alt="直接映射"></p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922151745544.png" alt="直接映射的例子"></p><p>0x00,0x40,0x80都映射了同一个高速缓存行里，会频繁发生高速缓存替换性能较低</p><h4 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h4><blockquote><p>当cache只有一个组，即主存中只有一个地址与n个cache line对应，成为全相联</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922152226573.png" alt="全相联的例子"></p><h4 id="组相联"><a href="#组相联" class="headerlink" title="组相联"></a>组相联</h4><ul><li>一个二路相联的高速缓存为例，每一路包括4个高速缓存行，那么每两个组有两个高速缓存行可以提供高速缓存行的替换</li><li>减小高速缓存的颠簸</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922152539265.png" alt="组相联"></p><p>举例：</p><ul><li>高速缓存的总大小是32KB，并且是4路(way)，所以每一路的大小为8KB：way_size = 32/4 = 8(KB)</li><li>高速缓存行的大小为32字节，所以每一路包含的高速缓存行数量为：num_cache_line = 8KB/32B=256</li></ul><p>由此可以画出高速缓存的结构图：<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922153052251.png" alt="高速缓存结构图"></p><p>索引值为12-5+1 = 8位，共2^8=256，可以索引256个cache line</p><h3 id="物理高速缓存"><a href="#物理高速缓存" class="headerlink" title="物理高速缓存"></a>物理高速缓存</h3><blockquote><p>当处理器查询MMU和TLB得到物理地址之后，使用物理地址去查询高速缓存</p></blockquote><p><strong>缺点</strong>：处理器在查询MMU和TLB后才能访问高速缓存，增加了流水线的延迟</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922153248763.png" alt="物理高速缓存"></p><h3 id="虚拟高速缓存"><a href="#虚拟高速缓存" class="headerlink" title="虚拟高速缓存"></a>虚拟高速缓存</h3><blockquote><p>处理器使用虚拟地址来寻址高速缓存</p></blockquote><p><strong>缺点</strong>：会引入不少问题：</p><ul><li>重名(Aliasing)问题</li><li>同名(Homonyms)问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922153646668.png" alt="虚拟高速缓存"></p><h4 id="别名问题-Aliasing"><a href="#别名问题-Aliasing" class="headerlink" title="别名问题(Aliasing)"></a>别名问题(Aliasing)</h4><blockquote><p>也称重名问题</p></blockquote><ul><li>在<strong>操作系统中，多个不同的虚拟地址可能映射相同的物理地址</strong>。由于采用虚拟高速缓存架构，那么这些不同的虚拟地址会占用高速缓存中不同的高速缓存行，但是它们对应的是相同的物理地址</li><li>举个例子：VA1和VA2都映射到PA，在cache中有两个cache line缓存了VA1和VA2<ul><li>当程序往VA1写入数据时，VA1对应的高速缓存行以及PA的内容会被更改，但是VA2还保存着旧数据。这样一个物理地址在虚拟高速缓存中就保存了两份数据，这样会产生歧义</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922155306709.png" alt="重名问题">    </p><h4 id="同名问题-Homonyms"><a href="#同名问题-Homonyms" class="headerlink" title="同名问题(Homonyms)"></a>同名问题(Homonyms)</h4><ul><li><strong>相同的虚拟地址对应着不同的物理地址</strong>，因为操作系统中不同的进程会存在很多相同的虚拟地址，而这些相同的虚拟地址在经过MMU转换后得到不同的物理地址，这就产生了同名问题</li><li>同名问题最常见的地方是进程切换。当一个进程切换到另外一个进程时，新进程使用虚拟地址来访问高速缓存的话，新进程会访问到旧进程遗留下来的高速缓存，这些高速缓存数据对于新进程来说是错误和没用的。解决办法是在进程切换时把旧进程遗留下来的高速缓存都置为无效，这样就能保证新进程执行时得到一个干净的虚拟高速缓存。</li></ul><h3 id="高速缓存分类"><a href="#高速缓存分类" class="headerlink" title="高速缓存分类"></a>高速缓存分类</h3><ul><li><p><strong>VIVT</strong> (Virtual Index Virtual Tag):  使用<strong>虚拟地址的索引域和虚拟地址的标记域</strong>，相当于是<strong>虚拟高速缓存</strong></p><ul><li>CPU 在访问缓存时，不需要先进行地址转换（虚拟地址 → 物理地址），直接用虚拟地址来决定缓存行（index）和匹配标记（tag）。</li><li>存在别名问题 (Synonym/Aliasing)：不同虚拟地址映射到同一物理地址时，会在缓存中出现多份数据，可能导致数据不一致。</li></ul></li><li><p><strong>PIPT</strong> (Physical Index Physical Tag): 使用<strong>物理地址索引域和物理地址标记域</strong>，相当于是<strong>物理高速缓存</strong></p><ul><li>CPU 先通过 MMU 将虚拟地址转换成物理地址，然后用物理地址进行缓存索引和匹配。</li><li>不存在别名问题</li><li>常见L2 Cache</li></ul></li><li><p><strong>VIPT</strong> (Virtual Index Physical Tag): 使用<strong>虚拟地址索引域和物理地址的标记域</strong></p><ul><li>CPU <strong>使用虚拟地址的低位部分作为缓存索引（Index）</strong>。<strong>使用物理地址作为标记（Tag）</strong>，用于匹配判断。因为<strong>缓存行对齐（通常是 64 字节或 128 字节），虚拟地址低位与物理地址低位一致</strong>，所以可以安全地用虚拟地址索引。</li><li><strong>避免了别名问题</strong>，因为使用了物理地址作为标记</li><li>受 <strong>Page Size</strong> 限制：虚拟索引长度必须 ≤ 页面偏移位数，否则不同页的同一虚拟索引会冲突。（VIPT 用虚拟地址的低位索引缓存行）</li><li>常见L1 Cache</li></ul></li></ul><h4 id="VIPT工作过程"><a href="#VIPT工作过程" class="headerlink" title="VIPT工作过程"></a>VIPT工作过程</h4><p>一般视角下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">VA</span> = 虚拟页号 (VPN) | 页内偏移 (PO)</span><br></pre></td></tr></table></figure><p>VIPT视角下<strong>PO</strong>分成：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">PO</span> = Cache Index | Cache Line <span class="literal">Off</span>set</span><br></pre></td></tr></table></figure><ul><li>VIPT 缓存的<strong>索引位仅来自虚拟地址的页内偏移部分</strong>（而非 VPN），这是为了避免索引位受虚拟地址转换影响（PO 在虚实地址中是一致的）。</li><li>缓存行偏移（Line Offset）用于定位缓存行内的具体字节</li></ul><p>假设 L1 Cache 有 64KB，缓存行 64B：</p><ul><li>索引位数 = log₂(64KB / 64B) = log₂(1024) = 10 位</li><li>所以缓存索引使用虚拟地址的 <strong>10 位</strong></li><li><p>页内偏移 = 12 位（4KB 页）</p></li><li><p>页内偏移在虚拟地址和物理地址中是<strong>完全相同</strong>的（分页机制只转换 VPN，不改变 PO）。</p></li><li>若索引位完全落在页内偏移中（即索引位长度 ≤ 页内偏移位长度），则 Cache 索引使用的是 “虚实一致” 的地址位，可避免因 VPN 不同但物理页相同导致的缓存别名问题（Alias Problem）。</li></ul><p>所以要求：索引位 ≤ 页内偏移位</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922160506763.png" alt="VIPT工作流程图"></p><p>左右两步同时进行</p><h4 id="VIPT别名问题"><a href="#VIPT别名问题" class="headerlink" title="VIPT别名问题"></a>VIPT别名问题</h4><p>两个虚拟页面同时映射到同一个物理页面时，两个虚拟页面同时一起填满了Cache的一路</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922160903254.png" alt="两个虚拟地址映射同一个物理页面"></p><p>如图，Virtual Page1改写后，Virtual Page2访问的仍然是原来的数据</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922161212502.png" alt="例子"></p><p>这个别名问题可以通过<strong>cache layout</strong> 来避免</p><h3 id="Cache层级"><a href="#Cache层级" class="headerlink" title="Cache层级"></a>Cache层级</h3><p><strong>两级cache</strong>的系统</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922161320308.png" alt="两级cache"></p><p><strong>三级cache</strong>的系统</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922161334333.png" alt="三级cache"></p><h3 id="多级cache的处理流程"><a href="#多级cache的处理流程" class="headerlink" title="多级cache的处理流程"></a>多级cache的处理流程</h3><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR x0,[x1]</span><br></pre></td></tr></table></figure><p>加载x1地址的值到x0，假设x1是cachable的</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922170619435.png" alt="多级cache"></p><ul><li><strong>Case1</strong>: 如果x1的值在<strong>L1 cache</strong>中，那么CPU直接从<strong>L1 cache</strong>获取了数据</li><li><strong>Case2</strong>: 如果x1的值不在<strong>L1 cache</strong>中，而是在<strong>L2 cache</strong>中<ul><li>如果<strong>L1 cache</strong>中没有空间，那么会淘汰一些<strong>cache line</strong></li><li>数据从<strong>L2 cache line</strong>加载到<strong>L1 cache line</strong></li><li>CPU从<strong>L1 cache line</strong>中读取数据</li></ul></li><li><strong>Case3</strong>: x1的值都不在L1和L2 <strong>cache</strong>中，但是在内存中<ul><li>如果<strong>L1 cache</strong>和<strong>L2 cache</strong>中没有空间，那么会淘汰一些<strong>cache line</strong></li><li>数据从内存中加载到L2和L1的<strong>cache line</strong>中</li><li>CPU从<strong>L1 cache line</strong>中读取数据</li></ul></li></ul><h3 id="多级cache的访问延迟"><a href="#多级cache的访问延迟" class="headerlink" title="多级cache的访问延迟"></a>多级cache的访问延迟</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922171339545.png" alt="多级访问的延迟"></p><h3 id="Cache的策略（Cache-Policies）"><a href="#Cache的策略（Cache-Policies）" class="headerlink" title="Cache的策略（Cache Policies）"></a>Cache的策略（Cache Policies）</h3><ul><li>Cache相关的策略是<strong>在MMU页表中配置</strong>。<strong>只有Normal内存可以被cacheable</strong></li><li>Cache策略包括：<ul><li>Cacheable/non-cacheable</li><li>Cacheable细分<ul><li>Read/write-allocate</li><li>Write-Back cacheable, write-through cacheable</li><li>Shareability</li></ul></li></ul></li></ul><ul><li>Cache 的分配策略<ul><li>Write allocation: 当write miss的时候才分配一个新的cache line</li><li>Read allocation: 当read miss的时候才分配一个新的cache line</li></ul></li><li>Cache回写策略：<ul><li>Write-back: 回写操作仅仅更新到cache，并没有马上更新回内存(cache line is marked as dirty)</li><li>Write through: 回写操作会直接更新cache和内存</li></ul></li></ul><h4 id="Write-Back和Write-Through"><a href="#Write-Back和Write-Through" class="headerlink" title="Write Back和Write Through"></a>Write Back和Write Through</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922174043566.png" alt="Write Back和Write Through"></p><ul><li>WT写直通模式<ul><li>进行写操作时，数据同时写入当前的高速缓存，下一级高速缓存或主存储器中</li><li>直写模式可以降低高速缓存一致性的实现难度，最大的缺点是消耗比较多的总线带宽</li></ul></li><li>ARM Cortex-A系列处理器把WT模式看成Non-cacheable<ul><li>The Cortex-A72 processor memory system treats all Write-Through pages as Non-cacheable</li></ul></li><li>WB模式回写模式<ul><li>在进行写操作时，数据直接写入当前高速缓存，而不会继续传递，当该高速缓存行被替换出去时，被改写的数据才会更新到下一级高速缓存或主存储器中。该策略增加了高速缓存一致性的实现难度，但是有效降低了总线带宽需求。</li><li>Cache line变成Dirty data</li></ul></li></ul><h4 id="Inner-和-Outer-Shareability"><a href="#Inner-和-Outer-Shareability" class="headerlink" title="Inner 和 Outer Shareability"></a>Inner 和 Outer Shareability</h4><ul><li><strong>Normal memory</strong>可以设置inner或者outer shareability</li><li>怎么区分是inner或者outer，不同设计有不同的区分<ul><li><strong>inner attribute</strong>通常是<strong>CPU IP</strong>集成的caches</li><li><strong>outer attribute</strong> are exported on the bus</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922190239281.png" alt="Inner和Outer Shareability"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922190633835.png" alt="inner and outer"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922190703269.png" alt="inner and outer"></p><ul><li>inner attribute是内部集成的cache</li><li>outer attribute是挂载在外部总线的外部cache</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922190725856.png" alt="内部共享与外部共享"></p><h3 id="Point-of-Unification-PoU-和Point-of-Coherency-PoC"><a href="#Point-of-Unification-PoU-和Point-of-Coherency-PoC" class="headerlink" title="Point of Unification(PoU)和Point of Coherency(PoC)"></a>Point of Unification(PoU)和Point of Coherency(PoC)</h3><ul><li><strong>PoU</strong>: 表示一个CPU中的<strong>指令cache</strong>，<strong>数据cache</strong>还有<strong>MMU</strong>，<strong>TLB</strong>等看到的是同一份的内存拷贝<ul><li><strong>PoU for a PE</strong>，是说保证<strong>PE</strong>看到的<strong>I/D cache</strong>和<strong>MMU</strong>是同一份拷贝。大多情况下，<strong>PoU是站在单核系统的角度来观察的</strong></li><li><strong>PoU for inner share</strong>，意思是说在<strong>inner share</strong>里面的所有<strong>PE</strong>都能看到相同的一份拷贝</li></ul></li><li><strong>PoC</strong>: 系统中所有的观察者例如<strong>DSP</strong>, <strong>GPU</strong>, <strong>CPU</strong>, <strong>DMA</strong>等都能看到同一份内存拷贝</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922191415284.png" alt="PoU"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922191831728.png" alt="PoU和Poc"></p><h4 id="PoU和PoC的区别"><a href="#PoU和PoC的区别" class="headerlink" title="PoU和PoC的区别"></a>PoU和PoC的区别</h4><ul><li><strong>PoC</strong>是系统一个概念，和系统配置相关</li><li>例如，<strong>Cortex-A53</strong>可以配置<strong>L2 cache</strong>和没有<strong>L2 cache</strong>，可能会影响<strong>PoU</strong>的范围</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922192009950.png" alt="PoU和PoC的区别"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922192115229.png" alt="PoU和PoC"></p><h3 id="Cache维护"><a href="#Cache维护" class="headerlink" title="Cache维护"></a>Cache维护</h3><ul><li>Cache的管理操作<ul><li>无效 (<strong>Invalidate</strong>)  整个高速缓存或者某个高速缓存行。高速缓存上的数据会被丢弃。</li><li>清除 (<strong>Clean</strong>) 整个高速缓存或者某个告诉缓存行。相应的告诉缓存行会被标记为脏，数<strong>据会写回到下一级高速缓存中或者主存储器中</strong>（也可称为flush）</li><li>清零 (<strong>Zero</strong>) 操作</li></ul></li><li>Cache管理的对象<ul><li><strong>ALL</strong> : 整块高速缓存</li><li><strong>VA</strong>:   某个虚拟地址</li><li><strong>Set/Way</strong>: 特定的告诉缓存行或者组和路</li></ul></li><li>Cache管理的范围<ul><li><strong>PoC</strong></li><li><strong>PoU</strong></li></ul></li><li>Shareability<ul><li><strong>inner</strong></li></ul></li></ul><h3 id="Cache指令格式"><a href="#Cache指令格式" class="headerlink" title="Cache指令格式"></a>Cache指令格式</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922192804276.png" alt="Cache指令格式"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922193009565.png" alt="高速缓存操作指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250927164329862.png" alt="System instructions for cache maintenance"></p><h3 id="Cache的枚举-Cache-discovery"><a href="#Cache的枚举-Cache-discovery" class="headerlink" title="Cache的枚举(Cache discovery)"></a>Cache的枚举(Cache discovery)</h3><ul><li>在我们做cache指令管理的时候，你需要知道如下信息：<ul><li>系统支持多少级的cache?</li><li>Cache line是多少</li><li>每一级的cache，它的set和way是多少</li><li>对于zero操作，我们需要知道多少data可以被zeroed?</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250922193251688.png" alt="Cache"></p><ul><li>Cache Level ID Register (<strong>CLIDR</strong>, <strong>CLIDR_EL1</strong>)：列出有多少level的cache</li><li>Cache Type Register(<strong>CTR, CRT_EL0</strong>): cache line大小</li><li>sets and ways: 需要访问两个寄存器来获取<ul><li>告诉Cache Size Selection Register(<strong>CSSELR</strong>, <strong>CSSELR_EL1</strong>)要查询哪个cache</li><li>从Cache Size ID Register(<strong>CCSIDR</strong>, <strong>CCSIDR_EL1</strong>)中读取相关信息</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> arm64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM Memory Management</title>
      <link href="/posts/2510241/"/>
      <url>/posts/2510241/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><h2 id="内存管理的基本知识和概念"><a href="#内存管理的基本知识和概念" class="headerlink" title="内存管理的基本知识和概念"></a>内存管理的基本知识和概念</h2><p><strong>直接使用物理内存的缺点</strong></p><ul><li>进程地址空间保护问题。所有的用户进程都可以访问全部的物理内存，所以恶意程序可以修改其他程序的内存数据</li><li>内存使用效率低。如果即将要运行的进程所需要的内存空间不足，就需要选择一个进程进行整体换出，这种机制导致有大量的数据需要换入和换出，效率非常低下</li><li>程序运行地址重定位问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831232611336.png" alt="地址空间抽象"></p><h2 id="分页机制的基本概念"><a href="#分页机制的基本概念" class="headerlink" title="分页机制的基本概念"></a>分页机制的基本概念</h2><ul><li>虚拟存储器(Virtual Memory)</li><li>虚拟地址空间(Virtual Address)</li><li>物理存储器(Physical Memory)</li><li>页帧(Page Frame)</li><li>虚拟页帧号(Virtual Page Frame Number)</li><li>物理页帧号(Physical Frame Number)</li><li>页表(Page Table, PT)</li><li>页表项(Page Table Entry, PTE)</li></ul><h2 id="虚拟地址到物理地址映射的过程"><a href="#虚拟地址到物理地址映射的过程" class="headerlink" title="虚拟地址到物理地址映射的过程"></a>虚拟地址到物理地址映射的过程</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831233733816.png" alt="虚拟地址到物理地址的映射的过程"></p><h3 id="一级页表"><a href="#一级页表" class="headerlink" title="一级页表"></a>一级页表</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831233838656.png" alt="一级页表"></p><p><strong>采用一级页表的缺点</strong></p><ul><li>处理器采用一级页表，虚拟地址空间位宽32位，寻址范围是4GB大小，物理地址空间位宽也是32bit，最大支持4GB物理内存，另外页面大小是4KB。为了能映射整个4GB地址空间，需要4GB/4KB = 1MB个页表项，每个页表项占用4字节，共需要4MB大小的物理内存来存放这张页表</li><li><strong>每个进程拥有一套属于自己的页表，在进程切换时需要切换页表基地址。</strong>如上述的一级页表，每个进程需要为其分配4MB的连续物理内存来存储页表，这是不能接受的，因为这样太浪费内存了。</li><li>多级页表：按需一级一级映射，不用一次全部映射所有地址空间</li></ul><h3 id="二级页表"><a href="#二级页表" class="headerlink" title="二级页表"></a>二级页表</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831235240724.png" alt="二级页表"></p><h2 id="VMSA"><a href="#VMSA" class="headerlink" title="VMSA"></a>VMSA</h2><blockquote><p>Virtual Memory System Architecture</p></blockquote><ul><li>VMSA提供了MMU硬件单元<ul><li>虚拟地址到物理地址的转换</li><li>访问权限</li><li>内存属性检查</li></ul></li><li>MMU硬件单元用来实现VA到PA的转换<ul><li>硬件遍历页表table walking</li><li>TTBR寄存器保存了页表基地址</li><li>TLB保存了最近的转换页表项</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831235512374.png" alt="VMSA"></p><p>没有虚拟化场景的情况下，翻译只有一个阶段，由VA映射到PA</p><p>在有虚拟化场景的情况下，翻译需要先转换为IPA</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250912181044741.png" alt="The AArch64 translation regimes"></p><p><strong>TTBR0_ELx</strong> 用于每个进程的地址空间</p><p><strong>TTBR1_ELx </strong>用于内核空间，所有进程共享</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921185018516.png" alt="TTBR0_ELx/TTBR1_ELx"></p><h2 id="ARMv8的页表"><a href="#ARMv8的页表" class="headerlink" title="ARMv8的页表"></a>ARMv8的页表</h2><ul><li><p><strong>aarch64仅仅支持Long Descriptor的页表格式</strong></p></li><li><p>AArch32支持两种页表格式</p><ul><li>Armv7-A Short Descriptor format</li><li>Armv7-A (<strong>LPAE</strong>) Long Descriptor format</li></ul></li><li><p>AArch64支持三种不同的页大小：4KB，16KB，64KB</p><ul><li><p>大粒度page size可以减少页表的体积</p></li><li><p>地址总线位宽支持48位或者52位</p></li><li><p>52位宽：ARMv8.2-LVA is implemented and the 64 KB translation granule</p></li><li><p>以48位总线位宽为例</p></li><li><p><strong>虚拟地址VA被划分为两个空间</strong>，<strong>每个空间最大支持256TB</strong></p><ul><li><strong>低位虚拟地址空间位于0x0000_0000_0000_0000到0x0000_FFFF_FFFF_FFFF</strong></li><li><strong>高位的虚拟地址空间位于0xFFFF_0000_0000_0000到0xFFFF_FFFF_FFFF_FFFF</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901095610466.png" alt="虚拟空间地址划分"></p><p>（<strong>Fault是非规范区域，CPU不能访问</strong>）</p><p><strong>四级页表</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901105744774.png" alt="4级别页表"></p></li></ul></li></ul><h3 id="AArch64的页表描述符"><a href="#AArch64的页表描述符" class="headerlink" title="AArch64的页表描述符"></a>AArch64的页表描述符</h3><p>下面的都是48位虚拟地址，4KB大小页面</p><h4 id="L0-L2的页表描述符"><a href="#L0-L2的页表描述符" class="headerlink" title="L0~L2的页表描述符"></a>L0~L2的页表描述符</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901110008780.png" alt="L0~L2页表的描述符"></p><p><strong>块类型</strong>表示描述的是一块非常大的内存</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250912180502711.png" alt="ARMv8文档中的描述"></p><h4 id="L3页表描述符"><a href="#L3页表描述符" class="headerlink" title="L3页表描述符"></a>L3页表描述符</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901122347242.png" alt="L3页表描述符"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250912180422209.png" alt="ARMv8文档中的描述"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250904214429165.png" alt="Block descriptor"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250904214445492.png" alt="Table descriptor"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250904214646426.png" alt="Page descriptor"></p><div class="table-container"><table><thead><tr><th>层级 (Level)</th><th>对应 Linux 抽象</th><th>描述符可能的类型</th></tr></thead><tbody><tr><td>L0 (可选)</td><td><strong>PGD</strong></td><td><strong>Table / Fault</strong></td></tr><tr><td>L1</td><td><strong>PUD</strong></td><td><strong>Block (1GB, granule=4K) / Table / Fault</strong></td></tr><tr><td>L2</td><td><strong>PMD</strong></td><td><strong>Block (2MB, granule=4K) / Table / Fault</strong></td></tr><tr><td>L3</td><td><strong>PTE</strong></td><td><strong>Page (4KB, granule=4K) / Fault</strong></td></tr></tbody></table></div><blockquote><p>注意：</p><ul><li><strong>Block entry</strong> 只能出现在中间层（L1/L2），表示大页映射，映射一大段物理地址空间，相当于最后一级页表了。</li><li><strong>PTE (L3)</strong> 不能是 Block，只能是 Page 或 Fault。</li><li>输出地址是下一级页表的<strong>PA</strong>即物理地址</li></ul></blockquote><h3 id="页表属性"><a href="#页表属性" class="headerlink" title="页表属性"></a>页表属性</h3><blockquote><p>只有指向 <strong>最终物理页（block/page）</strong> 的表项，才需要页表属性</p></blockquote><p>Armv8.6 <strong>D5.3.3</strong>章</p><ul><li><strong>bit[0]</strong> → 是否有效：<ul><li><code>0</code> = Invalid (Fault entry)</li><li><code>1</code> = 有效 (Valid entry)</li></ul></li><li><strong>bit[1]</strong> → 类型（只在有效时才有意义）：<ul><li><code>0</code> = Block entry （块映射，大页映射）</li><li><code>1</code> = Table entry （指向下一级页表；到最后一级时变成 Page entry）</li></ul></li></ul><p>所以：block和page的页表属性</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901234053981.png" alt="VMSAv8-64 translation table format descriptors"></p><p><strong>高位属性和低位属性</strong></p><p>只描述<strong>Block</strong>和<strong>Page</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250904022421615.png" alt="高位属性和低位属性"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901235625513.png" alt="高位属性和低位属性"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901234250544.png" alt="页表属性1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901234854341.png" alt="页表属性2"></p><h4 id="Contiguous-Block-entries"><a href="#Contiguous-Block-entries" class="headerlink" title="Contiguous Block entries"></a>Contiguous Block entries</h4><ul><li>ARMv8<strong>利用TLB进行的一个优化</strong>：利用<strong>一个TLB entry来完成多个连续的page的VA到PA的转换</strong></li><li><strong>使用Contiguous bit的条件</strong><ul><li><strong>页面对应的VA必须是连续的</strong></li><li><strong>对于4KB的页面，16个连续的page</strong></li><li><strong>对于16KB的页面，32或128个连续的page</strong></li><li><strong>对于64KB的页面，32个连续的page</strong></li><li><strong>连续的页面必须有相同的属性</strong></li><li><strong>起始地址必须以页面对齐</strong></li></ul></li></ul><h4 id="4KB页表"><a href="#4KB页表" class="headerlink" title="4KB页表"></a>4KB页表</h4><ul><li>4级页表</li><li>48bit虚拟地址</li><li><strong>每级页表使用9bit来做索引(512 entries)</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902001655479.png" alt="4KB页表"></p><h4 id="16KB页表"><a href="#16KB页表" class="headerlink" title="16KB页表"></a>16KB页表</h4><ul><li><p>4级页表</p></li><li><p>48bit虚拟地址</p></li><li><p>L0页表只有两个entry</p></li><li><p>L1，L2，L3页表使用11bit来做索引（2048 entries）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902002342487.png" alt="16KB页表"></p><h4 id="64KB页表"><a href="#64KB页表" class="headerlink" title="64KB页表"></a>64KB页表</h4><ul><li>3级页表</li><li>48bit虚拟地址</li><li>L1页表只有64个entry</li><li>L2和L3页表使用13bit</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902005851821.png" alt="64KB页表"></p><h3 id="分离的两套页表设计"><a href="#分离的两套页表设计" class="headerlink" title="分离的两套页表设计"></a>分离的两套页表设计</h3><ul><li>用户空间(EL0)和内核空间(EL1)采用两套分离的页表基地址设计<ul><li><strong>虚拟地址的高16位为1时选择TTBR1_EL1</strong></li><li><strong>虚拟地址的高16位为0时选择TTBR0_EL0</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902010728593.png" alt="分离的两套页表设计"></p><h3 id="与页表相关的系统寄存器"><a href="#与页表相关的系统寄存器" class="headerlink" title="与页表相关的系统寄存器"></a>与页表相关的系统寄存器</h3><h4 id="TCR-EL1"><a href="#TCR-EL1" class="headerlink" title="TCR_EL1"></a>TCR_EL1</h4><blockquote><p>Translation Control Register</p><p>配置地址空间大小和页表粒度</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902011041721.png" alt="TCR_EL1寄存器"></p><p><strong>配置地址空间大小和页表粒度</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902011102577.png" alt="配置地址空间大小和页表粒度"></p><ul><li><strong>IPS</strong>：Intermediate Physical Address Size，用来配置物理地址大小，例如48bit，256TB大小的物理空间</li><li><strong>TG1</strong>和<strong>TG0</strong>：配置页表粒度的大小，例如4KB，16KB，64KB</li><li><strong>T1SZ</strong>：用来配置TTBR_EL1页表能管辖的大小，计算公式为2^(64-T1SZ)个字节</li><li><strong>T0SZ</strong>：用来配置TTBR_EL0页表能管辖的大小，计算公式为2^(64-T0SZ)个字节</li></ul><blockquote><p>在 ARM64 中，虚拟地址的高位并不是随便用的，而是受 <strong>TCR_EL1.T0SZ / T1SZ</strong> 限制。</p></blockquote><p><strong>与Cache相关的字段</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902012554941.png" alt="与Cache相关的字段"></p><ul><li><strong>SH1</strong>：设置内存相关的cache属性，这些内存是通过TTBR_EL1页表来访问的。例如Non-shareable, Outer Shareable，Inner Shareable</li><li><strong>SH0</strong>：设置内存相关的cache属性，这些内存是通过TTBR_EL0页表来访问的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921173931770.png" alt="SH1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921174050978.png" alt="SH0"></p><ul><li><strong>ORGN1</strong>：设置Outer Shareable的相关属性</li><li><strong>ORGN0</strong>:  设置Outer Shareable的相关属性</li><li><strong>IRGN1</strong>： 设置Inner Shareable 的相关属性</li><li><strong>IRGN0</strong>： 设置Inner Shareable 的相关属性</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921173907036.png" alt="ORGN1/IRGN1"></p><h4 id="SCTLR-EL1"><a href="#SCTLR-EL1" class="headerlink" title="SCTLR_EL1"></a>SCTLR_EL1</h4><blockquote><p>System Control Register (EL1)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902013042637.png" alt="SCTLR_EL1寄存器"></p><ul><li>M：打开和关闭MMU</li><li>I：打开指令cache</li><li>C：打开data cache</li></ul><h4 id="TTBR0-EL1"><a href="#TTBR0-EL1" class="headerlink" title="TTBR0_EL1"></a>TTBR0_EL1</h4><blockquote><p>指向TTBR0页表的基地址，通常用于EL1/EL0的页表映射</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902013247666.png" alt="TTBR0_EL1"></p><h4 id="TTBR1-EL1"><a href="#TTBR1-EL1" class="headerlink" title="TTBR1_EL1"></a>TTBR1_EL1</h4><blockquote><p>指向TTBR1页表的基地址，通常用于EL1/EL0的页表映射</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902013328537.png" alt="TTBR1_EL1"></p><h4 id="MAIR-EL1"><a href="#MAIR-EL1" class="headerlink" title="MAIR_EL1"></a>MAIR_EL1</h4><blockquote><p>Memory Attribute Indirection Register</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919153741608.png" alt="MAIR_EL1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919153824935.png" alt="MAIR_EL1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919153907126.png" alt="Attrx meaning"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919153920520.png" alt="dd"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919154058311.png" alt="oooo"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919154116988.png" alt="iii"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919154133551.png" alt="R or W"></p><h4 id="ID-AA64MMFR0-EL1"><a href="#ID-AA64MMFR0-EL1" class="headerlink" title="ID_AA64MMFR0_EL1"></a>ID_AA64MMFR0_EL1</h4><blockquote><p>AArch64 Memory Model Feature Register 0，报告处理器对 <strong>页表、地址范围和内存特性的支持情况</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919163924002.png" alt="ID_AA64MMFR0_EL1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919163948258.png" alt="ID_AA64MMFR0_EL1"></p><div class="table-container"><table><thead><tr><th>字段</th><th>位</th><th>含义</th></tr></thead><tbody><tr><td>PARANGE</td><td>[3:0]</td><td>支持的物理地址位宽</td></tr><tr><td>ASID</td><td>[7:4]</td><td>支持的 ASID（Address Space ID）位数</td></tr><tr><td>BIGENDEL</td><td>[11:8]</td><td>支持 EL1/EL0 大页扩展</td></tr><tr><td>SNSMEM</td><td>[15:12]</td><td>是否支持安全内存访问</td></tr><tr><td>BIGENDEL0</td><td>[19:16]</td><td>支持 EL0 大页扩展</td></tr><tr><td>TGRAN16</td><td>[23:20]</td><td>支持 16KB 页</td></tr><tr><td>TGRAN64</td><td>[27:24]</td><td>支持 64KB 页</td></tr><tr><td>TGRAN4</td><td>[31:28]</td><td>支持 4KB 页</td></tr></tbody></table></div><h4 id="CPACR-EL1"><a href="#CPACR-EL1" class="headerlink" title="CPACR_EL1"></a>CPACR_EL1</h4><blockquote><p>Architectural Feature Access Control Register</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919152141812.png" alt="CPACR_EL1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919152257188.png" alt="CPACR_EL1"></p><p><strong>FPEN 字段（CPACR_EL1[21:20]）</strong></p><blockquote><p> FPEN = Floating-point Enable controls，控制 <strong>EL0/EL1 对 SVE、Advanced SIMD、浮点寄存器的访问是否被 EL1/EL2 捕获（trapped）</strong>。</p></blockquote><ul><li><strong>寄存器影响</strong>：<ul><li><strong>AArch64</strong>:<ul><li>FPCR、FPSR</li><li>SIMD/Floating-point 寄存器 <code>V0-V31</code>（含 D0-D31 / S0-S31 视图）</li></ul></li><li><strong>AArch32 / Advanced SIMD</strong>:<ul><li>FPSCR</li><li>Q0-Q15（含 D0-D31 / S0-S31 视图）</li></ul></li></ul></li><li><strong>异常报告</strong>：<ul><li>EL0/EL1 捕获 → EC syndrome = <code>0x07</code></li><li>EL2 捕获 → EC syndrome = <code>0x00</code>（当 EL2 启用且 <code>HCR_EL2.TGE = 1</code>）</li></ul></li></ul><div class="table-container"><table><thead><tr><th>FPEN</th><th>行为描述</th></tr></thead><tbody><tr><td>0b00</td><td><strong>EL0 和 EL1 的指令都会被捕获</strong>，除非 CPACR_EL1.ZEN 已经捕获它们</td></tr><tr><td>0b01</td><td><strong>仅 EL0 的指令会被捕获</strong>，EL1 不捕获</td></tr><tr><td>0b10</td><td><strong>EL0 和 EL1 的指令都会被捕获</strong>（与 0b00 相同）</td></tr><tr><td>0b11</td><td><strong>不捕获任何指令</strong>（寄存器可自由访问）</td></tr></tbody></table></div><p><strong>简单来说</strong>：</p><ul><li><p>FPEN 控制了 <strong>用户态 (EL0) 或内核态 (EL1) 是否可以直接使用浮点/SIMD/SVE 寄存器</strong>。<strong>开启MMU前通常要打开</strong></p></li><li><p>配合 CPACR_EL1.ZEN，可以对不同级别的访问做精细控制。</p></li><li><p>常用配置：</p><ul><li><p><strong>0b11</strong> → 不捕获，允许所有 EL0/EL1 指令访问 FP/SIMD。</p></li><li><p><strong>0b00/0b10</strong> → 捕获，通常用于安全或虚拟化场景。</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919152424128.png" alt="FPEN"></p><h4 id="MDSCR-EL1"><a href="#MDSCR-EL1" class="headerlink" title="MDSCR_EL1"></a>MDSCR_EL1</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919153102235.png" alt="MDSCR_EL1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919153306784.png" alt="MDSCR_EL1"></p><p><strong>TDCC</strong></p><ul><li><p><strong>TDCC = 0</strong> → 用户态 EL0 可以直接读写 DCC 寄存器。</p></li><li><p><strong>TDCC = 1</strong> → EL0 访问 DCC 寄存器会被 trap 到 EL1/EL2，常用于 <strong>安全/虚拟化/调试控制</strong>。</p></li></ul><blockquote><p>DCC 是 <strong>调试通信通道（Debug Communication Channel）</strong>，它提供了 <strong>CPU 与调试器（Debug Host）之间的数据传输接口</strong>，打开后才能使用Jtag</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250919153337564.png" alt="TDCC"></p><h2 id="内存属性"><a href="#内存属性" class="headerlink" title="内存属性"></a>内存属性</h2><h3 id="ARMv8定义的内存属性"><a href="#ARMv8定义的内存属性" class="headerlink" title="ARMv8定义的内存属性"></a>ARMv8定义的内存属性</h3><ul><li><p>ARMv8架构处理器提供两种内存属性</p><ul><li><p>普通内存(Normal Memory)</p><blockquote><p>普通内存是弱一致性的(weakly ordered)，没有其他额外约束，提供最高的内存访问性能</p></blockquote></li><li><p>设备内存(Device Memory)</p><blockquote><p>处理器访问设备内存会有很多限制，比如不能进行预测访问等。设备内存是严格按照指令顺序来执行的。ARMv8架构定义了多种设备内存的属性</p></blockquote><ul><li><strong>Device-nGnRnE</strong>   (不支持聚合操作，不支持指令重排，不支持提前写应答)</li><li><strong>Device-nGnRE</strong>     (不支持聚合操作，不支持指令重排，支持提前写应答)</li><li><strong>Device-nGRE</strong>        (不支持聚合操作，支持指令重排，支持提前写应答)</li><li><strong>Device-GRE</strong>           (支持聚合操作，支持指令重排，支持提前写应答)</li></ul></li></ul></li></ul><p><strong>Linux内核中定义</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902165725691.png" alt="Linux内核中定义的内存属性"></p><p><strong>内存属性并没有存放在页表的页表项中</strong>，而是存放在<strong>MAIR_ELn</strong>寄存器（<strong>Memory Attribute Indirection Register</strong>）。</p><p><strong>页表项中有一个3位的索引值（AttrInx[2:0]）来查找MAIR_ELn寄存器</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902165739744.png" alt="MAIR_ELn"></p><h3 id="Linux内核中定义的内存属性"><a href="#Linux内核中定义的内存属性" class="headerlink" title="Linux内核中定义的内存属性"></a>Linux内核中定义的内存属性</h3><ul><li>操作系统（Linux系统）根据armv8的定义的内存属性，以及内存的读写等属性，定义一些列属性<ul><li><strong>PAGE_KERNEL</strong>：内存最普通的内存页面</li><li><strong>PAGE_KERNEL_RO</strong>：内核中只读的普通内存页面</li><li><strong>PAGE_KERNEL_ROX</strong>：内核中只读可执行的普通页面</li><li><strong>PAGE_KERNEL_EXEC</strong>：内核中可执行的普通页面</li><li><strong>PAGE_KERNEL_EXEC_CONT</strong>：内核中可执行的普通页面，并且是物理连续的多个页面</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902171041351.png" alt="pgtable-prot.h"></p><h2 id="Linux5-0中的创建页表的例子"><a href="#Linux5-0中的创建页表的例子" class="headerlink" title="Linux5.0中的创建页表的例子"></a>Linux5.0中的创建页表的例子</h2><ul><li>全局目录项 <strong>PGD</strong> （<strong>Page Global Directory</strong>）对应arm64的L0页表</li><li>上级目录项 <strong>PUD</strong> （<strong>Page Upper Directory</strong>）对应arm64的L1页表</li><li>中间目录项 <strong>PMD</strong> （<strong>Page Middle Directory</strong>）对应arm64的L2页表</li><li>页表项（<strong>Page Table Entry</strong>）对应arm64的L3页表</li></ul><p>arch/arm64/mm/mmu.c</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902215605967.png" alt="arch/arm64/mm/mmu.c"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902221410257.png" alt="arch/arm64/mm/mmu.c"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902221747829.png" alt="arch/arm64/mm/mmu.c"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902221924509.png" alt="arch/arm64/mm/mmu.c"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902222005482.png" alt="arch/arm64/mm/mmu.c"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902222126787.png" alt="arch/arm64/mm/mmu.c"></p><ol><li>通过地址addr查找PGD表项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902230149054.png" alt="通过addr查找PGD表项"></p><ol><li>通过addr找到对应pgd的管辖范围的结束地址</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902230219912.png" alt="通过addr找到对应的pgd的管辖范围的结束地址"></p><ol><li>设置pgd页表项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902230227931.png" alt="设置pgd表项"></p><ol><li>通过地址addr查找PUD的表项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902230235914.png" alt="通过地址addr查找PUD的表项"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验一：建立恒等映射"><a href="#实验一：建立恒等映射" class="headerlink" title="实验一：建立恒等映射"></a>实验一：建立恒等映射</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250902230426760.png" alt="实验一"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250901105744774.png" alt="以4KB大小的页面和48位地址宽为例"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200447372.png" alt="get_free_page"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200359611.png" alt="early_pgtable_alloc"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920195827243.png" alt="paging_init"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200006833.png" alt="__create_identical_mapping"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200053467.png" alt="__create_pgd_mapping"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200225287.png" alt="pud_set_section"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200204862.png" alt="alloc_init_pud"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200137344.png" alt="alloc_init_pud"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200310102.png" alt="pmd_set_section"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200246974.png" alt="alloc_init_pmd"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920200334498.png" alt="alloc_init_pte"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920195849461.png" alt="enable_mmu"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920195936345.png" alt="cpu_init"></p><p><strong>为什么要恒等映射</strong></p><p>为了打开MMU不会出问题：</p><ol><li>在关闭MMU情况下，处理器访问的地址都是物理地址。<strong>当MMU打开时，处理器访问地址变为虚拟地址</strong></li><li>现代处理器都是<strong>多级流水线架构</strong>，<strong>处理器会提前预取多条指令到流水线中</strong>。当打开MMU时，处理器已经提前预取了多条指令，并且这些指令是以物理地址来进行预取的。当打开MMU指令执行完成，处理器的MMU功能生效。因此，这里是为了<strong>保证处理器在开启MMU前后可以连续取指令</strong>。</li></ol><h3 id="实验二：为什么MMU跑不起来"><a href="#实验二：为什么MMU跑不起来" class="headerlink" title="实验二：为什么MMU跑不起来"></a>实验二：为什么MMU跑不起来</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250903200428924.png" alt="实验2"></p><p>很明显，_text_boot到_etext的内存属性应该映射成PAGE_KERNEL_ROX</p><p>从_etext到TOTAL_MEMORY才是映射成PAGE_KERNEL</p><h3 id="实验三：实现一个MMU页表dump的功能"><a href="#实验三：实现一个MMU页表dump的功能" class="headerlink" title="实验三：实现一个MMU页表dump的功能"></a>实验三：实现一个MMU页表dump的功能</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250920201518274.png" alt="实验3"></p><h3 id="实验四：修改页面属性导致的系统宕机"><a href="#实验四：修改页面属性导致的系统宕机" class="headerlink" title="实验四：修改页面属性导致的系统宕机"></a>实验四：修改页面属性导致的系统宕机</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921164535873.png" alt="实验4"></p><p>小明同学做了这个实验，他在链接脚本里text段申请了一个4KB的只读页面，然后实现了一个walk_pgtable()的函数去遍历页表和查找对应的PTE，发现怎么设置都没法让页面设置为可写</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921164645740.png" alt="kenel_panic"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921165259831.png" alt="Descriptor encodings"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921165333901.png" alt="PMD_TYPE"></p><p>问题出在这里</p><p>​    <img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921165417892.png" alt="问题"></p><p>应改成</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921165555291.png" alt="修改"></p><h3 id="实验五：验证ldxr和stxr指令"><a href="#实验五：验证ldxr和stxr指令" class="headerlink" title="实验五：验证ldxr和stxr指令"></a>实验五：验证ldxr和stxr指令</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921170210342.png" alt="实验6"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921170511374.png" alt="ldxr指令的限制"></p><p>原因是我们没有设置sharable属性</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921170554115.png" alt="sharable属性"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921174407321.png" alt="配置sharable属性"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921174420561.png" alt="sctlr_el1"></p><h3 id="实验六：地址转换AT指令"><a href="#实验六：地址转换AT指令" class="headerlink" title="实验六：地址转换AT指令"></a>实验六：地址转换AT指令</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921181449858.png" alt="实验6"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921181554709.png" alt="AT指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250921181609567.png" alt="PAR_EL1"></p><h3 id="MMU芯片手册阅读"><a href="#MMU芯片手册阅读" class="headerlink" title="MMU芯片手册阅读"></a>MMU芯片手册阅读</h3><p>TODO</p>]]></content>
      
      
      <categories>
          
          <category> arm64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust std</title>
      <link href="/posts/2510240/"/>
      <url>/posts/2510240/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-22</p></div></div><div class='timeline-item-content'><p>add Vec, others todo</p></div></div></div><h1 id="primitive-like-collections"><a href="#primitive-like-collections" class="headerlink" title="primitive-like collections"></a>primitive-like collections</h1><blockquote><p>基础序列类型，在标准库的顶层模块里，而不是std::collections，在预导入模块里，不用显示导入</p></blockquote><h2 id="Vec"><a href="#Vec" class="headerlink" title="Vec"></a>Vec</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h4 id="vec"><a href="#vec" class="headerlink" title="vec![]"></a>vec![]</h4><p>用vec宏比较方便，可以在构造时初始化一些值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    () =&gt; (</span><br><span class="line">        $crate::vec::<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    );</span><br><span class="line">    ($elem:expr; $n:expr) =&gt; (</span><br><span class="line">        $crate::vec::<span class="title function_ invoke__">from_elem</span>($elem, $n)</span><br><span class="line">    );</span><br><span class="line">    ($($x:expr),+ $(,)?) =&gt; (</span><br><span class="line">        &lt;[_]&gt;::<span class="title function_ invoke__">into_vec</span>(</span><br><span class="line">            <span class="comment">// Using the intrinsic produces a dramatic improvement in stack usage for</span></span><br><span class="line">            <span class="comment">// unoptimized programs using this code path to construct large Vecs.</span></span><br><span class="line">            $crate::boxed::<span class="title function_ invoke__">box_new</span>([$($x),+])</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(v[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v[<span class="number">2</span>], <span class="number">3</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="Vec-new"><a href="#Vec-new" class="headerlink" title="Vec::new()"></a><strong>Vec::new()</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><ul><li>Constructs a new, empty Vec<T>. The vector <strong>will not allocate until elements are pushed onto it</strong>.</li></ul><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure><hr><h4 id="Vec-with-capacity"><a href="#Vec-with-capacity" class="headerlink" title="Vec::with_capacity()"></a><strong>Vec::with_capacity()</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">with_capacity</span>(capacity: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><ul><li><p>Constructs a new, empty <code>Vec&lt;T&gt;</code> with at least the specified capacity.</p></li><li><p>If <code>capacity</code> is zero, the vector will not allocate.</p></li><li><p>For <code>Vec&lt;T&gt;</code> where <code>T</code> is a zero-sized type, there will be no allocation and the capacity will always be <code>usize::MAX</code>.</p></li></ul><p><strong>Panics</strong></p><p>Panics if the new capacity exceeds <code>isize::MAX</code> <em>bytes</em>.</p><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The vector contains no items, even though it has capacity for more</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// These are all done without reallocating...</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    vec.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">10</span>);</span><br><span class="line"><span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...but this may make the vector reallocate</span></span><br><span class="line">vec.<span class="title function_ invoke__">push</span>(<span class="number">11</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">11</span>);</span><br><span class="line"><span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A vector of a zero-sized type will always over-allocate, since no</span></span><br><span class="line"><span class="comment">// allocation is necessary</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec_units</span> = <span class="type">Vec</span>::&lt;()&gt;::<span class="title function_ invoke__">with_capacity</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec_units.<span class="title function_ invoke__">capacity</span>(), <span class="type">usize</span>::MAX);</span><br></pre></td></tr></table></figure><hr><h4 id="Vec-from-raw-parts"><a href="#Vec-from-raw-parts" class="headerlink" title="Vec::from_raw_parts()"></a>Vec::from_raw_parts()</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">from_raw_parts</span>(</span><br><span class="line">    ptr: *<span class="keyword">mut</span> T,</span><br><span class="line">    length: <span class="type">usize</span>,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><ul><li><p>Creates a <code>Vec&lt;T&gt;</code> directly from a pointer, a length, and a capacity.</p></li><li><p>This is highly unsafe, due to the number of invariants that aren’t checked:</p><ul><li><p>T needs to have the same alignment as what ptr was allocated with.</p></li><li><p><strong>ptr must have been allocated using the global allocator, such as via the alloc::alloc function</strong></p><blockquote><p>用C的ptr是不安全的，因为Vec在Drop时会调用rust allocator的dealloc，但这个内存是C分配的，不安全</p></blockquote></li><li><p>length needs to be less than or equal to capacity</p></li><li><p>The first <code>length</code> values must be properly initialized values of type <code>T</code></p></li><li><p>capacity needs to be the capacity that the pointer was allocated with</p></li><li><p>The allocated size in bytes must be no larger than <code>isize::MAX</code></p></li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ptr;</span><br><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent running `v`&#x27;s destructor so we are in complete control</span></span><br><span class="line"><span class="comment">// of the allocation.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = mem::ManuallyDrop::<span class="title function_ invoke__">new</span>(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pull out the various important pieces of information about `v`</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">p</span> = v.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = v.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">cap</span> = v.<span class="title function_ invoke__">capacity</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// Overwrite memory with 4, 5, 6</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..len &#123;</span><br><span class="line">        ptr::<span class="title function_ invoke__">write</span>(p.<span class="title function_ invoke__">add</span>(i), <span class="number">4</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Put everything back together into a Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rebuilt</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from_raw_parts</span>(p, len, cap);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(rebuilt, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>using memory that was allocated else where</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::alloc::&#123;alloc, Layout&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 构造一个可以存16个 u32 的内存布局</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">layout</span> = Layout::array::&lt;<span class="type">u32</span>&gt;(<span class="number">16</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;overflow cannot happen&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 使用裸分配函数分配内存（返回 *mut u8 指针）</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mem</span> = <span class="title function_ invoke__">alloc</span>(layout).cast::&lt;<span class="type">u32</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> mem.<span class="title function_ invoke__">is_null</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 往分配的内存第一个位置写入一个值</span></span><br><span class="line">        mem.<span class="title function_ invoke__">write</span>(<span class="number">1_000_000</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 把这块原始内存包装成一个 Vec（长度1，容量16）</span></span><br><span class="line">        <span class="type">Vec</span>::<span class="title function_ invoke__">from_raw_parts</span>(mem, <span class="number">1</span>, <span class="number">16</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec, &amp;[<span class="number">1_000_000</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">capacity</span>(), <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><h4 id="vec-len"><a href="#vec-len" class="headerlink" title="vec.len"></a>vec.len</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">len</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span></span><br></pre></td></tr></table></figure><p>返回元素个数</p><hr><h4 id="vec-is-empty"><a href="#vec-is-empty" class="headerlink" title="vec.is_empty"></a>vec.is_empty</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">fn</span> <span class="title function_">is_empty</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>没有元素就返回真，否则返回false</p><hr><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><h4 id="vec-resize"><a href="#vec-resize" class="headerlink" title="vec.resize"></a>vec.resize</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">resize</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_len: <span class="type">usize</span>, value: T)</span><br></pre></td></tr></table></figure><blockquote><p>Resizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="string">&quot;hello&quot;</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">resize</span>(<span class="number">3</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;world&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">resize</span>(<span class="number">2</span>, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-resize-with"><a href="#vec-resize-with" class="headerlink" title="vec.resize_with"></a>vec.resize_with</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">resize_with</span>&lt;F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, new_len: <span class="type">usize</span>, f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>() <span class="punctuation">-&gt;</span> T</span><br></pre></td></tr></table></figure><blockquote><p>Resizes the <code>Vec</code> in-place so that <code>len</code> is equal to <code>new_len</code>.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">resize_with</span>(<span class="number">5</span>, <span class="built_in">Default</span>::default);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = <span class="number">1</span>;</span><br><span class="line">vec.<span class="title function_ invoke__">resize_with</span>(<span class="number">4</span>, || &#123; p *= <span class="number">2</span>; p &#125;);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>]);</span><br></pre></td></tr></table></figure><hr><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><h4 id="vec-insert"><a href="#vec-insert" class="headerlink" title="vec.insert"></a>vec.insert</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="type">usize</span>, element: T)</span><br></pre></td></tr></table></figure><blockquote><p>Inserts an element at position <code>index</code> within the vector, shifting all elements after it to the right.</p></blockquote><p><strong>Panics</strong></p><p>Panics if <code>index &gt; len</code>.</p><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">vec.<span class="title function_ invoke__">insert</span>(<span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-push"><a href="#vec-push" class="headerlink" title="vec.push"></a>vec.push</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: T)</span><br></pre></td></tr></table></figure><blockquote><p>Appends an element to the back of a collection.</p></blockquote><p><strong>Panics</strong></p><p>Panics if the new capacity exceeds <code>isize::MAX</code> <em>bytes</em>.</p><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-append"><a href="#vec-append" class="headerlink" title="vec.append"></a>vec.append</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">append</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, other: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;T, A&gt;)</span><br></pre></td></tr></table></figure><blockquote><p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec2</span> = <span class="built_in">vec!</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">append</span>(&amp;<span class="keyword">mut</span> vec2);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec2, []);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-extend-from-slice"><a href="#vec-extend-from-slice" class="headerlink" title="vec.extend_from_slice"></a>vec.extend_from_slice</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">extend_from_slice</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, other: &amp;[T])</span><br></pre></td></tr></table></figure><blockquote><p>Clones and appends all elements in a slice to the <code>Vec</code>.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">extend_from_slice</span>(&amp;[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure><h4 id="vec-extend-from-within"><a href="#vec-extend-from-within" class="headerlink" title="vec.extend_from_within"></a>vec.extend_from_within</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">extend_from_within</span>&lt;R&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, src: R)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    R: RangeBounds&lt;<span class="type">usize</span>&gt;,</span><br></pre></td></tr></table></figure><blockquote><p>Given a range <code>src</code>, clones a slice of elements in that range and appends it to the end.</p><p><code>src</code> must be a range that can form a valid subslice of the <code>Vec</code>.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">characters</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line">characters.<span class="title function_ invoke__">extend_from_within</span>(<span class="number">2</span>..);</span><br><span class="line"><span class="built_in">assert_eq!</span>(characters, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">numbers</span> = <span class="built_in">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.<span class="title function_ invoke__">extend_from_within</span>(..<span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(numbers, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">strings</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;!&quot;</span>)];</span><br><span class="line">strings.<span class="title function_ invoke__">extend_from_within</span>(<span class="number">1</span>..=<span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(strings, [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-into-flattened"><a href="#vec-into-flattened" class="headerlink" title="vec.into_flattened"></a>vec.into_flattened</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">into_flattened</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;T, A&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Takes a <code>Vec&lt;[T; N]&gt;</code> and flattens it into a <code>Vec&lt;T&gt;</code>.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]];</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">flattened</span> = vec.<span class="title function_ invoke__">into_flattened</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(flattened.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><h4 id="vec-pop"><a href="#vec-pop" class="headerlink" title="vec.pop"></a>vec.pop</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">pop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Removes the last element from a vector and returns it, or None if it is empty.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">pop</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-pop-if"><a href="#vec-pop-if" class="headerlink" title="vec.pop_if"></a>vec.pop_if</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">pop_if</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, predicate: <span class="keyword">impl</span> <span class="title class_">FnOnce</span>(&amp;<span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Removes and returns the last element from a vector if the predicate returns <code>true</code>, or None if the predicate returns false or the vector is empty (the predicate will not be called in that case).</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">pred</span> = |x: &amp;<span class="keyword">mut</span> <span class="type">i32</span>| *x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">pop_if</span>(pred), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">pop_if</span>(pred), <span class="literal">None</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-truncate"><a href="#vec-truncate" class="headerlink" title="vec.truncate"></a>vec.truncate</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">truncate</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, len: <span class="type">usize</span>)</span><br></pre></td></tr></table></figure><blockquote><p> Shortens the vector, keeping the first <code>len</code> elements and dropping the rest.</p><p>If <code>len</code> is greater or equal to the vector’s current length, this has no effect.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">truncate</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-drain"><a href="#vec-drain" class="headerlink" title="vec.drain"></a>vec.drain</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">drain</span>&lt;R&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, range: R) <span class="punctuation">-&gt;</span> Drain&lt;<span class="symbol">&#x27;_</span>, T, A&gt; ⓘ</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    R: RangeBounds&lt;<span class="type">usize</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>drain</code> 会“抽干”Vec里指定索引范围的元素，返回一个迭代器 <code>Drain</code>，可以逐个访问这些被移除的元素。</p><p><code>R</code> 可以是任何表示索引范围的类型，比如：<code>0..3</code>、<code>2..</code>、<code>..5</code>。</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">u</span>: <span class="type">Vec</span>&lt;_&gt; = v.<span class="title function_ invoke__">drain</span>(<span class="number">1</span>..).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"><span class="built_in">assert_eq!</span>(v, &amp;[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(u, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A full range clears the vector, like `clear()` does</span></span><br><span class="line">v.<span class="title function_ invoke__">drain</span>(..);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v, &amp;[]);</span><br></pre></td></tr></table></figure><h4 id="vec-remove"><a href="#vec-remove" class="headerlink" title="vec.remove"></a>vec.remove</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> T</span><br></pre></td></tr></table></figure><blockquote><p> Removes and returns the element at position <code>index</code> within the vector, shifting all elements after it to the left.</p></blockquote><p><strong>Panics</strong></p><p>Panics if <code>index</code> is out of bounds.</p><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">remove</span>(<span class="number">1</span>), <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-swap-remove"><a href="#vec-swap-remove" class="headerlink" title="vec.swap_remove"></a><strong>vec.swap_remove</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">swap_remove</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, index: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> T</span><br></pre></td></tr></table></figure><blockquote><p>Removes an element from the vector and returns it.</p><p>The removed element is replaced by the last element of the vector.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">swap_remove</span>(<span class="number">1</span>), <span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v, [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;qux&quot;</span>, <span class="string">&quot;baz&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(v.<span class="title function_ invoke__">swap_remove</span>(<span class="number">0</span>), <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(v, [<span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-retain"><a href="#vec-retain" class="headerlink" title="vec.retain"></a>vec.retain</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">retain</span>&lt;F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br></pre></td></tr></table></figure><blockquote><p>Retains only the elements specified by the predicate.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">retain</span>(|&amp;x| x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">2</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-retain-mut"><a href="#vec-retain-mut" class="headerlink" title="vec.retain_mut"></a>vec.retain_mut</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">retain_mut</span>&lt;F&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, f: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnMut</span>(&amp;<span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> <span class="type">bool</span></span><br></pre></td></tr></table></figure><blockquote><p>Retains only the elements specified by the predicate, passing a mutable reference to it.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">vec.<span class="title function_ invoke__">retain_mut</span>(|x| <span class="keyword">if</span> *x &lt;= <span class="number">3</span> &#123;</span><br><span class="line">    *x += <span class="number">1</span>;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-clear"><a href="#vec-clear" class="headerlink" title="vec.clear"></a>vec.clear</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">clear</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Clears the vector, removing all values.</p><p>Note that this method has no effect on the allocated capacity of the vector.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">v.<span class="title function_ invoke__">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert!</span>(v.<span class="title function_ invoke__">is_empty</span>());</span><br></pre></td></tr></table></figure><h4 id="vec-split-off"><a href="#vec-split-off" class="headerlink" title="vec.split_off"></a>vec.split_off</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">split_off</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, at: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;T, A&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    A: <span class="built_in">Clone</span>,</span><br></pre></td></tr></table></figure><blockquote><p>Splits the collection into two at the given index.</p><p>Returns a newly allocated vector containing the elements in the range <code>[at, len)</code>.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">vec2</span> = vec.<span class="title function_ invoke__">split_off</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(vec2, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br></pre></td></tr></table></figure><hr><h4 id="vec-dedup"><a href="#vec-dedup" class="headerlink" title="vec.dedup"></a>vec.dedup</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">dedup</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Removes consecutive repeated elements in the vector according to the <code>PartialEq</code> trait implementation.</p><p>If the vector is sorted, this removes all duplicates.</p></blockquote><p><strong>Examples</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">vec.<span class="title function_ invoke__">dedup</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line">    vec.<span class="title function_ invoke__">sort</span>();</span><br><span class="line">    vec.<span class="title function_ invoke__">dedup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h1 id="std-collections"><a href="#std-collections" class="headerlink" title="std::collections"></a>std::collections</h1><h2 id="VecDeque"><a href="#VecDeque" class="headerlink" title="VecDeque"></a>VecDeque</h2><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="BTreeMap"><a href="#BTreeMap" class="headerlink" title="BTreeMap"></a>BTreeMap</h2><h2 id="BinaryHeap"><a href="#BinaryHeap" class="headerlink" title="BinaryHeap"></a>BinaryHeap</h2><h1 id="Cost-of-Collection-Operations"><a href="#Cost-of-Collection-Operations" class="headerlink" title="Cost of Collection Operations"></a>Cost of Collection Operations</h1><div class="table-container"><table><thead><tr><th></th><th>get(i)</th><th>insert(i)</th><th>remove(i)</th><th>append(Vec(m))</th><th>split_off(i)</th><th>range</th><th>append</th></tr></thead><tbody><tr><td><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a></td><td><em>O</em>(1)</td><td><em>O</em>(<em>n</em>-<em>i</em>)*</td><td><em>O</em>(<em>n</em>-<em>i</em>)</td><td><em>O</em>(<em>m</em>)*</td><td><em>O</em>(<em>n</em>-<em>i</em>)</td><td>N/A</td><td>N/A</td></tr><tr><td><a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a></td><td><em>O</em>(1)</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))*</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(<em>m</em>)*</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td>N/A</td><td>N/A</td></tr><tr><td><a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>LinkedList</code></a></td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td><em>O</em>(1)</td><td><em>O</em>(min(<em>i</em>, <em>n</em>-<em>i</em>))</td><td>N/A</td><td>N/A</td></tr><tr><td><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a></td><td><em>O</em>(1)~</td><td><em>O</em>(1)~*</td><td><em>O</em>(1)~</td><td>N/A</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a></td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(log(<em>n</em>))</td><td>N/A</td><td>N/A</td><td><em>O</em>(log(<em>n</em>))</td><td><em>O</em>(<em>n</em>+<em>m</em>)</td></tr></tbody></table></div><p>Note that where ties occur, <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> is generally going to be faster than <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a>, and <a href="https://doc.rust-lang.org/std/collections/struct.VecDeque.html"><code>VecDeque</code></a> is generally going to be faster than <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html"><code>LinkedList</code></a>.</p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2048 下一个更大的数值平衡数</title>
      <link href="/posts/2048/"/>
      <url>/posts/2048/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-20</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2048 下一个更大的数值平衡数" href="https://leetcode.cn/problems/next-greater-numerically-balanced-number/description/"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2048 下一个更大的数值平衡数</p><p class="url">https://leetcode.cn/problems/next-greater-numerically-balanced-number/description/</p></div></a></div></p><p>这种问题所有可能解稀疏的题直接打表，时间空间复杂度都为$O(1)$</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Solution</span>;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::sync::LazyLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> RESULT: LazyLock&lt;<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;&gt; = LazyLock::<span class="title function_ invoke__">new</span>(|| &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="number">1</span>, <span class="number">22</span>, <span class="number">122</span>, <span class="number">212</span>, <span class="number">221</span>, <span class="number">333</span>, <span class="number">1333</span>, <span class="number">3133</span>, <span class="number">3313</span>, <span class="number">3331</span>, <span class="number">4444</span>, <span class="number">14444</span>, <span class="number">22333</span>, <span class="number">23233</span>, <span class="number">23323</span>, <span class="number">23332</span>,</span><br><span class="line">        <span class="number">32233</span>, <span class="number">32323</span>, <span class="number">32332</span>, <span class="number">33223</span>, <span class="number">33232</span>, <span class="number">33322</span>, <span class="number">41444</span>, <span class="number">44144</span>, <span class="number">44414</span>, <span class="number">44441</span>, <span class="number">55555</span>, <span class="number">122333</span>,</span><br><span class="line">        <span class="number">123233</span>, <span class="number">123323</span>, <span class="number">123332</span>, <span class="number">132233</span>, <span class="number">132323</span>, <span class="number">132332</span>, <span class="number">133223</span>, <span class="number">133232</span>, <span class="number">133322</span>, <span class="number">155555</span>, <span class="number">212333</span>,</span><br><span class="line">        <span class="number">213233</span>, <span class="number">213323</span>, <span class="number">213332</span>, <span class="number">221333</span>, <span class="number">223133</span>, <span class="number">223313</span>, <span class="number">223331</span>, <span class="number">224444</span>, <span class="number">231233</span>, <span class="number">231323</span>, <span class="number">231332</span>,</span><br><span class="line">        <span class="number">232133</span>, <span class="number">232313</span>, <span class="number">232331</span>, <span class="number">233123</span>, <span class="number">233132</span>, <span class="number">233213</span>, <span class="number">233231</span>, <span class="number">233312</span>, <span class="number">233321</span>, <span class="number">242444</span>, <span class="number">244244</span>,</span><br><span class="line">        <span class="number">244424</span>, <span class="number">244442</span>, <span class="number">312233</span>, <span class="number">312323</span>, <span class="number">312332</span>, <span class="number">313223</span>, <span class="number">313232</span>, <span class="number">313322</span>, <span class="number">321233</span>, <span class="number">321323</span>, <span class="number">321332</span>,</span><br><span class="line">        <span class="number">322133</span>, <span class="number">322313</span>, <span class="number">322331</span>, <span class="number">323123</span>, <span class="number">323132</span>, <span class="number">323213</span>, <span class="number">323231</span>, <span class="number">323312</span>, <span class="number">323321</span>, <span class="number">331223</span>, <span class="number">331232</span>,</span><br><span class="line">        <span class="number">331322</span>, <span class="number">332123</span>, <span class="number">332132</span>, <span class="number">332213</span>, <span class="number">332231</span>, <span class="number">332312</span>, <span class="number">332321</span>, <span class="number">333122</span>, <span class="number">333212</span>, <span class="number">333221</span>, <span class="number">422444</span>,</span><br><span class="line">        <span class="number">424244</span>, <span class="number">424424</span>, <span class="number">424442</span>, <span class="number">442244</span>, <span class="number">442424</span>, <span class="number">442442</span>, <span class="number">444224</span>, <span class="number">444242</span>, <span class="number">444422</span>, <span class="number">515555</span>, <span class="number">551555</span>,</span><br><span class="line">        <span class="number">555155</span>, <span class="number">555515</span>, <span class="number">555551</span>, <span class="number">666666</span>, <span class="number">1224444</span>, <span class="number">1242444</span>, <span class="number">1244244</span>, <span class="number">1244424</span>, <span class="number">1244442</span>, <span class="number">1422444</span>,</span><br><span class="line">        <span class="number">1424244</span>, <span class="number">1424424</span>, <span class="number">1424442</span>, <span class="number">1442244</span>, <span class="number">1442424</span>, <span class="number">1442442</span>, <span class="number">1444224</span>, <span class="number">1444242</span>, <span class="number">1444422</span>, <span class="number">1666666</span>,</span><br><span class="line">        <span class="number">2124444</span>, <span class="number">2142444</span>, <span class="number">2144244</span>, <span class="number">2144424</span>, <span class="number">2144442</span>, <span class="number">2214444</span>, <span class="number">2241444</span>, <span class="number">2244144</span>, <span class="number">2244414</span>, <span class="number">2244441</span>,</span><br><span class="line">        <span class="number">2255555</span>, <span class="number">2412444</span>, <span class="number">2414244</span>, <span class="number">2414424</span>, <span class="number">2414442</span>, <span class="number">2421444</span>, <span class="number">2424144</span>, <span class="number">2424414</span>, <span class="number">2424441</span>, <span class="number">2441244</span>,</span><br><span class="line">        <span class="number">2441424</span>, <span class="number">2441442</span>, <span class="number">2442144</span>, <span class="number">2442414</span>, <span class="number">2442441</span>, <span class="number">2444124</span>, <span class="number">2444142</span>, <span class="number">2444214</span>, <span class="number">2444241</span>, <span class="number">2444412</span>,</span><br><span class="line">        <span class="number">2444421</span>, <span class="number">2525555</span>, <span class="number">2552555</span>, <span class="number">2555255</span>, <span class="number">2555525</span>, <span class="number">2555552</span>, <span class="number">3334444</span>, <span class="number">3343444</span>, <span class="number">3344344</span>, <span class="number">3344434</span>,</span><br><span class="line">        <span class="number">3344443</span>, <span class="number">3433444</span>, <span class="number">3434344</span>, <span class="number">3434434</span>, <span class="number">3434443</span>, <span class="number">3443344</span>, <span class="number">3443434</span>, <span class="number">3443443</span>, <span class="number">3444334</span>, <span class="number">3444343</span>,</span><br><span class="line">        <span class="number">3444433</span>, <span class="number">4122444</span>, <span class="number">4124244</span>, <span class="number">4124424</span>, <span class="number">4124442</span>, <span class="number">4142244</span>, <span class="number">4142424</span>, <span class="number">4142442</span>, <span class="number">4144224</span>, <span class="number">4144242</span>,</span><br><span class="line">        <span class="number">4144422</span>, <span class="number">4212444</span>, <span class="number">4214244</span>, <span class="number">4214424</span>, <span class="number">4214442</span>, <span class="number">4221444</span>, <span class="number">4224144</span>, <span class="number">4224414</span>, <span class="number">4224441</span>, <span class="number">4241244</span>,</span><br><span class="line">        <span class="number">4241424</span>, <span class="number">4241442</span>, <span class="number">4242144</span>, <span class="number">4242414</span>, <span class="number">4242441</span>, <span class="number">4244124</span>, <span class="number">4244142</span>, <span class="number">4244214</span>, <span class="number">4244241</span>, <span class="number">4244412</span>,</span><br><span class="line">        <span class="number">4244421</span>, <span class="number">4333444</span>, <span class="number">4334344</span>, <span class="number">4334434</span>, <span class="number">4334443</span>, <span class="number">4343344</span>, <span class="number">4343434</span>, <span class="number">4343443</span>, <span class="number">4344334</span>, <span class="number">4344343</span>,</span><br><span class="line">        <span class="number">4344433</span>, <span class="number">4412244</span>, <span class="number">4412424</span>, <span class="number">4412442</span>, <span class="number">4414224</span>, <span class="number">4414242</span>, <span class="number">4414422</span>, <span class="number">4421244</span>, <span class="number">4421424</span>, <span class="number">4421442</span>,</span><br><span class="line">        <span class="number">4422144</span>, <span class="number">4422414</span>, <span class="number">4422441</span>, <span class="number">4424124</span>, <span class="number">4424142</span>, <span class="number">4424214</span>, <span class="number">4424241</span>, <span class="number">4424412</span>, <span class="number">4424421</span>, <span class="number">4433344</span>,</span><br><span class="line">        <span class="number">4433434</span>, <span class="number">4433443</span>, <span class="number">4434334</span>, <span class="number">4434343</span>, <span class="number">4434433</span>, <span class="number">4441224</span>, <span class="number">4441242</span>, <span class="number">4441422</span>, <span class="number">4442124</span>, <span class="number">4442142</span>,</span><br><span class="line">        <span class="number">4442214</span>, <span class="number">4442241</span>, <span class="number">4442412</span>, <span class="number">4442421</span>, <span class="number">4443334</span>, <span class="number">4443343</span>, <span class="number">4443433</span>, <span class="number">4444122</span>, <span class="number">4444212</span>, <span class="number">4444221</span>,</span><br><span class="line">        <span class="number">4444333</span>, <span class="number">5225555</span>, <span class="number">5252555</span>, <span class="number">5255255</span>, <span class="number">5255525</span>, <span class="number">5255552</span>, <span class="number">5522555</span>, <span class="number">5525255</span>, <span class="number">5525525</span>, <span class="number">5525552</span>,</span><br><span class="line">        <span class="number">5552255</span>, <span class="number">5552525</span>, <span class="number">5552552</span>, <span class="number">5555225</span>, <span class="number">5555252</span>, <span class="number">5555522</span>, <span class="number">6166666</span>, <span class="number">6616666</span>, <span class="number">6661666</span>, <span class="number">6666166</span>,</span><br><span class="line">        <span class="number">6666616</span>, <span class="number">6666661</span>, <span class="number">7777777</span>,</span><br><span class="line">    ];</span><br><span class="line">    vec</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_beautiful_number</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hash_map</span>: HashMap&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = n;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">curr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">            curr = i % <span class="number">10</span>;</span><br><span class="line">            vec.<span class="title function_ invoke__">push</span>(curr);</span><br><span class="line">            hash_map.<span class="title function_ invoke__">entry</span>(curr).<span class="title function_ invoke__">and_modify</span>(|a| *a += <span class="number">1</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">1</span>);</span><br><span class="line">            i = i / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vec &#123;</span><br><span class="line">            <span class="keyword">if</span> hash_map.<span class="title function_ invoke__">get</span>(&amp;val).<span class="title function_ invoke__">is_some_and</span>(|&amp;count| count != val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_beautiful_number</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> <span class="number">0</span>..=<span class="number">1000_0000</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Solution::<span class="title function_ invoke__">is_beautiful_number</span>(val)) &#123;</span><br><span class="line">                vec.<span class="title function_ invoke__">push</span>(val);</span><br><span class="line">                <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125;,&quot;</span>, val)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">next_beautiful_number</span>(n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &amp;val <span class="keyword">in</span> RESULT.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> val &gt; n &#123;</span><br><span class="line">                <span class="keyword">return</span> val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Solution::<span class="title function_ invoke__">get_beautiful_number</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 打表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P101 对称二叉树</title>
      <link href="/posts/101/"/>
      <url>/posts/101/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P101 对称二叉树" href="https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P101 对称二叉树</p><p class="url">https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>递归，对称比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line"><span class="built_in">TreeNode</span>()</span><br><span class="line">: <span class="built_in">val</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">right</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x)</span><br><span class="line">: <span class="built_in">val</span>(x)</span><br><span class="line">, <span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">right</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right)</span><br><span class="line">: <span class="built_in">val</span>(x)</span><br><span class="line">, <span class="built_in">left</span>(left)</span><br><span class="line">, <span class="built_in">right</span>(right)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(TreeNode *left, TreeNode *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">    right-&gt;val == left-&gt;val) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">isSame</span>(left-&gt;right, right-&gt;left) &amp;&amp;</span><br><span class="line">       <span class="built_in">isSame</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">isSame</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非递归写法，迭代，把结点入队两次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            left = que.<span class="built_in">front</span>(); </span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            right = que.<span class="built_in">front</span>(); </span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意这里的对称入队顺序</span></span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P226 翻转二叉树</title>
      <link href="/posts/226/"/>
      <url>/posts/226/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P226 翻转二叉树" href="https://leetcode.cn/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P226 翻转二叉树</p><p class="url">https://leetcode.cn/problems/invert-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>先序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function">TreeNode *<span class="title">invertTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line"><span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P100 相同的树</title>
      <link href="/posts/100/"/>
      <url>/posts/100/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P100 相同的树" href="https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P100 相同的树</p><p class="url">https://leetcode.cn/problems/same-tree/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>递归遍历，先序遍历，如果两个树相同，那么它们根节点一定相同并且它们的左子树相同，右子树也相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line"><span class="built_in">TreeNode</span>()</span><br><span class="line">: <span class="built_in">val</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">right</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x)</span><br><span class="line">: <span class="built_in">val</span>(x)</span><br><span class="line">, <span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">right</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right)</span><br><span class="line">: <span class="built_in">val</span>(x)</span><br><span class="line">, <span class="built_in">left</span>(left)</span><br><span class="line">, <span class="built_in">right</span>(right)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">nullptr</span> &amp;&amp; q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp;</span><br><span class="line">       <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// p or q is nullptr</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>rust 可以一句话结束，因为 TreeNode 实现了 PartialEq, Eq, 🤣🤣🤣</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> val: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> left: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> right: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(val: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        TreeNode &#123;</span><br><span class="line">            val,</span><br><span class="line">            left: <span class="literal">None</span>,</span><br><span class="line">            right: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Solution</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">is_same_tree</span>(</span><br><span class="line">        p: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span><br><span class="line">        q: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        p == q</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P104 二叉树的最大深度</title>
      <link href="/posts/104/"/>
      <url>/posts/104/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P104 二叉树的最大深度" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P104 二叉树的最大深度</p><p class="url">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>一颗二叉树的最大深度等于它左子树的最大深度和右子树最大深度的最大值+1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left)<span class="number">+1</span>, <span class="built_in">maxDepth</span>(root-&gt;right)<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>层次遍历每次记住每层的个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line"><span class="built_in">TreeNode</span>()</span><br><span class="line">: <span class="built_in">val</span>(<span class="number">0</span>)</span><br><span class="line">, <span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">right</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x)</span><br><span class="line">: <span class="built_in">val</span>(x)</span><br><span class="line">, <span class="built_in">left</span>(<span class="literal">nullptr</span>)</span><br><span class="line">, <span class="built_in">right</span>(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right)</span><br><span class="line">: <span class="built_in">val</span>(x)</span><br><span class="line">, <span class="built_in">left</span>(left)</span><br><span class="line">, <span class="built_in">right</span>(right)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 层次遍历求最大深度</span></span><br><span class="line"><span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">std::queue&lt;TreeNode *&gt; que;</span><br><span class="line"></span><br><span class="line">TreeNode *tmp;</span><br><span class="line"><span class="type">int</span> i, qsize;</span><br><span class="line">que.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">qsize = que.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; qsize; i++) &#123;</span><br><span class="line">tmp = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">que.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">que.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">depth++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rust实现<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq, Eq)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> val: <span class="type">i32</span>,</span><br><span class="line">    <span class="keyword">pub</span> left: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> right: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(val: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        TreeNode &#123;</span><br><span class="line">            val,</span><br><span class="line">            left: <span class="literal">None</span>,</span><br><span class="line">            right: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Solution</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">max_depth</span>(root: <span class="type">Option</span>&lt;Rc&lt;RefCell&lt;TreeNode&gt;&gt;&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">depth</span> = <span class="number">0_i32</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">length</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">que</span> = VecDeque::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(root) = root &#123;</span><br><span class="line">            que.<span class="title function_ invoke__">push_back</span>(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> !que.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            length = que.<span class="title function_ invoke__">len</span>();</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..length &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(node) = que.<span class="title function_ invoke__">front</span>() &#123;</span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">node</span> = Rc::<span class="title function_ invoke__">clone</span>(node); </span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">node_ref</span> = node.<span class="title function_ invoke__">borrow</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 先处理再 pop_front</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(left) = &amp;node_ref.left &#123;</span><br><span class="line">                        que.<span class="title function_ invoke__">push_back</span>(Rc::<span class="title function_ invoke__">clone</span>(left));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(right) = &amp;node_ref.right &#123;</span><br><span class="line">                        que.<span class="title function_ invoke__">push_back</span>(Rc::<span class="title function_ invoke__">clone</span>(right));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                    que.<span class="title function_ invoke__">pop_front</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            depth += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3461 判断操作后字符串中的数字是否相等 I</title>
      <link href="/posts/3461/"/>
      <url>/posts/3461/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3461 判断操作后字符串中的数字是否相等 I" href="https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-i/description/?envType=daily-question&envId=2025-10-23"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3461 判断操作后字符串中的数字是否相等 I</p><p class="url">https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-i/description/?envType=daily-question&envId=2025-10-23</p></div></a></div></p><p>这个就是杨辉三角，这里我们直接模拟即可。用队列来实现，注意要区分第一个和最后一个，因为这两个数在加法并取余中只用到了一次。因此我们用-1 做为标识。表示-1 前面这个数字为最后一个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasSameDigits</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="type">int</span> val1, val2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">que.<span class="built_in">push</span>(ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">que.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (que.<span class="built_in">size</span>() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">val1 = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">val2 = que.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">if</span> (val2 == <span class="number">-1</span>) &#123;</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">que.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">que.<span class="built_in">push</span>((val1 + val2) % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (que.<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">val1 = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">val2 = que.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">if</span> (val1 == val2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust language advanced</title>
      <link href="/posts/42972/"/>
      <url>/posts/42972/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-22</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="函数式语言特性-迭代器和闭包"><a href="#函数式语言特性-迭代器和闭包" class="headerlink" title="函数式语言特性:迭代器和闭包"></a>函数式语言特性:迭代器和闭包</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Rust 的 <strong>闭包</strong>（<em>closures</em>）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数</p><ul><li>匿名函数</li><li>保存为变量,作为参数</li><li>可以在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</li><li>可从其定义的作用域捕获值</li></ul><p>文件名: src/main.rs</p><p>一个用来代替假定计算的函数，它大约会执行两秒钟</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">simulated_expensive_calculation</span>(intensity: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    intensity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件名: src/main.rs</p><p>程序的业务逻辑，它根据输入并调用 simulated_expensive_calculation 函数来打印出健身计划</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件名: src/main.rs</p><p>main 函数包含了用于 generate_workout 函数的模拟用户输入和模拟随机数输入</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">simulated_user_specified_value</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">simulated_random_number</span> = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">generate_workout</span>(simulated_user_specified_value, simulated_random_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">       thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">       num</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><ul><li>闭包定义是 expensive_closure 赋值的 = 之后的部分。闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数；</li><li>如果<strong>有多于一个参数，可以使用逗号分隔，比如 |param1, param2|</strong>。</li><li>参数之后是存放闭包体的大括号 —— <strong>如果闭包体只有一行则大括号是可以省略的</strong>。大括号之后闭包的结尾，需要用于 let 语句的分号。因为闭包体的最后一行没有分号（正如函数体一样），所以闭包体（num）最后一行的返回值作为调用闭包时的返回值 。</li></ul><p>注意:</p><p>这个 let 语句意味着 expensive_closure 包含一个匿名函数的 <strong>定义</strong>，不是调用匿名函数的 <strong>返回值</strong>。</p><p><strong>重构代码</strong></p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">expensive_closure</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包的类型推断"><a href="#闭包的类型推断" class="headerlink" title="闭包的类型推断"></a>闭包的类型推断</h3><ul><li><strong>闭包不要求标注参数和返回值的类型</strong></li><li>闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型</li><li>可以手动添加类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>与函数的比较</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;<span class="comment">//函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;<span class="comment">//闭包</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;<span class="comment">//闭包</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;<span class="comment">//闭包</span></span><br></pre></td></tr></table></figure><p>src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这个闭包在执行第二行代码时，编译器就能确定该闭包的类型是 String 了，而在执行第三行时就会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   Compiling rust_programming v0.1.0 (/home/zhaohang/repository/rust_programming)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:4:29</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> n = example_closure(5);</span><br><span class="line">  |             --------------- ^ expected `String`, found <span class="built_in">integer</span></span><br><span class="line">  |             |</span><br><span class="line">  |             arguments to this <span class="keyword">function</span> are incorrect</span><br><span class="line">  |</span><br><span class="line">note: expected because the closure was earlier called with an argument of <span class="built_in">type</span> `String`</span><br><span class="line"> --&gt; src/main.rs:3:29</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="built_in">let</span> s = example_closure(String::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of <span class="built_in">type</span> `String`</span><br><span class="line">  |             |</span><br><span class="line">  |             <span class="keyword">in</span> this closure call</span><br><span class="line">note: closure parameter defined here</span><br><span class="line"> --&gt; src/main.rs:2:28</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> example_closure = |x| x;</span><br><span class="line">  |                            ^</span><br><span class="line"><span class="built_in">help</span>: try using a conversion method</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> n = example_closure(5.to_string());</span><br><span class="line">  |                              ++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br></pre></td></tr></table></figure><h3 id="泛型参数闭包"><a href="#泛型参数闭包" class="headerlink" title="泛型参数闭包"></a>泛型参数闭包</h3><p>在上面的代码仍然把慢计算闭包调用了比所需更多的次数。解决这个问题的一个方法是在全部代码中的每一个需要多个慢计算闭包结果的地方，可以将结果保存进变量以供复用，这样就可以使用变量而不是再次调用闭包。但是这样就会有很多重复的保存结果变量的地方。</p><p>幸运的是，还有另一个可用的方案。可以<strong>创建一个存放闭包和调用闭包结果的结构体</strong>。该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值。你可能见过这种模式被称 <strong>*memoization*</strong> 或 <strong>*lazy evaluation**</strong>（惰性求值）*。</p><h4 id="如何让-struct-持有闭包"><a href="#如何让-struct-持有闭包" class="headerlink" title="如何让 struct 持有闭包"></a>如何让 struct 持有闭包</h4><ul><li>struct 的定义需要知道所有字段的类型，即需要指明闭包的类型</li><li><strong>每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样</strong></li><li>所以需要使用:泛型和 Trait Bound</li></ul><p><strong>Fn Trait</strong></p><ul><li>由标准库提供</li><li><strong>所有的闭包都至少实现了以下 trait 之一:</strong><ul><li><strong>Fn</strong></li><li><strong>FnMut</strong></li><li><strong>FnOnce</strong></li></ul></li></ul><p>注意：<strong>函数也都实现了这三个</strong> <strong>Fn</strong> <strong>trait</strong>。如果不需要捕获环境中的值，则可以使用实现了 Fn trait 的函数而不是闭包。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体 Cacher 有一个泛型 T 的字段 calculation。</p><p>T 的 trait bound 指定了 T 是一个使用 Fn 的闭包。</p><p>任何我们希望储存到 Cacher 实例的 calculation 字段的闭包必须有一个 u32 参数（由 Fn 之后的括号的内容指定）并必须返回一个 u32（由 -&gt; 之后的内容）。</p><p>字段 value 是 Option<u32> 类型的。在执行闭包之前，value 将是 None。如果使用 Cacher 的代码请求闭包的结果，这时会执行闭包并将结果储存在 value 字段的 Some 成员中。接着<strong>如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 Some 成员中的结果</strong>。</p><p>重构代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">expensive_result</span> = Cacher::<span class="title function_ invoke__">new</span>(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, expensive_result.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, expensive_result.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                expensive_result.<span class="title function_ invoke__">value</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Cacher-实现的限制"><a href="#Cacher-实现的限制" class="headerlink" title="Cacher 实现的限制"></a>Cacher 实现的限制</h4><ol><li>第一个问题是 Cacher 实例假设对于 value 方法的任何 arg 参数值总是会返回相同的值。</li></ol><p><strong>解决方案</strong>：</p><p>可以使用 HashMap 代替单个值:</p><ul><li><p>key: arg 参数</p></li><li><p>value: 执行闭包的结果</p></li></ul><ol><li>第二个问题是只能接收一个 u32 类型的参数和 u32 类型的返回值</li></ol><p><strong>解决方案:</strong></p><p>引入两个或多个泛型参数</p><h3 id="闭包会捕获其环境"><a href="#闭包会捕获其环境" class="headerlink" title="闭包会捕获其环境"></a>闭包会捕获其环境</h3><ul><li>可以捕获其环境并访问其被定义的作用域的变量,而普通函数则不能</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>闭包<strong>会产生内存开销</strong><br> 闭包在 Rust 中是一个编译器生成的匿名结构体，结构体的字段就是捕获的变量。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器内部类似：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>, <span class="comment">// 捕获的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Fn</span>() <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>捕获变量需要存储空间</strong></p><ul><li>如果捕获的是<strong>值</strong>，闭包会在自身结构体中存储该值。</li><li>如果捕获的是<strong>引用</strong>，闭包结构体中存储的是指针（引用本身也占空间）。</li></ul><p><strong>开销大小</strong></p><ul><li><strong>小变量（如 i32, bool）</strong>：几乎没有额外开销，存储在闭包的结构体里即可。</li><li><strong>大变量（如 String, Vec, HashMap）</strong>：<ul><li>如果 <code>move</code> 捕获，闭包会拷贝或移动整个对象（堆内存可能被绑定到闭包）。</li><li>如果只是引用捕获，闭包内部只存指针，但要保证引用生命周期有效。</li></ul></li></ul><h4 id="闭包从所在环境捕获值的方式"><a href="#闭包从所在环境捕获值的方式" class="headerlink" title="闭包从所在环境捕获值的方式"></a>闭包从所在环境捕获值的方式</h4><p>与函数获得参数的三种方式一样:</p><ul><li><p>取得所有权: <strong>FnOnce</strong></p><ul><li>FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 <strong>环境</strong>，<em>environment</em>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li></ul></li><li><p>可变借用: <strong>FnMut</strong></p><ul><li>FnMut 获取可变的借用值所以可以改变其环境</li></ul></li><li><p>不可变借用: <strong>Fn</strong></p><ul><li>Fn 从其环境获取不可变的借用值</li></ul></li></ul><p>创建闭包时，通过闭包对环境值的使用，Rust 推断出具体使用哪个 trait：</p><ul><li><strong>所有的闭包都实现了 FnOnce</strong></li><li><strong>没有移动捕获变量的实现了 FnMut</strong></li><li><strong>无需可变访问捕获变量的闭包实现了 Fn</strong></li></ul><p>实际上有一个层级关系，所有实现了 Fn 的都实现了 FnMut，所有实现了 FnMut 的，都实现了 FnOnce</p><h4 id="move-关键字"><a href="#move-关键字" class="headerlink" title="move 关键字"></a>move 关键字</h4><p>在参数列表前<strong>使用 move 关键字，可以强制闭包取得它所使用的环境值得所有权</strong></p><ul><li>当<strong>将闭包传递给新线程以移动数据使其归新线程所有</strong>时，此技术最为有用</li></ul><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x 被移动进了闭包，因为闭包使用 move 关键字定义。接着闭包获取了 x 的所有权，同时 main 就不再允许在 println! 语句中使用 x 了。去掉 println! 即可修复问题。</p><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>当指定 Fn trait bound 之一时，首先用 Fn,基于闭包体里得情况，如果需要 FnOnce 或 FnMut，编译器会再告诉你 </p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器模式允许你对一个序列的项进行某些处理。<strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑。当使用迭代器时，我们无需重新实现这些逻辑。</p><p>在 Rust 中，<strong>迭代器是 惰性的（<em>lazy</em>）</strong>，这意味着在调用方法使用迭代器之前它都不会有效果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br></pre></td></tr></table></figure><h3 id="Iterator-trait"><a href="#Iterator-trait" class="headerlink" title="Iterator trait"></a>Iterator trait</h3><ul><li>所有迭代器都实现了这个 trait</li><li>定义于标准库</li></ul><p>这个 trait 的定义看起来像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>type Item 和 Self::Item，他们定义了 trait 的 <strong>关联类型</strong>（<em>associated type</em>）。</p><p>这段代码表明实现 Iterator trait 要求同时<strong>定义一个</strong> <strong>Item</strong> <strong>类型</strong>，这个 Item 类型被用作 <strong>next</strong> <strong>方法的返回值类型</strong>。换句话说，Item 类型将是迭代器返回元素的类型。</p><p>Iterator trait 仅要求实现一个方法：next</p><p>next:</p><ul><li>每次返回迭代中的一项</li><li>返回结果包裹在 Some 里</li><li>迭代结束，返回 None</li></ul><p>可直接在迭代器上调用 next 方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">iterator_demonstration</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>v1_iter 需要是可变的：在迭代器上调用 next 方法改变了迭代器中用来记录序列位置的状态。换句话说，代码 <strong>消费</strong>（consume）了，或使用了迭代器。每一个 next 调用都会从迭代器中消费一个项。</li><li>使用 for 循环时无需使 v1_iter 可变因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变。</li></ul><h4 id="几个迭代方法"><a href="#几个迭代方法" class="headerlink" title="几个迭代方法"></a>几个迭代方法</h4><ul><li><strong>iter</strong> 方法：在<strong>不可变引用上创建迭代器</strong>（元素的不可变引用）</li><li><strong>into_iter</strong> 方法：创建的<strong>迭代器会获得所有权</strong></li><li><strong>iter_mut</strong> 方法: <strong>迭代可变的引用</strong></li></ul><h3 id="消耗迭代器的方法"><a href="#消耗迭代器的方法" class="headerlink" title="消耗迭代器的方法"></a>消耗迭代器的方法</h3><ul><li>在标准库中，Iterator trait 由一些带默认实现的方法</li><li>其中有一些方法会调用 next 方法</li></ul><p>实现 Iterator trait 时必须实现 next 方法的原因之一</p><ul><li>调用 next 的叫做“<strong>消耗型适配器</strong>”</li></ul><p>因为调用它们会把迭代器耗尽</p><p>一个消费适配器的例子是 sum 方法。这个方法获取迭代器的所有权并反复调用 next 来遍历迭代器，因而会消费迭代器。当其遍历每一个项时，它将每一个项加总到一个总和并在迭代完成时返回总和。</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">iterator_sum</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="产生其它迭代器的方法"><a href="#产生其它迭代器的方法" class="headerlink" title="产生其它迭代器的方法"></a>产生其它迭代器的方法</h3><p>Iterator trait 中定义了另一类方法，被称为 <strong>迭代器适配器</strong>（<em>iterator adaptors</em>），</p><ul><li>他们允许将当前迭代器变为不同类型的迭代器。</li><li>可以链式调用多个迭代器适配器。</li><li>不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。</li></ul><p>文件名: src/main.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let v1: Vec&lt;i32&gt; = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    v1.iter().map(|x| x + 1);</span><br></pre></td></tr></table></figure><p>该 map 方法使用闭包来调用每个元素以生成新的迭代器。 这里的闭包创建了一个新的迭代器，对其中 vector 中的每个元素都被加 1。</p><p>不过这些代码会产生一个警告：</p><p>= note: iterators are lazy and do nothing unless consumed</p><p><strong>代码实际上并没有做任何事；所指定的闭包从未被调用过</strong>。警告提醒了我们为什么：<strong>迭代器适配器是惰性的</strong>，而这里我们需要消费迭代器。</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure><p>第二行代码的下划线实际上是让编译器去推断他的类型</p><p>collect 方法是一个<strong>消耗型适配器</strong>，把结果收集到一个集合类型中</p><p>因为 map 获取一个闭包，可以指定任何希望在遍历的每个元素上执行的操作。这是一个展示如何使用闭包来自定义行为同时又复用 Iterator trait 提供的迭代行为的绝佳例子。</p><h3 id="使用闭包捕获环境"><a href="#使用闭包捕获环境" class="headerlink" title="使用闭包捕获环境"></a>使用闭包捕获环境</h3><p>filter 方法过滤器</p><ul><li>迭代器的 filter 方法获取一个使用迭代器的每一个项并返回布尔值的闭包。</li><li>如果闭包返回 true，其值将会包含在 filter 提供的新迭代器中。</li><li>如果闭包返回 false，其值不会包含在结果迭代器中。</li></ul><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shoe</span> &#123;</span><br><span class="line">    size: <span class="type">u32</span>,</span><br><span class="line">    style: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size).<span class="title function_ invoke__">collect</span>()</span><br><span class="line">    <span class="comment">//闭包从环境中捕获了 `shoe_size` 变量并使用其值与每一只鞋的大小作比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">filters_by_size</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shoes</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">10</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">13</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sandal&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">10</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">in_my_size</span> = <span class="title function_ invoke__">shoes_in_size</span>(shoes, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            in_my_size,</span><br><span class="line">            <span class="built_in">vec!</span>[</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: <span class="number">10</span>,</span><br><span class="line">                    style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: <span class="number">10</span>,</span><br><span class="line">                    style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shoes_in_my_size 函数获取一个鞋子 vector 的所有权和一个鞋子大小作为参数。它返回一个只包含指定大小鞋子的 vector。</p><p>shoes_in_my_size 函数体中调用了 into_iter 来创建一个获取 vector 所有权的迭代器。接着调用 filter 将这个迭代器适配成一个只含有那些闭包返回 true 的元素的新迭代器。</p><p>闭包从环境中捕获了 shoe_size 变量并使用其值与每一只鞋的大小作比较，只保留指定大小的鞋子。最终，调用 collect 将迭代器适配器返回的值收集进一个 vector 并返回。</p><h3 id="创建自定义迭代器"><a href="#创建自定义迭代器" class="headerlink" title="创建自定义迭代器"></a>创建自定义迭代器</h3><p>trait Iterator定义中唯一要求提供的方法就是 next 方法。一旦定义了它，就可以使用所有其他由 Iterator trait 提供的拥有默认实现的方法来创建自定义迭代器了！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="comment">//这里将迭代器的关联类型 Item 设置为 u32，意味着迭代器会返回 u32 值集合。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 count 值小于 6，next 会返回封装在 Some 中的当前值，</span></span><br><span class="line">        <span class="comment">//不过如果 count 大于或等于 6，迭代器会返回 None。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">calling_next_directly</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过定义 next 方法实现 Iterator trait，我们现在就可以使用任何标准库定义的拥有默认实现的 Iterator trait 方法了，因为他们都使用了 next 方法的功能。</p><p>例如，出于某种原因我们希望获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在<strong>省略了第一个值</strong>之后产生的值配对，<strong>将每一对值相乘</strong>，<strong>只保留那些可以被三整除的结果</strong>，<strong>然后将所有保留的结果相加</strong>，这可以如示例 13-23 中的测试这样做：</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">using_other_iterator_trait_methods</span>() &#123;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">           .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">           .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">           .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">           .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">       <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>示例 13-23：使用自定义的 Counter 迭代器的多种方法，注意Counter本身就是Iterator</p><p>注意 zip 只产生四对值；理论上第五对值 (5, None) 从未被产生，因为 zip 在任一输入迭代器返回 None 时也返回 None。</p><p>所有这些方法调用都是可能的，因为我们指定了 next 方法如何工作，而标准库则提供了其它调用 next 的方法的默认实现。</p><h3 id="改进-I-O-项目"><a href="#改进-I-O-项目" class="headerlink" title="改进 I/O 项目"></a>改进 I/O 项目</h3><h4 id="使用迭代器并去掉-clone"><a href="#使用迭代器并去掉-clone" class="headerlink" title="使用迭代器并去掉 clone"></a>使用迭代器并去掉 clone</h4><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接使用-env-args-返回的迭代器"><a href="#直接使用-env-args-返回的迭代器" class="headerlink" title="直接使用 env::args 返回的迭代器"></a>直接使用 env::args 返回的迭代器</h4><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//let args: Vec&lt;String&gt; = env::args().collect();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(&amp;config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;With text:\n&#123;&#125;&quot;, contents);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(<span class="keyword">mut</span> args: std::env::Args) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// if args.len() &lt; 3 &#123;</span></span><br><span class="line">        <span class="comment">//     return Err(&quot;not enough arguments&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        args.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(arg) =&gt; arg,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Didn&#x27;t get a query string&quot;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(arg) =&gt; arg,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Didn&#x27;t get a file name&quot;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// println!(&quot;Search for &#123;&#125;&quot;, query);</span></span><br><span class="line">        <span class="comment">// println!(&quot;In file &#123;&#125;&quot;, filename);</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// let mut result = Vec::new();</span></span><br><span class="line">    <span class="comment">// for line in contents.lines() &#123;</span></span><br><span class="line">    <span class="comment">//     if line.contains(query) &#123;</span></span><br><span class="line">    <span class="comment">//         result.push(line);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// result</span></span><br><span class="line"></span><br><span class="line">    contents</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// let mut result = Vec::new();</span></span><br><span class="line">    <span class="comment">// let query = query.to_lowercase();</span></span><br><span class="line">    <span class="comment">// for line in contents.lines() &#123;</span></span><br><span class="line">    <span class="comment">//     if line.to_lowercase().contains(&amp;query) &#123;</span></span><br><span class="line">    <span class="comment">//         result.push(line);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// result</span></span><br><span class="line">    contents</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(query.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">as_str</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,args);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments:&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config)&#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Application error: &#123;&#125;&quot;</span>,e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能比较-循环-迭代器"><a href="#性能比较-循环-迭代器" class="headerlink" title="性能比较 循环/迭代器"></a>性能比较 循环/迭代器</h3><p>代器是 Rust 的 <strong>零成本抽象</strong>（<em>zero-cost abstractions</em>）之一，它意味着抽象并不会引入运行时开销，它与Bjarne Stroustrup（C++ 的设计和实现者）在 “Foundations of C++”（2012） 中所定义的 <strong>零开销</strong>（<em>zero-overhead</em>）如出一辙：</p><p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</p><ul><li>Bjarne Stroustrup “Foundations of C++”</li></ul><p>从整体来说，C++ 的实现遵循了零开销原则：你不需要的，无需为他们买单。更有甚者的是：你需要的时候，也不可能找到其他更好的代码了。</p><ul><li>本贾尼·斯特劳斯特卢普 “Foundations of C++”</li></ul><h1 id="Cargo-和-crates-io"><a href="#Cargo-和-crates-io" class="headerlink" title="Cargo 和 crates.io"></a>Cargo 和 crates.io</h1><h2 id="采用发布配置自定义构建"><a href="#采用发布配置自定义构建" class="headerlink" title="采用发布配置自定义构建"></a>采用发布配置自定义构建</h2><p><strong>release profile</strong></p><ul><li>是预定义的</li><li>可自定义</li><li>每个 profile 配置独立于其它 profile</li></ul><p>cargo 主要的两个 profile</p><ul><li><strong>dev profile</strong>: 适用于开发 cargo build</li><li><strong>release profile</strong>: 适用于发布 cargo build —release</li></ul><h3 id="自定义-profile"><a href="#自定义-profile" class="headerlink" title="自定义 profile"></a>自定义 profile</h3><p>在 Cargo.toml 中添加[profile.xxxx]区域，在里面覆盖某人配置的子集</p><p>文件名: Cargo.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>opt-level 设置控制 Rust 会对代码进行何种程度的优化。这个配置的值从 0 到 3。越高的优化级别需要更多的时间编译，所以如果你在进行开发并经常编译，可能会希望在牺牲一些代码性能的情况下编译得快一些。这就是为什么 dev 的 opt-level 默认为 0。</p><h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ul><li>生成 HTML 文档</li><li>显示公共 Api 的文档注释: 如何使用 API</li><li>使用///</li><li>支持 Markdown</li><li>放置在说明条目前</li></ul><h3 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h3><p>运行 rustdoc 工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc</span><br></pre></td></tr></table></figure><p>把生成的文档放到 target/doc 下</p><h3 id="生成文档并浏览"><a href="#生成文档并浏览" class="headerlink" title="生成文档并浏览"></a>生成文档并浏览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc --open</span><br></pre></td></tr></table></figure><h3 id="常用章节"><a href="#常用章节" class="headerlink" title="常用章节"></a>常用章节</h3><p>#Examples</p><p>其它常用章节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Panics: 函数可能发生panic的场景</span><br><span class="line">Errors: 如果函数返回Result,描述可能的错误种类，以及可导致错误的条件</span><br><span class="line">Safety: 如果函数处于unsafe调用，就应该解释函数unsafe的原因，以及调用者确保的使用前提</span><br></pre></td></tr></table></figure><h3 id="文档注释作为测试"><a href="#文档注释作为测试" class="headerlink" title="文档注释作为测试"></a>文档注释作为测试</h3><p>运行 cargo test： 把文档注释中的示例代码作为测试来运行</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let arg = 5;</span></span><br><span class="line"><span class="comment">/// let answer = my_crate::add_one(arg);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(6, answer);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试 cargo test 运行像示例中 add_one 函数的文档；应该在测试结果中看到像这样的部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Doc-tests my_crate</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> src/lib.rs - add_one (line 5) ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.27s</span><br></pre></td></tr></table></figure><p>现在尝试改变函数或例子来使例子中的 assert_eq! 产生 panic。再次运行 cargo test，我们将会看到文档测试捕获到了例子与代码不再同步！</p><h3 id="为包含注释的项添加文档注释"><a href="#为包含注释的项添加文档注释" class="headerlink" title="为包含注释的项添加文档注释"></a>为包含注释的项添加文档注释</h3><ul><li>符号: //!</li><li>这类注释通常描述 crate 和模块</li></ul><p>crate root (按惯例 src/lib.rs)</p><p>一个模块内，将 crate 或模块作为一个整体进行记录</p><p>例子：</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # My Crate</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `my_crate` is a collection of utilities to make performing certain</span></span><br><span class="line"><span class="comment">//! calculations more convenient.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure><h2 id="使用-pub-use-导出方便使用的公共-API"><a href="#使用-pub-use-导出方便使用的公共-API" class="headerlink" title="使用 pub use 导出方便使用的公共 API"></a>使用 pub use 导出方便使用的公共 API</h2><p>你开发时候使用的文件架构可能并不方便用户。你的结构可能是一个包含多个层级的分层结构，不过这对于用户来说并不方便。这是因为想要使用被定义在很深层级中的类型的人可能很难发现这些类型的存在。他们也可能会厌烦要使用 use my_crate::some_module::another_module::UsefulType; 而不是 use my_crate::UsefulType; 来使用类型。</p><p><strong>使用</strong> <strong>pub use</strong> <strong>重导出（re-export）项来使公有结构不同于私有结构</strong></p><p>src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">/// The primary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The secondary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SecondaryColor</span> &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Combines two primary colors in equal amounts to create</span></span><br><span class="line">    <span class="comment">/// a secondary color.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>(c1: PrimaryColor, c2: PrimaryColor) <span class="punctuation">-&gt;</span> SecondaryColor &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        SecondaryColor::Green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">use</span> art::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">red</span> = PrimaryColor::Red;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">yellow</span> = PrimaryColor::Yellow;</span><br><span class="line">    <span class="title function_ invoke__">mix</span>(red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了从公有 API 中去掉 crate 的内部组织，我们可以采用示例 中的 art crate 并增加 pub use 语句来重导出项到顶层结构，如示例 14-5 所示：</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::SecondaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::mix;</span><br><span class="line"><span class="keyword">use</span> art::PrimaryColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发布-Crate"><a href="#发布-Crate" class="headerlink" title="发布 Crate"></a>发布 Crate</h2><p>有了唯一的名称、版本号、由 cargo new 新建项目时增加的作者信息、描述和所选择的 license，已经准备好发布的项目的 <em>Cargo.toml</em> 文件可能看起来像这样：</p><p>文件名: Cargo.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A fun game where you guess what number the computer has chosen.&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span></span><br><span class="line"><span class="attr">author</span> = <span class="string">&quot;even629&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><p>Cargo 的文档 描述了其他可以指定的元信息，他们可以帮助你的 crate 更容易被发现和使用！</p><p>发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo publish</span><br></pre></td></tr></table></figure><p><strong>crate 一旦发布，就是永久性的:该版本无法覆盖，代码无法删除</strong></p><ul><li>目的：依赖于该版本的项目可继续正常工作</li></ul><h2 id="发布已存在-crate-的新版本"><a href="#发布已存在-crate-的新版本" class="headerlink" title="发布已存在 crate 的新版本"></a>发布已存在 crate 的新版本</h2><p>修改 version 重新发布</p><h2 id="使用-cargo-yank-从-Crates-io-撤回版本"><a href="#使用-cargo-yank-从-Crates-io-撤回版本" class="headerlink" title="使用 cargo yank 从 Crates.io 撤回版本"></a>使用 cargo yank 从 Crates.io 撤回版本</h2><ul><li>不可以删除 crate 之前的版本</li></ul><p>撤回某个版本会阻止新项目开始依赖此版本，不过所有现存此依赖的项目仍然能够下载和依赖这个版本。从本质上说，撤回意味着所有带有 <em>Cargo.lock</em> 的项目的依赖不会被破坏，同时任何新生成的 <em>Cargo.lock</em> 将不能使用被撤回的版本。</p><p>为了撤回一个 crate，运行 cargo yank 并指定希望撤回的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo yank --vers 1.0.1</span><br></pre></td></tr></table></figure><p>也可以撤销撤回操作，并允许项目可以再次开始依赖某个版本，通过在命令上增加 —undo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo yank --vers 1.0.1 --undo</span><br></pre></td></tr></table></figure><p>撤回 <strong>并没有</strong> 删除任何代码。举例来说，撤回功能并不意在删除不小心上传的秘密信息。如果出现了这种情况，请立即重新设置这些秘密信息。</p><h2 id="Cargo-工作空间（Workspaces）"><a href="#Cargo-工作空间（Workspaces）" class="headerlink" title="Cargo 工作空间（Workspaces）"></a>Cargo 工作空间（Workspaces）</h2><ul><li>cargo 工作空间： 帮助管理多个相互关联且需要协同开发的 crate</li><li>cargo 工作空间是一套共享同一个 Cargo.lock 和输出文件夹的包</li></ul><h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><div class="tag link"><a class="link-card" title="Cargo工作空间" href="https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html#cargo-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4"><div class="left"><img src="https://kaisery.github.io/trpl-zh-cn/favicon.svg"/></div><div class="right"><p class="text">Cargo工作空间</p><p class="url">https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html#cargo-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4</p></div></a></div><p>为了在顶层 <em>add</em> 目录运行二进制 crate，可以通过 -p 参数和包名称来运行 cargo run 指定工作空间中我们希望使用的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -p adder</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0s</span><br><span class="line">     Running `target/debug/adder`</span><br><span class="line">Hello, world! 10 plus one is 11!</span><br></pre></td></tr></table></figure><p>这会运行 <em>adder/src/main.rs</em> 中的代码，其依赖 add_one crate</p><h2 id="从-CRATES-IO-安装二进制-crate"><a href="#从-CRATES-IO-安装二进制-crate" class="headerlink" title="从 CRATES.IO 安装二进制 crate"></a>从 CRATES.IO 安装二进制 crate</h2><ul><li>命令: cargo install</li><li>来源 <a href="https://crates.io">https://crates.io</a></li><li>限制: 只能安装具有二进制目标 (binary target) 的 crate</li></ul><p>二进制目标 binary target:是一个可运行的程序</p><ul><li>拥有 src/main.rs 或其它被指定为二进制文件的 crate 生成</li></ul><p>通常: READEME 里面有关于 crate 的描述:</p><ul><li>拥有 library target</li><li>拥有 library target</li><li>两者兼备</li></ul><h3 id="cargo-install"><a href="#cargo-install" class="headerlink" title="cargo install"></a>cargo install</h3><p>cargo install 安装的二进制存放在根目录的 bin 文件夹</p><h2 id="使用自定义命令扩展-cargo"><a href="#使用自定义命令扩展-cargo" class="headerlink" title="使用自定义命令扩展 cargo"></a>使用自定义命令扩展 cargo</h2><ul><li>cargo 被设计成可以使用子命令来扩展</li><li>例：如果$PATH 中的某个二进制是 cargo-something，你可以像子命令一样运行:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo something</span><br></pre></td></tr></table></figure><ul><li>类似这样的自定义命令可以通过该命令列出: cargo —list</li><li>优点: 可以使用 cargo install 来安装扩展，像内置工具一样来运行</li></ul><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul><li><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量的通用概念。</li></ul><p>这个地址引用，或 “指向”（points at）一些其他数据。</p><ul><li>Rust 中最常见的指针是 <strong>引用</strong>（<em>reference</em>）。</li></ul><p>引用以 &amp; 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也<strong>没有任何额外开销</strong>，所以应用得最多。</p><ul><li><strong>智能指针</strong>（<em>smart pointers</em>）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。</li></ul><h2 id="引用和智能指针的其它不同"><a href="#引用和智能指针的其它不同" class="headerlink" title="引用和智能指针的其它不同"></a>引用和智能指针的其它不同</h2><ul><li><strong>引用：只借用数据</strong></li><li><strong>智能指针：很多时候都拥有它所指向的数据</strong></li></ul><p><strong>智能指针的例子：</strong></p><ul><li>String 和 Vec<T></li><li>都拥有一片内存区域，且允许用户对其操作</li><li>还拥有元数据（例如容量等）</li><li>提供额外的功能或保障（String 保障其数据是合法的 UTF-8 编码）</li></ul><p><strong>智能指针的实现</strong></p><ul><li><p><strong>智能指针通常使用 struct 实现，</strong>并且实现了：Deref 和 Drop 这两个 trait</p><ul><li><p><strong>Deref trait 允许智能指针 struct 的实例像引用一样使用</strong></p></li><li><p><strong>Drop trait 允许你自定义当智能指针实例走出作用域时的代码</strong></p></li></ul></li></ul><h2 id="使用-Box指向堆上的数据"><a href="#使用-Box指向堆上的数据" class="headerlink" title="使用 Box指向堆上的数据"></a>使用 Box<T>指向堆上的数据</h2><ul><li><p>Box<T>是最简单的智能指针：</p><ul><li>允许你在 heap 上存储数据（而不是 stack）</li><li>stack 上是指向 heap 数据的指针</li><li>没有性能开销</li><li>没有其它额外功能</li></ul></li><li><p>Box<T>实现了 Deref trait 和 Drop trait</p></li></ul><p>多用于如下场景：</p><ul><li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li><li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li><li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Box-赋能递归类型"><a href="#使用-Box-赋能递归类型" class="headerlink" title="使用 Box 赋能递归类型"></a>使用 Box 赋能递归类型</h2><ul><li>在编译时,Rust 需要知道一个类型所占的空间大小</li><li>而递归类型的大小无法在编译时确定</li><li>但 Box 类型的大小确定</li><li>在递归类型中使用 Box 就可以解决上述问题</li><li>函数式语言的 Cons List</li></ul><h3 id="Cons-List"><a href="#Cons-List" class="headerlink" title="Cons List"></a>Cons List</h3><p><em>cons list</em> 是一个来源于 Lisp 编程语言及其方言的数据结构。在 Lisp 中，cons 函数（“construct function” 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。</p><p>cons 函数的概念涉及到更常见的函数式编程术语；“将 <em>x</em> 与 <em>y</em> 连接” 通常意味着构建一个新的容器而将 <em>x</em> 的元素放在新容器的开头，其后则是容器 <em>y</em> 的元素。</p><p>cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 Nil 的值且没有下一项。cons list 通过递归调用 cons 函数产生。代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。</p><p>代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。注意这不同于 “null” 或 “nil” 的概念，他们代表无效或缺失的值。</p><p>Cons List 并不是 Rust 的常用集合</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons,Nil&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>,List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiling my_box v0.<span class="number">1.0</span> (C:\Users\cauchy\Desktop\rust\my_box)</span><br><span class="line">error[E0072]: recursive <span class="keyword">type</span> `List` has infinite size</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">6</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">6</span> | <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  | ^^^^^^^^^</span><br><span class="line"><span class="number">7</span> |     <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>,List),</span><br><span class="line">  |              ---- recursive without indirection</span><br><span class="line">  |</span><br><span class="line">help: insert some <span class="title function_ invoke__">indirection</span> (e.g., a `<span class="type">Box</span>`, `Rc`, or `&amp;`) to <span class="keyword">break</span> the cycle</span><br><span class="line">  |</span><br><span class="line"><span class="number">7</span> |     <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>,<span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">  |              ++++    +</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0072`.</span><br><span class="line">error: could not compile `my_box` due to previous error</span><br></pre></td></tr></table></figure><h3 id="计算非递归类型的大小"><a href="#计算非递归类型的大小" class="headerlink" title="计算非递归类型的大小"></a>计算非递归类型的大小</h3><p>Message 枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Rust 需要知道要为 Message 值分配多少空间时，它可以检查每一个成员并发现</p><ul><li>Message::Quit 并不需要任何空间，</li><li>Message::Move 需要足够储存两个 i32 值的空间，依此类推。</li><li>因为 enum 实际上只会使用其中的一个成员，所以 Message 值所需的空间等于储存其最大成员的空间大小。</li></ul><p>与此相对当 Rust 编译器检查像上例的 List 这样的递归类型时会发生什么呢。编译器尝试计算出储存一个 List 枚举需要多少内存，并开始检查 Cons 成员，那么 Cons 需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，它检查其成员，从 Cons 成员开始。Cons 成员储存了一个 i32 值和一个 List 值，这样的计算将无限进行下去</p><h3 id="使用-Box给递归类型一个已知的大小"><a href="#使用-Box给递归类型一个已知的大小" class="headerlink" title="使用 Box给递归类型一个已知的大小"></a>使用 Box<T>给递归类型一个已知的大小</h3><ul><li>因为 Box<T> 是一个指针，我们总是知道它需要多少空间</li></ul><p><strong>指针的大小并不会根据其指向的数据量而改变。</strong></p><ul><li>Box<T></li></ul><ol><li>只提供了”间接”存储和 heap 内存分配的功能</li><li>没有其它额外功能</li><li>没有性能开销</li><li>适用于需要间接存储的场景，例如 Cons List</li><li>实现了 Deref trait 和 Drop trait</li></ol><h2 id="Dref-Trait"><a href="#Dref-Trait" class="headerlink" title="Dref Trait"></a>Dref Trait</h2><ul><li>实现 Deref Trait 使我们可以<strong>自定义解引用运算符*的行为</strong></li><li>通过实现 Deref，智能指针可<strong>像引用一样来处理</strong></li></ul><h2 id="解引用运算符"><a href="#解引用运算符" class="headerlink" title="解引用运算符"></a>解引用运算符</h2><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把-Box当作引用"><a href="#把-Box当作引用" class="headerlink" title="把 Box当作引用"></a>把 Box<T>当作引用</h2><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义自己的智能指针"><a href="#定义自己的智能指针" class="headerlink" title="定义自己的智能指针"></a>定义自己的智能指针</h2><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的编译错误是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling deref-example v0.1.0 (file:///projects/deref-example)</span><br><span class="line">error[E0614]: <span class="built_in">type</span> `MyBox&lt;&#123;<span class="built_in">integer</span>&#125;&gt;` cannot be dereferenced</span><br><span class="line">  --&gt; src/main.rs:14:19</span><br><span class="line">   |</span><br><span class="line">14 |     assert_eq!(5, *y);</span><br><span class="line">   |                   ^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0614`.</span><br><span class="line">error: could not compile `deref-example` due to previous error</span><br></pre></td></tr></table></figure><p>MyBox<T> 类型不能解引用，因为我们尚未在该类型实现这个功能。为了启用 * 运算符的解引用功能，需要实现 Deref trait。</p><h2 id="通过实现-Deref-trait-将某类型像引用一样处理"><a href="#通过实现-Deref-trait-将某类型像引用一样处理" class="headerlink" title="通过实现 Deref trait 将某类型像引用一样处理"></a>通过实现 Deref trait 将某类型像引用一样处理</h2><ul><li><p>标准库中的 Deref trait 要求我们实现一个 deref 方法：</p><ul><li><p>该方法借用 self</p></li><li><p>返回一个指向内部数据的引用</p></li></ul></li></ul><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在示例代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入 *y 时，Rust 事实上在底层运行了如下代码：</p><p>*(y.deref())</p><h2 id="函数和方法的隐式解引用转化（Deref-Coercion）"><a href="#函数和方法的隐式解引用转化（Deref-Coercion）" class="headerlink" title="函数和方法的隐式解引用转化（Deref Coercion）"></a>函数和方法的隐式解引用转化（Deref Coercion）</h2><ul><li>Deref Coercion 是为<strong>函数和方法</strong>提供的一种便捷特性</li><li>假设 T 实现了 Deref trait: Deref Coercion 可以把 T 的引用转化为 T 经过 Deref 操作后生成的引用</li><li>当把某类型的引用传递给函数或方法时，但它的类型于定义的参数类型不匹配:</li></ul><ol><li>Deref Coercion 就会自动发生</li><li>编译器会对 deref 进行一系列调用，来把它转为所需的参数类型</li><li>它在编译时完成，没有额外性能开销</li></ol><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="comment">//&amp;m &amp;MyBox&lt;String&gt;</span></span><br><span class="line">    <span class="comment">//deref &amp;String</span></span><br><span class="line">    <span class="comment">//&amp;String &amp;str</span></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>这里使用 &amp;m 调用 hello 函数，其为 MyBox<String> 值的引用</li><li>因为示例 中在 MyBox<T> 上实现了 Deref trait，Rust 可以通过 deref 调用将 &amp;MyBox<String> 变为 &amp;String。</li><li>标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。Rust 再次调用 deref 将 &amp;String 变为 &amp;str，这就符合 hello 函数的定义了。</li></ol><p>如果 Rust 没有实现 Deref 强制转换，为了使用 &amp;MyBox<String> 类型的值调用 hello，则不得不编写以下的代码</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解引用与可变性"><a href="#解引用与可变性" class="headerlink" title="解引用与可变性"></a>解引用与可变性</h2><ul><li>可使用 DerefMut trait 重载可变引用的*运算符</li><li>在类型和 trait 在下列三种情况发生时，Rust 会执行 deref coercion:</li></ul><ol><li>当 T: Deref<Target=U>，允许&amp;T 转换为&amp;U</li><li>当 T: DerefMut<Target=U>，允许&amp;mut T 转换为&amp;mut U</li><li>当 T: Deref<Target=U>，允许&amp;mut T 转换为&amp;U</li></ol><div class="table-container"><table><thead><tr><th>情况</th><th>条件</th><th>转换</th></tr></thead><tbody><tr><td>1</td><td><code>T: Deref&lt;Target=U&gt;</code></td><td><code>&amp;T</code> 自动变 <code>&amp;U</code></td></tr><tr><td>2</td><td><code>T: DerefMut&lt;Target=U&gt;</code></td><td><code>&amp;mut T</code> 自动变 <code>&amp;mut U</code></td></tr><tr><td>3</td><td><code>T: Deref&lt;Target=U&gt;</code></td><td><code>&amp;mut T</code> 可变引用<strong>降级</strong>为不可变引用 <code>&amp;U</code></td></tr></tbody></table></div><p>举例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;name&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">greet</span>(&amp;s);  </span><br><span class="line"><span class="comment">// 正常情况下 &amp;String 不能传给 &amp;str，</span></span><br><span class="line"><span class="comment">// 但因为 String 实现了 Deref&lt;Target=str&gt;，所以自动变成了 &amp;str</span></span><br></pre></td></tr></table></figure><h2 id="Drop-Trait"><a href="#Drop-Trait" class="headerlink" title="Drop Trait"></a>Drop Trait</h2><ul><li><p>实现 Drop Trait 可以让我们自定义<strong>当值将要离开作用域时发生的动作</strong></p><ol><li><p>例如：文件，网络资源释放等</p></li><li><p>任何类型都可以实现 Drop trait</p></li></ol></li><li><p>Drop Trait 只要求你实现 drop 方法</p><ol><li>参数： 对 self 的可变引用</li></ol></li><li><p>Drop trait 在预导入模块里</p></li></ul><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;my stuff&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;other stuff&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointers created.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当运行这个程序，会出现如下输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling drop-example v0.<span class="number">1.0</span> (file:<span class="comment">///projects/drop-example)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.60</span>s</span><br><span class="line">     Running `target/debug/drop-example`</span><br><span class="line">CustomSmartPointers created.</span><br><span class="line">Dropping CustomSmartPointer with data `other stuff`!</span><br><span class="line">Dropping CustomSmartPointer with data `my stuff`!</span><br></pre></td></tr></table></figure><h2 id="使用-std-mem-drop-来提前-drop-值"><a href="#使用-std-mem-drop-来提前-drop-值" class="headerlink" title="使用 std::mem::drop 来提前 drop 值"></a>使用 std::mem::drop 来提前 drop 值</h2><ul><li>很难直接禁用自动的 drop 功能，也没必要<ol><li>Drop trait 的目的就是进行自动的释放处理逻辑</li></ol></li></ul><ul><li><strong>Rust 不允许手动调用 Drop trait 的 drop 方法</strong></li><li>但<strong>可以调用标准库的 std::mem::drop 函数(prelude)，来提前 drop 值</strong></li></ul><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;some data&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created.&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer dropped before the end of main.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码会打印出如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling drop-example v0.<span class="number">1.0</span> (file:<span class="comment">///projects/drop-example)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.73</span>s</span><br><span class="line">     Running `target/debug/drop-example`</span><br><span class="line">CustomSmartPointer created.</span><br><span class="line">Dropping CustomSmartPointer with data `some data`!</span><br><span class="line">CustomSmartPointer dropped before the end of main.</span><br></pre></td></tr></table></figure><p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 drop 只会在值不再被使用时被调用一次。</p><h2 id="Rc引用计数智能指针"><a href="#Rc引用计数智能指针" class="headerlink" title="Rc引用计数智能指针"></a>Rc<T>引用计数智能指针</h2><ul><li>有时一个值会有多个所有者</li><li><p>为了支持多重所有权: Rt<T></p><ol><li><p>reference counting(引用计数)</p></li><li><p>追踪到值得引用</p></li><li>0 个引用:该值可以被清理掉</li></ol></li><li><p>需要在 heap 上分配数据，这些数据<strong>被程序的多个部分读取（只读）</strong>，但在<strong>编译时无法确定哪个部分最后使用完这些数据</strong></p></li><li>注意 <strong>Rc<T> 只能用于单线程场景</strong>；</li></ul><p>我们希望创建两个共享第三个列表所有权的列表，其概念将会看起来如图所示：</p><p>文件名: src/main.rs</p><p>不能用两个 Box<T> 的列表尝试共享第三个列表的所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: use of moved value: `a`</span><br><span class="line">  --&gt; src/main.rs:11:30</span><br><span class="line">   |</span><br><span class="line"> 9 |     <span class="built_in">let</span> a = Cons(5, Box::new(Cons(10, Box::new(Nil))));</span><br><span class="line">   |         - move occurs because `a` has <span class="built_in">type</span> `List`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">10 |     <span class="built_in">let</span> b = Cons(3, Box::new(a));</span><br><span class="line">   |                              - value moved here</span><br><span class="line">11 |     <span class="built_in">let</span> c = Cons(4, Box::new(a));</span><br><span class="line">   |                              ^ value used here after move</span><br></pre></td></tr></table></figure><p>我们修改 List 的定义为使用 Rc<T> 代替 Box<T>，如列表 所示。现在每一个 Cons 变量都包含一个值和一个指向 List 的 Rc<T>。当创建 b 时，不同于获取 a 的所有权，这里会克隆 a 所包含的 Rc<List>，这会将引用计数从 1 增加到 2 并允许 a 和 b 共享 Rc<List> 中数据的所有权。创建 c 时也会克隆 a，这会将引用计数从 2 增加为 3。每次调用 Rc::clone，Rc<List> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据结构关系：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="selector-tag">a</span> (Rc)</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">      <span class="built_in">Cons</span>(<span class="number">5</span>)</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">      <span class="built_in">Cons</span>(<span class="number">10</span>)</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">        Nil</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">b</span> ---&gt; <span class="built_in">Cons</span>(<span class="number">3</span>) ───┐</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">                  <span class="selector-tag">a</span> (共享)</span><br><span class="line"></span><br><span class="line">c ---&gt; <span class="built_in">Cons</span>(<span class="number">4</span>) ───┘</span><br></pre></td></tr></table></figure><p>也可以调用 a.clone() 而不是 Rc::clone(&amp;a)，不过在这里 Rust 的习惯是使用 Rc::clone。</p><ul><li>Rc::clone 的实现并不像大部分类型的 clone 实现那样对所有数据进行深拷贝。</li><li><strong>Rc::clone 只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间</strong>。</li></ul><h2 id="克隆-Rc会增加引用计数"><a href="#克隆-Rc会增加引用计数" class="headerlink" title="克隆 Rc会增加引用计数"></a>克隆 Rc<T>会增加引用计数</h2><p>文件名: src/main.rs</p><p>Rc::strong_count 获得引用计数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会打印出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.<span class="number">1.0</span> (file:<span class="comment">///projects/cons-list)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.45</span>s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">count after creating a = <span class="number">1</span></span><br><span class="line">count after creating b = <span class="number">2</span></span><br><span class="line">count after creating c = <span class="number">3</span></span><br><span class="line">count after c goes out of scope = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们能够看到 a 中 Rc<List> 的初始引用计数为 1，接着每次调用 clone，计数会增加 1。当 c 离开作用域时，计数减 1。不必像调用 Rc::clone 增加引用计数那样调用一个函数来减少计数；Drop trait 的实现当 Rc<T> 值离开作用域时自动减少引用计数。</p><p>从这个例子我们所不能看到的是，在 main 的结尾当 b 然后是 a 离开作用域时，此处计数会是 0，同时 Rc<List> 被完全清理。使用 Rc<T> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。</p><ul><li>Rc<T>通过<strong>不可变引用</strong>， Rc<T> 允许在程序的多个部分之间只读地共享数据。</li><li>如果 Rc<T> 也允许多个可变引用，则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。</li></ul><h2 id="RefCell和内部可变性"><a href="#RefCell和内部可变性" class="headerlink" title="RefCell和内部可变性"></a>RefCell<T>和内部可变性</h2><h3 id="内部可变性（interior-mutability"><a href="#内部可变性（interior-mutability" class="headerlink" title="内部可变性（interior mutability)"></a>内部可变性（interior mutability)</h3><ul><li>interior mutability 是 Rust 的设计模式之一</li><li>它允许你在支持有不可变引用的前提下对数据进行修改</li></ul><p>数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则</p><ul><li>与 Rc<T>不同，RefCell<T>类型代表了其持有数据的唯一所有权</li></ul><p>回忆借用规则：</p><ol><li>在任何给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用</li><li>引用总是有效的</li></ol><h3 id="RefCell与-Box的区别"><a href="#RefCell与-Box的区别" class="headerlink" title="RefCell与 Box的区别"></a>RefCell<T>与 Box<T>的区别</h3><div class="table-container"><table><thead><tr><th>Box<T></th><th>RefCell<T></th></tr></thead><tbody><tr><td><strong>编译阶段</strong>强制代码遵守借用规则</td><td>只会在<strong>运行时</strong>检查借用规则</td></tr><tr><td>否则出现错误</td><td>否则触发 panic</td></tr></tbody></table></div><h3 id="借用规则在不同阶段进行检查的比较"><a href="#借用规则在不同阶段进行检查的比较" class="headerlink" title="借用规则在不同阶段进行检查的比较"></a>借用规则在不同阶段进行检查的比较</h3><div class="table-container"><table><thead><tr><th><strong>编译阶段</strong></th><th><strong>运行时</strong></th></tr></thead><tbody><tr><td>尽早暴露问题</td><td>问题暴露延后，甚至到生产环境</td></tr><tr><td>没有任何运行时开销</td><td>因借用计数产生些许性能损失</td></tr><tr><td>对大多数场景是最佳选择</td><td>实现某些特定的内存安全场景(不可变环境中修改自身数据)</td></tr><tr><td>是 Rust 的默认行为</td></tr></tbody></table></div><ul><li>与 Rc<T>类似，只能用于<strong>单线程</strong>场景</li></ul><h3 id="选择-Box，Rc，RefCell的依据"><a href="#选择-Box，Rc，RefCell的依据" class="headerlink" title="选择 Box，Rc，RefCell的依据"></a>选择 Box<T>，Rc<T>，RefCell<T>的依据</h3><div class="table-container"><table><thead><tr><th></th><th>Box<T></th><th>Rc<T></th><th>RefCell<T></th></tr></thead><tbody><tr><td>同一数据的所有者</td><td>一个</td><td>多个</td><td>一个</td></tr><tr><td>可变性,借用检查</td><td>可变，不可变借用(编译时检查)</td><td>不可变借用(编译时检查)</td><td>可变，不可变借用（运行时检查）</td></tr></tbody></table></div><h3 id="内部可变性：可变的借用一个不可变的值"><a href="#内部可变性：可变的借用一个不可变的值" class="headerlink" title="内部可变性：可变的借用一个不可变的值"></a>内部可变性：可变的借用一个不可变的值</h3><p>借用规则的一个推论是当有一个不可变值时，不能可变地借用它。例如，如下代码不能编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果尝试编译，会得到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling borrowing v0.1.0 (file:///projects/borrowing)</span><br><span class="line">error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable</span><br><span class="line"> --&gt; src/main.rs:3:13</span><br></pre></td></tr></table></figure><p>如下是一个我们想要测试的场景：</p><p>我们在编写一个记录某个值与最大值的差距的库，并根据当前值与最大值的差距来发送消息。例如，这个库可以用于记录用户所允许的 API 调用数量限额。</p><p>该库只提供记录与最大值的差距，以及何种情况发送什么消息的功能。使用此库的程序则期望提供实际发送消息的机制：程序可以选择记录一条消息、发送 email、发送短信等等。库本身无需知道这些细节；只需实现其提供的 Messenger trait 即可。示例 15-20 展示了库代码：</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">LimitTracker</span>&lt;<span class="symbol">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    value: <span class="type">usize</span>,</span><br><span class="line">    max: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(messenger: &amp;T, max: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">percentage_of_max</span> = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .<span class="title function_ invoke__">send</span>(<span class="string">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .<span class="title function_ invoke__">send</span>(<span class="string">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        sent_messages: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: <span class="built_in">vec!</span>[],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mock_messenger</span> = MockMessenger::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">limit_tracker</span> = LimitTracker::<span class="title function_ invoke__">new</span>(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.<span class="title function_ invoke__">set_value</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码中一个重要部分是拥有一个方法 send 的 Messenger trait，其获取一个 self 的<strong>不可变引用</strong>和文本信息。这个 trait 是 mock 对象所需要实现的接口库，这样 mock 就能像一个真正的对象那样使用了。另一个重要的部分是我们需要测试 LimitTracker 的 set_value 方法的行为。可以改变传递的 value 参数的值，不过 set_value 并没有返回任何可供断言的值。也就是说，如果使用某个实现了 Messenger trait 的值和特定的 max 创建 LimitTracker，当传递不同 value 值时，消息发送者应被告知发送合适的消息。</p><p>我们所需的 mock 对象是，调用 send 并不实际发送 email 或消息，而是只记录信息被通知要发送了。可以新建一个 mock 对象实例，用其创建 LimitTracker，调用 LimitTracker 的 set_value 方法，然后检查 mock 对象是否有我们期望的消息。示例 15-21 展示了一个如此尝试的 mock 对象实现，不过借用检查器并不允许：</p><p>然而，这个测试是有问题的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span></span><br><span class="line">   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)</span><br><span class="line">error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</span><br><span class="line">  --&gt; src/lib.rs:58:13</span><br><span class="line">   |</span><br><span class="line">2  |     fn send(&amp;self, msg: &amp;str);</span><br><span class="line">   |             ----- <span class="built_in">help</span>: consider changing that to be a mutable reference: `&amp;mut self`</span><br><span class="line">...</span><br><span class="line">58 |             self.sent_messages.push(String::from(message));</span><br><span class="line">   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `limit-tracker` due to previous error</span><br><span class="line">warning: build failed, waiting <span class="keyword">for</span> other <span class="built_in">jobs</span> to finish...</span><br><span class="line">error: build failed</span><br></pre></td></tr></table></figure><p>不能修改 MockMessenger 来记录消息，因为 <strong>send 方法获取了 self 的不可变引用</strong>。我们也不能参考错误文本的建议使用 &amp;mut self 替代，因为这样 send 的签名就不符合 Messenger trait 定义中的签名了（可以试着这么改，看看会出现什么错误信息）。</p><p>这正是内部可变性的用武之地！我们将通过 RefCell 来储存 sent_messages，然后 send 将能够修改 sent_messages 并储存消息。</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-RefCell在运行时记录借用信息"><a href="#使用-RefCell在运行时记录借用信息" class="headerlink" title="使用 RefCell在运行时记录借用信息"></a>使用 RefCell<T>在运行时记录借用信息</h3><ul><li><p>两个方法（安全接口）</p><ol><li><p>borrow 方法：返回智能指针 Ref<T>，它实现了 Deref</p></li><li><p>borrow_mut 方法：返回 RefMut<T>，它实现了 Deref</p></li></ol></li><li><p>RefCell<T>会记录当前存在多少个活跃的 Ref<T>和 RefMut<T>智能指针</p><ol><li><p>每次调用 borrow：不可变借用计数+1</p></li><li><p>任何一个 Ref<T>的值离开作用域被释放时：不可变借用计数-1</p></li><li><p>每次调用 borrow_mut: 可变借用计数+1</p></li><li><p>任何一个 RefMut<T>的值利开作用域被释放时：可变借用计数-1</p></li></ol></li><li><p>Rust 以此计数来维护借用检查规则：任何一个给定时间里，只允许拥有多个不可变借用或一个可变借用</p></li></ul><h3 id="结合-Rc-和-RefCell-来拥有多个可变数据所有者"><a href="#结合-Rc-和-RefCell-来拥有多个可变数据所有者" class="headerlink" title="结合 Rc 和 RefCell 来拥有多个可变数据所有者"></a>结合 Rc 和 RefCell 来拥有多个可变数据所有者</h3><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">4</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a after = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b after = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c after = &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们打印出 a、b 和 c 时，可以看到他们都拥有修改后的值 15 而不是 5：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.63s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">a after = Cons(RefCell &#123; value: 15 &#125;, Nil)</span><br><span class="line">b after = Cons(RefCell &#123; value: 3 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br><span class="line">c after = Cons(RefCell &#123; value: 4 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br></pre></td></tr></table></figure><h2 id="其它可实现内部可变性的类型"><a href="#其它可实现内部可变性的类型" class="headerlink" title="其它可实现内部可变性的类型"></a>其它可实现内部可变性的类型</h2><ul><li>Cell<T>：通过复制来访问数据</li><li>Mutex<T>：用于实现跨线程的情形下的内部可变性模式</li></ul><h2 id="循环引用导致内存泄漏"><a href="#循环引用导致内存泄漏" class="headerlink" title="循环引用导致内存泄漏"></a>循环引用导致内存泄漏</h2><p>Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 <strong>内存泄漏</strong>（<em>memory leak</em>）），但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的。这一点可以通过 Rc<T> 和 RefCell<T> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 是一个链表，每个节点是 Cons(value, next) 或 Nil</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a initial rc count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a next item = &#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after b creation = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b initial rc count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b next item = &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uncomment the next line to see that we have a cycle;</span></span><br><span class="line">    <span class="comment">// it will overflow the stack</span></span><br><span class="line">    <span class="comment">// println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果保持最后的 println! 行注释并运行代码，会得到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.53s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">a initial rc count = 1</span><br><span class="line">a next item = Some(RefCell &#123; value: Nil &#125;)</span><br><span class="line">a rc count after b creation = 2</span><br><span class="line">b initial rc count = 1</span><br><span class="line">b next item = Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)</span><br><span class="line">b rc count after changing a = 2</span><br><span class="line">a rc count after changing a = 2</span><br></pre></td></tr></table></figure><p>如果取消最后 println! 的注释并运行程序，Rust 会尝试打印出 a 指向 b 指向 a 这样的循环直到栈溢出。这是因为：</p><p>在 Rust 中，<code>#[derive(Debug)]</code> 对枚举（比如链表）会生成一个递归打印逻辑：注意：<code>next</code> 也会调用 <code>Debug</code> → 又去打印它的 <code>next</code> → 递归调用，而且这个递归调用没有终止条件，因此最后会导致栈溢出</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(v, next) =&gt; &#123;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;Cons(&#123;:?&#125;, &#123;:?&#125;)&quot;</span>, v, next)</span><br><span class="line">            &#125;</span><br><span class="line">            Nil =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Nil&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>防止内存泄漏的解决办法</strong></p><ul><li>依靠开发者来保证，不能依靠 Rust</li><li><p>重新组织数据结构：一些引用来表达所有权，一些引用不表达所有权</p><ol><li><p>循环引用中的一部分具有所有权关系，另一部分不涉及所有权关系</p></li><li><p>而只有所有权关系才影响值的清理</p></li></ol></li></ul><h3 id="避免引用循环：将-Rc-变为-Weak"><a href="#避免引用循环：将-Rc-变为-Weak" class="headerlink" title="避免引用循环：将 Rc 变为 Weak"></a>避免引用循环：将 Rc<T> 变为 Weak<T></h3><ul><li>Rc::clone 为 Rc<T>实例的 strong_count 加 1，Rc<T>的实例只有在 strong_count 为 0 时才会被清理</li><li><p><strong>Rc<T>实例通过调用 Rc::downgrade 方法可以创建值的 Weak Reference（弱引用）</strong></p><ol><li><p>返回类型是 Weak<T>（智能指针）</p></li><li><p>调用 Rc::downgrade 会为 weak_count 加 1</p></li></ol></li><li><p>Rc<T>使用 weak_count 来追踪存在多少 Weak<T></p></li><li><strong>weak_count 不为 0 并不影响 Rc<T>实例的清理</strong></li></ul><h3 id="Strong-VS-Weak"><a href="#Strong-VS-Weak" class="headerlink" title="Strong VS Weak"></a>Strong VS Weak</h3><ul><li>Strong Reference 是关于如何分享 Rc<T>实例的所有权</li><li>Weak Reference 并不表达上述意思</li><li>使用 Weak Reference 并不会创建循环引用：</li></ul><p><strong>当 Strong Reference 数量为 0 的时候，Weak Reference 会自动断开</strong></p><ul><li>在使用 Weak<T>前，需保证它指向的值仍然存在：</li></ul><p><strong>在 Weak<T>实例上调用 upgrade 方法，返回 Option<Rc<T>&gt;</strong></p><h4 id="创建树形数据结构：带有子节点的-Node"><a href="#创建树形数据结构：带有子节点的-Node" class="headerlink" title="创建树形数据结构：带有子节点的 Node"></a>创建树形数据结构：带有子节点的 Node</h4><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里克隆了 leaf 中的 Rc<Node> 并储存在了 branch 中，这意味着 leaf 中的 Node 现在有两个所有者：leaf 和 branch。可以通过 branch.children 从 branch 中获得 leaf，不过无法从 leaf 到 branch。leaf 没有到 branch 的引用且并不知道他们相互关联。我们希望 leaf 知道 branch 是其父节点。稍后我们会这么做</p><h4 id="增加从子到父的引用"><a href="#增加从子到父的引用" class="headerlink" title="增加从子到父的引用"></a>增加从子到父的引用</h4><p>为了使子节点知道其父节点，需要在 Node 结构体定义中增加一个 parent 字段。问题是 parent 的类型应该是什么。我们知道其不能包含 Rc<T>，因为这样 leaf.parent 将会指向 branch 而 branch.children 会包含 leaf 的指针，这会形成引用循环，会造成其 strong_count 永远也不会为 0。</p><p>现在换一种方式思考这个关系:</p><ul><li><strong>父节点应该拥有其子节点</strong></li><li><strong>如果父节点被丢弃了，其子节点也应该被丢弃</strong></li><li>然而<strong>子节点不应该拥有其父节点</strong></li><li><strong>如果丢弃子节点，其父节点应该依然存在</strong>。</li></ul><p>这正是弱引用的例子！</p><p>所以 parent 使用 Weak<T> 类型而不是 Rc<T>，具体来说是 RefCell<Weak<Node>&gt;。现在 Node 结构体定义看起来像这样：</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 leaf 节点类似于示例 15-27 中如何创建 leaf 节点的，除了 parent 字段有所不同：leaf 开始时没有父节点，所以我们新建了一个空的 Weak 引用实例。</p><p>此时，当尝试使用 upgrade 方法获取 leaf 的父节点引用时，会得到一个 None 值。如第一个 println! 输出所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaf parent = None</span><br></pre></td></tr></table></figure><p>当创建 branch 节点时，其也会新建一个 Weak<Node> 引用，因为 branch 并没有父节点。leaf 仍然作为 branch 的一个子节点。一旦在 branch 中有了 Node 实例，就可以修改 leaf 使其拥有指向父节点的 Weak<Node> 引用。这里使用了 leaf 中 parent 字段里的 RefCell<Weak<Node>&gt; 的 borrow_mut 方法，接着使用了 Rc::downgrade 函数来从 branch 中的 Rc<Node> 值创建了一个指向 branch 的 Weak<Node> 引用。</p><p>当再次打印出 leaf 的父节点时，这一次将会得到存放了 branch 的 Some 值：现在 leaf 可以访问其父节点了！当打印出 leaf 时，我们也避免了如示例 15-26 中最终会导致栈溢出的循环：Weak<Node> 引用被打印为 (Weak)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;,</span><br><span class="line">children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;,</span><br><span class="line">children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span><br></pre></td></tr></table></figure><p>没有无限的输出表明这段代码并没有造成引用循环。这一点也可以从观察 Rc::strong_count 和 Rc::weak_count 调用的结果看出。</p><p><strong>可视化 strong_count 和 weak_count 的改变</strong>让我们通过创建了一个新的内部作用域并将 branch 的创建放入其中，来观察 Rc<Node> 实例的 strong_count 和 weak_count 值的变化。这会展示当 branch 创建和离开作用域被丢弃时会发生什么。这些修改如示例所示：</p><p>示例 ：在内部作用域创建 branch 并检查其强弱引用计数</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// leaf strong = 1, weak = 0</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            value: <span class="number">5</span>,</span><br><span class="line">            parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">            children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line"><span class="comment">// branch strong = 1, weak = 1</span></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch),</span><br><span class="line">        );</span><br><span class="line"><span class="comment">// leaf strong = 2, weak = 0</span></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// leaf parent = None</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// leaf strong = 1, weak = 0</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦创建了 leaf，其 Rc<Node> 的强引用计数为 1，弱引用计数为 0。在内部作用域中创建了 branch 并与 leaf 相关联，此时 branch 中 Rc<Node> 的强引用计数为 1，弱引用计数为 1（因为 leaf.parent 通过 Weak<Node> 指向 branch）。这里 leaf 的强引用计数为 2，因为现在 branch 的 branch.children 中储存了 leaf 的 Rc<Node> 的拷贝，不过弱引用计数仍然为 0。</p><p>当内部作用域结束时，branch 离开作用域，Rc<Node> 的强引用计数减少为 0，所以其 Node 被丢弃。来自 leaf.parent 的弱引用计数 1 与 Node 是否被丢弃无关，所以并没有产生任何内存泄漏！</p><p>如果在内部作用域结束后尝试访问 leaf 的父节点，会再次得到 None。在程序的结尾，leaf 中 Rc<Node> 的强引用计数为 1，弱引用计数为 0，因为现在 leaf 又是 Rc<Node> 唯一的引用了。</p><p>所有这些管理计数和值的逻辑都内建于 Rc<T> 和 Weak<T> 以及它们的 Drop trait 实现中。通过在 Node 定义中指定从子节点到父节点的关系为一个 Weak<T>引用，就能够拥有父节点和子节点之间的双向引用而不会造成引用循环和内存泄漏。</p><h1 id="无畏并发"><a href="#无畏并发" class="headerlink" title="无畏并发"></a>无畏并发</h1><ul><li><strong>并发编程</strong>（<em>Concurrent programming</em>），代表程序的不同部分相互独立的执行，</li><li><strong>并行编程</strong>（<em>parallel programming</em>）代表程序不同部分于同时执行</li></ul><h2 id="使用线程同时运行代码"><a href="#使用线程同时运行代码" class="headerlink" title="使用线程同时运行代码"></a>使用线程同时运行代码</h2><p>在大部分现代操作系统中，已执行程序的代码在一个 <strong>进程</strong>（<em>process</em>）中运行，操作系统则负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。运行这些独立部分的功能被称为 <strong>线程</strong>（<em>threads</em>）。</p><p>将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p><ul><li>竞态条件（Race conditions），多个线程以不一致的顺序访问数据或资源</li><li>死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行</li><li>只会发生在特定情况且难以稳定重现和修复的 bug</li></ul><p>编程语言有一些不同的方法来实现线程。</p><ul><li>很多操作系统提供了创建新线程的 API。这种由编程语言调用操作系统 API 创建线程的模型有时被称为 <em>1:1</em>，一个 OS 线程对应一个语言线程。<strong>Rust 标准库只提供了 1:1 线程实现</strong>；需要较小的运行时（即Rust 不需要额外的线程调度器或复杂机制，只需要跟踪线程句柄（handle），创建和销毁线程时调用 OS API，没有额外的用户态调度）。</li><li>有一些 crate 实现了其他有着不同取舍的线程模型，即语言自己实现的线程（绿色线程）：M:N 模型。需要较大的运行时</li></ul><h2 id="通过-spawn-创建新线程"><a href="#通过-spawn-创建新线程" class="headerlink" title="通过 spawn 创建新线程"></a>通过 spawn 创建新线程</h2><p>为了创建一个新线程，需要调用 <strong>thread::spawn</strong> 函数并传递一个闭包，并在其中包含希望在新线程运行的代码</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当主线程结束时，新线程也会结束，而不管其是否执行完毕。</p><h2 id="通过-join-Handle-来等待所有线程的完成"><a href="#通过-join-Handle-来等待所有线程的完成" class="headerlink" title="通过 join Handle 来等待所有线程的完成"></a>通过 join Handle 来等待所有线程的完成</h2><ul><li>thread::spawn 的返回值类型是 JoinHandle。</li><li><strong>JoinHandle 是一个拥有所有权的值</strong></li><li><strong>当对其调用 join 方法时，会阻止当前运行线程的执行，直到 handle 所表示的这些线程的终结。</strong></li></ul><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束。<strong>阻塞</strong>（<em>Blocking</em>） 线程意味着阻止该线程执行工作或退出。因为我们将 join 调用放在了主线程的 for 循环之后，</p><h2 id="使用-move-闭包"><a href="#使用-move-闭包" class="headerlink" title="使用 move 闭包"></a>使用 move 闭包</h2><ul><li>move 闭包通常和 thread::spawn 函数一起使用，它允许你使用其他线程的数据</li><li>创建线程时，把值得所有权从一个线程转移到另一个线程</li></ul><p>示例: 尝试在另一个线程使用主线程创建的 vector</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包使用了 v，所以闭包会捕获 v 并使其成为闭包环境的一部分。因为 thread::spawn 在一个新线程中运行这个闭包，所以可以在新线程中访问 v。然而当编译这个例子时，会得到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling threads v0.1.0 (file:///projects/threads)</span><br><span class="line">error[E0373]: closure may outlive the current <span class="keyword">function</span>, but it borrows `v`, <span class="built_in">which</span> is owned by the current <span class="keyword">function</span></span><br><span class="line"> --&gt; src/main.rs:6:32</span><br><span class="line">  |</span><br><span class="line">6 |     <span class="built_in">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">  |                                ^^ may outlive borrowed value `v`</span><br><span class="line">7 |         println!(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">  |                                           - `v` is borrowed here</span><br><span class="line">  |</span><br><span class="line">note: <span class="keyword">function</span> requires argument <span class="built_in">type</span> to outlive `<span class="string">&#x27;static`</span></span><br><span class="line"><span class="string"> --&gt; src/main.rs:6:18</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">6 |       let handle = thread::spawn(|| &#123;</span></span><br><span class="line"><span class="string">  |  __________________^</span></span><br><span class="line"><span class="string">7 | |         println!(&quot;Here&#x27;</span>s a vector: &#123;:?&#125;<span class="string">&quot;, v);</span></span><br><span class="line"><span class="string">8 | |     &#125;);</span></span><br><span class="line"><span class="string">  | |______^</span></span><br><span class="line"><span class="string">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">6 |     let handle = thread::spawn(move || &#123;</span></span><br><span class="line"><span class="string">  |                                ++++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0373`.</span></span><br><span class="line"><span class="string">error: could not compile `threads` due to previous error</span></span><br></pre></td></tr></table></figure><p>Rust 会 <strong>推断</strong> 如何捕获 v，因为 <strong>println! 只需要 v 的引用，闭包尝试借用 v</strong>。然而这有一个问题：<strong>Rust 不知道这个新建线程会执行多久，所以无法知晓 v 的引用是否一直有效</strong>。</p><p>示例 16-4 展示了一个 v 的引用很有可能不再有效的场景：</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(v); <span class="comment">// oh no!</span></span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在闭包之前增加 move 关键字，我们强制闭包获取其使用的值的所有权，而不是任由 Rust 推断它应该借用值。下面展示对代码的修改，可以按照我们的预期编译并运行：</p><p>示例: 使用 move 关键字强制获取它使用的值的所有权</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用消息传递来跨线程传递数据"><a href="#使用消息传递来跨线程传递数据" class="headerlink" title="使用消息传递来跨线程传递数据"></a>使用消息传递来跨线程传递数据</h2><p>一个日益流行的确保安全并发的方式是 <strong>消息传递</strong>（<em>message passing</em>），这里线程或 actor 通过发送包含数据的消息来相互沟通。这个思想来源于 [Go 编程语言文档中]的口号：“不要通过共享内存来通讯；而是通过通讯来共享内存。”（“Do not communicate by sharing memory; instead, share memory by communicating.”）</p><ul><li>线程（或 Actor）通过彼此发送消息（数据）来进行通信</li><li>Rust: Channel(标准库提供)</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul><li>Channel 包含：<strong>发送端</strong>，<strong>接收端</strong></li><li>调用发送端的方法，发送数据</li><li>接收端会检查和接收到达的数据</li><li><strong>如果发送端，接收端中任意一端被丢弃了，那么 Channel 就被“关闭”了</strong></li></ul><h3 id="创建-Channel"><a href="#创建-Channel" class="headerlink" title="创建 Channel"></a>创建 Channel</h3><ul><li>使用<strong>mpsc::channel</strong> 函数来创建 Channel</li></ul><ol><li>mpsc 表示 <strong>multiple producer,single consumer</strong>(多个生产者，一个消费者)</li><li>返回一个 tuple(元组):里面元素分别是发送端，接收端</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">channel</span>&lt;T&gt;() <span class="punctuation">-&gt;</span> (Sender&lt;T&gt;, Receiver&lt;T&gt;)</span><br></pre></td></tr></table></figure><p>让我们将发送端移动到一个新建线程中并发送一个字符串，这样新建线程就可以和主线程通讯了</p><p>示例: 将 tx 移动到一个新建的线程中并发送 “hi”</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 阻塞主进程执行直到从信道中接受一个值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再次使用 thread::spawn 来创建一个新线程并使用 move 将 tx 移动到闭包中这样新建线程就拥有 tx 了。新建线程需要拥有信道的发送端以便能向信道发送消息。</p><p>信道的发送端有一个 send 方法用来获取需要放入信道的值。send 方法返回一个 Result<T, E> 类型，所以<strong>如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误</strong>。在这个例子中，出错的时候调用 unwrap 产生 panic。不过对于一个真实程序，需要合理地处理它</p><p><strong>接收端的 recv 方法</strong></p><ul><li>信道的接收端有两个有用的方法：recv 和 try_recv。</li><li>这里，我们使用了 recv，它是 <em>receive</em> 的缩写。这个方法会<strong>阻塞主线程执行直到从信道中接收一个值</strong>。一旦发送了一个值，recv 会在一个 Result<T, E> 中返回它。当信道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了。</li><li><strong>try_recv 不会阻塞</strong>，相反它立刻返回一个 Result<T, E>：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用 try_recv 很有用：可以编写一个循环来频繁调用 try_recv，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。</li></ul><h3 id="信道与所有权转移"><a href="#信道与所有权转移" class="headerlink" title="信道与所有权转移"></a>信道与所有权转移</h3><p>现在让我们做一个试验来看看信道与所有权如何一同协作以避免产生问题：我们将尝试在新建线程中的信道中发送完 val 值 <strong>之后</strong> 再使用它。尝试编译下面的示例的代码并看看为何这是不允许的：</p><p>示例: 在我们已经发送到信道中后，尝试使用 val 引用</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;val is &#123;&#125;&quot;</span>, val);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尝试在通过 tx.send 发送 val 到信道中之后将其打印出来。允许这么做是一个坏主意：</p><p><strong>一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前就将其修改或者丢弃。其他线程对值可能的修改会由于不一致或不存在的数据而导致错误或意外的结果</strong>。</p><p>然而，尝试编译示例 16-9 的代码时，Rust 会给出一个错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling message-passing v0.1.0 (file:///projects/message-passing)</span><br><span class="line">error[E0382]: borrow of moved value: `val`</span><br><span class="line">  --&gt; src/main.rs:10:31</span><br><span class="line">   |</span><br><span class="line">8  |         <span class="built_in">let</span> val = String::from(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">   |             --- move occurs because `val` has <span class="built_in">type</span> `String`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">9  |         tx.send(val).unwrap();</span><br><span class="line">   |                 --- value moved here</span><br><span class="line">10 |         println!(<span class="string">&quot;val is &#123;&#125;&quot;</span>, val);</span><br><span class="line">   |                               ^^^ value borrowed here after move</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `message-passing` due to previous error</span><br></pre></td></tr></table></figure><p>我们的并发错误会造成一个编译时错误。send 函数获取其参数的所有权并移动这个值归接收者所有。这可以防止在发送后再次意外地使用这个值；所有权系统检查一切是否合乎规则。</p><h3 id="发送多个值并观察接收者的等待"><a href="#发送多个值并观察接收者的等待" class="headerlink" title="发送多个值并观察接收者的等待"></a>发送多个值并观察接收者的等待</h3><p>示例: 发送多个消息，并在每次发送后暂停一段时间</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次，在新建线程中有一个字符串 vector 希望发送到主线程。我们遍历他们，单独的发送每一个字符串并通过一个 Duration 值调用 thread::sleep 函数来暂停一秒。</p><p>在主线程中，不再显式调用 recv 函数：而是将 rx 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当信道被关闭时，迭代器也将结束。</p><p>当运行示例 16-10 中的代码时，将看到如下输出，每一行都会暂停一秒：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br><span class="line">Got: from</span><br><span class="line">Got: the</span><br><span class="line">Got: thread</span><br></pre></td></tr></table></figure><p>因为主线程中的 for 循环里并没有任何暂停或等待的代码，所以可以说主线程是在等待从新建线程中接收值。</p><h3 id="通过克隆发送者来创建多个生产者"><a href="#通过克隆发送者来创建多个生产者" class="headerlink" title="通过克隆发送者来创建多个生产者"></a>通过克隆发送者来创建多个生产者</h3><p>示例: 从多个生产者发送多个消息</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx1.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;more&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;messages&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;for&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;you&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure><p>这一次，在创建新线程之前，我们对信道的发送端调用了 clone 方法。这会给我们一个<strong>可以传递给第一个新建线程的发送端句柄</strong>。我们会将原始的信道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向信道的接收端发送不同的消息。</p><p>如果运行这些代码，你 <strong>可能</strong> 会看到这样的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br><span class="line">Got: more</span><br><span class="line">Got: from</span><br><span class="line">Got: messages</span><br><span class="line">Got: <span class="keyword">for</span></span><br><span class="line">Got: the</span><br><span class="line">Got: thread</span><br><span class="line">Got: you</span><br></pre></td></tr></table></figure><p>虽然你可能会看到这些值以不同的顺序出现；这依赖于你的系统。这也就是并发既有趣又困难的原因。如果通过 thread::sleep 做实验，在不同的线程中提供不同的值，就会发现他们的运行更加不确定，且每次都会产生不同的输出。</p><h2 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h2><ul><li>在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。</li><li>共享内存类似于多所有权：多个线程可以同时访问相同的内存位置</li></ul><h3 id="互斥器一次只允许一个线程访问数据"><a href="#互斥器一次只允许一个线程访问数据" class="headerlink" title="互斥器一次只允许一个线程访问数据"></a>互斥器一次只允许一个线程访问数据</h3><p><strong>互斥器</strong>（<em>mutex</em>）是 <em>mutual exclusion</em> 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 <strong>锁</strong>（<em>lock</em>）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 <strong>保护</strong>（<em>guarding</em>）其数据。</p><p>互斥器以难以使用著称，因为你不得不记住：</p><ol><li><strong>在使用数据之前尝试获取锁。</strong></li><li><strong>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁</strong>。</li></ol><p>在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。</p><h3 id="Mutex-的-API"><a href="#Mutex-的-API" class="headerlink" title="Mutex 的 API"></a>Mutex 的 API</h3><p>作为展示如何使用互斥器的例子，让我们从在单线程上下文使用互斥器开始，如示例所示：</p><p>示例: 出于简单的考虑，在一个单线程上下文中探索 Mutex<T> 的 API</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像很多类型一样，我们使用关联函数 new 来创建一个 Mutex<T>。使用 lock 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。</p><p>一旦获取了锁，就可以将返回值（在这里是 num）<strong>视为一个其内部数据的可变引用</strong>了。类型系统确保了我们在使用 m 中的值之前获取锁：Mutex<i32> 并不是一个 i32，所以 <strong>必须</strong> 获取锁才能使用这个 i32 值。我们是不会忘记这么做的，因为反之类型系统不允许访问内部的 i32 值。</p><p>Mutex<T> 是一个智能指针。更准确的说，<strong>lock 调用 返回 一个叫做 MutexGuard 的智能指针</strong>。<strong>这个智能指针实现了 Deref 来指向其内部数据；其也提供了一个 Drop 实现当 MutexGuard 离开作用域时自动释放锁</strong>，这正发生于示例 16-12 内部作用域的结尾。为此，我们不会忘记释放锁并阻塞互斥器为其它线程所用的风险，因为<strong>锁的释放是自动发生的</strong>。</p><h3 id="在线程间共享-Mutex"><a href="#在线程间共享-Mutex" class="headerlink" title="在线程间共享 Mutex"></a>在线程间共享 Mutex</h3><p>现在让我们尝试使用 Mutex<T> 在多个线程间共享值。我们将启动十个线程，并在各个线程中对同一个计数器值加一，这样计数器将从 0 变为 10。示例中的例子会出现编译错误，而我们将通过这些错误来学习如何使用 Mutex<T>，以及 Rust 又是如何帮助我们正确使用的。</p><p>示例: 程序启动了 10 个线程，每个线程都通过 Mutex<T> 来增加计数器的值</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个 counter 变量来存放内含 i32 的 Mutex<T>，类似示例 16-12 那样。接下来遍历 range 创建了 10 个线程。使用了 thread::spawn 并对所有线程使用了相同的闭包：他们每一个都将调用 lock 方法来获取 Mutex<T> 上的锁，接着将互斥器中的值加一。当一个线程结束执行，num 会离开闭包作用域并释放锁，这样另一个线程就可以获取它了。</p><p>在主线程中，我们收集了所有的 join 句柄，调用它们的 join 方法来确保所有线程都会结束。这时，主线程会获取锁并打印出程序的结果。</p><p>编译失败：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.<span class="number">1.0</span> (file:<span class="comment">///projects/shared-state)</span></span><br><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `counter`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">9</span>:<span class="number">36</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">5</span>  |     <span class="keyword">let</span> <span class="variable">counter</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">   |         ------- <span class="keyword">move</span> occurs because `counter` has <span class="keyword">type</span> `Mutex&lt;<span class="type">i32</span>&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">...</span><br><span class="line"><span class="number">9</span>  |         <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |                                    ^^^^^^^ value moved into closure here, <span class="keyword">in</span> previous iteration of <span class="keyword">loop</span></span><br><span class="line"><span class="number">10</span> |             <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">   |                           ------- <span class="keyword">use</span> occurs due to <span class="keyword">use</span> <span class="keyword">in</span> closure</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">error: could not compile `shared-state` due to previous error</span><br></pre></td></tr></table></figure><p>错误信息表明 counter 值在上一次循环中被移动了。所以 Rust 告诉我们<strong>不能将</strong> <strong>counter</strong> <strong>锁的所有权移动到多个线程中</strong>。</p><h3 id="多线程和多所有权"><a href="#多线程和多所有权" class="headerlink" title="多线程和多所有权"></a>多线程和多所有权</h3><p>通过使用智能指针 Rc<T> 来创建引用计数的值，可以拥有多所有者。</p><p>示例: 尝试使用 Rc<T> 来允许多个线程拥有 Mutex<T></p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一次编译并…出现了不同的错误！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.1.0 (file:///projects/shared-state)</span><br><span class="line">error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">   --&gt; src/main.rs:11:22</span><br><span class="line">    |</span><br><span class="line">11  |           <span class="built_in">let</span> handle = thread::spawn(move || &#123;</span><br><span class="line">    |  ______________________^^^^^^^^^^^^^_-</span><br><span class="line">    | |                      |</span><br><span class="line">    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">12  | |             <span class="built_in">let</span> mut num = counter.lock().unwrap();</span><br><span class="line">13  | |</span><br><span class="line">14  | |             *num += 1;</span><br><span class="line">15  | |         &#125;);</span><br><span class="line">    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">    |</span><br><span class="line">    = <span class="built_in">help</span>: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented <span class="keyword">for</span> `Rc&lt;Mutex&lt;i32&gt;&gt;`</span><br><span class="line">    = note: required because it appears within the <span class="built_in">type</span> `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">note: required by a bound <span class="keyword">in</span> `spawn`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `shared-state` due to previous error</span><br></pre></td></tr></table></figure><p>第一行错误表明 Rc<Mutex<i32>&gt;<code>cannot be sent between threads safely</code>。编译器也告诉了我们原因 <code>the trait</code>Send<code>is not implemented for</code>Rc<Mutex<i32>&gt;。下一部分会讲到 Send：这是确保所使用的类型可以用于并发环境的 trait 之一。</p><p>不幸的是，<strong>Rc<T></strong> <strong>并不能安全的在线程间共享</strong>。当 Rc<T> 管理引用计数时，它必须在每一个 clone 调用时增加计数，并在每一个克隆被丢弃时减少计数。<strong>Rc<T></strong> <strong>并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断</strong>。在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个完全类似 Rc<T>，又以一种线程安全的方式改变引用计数的类型。</p><h3 id="原子引用计数-Arc"><a href="#原子引用计数-Arc" class="headerlink" title="原子引用计数 Arc"></a>原子引用计数 Arc<T></h3><p>Arc<T><strong>正是</strong> 这么一个类似 Rc<T> 并可以安全的用于并发环境的类型。字母 “a” 代表 <strong>原子性</strong>（<em>atomic</em>），所以这是一个 <strong>原子引用计数</strong>（<em>atomically reference counted</em>）类型.</p><p>为什么不是所有的原始类型都是原子性的？为什么不是所有标准库中的类型都默认使用 Arc<T> 实现？</p><p>原因在于<strong>线程安全带有性能惩罚</strong>，我们希望只在必要时才为此买单。如果只是在单线程中对值进行操作，原子性提供的保证并无必要，代码可以因此运行的更快。</p><p>示例: 使用 Arc<T> 包装一个 Mutex<T> 能够实现在多线程之间共享所有权</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会打印出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Result</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="RefCell-Rc-与-Mutex-Arc-的相似性"><a href="#RefCell-Rc-与-Mutex-Arc-的相似性" class="headerlink" title="RefCell/Rc 与 Mutex/Arc 的相似性"></a>RefCell/Rc 与 Mutex/Arc 的相似性</h3><ul><li>因为 counter 是不可变的，不过可以获取其内部值的可变引用；这意味着 Mutex<T> 提供了内部可变性，就像 Cell 系列类型那样。正如使用 RefCell<T> 可以改变 Rc<T> 中的内容那样，同样的可以使用 Mutex<T> 来改变 Arc<T> 中的内容。</li><li>Rust 不能避免使用 Mutex<T> 的全部逻辑错误。回忆一下使用 Rc<T> 就有造成引用循环的风险，这时两个 Rc<T> 值相互引用，造成内存泄漏。同理，Mutex<T> 也有造成 <strong>死锁</strong>（<em>deadlock</em>） 的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。</li></ul><h2 id="使用-Sync-和-Send-trait-的可扩展并发"><a href="#使用-Sync-和-Send-trait-的可扩展并发" class="headerlink" title="使用 Sync 和 Send trait 的可扩展并发"></a>使用 Sync 和 Send trait 的可扩展并发</h2><p>Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 <strong>甚少</strong>。我们之前讨论的几乎所有内容，都属于标准库，而不是语言本身的内容。由于不需要语言提供并发相关的基础设施，并发方案不受标准库或语言所限：我们可以编写自己的或使用别人编写的并发功能。</p><p>然而有两个并发概念是<strong>内嵌于语言中</strong>的：<strong>std::marker 中的 Sync 和 Send trait。</strong></p><h3 id="通过-Send-允许在线程间转移所有权"><a href="#通过-Send-允许在线程间转移所有权" class="headerlink" title="通过 Send 允许在线程间转移所有权"></a>通过 Send 允许在线程间转移所有权</h3><ul><li>Send 标记 trait 表明实现了 Send 的类型值的所有权可以在线程间传送。</li><li>几乎所有的 Rust 类型都是 Send 的，</li><li>不过有一些例外，包括 <strong>Rc<T>：这是不能 Send 的，</strong></li></ul><p>因为如果克隆了 Rc<T> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。为此，Rc<T> 被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价。</p><ul><li>Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 Rc<T> 在线程间发送。当尝试这么做的时候，会得到错误 the trait Send is not implemented for Rc<Mutex<i32>&gt;。而使用标记为 Send 的 Arc<T> 时，就没有问题了。</li><li>任何完全由 Send 的类型组成的类型也会自动被标记为 Send。<strong>几乎所有基本类型都是 Send 的，除了裸指针（raw pointer）</strong>。</li></ul><h3 id="Sync-允许多线程访问"><a href="#Sync-允许多线程访问" class="headerlink" title="Sync 允许多线程访问"></a>Sync 允许多线程访问</h3><ul><li>Sync 标记 trait 表明一个实现了 Sync 的类型可以<strong>安全的在多个线程中拥有其值的引用</strong>。</li><li>换一种方式来说，<strong>对于任意类型 T，如果 &amp;T（T 的不可变引用）是 Send 的话 T 就是 Sync 的</strong>，这意味着其引用就可以安全的发送到另一个线程。</li><li>类似于 Send 的情况，基本类型是 Sync 的，完全由 Sync 的类型组成的类型也是 Sync 的。</li><li><strong>智能指针 Rc<T> 也不是 Sync 的，出于其不是 Send 相同的原因。RefCell<T>和 Cell<T> 系列类型不是 Sync 的。RefCell<T> 在运行时所进行的借用检查也不是线程安全的。</strong></li><li><strong>Mutex<T> 是 Sync 的</strong>，正如 “在线程间共享 Mutex”部分所讲的它可以被用来在多线程中共享访问。</li></ul><h3 id="手动实现-Send-和-Sync-是不安全的"><a href="#手动实现-Send-和-Sync-是不安全的" class="headerlink" title="手动实现 Send 和 Sync 是不安全的"></a>手动实现 Send 和 Sync 是不安全的</h3><ul><li>通常并不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync 的。</li><li>因为他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。</li><li>手动实现这些标记 trait 涉及到编写不安全的 Rust 代码，</li></ul><p>当前重要的是，在创建新的由不是 Send 和 Sync 的部分构成的并发类型时需要多加小心，以确保维持其安全保证。<a href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a> 中有更多关于这些保证以及如何维持他们的信息。</p><h1 id="Rust-的面向对象特性"><a href="#Rust-的面向对象特性" class="headerlink" title="Rust 的面向对象特性"></a>Rust 的面向对象特性</h1><h2 id="面向对象语言的特点"><a href="#面向对象语言的特点" class="headerlink" title="面向对象语言的特点"></a>面向对象语言的特点</h2><ul><li><strong>对象包含数据和行为</strong></li></ul><p>在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。虽然带有方法的结构体和枚举并不被 <strong>称为</strong> 对象，但是他们提供了与对象相同的功能，</p><ul><li><strong>封装隐藏了实现细节</strong></li></ul><p><strong>封装</strong>（<em>encapsulation</em>）的思想：对象的实现细节不能被使用对象的代码获取到。所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。</p><p>Rust 中可以使用 pub 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的。</p><p>举例：</p><p>比如，我们可以定义一个包含一个 i32 类型 vector 的结构体 AveragedCollection。结构体也可以有一个字段，该字段保存了 vector 中所有值的平均值。这样，希望知道结构体中的 vector 的平均值的人可以随时获取它，而无需自己计算。换句话说，AveragedCollection 会为我们缓存平均值结果。下面示例有 AveragedCollection 结构体的定义：</p><p>示例: AveragedCollection 结构体维护了一个整型列表和集合中所有元素的平均值。</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AveragedCollection</span> &#123;</span><br><span class="line">    list: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    average: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>结构体自身被标记为 pub，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的</strong>。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 add、remove 和 average 方法来做到这一点，如示例所示：</p><p>示例: 在 AveragedCollection 结构体上实现了 add、remove 和 average 公有方法</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">AveragedCollection</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.list.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">update_average</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">self</span>.list.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">update_average</span>();</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">average</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.average</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update_average</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = <span class="keyword">self</span>.list.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>();</span><br><span class="line">        <span class="keyword">self</span>.average = total <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.list.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公有方法 add、remove 和 average 是修改 AveragedCollection 实例的唯一方式。当使用 add 方法把一个元素加入到 list 或者使用 remove 方法来删除时，这些方法的实现同时会调用私有的 update_average 方法来更新 average 字段。</p><p>list 和 average 是私有的，所以没有其他方式来使得外部的代码直接向 list 增加或者删除元素，否则 list 改变时可能会导致 average 字段不同步。average 方法返回 average 字段的值，这使得外部的代码只能读取 average 而不能修改它。</p><p>因为我们已经封装好了 AveragedCollection 的实现细节，将来可以轻松改变类似数据结构这些方面的内容。例如，可以使用 HashSet<i32> 代替 Vec<i32> 作为 list 字段的类型。只要 add、remove 和 average 公有函数的签名保持不变，使用 AveragedCollection 的代码就无需改变。相反如果使得 list 为公有，就未必都会如此了： HashSet<i32> 和 Vec<i32> 使用不同的方法增加或移除项，所以如果要想直接修改 list 的话，外部的代码可能不得不做出修改。</p><p>如果封装是一个语言被认为是面向对象语言所必要的方面的话，那么 Rust 满足这个要求。在代码中不同的部分使用 pub 与否可以封装其实现细节。</p><ul><li><strong>继承，作为类型系统与代码共享</strong></li></ul><p><strong>继承</strong>（<em>Inheritance</em>）是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。</p><p><strong>如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的</strong>。无法定义一个结构体继承父结构体的成员和方法。然而，如果你过去常常在你的编程工具箱使用继承，根据你最初考虑继承的原因，Rust 也提供了其他的解决方案。</p><p>选择继承有两个主要的原因。</p><ol><li>第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现。相反 Rust 代码可以使用默认 trait 方法实现来进行共享，</li><li>第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 <strong>多态</strong>（<em>polymorphism</em>），这意味着如果多种对象共享特定的属性，则可以相互替代使用。</li></ol><p>近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。<strong>子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用</strong>，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。</p><h2 id="不同类型值的-trait-对象"><a href="#不同类型值的-trait-对象" class="headerlink" title="不同类型值的 trait 对象"></a>不同类型值的 trait 对象</h2><p>vector 只能存储同种类型元素的局限。我们之前的示例中提供了一个定义 SpreadsheetCell 枚举来储存整型，浮点型和文本成员的替代方案。这意味着可以在每个单元中储存不同类型的数据，并仍能拥有一个代表一排单元的 vector。这在当编译代码时就知道希望可以交替使用的类型为固定集合的情况下是完全可行的。</p><p><strong>然而有时我们希望库用户在特定情况下能够扩展有效的类型集合。</strong></p><p>为了展示如何实现这一点，这里将创建一个图形用户接口（Graphical User Interface， GUI）工具的例子，它通过遍历列表并调用每一个项目的 draw 方法来将其绘制到屏幕上 —— 此乃一个 GUI 工具的常见技术。我们将要创建一个叫做 gui 的库 crate，它含一个 GUI 库的结构。这个 GUI 库包含一些可供开发者使用的类型，比如 Button 或 TextField。在此之上，gui 的用户希望创建自定义的可以绘制于屏幕上的类型：比如，一个程序员可能会增加 Image，另一个可能会增加 SelectBox。</p><p>这个例子中并不会实现一个功能完善的 GUI 库，不过会展示其中各个部分是如何结合在一起的。编写库的时候，我们不可能知晓并定义所有其他程序员希望创建的类型。我们所知晓的是 gui 需要记录一系列不同类型的值，并需要能够对其中每一个值调用 draw 方法。这里无需知道调用 draw 方法时具体会发生什么，只要该值会有那个方法可供我们调用。</p><p>在拥有继承的语言中，可以定义一个名为 Component 的类，该类上有一个 draw 方法。其他的类比如 Button、Image 和 SelectBox 会从 Component 派生并因此继承 draw 方法。它们各自都可以覆盖 draw 方法来定义自己的行为，但是框架会把所有这些类型当作是 Component 的实例，并在其上调用 draw。</p><p>不过 Rust 并没有继承，我们得另寻出路。</p><h2 id="定义通用行为的-trait"><a href="#定义通用行为的-trait" class="headerlink" title="定义通用行为的 trait"></a>定义通用行为的 trait</h2><p>为了实现 gui 所期望的行为，让我们定义一个 Draw trait，其中包含名为 draw 的方法。接着可以定义一个存放 <strong>trait 对象（trait object）</strong> 的 vector。trait 对象指向一个实现了我们指定 trait 的类型的实例，以及一个用于在运行时查找该类型的 trait 方法的表。我们通过指定某种指针来创建 trait 对象，例如 &amp; 引用或 Box<T> 智能指针，还有 dyn keyword， 以及指定相关的 trait（ [“动态大小类型和 Sized trait”] 部分会介绍 trait 对象必须使用指针的原因）。我们可以使用 trait 对象代替泛型或具体类型。任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。如此便无需在编译时就知晓所有可能的类型。</p><p>Rust 刻意不将结构体与枚举称为 “对象”，以便与其他语言中的对象相区别。在结构体或枚举中，结构体字段中的数据和 impl 块中的行为是分开的，不同于其他语言中将数据和行为组合进一个称为对象的概念中。</p><p>trait 对象将数据和行为两者相结合，从这种意义上说 <strong>则</strong> 其更类似其他语言中的对象。不过 trait 对象不同于传统的对象，因为不能向 trait 对象增加数据。trait 对象并不像其他语言中的对象那么通用：其（trait 对象）具体的作用是允许对通用行为进行抽象。</p><p>下面的示例展示了如何定义一个带有 draw 方法的 trait Draw：</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面定义了一个存放了名叫 components 的 vector 的结构体 Screen。这个 vector 的类型是 Box<dyn Draw>，此为一个 trait 对象：它是 Box 中任何实现了 Draw trait 的类型的替身。</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例: 一个 Screen 结构体的定义，它带有一个字段 components，其包含实现了 Draw trait 的 trait 对象的 vector</p><p>在 Screen 结构体上，我们将定义一个 run 方法，该方法会对其 components 上的每一个组件调用 draw 方法，如示例所示：</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与定义使用了带有 trait bound 的泛型类型参数的结构体不同。<strong>泛型类型参数一次只能替代一个具体类型</strong>，而 <strong>trait 对象则允许在运行时替代多种具体类型</strong>。例如，可以定义 Screen 结构体来使用泛型和 trait bound，如示例所示：</p><p>示例: 一种 Screen 结构体的替代实现，其 run 方法使用泛型和 trait bound</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span>&lt;T: Draw&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Draw,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这<strong>限制了</strong>Screen 实例中的Vec存放的元素必须是相同类型的，即必须拥有一个全是 Button 类型或者全是 TextField 类型的组件列表。如果只需要<strong>同质（相同类型）集合</strong>，则倾向于使用泛型和 trait bound，因为其定义会在编译时采用具体类型进行单态化。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一方面，通过使用 trait 对象的方法，一个 Screen 实例可以存放一个既能存放Button，也能包含TextField的智能指针的 Vec<T>。</p><p><strong>实现 trait</strong></p><p>现在来增加一些实现了 Draw trait 的类型。我们将提供 Button 类型。真正实现 GUI 库超出了范畴，所以 draw 方法体中不会有任何有意义的实现。为了想象一下这个实现看起来像什么，一个 Button 结构体可能会拥有 width、height 和 label 字段，如示例所示：</p><p>文件名: src/lib.rs</p><p>示例: 一个实现了 Draw trait 的 Button 结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a button</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Button 上的 width、height 和 label 字段会和其他组件不同，比如 TextField 可能有 width、height、label 以及 placeholder 字段。每一个我们希望能在屏幕上绘制的类型都会使用不同的代码来实现 Draw trait 的 draw 方法来定义如何绘制特定的类型，像这里的 Button 类型（并不包含任何实际的 GUI 代码，这超出了本章的范畴）。除了实现 Draw trait 之外，比如 Button 还可能有另一个包含按钮点击如何响应的方法的 impl 块。这类方法并不适用于像 TextField 这样的类型。</p><p>如果一些库的使用者决定实现一个包含 width、height 和 options 字段的结构体 SelectBox，并且也为其实现了 Draw trait，如示例所示：</p><p>示例: 另一个使用 gui 的 crate 中，在 SelectBox 结构体上实现 Draw trait</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::Draw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    options: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a select box</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>库使用者现在可以在他们的 main 函数中创建一个 Screen 实例。至此可以通过将 SelectBox 和 Button 放入 Box<T> 转变为 trait 对象来增加组件。接着可以调用 Screen 的 run 方法，它会调用每个组件的 draw 方法。下面示例展示了这个实现：</p><p>示例: 使用 trait 对象来存储实现了相同 trait 的不同类型的值</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::&#123;Button, Screen&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">screen</span> = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(SelectBox &#123;</span><br><span class="line">                width: <span class="number">75</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                options: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yes&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Maybe&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;No&quot;</span>),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;OK&quot;</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编写库的时候，我们不知道何人会在何时增加 SelectBox 类型，不过 Screen 的实现能够操作并绘制这个新类型，因为 SelectBox 实现了 Draw trait，这意味着它实现了 draw 方法。</p><p>这个概念 —— 只关心值所反映的信息而不是其具体类型 —— 类似于动态类型语言中称为 <strong>鸭子类型</strong>（<em>duck typing</em>）的概念：如果它走起来像一只鸭子，叫起来像一只鸭子，那么它就是一只鸭子！在示例中 Screen 上的 run 实现中，run 并不需要知道各个组件的具体类型是什么。<strong>它并不检查组件是</strong> <strong>Button</strong> <strong>或者</strong> <strong>SelectBox</strong> <strong>的实例</strong>。<strong>通过指定</strong> <strong>Box<dyn Draw></strong> <strong>作为</strong> <strong>components</strong> <strong>vector 中值的类型</strong>，我们就定义了 Screen 为需要可以在其上调用 draw 方法的值。</p><p>使用 trait 对象和 Rust 类型系统来进行类似鸭子类型操作的优势是无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。如果值没有实现 trait 对象所需的 trait 则 Rust 不会编译这些代码。</p><p>例如，示例展示了当创建一个使用 String 做为其组件的 Screen 时发生的情况：</p><p>示例: 尝试使用一种没有实现 trait 对象的 trait 的类型</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::Screen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">screen</span> = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>))],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会遇到这个错误，因为 String 没有实现 rust_gui::Draw trait：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling gui v0.<span class="number">1.0</span> (file:<span class="comment">///projects/gui)</span></span><br><span class="line">error[E0277]: the <span class="keyword">trait</span> <span class="title class_">bound</span> `<span class="type">String</span>: Draw` is not satisfied</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">5</span>:<span class="number">26</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> |         components: <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>))],</span><br><span class="line">  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the <span class="keyword">trait</span> `Draw` is not implemented <span class="keyword">for</span> `<span class="type">String</span>`</span><br><span class="line">  |</span><br><span class="line">  = note: required <span class="keyword">for</span> <span class="title class_">the</span> cast to the object <span class="keyword">type</span> `<span class="keyword">dyn</span> Draw`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0277`.</span><br><span class="line">error: could not compile `gui` due to previous error</span><br></pre></td></tr></table></figure><p>这告诉了我们，要么是我们传递了并不希望传递给 Screen 的类型并应该提供其他类型，要么应该在 String 上实现 Draw 以便 Screen 可以调用其上的 draw。</p><h2 id="trait-对象执行动态分发"><a href="#trait-对象执行动态分发" class="headerlink" title="trait 对象执行动态分发"></a>trait 对象执行动态分发</h2><ul><li>对泛型使用 trait bound 时编译器所执行的单态化处理：编译器为每一个被泛型类型参数代替的具体类型生成了函数和方法的非泛型实现。单态化产生的代码在执行 <strong>静态分发</strong>（<em>static dispatch</em>）。</li><li>静态分发发生于编译器在编译时就知晓调用了什么方法的时候。</li><li><strong>动态分发</strong> （<em>dynamic dispatch</em> 编译器在编译时无法知晓调用了什么方法。</li><li>在动态分发的场景下，编译器生成的代码到运行时才能确定调用了什么方法。</li></ul><p><strong>当使用 trait 对象时，Rust 必须使用动态分发</strong>。编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。<strong>动态分发也阻止编译器有选择的内联方法代码</strong>，这会相应的<strong>禁用一些优化</strong>。尽管在编写示例和可以支持示例中的代码的过程中确实获得了额外的灵活性，但仍然需要权衡取舍。</p><h2 id="trait-对象需要类型安全"><a href="#trait-对象需要类型安全" class="headerlink" title="trait 对象需要类型安全"></a>trait 对象需要类型安全</h2><p><strong>只有对象安全（object-safe）的 trait 可以实现为 特征(dyn)对象</strong> 。</p><p>这里有一些复杂的规则来实现 trait 的对象安全，但在实践中，只有两个相关的规则。</p><p><strong>如果一个 trait 中定义的所有方法都符合以下规则，则该 trait 是对象安全的：</strong></p><ul><li><strong>返回值不是 Self</strong></li><li><strong>没有泛型类型的参数</strong></li></ul><p>我们使用triat对象我们实际上是在做 <strong>动态分发</strong>。Rust 在运行时通过一个叫 <strong>vtable</strong> 的方法表来找到对应的方法实现。为了做到这一点，trait 的方法必须能够在编译时 <strong>完全确定方法签名</strong>（包括返回值的类型信息等），不能依赖未知的类型信息。</p><p>但是某些 trait 的方法依赖了 <code>Self</code> 或泛型，这样编译器就无法保证动态分发是安全的。</p><p><strong>一个非对象安全的 trait 例子是标准库中的</strong> <strong>Clone</strong> <strong>trait</strong>。Clone trait 中的 clone 方法的声明如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Clone</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String 类型实现了 Clone trait，当我们在 String 的实例对象上调用 clone 方法时，我们会得到一个 String 类型实例对象。相似地，如果我们调用 Vec<T> 实例对象上的 clone 方法，我们会得到一个 Vec<T> 类型的实例对象。clone 方法的标签需要知道哪个类型是 Self 类型，因为 Self 是它的返回类型。</p><p>当我们尝试编译一些违反 trait 对象的对象安全规则的代码时，我们会收到编译器的提示。例如，我们想实现的 Screen 结构体来保存一个实现了 Clone trait 而不是 Draw trait 的类型，如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Clone</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将会收到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">   Compiling gui v0.1.0 (file:///projects/gui)</span><br><span class="line">error[E0038]: the trait `Clone` cannot be made into an object</span><br><span class="line"> --&gt; src/lib.rs:2:29</span><br><span class="line">  |</span><br><span class="line">2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,</span><br><span class="line">  |                             ^^^^^^^^^ `Clone` cannot be made into an object</span><br><span class="line">  |</span><br><span class="line">  = note: the trait cannot be made into an object because it requires `Self: Sized`</span><br><span class="line">  = note: <span class="keyword">for</span> a trait to be <span class="string">&quot;object safe&quot;</span> it needs to allow building a vtable to allow the call to be resolvable dynamically; <span class="keyword">for</span> more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety&gt;</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0038`.</span><br><span class="line">error: could not compile `gui` due to previous error</span><br></pre></td></tr></table></figure><p>这个错误意味着我们不能将此 trait 用于 trait 对象。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用至少两种方法让代码工作</span></span><br><span class="line"><span class="comment">// 不要添加/删除任何代码行</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">MyTrait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">u32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt;)  &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">13_u32</span>));</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方式修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">MyTrait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">u32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>(x: <span class="keyword">impl</span> <span class="title class_">MyTrait</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">MyTrait</span>  &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="number">13_u32</span>);</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">MyTrait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">u32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt; &#123; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">42</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt; &#123; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>()) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt; &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">13_u32</span>));</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象设计模式的实现"><a href="#面向对象设计模式的实现" class="headerlink" title="面向对象设计模式的实现"></a>面向对象设计模式的实现</h2><ul><li><strong>状态模式</strong>（<em>state pattern</em>）是一个面向对象设计模式。该模式的关键在于一个值有某些内部状态，体现为一系列的 <strong>状态对象</strong>，同时值的行为随着其内部状态而改变</li><li>状态对象共享功能：在 Rust 中使用结构体和 trait 而不是对象和继承。每一个状态对象负责其自身的行为，以及该状态何时应当转移至另一个状态。持有一个状态对象的值对于不同状态的行为以及何时状态转移毫不知情。</li><li>使用状态模式意味着当程序的业务需求改变时，无需改变值持有状态或者使用值的代码。我们只需更新某个状态对象中的代码来改变其规则，或者是增加更多的状态对象。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, _post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    state: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;&gt;,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Post &#123;</span><br><span class="line">        Post &#123;</span><br><span class="line">            state: <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Draft &#123;&#125;)),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_text</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, text: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">push_str</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">content</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="comment">// 委托给状态对象决定是否返回内容</span></span><br><span class="line">        <span class="keyword">self</span>.state.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">content</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">request_review</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="title function_ invoke__">Some</span>(s.<span class="title function_ invoke__">request_review</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">approve</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="title function_ invoke__">Some</span>(s.<span class="title function_ invoke__">approve</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 状态实现 =====</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Draft</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">Draft</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PendingReview &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PendingReview</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">PendingReview</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Published &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Published</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">Published</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        &amp;post.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 测试 =====</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">post</span> = Post::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    post.<span class="title function_ invoke__">add_text</span>(<span class="string">&quot;Rust makes systems programming safe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;&quot;</span>, post.<span class="title function_ invoke__">content</span>()); <span class="comment">// 还在草稿，不能看内容</span></span><br><span class="line"></span><br><span class="line">    post.<span class="title function_ invoke__">request_review</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;&quot;</span>, post.<span class="title function_ invoke__">content</span>()); <span class="comment">// 待审核，还是不能看内容</span></span><br><span class="line"></span><br><span class="line">    post.<span class="title function_ invoke__">approve</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;Rust makes systems programming safe!&quot;</span>, post.<span class="title function_ invoke__">content</span>()); <span class="comment">// 发布了！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Published content: &#123;&#125;&quot;</span>, post.<span class="title function_ invoke__">content</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="模式与模式匹配"><a href="#模式与模式匹配" class="headerlink" title="模式与模式匹配"></a>模式与模式匹配</h1><p><strong>模式：</strong></p><ul><li>模式是 Rust 中的一种特殊语法，用于匹配复杂和简单类型的结构</li><li>将模式与匹配表达式和其它构造结合使用，可以更好地控制程序的控制流</li><li>模式由以下元素(的一些组合)组成：<ul><li>字面值</li><li>解构的数组，enum,struct 和 tuple</li><li>变量</li><li>通配符</li><li>占位符</li></ul></li></ul><h2 id="match-的-Arm"><a href="#match-的-Arm" class="headerlink" title="match 的 Arm"></a>match 的 Arm</h2><ul><li>match VALUE{PARTTERN=&gt;EXPRESSION,PARTTERN=&gt;EXPRESSION,PARTTERN=&gt;EXPRESSION,}</li><li><p>表达式的要求：详尽（包含所有的可能性）</p></li><li><p>一个特殊的模式：_ (下划线)：它不会匹配任何东西，不会绑定到变量，通常用于 match 的最后一个 arm，或用于忽略某些值</p></li></ul><h2 id="条件-if-let-表达式"><a href="#条件-if-let-表达式" class="headerlink" title="条件 if let 表达式"></a>条件 if let 表达式</h2><ul><li>if let 表达式主要是作为一种简短的方式来等价的替代只有一个匹配项的 match</li><li>if let 可选的可以拥有 else，包括：<ul><li>else if</li><li>else if let</li></ul></li></ul><ul><li>但，if let 不会检查穷举性例子：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">favorite_color</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_tuesday</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span>: <span class="type">Result</span>&lt;<span class="type">u8</span>,_&gt; = <span class="string">&quot;34&quot;</span>.<span class="title function_ invoke__">parse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(color) = favorite_color&#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;Using your favorite color,&#123;&#125;,as the background&quot;</span>,color);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> is_tuesday&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Tuesday is green day!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(age) = age &#123;</span><br><span class="line">        <span class="keyword">if</span> age &gt; <span class="number">30</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Using purple as the background color&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Using orange as the background color&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Using blue as the background color&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-let-条件循环"><a href="#while-let-条件循环" class="headerlink" title="while let 条件循环"></a>while let 条件循环</h2><ul><li>只要模式继续满足匹配的条件，那它允许 while 循环一直运行</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for-循环的模式匹配"><a href="#for-循环的模式匹配" class="headerlink" title="for 循环的模式匹配"></a>for 循环的模式匹配</h2><ul><li>for 循环是 Rust 中最常见的循环</li><li>for 循环中，模式就是紧随 for 关键字后的值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">   <span class="keyword">for</span> (index,value) <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>,value,index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iter().enumerate()返回的是一个元组</p><h2 id="let-语句的模式匹配"><a href="#let-语句的模式匹配" class="headerlink" title="let 语句的模式匹配"></a>let 语句的模式匹配</h2><ul><li>let 语句也是模式</li><li>let PARTTERN = EXPRESSION</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> (x,y,z) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ul><li>函数的参数也可以是模式</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_coordinates</span>(&amp;(x,y): &amp;(<span class="type">i32</span>,<span class="type">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current location: (&#123;&#125;,&#123;&#125;)&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = (<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_coordinates</span>(&amp;point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可辨驳性：模式是否会无法匹配"><a href="#可辨驳性：模式是否会无法匹配" class="headerlink" title="可辨驳性：模式是否会无法匹配"></a>可辨驳性：模式是否会无法匹配</h2><ul><li>模式的两种形式：可辨驳的，无可辩驳的</li><li>能匹配任何可能传值的模式：无可辩驳的 入 let x= 4;</li><li>对某些可能的值，无法进行匹配的模式:可辨驳的 例如：if let Some(x) = a_value</li><li><strong>函数参数，let 语句，for 循环只接受无可辩驳的模式</strong></li><li><strong>if let 和 while let 接受可辨驳和无可辩驳的模式</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Some</span>(x) = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0005]: refutable pattern <span class="keyword">in</span> <span class="built_in">local</span> binding: `None` not covered</span><br><span class="line">   --&gt; src\main.rs:3:9</span><br><span class="line">    |</span><br><span class="line">3   |     <span class="built_in">let</span> Some(x) = a;</span><br><span class="line">    |         ^^^^^^^ pattern `None` not covered</span><br><span class="line">    |</span><br><span class="line">    = note: `<span class="built_in">let</span>` bindings require an <span class="string">&quot;irrefutable pattern&quot;</span>, like a `struct` or an `enum` with only one variant</span><br><span class="line">    = note: <span class="keyword">for</span> more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html</span><br></pre></td></tr></table></figure><p>无法匹配，因为模式没有覆盖 None 这种情况</p><p>修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = a&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match 除了最后一个分支，其它的分支都是可辨驳的，最后一个分支是不可辩驳的，因为它需要匹配所有剩余的情况</p><h2 id="匹配字面值"><a href="#匹配字面值" class="headerlink" title="匹配字面值"></a>匹配字面值</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h2><ul><li>命名的变量是可匹配任何值的无可辩驳模式</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched,y=&#123;:?&#125;&quot;</span>,y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default Case,x=&#123;:?&#125;&quot;</span>,x),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x=&#123;:?&#125;,y=&#123;:?&#125;&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 match 的第二个 arm 中<strong>y 是一个新的变量</strong>，存在于该 arm 的作用域</p><h2 id="匹配一个可变引用"><a href="#匹配一个可变引用" class="headerlink" title="匹配一个可变引用"></a>匹配一个可变引用</h2><p>使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V<strong>是一个值</strong>，而<strong>不是可变引用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;<span class="keyword">mut</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="comment">// The type of value is &amp;mut String</span></span><br><span class="line">       value =&gt; value.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重模式"><a href="#多重模式" class="headerlink" title="多重模式"></a>多重模式</h2><ul><li>在 match 表达式中，使用 | 语法（就是或的意思）可以匹配多种模式</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-来匹配某个范围的值"><a href="#使用-来匹配某个范围的值" class="headerlink" title="使用..=来匹配某个范围的值"></a>使用..=来匹配某个范围的值</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">match</span> x&#123;</span><br><span class="line">        <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one through five&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;j&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;early ASCII letter&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;k&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;late ASCII letter&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数字或字符都可以</p><h2 id="解构以分解值"><a href="#解构以分解值" class="headerlink" title="解构以分解值"></a>解构以分解值</h2><ul><li>可以使用模式来结构 struct,enum,tuple，从而引用这些类型值的不同部分</li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (x, y);</span><br><span class="line">    (x,..) = (<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    [.., y] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>([x,y],[<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构元组"><a href="#解构元组" class="headerlink" title="解构元组"></a>解构元组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> x, y) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    x += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point&#123;x:<span class="number">0</span>,y:<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123;x:a,y:b&#125;=p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>,a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简写形式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span>&#123;x,y&#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>,x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123;x,y:<span class="number">0</span>&#125;=&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>,x),<span class="comment">//要求y必须为0</span></span><br><span class="line">        Point &#123;x:<span class="number">0</span>,y&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>,y),<span class="comment">//要求x必须为0</span></span><br><span class="line">        Point &#123;x,y&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis:(&#123;&#125;,&#123;&#125;)&quot;</span>,x,y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h3><p>注意：下面的代码会触发copy或move</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:<span class="type">i32</span>,y:<span class="type">i32</span>&#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text)=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Text message:&#123;&#125;&quot;</span>,text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b)=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rgb is (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;</span>,r,g,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World\n&quot;</span>));</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Text message:&#123;&#125;&quot;</span>, text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rgb is (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;</span>, r, g, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of partially moved value: `msg`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">24</span>:<span class="number">22</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">17</span> |         Message::<span class="title function_ invoke__">Write</span>(text) =&gt; &#123;</span><br><span class="line">   |                        ---- value partially moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">24</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">   |                      ^^^ value borrowed here after partial <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">   = note: partial <span class="keyword">move</span> occurs because value has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` which comes from the expansion of the <span class="keyword">macro</span> `println` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line">help: borrow this binding <span class="keyword">in</span> the pattern to avoid moving the value</span><br><span class="line">   |</span><br><span class="line"><span class="number">17</span> |         Message::<span class="title function_ invoke__">Write</span>(<span class="keyword">ref</span> text) =&gt; &#123;</span><br><span class="line">   |                        +++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">error: could not compile `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) due to <span class="number">1</span> previous error</span><br></pre></td></tr></table></figure><p>可以匹配引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">match</span> &amp;msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Text message:&#123;&#125;&quot;</span>, text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rgb is (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;</span>, r, g, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:<span class="type">i32</span>,y:<span class="type">i32</span>&#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b))=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;,green &#123;&#125;,and blue &#123;&#125;&quot;</span>,r,g,b);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v))=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to hue &#123;&#125;,saturation &#123;&#125;,and value &#123;&#125;&quot;</span>,h,s,v);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> ((feet,inches),Point&#123;x,y&#125;) = ((<span class="number">3</span>,<span class="number">10</span>),Point&#123;x:<span class="number">3</span>,y:-<span class="number">10</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在模式中忽略值"><a href="#在模式中忽略值" class="headerlink" title="在模式中忽略值"></a>在模式中忽略值</h2><ul><li>有几种方式可以在模式中忽略整个值或部分值:</li></ul><h3 id="忽略整个值"><a href="#忽略整个值" class="headerlink" title="_ 忽略整个值"></a><strong>_ 忽略整个值</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(_:<span class="type">i32</span>,y:<span class="type">i32</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y is &#123;&#125;&quot;</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用嵌套-忽略值的一部分"><a href="#使用嵌套-忽略值的一部分" class="headerlink" title="使用嵌套_忽略值的一部分"></a><strong>使用嵌套_忽略值的一部分</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">match</span> (setting_value,new_setting_value) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Some</span>(_),<span class="title function_ invoke__">Some</span>(_))=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Can&#x27;t overwrite an existing customized value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt;&#123;</span><br><span class="line">            setting_value = new_setting_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;setting is &#123;:?&#125;&quot;</span>,setting_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first,_,third,_,fifth)=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers:&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,first,third,fifth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用以-开头命名来忽略未使用的变量"><a href="#使用以-开头命名来忽略未使用的变量" class="headerlink" title="使用以_开头命名来忽略未使用的变量"></a><strong>使用以_开头命名来忽略未使用的变量</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_s) = s &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模式匹配中_s 是一个新的变量，模式匹配把 s 所有权移动到_s,后面再访问 s 就会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of partially moved value: `s`</span><br><span class="line"> --&gt; src/main.rs:6:22</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="keyword">if</span> <span class="built_in">let</span> Some(_s) = s &#123;</span><br><span class="line">  |                 -- value partially moved here</span><br><span class="line">...</span><br><span class="line">6 |     println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">  |                      ^ value borrowed here after partial move</span><br><span class="line">  |</span><br><span class="line">  = note: partial move occurs because value has <span class="built_in">type</span> `String`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the macro `<span class="variable">$crate</span>::format_args_nl` <span class="built_in">which</span> comes from the expansion of the macro `println` (<span class="keyword">in</span> Nightly builds, run with -Z macro-backtrace <span class="keyword">for</span> more info)</span><br><span class="line"><span class="built_in">help</span>: borrow this binding <span class="keyword">in</span> the pattern to avoid moving the value</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="keyword">if</span> <span class="built_in">let</span> Some(ref _s) = s &#123;</span><br><span class="line">  |                 +++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) due to 1 previous error</span><br></pre></td></tr></table></figure><p>使用_</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_) = s &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_ ，不会发生绑定，不会移动所有权</p><h3 id="忽略值的剩余部分"><a href="#忽略值的剩余部分" class="headerlink" title="..(忽略值的剩余部分)"></a><strong>..(忽略值的剩余部分)</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">    z: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = Point&#123;x:<span class="number">0</span>,y:<span class="number">0</span>,z:<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">match</span> origin &#123;</span><br><span class="line">        Point &#123;x,..&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>,x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first,..,last)=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;,&#123;&#125;&quot;</span>,first,last)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要加逗号,</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first,..,last) =&gt; &#123;</span><br><span class="line">           <span class="built_in">assert_eq!</span>(first, <span class="number">2</span>);</span><br><span class="line">           <span class="built_in">assert_eq!</span>(last, <span class="number">2048</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-match-守卫来提供额外的条件"><a href="#使用-match-守卫来提供额外的条件" class="headerlink" title="使用 match 守卫来提供额外的条件"></a>使用 match 守卫来提供额外的条件</h2><ul><li>match 守卫就是 match arm 模式后额外的 if 条件，想要匹配该条件也必须满足</li><li>match 守卫适合更复杂的场景</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five:&#123;&#125;&quot;</span>,x),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,x),</span><br><span class="line">        <span class="literal">None</span> =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) <span class="keyword">if</span> n==y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched,n = &#123;:?&#125;&quot;</span>,n),<span class="comment">//这里if n==y不是一个模式，不会引用新的变量</span></span><br><span class="line">        _ =&gt;<span class="built_in">println!</span>(<span class="string">&quot;Default case,x =&#123;:?&#125;&quot;</span>,x),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end:x=&#123;:?&#125;,y=&#123;:?&#125;&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> <span class="keyword">if</span> y=&gt; <span class="built_in">println!</span>(<span class="string">&quot;yes&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a>@绑定</h2><ul><li>@ 符号可以让我们可以创建一个变量，该变量可以在测试某个值是否与模式匹配的同时保存该值</li></ul><p>就相当于一个等号</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    Hello &#123;id:<span class="type">i32</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span>, &#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range:&#123;&#125;&quot;</span>,id_variable);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found some other id:&#123;&#125;&quot;</span>,id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// fill in the blank to let p match the second arm</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">2</span>, y: <span class="number">20</span> &#125;; <span class="comment">// x can be [0, 5], y can be 10 20 or 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>, x),</span><br><span class="line">        <span class="comment">// second arm</span></span><br><span class="line">        Point &#123; x: <span class="number">0</span>..=<span class="number">5</span>, y: y@ (<span class="number">10</span> | <span class="number">20</span> | <span class="number">30</span>) &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用场景：</p><p>下面这段代码会报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id:  <span class="number">3</span>..=<span class="number">7</span>,</span><br><span class="line">        &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;</span>, id),<span class="comment">//Error cannot find value `id` in this scope</span></span><br><span class="line">        Message::Hello &#123; id: newid@<span class="number">10</span> | <span class="number">11</span> | <span class="number">12</span> &#125; =&gt; &#123;<span class="comment">//Error variable `newid` is not bound in all patterns pattern doesn&#x27;t bind `newid`</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;</span>, newid)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复错误</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id: id @<span class="number">3</span>..=<span class="number">7</span>,</span><br><span class="line">        &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;</span>, id),</span><br><span class="line">        Message::Hello &#123; id: newid@(<span class="number">10</span> | <span class="number">11</span> | <span class="number">12</span>) &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;</span>, newid)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unsafe-Rust"><a href="#unsafe-Rust" class="headerlink" title="unsafe Rust"></a>unsafe Rust</h1><ul><li>隐藏着第二个语言，它<strong>没有强制内存安全保证</strong>：unsafe Rust(不安全的 Rust)</li></ul><p>和普通的 Rust 一样，但提供了额外的超能力</p><ul><li>Unsafe Rust 存在的原因:</li></ul><ol><li>静态分析是保守的，使用 unsafe rust 就相当于告诉编译器：我知道自己在做什么，并承担相应的风险</li><li><strong>计算机硬件本身就是不安全的，Rust 需要能够进行底层系统编程</strong></li></ol><h2 id="unsafe-超能力"><a href="#unsafe-超能力" class="headerlink" title="unsafe 超能力"></a>unsafe 超能力</h2><ul><li>使用 unsafe 关键字来切换到 unsafe Rust，开启一个块，里面放着 unsafe 代码</li><li>unsafe Rust 里执行的四个动作（unsafe 超能力):</li></ul><ol><li><strong>解引用原始指针</strong></li><li><strong>调用 unsafe 函数或方法</strong></li><li><strong>访问或修改可变的静态变量</strong></li><li><strong>实现 unsafe trait</strong></li></ol><ul><li>注意：</li></ul><p>unsafe 并<strong>没有关闭借用检查或停用其它安全的安全检查</strong></p><p>任何内存安全相关的而错误必须留在 unsafe 块里</p><p>尽可能隔离 unsafe 代码，最好将其封装在安全的抽象里，提供安全的 API</p><h3 id="解引用原始指针"><a href="#解引用原始指针" class="headerlink" title="解引用原始指针"></a>解引用原始指针</h3><ul><li>原始指针</li></ul><p><strong>可变的： *mut T</strong></p><p><strong>不可变的： *const T</strong>，意味着<strong>指针在解引用后不能直接对其进行赋值</strong></p><p>注意：这里的*不是解引用符号，它是类型名的一部分</p><ul><li>与引用不同，原始指针:</li></ul><ol><li><strong>允许通过同时具有可变和不可变指针或指向同一位置的可变指针来忽略借用规则</strong></li><li><strong>无法保证能指向合理的内存</strong></li><li><strong>允许为 null</strong></li><li><strong>不实现任何自动清理</strong></li></ol><ul><li>放弃保证的安全，换取更好的性能/与其它语言或硬件接口的能力</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span>=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = <span class="number">0x012345usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在安全代码块里创建原始指针，但不能够解引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span>=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r1:&#123;&#125;&quot;</span>,*r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r2:&#123;&#125;&quot;</span>,*r2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = <span class="number">0x012345usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r:&#123;&#125;&quot;</span>,*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要使用原始指针？</p><ul><li>与 C 语言进行接口</li><li>构建借用检查器无法理解的安全抽象</li></ul><h3 id="调用-unsafe-函数或方法"><a href="#调用-unsafe-函数或方法" class="headerlink" title="调用 unsafe 函数或方法"></a>调用 unsafe 函数或方法</h3><ul><li>unsafe 函数或方法：在定义前加上了 unsafe 关键字<ul><li>调用前需手动满足一些条件（主要靠看文档），因为 Rust 无法对这些条件进行验证</li><li>需要在 unsafe 块里进行调用</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dangerous</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-unsafe-代码的安全抽象"><a href="#创建-unsafe-代码的安全抽象" class="headerlink" title="创建 unsafe 代码的安全抽象"></a>创建 unsafe 代码的安全抽象</h3><ul><li>函数包含 unsafe 代码并不意味着需要将整个函数标记为 unsafe</li><li>将 unsafe 代码包裹在安全函数中是一个常见的抽象</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice:&amp;<span class="keyword">mut</span>[<span class="type">i32</span>],mid:<span class="type">usize</span>)<span class="punctuation">-&gt;</span>(&amp;<span class="keyword">mut</span> [<span class="type">i32</span>],&amp;<span class="keyword">mut</span>[<span class="type">i32</span>])&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(mid&lt;=len);</span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid],&amp;<span class="keyword">mut</span> slice[mid..])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>= <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a,b) = r.<span class="title function_ invoke__">split_at_mut</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a,&amp;<span class="keyword">mut</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b,&amp;<span class="keyword">mut</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `*slice` as mutable more than once at a <span class="keyword">time</span></span><br><span class="line"> --&gt; src\main.rs:6:29</span><br><span class="line">  |</span><br><span class="line">3 | fn split_at_mut(slice:&amp;mut[i32],mid:usize)-&gt;(&amp;mut [i32],&amp;mut[i32])&#123;</span><br><span class="line">  |                       - <span class="built_in">let</span><span class="string">&#x27;s call the lifetime of this reference `&#x27;</span>1`</span><br><span class="line">...</span><br><span class="line">6 |     (&amp;mut slice[..mid],&amp;mut slice[mid..])</span><br><span class="line">  |     ------------------------^^^^^--------</span><br><span class="line">  |     |     |                 |</span><br><span class="line">  |     |     |                 second mutable borrow occurs here</span><br><span class="line">  |     |     first mutable borrow occurs here</span><br><span class="line">  |     returning this value requires that `*slice` is borrowed <span class="keyword">for</span> `<span class="string">&#x27;1`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0499`.</span></span><br></pre></td></tr></table></figure><p>使用 unfase 代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>],mid: <span class="type">usize</span>)<span class="punctuation">-&gt;</span>(&amp;<span class="keyword">mut</span> [<span class="type">i32</span>],&amp;<span class="keyword">mut</span> [<span class="type">i32</span>])&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(mid&lt;=len);</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        (</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, mid),</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(mid), len-mid)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>= <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a,b) = r.<span class="title function_ invoke__">split_at_mut</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a,&amp;<span class="keyword">mut</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b,&amp;<span class="keyword">mut</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" class="headerlink" title="使用 extern 函数调用外部代码"></a>使用 extern 函数调用外部代码</h3><ul><li>extern 关键字：简化创建和使用外部函数接口（FFI）的过程</li><li>外部函数接口(FFI，Foreign Function Interface) : 它允许一种编程语言定义函数，并让其它编程语言能调用这些函数</li><li>extern 块中声明的函数在 Rust 代码中总是不安全的。因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;<span class="comment">//&quot;C&quot;指明外部函数应用的二进制接口abi(application binary interface)</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span><span class="type">i32</span>;<span class="comment">//想要调用的外部函数的签名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C:&#123;&#125;&quot;</span>,<span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>应用二进制接口(ABI，Application Binary Interface):定义函数在汇编层的调用方式</strong></li><li>“C” ABI 是最常见的 ABI,它遵循 C 语言的 ABI</li></ul><h2 id="从其它语言调用-Rust-函数"><a href="#从其它语言调用-Rust-函数" class="headerlink" title="从其它语言调用 Rust 函数"></a>从其它语言调用 Rust 函数</h2><ul><li>可以使用 extern 创建接口，其它语言通过它们可以调用 Rust 函数</li><li>在 <strong>fn 前添加 extern 关键字，并指定 ABI</strong></li><li>还需<strong>添加#[no_mangle]注解：避免 Rust 在编译时改变它的名称</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_c</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Just called a Rust function from C!&quot;</span>);<span class="comment">//编译链接后就可被c语言访问了，extern 的使用无需 unsafe。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问或修改一个可变的静态变量"><a href="#访问或修改一个可变的静态变量" class="headerlink" title="访问或修改一个可变的静态变量"></a>访问或修改一个可变的静态变量</h2><ul><li>Rust 支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争</li><li>在 Rust 里，全局变量叫做静态(static)变量</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name is: &#123;&#125;&quot;</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态（static）变量类似常量。</li><li>通常静态变量的名称采用 SCREAMING_SNAKE_CASE 写法。</li><li>静态变量只能储存拥有 ‘static 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。</li><li>访问<strong>不可变静态变量</strong>是安全的。</li></ul><p>静态变量和常量的区别：</p><ul><li>静态变量中的值<strong>有一个固定的内存地址</strong>。使用这个值总是会访问相同的地址。常量则允许在任何被用到的时候<strong>复制其数据</strong>。</li><li>静态变量可以是可变的。<strong>访问和修改可变静态变量都是 不安全 的。</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_to_count</span>(inc: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_count</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何读写 COUNTER 的代码都必须位于 unsafe 块中。这段代码可以编译并如期打印出 COUNTER: 3，因为这是单线程的。<strong>拥有多个线程访问 COUNTER 则可能导致数据竞争</strong>。</p><p>拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，优先使用智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的。</p><h2 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h2><ul><li>当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。</li><li>可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="comment">// methods go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line">    <span class="comment">// method implementations go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><p>Sync 和 Send 标记 trait，编译器会自动为完全由 Send 和 Sync 类型组成的类型自动实现他们。如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync，则必须使用 unsafe。Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程间访问，所以需要我们自己进行检查并通过 unsafe 表明。</p><h2 id="访问联合体中的字段"><a href="#访问联合体中的字段" class="headerlink" title="访问联合体中的字段"></a>访问联合体中的字段</h2><p>仅适用于 unsafe 的最后一个操作是访问 <strong>联合体</strong> 中的字段，union 和 struct 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互。访问联合体的字段是不安全的，因为 <strong>Rust 无法保证当前存储在联合体实例中数据的类型</strong>。可以查看 (<a href="https://doc.rust-lang.org/reference/items/unions.html">https://doc.rust-lang.org/reference/items/unions.html</a>) 了解有关联合体的更多信息。</p><h2 id="何时使用不安全的代码"><a href="#何时使用不安全的代码" class="headerlink" title="何时使用不安全的代码"></a>何时使用不安全的代码</h2><p>使用 unsafe 来进行这五个操作（超能力）之一是没有问题的，甚至是不需要深思熟虑的，不过使得 unsafe 代码正确也实属不易，因为编译器不能帮助保证内存安全。当有理由使用 unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注可以更容易地在错误发生时追踪问题的源头。</p><h1 id="高级-trait"><a href="#高级-trait" class="headerlink" title="高级 trait"></a>高级 trait</h1><h2 id="在-trait-定义中使用关联类型来指定占位类型"><a href="#在-trait-定义中使用关联类型来指定占位类型" class="headerlink" title="在 trait 定义中使用关联类型来指定占位类型"></a>在 trait 定义中使用关联类型来指定占位类型</h2><ul><li>关联类型(associate type)是 trait 中的类型占位符，它可以用于 trait 的方法签名中：</li></ul><p>可以定义出包含某些类型的 trait，而在实现前无需知道这些类型是什么</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联类型与泛型的区别"><a href="#关联类型与泛型的区别" class="headerlink" title="关联类型与泛型的区别"></a>关联类型与泛型的区别</h2><div class="table-container"><table><thead><tr><th><strong>泛型</strong></th><th><strong>关联类型</strong></th></tr></thead><tbody><tr><td>每次实现 Trait 时标注类型</td><td>无需标注类型</td></tr><tr><td>可以为一个类型多次实现某个 Trait(不同的泛型参数)</td><td>无法为单个类型多次实现某个 Trait</td></tr></tbody></table></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator2</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span>&#123;<span class="comment">//只能实现一次</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>=<span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// impl Iterator for Counter&#123;//只能实现一次,第二次为String实现报错</span></span><br><span class="line"><span class="comment">//     type Item=String;</span></span><br><span class="line"><span class="comment">//     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span></span><br><span class="line"><span class="comment">//         None</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator2</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator2</span>&lt;<span class="type">u32</span>&gt; <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;<span class="comment">//可以为不同的类型实现多次</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关联类型主要用于提升代码的可读性</strong>，例如以下代码 :</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">CacheableItem</span>: <span class="built_in">Clone</span> + <span class="built_in">Default</span> + fmt::<span class="built_in">Debug</span> + Decodable + Encodable &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Address</span>: <span class="built_in">AsRef</span>&lt;[<span class="type">u8</span>]&gt; + <span class="built_in">Clone</span> + fmt::<span class="built_in">Debug</span> + <span class="built_in">Eq</span> + Hash;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">is_null</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比 AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash， Address 的使用可以极大的减少其它类型在实现该特征时所需的模版代码.</p><p>例子：使用关联类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用关联类型实现重新实现以下特征</span></span><br><span class="line"><span class="comment">// trait Contains &#123;</span></span><br><span class="line"><span class="comment">//    type A;</span></span><br><span class="line"><span class="comment">//    type B;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Contains</span>&lt;A, B&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, _: &amp;A, _: &amp;B) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">last</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Contains</span>&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, number_1: &amp;<span class="type">i32</span>, number_2: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        (&amp;<span class="keyword">self</span>.<span class="number">0</span> == number_1) &amp;&amp; (&amp;<span class="keyword">self</span>.<span class="number">1</span> == number_2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Grab the first number.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="keyword">self</span>.<span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab the last number.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">last</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="keyword">self</span>.<span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">difference</span>&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    container.<span class="title function_ invoke__">last</span>() - container.<span class="title function_ invoke__">first</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_1</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_2</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = <span class="title function_ invoke__">Container</span>(number_1, number_2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">        &amp;number_1, &amp;number_2,</span><br><span class="line">        container.<span class="title function_ invoke__">contains</span>(&amp;number_1, &amp;number_2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;First number: &#123;&#125;&quot;</span>, container.<span class="title function_ invoke__">first</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Last number: &#123;&#125;&quot;</span>, container.<span class="title function_ invoke__">last</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The difference is: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">difference</span>(&amp;container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A trait which checks if 2 items are stored inside of container.</span></span><br><span class="line"><span class="comment">// Also retrieves first or last value.</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Contains</span> &#123;</span><br><span class="line">    <span class="comment">// Define generic types here which methods will be able to utilize.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">A</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, _: &amp;<span class="keyword">Self</span>::A, _: &amp;<span class="keyword">Self</span>::B) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">last</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Contains</span> <span class="keyword">for</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="comment">// Specify what types `A` and `B` are. If the `input` type</span></span><br><span class="line">    <span class="comment">// is `Container(i32, i32)`, the `output` types are determined</span></span><br><span class="line">    <span class="comment">// as `i32` and `i32`.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">A</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">B</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `&amp;Self::A` and `&amp;Self::B` are also valid here.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, number_1: &amp;<span class="type">i32</span>, number_2: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        (&amp;<span class="keyword">self</span>.<span class="number">0</span> == number_1) &amp;&amp; (&amp;<span class="keyword">self</span>.<span class="number">1</span> == number_2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Grab the first number.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="keyword">self</span>.<span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab the last number.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">last</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="keyword">self</span>.<span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">difference</span>&lt;C: Contains&gt;(container: &amp;C) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    container.<span class="title function_ invoke__">last</span>() - container.<span class="title function_ invoke__">first</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_1</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_2</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = <span class="title function_ invoke__">Container</span>(number_1, number_2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">        &amp;number_1, &amp;number_2,</span><br><span class="line">        container.<span class="title function_ invoke__">contains</span>(&amp;number_1, &amp;number_2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;First number: &#123;&#125;&quot;</span>, container.<span class="title function_ invoke__">first</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Last number: &#123;&#125;&quot;</span>, container.<span class="title function_ invoke__">last</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The difference is: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">difference</span>(&amp;container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认泛型参数和运算符重载"><a href="#默认泛型参数和运算符重载" class="headerlink" title="默认泛型参数和运算符重载"></a>默认泛型参数和运算符重载</h2><ul><li>可以在使用泛型参数时为泛型指定一个默认的具体类型</li><li>语法：<PlaceholderType=ConcreteType></li><li>这种结束常用于运算符重载（operator overloading）</li><li><strong>Rust 不允许创建自己的运算符及重载任意的运算符</strong></li><li>但<strong>可以通过实现 std::ops 中列出的那些 trait 来重载一部分相应的运算符</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">3</span> &#125;,</span><br><span class="line">        Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是 add 的默认泛型参数 self</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meter</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meter&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Meter) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span>+(other.<span class="number">0</span>*<span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定泛型参数</p><p><strong>默认泛型参数的主要应用场景</strong></p><ul><li>扩展一个类型而不破坏现有的代码</li><li>允许在大部分用户都不需要的特定场景下进行自定义</li></ul><h2 id="完全限定语法-Fully-Qualified-Syntax"><a href="#完全限定语法-Fully-Qualified-Syntax" class="headerlink" title="完全限定语法(Fully Qualified Syntax)"></a>完全限定语法(Fully Qualified Syntax)</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is your captain speaking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();<span class="comment">//调用本身的方法</span></span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);<span class="comment">//调用Pilot trait中的方法</span></span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person);<span class="comment">//调用Wizard trait中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参的形式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a&#123;&#125;&quot;</span>,Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a&#123;&#125;&quot;</span>,Animal::<span class="title function_ invoke__">baby_name</span>());<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 baby_name 没有参数，编译器不知道是哪个 Dog 调用</p><ul><li>完全限定语法：<Type as Trait>::function(receiver_if_method,netx_arg,..) ;</li><li>可以在任何调用函数或方法的地方使用</li><li>允许忽略那些从其他上下文能推导出来的部分</li><li>当 Rust 无法区分你期望调用哪个具体实现的时候，才需要使用这种语法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a&#123;&#125;&quot;</span>,Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a&#123;&#125;&quot;</span>,&lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-supertrait-来要求-trait-附带其它-trait-的功能"><a href="#使用-supertrait-来要求-trait-附带其它-trait-的功能" class="headerlink" title="使用 supertrait 来要求 trait 附带其它 trait 的功能"></a>使用 supertrait 来要求 trait 附带其它 trait 的功能</h2><ul><li>需要在一个 trait 中使用其它 trait 的功能<ul><li>需要被依赖的 trait 也被实现</li><li>那个被间接以来的 trait 就是当前 trait 的 supertrait</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="keyword">self</span>, write&#125;;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len+<span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>,<span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len+<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>,output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>,<span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len+<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len+<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    x:<span class="type">i32</span>,</span><br><span class="line">    y:<span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutlinePrint</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;,&#123;&#125;)&quot;</span>,<span class="keyword">self</span>.x,<span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-newtype-模式在外部类型上实现外部-trait"><a href="#使用-newtype-模式在外部类型上实现外部-trait" class="headerlink" title="使用 newtype 模式在外部类型上实现外部 trait"></a>使用 newtype 模式在外部类型上实现外部 trait</h2><ul><li>孤儿类型：只有当 trait 或类型定义在本地包时，才能为该类型实现这个 trait</li><li>可以通过 newtype 模式来绕过这一规则<ul><li>利用 tuple struct（元组结构体）创建一个新的类型</li></ul></li></ul><p>（例子）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f,<span class="string">&quot;[&#123;&#125;]&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w=&#123;&#125;&quot;</span>,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="使用-newtype-模式实现类型安全和抽象"><a href="#使用-newtype-模式实现类型安全和抽象" class="headerlink" title="使用 newtype 模式实现类型安全和抽象"></a>使用 newtype 模式实现类型安全和抽象</h2><ul><li>newtype 模式可以：<ul><li>用来静态的保证各种值之间不会混淆并表明值的单位</li><li>为类型的某些细节提供抽象能力</li><li>通过轻量级的封装来隐藏内部实现细节</li></ul></li></ul><h2 id="使用类型别名创建类型同义词"><a href="#使用类型别名创建类型同义词" class="headerlink" title="使用类型别名创建类型同义词"></a>使用类型别名创建类型同义词</h2><ul><li>Rust 提供了类型别名的功能：——为现有的类型生产另外的名称（同义词）——并不是一个独立的类型——使用 type 关键字</li><li>主要用途：减少代码的字符重复</li><li>类似于C的typedef</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt;)&#123;</span><br><span class="line">    <span class="comment">//snip</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>()<span class="punctuation">-&gt;</span><span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt;&#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>:<span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类型别名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Thunk</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: Thunk)&#123;</span><br><span class="line">    <span class="comment">//snip</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>()<span class="punctuation">-&gt;</span>Thunk&#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>:Thunk = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,buf: &amp;[<span class="type">u8</span>])<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;<span class="type">usize</span>,Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(),Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,buf: &amp;[<span class="type">u8</span>])<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(),Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_fmt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,fmt: fmt::Arguments)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(),Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类型别名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="comment">// type Result&lt;T&gt; = Result&lt;T,std::io::Error&gt;;标准库中定义了这个</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::io::<span class="type">Result</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,buf: &amp;[<span class="type">u8</span>])<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;<span class="type">usize</span>&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,buf: &amp;[<span class="type">u8</span>])<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_fmt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,fmt: fmt::Arguments)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><ul><li>有一个名为！的特殊类型：<ul><li>它没有任何值，行话称为空类型（empty type）</li><li>我们倾向于叫它 never 类型，因为它在不返回的函数中充当返回类型</li></ul></li></ul><ul><li>不返回值的函数也被称作发散函数（diverging fuction)</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>() <span class="punctuation">-&gt;</span> !&#123;</span><br><span class="line">    <span class="comment">//return (),返回了单元类型,但是不可能创建出返回!类型的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>:<span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match 表达式要求各个分支返回的类型是相同的，而 continue 会返回 never 类型，该类型可以安全地强制转换为 num 所对应的类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T&#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>&#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="literal">None</span>=&gt;<span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic！返回 never 类型</p><h2 id="动态大小和-Sized-Trait"><a href="#动态大小和-Sized-Trait" class="headerlink" title="动态大小和 Sized Trait"></a>动态大小和 Sized Trait</h2><ul><li>Rust 需要在编译时确定为一个特定类型的值分配多少空间</li><li>动态大小的类型（Dynamically Sized Types,DST）的概念:<ul><li>编写代码时使用只有在运行时才能确定大小的值</li></ul></li></ul><ul><li><strong>str 是动态大小的类型</strong>（注意不是&amp;str）:只有运行时才能确定字符串的长度<br>以下代码无法正常工作:</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span>:<span class="type">str</span> = <span class="string">&quot;Hello therel&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>:<span class="type">str</span> = <span class="string">&quot;How is it going&quot;</span>;</span><br></pre></td></tr></table></figure><p>因为他们都是同一个类型，需要的空间应该一样，但是这里声明时没有确定共同的空间</p><p>解决办法: 使用&amp;str 字符串切片类型</p><h2 id="Rust-使用动态大小类型的通用方式"><a href="#Rust-使用动态大小类型的通用方式" class="headerlink" title="Rust 使用动态大小类型的通用方式"></a>Rust 使用动态大小类型的通用方式</h2><ul><li><strong>附带一些额外的元数据来存储动态信息的大小</strong><ul><li>使用动态大小类型时总会把它的值放在某种指针后面</li></ul></li></ul><h2 id="另外一种动态大小的类型：trait"><a href="#另外一种动态大小的类型：trait" class="headerlink" title="另外一种动态大小的类型：trait"></a>另外一种动态大小的类型：trait</h2><ul><li>每个 <strong>trait 都是一个动态大小的类型</strong>，可以通过名称对其进行引用</li><li>为了将 trait 用作 trait 对象，必须将它放置在某种指针之后<ul><li>例如 &amp;dyn Trait 或 Box<dyn Trait> (Rc<dyn Trait>) 之后</li></ul></li></ul><h2 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a>Sized trait</h2><ul><li>为了处理动态大小的类型，Rust 提供了一个 Sized trait 来确定一个类型的大小在编译时是否已知——<strong>编译时可计算出大小的类型会自动实现这一 trait</strong></li><li><strong>Rust 还会为每一个泛型函数隐式的添加 Sized 约束</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T&gt;(t:T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: <span class="built_in">Sized</span>&gt;(t:T)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，泛型函数只能被用于编译时已经知道大小的类型，可以通过特殊语法来解除这一限制</li></ul><h2 id="Sized-trait-约束"><a href="#Sized-trait-约束" class="headerlink" title="?Sized trait 约束"></a>?Sized trait 约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T: ?Sized&gt;(t:&amp;T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T 可能是也可能不是 Sized</li><li>这个语法只能用在 Sized 上面，不能被用于其它 trait</li></ul><h1 id="高级函数和闭包"><a href="#高级函数和闭包" class="headerlink" title="高级函数和闭包"></a>高级函数和闭包</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li>可以将函数传递给其它函数</li><li>函数在传递过程中会被强制转换为 fn 类型</li><li>fn 类型就是 <strong>函数指针(function pointer)</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">    x+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>,arg:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(arg) + <span class="title function_ invoke__">f</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">do_twice</span>(add_one, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The answer is:&#123;&#125;&quot;</span>,answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数指针与闭包的不同"><a href="#函数指针与闭包的不同" class="headerlink" title="函数指针与闭包的不同"></a>函数指针与闭包的不同</h2><ul><li><p><strong>fn 是一个类型而不是一个 trait</strong></p><ul><li>可以直接指定 fn 为参数类型，不用声明一个以 Fn trait 为约束的泛型参数</li></ul></li><li><p>函数指针实现了全部 3 种闭包 trait（Fn,FnMut,FnOnce）:</p><ul><li>总是可以把函数指针用作参数传递给一个接受闭包的参数</li><li>所以，倾向于搭配闭包 trait 的泛型来编写函数：可以同时接收闭包和普通函数</li></ul></li></ul><ul><li>某些情景，只想接收 fn 而不接收闭包<ul><li>与外部不支持闭包的代码交互：C 函数</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_strings</span>:<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">Value</span>(<span class="type">u32</span>),</span><br><span class="line">        Stop,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = Status::<span class="title function_ invoke__">Value</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_statuses</span>:<span class="type">Vec</span>&lt;Status&gt; = (<span class="number">0u32</span>..<span class="number">20</span>).<span class="title function_ invoke__">map</span>(Status::Value).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h2><ul><li>闭包使用 trait 进行表达，无法在函数中直接返回一个闭包，可以将一个实现了该 trait 的具体类型作为返回值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn returns_closure()-&gt;Fn(i32)-&gt;i32&#123;//返回类型大小不固定</span></span><br><span class="line"><span class="comment">//     |x| x+1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&gt;&#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>参考：</p><p>官方文档：</p><div class="tag link"><a class="link-card" title="宏" href="https://kaisery.github.io/trpl-zh-cn/ch20-05-macros.html"><div class="left"><img src="https://kaisery.github.io/trpl-zh-cn/favicon.svg"/></div><div class="right"><p class="text">宏</p><p class="url">https://kaisery.github.io/trpl-zh-cn/ch20-05-macros.html</p></div></a></div><p>Rust语言圣经</p><div class="tag link"><a class="link-card" title="宏" href="https://course.rs/advance/macro.html"><div class="left"><img src="https://course.rs/favicon.svg"/></div><div class="right"><p class="text">宏</p><p class="url">https://course.rs/advance/macro.html</p></div></a></div><p>Rust宏小册子</p><div class="tag link"><a class="link-card" title="The Little Book of Rust Macros" href="https://zjp-cn.github.io/tlborm/"><div class="left"><img src="https://zjp-cn.github.io/tlborm/favicon.svg"/></div><div class="right"><p class="text">The Little Book of Rust Macros</p><p class="url">https://zjp-cn.github.io/tlborm/</p></div></a></div><h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>参考：</p><p>Rust异步编程</p><div class="tag link"><a class="link-card" title="Asynchronous Programming in Rust" href="https://rust-lang.github.io/async-book/intro.html"><div class="left"><img src="https://rust-lang.github.io/async-book/favicon.png"/></div><div class="right"><p class="text">Asynchronous Programming in Rust</p><p class="url">https://rust-lang.github.io/async-book/intro.html</p></div></a></div><p>Rust语言圣经</p><div class="tag link"><a class="link-card" title="async/await 异步编程" href="https://course.rs/advance/async/intro.html"><div class="left"><img src="https://course.rs/favicon.svg"/></div><div class="right"><p class="text">async/await 异步编程</p><p class="url">https://course.rs/advance/async/intro.html</p></div></a></div><h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>);<span class="comment">// =&gt; Alice, this is Bob. Bob, this is Alice</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;1&#125;&#123;0&#125;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>), <span class="string">&quot;21&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;1&#125;&#123;&#125;&#123;0&#125;&#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>), <span class="string">&quot;2112&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;argument&#125;&quot;</span>, argument = <span class="string">&quot;test&quot;</span>); <span class="comment">// =&gt; &quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;name&#125;&#123;&#125;&quot;</span>, <span class="number">1</span>, name = <span class="number">2</span>), <span class="string">&quot;21&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;</span>,a = <span class="string">&quot;a&quot;</span>, b = <span class="string">&#x27;b&#x27;</span>, c = <span class="number">3</span> ), <span class="string">&quot;a 3 b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// named argument must be placed after other arguments</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;abc&#125; &#123;0&#125;&quot;</span>, <span class="number">2</span>, abc = <span class="string">&quot;def&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h2><p>默认情况下，通过空格来填充字符串</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// the following two are padding with 5 spaces</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>); <span class="comment">// =&gt;  &quot;Hello x    !&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:1$&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">5</span>); <span class="comment">// =&gt;  &quot;Hello x    !&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;1:0$&#125;!&quot;</span>, <span class="number">5</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello x    !&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;:width$&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>, width = <span class="number">5</span>), <span class="string">&quot;Hello x    !&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左对齐, 右对齐, 使用指定的字符填充</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// left align</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:&lt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>); <span class="comment">// =&gt; Hello x    !</span></span><br><span class="line">    <span class="comment">// right align</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;:&gt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello     x!&quot;</span>);</span><br><span class="line">    <span class="comment">// center align</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;:^5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello   x  !&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left align, pad with &#x27;&amp;&#x27;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello x&amp;&amp;&amp;&amp;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还能使用 0 来填充数字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:5&#125;!&quot;</span>, <span class="number">5</span>); <span class="comment">// =&gt; Hello     5!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:+&#125;!&quot;</span>, <span class="number">5</span>); <span class="comment">// =&gt;  Hello +5!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:05&#125;!&quot;</span>, <span class="number">5</span>); <span class="comment">// =&gt; Hello 00005!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:05&#125;!&quot;</span>, -<span class="number">5</span>); <span class="comment">// =&gt; Hello -0005!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;number:0&gt;width$&#125;&quot;</span>, number=<span class="number">1</span>, width=<span class="number">6</span>) == <span class="string">&quot;000001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h2><p>浮点数精度</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:.1$&#125;&quot;</span>, v, <span class="number">4</span>); <span class="comment">// same as &#123;:.4&#125; =&gt; 3.1416</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, v), <span class="string">&quot;3.14&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:+.2&#125;&quot;</span>, v), <span class="string">&quot;+3.14&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:.0&#125;&quot;</span>, v), <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串长度</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;0:.5&#125;&quot;</span>, s); <span class="comment">// =&gt; Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;1:.0$&#125;!&quot;</span>, <span class="number">3</span>, <span class="string">&quot;abcdefg&quot;</span>), <span class="string">&quot;Hello abc!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二进制，八进制，十六进制"><a href="#二进制，八进制，十六进制" class="headerlink" title="二进制，八进制，十六进制"></a>二进制，八进制，十六进制</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#b&#125;&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0b11011&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#o&#125;&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0o33&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#x&#125;&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0x1b&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#X&#125;&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0x1B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;!&quot;</span>, <span class="number">27</span>); <span class="comment">// hex with no prefix =&gt; 1b</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#010b&#125;&quot;</span>, <span class="number">27</span>); <span class="comment">// pad binary with 0, width = 10,  =&gt; 0b00011011</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="捕获环境中的值"><a href="#捕获环境中的值" class="headerlink" title="捕获环境中的值"></a>捕获环境中的值</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_person</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_format</span>() <span class="punctuation">-&gt;</span> (<span class="type">usize</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    (<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = <span class="title function_ invoke__">get_person</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;person&#125;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (width, precision) = <span class="title function_ invoke__">get_format</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scores</span> = [(<span class="string">&quot;sunface&quot;</span>, <span class="number">99.12</span>), (<span class="string">&quot;jack&quot;</span>, <span class="number">60.34</span>)];</span><br><span class="line">    <span class="comment">/* Make it print:</span></span><br><span class="line"><span class="comment">    sunface:   99.1</span></span><br><span class="line"><span class="comment">    jack:   60.3</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (name, score) <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;name&#125;: &#123;score:width$.precision$&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指数，指针地址，转义"><a href="#指数，指针地址，转义" class="headerlink" title="指数，指针地址，转义"></a>指数，指针地址，转义</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 指数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:2e&#125;&quot;</span>, <span class="number">1000000000</span>); <span class="comment">// =&gt; 1e9</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:2E&#125;&quot;</span>, <span class="number">1000000000</span>); <span class="comment">// =&gt; 1E9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针地址</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>= <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, v.<span class="title function_ invoke__">as_ptr</span>()); <span class="comment">// =&gt; 0x600002324050</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转义</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#123;&#125;&#125;&quot;</span>); <span class="comment">// =&gt; Hello &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h2><h3 id="unreachable"><a href="#unreachable" class="headerlink" title="unreachable!()"></a>unreachable!()</h3><p>这是标记程序不应输入的路径的标准宏。如果程序进入这些路径，程序将 panicked 并返回”‘internal error: entered unreachable code’”错误消息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">level</span> = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stage</span> = <span class="keyword">match</span> level &#123;</span><br><span class="line">        <span class="number">1</span>...<span class="number">5</span> =&gt; <span class="string">&quot;beginner&quot;</span>,</span><br><span class="line">        <span class="number">6</span>...<span class="number">10</span> =&gt; <span class="string">&quot;intermediate&quot;</span>,</span><br><span class="line">        <span class="number">11</span>...<span class="number">20</span> =&gt; <span class="string">&quot;expert&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, stage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- Compile time error --------------</span></span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code<span class="string">&#x27;, src/main.rs:7:20</span></span><br></pre></td></tr></table></figure><p>我们也可以为此设置自定义错误消息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- with a custom message ---</span></span><br><span class="line">_ =&gt; <span class="built_in">unreachable!</span>(<span class="string">&quot;Custom message&quot;</span>),</span><br><span class="line"><span class="comment">// -------------- Compile time error --------------</span></span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code: Custom message<span class="string">&#x27;, src/main.rs:7:20</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// --- with debug data ---</span></span><br><span class="line"><span class="string">_ =&gt; unreachable!(&quot;level is &#123;&#125;&quot;, level),</span></span><br><span class="line"><span class="string">// -------------- Compile time error --------------</span></span><br><span class="line"><span class="string">thread &#x27;</span>main<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code: level is <span class="number">22</span><span class="string">&#x27;, src/main.rs:7:14</span></span><br></pre></td></tr></table></figure><h2 id="misconception-corollaries"><a href="#misconception-corollaries" class="headerlink" title="misconception corollaries"></a>misconception corollaries</h2><h3 id="if-T-39-static-then-T-must-be-valid-for-the-entire-program"><a href="#if-T-39-static-then-T-must-be-valid-for-the-entire-program" class="headerlink" title="if T: &#39;static then T must be valid for the entire program"></a>if <code>T: &#39;static</code> then <code>T</code> must be valid for the entire program</h3><p><strong>Misconception Corollaries</strong></p><ul><li><code>T: &#39;static</code> should be read as <em>“<code>T</code> has a <code>&#39;static</code> lifetime”</em></li><li><code>&amp;&#39;static T</code> and <code>T: &#39;static</code> are the same thing</li><li>if <code>T: &#39;static</code> then <code>T</code> must be immutable</li><li>if <code>T: &#39;static</code> then <code>T</code> can only be created at compile time</li></ul><p>Most Rust beginners get introduced to the <code>&#39;static</code> lifetime for the first time in a code example that looks something like this:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_literal</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;str literal&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>They get told that <code>&quot;str literal&quot;</code> is hardcoded into the compiled binary and is loaded into read-only memory at run-time so it’s immutable and valid for the entire program and that’s what makes it <code>&#39;static</code>. These concepts are further reinforced by the rules surrounding defining <code>static</code> variables using the <code>static</code> keyword.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: This example is purely for illustrative purposes.</span></span><br><span class="line"><span class="comment">// Never use `static mut`. It&#x27;s a footgun. There are</span></span><br><span class="line"><span class="comment">// safe patterns for global mutable singletons in Rust but</span></span><br><span class="line"><span class="comment">// those are outside the scope of this article.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> MUT_BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// ❌ - mutating static is unsafe</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">99</span>, MUT_BYTES[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Regarding <code>static</code> variables</p><ul><li><strong>they can only be created at compile-time</strong></li><li><strong>they should be immutable, mutating them is unsafe</strong></li><li><strong>they’re valid for the entire program</strong></li></ul><p>The <code>&#39;static</code> lifetime was probably named after the default lifetime of <code>static</code> variables, right? So it makes sense that the <code>&#39;static</code> lifetime has to follow all the same rules, right?</p><p>Well yes, but <strong>a type <em>with</em> a <code>&#39;static</code> lifetime is different from a type <em>bounded by</em> a <code>&#39;static</code> lifetime</strong>. The latter can be dynamically allocated at run-time, can be safely and freely mutated, can be dropped, and can live for arbitrary durations.</p><p>It’s important at this point to distinguish <code>&amp;&#39;static T</code> from <code>T: &#39;static</code>.</p><p><code>&amp;&#39;static T</code> is an immutable reference to some <code>T</code> that can be safely held indefinitely long, including up until the end of the program. This is only possible if <code>T</code> itself is immutable and does not move <em>after the reference was created</em>. <code>T</code> does not need to be created at compile-time. It’s possible to generate random dynamically allocated data at run-time and return <code>&#39;static</code> references to it at the cost of leaking memory, e.g.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate random &#x27;static str refs at run-time</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rand_str_generator</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(rand_string.<span class="title function_ invoke__">into_boxed_str</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T: &#39;static</code> is some <code>T</code> that can be safely held indefinitely long, including up until the end of the program. <code>T: &#39;static</code> includes all <code>&amp;&#39;static T</code> however it also includes all owned types, like <code>String</code>, <code>Vec</code>, etc. The owner of some data is guaranteed that data will never get invalidated as long as the owner holds onto it, therefore the owner can safely hold onto the data indefinitely long, including up until the end of the program. <code>T: &#39;static</code> should be read as <em>“<code>T</code> is bounded by a <code>&#39;static</code> lifetime”</em> not <em>“<code>T</code> has a <code>&#39;static</code> lifetime”</em>. A program to help illustrate these concepts:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">drop_static</span>&lt;T: <span class="symbol">&#x27;static</span>&gt;(t: T) &#123;</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand::<span class="title function_ invoke__">random</span>() &#123;</span><br><span class="line">            <span class="comment">// all the strings are randomly generated</span></span><br><span class="line">            <span class="comment">// and dynamically allocated at run-time</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            strings.<span class="title function_ invoke__">push</span>(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strings are owned types so they&#x27;re bounded by &#x27;static</span></span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">mut</span> string <span class="keyword">in</span> strings &#123;</span><br><span class="line">        <span class="comment">// all the strings are mutable</span></span><br><span class="line">        string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;a mutation&quot;</span>);</span><br><span class="line">        <span class="comment">// all the strings are droppable</span></span><br><span class="line">        <span class="title function_ invoke__">drop_static</span>(string); <span class="comment">// ✅</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all the strings have been invalidated before the end of the program</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I am the end of the program&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Key Takeaways</strong></p><ul><li><p><code>T: &#39;static</code> should be read as <em>“<code>T</code> is bounded by a <code>&#39;static</code> lifetime”</em></p></li><li><p>if <code>T: &#39;static</code> then <code>T</code> can be a borrowed type with a <code>&#39;static</code> lifetime <em>or</em> an owned type</p></li><li><p>since</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">T:</span> <span class="comment">&#x27;static</span></span><br></pre></td></tr></table></figure><p>includes owned types that means</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">T</span></span><br></pre></td></tr></table></figure><ul><li>can be dynamically allocated at run-time</li><li>does not have to be valid for the entire program</li><li>can be safely and freely mutated</li><li>can be dynamically dropped at run-time</li><li>can have lifetimes of different durations</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM Interrupt Controller</title>
      <link href="/posts/2510220/"/>
      <url>/posts/2510220/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-22</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><p>参考文档：</p><div class="tag link"><a class="link-card" title="Arm Architecture Reference Manual Armv8" href="https://developer.arm.com/documentation/ddi0487/fc/"><div class="left"><img src="https://developer.arm.com/shared/common/img/favicon/favicon.ico"/></div><div class="right"><p class="text">Arm Architecture Reference Manual Armv8</p><p class="url">https://developer.arm.com/documentation/ddi0487/fc/</p></div></a></div><h2 id="ARM64异常处理之中断处理"><a href="#ARM64异常处理之中断处理" class="headerlink" title="ARM64异常处理之中断处理"></a>ARM64异常处理之中断处理</h2><ul><li><strong>ARM</strong>核心两个和中断相关的管脚：<strong>nIRQ</strong>和<strong>nFIQ</strong></li><li>每个<strong>CPU</strong>核心有一对这样的中断相关的管脚</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825185705111.png" alt="ARM® Cortex®-A72 MPCore ProcessorRevision: r0p3Technical Reference Manual"></p><ul><li>PSTATE状态中有两个比特位和中断相关<ul><li>I 用来屏蔽IRQ中断</li><li>F 用来屏蔽FIQ中断</li></ul></li></ul><p><strong>ARM64</strong>中的<strong>GIC</strong>控制器</p><ul><li>ARM提供了标准的GIC控制器，例如树莓派4b上支持GIC-400</li><li>树莓派3b上支持传统的中断方式（legacy interrupt）</li></ul><p><strong>Legacy Interrupt</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825185957548.png" alt="Legacy Interrupt"></p><h3 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a><strong>中断的处理过程</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825220741422.png" alt="中断处理的过程"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251025163458928.png" alt="Interrupt Handler in C code"></p><p>当处理器接受一个异常到 AArch64 执行状态时，所有的 PSTATE 中断掩码都会自动设置。这意味着后续的<br>异常将被禁用。如果软件要支持异常嵌套，例如，允许高优先级的中断去打断对低优先级源的处理，那么软<br>件需要显式地重新启用中断。<br>对于下面的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSR DAIFClr, #imm</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251025163402909.png" alt="Handling nested Interrupts"></p><p>嵌套处理程序需要一些额外的代码。它必须在堆栈上保存 SPSR_EL1 和 ELR_EL1 的内容。在确定（并清除）<br>中断源之后，我们还必须重新启用 IRQ。</p><h3 id="树莓派4B上的中断源"><a href="#树莓派4B上的中断源" class="headerlink" title="树莓派4B上的中断源"></a><strong>树莓派4B上的中断源</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825225558702.png" alt="树莓派4B上的中断源"></p><ul><li><p><strong>ARM Core n</strong>    (ARM核心的中断源)</p><ul><li><strong>PNS timer IRQ</strong>对应 <strong>A Non-secure EL1 physical timer</strong></li><li><strong>PS timer IRQ</strong>对应<strong>A secure EL1 physical timer</strong></li><li><strong>HP timer IRQ</strong>(Hypervisor)对应<strong>A Non-secure EL2 physical timer</strong></li><li><strong>V timer IRQ</strong> 对应 <strong>A virtual timer</strong></li><li><strong>PMU</strong> 是<strong>Performance Monitor Unit（性能监控单元）</strong></li><li>repeated 4 times 表示每个核心都有一组这样的中断源，树莓派有4个核心因此repeated 4 times</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826095549264.png" alt="Generic Timer"></p></li><li><p><strong>ARM_LOCAL</strong>    (只有CPU才能访问的中断源)</p></li><li><p><strong>ARMC</strong>    (CPU和GPU都能访问的中断源)</p></li><li><p><strong>VideoCore</strong>    (GPU核心的中断 源)</p><p>包括的中断如下表：</p><p><strong>VC(VideoCore) peripheral IRQs</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825230210414.png" alt="VideoCore Peripheral IRQs"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825230153579.png" alt="VideoCore Peripheral IRQs"></p></li><li><p><strong>ETH_PCIe</strong> (PCIe的中断)</p></li></ul><h2 id="树莓派4B的Legacy-Interrupt-Routing"><a href="#树莓派4B的Legacy-Interrupt-Routing" class="headerlink" title="树莓派4B的Legacy Interrupt Routing"></a><strong>树莓派4B</strong>的<strong>Legacy Interrupt Routing</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825225802525.png" alt="Legacy Interrupt Routing"></p><p>ARM Core IRQs直接路由到pre-core routing</p><p>ARMC和VC通过ARMC routing 硬件单元路由</p><h3 id="Legacy-IRQ-status-registers"><a href="#Legacy-IRQ-status-registers" class="headerlink" title="Legacy IRQ status registers"></a><strong>Legacy IRQ status registers</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825225938975.png" alt="Legacy IRQ status registers"></p><ul><li><p>FIQn/IRQn_PENDING2</p></li><li><p>FIQn/IRQn_PENDING0</p></li><li><p>FIQn/IRQn_PENDING1</p></li><li><p>FIQ/IRQ_SOURCEn</p><blockquote><p>当source 寄存器的bit8被设置了，那么你需要读PENDING2状态寄存器</p><p>如果PENDING2的bit24置位了，那么你需要读PENDING0的状态寄存器</p><p>如果PENDING2的bit25置位了，那么你需要读PENDING1的寄存器</p><p>软件需要一步一步读取中断状态寄存器</p></blockquote></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       ┌──────────────┐</span><br><span class="line">       │ SOURCE寄存器 │   ← ARM_LOCAL_IRQ_SOURCE0</span><br><span class="line">       └───────┬──────┘</span><br><span class="line">               │</span><br><span class="line">    ┌──────────┴──────────┐</span><br><span class="line">    │                     │</span><br><span class="line"> 本地中断？             <span class="attribute">bit8</span>=1？</span><br><span class="line">(定时器等)             (有外设/GPU中断)</span><br><span class="line">    │                     │</span><br><span class="line">    ↓                     ↓</span><br><span class="line">handle_timer_irq()   ┌───────────────┐</span><br><span class="line">                     │  PENDING2寄存器│</span><br><span class="line">                     └───────┬───────┘</span><br><span class="line">                             │</span><br><span class="line">          ┌───────────┬───────────┐</span><br><span class="line">          │           │           │</span><br><span class="line">     <span class="attribute">bit24</span>=1？    <span class="attribute">bit25</span>=1？     其它位？</span><br><span class="line">     去PENDING0   去PENDING1   直接是GPU中断</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Example</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250825230422582.png" alt="树莓派文档中判断类型的例子"></p><p>以ARM Core的generic timer为例</p><ul><li>Cortex-A72支持4个ARM Core的generic timer<ul><li><strong>CNT_PS_IRQ</strong>     Secure EL1 Physical Timer Event Interrupt</li><li><strong>CNT_PNS_IRQ</strong>      Nonsecure EL1 Physical Timer Event interrupt</li><li><strong>CNT_HP_IRQ</strong>        Hypervisor Physical Timer Event interrupt, EL2</li><li><strong>CNT_V_IRQ</strong>           Virtual Timer Event interrupt EL3</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826105237538.png" alt="CNTP_CTL_ELx和CNTP_TVAL_ELx"></p><p>Timer支持两种触发方式</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826105313370.png" alt="Timer的两种触发方式"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826105434716.png" alt="CNTP_CTL_EL0"></p><p><code>XXX_ELn</code> → 表示这个系统寄存器 <strong>可在 ELn 及更高特权级访问</strong>。</p><ul><li>比如 <code>CNTP_CTL_EL0</code> 就是 <strong>EL0 和 EL1 都能访问</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826105846910.png" alt="CNTP_TVAL_EL0"></p><h3 id="EL1的Nonsecure-generic-timer的中断处理流程"><a href="#EL1的Nonsecure-generic-timer的中断处理流程" class="headerlink" title="EL1的Nonsecure generic timer的中断处理流程"></a><strong>EL1的Nonsecure generic timer的中断处理流程</strong></h3><ol><li>初始化timer，设置<strong>cntp_ctl_el0</strong>寄存器的<strong>enable域为1</strong></li><li>给timer的<strong>TimeValue</strong>一个初值，设置<strong>cntp_tval_el0</strong>寄存器</li><li>打开树莓派中断控制器中和timer相关的中断，设置<strong>TIMER_CNTRL0</strong>寄存器中的<strong>CNT_PNS_IRQ</strong>为1</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826110142568.png" alt="TIMER_CNTRLx"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826110209383.png" alt="TIMER_CNTRLx"></p><ol><li><p>打开PSTATE寄存器中的IRQ中断总开关</p></li><li><p>Timer中断发生</p></li><li>CPU跳转到el1_irq汇编函数</li><li><strong>保存中断上下文</strong>(使用<strong>kernel_entry</strong>宏)</li><li>跳转到中断处理函数</li><li>读取ARM_LOCAL中中断状态寄存器<strong>IRQ_SOURCE0</strong></li><li>判断是否<strong>CNT_PNS_IRQ</strong>中断发生</li><li>如果是，重新设置TimeValue</li><li>返回到el1_irq汇编函数</li><li>恢复中断上下文</li><li>返回中断现场</li></ol><h3 id="中断现场"><a href="#中断现场" class="headerlink" title="中断现场"></a>中断现场</h3><ul><li>中断发生瞬间，CPU的状态包括：<ul><li>PSTATE寄存器</li><li>PC值</li><li>SP值</li><li>x0~x30寄存器</li></ul></li><li>使用一个栈框数据结构来描述需要保存的中断现场(struct pt_regs)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826110704640.png" alt="栈框"></p><p><strong>保存中断现场</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826110745607.png" alt="保存中断现场"></p><p><strong>恢复中断现场</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826110823118.png" alt="恢复中断现场"></p><h3 id="中断实验1：在树莓派上实现generic-timer"><a href="#中断实验1：在树莓派上实现generic-timer" class="headerlink" title="中断实验1：在树莓派上实现generic timer"></a>中断实验1：在树莓派上实现generic timer</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250826110924758.png" alt="实验1"></p><p>树莓派firmware启动时默认加载GIC控制器而不是使用Legacy Interrupt因此可以在QEMU上跑</p><ol><li><p>初始化timer，设置<strong>cntp_ctl_el0</strong>寄存器的<strong>enable域为1</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827230224054.png" alt="初始化timer"></p></li><li><p>给timer的<strong>TimeValue</strong>一个初值，设置<strong>cntp_tval_el0</strong>寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827230238100.png" alt="设置cntp_tval_el0"></p></li><li><p>打开树莓派中断控制器中和timer相关的中断，设置<strong>TIMER_CNTRL0</strong>寄存器中的<strong>CNT_PNS_IRQ</strong>为1</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827231440713.png" alt="CNT_PNS_IRQ宏定义"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827231506112.png" alt="树莓派TIMER_CNTRLx的地址"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827231410006.png" alt="设置TIMER_CNTRL0的CNT_PNS_IRQ"></p></li><li><p>打开PSTATE寄存器中的IRQ中断总开关</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827231538262.png" alt="打开PSTATE寄存器的IRQ中断总开关"></p></li><li><p>Timer中断发生</p></li><li><p>CPU跳转到el1_irq汇编函数</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827231620546.png" alt="异常向量表"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827233439350.png" alt="el1_irq处理逻辑"></p></li><li><p><strong>保存中断上下文</strong>(使用<strong>kernel_entry</strong>宏)</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827233409312.png" alt="中断保存上下文的宏定义"></p></li><li><p>跳转到中断处理函数</p></li><li><p>读取ARM_LOCAL中中断状态寄存器<strong>IRQ_SOURCE0</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827233805645.png" alt="ARM_LOCAL_IRQ_SOURCE0"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827233704448.png" alt="中断转发函数"></p></li><li><p>判断是否<strong>CNT_PNS_IRQ</strong>中断发生</p></li><li><p>如果是，重新设置TimeValue</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827233924549.png" alt="timer的中断处理函数"></p><ol><li>返回到el1_irq汇编函数</li><li>恢复中断上下文</li><li>返回中断现场</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827234104251.png" alt="image-20250827234104251"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250827234133603.png" alt="恢复中断现场的宏定义"></p><p>另一种实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/arm_local_reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;io.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;irq.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;printk.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">read_cntfrq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> v;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mrs %0, cntfrq_el0&quot;</span> : <span class="string">&quot;=r&quot;</span>(v))</span>;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ms -&gt; ticks</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">ms_to_ticks</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> f = read_cntfrq();</span><br><span class="line">  <span class="keyword">return</span> (f / <span class="number">1000UL</span>) * (<span class="type">unsigned</span> <span class="type">long</span>)ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置cntp_ctl_el0 enable域为1 开启EL1 Nonsecure generic timer</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">generic_timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov x0, #1\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;msr cntp_ctl_el0, x0&quot;</span></span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置cntp_ctl_el0 enable域为0 关闭EL1 Nonsecure generic timer</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">generic_timer_deinit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mov x0, #0\n&quot;</span></span></span><br><span class="line"><span class="params">               <span class="string">&quot;msr cntp_ctl_el0, x0&quot;</span></span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// %[name] → 引用约束变量</span></span><br><span class="line"><span class="comment">// %w[name] → 引用 低 32 位寄存器（如 w0, w1）</span></span><br><span class="line"><span class="comment">// %x[name] → 引用 完整 64 位寄存器（如 x0, x1）</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">generic_timer_reset</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;msr cntp_tval_el0, %x[timer_val]&quot;</span></span></span><br><span class="line"><span class="params">               :</span></span><br><span class="line"><span class="params">               : [timer_val] <span class="string">&quot;r&quot;</span>(val)</span></span><br><span class="line"><span class="params">               : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">enable_timer_interrupt</span><span class="params">(<span class="type">void</span>)</span> &#123; writel(CNT_PNS_IRQ, TIMER_CNTRL0); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*timer_callback)</span><span class="params">(<span class="type">void</span>)</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms, <span class="type">void</span> (*callback)(<span class="type">void</span>))</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化timer, cntp_ctl_el0 enable为1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ticks = ms_to_ticks(ms); <span class="comment">// ms -&gt; tick</span></span><br><span class="line">  generic_timer_reset(ticks);</span><br><span class="line">  <span class="comment">// 打开中断控制器和timer相关的中断</span></span><br><span class="line">  enable_timer_interrupt();</span><br><span class="line">  timer_callback = callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_start</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  raw_local_irq_disable(); <span class="comment">// 关闭PSTATE中断控制器总开关，防止初始化时被打断</span></span><br><span class="line">  generic_timer_init();    <span class="comment">// 打开cntp_ctl_el0.enbale=1，启动计数</span></span><br><span class="line">  raw_local_irq_enable();  <span class="comment">// 打开PSTATE中断控制器总开关，防止初始化时被打断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_stop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  raw_local_irq_disable(); <span class="comment">// 关闭PSTATE中断控制器总开关，防止初始化时被打断</span></span><br><span class="line">  generic_timer_deinit();</span><br><span class="line">  raw_local_irq_enable(); <span class="comment">// 打开PSTATE中断控制器总开关，防止初始化时被打断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_reset</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ticks = ms_to_ticks(ms); <span class="comment">// ms -&gt; tick</span></span><br><span class="line">  generic_timer_reset(ticks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  generic_timer_deinit();</span><br><span class="line">  <span class="keyword">if</span> (timer_callback) &#123;</span><br><span class="line">    timer_callback();</span><br><span class="line">    timer_callback = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(<span class="string">&quot;Core0 Timer interrupt received\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uart_init();</span><br><span class="line">  init_printk_done();</span><br><span class="line">  printk(<span class="string">&quot;Welcome to arm64 mini OS!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  raw_local_irq_enable(); <span class="comment">// 打开PSTATE中断控制器总开关</span></span><br><span class="line">  printk(<span class="string">&quot;timer test\n&quot;</span>);</span><br><span class="line">  timer_init(<span class="number">2000</span>, test_function);</span><br><span class="line">  timer_start();</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span>;</span><br><span class="line">  <span class="comment">/* my test*/</span></span><br><span class="line">  my_test();</span><br><span class="line">  <span class="comment">// data_abort在QEMU中不起作用</span></span><br><span class="line">  <span class="comment">// trigger_sync_data_abort();</span></span><br><span class="line"></span><br><span class="line">  trigger_sync_instruction_alignment();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    uart_send(uart_recv());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>顺序（推荐的顺序）</strong></p><ol><li><code>cntp_tval_el0</code> ← 写定时器值</li><li><code>TIMER_CNTRL0.CNT_PNS_IRQ</code> ← 打开外设中断路径</li><li><code>PSTATE.I</code> ← 关闭 CPU IRQ 总开关</li><li><code>cntp_ctl_el0.enable</code> ← 启动定时器</li><li><p><code>PSTATE.I</code> ← 打开 CPU IRQ 总开关</p><p>这种顺序保证 <strong>在 CPU 开 IRQ 前，外设和定时器都准备好了</strong>，所以一旦中断触发，CPU 能立刻收到并处理。</p></li></ol><p>在 <strong>裸机/内核初始化阶段</strong>，定时器还没准备好，如果这时候 CPU <strong>允许 IRQ</strong>，就可能被 <strong>别的外设中断打断</strong>，导致：</p><ul><li>初始化流程被中断，配置寄存器可能只做了一半。</li><li>定时器或者外设中断配置还没完成，就有中断 pending → 结果是中断丢失或乱序执行。</li></ul><h3 id="中断实验2：使用汇编函数的方式来保存和恢复中断现场"><a href="#中断实验2：使用汇编函数的方式来保存和恢复中断现场" class="headerlink" title="中断实验2：使用汇编函数的方式来保存和恢复中断现场"></a>中断实验2：使用汇编函数的方式来保存和恢复中断现场</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828162932926.png" alt="实验2"></p><p>关键在于<strong>使用函数方式lr寄存器被破坏</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828163516633.png" alt="kernel_entry"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828163836566.png" alt="el1_irq"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828163456205.png" alt="kernel_exit"></p><h2 id="GIC中断控制器"><a href="#GIC中断控制器" class="headerlink" title="GIC中断控制器"></a>GIC中断控制器</h2><ul><li>传统的中断控制器，例如树莓派4b上的legacy interrupt controller<ul><li>中断enable寄存器</li><li>中断disable寄存器</li><li>中断状态状态寄存器</li></ul></li><li>传统的使用简单状态寄存器的方式来管理中断，变得越来越难管理<ul><li>中断源变得越来越多</li><li>不同类型的中断，比如多核间的中断，中断优先级，软件定义的中断等、</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828193356484.png" alt="GIC版本"></p><p><strong>GIC 主要有两个主要的功能块</strong>：</p><ul><li><strong>Distributor</strong>：系统中的所有中断源都连接到 distributor。Distributor 提供寄存器来控制各个中断的属性，例<br>如优先级、状态、安全性、路由信息和启用状态。distributor 通过附加的 CPU 接口确定将哪个中断转发到内<br>核。</li><li><strong>CPU Interface</strong>：cpu 通过它接收中断。CPU 接口提供寄存器来屏蔽、识别和控制转发到该内核的中断状态。<br>系统中的每个内核都有一个单独的 CPU 接口。</li></ul><h3 id="GIC支持的中断类型"><a href="#GIC支持的中断类型" class="headerlink" title="GIC支持的中断类型"></a>GIC支持的中断类型</h3><ul><li><p><strong>SGI</strong> （<strong>Software Generated Interrupt</strong>）,软件产生的中断，软中断，用于给其他CPU核心发送中断信号</p></li><li><p><strong>PPI</strong> （<strong>Private Peripheral Interrupt</strong>）,私有的外设中断，该中断时某个指定的CPU独有的</p></li><li><p><strong>SPI</strong>（<strong>Shared Peripheral Interrupt</strong>）,共享的外设中断，所有CPU都可以访问这个中断</p></li><li><p><strong>LPI</strong> （<strong>Locality-specific Peripheral Interrupt</strong>）,本地特殊外设中断，<strong>GICv3新增的中断类型</strong>。<strong>基于消息传递的中断类型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828193912447.png" alt="GIC支持的中断类型"></p></li></ul><h3 id="中断的触发类型"><a href="#中断的触发类型" class="headerlink" title="中断的触发类型"></a>中断的触发类型</h3><p>每个中断类型要么是<strong>Edge-triggered</strong>的要么是<strong>Level-sensitive</strong>的：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831140733534.png" alt="中断的触发类型"></p><p>由<strong>GICD_ICFGRn</strong>寄存器控制</p><ul><li><strong>Edge-triggered</strong>: 当 GIC 检测到相关输入的上升沿时被认为是有效的，并且在清除之前保持有效</li><li><strong>Level-sensitive</strong>: 仅当 GIC 的相关输入为高电平时才有效</li></ul><h3 id="中断号"><a href="#中断号" class="headerlink" title="中断号"></a>中断号</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830235356196.png" alt="中断号"></p><blockquote><p>banked interrupt 意思是对于 <strong>SGI 和 PPI</strong>，虽然它们的 ID 在整个系统里一样（例如 Timer PPI 在所有核都是 <strong>ID30</strong>），但是 <strong>它们是私有的</strong>，每个 CPU 都有自己的一份，互不干扰。</p></blockquote><ul><li><strong>SGI (0–15)</strong>：某核触发 SGI0，不会影响别的核的 SGI0。</li><li><p><strong>PPI (16–31)</strong>：核 0 的 Timer PPI（比如 ID30）和核 1 的 Timer PPI（ID30）是独立的，它们不会共享。</p><blockquote><p>中断号 1020~1023是保留的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830235300131.png" alt="Special Interrupt numbers"></p></li></ul><h3 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h3><p>每个中断优先级设置在<strong>GICD_IPRIORITYRn</strong>寄存器中</p><p><strong>优先级字段的宽度</strong></p><ul><li>每个中断优先级字段是8bit</li><li>实际实现支持的优先级级数 = 2ⁿ，n ∈ [4, 8]（即 <strong>16 ~ 256 级</strong>）。</li><li>如果硬件实现的比 8 小，比如只实现 5 bit，则写入低 3 bit 是 <strong>RAZ/WI</strong>（读为 0、写无效）。</li></ul><p><strong>数值大小与优先级</strong></p><ul><li>数值越小，优先级越高</li><li>最大优先级值依赖实现</li><li>初始化默认应当给所有中断一个中等优先级，避免打断系统调度，常见是0xa0或0x80</li></ul><h3 id="中断状态"><a href="#中断状态" class="headerlink" title="中断状态"></a>中断状态</h3><ul><li><p><strong>inactive</strong> （不活跃状态）：<strong>中断处于无效状态</strong></p></li><li><p><strong>pending</strong> （等待状态）：<strong>中断处于有效状态，但是等待CPU响应该中断</strong></p></li><li><p><strong>active</strong> （活跃状态）：<strong>CPU已经响应该中断</strong></p></li><li><p><strong>active and pending</strong> （活跃并等待状态）：<strong>CPU正在响应该中断，但是该中断源又发送中断过来</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828194800627.png" alt="中断状态机"></p></li></ul><h3 id="中断路由"><a href="#中断路由" class="headerlink" title="中断路由"></a>中断路由</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829105109530.png" alt="Distributor"></p><p><strong>GICD_ITARGETSRn</strong> (<strong>Interrupt Processor Targets Registers</strong>)</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829104753310.png" alt="GICD_ITARGETSRn"></p><blockquote><p>GICD_ITARGETSRn寄存器<strong>用来配置Distributor可以把中断路由到哪个CPU上</strong>，是一个 32 位寄存器，通常每<strong>个中断有一个对应的寄存器</strong>。</p></blockquote><ul><li><strong>8bit来表示一个中断源，共四个中断源，每个bit代表能路由的CPU</strong></li><li><strong>byte-accessible</strong></li><li>某个bit设置了，说明该中断源可以路由到这个CPU上</li><li><strong>前32个中断源的路由配置是硬件设置好的，RO</strong></li><li>第33~1019号中断，可以由软件来配置其路由，RW</li></ul><p>对应<strong>计算方法</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830172455166.png" alt="计算方法"></p><blockquote><p>假设m是中断ID, n是对应寄存器号</p></blockquote><ul><li>GICD_ITARGETSRn寄存器与中断源的关系<ul><li>每个GICD_ITARGETSRn控制四个中断源</li><li><strong>n =  m DIV 4</strong></li><li>计算n后要加上GICD_ITARGETSRn寄存器的起始地址偏移0x800</li></ul></li><li>Priority字段的字节偏移<ul><li><strong>m MOD 4</strong>用来确定目标中断源对应的字节偏移<ul><li><strong>偏移 0</strong> 对应寄存器的 <strong>[7:0]</strong> 位（即最低字节），对应中断 ID <strong>m % 4 == 0</strong>。</li><li><strong>偏移 1</strong> 对应寄存器的 <strong>[15:8]</strong> 位，适用于 <strong>m % 4 == 1</strong>。</li><li><strong>偏移 2</strong> 对应寄存器的 <strong>[23:16]</strong> 位，适用于 <strong>m % 4 == 2</strong>。</li><li><strong>偏移 3</strong> 对应寄存器的 <strong>[31:24]</strong> 位，适用于 <strong>m % 4 == 3</strong>。</li></ul></li></ul></li></ul><p><strong>GICD_ITARGETSRn 是一个数组寄存器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830172659368.png" alt="CPU targets"></p><h3 id="GICV2中断控制器"><a href="#GICV2中断控制器" class="headerlink" title="GICV2中断控制器"></a>GICV2中断控制器</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828195150321.png" alt="GICV2中断控制器"></p><ul><li><strong>The Distributor registers</strong> (<strong>GICD_</strong>)      包含了<strong>中断设置和配置</strong></li><li><strong>The CPU Interface registers</strong> (<strong>GICC_</strong>)  包含<strong>CPU相关的特殊设置</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829104632703.png" alt="GIC logical partitioning"></p><p>中断传递的优先级和目标 core 都在 distributor 中配置。</p><p>外围设备 distributor 发送的中断都处于待处理状态。distributor 确定最高优先级的待处理的中断，可以传递<br>到 core 并将其转发到 CPU 接口，在 CPU 接口处，中断依次发送给 core，此时 core 接受 FIQ 或 IRQ 异常。<br>core 执行异常处理程序作为响应。处理程序从 CPU 接口寄存器中查询中断 ID 并开始执行中断服务程序。完<br>成后，处理程序必须写入 CPU 接口寄存器以报告处理结束。</p><p>Distributor 提供了报告不同中断 ID 的当前状态的寄存器。在多核/多处理器系统中，单个 GIC 可以由多个内<br>核共享（在 GICv2 中最多 8 个）。GIC 提供寄存器来控制 SPI 所对应的内核。这个机制使操作系统能够跨内<br>核共享和分发中断，并且协调工作。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>GIC 的寄存器实现都是<strong>外部 memory_map 形式</strong>。所有的核都可以访问公共的 Distributor，但是 CPU 接口是<br>banked 的，即每个核使用相同的地址访问自己的私有 CPU 接口。一个内核不可能访问另一个内核的 CPU 接<br>口。</p><p>Distributor 包含许多寄存器，您可以使用它们来配置各个中断的属性。这些可配置的属性有：</p><ul><li><strong>中断优先级</strong>（<strong>GICD_IPRIORITY</strong>)，distributor 使用它来确定哪个中断接下来被转发到 CPU 接口。</li><li><strong>中断配置</strong>（<strong>GICD_ICFGR</strong>）。这决定了中断是电平还是边缘敏感。不适用于 SGI。</li><li><strong>一个中断目标 core</strong>（<strong>GICD_ITARGETSR</strong>）。这确定了中断可以路由到哪些 core。仅适用于 SPI。</li><li><strong>中断启用或禁用状态</strong>（<strong>GICD_ISENABLERGICD_ICENABLER</strong>）。只有那些在 distributor 中启用的中断。<br>当它们处于待处理状态时有资格被路由到 cpu 接口。</li><li><strong>中断安全</strong> (<strong>GICD_IGROUPR</strong>) 确定中断是否分配给安全或非安全。</li><li><strong>中断状态</strong>。</li></ul><p>Distributor 还提供了优先级屏蔽，通过它可以防止低于某个优先级的中断到达内核。distributor 在确定是否可<br>以将挂起的中断转发到特定内核时使用它每个内核上的 CPU 接口有助于微调中断控制和处理核</p><p><strong>初始化</strong>：</p><p>Distributor 和 CPU interface 在复位时都被禁用。GIC 必须在复位后初始化，然后才能向内核提供中断。</p><p>在 Distributor 中，软件必须配置优先级、目标 core、安全性并启用各个中断。随后必须通过其控制寄存器<br>(<strong>GICD_CTLR</strong>) <strong>启用 distributor</strong>。</p><p>对于每个 CPU interface，软件必须对优先级掩码和优先级抢占进行设置。每个 CPU interface 本身必须通过控制寄存器 (<strong>GICD_CTLR</strong>) 启用。</p><p>在 cpu 处理中断之前，软件通过设置使 cpu准备好接受中断向量表中的有效中断向量，并清除 PSTATE 中的中断屏蔽位，并设置路由控制。</p><p>可以通过禁用 Distributor 来禁用系统中的整个中断机制。也可以通过禁用其 CPU 接口来禁用对单个内核的中断传递。也可以在分配器中禁用（或启用）各个中断。</p><p>对于一个中断到达核心，单个中断、分配器和 CPU 接口必须全部启用。中断也需要有足够的优先级，即高于内核的优先掩码。</p><p><strong>中断处理</strong></p><p>当 core 接受了中断，就跳转到顶层中断向量表并且开始执行。顶层的<strong>中断处理程序从 CPU interface 读取寄存</strong><br><strong>器以获得中断 ID</strong>。</p><p>读取寄存器除了返回中断 ID 外，还会导致中断在 distributor 中被标记为活 active。一旦知道中断 ID（识别中<br>断源），顶层处理程序就可以调度特定于设备的中断处理程序来服务中断。</p><p>当中断处理程序完成执行时，顶层处理程序将相同的中断 ID 写入 CPU 接口块中的中断结束 (EoI) 寄存器，指<br>示中断处理结束。</p><p>除了移除活动状态，使最终的中断状态为 Inactive 或 pending（如果状态为 active and pending），这使 CPU 接口能够将更多挂起的中断转发到 core。这结束了单个中断的处理。</p><p>在同一个内核上可能有多个中断等待服务，但是 CPU 接口一次只能发出一个中断信号。顶层中断处理程序<br>可以重复上述顺序，直到读取到<strong>特殊中断 ID 值 1023</strong>，<strong>表示有在这个核心上没有更多的中断挂起</strong>。这个特殊<br>的中断 ID 被称为<strong>虚假的中断标识</strong>。虚假中断 ID 是一个保留值，不能分配给系统。<strong>当顶层处理程序读取了虚</strong><br><strong>假中断 ID 后，它可以完成它的执行，并准备内核在中断之前恢复它正在执行的任务。</strong></p><p>通用中断控制器 (GIC)通常管理来自多个中断源的输入。并将它们分发给 IRQ 或 FIQ 。</p><h3 id="中断状态时序图"><a href="#中断状态时序图" class="headerlink" title="中断状态时序图"></a>中断状态时序图</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829105233126.png" alt="中断状态时序图"></p><blockquote><p> M和N分别代表两个中断,Input表示中断信号,State表示中断状态机，nFIQCPU[n]表示连接到CPU核心的FIQ信号</p><p> 假设M和N都是SPI中断，且N的优先级高于M</p></blockquote><h3 id="GICv2寄存器"><a href="#GICv2寄存器" class="headerlink" title="GICv2寄存器"></a>GICv2寄存器</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830162301992.png" alt="GIC寄存器后缀"></p><blockquote><p>有些寄存器是按中断号来描述的，比如使用某几个比特位来描述一个中断号的相关属性，同一个寄存器可以n个，例如GICD_ISENABLERn寄存器，它是用来使能某个中断号的。“n”表示它有n个这样的寄存器</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829114953289.png" alt="GICD_ISENABLERn"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829115143868.png" alt="GICD_ISENABLERn的Set-enable bits"></p><p>计算方法：根据中断号计算对应寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829115241074.png" alt="计算方法"></p><p>对于有些寄存器，会提示：</p><p><code>A register bit corresponding to an unimplemented interrupt is RAZ/WI.</code></p><p><strong>RAZ</strong> = <em>Read-As-Zero</em><br> 如果你读这个寄存器位，返回值永远是 <strong>0</strong>，即使你写过别的值。</p><p><strong>WI</strong> = <em>Write-Ignored</em><br> 如果你往这个位写入数据，<strong>硬件会忽略</strong>，不会改变，也不会报错。</p><h4 id="GICD-CTLR"><a href="#GICD-CTLR" class="headerlink" title="GICD_CTLR"></a>GICD_CTLR</h4><blockquote><p><strong>Distributor Control Register</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830231416178.png" alt="image-20250830231416178"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830231432858.png" alt="GICD_CTLR bit"></p><h4 id="GICD-ITARGETSRn"><a href="#GICD-ITARGETSRn" class="headerlink" title="GICD_ITARGETSRn"></a><strong>GICD_ITARGETSRn</strong></h4><blockquote><p><strong>Interrupt Processor Targets Registers</strong>，见中断路由章节</p></blockquote><h4 id="GICD-TYPER-（Interrupt-Controller-Type-Register）"><a href="#GICD-TYPER-（Interrupt-Controller-Type-Register）" class="headerlink" title="GICD_TYPER （Interrupt Controller Type Register）"></a>GICD_TYPER （Interrupt Controller Type Register）</h4><blockquote><p><strong>描述这个 GIC 的能力和配置参数</strong>，比如有多少中断、多少个 CPU 接口、是否支持某些特性等等。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830173053302.png" alt="GICD_TYPER"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250830173102370.png" alt="GICD_TYPER bit"></p><h4 id="GICD-ICFGRn"><a href="#GICD-ICFGRn" class="headerlink" title="GICD_ICFGRn"></a>GICD_ICFGRn</h4><blockquote><p>Interrupt Configuration Registers</p></blockquote><p>GIC用来配置<strong>中断触发类型</strong>的寄存器</p><p>每个 <code>GICD_ICFGRn</code> 是 <strong>32 位寄存器</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831140137876.png" alt="GICD_ICFGRn"></p><p><strong>分布方式</strong></p><ul><li><p>每个中断需要 <strong>2 bit</strong> （<strong>Int_config</strong>）来描述，所以<strong>一个寄存器可以配置 16 个中断</strong>。</p></li><li><p>第 <code>n</code> 个寄存器（<code>ICFGRn</code>）对应的中断范围是：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中断 ID = <span class="built_in">n</span>*<span class="number">16</span>  ~ (<span class="built_in">n</span>*<span class="number">16</span> + <span class="number">15</span>)</span><br></pre></td></tr></table></figure></li></ul><p><strong>Int_config字段编码</strong></p><p>根据 ARM GICv2 TRM（Table 4-18）：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831140152098.png" alt="GICD_ICFG Int_config.field"></p><p>对于<strong>PPI</strong>（Private Peripheral Interrupt）和<strong>SPI</strong>（Private Peripheral Interrupt）来说</p><div class="table-container"><table><thead><tr><th>Bit[1]</th><th>Bit[0]</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>reversed</td><td><strong>Level-sensitive</strong></td></tr><tr><td>1</td><td>reserved</td><td><strong>Edge-triggered</strong></td></tr></tbody></table></div><h4 id="GICD-ISENABLERn"><a href="#GICD-ISENABLERn" class="headerlink" title="GICD_ISENABLERn"></a>GICD_ISENABLERn</h4><blockquote><p>Interrupt Set-Enable Registers</p></blockquote><p>负责<strong>打开中断转发</strong></p><ul><li><p><strong>GICD_ISENABLERn</strong>是<strong>32位寄存器</strong></p></li><li><p>每个 <code>GICD_ISENABLERn</code> 控制 <strong>32 个中断源</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831142342695.png" alt="GICD_ISENABLERn"></p></li><li><p><strong>写 1</strong> → 使能对应的中断（让 Distributor 可以把它转发给 CPU interface）</p></li><li><p><strong>写 0</strong> → 没有作用</p></li><li><p><strong>读</strong> → 可以看到某个中断当前是否被使能（1=已使能，0=未使能）</p></li></ul><p>根据中断号<strong>计算GICD_ISENABLERn的n</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831142421934.png" alt="GICD_ISENABLERn计算"></p><h4 id="GICD-ICENABLERn"><a href="#GICD-ICENABLERn" class="headerlink" title="GICD_ICENABLERn"></a>GICD_ICENABLERn</h4><blockquote><p>Interrupt Clear-Enable Registers</p></blockquote><ul><li>W1C (写 1 清除)，禁用某个中断（禁止分发到 CPU）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831215408848.png" alt="GICD_ICEABLERn"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831215417447.png" alt="GICD_ICEABLERn Clear-enable bit"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831215423861.png" alt="GICD_ICENABLERn计算"></p><h4 id="GICD-ISACTIVERn"><a href="#GICD-ISACTIVERn" class="headerlink" title="GICD_ISACTIVERn"></a>GICD_ISACTIVERn</h4><blockquote><p>Interrupt Set-Active Registers</p></blockquote><ul><li>W1S（写1设置），软件可以<strong>把一个中断状态人为标记为 active</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831215015317.png" alt="GICD_ISACTIVERn"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831215029622.png" alt="GICD_ISACTIVERn Set-active bits"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831215037371.png" alt="GICD_ISACTIVERn计算"></p><h4 id="GICD-ICACTIVERn"><a href="#GICD-ICACTIVERn" class="headerlink" title="GICD_ICACTIVERn"></a>GICD_ICACTIVERn</h4><blockquote><p>Interrupt Clear-Active Registers</p></blockquote><ul><li><p>W1C（写1清除），清除中断的 active 状态。</p></li><li><p>和 EOI（End of Interrupt）有点类似，但 <strong>EOI 是 CPU interface 寄存器</strong>，只能由当前 CPU 对自己接收的中断做“中断服务完成”的动作；</p></li><li><p><code>ICACTIVERn</code> 在 <strong>Distributor</strong>，软件可以<strong>全局地强制清除某个中断的 active 位</strong>。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831214854607.png" alt="GICD_ICACTIVERn"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831215056169.png" alt="GICD_ICACTIVERn Clear-active bits"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831215102023.png" alt="GICD_ICACTIVERn"></p><h4 id="GICD-IPRIORITYRn"><a href="#GICD-IPRIORITYRn" class="headerlink" title="GICD_IPRIORITYRn"></a>GICD_IPRIORITYRn</h4><blockquote><p>Interrupt Priority Registers</p></blockquote><p>用于<strong>设置每个中断的优先级</strong></p><ul><li><p>每个中断占 8 bit</p></li><li><p>一个 32 位寄存器管理 4 个中断</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831152550466.png" alt="GICD_IPRIORITYRn"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831152601654.png" alt="GICD_IPRIORITYRn bit assignments"></p><p>地址计算：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831152618888.png" alt="GICD_IPRIORITYRn地址计算"></p><h4 id="GICC-CTLR"><a href="#GICC-CTLR" class="headerlink" title="GICC_CTLR"></a>GICC_CTLR</h4><blockquote><p>CPU Interface Control Register</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831152322508.png" alt="GICC_CTLR"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831152337691.png" alt="GICC_CTLR bit assignment"></p><h4 id="GICC-PMR"><a href="#GICC-PMR" class="headerlink" title="GICC_PMR"></a>GICC_PMR</h4><blockquote><p>Iterrupt Priority Mask Register</p></blockquote><p> <strong>CPU 接口的优先级屏蔽寄存器</strong>，它决定了 <strong>CPU 能够接收哪些优先级的中断</strong>。</p><ul><li>只有 <strong>优先级数值 ≤ PMR 的中断</strong> 才能被 CPU 接收。</li><li>注意：GIC 的优先级是 <strong>数值越小，优先级越高</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831151830984.png" alt="GICC_PMR"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831151843672.png" alt="GICC_PMR bit assignment"></p><p><strong>使用举例</strong>：假设你的 GIC 实现有 8 bit 优先级：</p><ol><li>如果 <code>GICC_PMR = 0xff</code><ul><li>CPU 接收所有优先级的中断（最常见的初始化设置）。</li></ul></li><li>如果 <code>GICC_PMR = 0xa0</code><ul><li>只接收 <strong>优先级值 ≤ 0xa0</strong> 的中断，优先级更“低”的中断会被屏蔽。</li></ul></li><li>如果 <code>GICC_PMR = 0x0</code><ul><li>只接收最高优先级（0）的中断，其他都屏蔽</li></ul></li></ol><h4 id="GICC-IAR"><a href="#GICC-IAR" class="headerlink" title="GICC_IAR"></a>GICC_IAR</h4><blockquote><p>Interrupt Acknowledge Register</p></blockquote><p>当 CPU 收到 IRQ 信号时，软件需要从这个寄存器读取当前 <strong>pending 中断的 ID</strong>，并确认它是哪一个 IRQ。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831172449575.png" alt="GICC_IAR"></p><div class="table-container"><table><thead><tr><th>Bits</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>[9:0]</td><td><strong>INTID</strong></td><td>中断 ID（0~1019 表示有效中断号）</td></tr><tr><td>[12:10]</td><td><strong>CPUID</strong></td><td>标识触发该中断的 CPU（多核系统有用）</td></tr><tr><td>[31:13]</td><td>Reserved</td><td>保留，读出为 0</td></tr></tbody></table></div><h4 id="GICC-EOIR"><a href="#GICC-EOIR" class="headerlink" title="GICC_EOIR"></a>GICC_EOIR</h4><blockquote><p>End of Interrupt Register</p></blockquote><p>软件在完成中断处理后，必须写入这个寄存器，告诉 GIC：“这个 IRQ 已经处理完了，可以清除 active 状态，并允许后续相同中断再次触发”。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831172738732.png" alt="GICC_EOIR"></p><div class="table-container"><table><thead><tr><th>Bits</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>[9:0]</td><td>INTID</td><td>中断 ID（必须与 IAR 读出的中断号一致）</td></tr><tr><td>[12:10]</td><td>CPUID</td><td>发出该中断的 CPU ID（多核系统使用）</td></tr><tr><td>[31:13]</td><td>Reserved</td><td>保留，写 0</td></tr></tbody></table></div><h3 id="树莓派4B的GIC400"><a href="#树莓派4B的GIC400" class="headerlink" title="树莓派4B的GIC400"></a>树莓派4B的GIC400</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829115524256.png" alt="GIC-400"></p><ul><li>ARM Core的中断：<ul><li>Core n HP tiemr IRQ</li><li>Core n V timer IRQ</li><li>Legacy FIQn</li><li>Core n PS timer IRQ</li><li><strong>Core n PNS timer IRQ</strong> (PPI ID <strong>30</strong>)</li><li>Legacy IRQn</li></ul></li><li>ARM local的中断<ul><li>ARM Mailbox IRQs</li><li>Core 0 PMU IRQ</li><li>Core 1 PMU IRQ</li><li>Core 2 PMU IRQ</li><li>Core 3 PMU IRQ</li><li>AXIERR IRQ</li><li>Local timer IRQ</li></ul></li><li>16个ARMC外设中断</li><li>64个VC外设中断</li><li>51个PCI相关的外设中断</li></ul><h4 id="访问GIC-400寄存器"><a href="#访问GIC-400寄存器" class="headerlink" title="访问GIC-400寄存器"></a><strong>访问GIC-400寄存器</strong></h4><ul><li>树莓派4b上的GIC-400的基地址</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829121750493.png" alt="GIC-400地址"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829121853350.png" alt="GIC-400 register map"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829121911817.png" alt="GIC-400 memory map"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829121943003.png" alt="GIC-400 memory map"></p><p><strong>访问</strong>：树莓派GIC400的<strong>基地址 </strong>+ GIC-400 <strong>memory map偏移</strong> + <strong>寄存器偏移</strong></p><h4 id="GIC400的初始化流程"><a href="#GIC400的初始化流程" class="headerlink" title="GIC400的初始化流程"></a>GIC400的初始化流程</h4><ol><li>设置distributor和CPU interface寄存器组的基地址</li><li>读取<strong>GICD_TYPER</strong>寄存器，计算当前GIC最大支持多少个中断源</li><li>初始化distributor<ol><li><strong>Disable distributor</strong>，设置<strong>GICD_CTLR</strong>（这一步可以不做，因为复位时本来就是关闭的）</li><li><strong>设置SPI中断的路由</strong><ol><li>前32个中断怎么路由是GIC芯片固定的，因此先读<strong>GICD_ITARGETSRn</strong>前面的值，获取能路由的所有CPU</li><li>将 <strong>SPI（Shared Peripheral Interrupt）中断</strong> 的路由设置为将中断分发到所有能路由的 CPU，因为SPI中断是Shared的中断，设置SPI的<strong>GICD_ITARGETSRn</strong></li></ol></li><li><strong>设置SPI中断的触发类型，例如Level触发</strong>，设置<strong>GICD_ICFGRn</strong></li><li><strong>Disactive和disable所有的SPI中断源</strong></li><li><strong>打开SGI中断(0-15)，SMP会用到</strong></li><li><strong>Enable distributor</strong>,设置<strong>GICD_CTLR</strong></li></ol></li><li>初始化CPU interface<ol><li>为前32个中断源设置默认中断优先级，设置<strong>GICD_IPRIORITYRn</strong></li><li>设置<strong>GICC_PRM</strong>，设置中断优先级mask level</li><li>Enable CPU interface，设置<strong>GICC_PRM</strong></li></ol></li></ol><h5 id="注册中断"><a href="#注册中断" class="headerlink" title="注册中断"></a><strong>注册中断</strong></h5><ol><li>初始化外设</li><li>查找该外设的中断在GIC-400的中断号，例如PNS timer的中断号为30</li><li>设置<strong>GICD_ISENABLERn</strong>寄存器来enable这个中断号</li><li>打开设备相关的中断，例如树莓派上的generic timer，需要打开ARM_LOCAL寄存器中的TIMER_CNTRL0寄存器中相关的enable位</li><li>打开CPU的PSTATE中的I位</li></ol><h5 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a><strong>中断响应</strong></h5><ol><li>中断发生</li><li>异常向量表</li><li>跳转到GIC中断函数里，gic_handle_irq()</li><li>读取<strong>GICC_IAR</strong>寄存器，获取中断号</li><li>根据中断号来进行相应的中断处理，例如读取的中断号为30，说明的是PNS的generic timer，然后跳转到generic timer的处理函数里。</li></ol><h3 id="GIC中断实验1：实现generic-timer"><a href="#GIC中断实验1：实现generic-timer" class="headerlink" title="GIC中断实验1：实现generic timer"></a>GIC中断实验1：实现generic timer</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829133657152.png" alt="GIC中断实验1"></p><p><strong>GIC-400初始化</strong></p><ol><li>设置<strong>distributor</strong>和<strong>CPU interface</strong>寄存器组的基地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GIC_V2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GIC_V2_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GIC_V2_DISTRIBUTOR_OFFSET 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GIC_V2_CPU_INTERFACE_OFFSET 0x2000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GIC_V2_DISTRIBUTOR_BASE (GIC_400_BASE + GIC_V2_DISTRIBUTOR_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GIC_V2_CPU_INTERFACE_BASE (GIC_400_BASE + GIC_V2_CPU_INTERFACE_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_CTLR (GIC_V2_DISTRIBUTOR_BASE + 0x000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_TYPER (GIC_V2_DISTRIBUTOR_BASE + 0x004)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_TYPER_ITLINESNUMBER 0x1f</span></span><br><span class="line"><span class="comment">// 直接用 n / 4 或 n / 16 会得到 寄存器索引</span></span><br><span class="line"><span class="comment">// 然后在地址计算上乘以 4（每个寄存器 4 字节）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_ITARGETSRn(n) (GIC_V2_DISTRIBUTOR_BASE + 0x800 + (n / 4) * 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_ICFGRn(n) (GIC_V2_DISTRIBUTOR_BASE + 0xc00 + (n / 16) * 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_ICFG_LEVEL_SENSITIVE 0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_ICFG_LEVEL_EDGE_TRIGGERED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_ISENABLERn(n) (GIC_V2_DISTRIBUTOR_BASE + 0x100 + (n / 32) * 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_ICENABLERn(n) (GIC_V2_DISTRIBUTOR_BASE + 0x180 + (n / 32) * 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_ICACTIVERn(n) (GIC_V2_DISTRIBUTOR_BASE + 0x380 + (n / 32) * 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICD_IPRIORITYRn(n) (GIC_V2_DISTRIBUTOR_BASE + 0x400 + (n / 4) * 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAFAULT_IPRIORITY 0xa0a0a0a0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICC_PMR (GIC_V2_CPU_INTERFACE_BASE + 0x4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICC_CTLR (GIC_V2_CPU_INTERFACE_BASE + 0x0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICC_IAR (GIC_V2_CPU_INTERFACE_BASE + 0xc)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICC_IAR_CPU_ID_MASK 0x1c00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICC_IAR_INT_ID_MASK 0x3ff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GICC_EOIR (GIC_V2_CPU_INTERFACE_BASE + 0x10)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gic_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gic_enable_irq</span><span class="params">(<span class="type">int</span> irq)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>读取<strong>GICD_TYPER</strong>寄存器，计算当前GIC最大支持多少个中断源</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831220730571.png" alt="读取GICD_TYPER寄存器"></p><ol><li><p>初始化<strong>distributor</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831221034830.png" alt="初始化distributor"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831220807403.png" alt="gic_distributor_init"></p></li><li><p>初始化CPU interface</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831220821697.png" alt="gic_cpu_init"></p></li><li><p>打开PNS_TIMER_IRQ的路由</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831220947964.png" alt="打开PNS_TIMER_IRQ路由"></p><ol><li>测试</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831221126852.png" alt="gic_irq_handle"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250831221107431.png" alt="测试"></p><h3 id="GIC中断实验2：实现树莓派上的System-Timer"><a href="#GIC中断实验2：实现树莓派上的System-Timer" class="headerlink" title="GIC中断实验2：实现树莓派上的System Timer"></a>GIC中断实验2：实现树莓派上的System Timer</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250829142717776.png" alt="实验2"></p><h2 id="GICv3中断控制器"><a href="#GICv3中断控制器" class="headerlink" title="GICv3中断控制器"></a>GICv3中断控制器</h2><h3 id="GICv3比GICv2改进了哪些内容"><a href="#GICv3比GICv2改进了哪些内容" class="headerlink" title="GICv3比GICv2改进了哪些内容"></a>GICv3比GICv2改进了哪些内容</h3><ul><li>GICv3兼容GICv2</li><li>支持更多CPU数量，&gt;8</li><li>支持message-base中断（<strong>Message Signaled Interrupt</strong>，<strong>MSI</strong>）</li><li>支持<strong>ITS</strong>（<strong>Interrupt Translation Service</strong>）服务</li><li>支持更多的硬件中断号，&gt;1020</li><li>为了更好兼容ARMv8异常模型，支持<strong>中断组</strong>（Interrupt grouping）</li><li>为了优化访问延时，<strong>提供系统寄存器的方式来访问CPU Interface</strong></li></ul><h3 id="GICv3支持的中断类型"><a href="#GICv3支持的中断类型" class="headerlink" title="GICv3支持的中断类型"></a>GICv3支持的中断类型</h3><ul><li><strong>Private Peripheral Interrupt（PPI）</strong><ul><li>PPI是指本地CPU特有的中断，比如CPU内部的定时器等。不同的CPU可以使用相同的PPI中断号</li><li>PPI可以在group0和group1</li><li>可以边沿触发（edge-triggered）或者水平触发（level-sensitve）</li></ul></li><li><strong>Shared Peripheral Interrupt（SPI）</strong><ul><li>SPI通常用于外设中断，它可以路由到任意一个CPU</li><li>SPI可以在group0和group1</li><li>可以边沿触发或者水平触发</li></ul></li><li><strong>Software Generated Interrupt（SGI）</strong><ul><li>SGI通常软件触发的中断，用于核间通信，例如IPI（Inter-Processor Interrupts）</li><li>SGI只能边沿触发</li></ul></li><li>新增：<strong>Locality-specific Peripheral Interrupt（LPI）</strong><ul><li>在非安全中断组1</li><li>边沿触发</li><li>使用ITS服务</li><li>没有active状态</li><li>message-based中断</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010135558355.png" alt="LPI"></p><h3 id="有线中断与基于消息的中断"><a href="#有线中断与基于消息的中断" class="headerlink" title="有线中断与基于消息的中断"></a>有线中断与基于消息的中断</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009141946437.png" alt="有线中断"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009141956246.png" alt="基于消息的中断"></p><ul><li>SPI和LPI都支持message-base中断<ul><li>SPI的message-base中断不需要经过ITS，往<strong>GICD_SETSPI_NSR</strong>寄存器写入中断号触发中断</li><li>LPI的message-base需要ITS</li></ul></li></ul><h3 id="中断号分配"><a href="#中断号分配" class="headerlink" title="中断号分配"></a>中断号分配</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009142233146.png" alt="中断号分配"></p><h3 id="中断状态机"><a href="#中断状态机" class="headerlink" title="中断状态机"></a>中断状态机</h3><ul><li><strong>Inactive</strong> 不活跃状态</li><li><strong>Pending</strong> 中断触发了，但是还没有被CPU响应（acknowledge）</li><li><strong>Active</strong>  中断被CPU响应和处理</li><li><strong>Active &amp; Pending</strong> 当前有一个中断正在被CPU响应和处理，这时有一个相同的中断触发了，这个新的中断被设置为active &amp; pending</li><li><strong>LPI</strong>没有active和active &amp; pending状态</li></ul><blockquote><p>问题：如果GIC在响应中断的过程中，又有一个相同的中断触发了，那怎么办？</p><p>这里要分两种情况：</p><ul><li>如果GIC正在响应第一个中断时，即第一个中断的状态为active，此时第二个相同的中断触发，那么蝶儿个中断的状态会变成 active &amp; pending，这样避免丢失了中断</li><li>如果第一个中断还处于pending状态，此时又来了一个相同的中断，那么它们会merge成一个</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009142918490.png" alt="中断状态机"></p><h3 id="中断亲和性路由层级（Affinity-routing）"><a href="#中断亲和性路由层级（Affinity-routing）" class="headerlink" title="中断亲和性路由层级（Affinity routing）"></a>中断亲和性路由层级（Affinity routing）</h3><ul><li>GICv3支持4级路由</li><li>Level 0面对的是redistributor</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009143149657.png" alt="Distributor分发"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009143201412.png" alt="core的唯一标识"></p><h3 id="GIC-500的中断亲和性路由"><a href="#GIC-500的中断亲和性路由" class="headerlink" title="GIC-500的中断亲和性路由"></a>GIC-500的中断亲和性路由</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009143324963.png" alt="GIC-500的中断亲和性路由"></p><ul><li>GIC-500支持两级的亲和性路由<ul><li>Level 0 是 core</li><li>Level 1 是 cluster</li></ul></li><li>GIC-500最大支持128个cores以及32个cluster</li></ul><p>0.0.0.1表示第0个cluster中的第1个core</p><p>0.0.1.1表示第1个cluster中的第1个core</p><ul><li>中断组与安全模式<ul><li>ARMv8支持安全模式和非安全模式</li><li>GICv3支持EL0~EL3，所以每个中断源都需要设置对应的中断组和安全模式<ul><li>Group0用于EL3</li><li>安全模式的Group1：用于Trust OS on EL2</li><li>非安全模式的Group1：用于VMM或者OS</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009143825096.png" alt="中断组与安全模式"></p><p><strong>Group0使用FIQ，Group1根据情况使用IRQ or FIQ</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009143905363.png" alt="Group0,Group1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009143925894.png" alt="Exception Level"></p><p><strong>例子</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009144136472.png" alt="Non-secure/secure Group"></p><blockquote><p>注意：中断是否会路由到EL3要看SCR_EL3寄存器FIQ和IRQ字段</p></blockquote><ul><li>在非安全模式下：<ul><li>非安全group1的中断直接在RichOS响应</li><li>安全group1和Group0的FIQ中断路由到EL3</li></ul></li><li>在安全模式下<ul><li>安全group1的IRQ中断直接在Trusted OS响应</li><li>非安全group1和group0的FIQ中断路由到EL3</li></ul></li></ul><h3 id="特殊中断号"><a href="#特殊中断号" class="headerlink" title="特殊中断号"></a>特殊中断号</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009144717625.png" alt="特殊中断号"></p><h4 id="1021号中断的使用1"><a href="#1021号中断的使用1" class="headerlink" title="1021号中断的使用1"></a>1021号中断的使用1</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009144819643.png" alt="例子: 陷入到EL3"></p><ol><li>CPU运行在安全模式下的trusted os，此时来了一个非安全模式下的OS的中断，那么需要陷入到EL3的FIQ来处理</li><li>CPU陷入到EL3的安全监视器，安全监视器会读取IAR寄存器，并且读到1021，说明这个中断是希望在非安全模式下处理的。切换到非安全模式的Rich OS</li><li>CPU切换到非安全模式的Rich OS来处理这个中断</li></ol><h4 id="1021号中断的使用2"><a href="#1021号中断的使用2" class="headerlink" title="1021号中断的使用2"></a>1021号中断的使用2</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251009145147749.png" alt="例子: 陷入到EL2的情况"></p><ol><li>CPU运行在安全模式下的trusted os，此时来了一个非安全模式下OS的中断。那么需要陷入到EL3的FIQ来处理。但是由于SCR_EL3.FIQ=0，它只能在EL2中处理。</li><li>EL2的Trusted OS执行SMC系统调用陷入到EL3</li><li>安全监视器会读取IAR寄存器，并且读到1021，说明这个中断是希望在非安全模式下处理的。切换到非安全模式的Rich OS</li><li>CPU切换到非安全模式的Rich OS来处理这个中断</li></ol><h3 id="中断优先级-1"><a href="#中断优先级-1" class="headerlink" title="中断优先级"></a>中断优先级</h3><ul><li>GICv3支持8位优先级，最多256级别<ul><li>支持2个安全模式时，最少支持32个中断优先级，最多支持256个</li><li>支持1个安全模式时，最少支持16个中断优先级</li></ul></li><li>中断优先级<ul><li>数值越小，中断优先级越高，0表示最高优先级，255表示最低优先级，idle priority</li><li>GICR_IPRIORITYR\<n\> 设置PPI和SGI中断优先级</li><li>GICD_IPRIORITYR\<n\> 设置SPI中断优先级</li><li>LPI配置表保存了LPI的中断优先级</li></ul></li></ul><h4 id="中断优先级分组寄存器（ICC-BPR0-EL1-ICC-BPR1-EL1）"><a href="#中断优先级分组寄存器（ICC-BPR0-EL1-ICC-BPR1-EL1）" class="headerlink" title="中断优先级分组寄存器（ICC_BPR0_EL1/ICC_BPR1_EL1）"></a>中断优先级分组寄存器（ICC_BPR0_EL1/ICC_BPR1_EL1）</h4><ul><li>Binary Point Register寄存器把中断优先级分成两个字段<ul><li>group priority 需要抢占时，优先比较group priority</li><li>subpriority   当需要抢占时，只有当group priority相同时，才比较subpriority</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010105121747.png" alt="中断优先级分组寄存器"></p><p>Group0的中断优先级分组情况，见ICC_BPR0_EL1寄存器</p><p>注意：group1和group0的分组情况略有不同</p><h4 id="中断优先级阈值与运行中断优先级"><a href="#中断优先级阈值与运行中断优先级" class="headerlink" title="中断优先级阈值与运行中断优先级"></a>中断优先级阈值与运行中断优先级</h4><ul><li>中断阈值<ul><li>寄存器：ICC_PMR_EL1</li><li>PMR决定目标CPU的优先级阈值。GIC只有当pending中断的优先级高于这个中断优先级阈值，才会发送中断到CPU</li><li>PMR为0，表示屏蔽了所有中断发送给CPU</li></ul></li><li>Running priority<ul><li>寄存器：ICC_PMR_EL1</li><li>返回正在响应中的group priority</li></ul></li></ul><h4 id="中断优先级的抢占"><a href="#中断优先级的抢占" class="headerlink" title="中断优先级的抢占"></a>中断优先级的抢占</h4><ul><li>GICv3支持中断抢占，当一个中断优先级同时满足下面条件<ul><li>优先级高于CPU接口的优先级阈值PMR</li><li>Group priority高于正在处理的running prirority</li></ul></li></ul><h3 id="GICv3内部架构"><a href="#GICv3内部架构" class="headerlink" title="GICv3内部架构"></a>GICv3内部架构</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010105724987.png" alt="GICv3内部架构"></p><ul><li>Distributor：优先级排队，派发SPI和SGI到redistributor</li><li>Redistributor：连接CPU interface。每个CPU一个redistributor</li><li>CPU interface：发送中断给CPU，响应中断等</li><li>ITS: 中断转换服务，把LPIs中断请求转换到中断号以及发送到redistributor</li></ul><h3 id="ITS服务（Interrupt-translation-service）"><a href="#ITS服务（Interrupt-translation-service）" class="headerlink" title="ITS服务（Interrupt translation service）"></a>ITS服务（Interrupt translation service）</h3><ul><li>ITS作用：把设备（device_id）的Event_ID转成：<ul><li>硬件中断号（INTID）</li><li>目标redistributor</li></ul></li><li>ITS转换过程<ul><li>使用Device_ID来查询device table</li><li>使用Event_ID来查询Interrupt translation table<ul><li>物理中断号INTID</li><li>interrupt collection number</li></ul></li><li>由ICID来查询Collection table得到目标redistributor</li></ul></li><li>ITS五张表<ul><li>中断配置表configure table</li><li>中断pending表</li><li>device table</li><li>Interrupt translation table</li><li>Collection table</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010110352750.png" alt="Interrupt translation service"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010140039638.png" alt="Interrupt translation"></p><h4 id="配置表和pending表"><a href="#配置表和pending表" class="headerlink" title="配置表和pending表"></a>配置表和pending表</h4><ul><li><p><strong>中断配置表</strong>用来存储每个LPI中断的优先级和enable位</p><ul><li>每个表项占8bit</li><li>配置表基地址：GICR_PROPBASER.Physical_Address</li><li>表项个数：2^(GICR_PROPBASER.IDbits)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010111038377.png" alt="中断配置表"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010110915247.png" alt="中断配置表表表项"></p><ul><li><strong>中断pending</strong> 用来表示每个LPI中断的pending状态<ul><li>每个表项占1个bit</li><li>每个redistributor有一个中断pending表</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010111028122.png" alt="Pending表"></p><h4 id="Device-Table的创建"><a href="#Device-Table的创建" class="headerlink" title="Device Table的创建"></a>Device Table的创建</h4><ul><li>Device Table由OS软件创建<ul><li>分配内存，创建Table</li><li>把表的基地址设置到GITS_BASER.Physical_Address</li></ul></li><li><p>Device Table的重要参数在GITS_BASER\<n\>寄存器中</p><ul><li>表的类型：GITS_BASER.Type</li><li>表项的大小：GITS_BASER.Entry_Size（8个字节）</li><li>Table中每个page的大小：GITS_BASER.Page_Size（eg, 64KB）</li><li>是否需要二级页表：GITS_BASER_Indirect</li><li>设置表基地址：GITS_BASER.Physical_Address</li><li>需要多少个表项：2^(device_id位宽)，device_id位宽在GITS_TYPER.devbits</li></ul></li><li><p>Device Table支持1级或者2级表</p></li><li>Ddevice Table表项的内容由：<ul><li>软件通过command queue来发送命令给硬件，硬件来填充表项</li><li>通过MAPD命令，把deviceID映射到ITT表中</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010112026541.png" alt="Device table一级表"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010112040856.png" alt="Device Table二级表"></p><ul><li>Device Table的表项叫做DTE，用来指向ITT表的</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010135707597.png" alt="DDT表项DTE"></p><ul><li>ITT的表项叫做ITE，用来描述EventID和最终物理ID号的关系</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010135818459.png" alt="ITT表项ITE"></p><h4 id="Interrupt-translation-table的创建"><a href="#Interrupt-translation-table的创建" class="headerlink" title="Interrupt translation table的创建"></a>Interrupt translation table的创建</h4><ul><li>ITT表项用来映射 <strong>EventID -&gt; 物理中断号INTID以及ICID</strong></li><li>ITT重要参数<ul><li>ITT表项大小：GITS_TYPER.ITT_entry_size（eg：16字节）</li><li>ITT表项个数：申请中断时请求的vector个数</li><li>ITT表的基地址：由OS来分配</li></ul></li><li>ITT表项的内容由：<ul><li>软件通过command queue来发送命令给硬件，硬件来完成</li><li>通过MAPD命令，把deviceID映射到ITT表中</li></ul></li></ul><h4 id="Collection-Table的创建"><a href="#Collection-Table的创建" class="headerlink" title="Collection Table的创建"></a>Collection Table的创建</h4><ul><li>Collection Table表项用来映射：<strong>ICID -&gt; redistributor</strong></li><li><strong>这个表不需要在内存中分配内存</strong></li></ul><ul><li><p>Collection Table表项的内容由：</p><ul><li>软件通过command queue来发送命令给硬件，硬件来完成</li><li>软件告知：redistributor的物理地址或者GICR_TYPER.Processor_Number</li><li>通过MAPC命令来映射ICID -&gt; redistributor</li><li>在GIC初始化的时候就遍历所有的redistributor，并且调用MAPC命令初始化</li></ul><p>gic_smp_init()-&gt;</p><p>​    遍历所有present CPU()-&gt;</p><p>​        gic_starting_cpu()-&gt;</p><p>​            its_cpu_init()-&gt;</p><p>​                its_cpu_init_collections()-&gt;</p><p>​                    its_cpu_init_collection()-&gt;</p><p>​                        its_send_mapc()发送MAPC命令初始化collection table</p></li><li><p>Collection table的表项CTE</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010135921573.png" alt="collection table表项CTE"></p><h4 id="ITS-Command-Queue"><a href="#ITS-Command-Queue" class="headerlink" title="ITS Command Queue"></a>ITS Command Queue</h4><ul><li>三个与command queue相关的寄存器<ul><li>GITS_CBASER：指定command queue的大小和基地，基地址必须64KB对齐，大小必须4KB整数倍</li><li>GITS_CREADR：ITS下一条要处理的command</li><li>GITS_CWRITER：下一条要写入的command</li></ul></li><li>常用的Command<ul><li>MAPD：映射device ID到ITT table中<ul><li>MAPD \<DeviceID\>, \<ITT_addr\>, \<size\></li></ul></li><li>MAPI：映射eventid和deviceid以及硬件中断号到ITT中<ul><li>MAPI \<DeviceID\>, \<EventID\>,  \<Collection ID\></li></ul></li><li>MAPTI：映射eventid,deviceid以及硬件中断号到ITT中<ul><li>MAPTI \<DeviceID\>, \<EventID\>, \<INTID\>, \<Collection ID\></li></ul></li><li>MAPC：映射collection id到目标redistributor<ul><li>MAPC \<Collection ID\>, \<Target Redistributor\></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010113824599.png" alt="ITS Command Queue"></p><p><strong>例子</strong></p><p>假设某个设备的Device ID为5，想把Event ID=0映射到物理中断号8192中，ITT表的基地址为0x850000。对应的Collection ID为3，对应的目标redistributor的物理地址为0x78400000</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010114149986.png" alt="例子"></p><p><strong>linux内核中喜欢用vector表示eventid</strong></p><h4 id="ITS在Linux中的实现"><a href="#ITS在Linux中的实现" class="headerlink" title="ITS在Linux中的实现"></a>ITS在Linux中的实现</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010115024410.png" alt="qemu virtio device its"></p><h5 id="irq-domain中断控制域"><a href="#irq-domain中断控制域" class="headerlink" title="irq domain中断控制域"></a>irq domain中断控制域</h5><ul><li>系统存在多级中断控制器的可能性<ul><li>传统中断控制器-GIC</li><li>可以抽象成中断控制器：GIC ITS，GPIO等</li><li>虚拟中断控制器，platform irqdomain</li></ul></li><li>IRQ Domain看作是IRQ Controller的软件抽象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010115236509.png" alt="irq domain"></p><h5 id="ITS驱动框架"><a href="#ITS驱动框架" class="headerlink" title="ITS驱动框架"></a>ITS驱动框架</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010115535390.png" alt="ITS驱动代码"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010115545982.png" alt="ITS驱动框架"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010115730896.png" alt="OPS"></p><h5 id="创建MSI中断的API"><a href="#创建MSI中断的API" class="headerlink" title="创建MSI中断的API"></a>创建MSI中断的API</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010115937979.png" alt="MSI中断 platform device"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010115959287.png" alt="MSI中断 PCI device"></p><h5 id="Platform-device中使用MSI中断的例子-SMMUv3"><a href="#Platform-device中使用MSI中断的例子-SMMUv3" class="headerlink" title="Platform device中使用MSI中断的例子-SMMUv3"></a>Platform device中使用MSI中断的例子-SMMUv3</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010120438448.png" alt="SMMUv3"></p><h5 id="platform请求分配MSI中断流程图"><a href="#platform请求分配MSI中断流程图" class="headerlink" title="platform请求分配MSI中断流程图"></a>platform请求分配MSI中断流程图</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010121655276.png" alt="platform请求分配MSI中断流程图"></p><h5 id="PCI设备分配MSI中断流程图"><a href="#PCI设备分配MSI中断流程图" class="headerlink" title="PCI设备分配MSI中断流程图"></a>PCI设备分配MSI中断流程图</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010122629205.png" alt="PCI设备分配MSI中断"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010122648639.png" alt="pci_alloc_irq_vectors_affinity"></p><h5 id="IO设备如何触发中断？"><a href="#IO设备如何触发中断？" class="headerlink" title="IO设备如何触发中断？"></a>IO设备如何触发中断？</h5><p>对于GICv3中断控制来说，IO设备需要往GITS_TRANSLATER寄存器写入event ID，即可触发MSI中断</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010134842066.png" alt="GITS_TRANSLATER"></p><p>Linux内核封装了一个struct msi_msg数据结构，包括了这个寄存器的地址，以及将要写入的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msi_msg</span>&#123;</span></span><br><span class="line">u32 address_lo;</span><br><span class="line">u32 address_hi;</span><br><span class="line">u32 data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在irq_chip的ops有一个its_irq_compose_msi_msg回调函数，用来填充这个msi_msg，就是把GITS_TRANSLATER寄存器的物理地址写入到msi_msg-&gt;address字段里</p><p>设备驱动程序在使用platform_msi_domain_alloc_irqs()注册MSI的时候，就会从msi_msg数据结构中获取到GITS_TRANSLATER寄存器的物理地址和eventID，然后写入到IO设备自己的寄存器（例如SMMU中的SMMU_EVENTQ_IRQ_CFGO和CFG1）里。</p><p>设备要触发MSI，就会自动往自己寄存器里写入eventid，来触发中断。</p><p>以SMMU为例：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010140250054.png" alt="SMMU"></p><h5 id="ITS-Debug-Tips"><a href="#ITS-Debug-Tips" class="headerlink" title="ITS Debug Tips"></a>ITS Debug Tips</h5><ul><li>最新的qemu支持ITS。可以通过QEMU+linux kernel来单步调试ITS和MSI</li><li>在kernel command line中添加”irq_gic_v3_its.dyndbg=+pflmt irqdomain.dyndbg=+pflmt”来打开相关的动态打印：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010135349580.png" alt="kenel启动日志"></p><ul><li>可以在its_domain_ops回调中添加”dump_stack()”来打印调用函数关系calltrace</li></ul>]]></content>
      
      
      <categories>
          
          <category> arm64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3347 执行操作后元素的最高频率 II</title>
      <link href="/posts/3347/"/>
      <url>/posts/3347/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-22</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3347 执行操作后元素的最高频率 I" href="https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/?envType=daily-question&envId=2025-10-22"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3347 执行操作后元素的最高频率 I</p><p class="url">https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-ii/description/?envType=daily-question&envId=2025-10-22</p></div></a></div></p><p>对于一个值 nums[i]，我们要找 nums[i]中值处于[nums[i]-k,nums[i]+k]之间的值，这样的值通过一次 operation 就能变成目标众数。但是仅仅考虑 nums[i]是不正确的，因为 nums[i]也可以通过一次 operation 变成[nums[i]-k,nums[i]+k]之间的任何一个值作为目标众数。<br>那么我们还要将 num[i]待选目标众数通过一次 operation 得到的所有值都作为目标众数枚举一遍吗？答案是否定的。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>排序数组 <code>nums</code></li><li>每个元素的可操作区间：<code>[nums[i]-k, nums[i]+k]</code></li><li>枚举目标众数 val → 计算能变成 val 的元素数量</li></ul><p>定义窗口 <code>[val-k, val+k]</code>：</p><ul><li>左边界 l：窗口包含的最左元素</li><li>右边界 r：窗口包含的最右元素</li><li><code>range_size = r - l + 1</code></li></ul><p>最大频率：</p><script type="math/tex; mode=display">f_i = \min(\text{range\_size}, \text{numOperations} + \text{count}[val])</script><h2 id="关键观察"><a href="#关键观察" class="headerlink" title="关键观察"></a>关键观察</h2><blockquote><p>只有当窗口的左右边界 l 或 r 发生变化时，<code>range_size</code> 才会变化 → f_i 才可能变大</p></blockquote><ul><li>假设 val ∈ <code>[nums[r]-k, nums[r+1]-k)</code>：<ul><li>r 不变</li><li>l 不变</li><li>range_size 恒定 → f_i 不变</li></ul></li><li>区间内部的所有 val <strong>不会增加最大频率</strong> → 无需枚举</li></ul><h2 id="临界点分析"><a href="#临界点分析" class="headerlink" title="临界点分析"></a>临界点分析</h2><p>窗口边界变化的临界点：</p><ol><li>左边界 l 变化：val - k = nums[i]（左边元素刚好进入/离开窗口）</li><li>右边界 r 变化：val + k = nums[i]（右边元素刚好进入/离开窗口）</li></ol><p>也就是说，<strong>只有当 val 等于某个 nums[i] ± k 或 nums[i] 本身</strong>，窗口边界会发生变化。</p><ul><li>val = nums[i] → 对应窗口覆盖 nums[i] 本身</li><li>val = nums[i] - k → 窗口左边界刚好覆盖 nums[i]</li><li>val = nums[i] + k → 窗口右边界刚好覆盖 nums[i]</li></ul><blockquote><p>这三个值就是 <strong>所有可能改变窗口范围的临界点</strong></p></blockquote><p>综上：我们只需要枚举边界值即可，即枚举{nums[i]-k , nums[i], num[i] +k}。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxFrequency</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k, <span class="type">int</span> numOperations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> range_size;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">umap[nums[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 0 &lt;= numOperations &lt;= nums.length</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : &#123; nums[i] - k, nums[i], nums[i] + k &#125;) &#123;</span><br><span class="line"><span class="comment">// 要枚举的值不在范围内</span></span><br><span class="line"><span class="keyword">if</span> (val &lt; nums.<span class="built_in">front</span>() || val &gt; nums.<span class="built_in">back</span>()) &#123;</span><br><span class="line"><span class="comment">// 如果val比nums最小值还小，没有意义，因为任何一个值能通过操作变成这个val，那么肯定也可以变成nums的最小值，那么为什么不用最小值作为目标众数呢？</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range &#123;x in nums[i] &amp;&amp; x in &#123;val-k..val+k&#125;&#125;</span></span><br><span class="line">range_size =</span><br><span class="line">std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),</span><br><span class="line"> nums.<span class="built_in">end</span>(), val + k) -</span><br><span class="line">std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),</span><br><span class="line"> nums.<span class="built_in">end</span>(), val - k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终能把某个值变成出现次数最多的频率 = 原来这个值的出现次数 +</span></span><br><span class="line"><span class="comment">// 通过操作可以变成这个值的次数,但不能超过窗口内可转换到的数量</span></span><br><span class="line">res = std::<span class="built_in">max</span>(</span><br><span class="line">res, std::<span class="built_in">min</span>(numOperations + umap[val],</span><br><span class="line">      range_size));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">999999997</span>, <span class="number">999999999</span>, <span class="number">999999999</span> &#125;;</span><br><span class="line">Solution S;</span><br><span class="line"><span class="type">int</span> k = <span class="number">999999999</span>;</span><br><span class="line"><span class="type">int</span> numOperations = <span class="number">2</span>;</span><br><span class="line">S.<span class="built_in">maxFrequency</span>(nums, k, numOperations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3346 执行操作后元素的最高频率 I</title>
      <link href="/posts/3346/"/>
      <url>/posts/3346/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-21</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3346 执行操作后元素的最高频率 I" href="https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-i/description/?envType=daily-question&envId=2025-10-21"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3346 执行操作后元素的最高频率 I</p><p class="url">https://leetcode.cn/problems/maximum-frequency-of-an-element-after-performing-operations-i/description/?envType=daily-question&envId=2025-10-21</p></div></a></div></p><h1 id="WA"><a href="#WA" class="headerlink" title="WA"></a>WA</h1><p>先看 WA 的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxFrequency</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k, <span class="type">int</span> numOperations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> left_bound, right_bound;</span><br><span class="line"><span class="type">int</span> max_val;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">umap[nums[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">nums.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line">n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">max_val = <span class="number">0</span>;</span><br><span class="line">left_bound = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left_bound &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">       nums[left_bound] &gt;= nums[i] - k) &#123;</span><br><span class="line">max_val += umap[left_bound];</span><br><span class="line">left_bound--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">right_bound = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (right_bound &lt; n &amp;&amp;</span><br><span class="line">       nums[right_bound] &lt;= nums[i] + k) &#123;</span><br><span class="line">max_val += umap[right_bound];</span><br><span class="line">right_bound++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max_val &lt;= numOperations) &#123;</span><br><span class="line">res = std::<span class="built_in">max</span>(res, max_val + umap[nums[i]]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = std::<span class="built_in">max</span>(res,</span><br><span class="line">       numOperations + umap[nums[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于输入</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nums</span> = [<span class="number">5</span>,<span class="number">64</span>]</span><br><span class="line"><span class="attr">k</span> = <span class="number">42</span></span><br><span class="line"><span class="attr">numOperations</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>上面的代码是 WA 的，因为上面的代码只把最终频率最大的众数，我们称为目标众数的枚举范围只限定在 nums 中的值了。实际上，对于每个数都可以进行一次 operation，两个数如果都进行一次 operation 后相等也是符合要求的。</p><h1 id="AC"><a href="#AC" class="headerlink" title="AC"></a>AC</h1><p>上面 WA 的原因主要是我们没有枚举完整，对于一个值 nums[i]，我们要找 nums[i]中值处于[nums[i]-k,nums[i]+k]之间的值，这样的值通过一次 operation 就能变成目标众数。但是仅仅考虑 nums[i]是不正确的，因为 nums[i]也可以通过一次 operation 变成[nums[i]-k,nums[i]+k]之间的任何一个值作为目标众数。<br>那么我们还要将 num[i]待选目标众数通过一次 operation 得到的所有值都作为目标众数枚举一遍吗？答案是否定的。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>排序数组 <code>nums</code></li><li>每个元素的可操作区间：<code>[nums[i]-k, nums[i]+k]</code></li><li>枚举目标众数 val → 计算能变成 val 的元素数量</li></ul><p>定义窗口 <code>[val-k, val+k]</code>：</p><ul><li>左边界 l：窗口包含的最左元素</li><li>右边界 r：窗口包含的最右元素</li><li><code>range_size = r - l + 1</code></li></ul><p>最大频率：</p><script type="math/tex; mode=display">f_i = \min(\text{range\_size}, \text{numOperations} + \text{count}[val])</script><h2 id="关键观察"><a href="#关键观察" class="headerlink" title="关键观察"></a>关键观察</h2><blockquote><p>只有当窗口的左右边界 l 或 r 发生变化时，<code>range_size</code> 才会变化 → f_i 才可能变大</p></blockquote><ul><li>假设 val ∈ <code>[nums[r]-k, nums[r+1]-k)</code>：<ul><li>r 不变</li><li>l 不变</li><li>range_size 恒定 → f_i 不变</li></ul></li><li>区间内部的所有 val <strong>不会增加最大频率</strong> → 无需枚举</li></ul><h2 id="临界点分析"><a href="#临界点分析" class="headerlink" title="临界点分析"></a>临界点分析</h2><p>窗口边界变化的临界点：</p><ol><li>左边界 l 变化：val - k = nums[i]（左边元素刚好进入/离开窗口）</li><li>右边界 r 变化：val + k = nums[i]（右边元素刚好进入/离开窗口）</li></ol><p>也就是说，<strong>只有当 val 等于某个 nums[i] ± k 或 nums[i] 本身</strong>，窗口边界会发生变化。</p><ul><li>val = nums[i] → 对应窗口覆盖 nums[i] 本身</li><li>val = nums[i] - k → 窗口左边界刚好覆盖 nums[i]</li><li>val = nums[i] + k → 窗口右边界刚好覆盖 nums[i]</li></ul><blockquote><p>这三个值就是 <strong>所有可能改变窗口范围的临界点</strong></p></blockquote><p>综上：我们只需要枚举边界值即可，即枚举{nums[i]-k , nums[i], num[i] +k}。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxFrequency</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k, <span class="type">int</span> numOperations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> range_size;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">umap[nums[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 0 &lt;= numOperations &lt;= nums.length</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : &#123; nums[i] - k, nums[i], nums[i] + k &#125;) &#123;</span><br><span class="line"><span class="comment">// 要枚举的值不在范围内</span></span><br><span class="line"><span class="keyword">if</span> (val &lt; nums.<span class="built_in">front</span>() || val &gt; nums.<span class="built_in">back</span>()) &#123;</span><br><span class="line"><span class="comment">// 如果val比nums最小值还小，没有意义，因为任何一个值能通过操作变成这个val，那么肯定也可以变成nums的最小值，那么为什么不用最小值作为目标众数呢？</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// range &#123;x in nums[i] &amp;&amp; x in &#123;val-k..val+k&#125;&#125;</span></span><br><span class="line">range_size =</span><br><span class="line">std::<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),</span><br><span class="line"> nums.<span class="built_in">end</span>(), val + k) -</span><br><span class="line">std::<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),</span><br><span class="line"> nums.<span class="built_in">end</span>(), val - k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终能把某个值变成出现次数最多的频率 = 原来这个值的出现次数 +</span></span><br><span class="line"><span class="comment">// 通过操作可以变成这个值的次数,但不能超过窗口内可转换到的数量</span></span><br><span class="line">res = std::<span class="built_in">max</span>(</span><br><span class="line">res, std::<span class="built_in">min</span>(numOperations + umap[val],</span><br><span class="line">      range_size));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">999999997</span>, <span class="number">999999999</span>, <span class="number">999999999</span> &#125;;</span><br><span class="line">Solution S;</span><br><span class="line"><span class="type">int</span> k = <span class="number">999999999</span>;</span><br><span class="line"><span class="type">int</span> numOperations = <span class="number">2</span>;</span><br><span class="line">S.<span class="built_in">maxFrequency</span>(nums, k, numOperations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P135 分发糖果</title>
      <link href="/posts/135/"/>
      <url>/posts/135/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-20</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P135 分发糖果" href="https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P135 分发糖果</p><p class="url">https://leetcode.cn/problems/candy/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>可以想象 ratings 构成一段连绵的山，最开始我们初始化为 1，是平坦的平地，从左向右扫描会处理上坡的所有元素，从右向左扫描处理下坡的元素，而对于上下坡的分界点，要由左边要求的和右边要求的最大值+1，才能既满足上坡，又满足下坡。</p><p>初始化先给每一个人发一个糖果。</p><p>🍬 Step 1：从左到右<br>保证右边比左边高的孩子糖果更多：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ratings<span class="comment">[i]</span> &gt; ratings<span class="comment">[i-1]</span></span><br><span class="line">    candy<span class="comment">[i]</span> = candy<span class="comment">[i-1]</span> + 1</span><br></pre></td></tr></table></figure><p>🍬 Step 2：从右到左</p><p>保证左边比右边高的孩子糖果更多，同时和已有值取最大（避免破坏左到右的规则）：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ratings<span class="selector-attr">[i]</span> &gt; ratings<span class="selector-attr">[i+1]</span></span><br><span class="line">  candy<span class="selector-attr">[i]</span> = <span class="built_in">max</span>(candy<span class="selector-attr">[i]</span>, candy<span class="selector-attr">[i+1]</span> + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>上坡从左往右，因为右边需要参考左边</li><li>下坡从右往左，因为左边需要参考右边</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ratings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, n = ratings.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candies</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// left to right</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// right to left</span></span><br><span class="line"><span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">candies[i] = std::<span class="built_in">max</span>(candies[i + <span class="number">1</span>] + <span class="number">1</span>,</span><br><span class="line">      candies[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> std::<span class="built_in">accumulate</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 贪心 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2011 执行操作后的变量值</title>
      <link href="/posts/2011/"/>
      <url>/posts/2011/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-20</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2011 执行操作后的变量值" href="https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/description/?envType=daily-question&envId=2025-10-20"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2011 执行操作后的变量值</p><p class="url">https://leetcode.cn/problems/final-value-of-variable-after-performing-operations/description/?envType=daily-question&envId=2025-10-20</p></div></a></div></p><p>重拳出击！👊👊👊<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">finalValueAfterOperations</span><span class="params">(vector&lt;string&gt; &amp;operations)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = operations.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (operations[i].<span class="built_in">compare</span>(<span class="string">&quot;++X&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">    operations[i].<span class="built_in">compare</span>(<span class="string">&quot;X++&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">res++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operations[i].<span class="built_in">compare</span>(<span class="string">&quot;--X&quot;</span>) ||</span><br><span class="line">   operations[i].<span class="built_in">compare</span>(<span class="string">&quot;X--&quot;</span>)) &#123;</span><br><span class="line">res--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P1625 执行操作后字典序最小的字符串</title>
      <link href="/posts/1625/"/>
      <url>/posts/1625/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-19</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P1625 执行操作后字典序最小的字符串" href="https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/?envType=daily-question&envId=2025-10-19"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P1625 执行操作后字典序最小的字符串</p><p class="url">https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/?envType=daily-question&envId=2025-10-19</p></div></a></div></p><p>DFS枚举：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::unordered_set;</span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sadd</span><span class="params">(string &amp;s, <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, n;</span><br><span class="line">n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">s[i] = ((s[i] - <span class="string">&#x27;0&#x27;</span>) + a) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sshift</span><span class="params">(string &amp;s, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">b = b % n;</span><br><span class="line"></span><br><span class="line">string substr = s.<span class="built_in">substr</span>(n - b, b);</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">end</span>() - b, s.<span class="built_in">end</span>());</span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(), substr.<span class="built_in">begin</span>(), substr.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">findLexSmallestString</span><span class="params">(string s, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_set&lt;string&gt; visited;</span><br><span class="line">queue&lt;string&gt; q;</span><br><span class="line">string res = s, cur, t;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line">visited.<span class="built_in">insert</span>(s);</span><br><span class="line">                <span class="comment">// BFS</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cur = q.<span class="built_in">front</span>();       </span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">res = <span class="built_in">min</span>(res, cur);</span><br><span class="line">                        <span class="comment">// 两条分支累加或者轮转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加操作</span></span><br><span class="line">t = cur;</span><br><span class="line"><span class="built_in">sadd</span>(t, a);</span><br><span class="line"><span class="keyword">if</span> (!visited.<span class="built_in">count</span>(t)) &#123;</span><br><span class="line">visited.<span class="built_in">insert</span>(t);</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮转操作</span></span><br><span class="line">t = cur;</span><br><span class="line"><span class="built_in">sshift</span>(t, b);</span><br><span class="line"><span class="keyword">if</span> (!visited.<span class="built_in">count</span>(t)) &#123;</span><br><span class="line">visited.<span class="built_in">insert</span>(t);</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3397 执行操作后不同元素的最大数量</title>
      <link href="/posts/3397/"/>
      <url>/posts/3397/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-18</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3397 执行操作后不同元素的最大数量" href="https://leetcode.cn/problems/maximum-number-of-distinct-elements-after-operations/description/?envType=daily-question&envId=2025-10-18"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3397 执行操作后不同元素的最大数量</p><p class="url">https://leetcode.cn/problems/maximum-number-of-distinct-elements-after-operations/description/?envType=daily-question&envId=2025-10-18</p></div></a></div></p><h1 id="O-nk"><a href="#O-nk" class="headerlink" title="$O(nk)$"></a>$O(nk)$</h1><p>先排个序，然后贪心地选择每次能取到的最小的，$ 0 &lt; offset &lt;= 2 \times k$这种情况下选择用循环取找下一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDistinctElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> last_val;</span><br><span class="line"><span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">last_val = nums[i] - k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">offset = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (offset == <span class="number">0</span> &amp;&amp; last_val != nums[i - <span class="number">1</span>] + k) &#123;</span><br><span class="line">last_val = last_val + <span class="number">1</span>;</span><br><span class="line">res++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; <span class="number">2</span> * k) &#123;</span><br><span class="line">last_val = nums[i] - k;</span><br><span class="line">res++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 0 &lt; offset &lt;= 2*k</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] - k + j &gt; last_val) &#123;</span><br><span class="line">res++;</span><br><span class="line">last_val = nums[i] - k + j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Solution s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">s.<span class="built_in">maxDistinctElements</span>(vec, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="O-n"><a href="#O-n" class="headerlink" title="$O(n)$"></a>$O(n)$</h1><p>只需要遍历一遍，主要思想是优化$ 0 &lt; offset &lt;= 2 \times k$的情况，下一个值取到哪里与 nums[i] - k 和 last_val 有关，对其情况进行穷举避免循环遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxDistinctElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> last_val;</span><br><span class="line"><span class="type">int</span> offset;</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">last_val = nums[i] - k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">offset = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (offset == <span class="number">0</span> &amp;&amp; last_val != nums[i - <span class="number">1</span>] + k) &#123;</span><br><span class="line">last_val = last_val + <span class="number">1</span>;</span><br><span class="line">res++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == <span class="number">0</span> &amp;&amp; last_val == nums[i - <span class="number">1</span>] + k) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; <span class="number">2</span> * k) &#123;</span><br><span class="line">last_val = nums[i] - k;</span><br><span class="line">res++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 0 &lt; offset &lt;= 2*k</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] - k &gt; last_val) &#123;</span><br><span class="line">last_val = nums[i] - k;</span><br><span class="line">res++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">last_val = last_val + <span class="number">1</span>;</span><br><span class="line">res++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Solution s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">s.<span class="built_in">maxDistinctElements</span>(vec, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM Exception Model</title>
      <link href="/posts/2510160/"/>
      <url>/posts/2510160/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-16</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><h1 id="ARM64-的异常处理（Exception-Model）"><a href="#ARM64-的异常处理（Exception-Model）" class="headerlink" title="ARM64 的异常处理（Exception Model）"></a>ARM64 的异常处理（Exception Model）</h1><p>参考文档：</p><div class="tag link"><a class="link-card" title="Arm Architecture Reference Manual Armv8" href="https://developer.arm.com/documentation/ddi0487/fc/"><div class="left"><img src="https://developer.arm.com/shared/common/img/favicon/favicon.ico"/></div><div class="right"><p class="text">Arm Architecture Reference Manual Armv8</p><p class="url">https://developer.arm.com/documentation/ddi0487/fc/</p></div></a></div><h2 id="ARM64-的异常等级（Exception-Level）"><a href="#ARM64-的异常等级（Exception-Level）" class="headerlink" title="ARM64 的异常等级（Exception Level）"></a>ARM64 的异常等级（Exception Level）</h2><ul><li><strong>EL0</strong> 非特权模式，例如应用程序</li><li><strong>EL1</strong> 特权模式，例如 OS 内核</li><li><strong>EL2</strong> 虚拟化监控程序，例如 hypervisor</li><li><strong>EL3</strong> 安全模式，例如 secure monitor</li></ul><h2 id="术语（Exception-terminology）"><a href="#术语（Exception-terminology）" class="headerlink" title="术语（Exception terminology）"></a>术语（Exception terminology）</h2><ul><li><strong>Taking an exception</strong>: 正在处理一个异常</li><li><strong>Returning from an exception</strong>: 从一个异常中返回</li><li><strong>Exception levels</strong>: 异常等级</li><li><strong>Precise exception</strong>: 精准异常</li><li><strong>Synchronous and asynchronous exception</strong>: 同步异常与异步异常<ul><li><strong>同步异常</strong><ul><li><strong>系统调用, svc, hvc, SMC 等</strong></li><li><strong>MMU 引发的异常</strong></li><li><strong>SP 和 PC 对齐检查</strong></li><li><strong>未分配的指令</strong><ul><li>未分配的指令操作码</li><li>需要比当前异常级别更高级别特权的指令。</li><li>已禁用的指令。</li><li>PSTATE.IL 域被设置时的任何指令</li></ul></li><li>调试异常</li></ul></li><li><strong>异步异常</strong><ul><li><strong>IRQ 中断</strong></li><li><strong>FIQ 中断</strong></li><li><strong>SError</strong>（系统错误）</li></ul></li></ul></li></ul><h2 id="异常入口（Exception-Entry）"><a href="#异常入口（Exception-Entry）" class="headerlink" title="异常入口（Exception Entry）"></a>异常入口（Exception Entry）</h2><blockquote><p>Process state or PSTATE is an abstraction of process state information</p></blockquote><ul><li>当异常发生时，<strong>CPU 硬件</strong>都做了哪些事情<ul><li><strong>PSTATE 保存到 SPSR_ELx（The Saved Program Status Register）</strong></li><li><strong>返回地址保存 ELR_ELx</strong></li><li><strong>PSTATE 寄存器的 DAIF 域都设置为 1，相当于把调试异常，系统错误（SError），IRQ 中断以及 FIQ 中断都关闭了</strong></li><li><strong>更新了 ESR_ELx（Exception Syndrome Register）寄存器，里面包含了同步异常或SError发生的原因</strong></li><li><strong>SP 执行 SP_ELx</strong></li><li><strong>切换到对应的 EL，然后跳转到异常向量表里执行</strong></li></ul></li><li>当异常发生后，操作系统需要做哪些事情</li></ul><blockquote><p>操作系统需要设置异常向量表，这样CPU根据异常发生的类型，会跳转到合适的异常向量表的表项</p><p>异常向量表的每个表项会保存一个异常处理的跳转函数，然后跳转到恰当的异常处理函数并处理异常</p></blockquote><p>异常状态寄存器（Exception Syndrome Register, ESR_ELn）包含允许异常处理程序确定异常原因的信息。它只<br>对针对同步异常和 SError 做更新，不为 IRQ 或 FIQ 更新，因为这些中断处理程序通常从通用中断控制<br>器 (GIC) 的寄存器中获取状态信息。</p><h2 id="异常的返回"><a href="#异常的返回" class="headerlink" title="异常的返回"></a>异常的返回</h2><ul><li>操作系统执行一条<strong>eret</strong>语句<ul><li><strong>从 ELR_ELx（Exception Link Register）寄存器中恢复 PC 指针</strong></li><li><strong>从 SPSR_ELx（The Saved Program Status Register）寄存器恢复处理器的状态</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161436060.png" alt="异常处理的流程"></p><h3 id="异常返回地址"><a href="#异常返回地址" class="headerlink" title="异常返回地址"></a>异常返回地址</h3><ul><li>返回地址两个寄存器<ul><li><strong>x30：子函数的返回地址。使用 ret 指令来返回</strong></li><li><strong>ELR_ELx：异常返回地址。使用 eret 指令来返回</strong></li></ul></li><li><strong>ELR_ELx</strong>寄存器保存了异常返回地址<ul><li><strong>对于异步异常，它的返回地址是中断发生时的下一条指令，或者没有执行的第一条指令</strong></li><li><strong>对于不是 system call 的同步异常，返回的是触发同步异常的那一条指令</strong></li><li><strong>对于 system call，它返回的是 svc 指令的下一条指令</strong></li></ul></li></ul><p><strong>异步异常（中断）</strong></p><blockquote><p>硬件已经把 ELR 设置为 <em>下一条要执行的指令</em>，<code>eret</code> 就直接回去继续执行，不用额外改</p></blockquote><p><strong>同步异常（非 system call）</strong></p><blockquote><p>硬件把 ELR 设置为 <em>触发异常的那条指令</em><br>如果你修复了异常原因（比如缺页异常），直接 <code>eret</code> 就会重新执行这条指令<br>如果你想跳过它（不重试），就要手动 <code>ELR_ELx += 4</code></p></blockquote><p><strong>system call（svc）</strong></p><blockquote><p>硬件把 ELR 设置为 <em>svc 的下一条指令</em>，所以 <code>eret</code> 会直接返回到下一条</p></blockquote><h2 id="异常处理的路由"><a href="#异常处理的路由" class="headerlink" title="异常处理的路由"></a>异常处理的路由</h2><blockquote><p>当在一个特定的“异常等级（Exception Level, EL）”发生异常时，CPU 应该跳转到哪个异常等级去处理它</p></blockquote><ul><li>异常发生时，可以在<strong>当前 EL 处理也可以在更高 EL 处理</strong><ul><li><strong>EL0 不能用来处理异常</strong></li><li><strong>同步异常是可以在当前 EL 里处理的</strong>，比如在 EL1 发生了同步异常</li><li>对于<strong>异步异常，可以路由到 EL1,EL2,EL3 处理</strong>，需要配置<strong>HCR</strong>（Hypervisor Configuration Register）以及<strong>SCR</strong>（Secure Configuration Register）相关寄存器</li><li>如果异常是由于在 EL0 处取指令而产生的，则将其视为 EL1 的异常，除非 HCR_EL2.TGE 位设置为非安全状态，在这种情况下将其视为 EL2。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161443573.png" alt="异常发生时要路由到哪一级"></p><p>参考 armv8.6 的 tableD1-10</p><ul><li>SCR_EL3: Secure Configuration Register</li><li>HCR_EL2: Hyervisor Cofiguration Register</li></ul><p>该图片中的表格（Table D1-10）是<strong>ARM 架构下 EL3（安全监控模式）与 EL2（虚拟化监控模式）同时实现时的中断 / 异常路由规则表</strong>，核心用于定义不同系统状态（寄存器配置）下，中断（IRQ/FIQ）或异常（如 Abt 中止异常）触发后，处理器最终跳转的目标特权级别（EL0~EL3）。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161444608.png" alt="Routing when both EL3 and EL2 are implemented"></p><ol><li>第 1 行：SCR=0，NS EEL2a=0，EA IRQ FIQ=0，RW=0</li></ol><ul><li><strong>输入条件</strong>：安全配置为默认（SCR=0）、非安全 EL2 异常入口关闭（NS EEL2a=0）、无活跃中断 / 异常（EA IRQ FIQ=0）、读写权限为 0；HCR TGE、E2H 为任意值（X）。</li><li><strong>路由结果</strong>：<ul><li>从 EL0 触发：跳转到 “FIQ IRQ Abt”（即触发对应中断 / 异常的原生处理入口，未被高 EL 拦截）；</li><li>从 EL1 触发：同 EL0，跳转到 “FIQ IRQ Abt”；</li><li>从 EL2 触发：<code>n/a</code>（不适用，因 NS EEL2a=0 时 EL2 未使能该场景）；</li><li>从 EL3 触发：跳转到 “C”（通常指 “安全态下的异常处理入口”，ARM 架构中 “C” 常代表安全相关的默认目标）。</li></ul></li></ul><ol><li>第 2 行：SCR=0，NS EEL2a=0，EA IRQ FIQ=0，RW=1</li></ol><ul><li><strong>输入条件</strong>：仅 RW（读写权限）从 0 改为 1，其他与第 1 行一致。</li><li><strong>路由结果</strong>：<ul><li>从 EL0/EL1 触发：跳转到 “EL1”（即异常被 EL1（内核态）拦截处理，而非原生中断入口，因 RW=1 对应更高权限的内核处理逻辑）；</li><li>从 EL2 触发：<code>n/a</code>（同第 1 行，EL2 未使能）；</li><li>从 EL3 触发：跳转到 “C”（安全态入口不变）。</li></ul></li></ul><ol><li>第 3 行：SCR=0，NS EEL2a=0，EA IRQ FIQ=1</li></ol><ul><li><strong>输入条件</strong>：EA IRQ FIQ=1（有活跃的中断 / 异常触发），其他配置同前两行；HCR TGE、E2H 为任意值。</li><li><strong>路由结果</strong>：<ul><li>从 EL0/EL1 触发：跳转到 “EL3”（活跃中断 / 异常被最高安全级 EL3 拦截，符合 ARM 安全架构中 “高优先级异常由 EL3 处理” 的逻辑）；</li><li>从 EL2 触发：<code>n/a</code>（EL2 未使能）；</li><li>从 EL3 触发：跳转到 “EL3”（EL3 自身触发的异常，在 EL3 内部处理，不跳转其他级别）。</li></ul></li></ul><ol><li>第 4 行：SCR=0，NS EEL2a=1，EA IRQ FIQ=0，HCR TGE=0，E2H=0，RW=0</li></ol><ul><li><strong>输入条件</strong>：NS EEL2a=1（非安全 EL2 异常入口开启）、无活跃中断 / 异常（EA IRQ FIQ=0）、虚拟化模式关闭（HCR TGE=0）、EL2 不拦截 EL1 异常（E2H=0）。</li><li><strong>路由结果</strong>：<ul><li>从 EL0 触发：跳转到 “FIQ IRQ Abt”（原生中断入口）；</li><li>从 EL1 触发：跳转到 “FIQ IRQ Abt”（EL2 未拦截，因 E2H=0）；</li><li>从 EL2 触发：跳转到 “C”（非安全 EL2 触发的异常，路由到安全态入口 “C”）；</li><li>从 EL3 触发：跳转到 “C”（安全态内部处理，目标不变）。</li></ul></li></ul><h2 id="栈的选择"><a href="#栈的选择" class="headerlink" title="栈的选择"></a>栈的选择</h2><ul><li>每个异常等级 EL 都有对应栈指针寄存器 SP_ELx<ul><li>SP_EL0, SP_EL1, SP_EL2, SP_EL3</li></ul></li><li><strong>栈必须 16 字节对齐</strong>。硬件可以检测栈指针是否对齐</li><li><strong>当异常发生时，并跳转到目标异常等级时，硬件会自动选择 SP_ELx</strong></li><li><strong>操作系统负责和分配</strong>保证每个异常等级 EL 对应的栈，是可用的</li></ul><h2 id="执行模式"><a href="#执行模式" class="headerlink" title="执行模式"></a>执行模式</h2><h3 id="异常处理的执行模式"><a href="#异常处理的执行模式" class="headerlink" title="异常处理的执行模式"></a>异常处理的执行模式</h3><ul><li>当异常发生时，切换到高级别的 EL，这个 EL 运行在哪个模式？AArch64 or AArch32<ul><li><strong>HCR_EL2.RW（Hypervisor Configuration Register）</strong>记录了 EL1 要运行在哪个模式<ul><li>1 表示 aarch64</li><li>0 表示 aarch32</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161444227.png" alt="Execution state control for lower Exception levels"></p><ul><li><strong>当异常发生后，执行模式可以发生改变</strong><ul><li>一个 aarch32 的应用程序正在运行，这时候来了一个中断，它可能会跑到 aarch64 执行状态下的 EL1 里处理这个中断</li></ul></li></ul><h3 id="异常返回的执行模式"><a href="#异常返回的执行模式" class="headerlink" title="异常返回的执行模式"></a>异常返回的执行模式</h3><ul><li>从一个异常返回，SPSR 寄存器(Saved Program Status Register)记录了：<ul><li>返回到哪个 EL? <strong>SPSR.M[3:0]</strong></li><li>返回目标 EL 的执行模式？<strong>SPSR.M[4]</strong><ul><li>0 表示 aarch64</li><li>1 表示 aarch32</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161445722.png" alt="Exceptions taken from AArch64 state"></p><h2 id="实验-1：切换到-EL1-中运行"><a href="#实验-1：切换到-EL1-中运行" class="headerlink" title="实验 1：切换到 EL1 中运行"></a>实验 1：切换到 EL1 中运行</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161446370.png" alt="实验一"></p><p><strong>提示</strong></p><p>从 EL2 切换到 EL1，需要做如下几件事情</p><ol><li><p><strong>设置 HCR_EL2（Hypervisor Configuration Register）寄存器，最重要的是 Bit 31 的 RW 域，表示 EL1 要运行在哪个执行环境里，aarch32 或 aarch64</strong>（相似地对于EL2的执行状态由SCR_EL3决定）</p><ul><li>HCR_EL2 属于 General System Control Register</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161446047.png" alt="HCR_EL2"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161446427.png" alt="HCR_EL2.RW"></p></li><li><p><strong>设置 SCTLR_EL1（System Control Register），要设置大小端和关闭 MMU</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161446790.png" alt="SCTLR_EL1.EE"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161447667.png" alt="SCTLR_EL1.E0E"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161447770.png" alt="SCTELR_EL1.M"></p></li><li><p><strong>设置 SPSR_EL2（Saved Program Status Register）寄存器，设置模式 M 域为 EL1h，另外需要关闭所有 PSTATE 的 DAIF</strong></p><ul><li><strong>SPSR_ELx</strong>属于<strong>Special-purpose Register</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161448334.png" alt="SPSR_EL2"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161448924.png" alt="SPSR_EL2.M"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161449361.png" alt="PSTATE.DAIF at EL2"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161449139.png" alt="SPSR_EL1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161451860.png" alt="SPSR_EL.M"></p></li></ol><div class="table-container"><table><thead><tr><th>M[3:0]</th><th>目标模式</th><th>说明</th></tr></thead><tbody><tr><td><code>0000</code></td><td>EL0t</td><td>EL0，使用 SP_EL0</td></tr><tr><td><code>0100</code></td><td>EL1t</td><td>EL1，使用 SP_EL0</td></tr><tr><td><code>0101</code></td><td>EL1h</td><td>EL1，使用 SP_EL1</td></tr><tr><td><code>1000</code></td><td>EL2t</td><td>EL2，使用 SP_EL0</td></tr><tr><td><code>1001</code></td><td>EL2h</td><td>EL2，使用 SP_EL2</td></tr><tr><td><code>1100</code></td><td>EL3t</td><td>EL3，使用 SP_EL0</td></tr><tr><td><code>1101</code></td><td>EL3h</td><td>EL3，使用 SP_EL3</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161528528.png" alt="PSTATE.DAIF at EL1"></p><ol><li><p><strong>设置异常返回寄存器 elr_el2，让其返回到 el1_entry 汇编函数里</strong></p></li><li><p>执行<strong>eret</strong></p></li></ol><p>（3,4 其实是一个异常返回的经典步骤，从 EL2 返回到 EL1）</p><p><strong>首先根据当前异常等级判断要跳到哪个异常等级</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161453031.png" alt="判断当前异常等级"></p><p>注意执行 eret 前要设置 elr_el2 寄存器</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161458740.png" alt="跳到EL1"></p><h2 id="异常向量表（Exception-vectors）"><a href="#异常向量表（Exception-vectors）" class="headerlink" title="异常向量表（Exception vectors）"></a>异常向量表（Exception vectors）</h2><ul><li><p>每个异常等级 EL 都有自己的异常向量表，EL0 除外</p></li><li><p>异常向量表的基地址需要设置到<strong>VBAR_ELx（Vector Base Address Register）</strong>寄存器中</p></li><li><p>VBAR_EL1 寄存器：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161458499.png" alt="VBAR_ELx"></p><p>0~10 是 reserve，因此<strong>地址是 2k 对齐</strong></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161459864.png" alt="异常向量表结构"></p><ol><li><p>行（Exception taken from）</p><blockquote><p>定义异常触发时的 “当前执行状态”，分 4 类场景：</p></blockquote><ul><li><strong>Current Exception level with SP_EL0</strong>：当前异常级别使用 <code>SP_EL0</code> 栈指针（如在 EL1 下用用户级栈指针时触发异常 ）。</li><li><strong>Current Exception level with SP_ELx, x&gt;0</strong>：当前异常级别使用 <code>SP_ELx</code>（x≥1，如 EL1 用 <code>SP_EL1</code>、EL2 用 <code>SP_EL2</code> 等内核级栈指针）时触发异常。</li><li><strong>Lower Exception level（AArch64）</strong>：从更低异常级别触发，且 “更低级别” 处于 AArch64 执行状态（如从 EL0/EL1 切换到更高 EL 时，且原级别是 64 位模式 ）。</li><li><strong>Lower Exception level（AArch32）</strong>：从更低异常级别触发，且 “更低级别” 处于 AArch32 执行状态（如从 32 位模式的 EL0/EL1 切换到更高 EL ）。</li></ul></li><li><p>列（Offset for exception type）</p><blockquote><p>按异常类型分类，对应不同偏移：</p></blockquote><ul><li><strong>Synchronous</strong>：同步异常（如指令执行错误、软件触发异常等，与指令流同步发生 ）。</li><li><strong>IRQ or vIRQ</strong>：普通中断（IRQ）或虚拟中断（vIRQ，虚拟化场景下）。</li><li><strong>FIQ or vFIQ</strong>：快速中断（FIQ，优先级通常更高）或虚拟快速中断（vFIQ，虚拟化场景 ）。</li><li><strong>SError or vSError</strong>：系统错误（SError，如总线错误等严重错误）或虚拟系统错误（vSError，虚拟化场景 ）。</li></ul></li><li><p><strong>偏移值（如 0x000、0x080 等）</strong>：基于行（触发状态）和列（异常类型）的组合，给出相对于向量表基地址的偏移，处理器通过基地址 + 偏移，就能找到异常处理程序的入口地址 。</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161459444.png" alt="异常向量表结构"></p><ul><li><strong>异常向量表的整体结构</strong></li></ul><p>在 <strong>AArch64 EL1</strong> 及以上的执行级别中，异常向量表（Vector Table）存放在 <strong><code>VBAR_ELx</code></strong>（Vector Base Address Register）寄存器指向的地址。</p><p>这个表里一共包含 <strong>4 个“区块” (blocks)</strong>，分别对应不同的异常来源：</p><ol><li><strong>从当前的 SP (SP0)</strong> 触发的异常</li><li><strong>从当前的 SP (SPx)</strong> 触发的异常（x≠0，比如 SP_EL1）</li><li><strong>来自下一个更低特权级（比如 EL0）</strong> 的异常</li><li><strong>来自当前特权级（比如 EL1 内部）</strong> 的异常</li></ol><p>每个区块又包含 <strong>4 种异常类型</strong>：</p><ul><li><strong>Synchronous exception</strong> （同步异常，比如 SVC 指令、数据访问异常）</li><li><strong>IRQ</strong> （普通中断）</li><li><strong>FIQ</strong> （快速中断）</li><li><strong>SError</strong> （系统错误，通常是硬件异常）</li></ul><p>所以总共：<br><strong>4 个区块 × 4 种异常 = 16 个表项</strong></p><hr><p><strong>每个表项的大小</strong></p><p>ARMv8-A 规定：</p><ul><li><strong>每个表项的大小固定为 128 字节</strong>（0x80）（32条指令大小）。</li><li><strong>16 个表项 × 128 字节 = 2048 字节 = 2KB</strong>。</li><li>所以整个向量表的大小是 <strong>2KB</strong>。</li></ul><p>也就是说，异常向量表必须是 <strong>2KB 对齐</strong>的区域。</p><p>异常向量表表实际上由 4 组 4 项组成</p><h2 id="Linux5-0-内核的异常处理"><a href="#Linux5-0-内核的异常处理" class="headerlink" title="Linux5.0 内核的异常处理"></a>Linux5.0 内核的异常处理</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161500753.png" alt="Linux5.0的异常向量表"></p><ul><li><p>.align 11 就是让异常向量表按<strong>2k 大小对齐</strong></p></li><li><p>kernel_ventry 是一个宏，简化代码如下</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161501900.png" alt="kernel_ventry"></p><blockquote><p>align 7 表示按 2 的 7 次方大小来对齐，2 的 7 次方是 128 个字节</p><p>sub 指令是让栈指针 sp 减去一个 S_FRAME_SIZE，其中 S_FRAME_SIZE 称为寄存器框架大小，也就是 struct pt_regs 数据结构的大小</p><p>“\()”表示连接</p><p>举例：在发生 EL1 的 IRQ 中断时，这条语句变成了”b el1_irq”</p></blockquote><p><code>kernel_entry</code> 是异常向量表跳转到的第一级入口，它的职责是：</p><ol><li><strong>保存上下文</strong>：把 CPU 现场（通用寄存器）保存到栈上。</li><li><strong>建立栈帧</strong>：为异常处理函数（C 代码）准备好栈空间。</li><li><strong>切换栈</strong>（如果需要）：例如从用户态进入内核态时，栈要换成内核栈。</li><li><strong>调用 C 层的异常分发函数</strong>。</li></ol><p><strong>以发生在 EL1 的 FIQ 为例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161502048.png" alt="发生在EL1的FIQ"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161502412.png" alt="bad_mode"></p><p><strong>保存异常上下文</strong></p><ul><li><strong>栈框</strong>：Linux 内核中定义了一个<strong>struct pt_regs</strong>的数据结构来描述内核栈上保存寄存器的排列信息，通常用于保存中断上下文等信息</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161502433.png" alt="栈框"></p><blockquote><p>orig_x0, syscallno, orig_addr_limit, unused, stackfram[0], stackframe[1]都是软件定义保存的东西</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161503209.png" alt="保存异常上下文的处理流程"></p><h2 id="实验-2：建立一个异常向量表并创造一个同步异常"><a href="#实验-2：建立一个异常向量表并创造一个同步异常" class="headerlink" title="实验 2：建立一个异常向量表并创造一个同步异常"></a>实验 2：建立一个异常向量表并创造一个同步异常</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161503661.png" alt="实验2"></p><p><strong>FAR Fault Address Register (at EL1)</strong></p><p>它的作用是：</p><ul><li>当 <strong>发生同步异常（Synchronous Exception）</strong> 时，处理器会把导致异常的 <strong>虚拟地址</strong>写入到 <code>FAR_ELx</code> 对应寄存器中。</li><li><code>EL1</code> 就对应内核态（操作系统层），所以 <code>FAR_EL1</code> 保存的是 <strong>EL1 下异常发生时的虚拟地址</strong>。</li></ul><hr><p><strong>常见场景</strong></p><ol><li><strong>Page Fault（缺页异常）</strong><br>如果 CPU 在访问一个不存在或非法的虚拟地址时触发异常，<code>FAR_EL1</code> 会保存这个地址，内核就可以根据它决定是否分配新页、还是杀掉进程。</li><li><strong>Alignment Fault（未对齐访问异常）</strong><br>如果访问地址不符合对齐规则，<code>FAR_EL1</code> 也会保存那个地址。</li><li><strong>Watchpoint/Breakpoint 异常</strong><br><code>FAR_EL1</code> 也可能被用来存储触发异常的地址。</li></ol><hr><p><strong>相关寄存器</strong></p><ul><li><code>ESR_EL1</code> (<strong>Exception Syndrome Register</strong>)<br>保存异常的 <strong>原因码</strong>（比如是缺页、权限错误、未对齐等）。</li><li><code>FAR_EL1</code><br>保存导致异常的 <strong>具体虚拟地址</strong>。</li></ul><p>entry.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#define BAD_SYNC  0</span><br><span class="line">#define BAD_IRQ   1</span><br><span class="line">#define BAD_FIQ   2</span><br><span class="line">#define BAD_ERROR 3</span><br><span class="line"></span><br><span class="line">    .macro inv_entry el, reason</span><br><span class="line">    // 保存异常现场，暂未实现</span><br><span class="line">    // kernel_entry el</span><br><span class="line">    mov x0, sp</span><br><span class="line">    mov x1, #\reason</span><br><span class="line">    mrs x2, esr_el1</span><br><span class="line">    b bad_mode</span><br><span class="line">    .endm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 异常向量表</span><br><span class="line">    .macro vtentry label</span><br><span class="line">    .align 7</span><br><span class="line">    b \label</span><br><span class="line">    .endm</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* ARM64的异常向量表一共占用2048个字节，分成四组，每个表项占用128字节</span><br><span class="line">* .align 11表示按2048对齐</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align 11</span><br><span class="line">.global vectors</span><br><span class="line"></span><br><span class="line">vectors:</span><br><span class="line">/* Current EL with SP0</span><br><span class="line">*  当前系统运行在EL1时使用EL0的栈指针SP</span><br><span class="line">* 这是一种异常的错误类型</span><br><span class="line">*/</span><br><span class="line">  vtentry el1_sync_invalid</span><br><span class="line">  vtentry el1_irq_invalid</span><br><span class="line">  vtentry el1_fiq_invalid</span><br><span class="line">  vtentry el1_error_invalid</span><br><span class="line"></span><br><span class="line">/* Current EL with SPx</span><br><span class="line">* 当前系统运行在EL1时使用EL1的栈指针SP</span><br><span class="line">* 说明系统内核态发生了异常</span><br><span class="line">* 暂时只实现IRQ中断</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">  vtentry el1_sync_invalid</span><br><span class="line">  vtentry el1_irq_invalid</span><br><span class="line">  vtentry el1_fiq_invalid</span><br><span class="line">  vtentry el1_error_invalid</span><br><span class="line"></span><br><span class="line">/* Lower EL using AArch64</span><br><span class="line">* 用户态的aarch64程序发生异常</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">  vtentry el0_sync_invalid</span><br><span class="line">  vtentry el0_irq_invalid</span><br><span class="line">  vtentry el0_fiq_invalid</span><br><span class="line">  vtentry el0_error_invalid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Lower EL using AArch32</span><br><span class="line">* 在用户态的aarch32程序发生异常</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">  vtentry el0_sync_invalid</span><br><span class="line">  vtentry el0_irq_invalid</span><br><span class="line">  vtentry el0_fiq_invalid</span><br><span class="line">  vtentry el0_error_invalid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">el1_sync_invalid:</span><br><span class="line">  inv_entry 1, BAD_SYNC</span><br><span class="line">el1_irq_invalid:</span><br><span class="line">  inv_entry 1, BAD_IRQ</span><br><span class="line">el1_fiq_invalid:</span><br><span class="line">  inv_entry 1, BAD_FIQ</span><br><span class="line">el1_error_invalid:</span><br><span class="line">  inv_entry 1, BAD_ERROR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">el0_sync_invalid:</span><br><span class="line">  inv_entry 0, BAD_SYNC</span><br><span class="line">el0_irq_invalid:</span><br><span class="line">  inv_entry 0, BAD_IRQ</span><br><span class="line">el0_fiq_invalid:</span><br><span class="line">  inv_entry 0, BAD_FIQ</span><br><span class="line">el0_error_invalid:</span><br><span class="line">  inv_entry 0, BAD_ERROR</span><br><span class="line"></span><br><span class="line">// 占用两个字节</span><br><span class="line">string_test:</span><br><span class="line">  .string &quot;t&quot;</span><br><span class="line">// 因为string_test导致不是4个字节对齐了</span><br><span class="line">.global trigger_alignment</span><br><span class="line"></span><br><span class="line">trigger_alignment:</span><br><span class="line">  ldr x0, =0x80002</span><br><span class="line">  ldr x1, [x0]</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p><strong>kernel.c</strong>中定义</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161504351.png" alt="bad_mode"></p><p>在<strong>kernel_main</strong>中触发<strong>trigger_alignment</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161504441.png" alt="trigger_alignment"></p><p>在<strong>boot.S</strong>中设置异常向量表</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161504951.png" alt="设置异常向量表"></p><h2 id="实验-3：解-bug：寻找树莓派-4-上触发异常的指令"><a href="#实验-3：解-bug：寻找树莓派-4-上触发异常的指令" class="headerlink" title="实验 3：解 bug：寻找树莓派 4 上触发异常的指令"></a>实验 3：解 bug：寻找树莓派 4 上触发异常的指令</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161505564.png" alt="实验3"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161528897.png" alt="ldr一个hong"></p><p>这条指令会加载当前 PC+MY_LABEL 为地址取值到 x6</p><p>相当于：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x6</span> = *(PC-relative 地址 + MY_LABEL)</span><br></pre></td></tr></table></figure><p>对于 LDR Xt 来说<strong>目标地址必须是 8 字节对齐的（因为 Xt 是 64 位寄存器）</strong></p><p>可以改成 w6，只需要四个字节对齐，因为 MY_LABEL 定义为 0x20</p><h2 id="异常的解析"><a href="#异常的解析" class="headerlink" title="异常的解析"></a>异常的解析</h2><h3 id="ESR-ELx-异常综合信息寄存器-Excepion-Syndrome-Register"><a href="#ESR-ELx-异常综合信息寄存器-Excepion-Syndrome-Register" class="headerlink" title="ESR_ELx(异常综合信息寄存器 Excepion Syndrome Register)"></a>ESR_ELx(异常综合信息寄存器 Excepion Syndrome Register)</h3><blockquote><p>ESR_ELx它只对针对同步异常和 SError 做更新，不为 IRQ 或 FIQ 更新，因为这些中断处理程序通常从通用中断控制器 (GIC) 的寄存器中获取状态信息。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161505049.png" alt="ESR_ELx"></p><ul><li>ESR 寄存器一共包含四个字段（域）<ul><li>Bit 32~63 保留比特位</li><li>Bit 26~31，是<strong>异常类型（Exception Class，简称 EC）</strong>,这个字段<strong>指示发生异常的类型</strong>，同时用来<strong>索引 ISS 域</strong></li><li>Bit 25，IL，表示同步异常指令的指令长度，Instruction Length</li><li>Bit 0~24，<strong>ISS（Instruction Specific Syndrome）具体的异常指令编码</strong>。这个异常指令编码表依赖不同的异常类型，<strong>不同的异常类型有不同的编码格式</strong></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161505572.png" alt="ESR寄存器中的异常类型"></p><p><strong>常见的异常类型对应编码</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161505469.png" alt="Instruction Abort"></p><p>第一个表示从低级异常等级的指令异常，第二个表示当前异常等级的指令异常</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161505993.png" alt="Data Abort"></p><p><strong>ISS 字段的编码方式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161507725.png" alt="ISS encoding for Instruction Abort"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161508098.png" alt="ISS encoding for Data Abort"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161508220.png" alt="ISS编码格式 Data Abort"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161509051.png" alt="Data Abort DFSC"></p><h3 id="FAR-失效地址寄存器"><a href="#FAR-失效地址寄存器" class="headerlink" title="FAR(失效地址寄存器)"></a>FAR(失效地址寄存器)</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161509372.png" alt="FAR"></p><p>FAR 寄存器保<strong>存了发生异常时刻的虚拟地址</strong></p><h2 id="实验四：解析数据异常的信息"><a href="#实验四：解析数据异常的信息" class="headerlink" title="实验四：解析数据异常的信息"></a>实验四：解析数据异常的信息</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161509422.png" alt="实验四"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161510757.png" alt="实验四结果"></p><p><strong>esr.h</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ESR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ESR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UL(x) x</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_UNKNOWN(0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_WFx(0x01)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x02 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_CP15_32(0x03)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_CP15_64(0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_CP14_MR(0x05)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_CP14_LS(0x06)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_FP_ASIMD(0x07)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_CP10_ID(0x08)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x09 - 0x0B */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_CP14_64(0x0C)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x0d */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_ILL(0x0E)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x0F - 0x10 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SVC32(0x11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_HVC32(0x12)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SMC32(0x13)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x14 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SVC64(0x15)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_HVC64(0x16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SMC64(0x17)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SYS64(0x18)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x19 - 0x1E */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_IMP_DEF(0x1f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_IABT_LOW(0x20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_IABT_CUR(0x21)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_PC_ALIGN(0x22)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x23 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_DABT_LOW(0x24)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_DABT_CUR(0x25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SP_ALIGN(0x26)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x27 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_FP_EXC32(0x28)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x29 - 0x2B */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_FP_EXC64(0x2C)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x2D - 0x2E */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SERROR(0x2F)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_BREAKPT_LOW(0x30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_BREAKPT_CUR(0x31)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SOFTSTP_LOW(0x32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SOFTSTP_CUR(0x33)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_WATCHPT_LOW(0x34)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_WATCHPT_CUR(0x35)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x36 - 0x37 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_BKPT32(0x38)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x39 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_VECTOR32(0x3A)</span></span><br><span class="line"><span class="comment">/* Unallocted EC: 0x3B */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_BRK64(0x3C)</span></span><br><span class="line"><span class="comment">/* Unallocated EC: 0x3D - 0x3F */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_MAX(0x3F)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SET_SHIFT(11)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_FnV_SHIFT(10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EA_SHIFT(9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_CM_SHIFT(8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_S1PTW_SHIFT(7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_WNR_SHIFT(6)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_SHIFT(26)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC_MASK(UL(0x3F) &lt;&lt; ESR_ELx_EC_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EC(esr)(((esr) &amp; ESR_ELx_EC_MASK) &gt;&gt; ESR_ELx_EC_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_IL(UL(1) &lt;&lt; 25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_ISS_MASK(ESR_ELx_IL - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_ISV(UL(1) &lt;&lt; 24)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SAS_SHIFT(22)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SAS(UL(3) &lt;&lt; ESR_ELx_SAS_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SSE_SHIFT(21)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SSE(UL(1) &lt;&lt; 21)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SRT_SHIFT(16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SRT_MASK(UL(0x1F) &lt;&lt; ESR_ELx_SRT_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SF_SHIFT(15)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_SF (UL(1) &lt;&lt; 15)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_AR_SHIFT(14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_AR (UL(1) &lt;&lt; 14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_EA (UL(1) &lt;&lt; 9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_CM (UL(1) &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_S1PTW (UL(1) &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_WNR(UL(1) &lt;&lt; 6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_FSC(0x3F)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_FSC_TYPE(0x3C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_FSC_EXTABT(0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_FSC_FAULT(0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_FSC_PERM(0x0C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_CV(UL(1) &lt;&lt; 24)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_COND_SHIFT(20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_COND_MASK(UL(0xF) &lt;&lt; ESR_ELx_COND_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_WFx_ISS_WFE(UL(1) &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ESR_ELx_xVC_IMM_MASK((1UL &lt;&lt; 16) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>作用</strong>：解析 ESR_ELx 寄存器的值，方便异常处理。</p><p><strong>结构</strong>：</p><ul><li>高 6 位 → <strong>EC（Exception Class）</strong></li><li>IL、ISV → 指令长度/有效性</li><li><strong>ISS → Instruction Specific Syndrome</strong></li><li>FSC → 数据访问异常代码</li><li>WNR、EA、CM → 访问属性</li></ul><p><strong>kernel.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> bad_mode_handler[] = &#123;<span class="string">&quot;Sync Abort&quot;</span>, <span class="string">&quot;IRQ&quot;</span>, <span class="string">&quot;FIQ&quot;</span>,</span><br><span class="line">                                               <span class="string">&quot;SError&quot;</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *data_fault_code[] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = <span class="string">&quot;Address size fault, level0&quot;</span>,</span><br><span class="line">    [<span class="number">1</span>] = <span class="string">&quot;Address size fault, level1&quot;</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="string">&quot;Address size fault, level2&quot;</span>,</span><br><span class="line">    [<span class="number">3</span>] = <span class="string">&quot;Address size fault, level3&quot;</span>,</span><br><span class="line">    [<span class="number">4</span>] = <span class="string">&quot;Translation fault, level0&quot;</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="string">&quot;Translation fault, level1&quot;</span>,</span><br><span class="line">    [<span class="number">6</span>] = <span class="string">&quot;Translation fault, level2&quot;</span>,</span><br><span class="line">    [<span class="number">7</span>] = <span class="string">&quot;Translation fault, level3&quot;</span>,</span><br><span class="line">    [<span class="number">9</span>] = <span class="string">&quot;Access flag fault, level1&quot;</span>,</span><br><span class="line">    [<span class="number">10</span>] = <span class="string">&quot;Access flag fault, level2&quot;</span>,</span><br><span class="line">    [<span class="number">11</span>] = <span class="string">&quot;Access flag fault, level3&quot;</span>,</span><br><span class="line">    [<span class="number">13</span>] = <span class="string">&quot;Permission fault, level1&quot;</span>,</span><br><span class="line">    [<span class="number">14</span>] = <span class="string">&quot;Permission fault, level2&quot;</span>,</span><br><span class="line">    [<span class="number">15</span>] = <span class="string">&quot;Permission fault, level3&quot;</span>,</span><br><span class="line">    [<span class="number">0x21</span>] = <span class="string">&quot;Alignment fault&quot;</span>,</span><br><span class="line">    [<span class="number">0x35</span>] = <span class="string">&quot;Unsupported Exclusive or Atomic access&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">esr_get_dfsc_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> esr)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data_fault_code[esr &amp; <span class="number">0x3f</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *esr_class_str[] = &#123;</span><br><span class="line">    <span class="comment">// GCC 扩展，表示把数组下标从 0 到 ESR_ELx_EC_MAX 全部初始化为 &quot;UNRECOGNIZED</span></span><br><span class="line">    <span class="comment">// EC&quot;。</span></span><br><span class="line">    [<span class="number">0</span> ... ESR_ELx_EC_MAX] = <span class="string">&quot;UNRECOGNIZED EC&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_UNKNOWN] = <span class="string">&quot;Unknown/Uncategorized&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_WFx] = <span class="string">&quot;WFI/WFE&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_CP15_32] = <span class="string">&quot;CP15 MCR/MRC&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_CP15_64] = <span class="string">&quot;CP15 MCRR/MRRC&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_CP14_MR] = <span class="string">&quot;CP14 MCR/MRC&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_CP14_LS] = <span class="string">&quot;CP14 LDC/STC&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_FP_ASIMD] = <span class="string">&quot;ASIMD&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_CP10_ID] = <span class="string">&quot;CP10 MRC/VMRS&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_CP14_64] = <span class="string">&quot;CP14 MCRR/MRRC&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_ILL] = <span class="string">&quot;PSTATE.IL&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SVC32] = <span class="string">&quot;SVC (AArch32)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_HVC32] = <span class="string">&quot;HVC (AArch32)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SMC32] = <span class="string">&quot;SMC (AArch32)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SVC64] = <span class="string">&quot;SVC (AArch64)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_HVC64] = <span class="string">&quot;HVC (AArch64)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SMC64] = <span class="string">&quot;SMC (AArch64)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SYS64] = <span class="string">&quot;MSR/MRS (AArch64)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_IMP_DEF] = <span class="string">&quot;EL3 IMP DEF&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_IABT_LOW] = <span class="string">&quot;IABT (lower EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_IABT_CUR] = <span class="string">&quot;IABT (current EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_PC_ALIGN] = <span class="string">&quot;PC Alignment&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_DABT_LOW] = <span class="string">&quot;DABT (lower EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_DABT_CUR] = <span class="string">&quot;DABT (current EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SP_ALIGN] = <span class="string">&quot;SP Alignment&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_FP_EXC32] = <span class="string">&quot;FP (AArch32)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_FP_EXC64] = <span class="string">&quot;FP (AArch64)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SERROR] = <span class="string">&quot;SError&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_BREAKPT_LOW] = <span class="string">&quot;Breakpoint (lower EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_BREAKPT_CUR] = <span class="string">&quot;Breakpoint (current EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SOFTSTP_LOW] = <span class="string">&quot;Software Step (lower EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_SOFTSTP_CUR] = <span class="string">&quot;Software Step (current EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_WATCHPT_LOW] = <span class="string">&quot;Watchpoint (lower EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_WATCHPT_CUR] = <span class="string">&quot;Watchpoint (current EL)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_BKPT32] = <span class="string">&quot;BKPT (AArch32)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_VECTOR32] = <span class="string">&quot;Vector catch (AArch32)&quot;</span>,</span><br><span class="line">    [ESR_ELx_EC_BRK64] = <span class="string">&quot;BRK (AArch64)&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">esr_get_class_string</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> esr)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> esr_class_str[esr &gt;&gt; ESR_ELx_EC_SHIFT];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_esr</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> esr)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ec = ESR_ELx_EC(esr);</span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;ESR info:\n&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;  ESR = 0x%08x\n&quot;</span>, esr);</span><br><span class="line">  printk(<span class="string">&quot;  Exception class = %s, IL = %u bits\n&quot;</span>, esr_get_class_string(esr),</span><br><span class="line">         (esr &amp; ESR_ELx_IL) ? <span class="number">32</span> : <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ec == ESR_ELx_EC_DABT_LOW || ec == ESR_ELx_EC_DABT_CUR) &#123;</span><br><span class="line">    printk(<span class="string">&quot;  Data abort:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((esr &amp; ESR_ELx_ISV)) &#123;</span><br><span class="line">      printk(<span class="string">&quot;  Access size = %u byte(s)\n&quot;</span>,</span><br><span class="line">             <span class="number">1U</span> &lt;&lt; ((esr &amp; ESR_ELx_SAS) &gt;&gt; ESR_ELx_SAS_SHIFT));</span><br><span class="line">      printk(<span class="string">&quot;  SSE = %lu, SRT = %lu\n&quot;</span>,</span><br><span class="line">             (esr &amp; ESR_ELx_SSE) &gt;&gt; ESR_ELx_SSE_SHIFT,</span><br><span class="line">             (esr &amp; ESR_ELx_SRT_MASK) &gt;&gt; ESR_ELx_SRT_SHIFT);</span><br><span class="line">      printk(<span class="string">&quot;  SF = %lu, AR = %lu\n&quot;</span>, (esr &amp; ESR_ELx_SF) &gt;&gt; ESR_ELx_SF_SHIFT,</span><br><span class="line">             (esr &amp; ESR_ELx_AR) &gt;&gt; ESR_ELx_AR_SHIFT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;  SET = %lu, FnV = %lu\n&quot;</span>, (esr &gt;&gt; ESR_ELx_SET_SHIFT) &amp; <span class="number">3</span>,</span><br><span class="line">           (esr &gt;&gt; ESR_ELx_FnV_SHIFT) &amp; <span class="number">1</span>);</span><br><span class="line">    printk(<span class="string">&quot;  EA = %lu, S1PTW = %lu\n&quot;</span>, (esr &gt;&gt; ESR_ELx_EA_SHIFT) &amp; <span class="number">1</span>,</span><br><span class="line">           (esr &gt;&gt; ESR_ELx_S1PTW_SHIFT) &amp; <span class="number">1</span>);</span><br><span class="line">    printk(<span class="string">&quot;  CM = %lu, WnR = %lu\n&quot;</span>, (esr &amp; ESR_ELx_CM) &gt;&gt; ESR_ELx_CM_SHIFT,</span><br><span class="line">           (esr &amp; ESR_ELx_WNR) &gt;&gt; ESR_ELx_WNR_SHIFT);</span><br><span class="line">    printk(<span class="string">&quot;  DFSC = %s\n&quot;</span>, esr_get_dfsc_string(esr));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;Not supported yet\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bad_mode</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">int</span> reason, <span class="type">unsigned</span> <span class="type">int</span> esr)</span> &#123;</span><br><span class="line">  printk(<span class="string">&quot;Bad mode for %s handler detected, far:0x%x esr:0x%x - %s\n&quot;</span>,</span><br><span class="line">         bad_mode_handler[reason], read_sysreg(far_el1), esr,</span><br><span class="line">         esr_get_class_string(esr));</span><br><span class="line"></span><br><span class="line">  parse_esr(esr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">trigger_sync_data_abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">trigger_sync_instruction_alignment</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>触发数据异常的代码：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510161510405.png" alt="触发同步数据异常"></p>]]></content>
      
      
      <categories>
          
          <category> arm64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2598 执行操作后的最大 MEX</title>
      <link href="/posts/2598/"/>
      <url>/posts/2598/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-16</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2598 执行操作后的最大 MEX" href="https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/description/?envType=daily-question&envId=2025-10-16"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2598 执行操作后的最大 MEX</p><p class="url">https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/description/?envType=daily-question&envId=2025-10-16</p></div></a></div></p><h1 id="TLE"><a href="#TLE" class="headerlink" title="TLE"></a>TLE</h1><p>用最小堆存储nums中各个数取绝对值并取value余数的值，然后从最小值开始数，如果最小堆弹出的值和当前数的值相同，那么把它+value后压回栈。重复此过程，直到栈空或者出现不连续的值。但这种方法O(nlogn)会超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cel_div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findSmallestInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先将所有负数变为正数</span></span><br><span class="line"><span class="comment">// 再将所有数变为除以value的余数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> top_value;</span><br><span class="line"><span class="type">int</span> last_value;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt; &gt; min_heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nums[i] += <span class="built_in">cel_div</span>(-nums[i], value) * value;</span><br><span class="line">&#125;</span><br><span class="line">nums[i] = nums[i] % value;</span><br><span class="line">min_heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">last_value = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!min_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">top_value = min_heap.<span class="built_in">top</span>();</span><br><span class="line"><span class="keyword">if</span> (top_value == last_value) &#123;</span><br><span class="line">min_heap.<span class="built_in">pop</span>();</span><br><span class="line">min_heap.<span class="built_in">push</span>(top_value + value);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (top_value != last_value + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">last_value = top_value;</span><br><span class="line">min_heap.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> last_value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">Solution s;</span><br><span class="line">s.<span class="built_in">findSmallestInteger</span>(vec, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数学上优化"><a href="#数学上优化" class="headerlink" title="数学上优化"></a>数学上优化</h1><p>value的余数的所有可能取值为一组，假设有group组value的余数的所有可能取值，那么最终数组最大至少取到$value \times group -1$，从nums中去掉这些组的值，剩下的里面，必定缺少value余数的所有可能取值中的一个，我们找缺少的最小值加上$value \times group -1$即可。编程来看就是统计各个余数的个数，找个数中最小的那个为group，最小的当然不能为0，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cel_div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a + b - <span class="number">1</span>) / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findSmallestInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先将所有负数变为正数</span></span><br><span class="line"><span class="comment">// 再将所有数变为除以value的余数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> group = INT_MAX;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">nums[i] += <span class="built_in">cel_div</span>(-nums[i], value) * value;</span><br><span class="line">&#125;</span><br><span class="line">nums[i] = nums[i] % value;</span><br><span class="line">umap[nums[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; value; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (umap.<span class="built_in">count</span>(i) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[num, count] : umap) &#123;</span><br><span class="line"><span class="keyword">if</span> (count &lt; group) &#123;</span><br><span class="line">group = count;</span><br><span class="line">res = num;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == group) &#123;</span><br><span class="line">res = std::<span class="built_in">min</span>(res, num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res += group * value - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">Solution s;</span><br><span class="line">s.<span class="built_in">findSmallestInteger</span>(vec, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P392 判断子序列</title>
      <link href="/posts/392/"/>
      <url>/posts/392/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-15</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P392 判断子序列" href="https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P392 判断子序列</p><p class="url">https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>双指针分别指向s和t，如果匹配上了就两个指针都向前移动，如果没有匹配上则指向t的指针向前移动，注意空字符串要单独处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 判断s是否为t的子字符串</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s_len = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> t_len = t.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s_len == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s_len &amp;&amp; j &lt; t_len) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == s_len &amp;&amp; s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Solution solution;</span><br><span class="line">string s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">string t = <span class="string">&quot;ahbgdc&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, solution.<span class="built_in">isSubsequence</span>(s, t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>考虑前面的双指针的做法，我们注意到我们有大量的时间用于在 t 中找到下一个匹配字符。这样我们可以预处理出对于 t 的每一个位置，从该位置开始往后每一个字符第一次出现的位置。我们可以使用动态规划的方法实现预处理：</p><p>令$ f[i][j]$ 表示字符串 t 中从位置 i 开始往后字符 j 第一次出现的位置。</p><p>状态转移时：如果 t 中位置 i 的字符就是 j，那么 $f[i][j]=i$，否则 j 出现在位置 i+1 开始往后，即 $f[i][j]=f[i+1][j]$，因此我们需要从后向前构建dp</p><p>状态转移方程是：</p><script type="math/tex; mode=display">f[i][j] =\begin{cases} i, & \text{如果 } t[i] = j \\f[i+1][j], & \text{如果 } t[i] \neq j\end{cases}</script><p>边界条件为：</p><script type="math/tex; mode=display">f[m][j] = m \quad \forall j \in \{0, 1, \dots, 25\}</script><p>其中：</p><ul><li>$i$ 表示字符串 $t$ 中的位置（从 0 开始，0 ≤ i ≤ m）</li><li>$j$ 表示字符的编号（通常 ‘a’ 对应 0，’b’ 对应 1，…，’z’ 对应 25）</li><li>$f[i][j] = m$ 表示从位置 $i$ 开始往后不存在字符 $j$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = t.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// m+1是为了处理边界情况</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">f</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            f[m][i] = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i] == j + <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                    f[i][j] = i;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[add][s[i] - <span class="string">&#x27;a&#x27;</span>] == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            add = f[add][s[i] - <span class="string">&#x27;a&#x27;</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3350 检测相邻递增子数组 II</title>
      <link href="/posts/3350/"/>
      <url>/posts/3350/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-15</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3350 检测相邻递增子数组 II" href="https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/description/?envType=daily-question&envId=2025-10-15"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3350 检测相邻递增子数组 II</p><p class="url">https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/description/?envType=daily-question&envId=2025-10-15</p></div></a></div></p><h1 id="O-n-3-穷举"><a href="#O-n-3-穷举" class="headerlink" title="O(n^3) 穷举"></a><script type="math/tex">O(n^3)</script> 穷举</h1><p>直接穷举，没啥好说的，超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxIncreasingSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// n从2开始</span></span><br><span class="line">    <span class="type">int</span> k = n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> a, b, i;</span><br><span class="line">    <span class="type">int</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      a = <span class="number">0</span>;     <span class="comment">// 0..k-1</span></span><br><span class="line">      b = a + k; <span class="comment">// a+k.. b+k-1</span></span><br><span class="line">      <span class="keyword">while</span> (b + k - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (nums[a + i] &gt; nums[a + i - <span class="number">1</span>] &amp;&amp; nums[b + i] &gt; nums[b + i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a++;</span><br><span class="line">            b = a + k;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">          <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">19</span>, <span class="number">-14</span>, <span class="number">0</span>, <span class="number">9</span>&#125;;</span><br><span class="line">  Solution s;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.<span class="built_in">maxIncreasingSubarrays</span>(vec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="O-n-2-预处理优化"><a href="#O-n-2-预处理优化" class="headerlink" title="O(n^2) 预处理优化"></a><script type="math/tex">O(n^2)</script> 预处理优化</h1><p>我们定义一个数组 inc, inc[i]表示以 nums[i] 结尾的最长递增子数组的长度。a，b 开始的两个数据段相邻且递增必定满足 inc[a + k - 1] &gt;= k &amp;&amp; inc[b + k - 1] &gt;= k。这个也超时了呜呜。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxIncreasingSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// n从2开始</span></span><br><span class="line">    <span class="type">int</span> k = n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inc</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        inc[i] = inc[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line">      b = a + k;</span><br><span class="line">      <span class="keyword">while</span> (b + k - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inc[a + k - <span class="number">1</span>] &gt;= k &amp;&amp; inc[b + k - <span class="number">1</span>] &gt;= k) &#123;</span><br><span class="line">          <span class="keyword">return</span> k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          a++;</span><br><span class="line">          b = a + k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      k--;</span><br><span class="line">      <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a><script type="math/tex">O(n)</script></h1><p>如果我们知道所有严格递增的两个相邻数据段，那么 k 为这两个段的最小值。我们遍历一遍数组，找到 k 的最大值即可。但要注意，我们还需要记录单个严格递增段的长度，因为它也可以拆成两个严格递增的两个相邻数据段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;limits.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 遍历数组，计算所有连续递增段的长度。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxIncreasingSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> curr_len = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// prev_len取0，否则第一次判断时会更新max，即使前面没有数据段</span></span><br><span class="line">    <span class="type">int</span> prev_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max_val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len_max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        curr_len++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        max_val = std::<span class="built_in">max</span>(max_val, std::<span class="built_in">min</span>(curr_len, prev_len));</span><br><span class="line">        len_max = std::<span class="built_in">max</span>(curr_len, len_max);</span><br><span class="line">        prev_len = curr_len;</span><br><span class="line">        curr_len = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后不要忘了更新len_max</span></span><br><span class="line">    len_max = std::<span class="built_in">max</span>(len_max, curr_len);</span><br><span class="line"></span><br><span class="line">    max_val = std::<span class="built_in">max</span>(max_val, std::<span class="built_in">min</span>(curr_len, prev_len));</span><br><span class="line">    max_val = std::<span class="built_in">max</span>(len_max / <span class="number">2</span>, max_val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/posts/50012/"/>
      <url>/posts/50012/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-14</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止docker</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">$ <span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker基本信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker具体命令帮助文档</span></span><br><span class="line">$ <span class="built_in">sudo</span> docker 具体命令 --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地主机上的镜像</span></span><br><span class="line">$ docker images</span><br><span class="line"><span class="comment"># 列出本地所有的镜像(含历史镜像)</span></span><br><span class="line">$ docker images -a</span><br><span class="line"><span class="comment"># 只显示镜像ID</span></span><br><span class="line">$ docker images -q</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索某个镜像的名字</span></span><br><span class="line">$ docker search 镜像名</span><br><span class="line"><span class="comment"># 只列出N个镜像,默认25个</span></span><br><span class="line">$ docker search --<span class="built_in">limit</span> N 镜像名</span><br><span class="line"><span class="comment"># 拉取某个镜像</span></span><br><span class="line">$ docker pull 镜像名</span><br><span class="line"><span class="comment"># 拉去某个镜像并指定版本(tag)</span></span><br><span class="line">$ docker pull 镜像名[:TAG]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看镜像/容器/数据卷所占的空间</span></span><br><span class="line">$ docker system <span class="built_in">df</span></span><br><span class="line"><span class="comment"># 删除镜像单个</span></span><br><span class="line">$ docker rmi 镜像名[:TAG]/镜像<span class="built_in">id</span></span><br><span class="line"><span class="comment"># 删除镜像多个,-f强制删除</span></span><br><span class="line">$ docker rmi -f 镜像名1[:TAG] </span><br><span class="line"><span class="comment"># 删除镜像全部</span></span><br><span class="line">$ docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建+启动容器</span></span><br><span class="line">$ docker run [OPTIONS] IMAGE [COMMAND] [ARG..]</span><br></pre></td></tr></table></figure><p><strong>OPTIONS</strong></p><ul><li>—name=”新容器名称”            为容器指定一个名称</li><li>-d        后台运行容器并返回容器ID,也即启动守护式容器</li><li>-i         以交互模式运行容器，通常与-t同时使用</li><li>-t         为容器重新分配一个伪输入终端，通常与-i同时使用:也即启动交互式容器</li><li>-P        随机端口映射，大写P</li><li>-p hostPort:containerPort        指定端口映射，小写p，如-p 8080:80</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu /bin/bash</span><br><span class="line"><span class="comment"># 这里我们希望有个交互式shell,因此用的是/bin/bash</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有正在运行的容器</span></span><br><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><p><strong>OPTIONS</strong></p><ul><li>-a      列出当前所有正在运行的容器+历史上运行过的</li><li>-l      显示最近创建的容器</li><li>-n     显示最近n个创建的容器</li><li>-q      静默模式，只显示容器编号</li></ul><h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><ol><li>run进入容器，exit退出，<strong>容器停止</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ol><li>run进入容器，ctrl+p+q退出<strong>,容器不停止</strong></li></ol><h4 id="启动已经停止运行的容器"><a href="#启动已经停止运行的容器" class="headerlink" title="启动已经停止运行的容器*"></a>启动已经停止运行的容器*</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start 容器ID或者容器名</span><br></pre></td></tr></table></figure><h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop 容器ID或容器名</span><br></pre></td></tr></table></figure><h4 id="强制停止容器"><a href="#强制停止容器" class="headerlink" title="强制停止容器"></a>强制停止容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">kill</span> 容器ID或容器名</span><br></pre></td></tr></table></figure><h4 id="删除已经停止的容器"><a href="#删除已经停止的容器" class="headerlink" title="删除已经停止的容器"></a>删除已经停止的容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span> 容器ID或容器名</span><br></pre></td></tr></table></figure><p>需要删除未停止的容器需要加上参数-f</p><p><strong>一次性删除多个容器实例 danger!</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">rm</span> -f $(docker ps -a -q)</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">$ docker ps -a -q | xargs docker <span class="built_in">rm</span></span><br></pre></td></tr></table></figure><h4 id="一些重要问题"><a href="#一些重要问题" class="headerlink" title="一些重要问题"></a>一些重要问题</h4><p>启动守护式容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu</span><br></pre></td></tr></table></figure><p>问题：然后使用docker ps -a查看发现容器已经退出，原因是<br><strong>docker容器后台运行，就必须有一个前台进程</strong>，容器运行的命令如果不是那些一直挂起的命令，就会自动退出<br>因此有些镜像-d参数是不起作用的，使用-it运行一个交互式的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis:6.0.8</span><br><span class="line">$ docker run -d redis:6.0.8</span><br></pre></td></tr></table></figure><h4 id="查看某个容器的日志"><a href="#查看某个容器的日志" class="headerlink" title="查看某个容器的日志"></a>查看某个容器的日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs 容器ID</span><br></pre></td></tr></table></figure><h4 id="查看容器内运行的进程"><a href="#查看容器内运行的进程" class="headerlink" title="查看容器内运行的进程"></a>查看容器内运行的进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker top 容器ID</span><br></pre></td></tr></table></figure><h4 id="查看容器内部细节"><a href="#查看容器内部细节" class="headerlink" title="查看容器内部细节"></a>查看容器内部细节</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect 容器<span class="built_in">id</span></span><br></pre></td></tr></table></figure><h4 id="进入正在运行的容器并以命令行交互"><a href="#进入正在运行的容器并以命令行交互" class="headerlink" title="进入正在运行的容器并以命令行交互"></a>进入正在运行的容器并以命令行交互</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入正在运行的容器并以命令行交互</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it 容器ID /bin/bash</span><br><span class="line"><span class="comment"># 重新进入</span></span><br><span class="line">$ docker attach 容器ID</span><br></pre></td></tr></table></figure><p><strong>区别</strong></p><ul><li>attach 直接进入容器启动命令的终端，不会启动新的进程，用exit退出，会直接导致容器停止</li><li>exec 是在容器中直接打开新的终端，并且可以启动新的进程，用exit退出，不会导致容器的停止</li></ul><p>因此一般来说我们会先使用docker run -d然后使用docker exec -it</p><h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">cp</span> 容器ID:容器内路径 目的主机路径</span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">$ docker <span class="built_in">cp</span> ddd1abihiin87:/tmp/a.txt ~/Desktop</span><br></pre></td></tr></table></figure><h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># export 导出容器的内容流作为一个tar归档文件</span></span><br><span class="line">$ docker <span class="built_in">export</span> 容器ID &gt; abc.tar</span><br><span class="line"><span class="comment"># export 从tar包中的内容创建一个新的文件系统再导入为镜像</span></span><br><span class="line">$ <span class="built_in">cat</span> abc.tar | docker import - 镜像用户/镜像名:镜像版本号</span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">$ <span class="built_in">cat</span> abc.tar | docker import - atguigu/ubuntu3.7</span><br></pre></td></tr></table></figure><h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h4 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h4><p>docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统UnionFS</p><h4 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS(联合文件系统)"></a>UnionFS(联合文件系统)</h4><p>Union文件系统(UnionFS)是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层一层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像(没有父镜像),可以制作各种具体的应用镜像</p><h4 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h4><ul><li>bootfs(boot file system)主要包含bootloader和kernel<br>bootloader主要是加载kernel,Linux刚启动时会加载bootfs文件系统,在Docker镜像的最底层是引导文件系统bootfs.这一层与我们典型的Linux/Unix文件系统是一样的,包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核,此时系统也会卸载bootfs.</li><li>rootfs(root file system)<br>在bootfs之上。包含的就是典型Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件.rootfs就是各种不同操作系统的发行版，比如Ubuntu,CentOS等</li></ul><p>对于一个精简的OS,rootfs可以很小,只需要包括最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel,自己只需要提供rootfs就行了。由此可见对于不同的Linux发行版,bootfs基本上是一致的,rootfs会有差别，因此不同的发行版可以公用bootfs</p><p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用</p><p>比如说有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像:同时内存中也只需加载一份base镜像,就可以为所有容器服务.而且镜像的每一层都可以被共享。</p><h4 id="重点理解"><a href="#重点理解" class="headerlink" title="重点理解"></a>重点理解</h4><p>Docker的镜像层都是只读的，容器层是可写的<br>当容器启动时，一个新的科协曾被加载到镜像的顶部，这一层通常被称作”容器层”,容器层之下的都叫做镜像层</p><h4 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h4><p>docker commit 提交容器副本使之成为一个新的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$  docker commit -m=<span class="string">&quot;提交的描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器ID 要创建的目标镜像名:[标签名]</span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">$ docker commit -m=<span class="string">&quot;vim add ok&quot;</span> -a=<span class="string">&quot;zhaohang&quot;</span> fcbfaingngi5 hnu/myubuntu:1.3</span><br></pre></td></tr></table></figure><p>之后可以发布镜像到dockerhub或者阿里云(共有库),也可以发布到私有库(相当于gitlab与github的关系)</p><p><a href="https://cn.bing.com/search?q=doker如何构建私有Hub&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;lq=0&amp;pq=doker如何构建私有hub&amp;sc=0-14&amp;sk=&amp;cvid=3005BB22809F420AA7DF1C31A5A20ABA&amp;ghsh=0&amp;ghacc=0&amp;ghpl=">https://cn.bing.com/search?q=doker如何构建私有Hub&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;lq=0&amp;pq=doker如何构建私有hub&amp;sc=0-14&amp;sk=&amp;cvid=3005BB22809F420AA7DF1C31A5A20ABA&amp;ghsh=0&amp;ghacc=0&amp;ghpl=</a></p><h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><p>docker 挂载主机目录访问如果出现cannot open directory: Permisssion denied，要在挂载目录后多加一个—privileged=true参数即可<br>使用该参数,container内的root拥有真正的root权限,否则，container内的root只是外部的一个普通用户权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录 镜像名/镜像ID</span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">$ docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry --privileged=<span class="literal">true</span> registry</span><br></pre></td></tr></table></figure><p>默认情况下，仓库被创建在容器的/var/lib/registry目录下,建议自行用容器卷映射，方便宿主机联调</p><p>卷就是目录或文件存在于一个或多个容器中,由docker挂载到容器,但不属于联合文件系统，因此能够绕过Union File System提供一些用户持续存储或共享数据的特征。</p><p>卷的设计目的就是<strong>数据的持久化</strong>,完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂在的数据卷。</p><p>注意：容器卷的更改不会包含在镜像的更新中,数据卷的生命周期一直持续到没有容器使用它为止。</p><p>一些例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --privileged=<span class="literal">true</span> -v /tmp/host_data:/tmp/docker_data --name=u1 ubuntu</span><br></pre></td></tr></table></figure><h3 id="读写规则映射添加说明"><a href="#读写规则映射添加说明" class="headerlink" title="读写规则映射添加说明"></a>读写规则映射添加说明</h3><p><strong>只读权限，容器实例内部被限制，只能读不能写</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --privileged=<span class="literal">true</span> -v 宿主机绝对路径目录:容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure><p><strong>卷的继承和共享</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --privileged=<span class="literal">true</span> --volumes-from u1 --name u2 ubuntu</span><br><span class="line">$ docker run -it --privileged=<span class="literal">true</span> --volumes-from=u1 --name=u2 ubuntu</span><br></pre></td></tr></table></figure><p>如果volumes-from的主机没了，该主机还是挂载的父主机的卷</p><h2 id="Docker常规安装简介"><a href="#Docker常规安装简介" class="headerlink" title="Docker常规安装简介"></a>Docker常规安装简介</h2><p>docker拉去某些软件可能会出一些问题，比如mysql字符集配置</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:8.0.20</span><br><span class="line">$ docker run -d -p 3306:3306 --privileged=<span class="literal">true</span> -v /root/mysql/log:/var/log/mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql:8.0.20</span><br><span class="line">$ <span class="built_in">cd</span> /root/mysql/conf</span><br><span class="line">$ <span class="built_in">touch</span> my.cnf</span><br><span class="line">$ vim my.cnf</span><br></pre></td></tr></table></figure><p>mysql配置(貌似8.0以上不用配置也行)</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">default_character_set</span>=utf8</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">collation_server</span> = utf8_general_ci</span><br><span class="line"><span class="attr">character_set_server</span> = utf8</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker restart mysql</span><br><span class="line">$ docker <span class="built_in">exec</span> -it mysql /bin/bash</span><br><span class="line">$ mysql -uroot -p</span><br><span class="line">$ SHOW VARIABLES LIKE <span class="string">&#x27;character%&#x27;</span></span><br></pre></td></tr></table></figure><p>挂载卷后数据持久化</p><h3 id="redis集群配置-扩容-缩容等"><a href="#redis集群配置-扩容-缩容等" class="headerlink" title="redis集群配置,扩容,缩容等"></a>redis集群配置,扩容,缩容等</h3><p>redis还没有系统性地学习<br>…</p><h2 id="Docker-File解析"><a href="#Docker-File解析" class="headerlink" title="Docker File解析"></a>Docker File解析</h2><h3 id="Docker-File是什么"><a href="#Docker-File是什么" class="headerlink" title="Docker File是什么"></a>Docker File是什么</h3><p>Dockerfile是用来构建Docker镜像的文本文件,是由一条条构建镜像所需的指令和参数构成的脚本。</p><h3 id="Docker-File-内容基础知识"><a href="#Docker-File-内容基础知识" class="headerlink" title="Docker File 内容基础知识"></a>Docker File 内容基础知识</h3><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ol><h3 id="Docker执行DockerFile的大致流程"><a href="#Docker执行DockerFile的大致流程" class="headerlink" title="Docker执行DockerFile的大致流程"></a>Docker执行DockerFile的大致流程</h3><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器做出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新的容器</li><li>执行dockerfile中的下一条指令知道所有指令都完成</li></ol><h3 id="Docker-File保留字"><a href="#Docker-File保留字" class="headerlink" title="Docker File保留字"></a>Docker File保留字</h3><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>基础镜像，当前镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是from</p><h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><p>镜像维护者的姓名和邮箱地址</p><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>容器构建时所需要运行的命令<br>两种格式:shell格式和exec格式<br>RUN是在docker build时运行</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>当前容器对外暴露出的端口</p><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定在创建容器后，终端默认登陆进来的工作目录，一个落脚点</p><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>指定该镜像以什么样的用户去执行，如果都不指定，默认是root</p><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>用来构建镜像过程中设置的环境变量</p><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>将宿主机目录下的文件拷贝进镜像切回自动处理URL和解压tar压缩包</p><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>类似ADD,拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;<br>COPY src dest<br>COPY [“src”,”dest”]</p><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>容器数据卷，用于数据保存和持久化工作</p><p><strong>volume和run -v的区别，什么时候需要使用volume</strong></p><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><p>那么Dockerfile中的VOLUME指令实际使用中是不是就是跟docker run中的-v参数一样是将宿主机的一个目录绑定到容器中的目录以达到共享目录的作用呢？</p><p>并不然，其实<strong>VOLUME指令只是起到了声明了容器中的目录作为匿名卷，但是并没有将匿名卷绑定到宿主机指定目录的功能</strong>。</p><p>当我们生成镜像的Dockerfile中以Volume声明了匿名卷，并且我们以这个镜像run了一个容器的时候，docker会在安装目录下的指定目录下面生成一个目录来绑定容器的匿名卷（这个指定目录不同版本的docker会有所不同），我当前的目录为：/var/lib/docker/volumes/{容器ID}。</p><p><strong>总结</strong>： volume只是指定了一个目录，用以在用户忘记启动时指定-v参数也可以保证容器的正常运行。比如mysql，你不能说用户启动时没有指定-v，然后删了容器，就把mysql的数据文件都删了，那样生产上是会出大事故的，所以mysql的dockerfile里面就需要配置volume，这样即使用户没有指定-v，容器被删后也不会导致数据文件都不在了。还是可以恢复的。</p><p><strong>volume指定的位置在容器被删除以后数据文件会被删除吗</strong></p><p>volume与-v指令一样，容器被删除以后映射在主机上的文件不会被删除。</p><p><strong>如果-v和volume指定了不同的位置，会发生什么事呢？</strong></p><p>会以-v设定的目录为准，其实volume指令的设定的目的就是为了避免用户忘记指定-v的时候导致的数据丢失，那么如果用户指定了-v，自然而然就不需要volume指定的位置了。</p><p>其实一般的dockfile如果不是数据库类的这种需要持久化数据到磁盘上的应用，都是无需指定volume的。指定volume只是为了避免用户忘记指定-v时导致的数据全部在容器中，这样的话容器一旦被删除所有的数据都丢失了。</p><p><strong>那么为什么dockerfile中不提供一个能够映射为主机目录:容器目录这样的指令呢？</strong>其实这样的设计是有道理的，如果在dockerfile中指定了主机目录，这样dockerfile就不具备了可移植性了，毕竟每个人所需要映射的目录可能是不同的，那么最好的办法就是把这个权利交给每个运行这个dockerfile的人，所以才会有 run -v 主机目录:容器目录 这样的指令。</p><p>————————————————</p><p>版权声明：本文为CSDN博主「诺浅」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：<a href="https://blog.csdn.net/qq32933432/article/details/120944205">https://blog.csdn.net/qq32933432/article/details/120944205</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create edc-nginx-vol // 创建一个自定义容器卷</span><br><span class="line">$ docker volume <span class="built_in">ls</span> // 查看所有容器卷</span><br><span class="line">$ docker volume inspect edc-nginx-vol // 查看指定容器卷详情信息</span><br><span class="line">$ docker volume <span class="built_in">rm</span> edc-nginx-vol // 删除自定义数据卷</span><br></pre></td></tr></table></figure><p><strong>docker volume命令</strong></p><p><a href="https://blog.csdn.net/lihongbao80/article/details/122812274">https://blog.csdn.net/lihongbao80/article/details/122812274</a></p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><ul><li>指定容器启动后要干的事情<br>和RUN类似也是shell和exec两种格式</li><li>Dockerfile中可以由多个CMD指令,但只有最后一个生效,CMD会被docker run之后的参数替换</li></ul><p>例子:<br>tomacat 的Dockerfile中：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;catalina.sh&quot;</span>,<span class="string">&quot;run&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>如果我们这样启动tomcat:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -p 8080:8080 57800e5b1cbf /bin/bash</span><br></pre></td></tr></table></figure><p>/bin/bash这个参数会覆盖CMD参数,从而导致无法tomacat没有正常启动</p><ul><li>和RUN的区别</li><li>run 是在 docker build 构建镜像时, 会执行的命令</li><li>cmd 是在 docker run 启动容器时, 会执行的命令</li></ul><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>也是用来指定一个容器启动时要运行的命令,类似于CMD命令但是<strong>ENTRYPOINT</strong>不会被docker run后面的命令覆盖，而且这些命令行参数会被当做参数送给<strong>ENTRYPOINT</strong>指令的程序</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>,<span class="string">&quot;-c&quot;</span>] <span class="comment"># 定参</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="comment"># 变参</span></span></span><br></pre></td></tr></table></figure><p>按照dockerfile编写执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run nginx:<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 实际衍生出的命令</span></span><br><span class="line">$ nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>主动传参运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run nginx:<span class="built_in">test</span> -c /etc/nginx/new.conf</span><br><span class="line"><span class="comment"># 实际衍生出命令</span></span><br><span class="line">$ nginx -c /ect/nginx/new.conf</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="自定义镜像centosjava8"><a href="#自定义镜像centosjava8" class="headerlink" title="自定义镜像centosjava8"></a>自定义镜像centosjava8</h4><p>要求:Centos7镜像具备vim+ifconfig+jdk8</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> zhaohang&lt;zhaohang15639535703.proton.me&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="comment"># 安装vim编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="comment"># 安装ifconfig命令查看网络ip</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span></span><br><span class="line"><span class="comment"># 安装java8及lib库</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install glibc.i686</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /usr/local/java</span></span><br><span class="line"><span class="comment"># ADD 是相对路径jar，把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置,它会自动解压</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u171-linux-x64.tar.gz /usr/local/java/</span></span><br><span class="line"><span class="comment"># 配置java环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_171</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $JAVA_HOME/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line"><span class="keyword">ENV</span> PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;success-----------ok&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><ul><li>构建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t 新镜像名字:TAG .</span><br></pre></td></tr></table></figure><p>(注意后面有个.)</p><h4 id="虚悬镜像-dangling-image"><a href="#虚悬镜像-dangling-image" class="headerlink" title="虚悬镜像(dangling image)"></a>虚悬镜像(dangling image)</h4><ul><li>是什么<br>仓库名,标签都是的镜像,可能是Dockerfile编写的问题或者docker在构建出了问题导致</li><li>查看所有的虚悬镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> -f dangling=<span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>删除虚悬镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune</span><br></pre></td></tr></table></figure><h2 id="Docker微服务实战"><a href="#Docker微服务实战" class="headerlink" title="Docker微服务实战"></a>Docker微服务实战</h2><ol><li>通过IDEA新建一个普通微服务模块</li><li>通过Dockerfile发布微服务部署到docker容器</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> zhaohang&lt;zhaohang15639535703.proton.me&gt;</span><br><span class="line"><span class="comment"># VOLUME指定临时文件目录为/tmp,在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /tmp</span></span><br><span class="line"><span class="comment"># 将jar包添加到容器中并更名为zzyy_docker.jar</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> docker_boot-0.0.1-SNAPSHOT.jar zzyy_docker.jar</span></span><br><span class="line"><span class="comment"># 运行jar包</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bash -c <span class="string">&#x27;touch /zzyy_docker.jar&#x27;</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/zzyy_docker.jar&quot;</span>]</span></span><br><span class="line"><span class="comment">#暴露端口6001端口作为微服务</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">6001</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure><h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><p>启动docker后会产生一个名为docker0的虚拟网桥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看docker所有网络</span></span><br><span class="line">$ docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 创建一个网络</span></span><br><span class="line">$ docker network create aa_network</span><br><span class="line"><span class="comment"># 删除一个网络</span></span><br><span class="line">$ docker network <span class="built_in">rm</span> aa_network</span><br><span class="line"><span class="comment"># 查看网络源数据</span></span><br><span class="line">$ docker network inspect bridge</span><br></pre></td></tr></table></figure><p>docker默认创建的3大网络模式:</p><ul><li>bridge</li><li>host</li><li>none</li></ul><p>docker的5大网络模式:</p><ul><li>bridge<br>为每一个容器分配,设置IP等,并将容器连接到一个docker0<br>虚拟网桥，默认为该模式<br>使用—network bridge指定,默认使用docker0</li><li>host<br>容器将不会虚拟出自己的网卡,培植自己的IP等,二十使用宿主机的IP和端口<br>使用—network host指定</li><li>none<br>容器有独立的Network namespace,但没有对其进行任何网络设置,如分配veth pair和网桥连接,IP等<br>使用—network none指定</li><li>container<br>新创建的容器不会创建自己的网卡和配置自己的IP,而是和一个指定的容器共享IP,端口范围<br>使用—network container:NAME或容器ID</li><li>…</li></ul><p>docker网络能干什么:</p><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li></ul><p>网桥docker0创建一对对等虚拟设备接口,一个叫veth，另一个叫eth0，成对匹配</p><p><strong>host模式下使用和主机相同的网段</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 警告</span></span><br><span class="line">$ docker run -d -p 8083:8080 --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br><span class="line"><span class="comment"># 正确</span></span><br><span class="line">$ docker run -d --network host --name tomcat83 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>如果使用host模式，端口号会以主机端口号为主，重复时则递增</p><p><strong>none模式</strong>:<br>该模式下,并不为Docker容器进行任何网络配置<br>也就是说，这个Docker容器没有网卡,IP,路由等信息,只有一个Io<br>需要我们自己为Docker容器添加网卡,配置IP等</p><p><strong>container模式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8085:8080 --name tomcat85 billygoo/tomcat8-jdk8</span><br><span class="line"><span class="comment"># 下面运行这条命令会报错</span></span><br><span class="line">$ docker run -d -p 8086:8080 --network container:tomcat85 --name tomcat86 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>相当于tomcat86和tomcat85公用同一个ip同一个端口,导致端口冲突,因为tomcat需要端口8080，因此这种情况下container模式不太适合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --name=alpine1 alpine /bin/sh</span><br><span class="line">$ docker run -it --network container:alpine1 --name=alpine2 alpine /bin/sh</span><br><span class="line"><span class="comment"># 进入到容器,查看网络</span></span><br><span class="line">$ ip addr</span><br></pre></td></tr></table></figure><p>如果关闭了alpine1,alpine2的网络就没有了</p><p><strong>自定义网络案例</strong></p><ol><li>自定义桥接网络，自定网络默认使用的是桥接网络bridge</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create zzyy_network</span><br></pre></td></tr></table></figure><ol><li>新建自定义网络</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8081:8080 --network zzyy_network --name tomcat81 billygoo/tomcat8-jdk</span><br><span class="line">$ docker run -d -p 8082:8080 --network zzyy_network --name tomcat82 billygoo/tomcat8-jdk</span><br><span class="line">$ docker <span class="built_in">exec</span> -it tomcat81 bash</span><br><span class="line">$ ip addr</span><br><span class="line">$ ping tomcat82</span><br><span class="line">$ <span class="built_in">exit</span></span><br><span class="line">$ docker <span class="built_in">exec</span> -it tomcat82 bash</span><br><span class="line">$ ip addr</span><br><span class="line">$ ping tomcat81</span><br><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ol><li>新建容器加入上一步新建的自定义网络</li><li>互相ping测试</li></ol><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>Compose是Docker公司推出的一个工具软件，可以管理多个Docker容器组成一个应用。需要定义一个YAML格式的配置文件<strong>docker-compose.yml，</strong>写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器。</p><h3 id="compose核心概念"><a href="#compose核心概念" class="headerlink" title="compose核心概念"></a>compose核心概念</h3><ul><li>一文件</li></ul><p>docker-compose.yml</p><ul><li>两要素</li></ul><ol><li>服务(serivce)</li></ol><p>一个个应用容器实例，比如订单微服务，库存微服务，mysql容器，nginx容器或者redis容器</p><ol><li>工程(project)</li></ol><p>由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义</p><h3 id="compose使用的3个步骤"><a href="#compose使用的3个步骤" class="headerlink" title="compose使用的3个步骤"></a>compose使用的3个步骤</h3><ol><li>编写Dockerfile定义各个微服务应用并且构建出对应的镜像文件</li><li>使用docker-compose.yml定义一个完整业务单元，安排好整体应用中的各个容器服务</li><li>最后，执行docker-comose up命令，来启动并运行整个应用程序，完成一键部署上线</li></ol><h3 id="compose常用命令"><a href="#compose常用命令" class="headerlink" title="compose常用命令"></a>compose常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -h <span class="comment">#查看帮助</span></span><br><span class="line">$ docker-compose up <span class="comment">#启动所有docker-compose服务</span></span><br><span class="line">$ docker-compose up -d <span class="comment">#启动所有的docker-compose服务并且后台运行</span></span><br><span class="line">$ docker-compose down <span class="comment">#停止并且删除容器,网络,卷,镜像</span></span><br><span class="line">$ docker-compose <span class="built_in">exec</span> yml里面的服务<span class="built_in">id</span> <span class="comment"># 进入容器实例内部 docker-compose exec docker-compose.yml文件中的服务id /bin/bash</span></span><br><span class="line">$ docker-compose ps <span class="comment">#展示当前docker-compose编排过的运行的所有容器</span></span><br><span class="line">$ docker-compose top <span class="comment">#展示当前docker-compose编排过的容器进程</span></span><br><span class="line">$ docker-compose logs yml里面的服务<span class="built_in">id</span> <span class="comment">#查看容器输出日志</span></span><br><span class="line">$ docker-compose config <span class="comment">#检查配置</span></span><br><span class="line">$ docker-compose config -q <span class="comment">#检查配置，有问题才有输出</span></span><br><span class="line">$ docker-compose restart <span class="comment">#重启服务</span></span><br><span class="line">$ docker-comopse start <span class="comment">#启动服务</span></span><br><span class="line">$ docker-compose stop <span class="comment">#停止服务</span></span><br></pre></td></tr></table></figure><h3 id="compose编排微服务"><a href="#compose编排微服务" class="headerlink" title="compose编排微服务"></a>compose编排微服务</h3><ol><li>编写docker-compose.yml</li></ol><p>contianer_name设定容器名称</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">microService:</span></span><br><span class="line">  <span class="attr">image: zzyy_docker:</span> <span class="number">1.6</span></span><br><span class="line">    <span class="attr">contianer_name:</span> <span class="string">ms01</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="string">-&quot;6001:6001&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/microService:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">redis:6.0.8</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/app/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/app/redis/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">mysql:</span> </span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">&#x27;no&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;db2021&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;zzyy&#x27;</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;zzyy123&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/mysql/db:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/mysql/conf/my.cnf:/etc/mysql/conf.d/my.cnf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/mysql/init:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authentication-plugin=mysql_native_password</span> <span class="comment">#解决外部无法访问</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">atguigu_net:</span></span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>2.修改application.yml中固定写死的ip换成docker服务名</p><p>比如:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://mysql:3306/db2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br></pre></td></tr></table></figure><ol><li>编写Dockerfile将打包好的jar包放到Dockerfile同级目录下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t zzyy_docker:1.6 .</span><br></pre></td></tr></table></figure><ol><li>使用docker-compose</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查yaml文件的语法</span></span><br><span class="line">$ docker-compose config -q</span><br><span class="line"><span class="comment"># 执行,-d表示后台运行</span></span><br><span class="line">$ docker-compose up -d</span><br></pre></td></tr></table></figure><p>运行完成后检查network</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker network <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>发现其网络名加了前缀后缀,服务名也加了前缀和后缀</p><h2 id="Docker轻量级可视化工具Portainer"><a href="#Docker轻量级可视化工具Portainer" class="headerlink" title="Docker轻量级可视化工具Portainer"></a>Docker轻量级可视化工具Portainer</h2><p><a href="https://www.portainer.io/">https://www.portainer.io/</a></p><h2 id="Docker容器监控之CAdvisor-InfluxDB-Granfana-CIG"><a href="#Docker容器监控之CAdvisor-InfluxDB-Granfana-CIG" class="headerlink" title="Docker容器监控之CAdvisor+InfluxDB+Granfana(CIG)"></a>Docker容器监控之CAdvisor+InfluxDB+Granfana(CIG)</h2><h3 id="原生命令"><a href="#原生命令" class="headerlink" title="原生命令"></a>原生命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stats</span><br></pre></td></tr></table></figure><p>可以很方便的看到当前宿主机上所有的容器的CPU，内存以及网络流量等数据，但是docker stats统计结果只能是当前宿主机的全部容器,数据资料是实时的,没有地方存储,没有健康指标过线预警功能</p><h3 id="CAdvisor监控收集-InfluxDB存储数据-Granfana展示图表"><a href="#CAdvisor监控收集-InfluxDB存储数据-Granfana展示图表" class="headerlink" title="CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表"></a>CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表</h3><ol><li>CAdvisor</li></ol><p>CAdvisor是一个容器资源监控工具，包括容器的内存,CPU,网络IO,磁盘IO等监控，同时提供了一个WEB页面用于查看容器的实时运行状态。CAvisor默认存储2分钟的数据，而且只是针对单物理机。不过CAdivisor提供了很多数据集成的接口,支持InfluxDB,Redis,Kafka等集成,可以加上对应配置将监控数据发往这些数据库存储起来</p><p>CAdvisor功能主要有两点:</p><ul><li>展示Host和容器的两个层次的监控数据</li><li>展示历史变化数据</li></ul><ol><li>InfluxDB</li></ol><p>InfluxDB是用Go语言编写的一个开源分布式时序，事件和指标数据库，无需外部依赖。CAdivisor本身已经提供了InfluxDB的集成方法，在启动容器时指定配置即可</p><p>InfluxDB的主要功能:</p><ul><li>基于时间序列，支持与事件有关的相关函数(如最大,最小,求和等)</li><li>可度量性: 你可以实时对大量数据进行计算</li><li>基于事件: 它支持任意的事件数据</li></ul><ol><li>Granfana</li></ol><p>Granfana是一个开源的数据架空分析可视化平台,支持多种数据源配置(支持的数据源包括InfluxDB,MYSQL,Elasticsearch,OpenTSDB,Graphite等)和丰富的插件以及模板功能,支持图表权限控制和警报</p><p>Granfana主要特性:</p><ul><li>灵活丰富的图形化选项</li><li>可以混合多种风格</li><li>支持白天和黑夜模式</li><li>多个数据源</li></ul><p>三件套容器编排</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.1&#x27;</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">grafana_data:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">influxdb:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">image:</span> <span class="string">tutum/influxdb:0.9</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PRE_CREATE_DB=cadvisor</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8083:8083&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8086:8086&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./data/influxdb:/data</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="attr">cadvisor:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">image:</span> <span class="string">google/cadvisor</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">links:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">influxdb:influxsrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">command:</span> <span class="string">-storage_driver=influxdb</span> <span class="string">-storage_driver_db=cadvisor</span> <span class="string">-storage_driver_host=influxsrv:8086</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/:/rootfs:ro</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run:/var/run:rw</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/sys:/sys:ro</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="attr">grafana:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">user:</span> <span class="string">&quot;104&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">user:</span> <span class="string">&quot;104&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">links:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">influxdb:influxsrv</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">grafana_data:/var/lib/grafana</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">HTTP_USER=admin</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">HTTP_PASS=admin</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_HOST=influxsrv</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_PORT=8086</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_NAME=cadvisor</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_USER=root</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="string">INFLUXDB_PASS=root</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes</title>
      <link href="/posts/50011/"/>
      <url>/posts/50011/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-14</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h2 id="Kubernetes-简述和特性"><a href="#Kubernetes-简述和特性" class="headerlink" title="Kubernetes 简述和特性"></a>Kubernetes 简述和特性</h2><h3 id="k8s-简述"><a href="#k8s-简述" class="headerlink" title="k8s 简述"></a>k8s 简述</h3><ul><li>k8s 是谷歌在 2014 年开源的容器化集群管理系统</li><li>使用 k8s 进行容器化应用部署</li><li>使用 k8s 利于应用扩展</li><li>k8s 目标是是让部署容器化应用更简洁和高效</li></ul><h3 id="k8s-功能"><a href="#k8s-功能" class="headerlink" title="k8s 功能"></a>k8s 功能</h3><ol><li>自动装箱</li><li>自动修复(自愈能力)</li><li>水平扩展</li><li>服务发现</li><li>滚动更新</li><li>版本回退</li><li>密钥和配置管理(类似热部署)</li><li>存储编排</li><li>批处理</li></ol><h3 id="k8s-集群架构组件"><a href="#k8s-集群架构组件" class="headerlink" title="k8s 集群架构组件"></a>k8s 集群架构组件</h3><p>Master(主控节点)和 Node(工作节点)</p><p>(1) master 组件</p><ul><li>apiserver</li></ul><p>集群统一入口，以 restful 方式，交给 etcd 存储</p><ul><li>scheduler</li></ul><p>节点调度，选择 node 节点应用部署</p><ul><li>controller-manager</li></ul><p>处理集群中常规后台任务，一个资源对应一个控制器</p><ul><li>etcd</li></ul><p>存储系统,用于保存集群相关的数据</p><p>(2) node 组件</p><ul><li>kubeelet</li></ul><p>master 派到 node 节点的代表，管理本机容器</p><ul><li>kube-proxy</li></ul><p>提供网络代理，实现负载均衡等操作</p><h3 id="k8s-核心概念"><a href="#k8s-核心概念" class="headerlink" title="k8s 核心概念"></a>k8s 核心概念</h3><ol><li>Pod</li></ol><ul><li>最小部署单元</li><li>一组容器的集合</li><li>共享网络</li><li>生命周期是短暂的</li></ul><ol><li>Controller</li></ol><ul><li>确保预期的 pod 副本数量</li><li>无状态应用部署</li><li>有状态应用部署</li><li>确保所有的 node 运行同一个 pod</li><li>一次性任务和定时任务</li></ul><ol><li>Service</li></ol><ul><li><p>定义一组 pod 的访问规则</p></li><li><p><strong>Master（主节点）：</strong> 控制 Kubernetes 节点的机器，也是创建作业任务的地方。</p></li><li><strong>Node（节点）：</strong> 这些机器在 Kubernetes 主节点的控制下执行被分配的任务。</li><li><strong>Pod：</strong> 由一个或多个容器构成的集合，作为一个整体被部署到一个单一节点。同一个 pod 中的容器共享 IP 地址、进程间通讯（IPC）、主机名以及其它资源。Pod 将底层容器的网络和存储抽象出来，使得集群内的容器迁移更为便捷。</li><li><strong>Replication controller（复制控制器）：</strong> 控制一个 pod 在集群上运行的实例数量。</li><li><strong>Service（服务）：</strong> 将服务内容与具体的 pod 分离。Kubernetes 服务代理负责自动将服务请求分发到正确的 pod 处，不管 pod 移动到集群中的什么位置，甚至可以被替换掉。</li><li><strong>Kubelet：</strong> 这个守护进程运行在各个工作节点上，负责获取容器列表，保证被声明的容器已经启动并且正常运行。</li><li><strong>kubectl：</strong> 这是 Kubernetes 的命令行配置工具</li></ul><h3 id="k8s-集群搭建"><a href="#k8s-集群搭建" class="headerlink" title="k8s 集群搭建"></a>k8s 集群搭建</h3><ol><li>搭建环境平台规划</li></ol><ul><li>单 master 集群</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141437106.png" alt="单master集群"></p><p>缺点:master 挂掉就寄了</p><ul><li>多 master 集群</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141437499.png" alt="多master集群"></p><p>高可用的集群</p><ol><li>服务器硬件配置要求</li></ol><ul><li>测试环境：</li></ul><p>master: 2 核 4G 20G</p><p>node: 4 核 8G 40G</p><ul><li>生产环境：</li></ul><p>更高要求</p><ol><li>搭建 k8s 集群部署方式</li></ol><ul><li>kubeadm</li></ul><p>一个 k8s 部署工具，提供 kubeadmin init 和 kubeadm josin，用于快速部署 kubernetes 集群</p><ul><li>二进制包</li></ul><p>从 github 下载发行版二进制包，各个组件要单独部署</p><h4 id="kubeadm-方式搭建"><a href="#kubeadm-方式搭建" class="headerlink" title="kubeadm 方式搭建"></a>kubeadm 方式搭建</h4><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置服务器hostname</span></span><br><span class="line">$ hostnamectl set-hostname &lt;hostname&gt;</span><br><span class="line">$ yum install -y kubelet-1.18.0 kubeadm-1.18.0 kubectl-1.18.0</span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">$ systemctl <span class="built_in">enable</span> kebelet</span><br><span class="line"><span class="comment"># 部署Kubernetes Master,在master节点上执行</span></span><br><span class="line"><span class="comment"># 由于默认拉取镜像地址 k8s.gcr.io 国内无法访问，这里指定阿里云镜像仓库地址</span></span><br><span class="line">$ kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.31.61 \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.17.0 \</span><br><span class="line">--service-cidr=10.96.0.0/12 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16</span><br><span class="line"><span class="comment"># 使用 kubectl 工具</span></span><br><span class="line">$ <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"><span class="comment"># 查看目前的节点</span></span><br><span class="line">$ kubectl get nodes</span><br><span class="line"><span class="comment"># 加入 Kubernetes Node</span></span><br><span class="line"><span class="comment"># 在 192.168.31.62/63（Node节点而不是master节点）执行</span></span><br><span class="line"><span class="comment"># 向集群添加新节点，执行在 kubeadm init 输出的 kubeadm join 命令</span></span><br><span class="line">$ kubeadm <span class="built_in">join</span> 192.168.31.61:6443 --token esce21.q6hetwm8si29qxwn \</span><br><span class="line">--discovery-token-ca-cert-hash</span><br><span class="line">sha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5</span><br><span class="line"><span class="comment"># 安装 Pod 网络插件</span></span><br><span class="line">$ kubectl apply –f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># 测试 kubernetes 集群</span></span><br><span class="line"><span class="comment"># 在 Kubernetes 集群中创建一个 pod，验证是否正常运行：</span></span><br><span class="line">$ kubectl create deployment nginx --image=nginx</span><br><span class="line">$ kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">$ kubectl get pod,svc</span><br></pre></td></tr></table></figure><ol><li>安装 3 台虚拟机，安装操作系统</li><li>对三个安装之后的操作系统进行初始化操作</li><li>在三个节点安装 docker kubelet,kubeadm kubectl,更改 docker 源</li><li>在 master 节点执行 kubeadm init 命令进行初始化</li><li>在 node 节点上执行 kubeadm join 命令把 node 节点添加到当前集群里面</li></ol><h4 id="二进制包搭建"><a href="#二进制包搭建" class="headerlink" title="二进制包搭建"></a>二进制包搭建</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141438880.png" alt="二进制包搭建"></p><ol><li>创建多台虚拟机，安装 Linux 操作系统</li><li>操作系统初始化</li><li>为 etcd 和 apiserver 自签证书</li><li>部署 etcd 集群</li><li>部署 master 组件</li></ol><p>kube-apiserver,kube-controller-manager,kube-scheduler,etcd</p><ol><li>部署 node 组件</li></ol><p>kebelet,kube-proxy,docker,etcd</p><ol><li>部署集群网络</li></ol><h3 id="k8s-集群命令行工具-kubectl"><a href="#k8s-集群命令行工具-kubectl" class="headerlink" title="k8s 集群命令行工具 kubectl"></a>k8s 集群命令行工具 kubectl</h3><p>kubectl 是 Kubernetes 集群的命令行工具,通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl [<span class="built_in">command</span>] [<span class="built_in">type</span>] [name] [flags]</span><br><span class="line">$ kubectl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h3 id="yaml-文件说明"><a href="#yaml-文件说明" class="headerlink" title="yaml 文件说明"></a>yaml 文件说明</h3><h4 id="文件书写格式"><a href="#文件书写格式" class="headerlink" title="文件书写格式"></a>文件书写格式</h4><ul><li><p>通过缩进表示层级关系</p></li><li><p>不能用 tab 键表示缩进</p></li><li><p>: 后加一个空格</p></li><li><p>一般开头缩进两个空格</p></li><li><p>字符后缩进一个空格</p></li><li><p>—- 表示一个新的 yaml 文件的开始</p></li><li><p>使用#代表注释</p></li></ul><h4 id="yaml-文件示例"><a href="#yaml-文件示例" class="headerlink" title="yaml 文件示例"></a>yaml 文件示例</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141438799.png" alt="yaml文件示例"></p><div class="table-container"><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>apiVersion</td><td>Api 版本</td></tr><tr><td>kind</td><td>资源类型</td></tr><tr><td>metadata</td><td>资源元数据</td></tr><tr><td>spec</td><td>资源规格</td></tr><tr><td>replicas</td><td>副本数量</td></tr><tr><td>selector</td><td>标签选择器</td></tr><tr><td>template</td><td>Pod 模板</td></tr><tr><td>metadata</td><td>Pod 元数据</td></tr><tr><td>spec</td><td>Pod 规格</td></tr><tr><td>container</td><td>容器配置</td></tr></tbody></table></div><h4 id="如何快速编写-yaml-文件"><a href="#如何快速编写-yaml-文件" class="headerlink" title="如何快速编写 yaml 文件"></a>如何快速编写 yaml 文件</h4><ol><li>使用<strong>kubectl create</strong>命令生成 yaml 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create deployment web --image=nginx -o yaml --dry-run &gt; web1.yaml</span><br></pre></td></tr></table></figure><h2 id="Kubernetes-核心技术"><a href="#Kubernetes-核心技术" class="headerlink" title="Kubernetes 核心技术"></a>Kubernetes 核心技术</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><h4 id="Pod-概述"><a href="#Pod-概述" class="headerlink" title="Pod 概述"></a>Pod 概述</h4><ol><li><p>Pod 是 k8s 系统中可以创建(部署)和管理的最小单元</p></li><li><p>k8s 不会直接处理容器,而是 Pod,Pod 可以包含多个容器(一组容器的集合)</p></li><li><p>一个 pod 中共享网络命名空间</p></li><li>每一个 Pod 都有一个特殊的被称为”根容器”的 Pause 容器。Pause 容器对应的镜像属于 k8s 平台的一部分,除了 Pause 容器,每个 Pod 还包含一个或者多个紧密相关的用户业务容器。</li><li>Pod 是短暂的</li></ol><h4 id="Pod-存在的意义"><a href="#Pod-存在的意义" class="headerlink" title="Pod 存在的意义"></a>Pod 存在的意义</h4><ol><li>创建容器使用 docker，一个 docker 对应一个容器，一个容器有进程，一个容器运行一个应用程序</li><li>Pod 是多进程设计，可以运行多个应用程序；一个 Pod 有多个容器，一个容器里面运行一个应用程序</li><li>Pod 存在是为了亲密性交互:<ul><li>两个应用之间进行交互</li><li>网络之间进行调用</li><li>两个应用需要频繁调用</li></ul></li></ol><h4 id="Pod-实现机制"><a href="#Pod-实现机制" class="headerlink" title="Pod 实现机制"></a>Pod 实现机制</h4><ol><li>共享网络</li></ol><p>容器本身是相互隔离的，k8s 利用 Pod 的 Pause 容器(info 容器)，吧其他业务容器加入到 Pause 容器中，让所有业务容器在同一个名称空间中，可以实现网络共享</p><ol><li>共享存储</li></ol><p>Pod 持久化数据：日志数据，业务数据</p><p>使用 Volume 数据卷进行持久化存储</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141438637.png" alt="volumes"></p><h4 id="Pod-镜像拉取策略"><a href="#Pod-镜像拉取策略" class="headerlink" title="Pod 镜像拉取策略"></a>Pod 镜像拉取策略</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141438267.png" alt="imagePullPolicy"></p><p><strong>imagePullPolicy</strong></p><p>IfNotPresent: 默认值，镜像在宿主机上不存在时才拉取</p><p>Always: 每次创建 Pod 都会拉取一次镜像</p><p>Never: Pod 永远不会主动拉取这个镜像,需要手动拉取</p><h4 id="Pod-资源限制"><a href="#Pod-资源限制" class="headerlink" title="Pod 资源限制"></a>Pod 资源限制</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141439263.png" alt="Pod资源限制"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141439921.png" alt="resources"></p><p>1c = 1000m(1 核 cpu)</p><h4 id="Pod-重启机制"><a href="#Pod-重启机制" class="headerlink" title="Pod 重启机制"></a>Pod 重启机制</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141439857.png" alt="restartPolicy"></p><p><strong>restartPolicy</strong></p><p>Always: 当容器终止推出后，总是重启容器，默认策略</p><p>OnFailure: 当容器异常退出(退出状态码非 0)时才重启容器</p><p>Never: 当容器终止推出时，从不重启容器</p><h4 id="Pod-健康检查"><a href="#Pod-健康检查" class="headerlink" title="Pod 健康检查"></a>Pod 健康检查</h4><p>容器检查：</p><p>检测不出 java 堆内存溢出(状态还是 running)</p><p>应用层面健康检查：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141439085.png" alt="应用层面健康检查"></p><p>echo $?表示 linux 上一条命令是否执行成功</p><h4 id="创建-Pod-流程"><a href="#创建-Pod-流程" class="headerlink" title="创建 Pod 流程"></a>创建 Pod 流程</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141440960.png" alt="创建Pod流程"></p><ul><li>master 节点</li></ul><p>createpod — apiserver — etcd</p><p>scheducler — apiserver —etcd — 调度算法,吧 pod 调度到某个 node 节点上</p><ul><li>node 节点</li></ul><p>kubelet —apiserver —读取 etcd 拿到分配给当前节点 pod —docker 创建容器</p><p><strong>影响调度的属性</strong></p><ol><li><p>pod 资源限制: resources</p></li><li><p>节点选择器标签影响 Pod 调度</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141440236.png" alt="nodeSelector"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141440048.png" alt="nodeSelector"></p><p>需要先对节点打标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl label node k8snode1 env_role=prod</span><br><span class="line">$ kubectl get nodes k8snode1 --show-labels</span><br></pre></td></tr></table></figure><ol><li>节点亲和性影响 Pod 调度</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141441999.png" alt="节点亲和性"></p><p><strong>节点亲和性</strong> nodeAffinity 和之前 nodeSelector 基本一样的,根据节点上标签约束来决定 Pod 调度到哪些节点上</p><p>(1) 硬亲和性(requireDuringSchedulingIgnoreDuringExecution)</p><p>约束条件必须满足</p><p>(2) 软亲和性(preferredDuringSchedulingIgnoredDuringExecution)</p><p>尝试满足，不保证</p><p>常用的操作符(operator):</p><p>In NotIn Exists Gt Lt DoesNotExists</p><p><strong>反亲和性</strong>:使用 NotIn 和 DoesNotExists</p><ol><li>污点和污点容忍</li></ol><ul><li>基本介绍：</li></ul><p>nodeSelector 和 nodeAffinity: Pod 调度到某些节点上,Pod 属性,调度的时候实现</p><p>Taint 污点: 节点不做普通分配调度,是节点属性</p><ul><li>场景</li></ul><p>专用节点</p><p>配置特点硬件节点</p><p>基于 Taint 驱逐</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前节点的污点情况</span></span><br><span class="line">$ kubectl describe node k8smaster | grep Taint</span><br></pre></td></tr></table></figure><p>污点值有三个:</p><p>NoSchedule: 一定不被调度</p><p>PreferNoSchedule: 尽量不被调度</p><p>NoExecute: 不会调度,而且还会驱逐 Node 已有 Pod</p><p>为节点添加污点</p><p>kubectl taint node [node] key=value:污点三个值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl create deployment web --image=nginx</span><br><span class="line">$ kubectl get pods -o wide</span><br><span class="line"><span class="comment"># 再创建4个</span></span><br><span class="line">$ kubectl scale deployment web --replicas=5</span><br><span class="line">$ kubectl taint node [node] key=value</span><br><span class="line"><span class="comment"># 删除pod</span></span><br><span class="line">$ kubectl delete deployment web</span><br><span class="line">$ kubectl get pods</span><br><span class="line">No resources found <span class="keyword">in</span> default namespace</span><br><span class="line">$ kubectl taint node k8snode1 env_role=<span class="built_in">yes</span>:NoSchedule</span><br><span class="line">$ kubectl describe node k8snode1 | grep Taint</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除污点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint node k8snode1 env_role:NoSchedule-</span><br><span class="line">$ kubectl describe node k8snode1 | grep Taint</span><br></pre></td></tr></table></figure><p>污点容忍:</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141441913.png" alt="tolerations"></p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><h4 id="什么是-Controller"><a href="#什么是-Controller" class="headerlink" title="什么是 Controller"></a>什么是 Controller</h4><p>在集群上管理和运行容器的对象</p><h4 id="Pod-和-Controller-关系"><a href="#Pod-和-Controller-关系" class="headerlink" title="Pod 和 Controller 关系"></a>Pod 和 Controller 关系</h4><ul><li><p>Pod 通过 Controller 实现应用的运维，比如伸缩，滚动升级等</p><ul><li>Pod 和 Controller 之间通过 label 标签建立关系</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141441405.png" alt="Pod和Controller通过标签建立关系"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141442159.png" alt="Pod和Controller的关系"></p><h4 id="deployment-应用场景"><a href="#deployment-应用场景" class="headerlink" title="deployment 应用场景"></a>deployment 应用场景</h4><ul><li>部署无状态应用</li><li>管理 Pod 和 ReplicaSet</li><li>部署，滚动升级等功能</li></ul><p>应用场景: web 服务,微服务</p><h4 id="使用-deployment-部署应用-yaml"><a href="#使用-deployment-部署应用-yaml" class="headerlink" title="使用 deployment 部署应用(yaml)"></a>使用 deployment 部署应用(yaml)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出yaml文件</span></span><br><span class="line">$ kubectl create deployment web --image=nginx --dry-run -o yaml &gt; web.yaml</span><br><span class="line"><span class="comment"># 使用yaml部署y</span></span><br><span class="line">$ kubectl apply -f web.yaml</span><br><span class="line">$ kubectl get nodes</span><br><span class="line"><span class="comment"># 对外发布,暴露端口</span></span><br><span class="line">$ kubectl expose deployment web --port=80 --<span class="built_in">type</span>=NodePort --target-port=80 --name=web1 -o yaml &gt; web1.yaml</span><br><span class="line">$ kubectl apply -f web1.yaml</span><br><span class="line">$ kubectl get nodes -o wide</span><br></pre></td></tr></table></figure><h4 id="应用升级回滚和弹性伸缩"><a href="#应用升级回滚和弹性伸缩" class="headerlink" title="应用升级回滚和弹性伸缩"></a>应用升级回滚和弹性伸缩</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用升级</span></span><br><span class="line">$ kubectl <span class="built_in">set</span> image deployment web nginx=nginx:1.15</span><br><span class="line"><span class="comment"># 查看升级状态</span></span><br><span class="line">$ kubectl rollout status deployment web</span><br><span class="line"><span class="comment"># 查看历史版本</span></span><br><span class="line">$ kubectl rollout <span class="built_in">history</span> deployment web</span><br><span class="line"><span class="comment"># 还原到上一个版本</span></span><br><span class="line">$ kubectl rollout undo deployment web</span><br><span class="line"><span class="comment"># 弹性伸缩</span></span><br><span class="line">$ kubectl scale deployment web --replicas=10</span><br></pre></td></tr></table></figure><h4 id="无状态和有状态的区别"><a href="#无状态和有状态的区别" class="headerlink" title="无状态和有状态的区别"></a>无状态和有状态的区别</h4><ol><li>无状态<ul><li>认为 Pod 都是一样的(副本都是一样的)</li><li>没有顺序要求</li><li>不用考虑在哪个 node 运行</li><li>随意进行伸缩和扩展</li></ul></li><li>有状态<ul><li>上面因素都需要考虑到</li><li>让每个 pod 独立，保持 pod 启动顺序和唯一性(唯一的网络标识符，持久存储，有序，比如 mysql 主从)</li></ul></li></ol><h4 id="部署有状态的应用"><a href="#部署有状态的应用" class="headerlink" title="部署有状态的应用"></a>部署有状态的应用</h4><ul><li>无头 service:<ul><li>ClusterIP: node</li></ul></li></ul><p><strong>StatefulSet</strong>部署有状态应用</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141443096.png" alt="StatefulSet部署有状态应用"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141443707.png" alt="StatefulSet部署有状态应用"></p><p>执行后查看 pod，有 3 个 Pod，每个都是唯一的名称</p><p>查看 svc, ClusterIP 为 None</p><p>deployment 和 statefulset 区别:有身份的(唯一标识的)</p><ul><li>根据主机名+按照一定规则生成域名</li><li>唯一域名</li></ul><p>格式： 主机名称.service 名称.名称空间.svc.cluster.local</p><p>example: nginx-statefulset-0.nignx.default.svc</p><h4 id="部署守护进程-DaemonSet"><a href="#部署守护进程-DaemonSet" class="headerlink" title="部署守护进程 DaemonSet"></a>部署守护进程 DaemonSet</h4><ul><li>在每个 node 上运行一个 pod，新加入的 node 也同样运行在一个 Pod 里面</li><li>例子：在每个 node 节点安装数据采集工具</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141443841.png" alt="部署守护进程DaemonSet"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete statefulset --all</span><br><span class="line">$ kubectl delete svc nginx</span><br><span class="line">$ kubectl delete svc web</span><br><span class="line">$ kubectl apply -f ds.yaml</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it ds-test-cbk6cv bash</span><br></pre></td></tr></table></figure><h4 id="job-一次性任务-和-cronjob-定时任务"><a href="#job-一次性任务-和-cronjob-定时任务" class="headerlink" title="job(一次性任务)和 cronjob(定时任务)"></a>job(一次性任务)和 cronjob(定时任务)</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141444374.png" alt="job"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f job.yaml</span><br><span class="line">$ kubectl get pods -o wide</span><br><span class="line">$ kubectl get <span class="built_in">jobs</span></span><br><span class="line">pi-qpqff Completed</span><br><span class="line">$ kubectl logs pi-qpqff</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">$ kubectl delete -f job.yaml</span><br></pre></td></tr></table></figure><p>定时任务:</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141444234.png" alt="CronJob"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f cronjob.yaml</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl get cronjobs</span><br><span class="line">$ kubectl logs hello-1599100140-wkn79</span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h4 id="Service-是什么"><a href="#Service-是什么" class="headerlink" title="Service 是什么"></a>Service 是什么</h4><p>定义一组 Pod 的访问规则</p><h4 id="Service-存在意义"><a href="#Service-存在意义" class="headerlink" title="Service 存在意义"></a>Service 存在意义</h4><ul><li><p>防止 Pod 失联(服务发现)</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141445936.png" alt="服务发现"></p></li><li><p>定义一组 Pod 访问策略(负载均衡)</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141445167.png" alt="负载均衡"></p><h4 id="Pod-和-Service-的关系"><a href="#Pod-和-Service-的关系" class="headerlink" title="Pod 和 Service 的关系"></a>Pod 和 Service 的关系</h4><p>根据 label 标签建立关系</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141445708.png" alt="Pod和Service通过标签建立关系"></p><h4 id="常用-Service-类型"><a href="#常用-Service-类型" class="headerlink" title="常用 Service 类型"></a>常用 Service 类型</h4><ol><li>ClusterIP: 集群内部使用</li><li>NodePort: 对外访问应用使用</li><li>LoadBalancer: 对外访问应用使用,公有云</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">$ kubectl expose deployment web --port=80 --target-port=80 --dry-run -o yaml &gt; service1.yaml</span><br><span class="line">$ kubectl apply -f service1.yaml</span><br><span class="line">$ kubectl get svc</span><br></pre></td></tr></table></figure><p>node 内网部署应用,外网一般不能访问到:</p><p>用一台可以进行外网访问的机器，安装 nginx,反向代理</p><p>手动把可以访问节点添加到 nginx</p><p>LoadBalancer: 公有云，把负载均衡,控制器</p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><h4 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h4><p>作用： 加密数据存在 etcd 里面，让 Pod 容器以挂载 Volume 的方式进行访问</p><p>场景: 凭证</p><p>base64 编码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -n <span class="string">&quot;admin&quot;</span> | <span class="built_in">base64</span></span><br></pre></td></tr></table></figure><p>1.创建 secret 加密数据</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141446261.png" alt="创建secret加密数据"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f secret.yaml</span><br><span class="line">$ kubectl get secret</span><br></pre></td></tr></table></figure><ol><li>以变量的形式挂载到 pod 容器中</li></ol><p>valueFrom</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141446007.png" alt="valueFrom"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f secret-val.yaml</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it mypod bash</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SECRET_USERNAME</span></span><br></pre></td></tr></table></figure><ol><li>以 Volume 挂载数据卷中</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141446735.png" alt="以Volume挂载到数据卷中"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141447594.png" alt="以Volume挂载到数据卷中"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f secret-val.yaml</span><br><span class="line">$ kubectl apply -f secret-vol.yaml</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it mypod bash</span><br><span class="line">$ <span class="built_in">ls</span> /etc/foo</span><br><span class="line">$ <span class="built_in">cat</span> /etc/foo/username</span><br></pre></td></tr></table></figure><h4 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h4><p>作用：存储不加密数据到 etcd 中,让 Pod 以变量或者 Volume 挂载到容器中</p><p>场景：配置文件</p><p>1.创建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete secret --all</span><br><span class="line">$ kubectl delete Pod --all</span><br><span class="line">$ vim redis.properties</span><br></pre></td></tr></table></figure><p>2.创建 configmap</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create configmap redis-config --from-file=redis.properties</span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">$ kubectl get cm</span><br><span class="line">$ kubectl describe cm redis-config</span><br></pre></td></tr></table></figure><p>3.以 Volume 挂在到 Pod 容器中</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141447224.png" alt="以Volume挂在到Pod容器中"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f cm.yaml</span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">$ kubectl logs mypod</span><br></pre></td></tr></table></figure><p>4.以变量形式挂载</p><p>（1）创建 yaml,声明变量信息 configmap 创建</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141448378.png" alt="声明变量"></p><p>（2）以变量挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f myconfig.yaml</span><br><span class="line">$ kubectl get cm</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141448692.png" alt="以变量挂载"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f config-var.yaml</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl get cm</span><br><span class="line">$ kubectl logs mypod</span><br></pre></td></tr></table></figure><h3 id="k8s-集群安装机制"><a href="#k8s-集群安装机制" class="headerlink" title="k8s 集群安装机制"></a>k8s 集群安装机制</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li><p>访问 k8s 集群的时候要经过三个步骤完成具体操作</p><p>(1) 认证</p><p>(2) 鉴权(授权)</p><p>(3) 准入控制</p></li><li><p>进行访问的时候，过程中都需要经过 apiserver，apiserver 做统一协调,比如门卫,访问过程中需要证书,token，或者用户名+密码，如果访问 pod 需要 serviceAccount</p></li></ol><p>第一步认证</p><ul><li>传输安全: 对外不暴露 8080 端口,只能内部访问,对外使用端口 6443</li><li>认证： 客户端身份认证常用方式：<ul><li>https 证书认证,基于 ca 证书</li><li>http token 认证,通过 token 识别用户</li><li>http 基本认证,用户名+密码认证</li></ul></li></ul><p>第二步 鉴权</p><ul><li>基于 RBAC 进行鉴权操作</li><li>基于角色访问控制</li></ul><p>第三步 准入控制</p><ul><li>就是准入控制器的列表,如果列表友情就内容就通过</li></ul><h4 id="RBAC-基于角色的访问控制"><a href="#RBAC-基于角色的访问控制" class="headerlink" title="RBAC 基于角色的访问控制"></a>RBAC 基于角色的访问控制</h4><p>Role Based Access Control</p><ol><li>角色</li></ol><ul><li><p>role: 角色,特定命名空间的访问权限</p></li><li><p>clusterRole: 对所有命名空间的访问权限</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看命名空间</span></span><br><span class="line">$ kubectl get ns</span><br><span class="line"><span class="comment"># 创建命名空间</span></span><br><span class="line">$ kubectl create ns roletest</span><br></pre></td></tr></table></figure><ol><li>角色绑定</li></ol><ul><li>roleBinding: 角色绑定到主题</li><li>ClusterRoleBinding: 集群角色绑定到主体</li></ul><ol><li>主体</li></ol><ul><li>user: 用户</li><li>group: 用户组</li><li>serviceAccount: 服务账号</li></ul><h4 id="RBAC-实现鉴权"><a href="#RBAC-实现鉴权" class="headerlink" title="RBAC 实现鉴权"></a>RBAC 实现鉴权</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.创建命名空间</span></span><br><span class="line">$ kubectl create ns roledemo</span><br><span class="line"><span class="comment"># 2.在新的命名空间下创建一个Pod</span></span><br><span class="line">$ kubectl run nginx --image=nginx -n roledemo</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141449633.png" alt="RBAC实现鉴权"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.创建角色</span></span><br><span class="line">$ vim rbac-role.yaml</span><br><span class="line">$ kubectl apply -f rbac-role.yaml</span><br><span class="line"><span class="comment"># 查看命名空间下的角色</span></span><br><span class="line">$ kubectl get role -n roledemo</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141449836.png" alt="RBAC实现鉴权"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 4.创建角色绑定</span></span><br><span class="line">$ vim rbac-rolebing.yaml</span><br><span class="line">$ kubectl apply -f rbac-rolebinding.yaml</span><br><span class="line">$ kubectl get role,rolebinding -n roledemo</span><br></pre></td></tr></table></figure><ol><li>使用证书</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141449002.png" alt="使用证书"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim rbac-user.sh</span><br><span class="line">$ <span class="built_in">cp</span> /root/TLS/k8s/ca* ./</span><br><span class="line">$ bash rbac.sh</span><br><span class="line">$ kubectl get pods -n roledemo</span><br></pre></td></tr></table></figure><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ol><li>把端口号对外暴露，通过 ip+端口号进行访问,使用 Service 里面的 NodePort 实现</li><li>NodePort 缺陷</li></ol><ul><li>在每个节点上都会起到端口，在访问时候通过任何节点,通过节点 ip+暴露端口实现访问</li><li>意味着灭个端口只能使用一次,一个端口对应一个应用</li><li>实际访问中都是用域名，根据不同的域名跳转到不同端口服务中</li></ul><h4 id="Ingress-和-Pod-关系"><a href="#Ingress-和-Pod-关系" class="headerlink" title="Ingress 和 Pod 关系"></a>Ingress 和 Pod 关系</h4><ul><li>pod 和 ingress 通过 service 关联的</li><li>ingress 作为统一入口,由 service 关联一组 pod</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141450003.png" alt="Ingress"></p><h4 id="使用-ingress"><a href="#使用-ingress" class="headerlink" title="使用 ingress"></a>使用 ingress</h4><p>使用 Ingress 对外暴露应用</p><ol><li>创建 nginx 应用,对外暴露端口使用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create deployment web --image=nginx</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl get deploy</span><br><span class="line">$ kubectl expose deployment web --port=80 --target-port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line">$ kubectl get svc</span><br></pre></td></tr></table></figure><ol><li>部署 ingress controller</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141450672.png" alt="部署ingress controller"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f ingress-con.yaml</span><br><span class="line"><span class="comment"># 查看ingress controller状态</span></span><br><span class="line">$ kubectl get pods -n ingress-nginx</span><br><span class="line"><span class="comment"># 创建ingress规则</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141450934.png" alt="创建ingress规则"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim ingress-h.yaml</span><br><span class="line">$ kubectl apply -f ingress-h.yaml</span><br><span class="line">$ kubectl get pods -n ingress-nginx -o wide</span><br><span class="line">$ kubectl get ing</span><br></pre></td></tr></table></figure><h3 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>之前部署应用的基本过程：</p><p>​ 编写 yaml 文件: deployment,Service,Ingress</p><p>如果使用之前方式部署单一应用,少数服务的应用,比较合适</p><p>如果部署微服务项目,可能有几十个服务，每个服务都有一套 yaml 文件，需要维护大量 yaml 文件，版本管理特别不方便</p><p>使用 helm 可以解决哪些问题？</p><ol><li>使用 helm 可以把这些 yaml 作为一个整体管理</li><li>实现 yaml 高效服用</li><li>使用 helm 应用级别的版本管理</li></ol><p><strong>helm 介绍</strong></p><p>Helm 是一个 k8s 的包管理工具,就像 Linux 下的包管理器如 yum/apt 等，可以很方便的将之前打包好的 yaml 文件部署到 k8s 上</p><p><strong>三个重要概念</strong></p><ul><li><p>helm</p><ul><li>是一个命令行客户端工具</li></ul></li><li><p>Chart</p><ul><li>是把 yaml 打包，是 yaml 集合</li></ul></li><li><p>Release</p><ul><li>基于 chart 部署实体,应用级别的版本管理</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141451107.png" alt="Helm v3架构"></p><p><a href="https://helm.sh/docs/intro/quickstart/">https://helm.sh/docs/intro/quickstart/</a></p><p><strong>安装</strong></p><p><a href="https://helm.sh/docs/intro/install/">https://helm.sh/docs/intro/install/</a></p><p><strong>添加仓库</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm repo add brigade https://brigadecore.github.io/charts</span><br><span class="line"><span class="string">&quot;brigade&quot;</span> has been added to your repositories</span><br><span class="line">$ helm search repo brigade</span><br></pre></td></tr></table></figure><h4 id="使用-helm-快速部署应用"><a href="#使用-helm-快速部署应用" class="headerlink" title="使用 helm 快速部署应用"></a>使用 helm 快速部署应用</h4><ol><li>使用命令搜索应用</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm search repo 名称</span><br></pre></td></tr></table></figure><ol><li>根据搜索内容选择安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm install 安装之后的名称 搜索之后的名称</span><br></pre></td></tr></table></figure><ol><li>查看安装后的状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm list</span><br><span class="line">$ helm status 安装后的名称</span><br></pre></td></tr></table></figure><p>example</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ helm search repo weave</span><br><span class="line">$ helm install ui stable/weave-scope</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl get svc</span><br><span class="line"><span class="comment"># 发现没有暴露端口需要改nodePort</span></span><br><span class="line">$ kubectl edit svc ui-weave-scope</span><br></pre></td></tr></table></figure><h4 id="如何自己创建-Chart"><a href="#如何自己创建-Chart" class="headerlink" title="如何自己创建 Chart"></a>如何自己创建 Chart</h4><ol><li>使用命令创建 chart</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helm create mychart</span><br><span class="line">$ <span class="built_in">cd</span> mychart</span><br></pre></td></tr></table></figure><ul><li>Chart.yaml： 当前 chart 属性配置信息</li><li>templates: 编写 yaml 文件放到这个目录中</li><li>values.yaml： yaml 文件可以使用的全局变量</li></ul><ol><li>在 templates 文件夹下创建两个 yaml 文件</li></ol><ul><li>deployment.yaml</li><li>service.yaml</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create deployment web1 --images=nginx --dry-run -o yaml &gt; deployment.yaml</span><br><span class="line">$ kubectl create deployment web1 --image=nginx</span><br><span class="line">$ kubectl expose deployment web1 --port=80 --target-port=80 --<span class="built_in">type</span>=NodePort --dry-run -o yaml &gt; service.yaml</span><br><span class="line">$ kubectl delete deployment web1</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>安装 mychart</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm install web1 mychart/</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl get svc</span><br></pre></td></tr></table></figure><p>4.应用升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ helm upgrade chart名称 chart文件夹</span><br><span class="line"><span class="comment"># example</span></span><br><span class="line">$ helm upgrade web1 mychart/</span><br></pre></td></tr></table></figure><h4 id="实现-yaml-高效服用"><a href="#实现-yaml-高效服用" class="headerlink" title="实现 yaml 高效服用"></a>实现 yaml 高效服用</h4><p>通过传递参数,动态渲染模板,yaml 内容动态传入参数生成</p><ol><li>在 values.yaml 定义变量和值</li><li>在具体 yaml 文件中获取定义变量和值</li></ol><ul><li>yaml 文件大体上有这几个地方是不同的<ul><li>image</li><li>tag</li><li>label</li><li>port</li><li>replicas</li></ul></li></ul><p>一.在 values.yaml 定义变量和值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">tag:</span> <span class="number">1.16</span></span><br><span class="line"><span class="attr">label:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>二.在 templates 的 yaml 文件中使用 values.yaml 定义变量</p><ul><li>通过表达式形式使用全局变量</li></ul><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123;<span class="name">.Values.变量名称</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#123; <span class="name">.Release.Name</span>&#125;&#125;</span><span class="language-xml">-deploy</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span><span class="template-variable">&#123;&#123;<span class="name">.Values.image</span>&#125;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ helm install --dry-run web2 mychart/</span><br></pre></td></tr></table></figure><h3 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h3><p>数据卷 emptydir,是本地存储,pod 重启,数据不存在了,需要对数据持久化存储</p><h4 id="nfs-网络存储"><a href="#nfs-网络存储" class="headerlink" title="nfs 网络存储"></a>nfs 网络存储</h4><p>pod 重启,数据还是在的</p><p>第一步 找一台服务器 nfs 服务端</p><p>(1) 安装 nfs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y nfs-utils</span><br></pre></td></tr></table></figure><p>(2) 设置挂载路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/exports</span><br><span class="line">/data/nfs *(rw.no_root_squash)</span><br></pre></td></tr></table></figure><p>(3) 对外挂在路径需要先创建出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /data/nfs</span><br></pre></td></tr></table></figure><p>第二步 在 k8s 集群 node 节点上安装 nfs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y nfs-utils</span><br></pre></td></tr></table></figure><p>第三步 在 nfs 服务器启动 nfs 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start nfs</span><br><span class="line">$ ps -elf | grep nfs</span><br></pre></td></tr></table></figure><p>第四步 在 k8s 集群中部署应用使用 nfs 持久网络存储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> pv</span><br><span class="line">$ <span class="built_in">cd</span> pv</span><br><span class="line">$ vim nfs-nginx.yaml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141451280.png" alt="使用nfs持久网络存储"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl describe pod nginx-dep1-79x79jg79-9sn8gx</span><br></pre></td></tr></table></figure><h4 id="PV-和-PVC"><a href="#PV-和-PVC" class="headerlink" title="PV 和 PVC"></a>PV 和 PVC</h4><ol><li>PV: 持久化存储，对存储资源进行抽象，对外提供可以调用的地方(生产者)</li><li>PVC: 用户调用不需要关心内部实现细节(消费者)</li><li>实现流程：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141451943.png" alt="PV和PVC"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim pvc.yaml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141452459.png" alt="pvc.yaml"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141452112.png" alt="pvc.yaml"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f pvc.yaml</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim pv.yaml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141452154.png" alt="pv.yaml"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f pv.yaml</span><br><span class="line">$ kubectl get pv,pvc</span><br><span class="line">$ kubectl get pods</span><br><span class="line">$ kubectl <span class="built_in">exec</span> -it nginx-dep1-79u99x9g68s bash</span><br><span class="line">$ <span class="built_in">ls</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure><h3 id="k8s-集群资源监控"><a href="#k8s-集群资源监控" class="headerlink" title="k8s 集群资源监控"></a>k8s 集群资源监控</h3><h4 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h4><ol><li>集群监控<ul><li>节点资源利用率</li><li>节点数</li><li>运行 pods</li></ul></li><li>Pod 监控<ul><li>容器指标</li><li>应用程序</li></ul></li></ol><h4 id="监控平台"><a href="#监控平台" class="headerlink" title="监控平台"></a>监控平台</h4><p>prometheus+Grafana</p><p>(1) prometheus</p><ul><li>开源的</li><li>监控，报警，数据库</li><li>以 HTTP 协议周期性抓取被监控的组件状态</li><li>不需要复杂的继承过程,使用 http 接口接入就可以了</li></ul><p>(2) Grafana</p><ul><li>开源的数据分析和可视化工具</li><li>支持多种数据源</li></ul><p>部署：</p><p><a href="https://developer.aliyun.com/article/836300">https://developer.aliyun.com/article/836300</a></p><h2 id="搭建高可用集群"><a href="#搭建高可用集群" class="headerlink" title="搭建高可用集群"></a>搭建高可用集群</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141453676.png" alt="高可用集群"></p><h4 id="高可用集群技术"><a href="#高可用集群技术" class="headerlink" title="高可用集群技术"></a>高可用集群技术</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141453922.png" alt="高可用集群技术"></p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141453467.png" alt="部署"></p><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/">https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/</a></p><h2 id="部署一个-java-项目"><a href="#部署一个-java-项目" class="headerlink" title="部署一个 java 项目"></a>部署一个 java 项目</h2><h4 id="容器交付流程"><a href="#容器交付流程" class="headerlink" title="容器交付流程"></a>容器交付流程</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141453133.png" alt="容器交付流程"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510141503175.png" alt="容器交付流程"></p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang</title>
      <link href="/posts/50010/"/>
      <url>/posts/50010/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-14</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><h3 id="1-Package"><a href="#1-Package" class="headerlink" title="1.Package"></a>1.Package</h3><ul><li>Every Go program is made up of packages</li><li>program start with package <strong>main</strong></li></ul><p>By convention, the package name is the same as the last element of the import path.</p><p>For instance, the “<strong>math/rand</strong>“ package comprises files that begin with the statement <strong>package rand.</strong></p><h3 id="2-Imports"><a href="#2-Imports" class="headerlink" title="2.Imports"></a>2.Imports</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// also like:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-Exported-names"><a href="#3-Exported-names" class="headerlink" title="3.Exported names"></a>3.Exported names</h3><p>A name is exported if it begin with a capital letter.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// error:undefined: math.pi</span></span><br><span class="line">fmt.Println(math.pi)</span><br><span class="line">    <span class="comment">// 3.141592653589793</span></span><br><span class="line">    fmt.Println(math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Functions"><a href="#4-Functions" class="headerlink" title="4.Functions"></a>4.Functions</h3><p>Notice that the type comes <em>after</em> the variable name.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Syntactic Sugar</strong></p><p>When two or more consecutive named function parameters share a type, you can omit the type from all but the last.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Multiple results</strong></p><p>A function can return any number of results</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := swap(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Named return values</strong></p><p>Go’s return values may be <strong>named.</strong></p><p>If so, they are treated as <strong>variables defined at the top of the function.</strong></p><p>A return statement without arguments returns the named return values. This is known as a “naked” return.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Suggestions<strong>: Naked return statements</strong> should be used only in short functions, as with the example shown here. They can harm readability in longer functions.</p><h3 id="5-Variables"><a href="#5-Variables" class="headerlink" title="5.Variables"></a>5.Variables</h3><ul><li>The var statement declares a list of variables;</li><li>as in function argument lists, the type is last.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A var statement can be at package or function level.</span></span><br><span class="line"><span class="keyword">var</span> c, python, java <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Initializer</strong></p><p>A var declaration can include initializers, one per variable.</p><p>If an initializer is present, the type can be omitted; the variable will take the type of the initializer.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="comment">//var i, j  = 1, 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Variables declared without an explicit initial value are given their <strong>*zero value***</strong>.**</p><p>The zero value is:</p><ul><li>0 for numeric types,</li><li>false for the boolean type, and</li><li>“” (the empty string) for strings.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">    <span class="comment">//0 0 false &quot;&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %v %v %q\n&quot;</span>, i, f, b, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Short variable declarations</strong></p><ul><li><strong>Inside</strong> a function, the <strong>“ := “</strong> short assignment statement can be used in place of a var declaration with implicit type.</li><li><strong>Outside</strong> a function, <strong>every statement begins with a keyword</strong> (var, func, and so on) and so the := construct is not available.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i, j <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">k := <span class="number">3</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(i, j, k, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Basic-Types"><a href="#6-Basic-Types" class="headerlink" title="6.Basic Types"></a>6.Basic Types</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  <span class="type">int8</span>  <span class="type">int16</span>  <span class="type">int32</span>  <span class="type">int64</span></span><br><span class="line"><span class="type">uint</span> <span class="type">uint8</span> <span class="type">uint16</span> <span class="type">uint32</span> <span class="type">uint64</span> <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"></span><br><span class="line"><span class="type">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line">     <span class="comment">// represents a Unicode code point</span></span><br><span class="line"></span><br><span class="line"><span class="type">float32</span> <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="type">complex64</span> <span class="type">complex128</span></span><br></pre></td></tr></table></figure><ul><li>The int, uint, and uintptr types are usually 32 bits wide on 32-bit systems and 64 bits wide on 64-bit systems.</li><li>When you need an integer value you should use int unless you have a specific reason to use a sized or unsigned integer type.</li></ul><p>example</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/cmplx&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ToBe   <span class="type">bool</span>       = <span class="literal">false</span></span><br><span class="line">MaxInt <span class="type">uint64</span>     = <span class="number">1</span>&lt;&lt;<span class="number">64</span> - <span class="number">1</span></span><br><span class="line">z      <span class="type">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, ToBe, ToBe)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, MaxInt, MaxInt)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Type: %T Value: %v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Type conversions</strong></p><p>The expression T(v) converts the value v to the type T.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Some numeric conversions:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var i int = 42</span></span><br><span class="line"><span class="comment">// var f float64 = float64(i)</span></span><br><span class="line"><span class="comment">// var u uint = uint(f)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Or, put more simply:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// i := 42</span></span><br><span class="line"><span class="comment">// f := float64(i)</span></span><br><span class="line"><span class="comment">// u := uint(f)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float64</span> = math.Sqrt(<span class="type">float64</span>(x*x + y*y))</span><br><span class="line"><span class="keyword">var</span> z <span class="type">uint</span> = <span class="type">uint</span>(f)</span><br><span class="line">fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unlike in C, in Go assignment between items of different type <strong>requires an explicit conversion</strong></p><p><strong>Type Inference</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">j := i <span class="comment">// j is an int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// when the right hand side contains an untyped numeric constant, the new variable may</span></span><br><span class="line"><span class="comment">// be an int, float64, or complex128 depending on the precision of the constant:</span></span><br><span class="line">i := <span class="number">42</span>           <span class="comment">// int</span></span><br><span class="line">f := <span class="number">3.142</span>        <span class="comment">// float64</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> <span class="comment">// complex128</span></span><br></pre></td></tr></table></figure><h3 id="7-Constants"><a href="#7-Constants" class="headerlink" title="7.Constants"></a>7.Constants</h3><ul><li>Constants are declared like variables, but with the const keyword.</li><li>Constants can be character, string, boolean, or numeric values.</li><li>Constants cannot be declared using the := syntax.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line">fmt.Println(<span class="string">&quot;Happy&quot;</span>, Pi, <span class="string">&quot;Day&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, Truth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Numeric Constants</strong></p><ul><li>Numeric constants are <strong>high-precision</strong> <em>values</em>.</li></ul><p>An untyped constant takes the type needed by its context.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"><span class="comment">// Create a huge number by shifting a 1 bit left 100 places.</span></span><br><span class="line"><span class="comment">// In other words, the binary number that is 1 followed by 100 zeroes.</span></span><br><span class="line">Big = <span class="number">1</span> &lt;&lt; <span class="number">100</span></span><br><span class="line"><span class="comment">// Shift it right again 99 places, so we end up with 1&lt;&lt;1, or 2.</span></span><br><span class="line">Small = Big &gt;&gt; <span class="number">99</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needInt</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> x*<span class="number">10</span> + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">needFloat</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x * <span class="number">0.1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(needInt(Small))</span><br><span class="line">fmt.Println(needFloat(Small))</span><br><span class="line">fmt.Println(needFloat(Big))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-For"><a href="#8-For" class="headerlink" title="8.For"></a>8.For</h3><p>Go has only one looping construct, the for loop.</p><p>The basic for loop has three components separated by semicolons:</p><ul><li>the init statement: executed before the first iteration</li><li>the condition expression: evaluated before every iteration</li><li>the post statement: executed at the end of every iteration</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line">    <span class="comment">//there are no parentheses surrounding the three components of the for</span></span><br><span class="line">    <span class="comment">//statement and the braces &#123; &#125; are always required</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>but the init and post statements are optional.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>For is Go’s “while”</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Forever</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-If"><a href="#9-If" class="headerlink" title="9.If"></a>9.If</h3><p>Go’s if statements are like its for loops; the expression need not be surrounded by parentheses ( ) but the braces { } are required.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="type">float64</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">&quot;i&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>If with a short statement</strong></p><ul><li>Like for, the if statement can start with a short statement to execute before the condition.</li><li>Variables declared by the statement are only in scope until the end of the if.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%g &gt;= %g\n&quot;</span>, v, lim)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Variables declared inside an if short statement are also available inside any of the else blocks.</p><h3 id="10-Switch"><a href="#10-Switch" class="headerlink" title="10.Switch"></a>10.Switch</h3><p>Go’s switch is like the one in C, C++, Java, JavaScript, and PHP, except that <strong>Go only runs the selected case, not all the cases that follow</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Print(<span class="string">&quot;Go runs on &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s.\n&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Switch cases evaluate cases <strong>from top to bottom</strong>, stopping when a case succeeds.</p><ul><li>Switch without a condition is the same as switch true.</li></ul><p>This construct can be <strong>a clean way to write long if-then-else chains.</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Defer"><a href="#11-Defer" class="headerlink" title="11.Defer"></a>11.Defer</h3><ul><li>A defer statement <strong>defers the execution of a function</strong> until the surrounding function returns.</li><li>The deferred call’s arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print:</span></span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>Deferred function calls are pushed onto a <strong>stack</strong>. When a function returns, its deferred calls are executed in <strong>last-in-first-out</strong> order.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// counting</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="12-Pointers"><a href="#12-Pointers" class="headerlink" title="12.Pointers"></a>12.Pointers</h3><p>A pointer holds the memory address of a value</p><p>The type *T is a pointer to a T value. Its zero value is nil.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br><span class="line"><span class="comment">//this is called dereferencing or indirecting</span></span><br><span class="line">fmt.Println(*p)</span><br><span class="line">*p = <span class="number">21</span></span><br></pre></td></tr></table></figure><ul><li>Unlike C, <strong>Go has no pinter arithmetic</strong></li></ul><h3 id="13-Struct"><a href="#13-Struct" class="headerlink" title="13.Struct"></a>13.Struct</h3><p>A struct is a collection of fields</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="type">int</span></span><br><span class="line">Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>the struct fields are accessed using a dot.</li><li>the struct fields can be accessed by a pointer through a struct pointer.Like Rust,you can use p.x instead of (*p).x , without the explicit dereference</li></ul><p><strong>struct literals</strong></p><p>a struct literal denotes a newly allocated struct value by listing the values of its fields.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span>&#123;</span><br><span class="line">    X,Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    v1 = Vertex&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    v2 = Vertex&#123;X:<span class="number">1</span>&#125;</span><br><span class="line">    v3 = Vertex&#123;&#125;</span><br><span class="line">    p = &amp;Vertex&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(v1,p,v2,v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-Array"><a href="#14-Array" class="headerlink" title="14.Array"></a>14.Array</h3><p>The type <strong>[n]T</strong> is an array of n values of type T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="type">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>An array’s length is part of its type, so <strong>arrays cannot be resized</strong>.</li></ul><h3 id="15-Slices"><a href="#15-Slices" class="headerlink" title="15.Slices"></a>15.Slices</h3><p>like rust</p><p>A slice is formed by specifying two indices a low and high bound,separated by a colon,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[low:high]</span><br></pre></td></tr></table></figure><ul><li>this selects a half-open range which includes the first element,but excludes the last one</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">primes := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>a slice does not store any data,it just describes a section of an underlying array</li><li>Changing the elements of a slice modifies the corresponding elements of its underlying array.</li></ul><p><strong>slice literals:</strong></p><p>A slice literal is like an array literal without the length</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">q := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">fmt.Println(q)</span><br><span class="line"></span><br><span class="line">r := []<span class="type">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">fmt.Println(r)</span><br><span class="line"></span><br><span class="line">s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">i <span class="type">int</span></span><br><span class="line">b <span class="type">bool</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>like rust,the slice has defaults</p><p>these slice expressions are equivalent:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure><p><strong>length</strong> and <strong>capacity</strong></p><p>A slice has both a <em>length</em> and a <em>capacity</em>.</p><ul><li>The length of a slice is the number of elements it contains.</li><li>The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.</li><li>The length and capacity of a slice s can be obtained using the expressions len(s) and cap(s).</li><li>You can extend a slice’s length by re-slicing it, provided it has sufficient capacity.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Slice the slice to give it zero length.</span></span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend its length.</span></span><br><span class="line">s = s[:<span class="number">4</span>]</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop its first two values.</span></span><br><span class="line">s = s[<span class="number">2</span>:]</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Nil slices</strong></p><p>The zero value of a slice is nil</p><p>A nil slice has a length and capacity of 0 and has no underlying array.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;nil!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Creating a slice with make</strong></p><p>Slices can be created with the built-in make function; <strong>this is how you create dynamically-sized arrays.</strong></p><ul><li>The make function allocates a zeroed array and returns a slice that refers to that array:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure><ul><li>To specify a capacity, pass a third argument to make:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">c := b[:<span class="number">2</span>]</span><br><span class="line">printSlice(<span class="string">&quot;c&quot;</span>, c)</span><br><span class="line"></span><br><span class="line">d := c[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">printSlice(<span class="string">&quot;d&quot;</span>, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s <span class="type">string</span>, x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s len=%d cap=%d %v\n&quot;</span>,</span><br><span class="line">s, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>slices of slices</strong></p><p>slices can contain any type,including other slices</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create a tic-tac-toe board.</span></span><br><span class="line">board := [][]<span class="type">string</span>&#123;</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">[]<span class="type">string</span>&#123;<span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;_&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The players take turns.</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">2</span>][<span class="number">2</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">board[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;O&quot;</span></span><br><span class="line">board[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(board); i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, strings.Join(board[i], <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Appending to a slice</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span></span> []T</span><br></pre></td></tr></table></figure><p>The first parameter s of append is a slice of type T, and the rest are T values to append to the slice.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append works on nil slices.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The slice grows as needed.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can add more than one element at a time.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d %v\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-Range"><a href="#16-Range" class="headerlink" title="16.Range"></a>16.Range</h3><p>the range form of the for loop iterates over a slice or map</p><p>like rust,When ranging over a slice, two values are returned for each iteration. The first is the index, and the second is a copy of the element at that index.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pow = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;2**%d = %d\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can skip the index or value by assigning to _.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure><p>If you only want the index, you can omit the second variable.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure><h3 id="17-Map"><a href="#17-Map" class="headerlink" title="17.Map"></a>17.Map</h3><p>A map maps keys to values.</p><p>The zero value of a map is nil. A nil map has no keys, nor can keys be added.</p><p>The make function returns a map of the given type, initialized and ready for use.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]Vertex)</span><br><span class="line">m[<span class="string">&quot;Bell Labs&quot;</span>] = Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m[<span class="string">&quot;Bell Labs&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Map literals</strong></p><p>Map literals are like struct literals, but the keys are required.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="type">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Mutating Maps</strong></p><p>insert or update an element in map m:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure><p>retrieve an element</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure><p>delete an element</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m,key)</span><br></pre></td></tr></table></figure><p>test that a key is present with a two-value assignment</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elemt,ok = m[key]</span><br></pre></td></tr></table></figure><ul><li>If key is in m, ok is true. If not, ok is false.</li><li>If key is not in the map, then elem is the zero value for the map’s element type.</li></ul><h3 id="18-Function-values"><a href="#18-Function-values" class="headerlink" title="18.Function values"></a>18.Function values</h3><p>Functions are values too. They can be passed around just like other values.</p><p>Function values may be used as function arguments and return values.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="type">float64</span>, <span class="type">float64</span>)</span></span> <span class="type">float64</span>) <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(compute(hypot))</span><br><span class="line">fmt.Println(compute(math.Pow))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-Function-closures"><a href="#19-Function-closures" class="headerlink" title="19.Function closures"></a>19.Function closures</h3><p>Go functions may be closures.</p><p>A closure is a function value that references variables from outside its body.</p><p>The function may access and assign to the referenced variables</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Methods-and-interfaces"><a href="#Methods-and-interfaces" class="headerlink" title="Methods and interfaces"></a>Methods and interfaces</h2><h3 id="1-Methods"><a href="#1-Methods" class="headerlink" title="1.Methods"></a>1.Methods</h3><p>Go does not have classes. However, you can define methods on types.</p><p>A method is a function with a special <em>receiver</em> argument.</p><p>The receiver appears in its own argument list <strong>between the</strong> <strong>func</strong> <strong>keyword and the method name.</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Remember: <strong>a method is just a function with a receiver argument.</strong></p><p>Here’s Abs written as a regular function with no change in functionality.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span><span class="params">(v Vertex)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(Abs(v))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You can declare a method on <strong>non-struct types</strong>, too.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Pointer receivers</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods with pointer receivers can modify the value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Scale(f <span class="type">float64</span>) &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    <span class="comment">// even though v is a value and not a pointer, the</span></span><br><span class="line">    <span class="comment">// method with the pointer receiver is called automatically.</span></span><br><span class="line">    <span class="comment">// but common functions that take a value argument must take</span></span><br><span class="line">    <span class="comment">// a value of that specific type:</span></span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Methods with pointer receivers can modify the value</strong> to which the receiver points (as Scale does here). Since methods often need to modify their receiver, <strong>pointer receivers are more common than value receivers</strong>.</p><p>It can <strong>avoid copying the value on each method call.</strong> This can be more efficient if the receiver is a large struct, for example.</p><p>With a value receiver, the Scale method operates on <strong>a copy of the original</strong> Vertex value. (This is the same behavior as for any other function argument.) The Scale method must have a pointer receiver to change the Vertex value declared in the main function.</p><h3 id="2-Interfaces"><a href="#2-Interfaces" class="headerlink" title="2.Interfaces"></a>2.Interfaces</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line"><span class="comment">// and does NOT implement Abser.</span></span><br><span class="line">a = v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// we don&#x27;t need to explicitly declare that it does so.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> Abs() <span class="type">float64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An <em>interface type</em> is defined as a set of method signatures.</p><p>A value of interface type can hold any value that implements those methods.</p><p>A type implements an interface by implementing its methods. <strong>There is no explicit declaration of intent, no “implements” keyword.</strong></p><p>Under the hood, <strong>interface values can be thought of as a tuple of a value and a concrete type:</strong></p><p><strong>(value, type)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> F <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f F)</span></span> M() &#123;</span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;Hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = F(math.Pi)</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the concrete value inside the interface itself is nil, the method will be called with a nil receiver.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> M() &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;&lt;nil&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">describe(i)</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i I)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In some languages this would trigger a null pointer exception, but in Go i<strong>t is common to write methods that gracefully handle being called with a nil receiver</strong> (as with the method M in this example.)</p><p>A nil interface value holds neither value nor concrete type.Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which <em>concrete</em> method to call.</p><p><strong>Empty Interface:</strong></p><p>The interface type that specifies zero methods is known as the <em>empty interface</em>:</p><p><strong>interface{}</strong></p><p>An empty interface may hold values of any type. (Every type implements at least zero methods.)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="number">42</span></span><br><span class="line">describe(i)</span><br><span class="line"></span><br><span class="line">i = <span class="string">&quot;hello&quot;</span></span><br><span class="line">describe(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;(%v, %T)\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.</p><p><strong>Type assertions</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This statement asserts that the interface value i holds the</span></span><br><span class="line">    <span class="comment">// concrete type T and assigns the underlying T value to the variable t.</span></span><br><span class="line">s := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s, ok := i.(<span class="type">string</span>)</span><br><span class="line">fmt.Println(s, ok)</span><br><span class="line"></span><br><span class="line">f, ok := i.(<span class="type">float64</span>)</span><br><span class="line">fmt.Println(f, ok)</span><br><span class="line"></span><br><span class="line">f = i.(<span class="type">float64</span>) <span class="comment">// panic</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Type switches</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;Twice %v is %v\n&quot;</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;%q is %v bytes long\n&quot;</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;I don&#x27;t know about type %T!\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">do(<span class="number">21</span>)</span><br><span class="line">do(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">do(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A type switch is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.</p><p><strong>Stringers</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := Person&#123;<span class="string">&quot;Arthur Dent&quot;</span>, <span class="number">42</span>&#125;</span><br><span class="line">z := Person&#123;<span class="string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="number">9001</span>&#125;</span><br><span class="line">fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>One of the most ubiquitous interfaces is <a href="https://golang.google.cn/pkg/fmt/#Stringer">Stringer</a> defined by the <a href="https://golang.google.cn/pkg/fmt/">fmt</a> package.</p><p>type Stringer interface { String() string }</p><p>A Stringer is a type that can describe itself as a string. The fmt package (and many others) look for this interface to print values.</p><h3 id="3-Errors"><a href="#3-Errors" class="headerlink" title="3.Errors"></a>3.Errors</h3><p>Go programs express error state with error values.</p><p>The error type is a built-in interface similar to fmt.Stringer:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(As with fmt.Stringer, the fmt package looks for the error interface when printing values.)</p><p>Functions often return an error value, and calling code should handle errors by testing whether the error equals nil.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(<span class="string">&quot;42&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;couldn&#x27;t convert number: %v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Converted integer:&quot;</span>, i)</span><br></pre></td></tr></table></figure><p>A nil error denotes success; a non-nil error denotes failure.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">When time.Time</span><br><span class="line">What <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">time.Now(),</span><br><span class="line"><span class="string">&quot;it didn&#x27;t work&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Readers"><a href="#4-Readers" class="headerlink" title="4.Readers"></a>4.Readers</h3><p>The io package specifies the io.Reader interface, which represents the read end of a stream of data.</p><p>The Go standard library contains <a href="https://cs.opensource.google/search?q=Read(\w%2B\s[]byte">many implementations</a>&amp;ss=go%2Fgo&gt;) of this interface, including files, network connections, compressors, ciphers, and others.</p><p>The io.Reader interface has a Read method:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>Read populates the given byte slice with data and returns the number of bytes populated and an error value. It returns an io.EOF error when the stream ends.</p><p>The example code creates a <a href="https://golang.google.cn/pkg/strings/#Reader">strings.Reader</a> and consumes its output 8 bytes at a time.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := strings.NewReader(<span class="string">&quot;Hello, Reader!&quot;</span>)</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := r.Read(b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n = %v err = %v b = %v\n&quot;</span>, n, err, b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b[:n] = %q\n&quot;</span>, b[:n])</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><h3 id="1-Type-parameter"><a href="#1-Type-parameter" class="headerlink" title="1.Type parameter"></a>1.Type parameter</h3><p>Go functions can be written to work on multiple types using type parameters. The type parameters of a function appear between brackets, before the function’s arguments.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Index returns the index of x in s, or -1 if not found.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(s []T, x T)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="comment">// v and x are type T, which has the comparable</span></span><br><span class="line"><span class="comment">// constraint, so we can use == here.</span></span><br><span class="line"><span class="keyword">if</span> v == x &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Index works on a slice of ints</span></span><br><span class="line">si := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">-10</span>&#125;</span><br><span class="line">fmt.Println(Index(si, <span class="number">15</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Index also works on a slice of strings</span></span><br><span class="line">ss := []<span class="type">string</span>&#123;<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>&#125;</span><br><span class="line">fmt.Println(Index(ss, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This declaration means that s is a slice of any type T that fulfills the built-in constraint comparable. x is also a value of the same type.</p><p>comparable is a useful constraint that makes it possible to use the == and != operators on values of the type. In this example, we use it to compare a value to all slice elements until a match is found. This Index function works for any type that supports comparison.</p><h3 id="3-Generic-types"><a href="#3-Generic-types" class="headerlink" title="3.Generic types"></a>3.Generic types</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// List represents a singly-linked list that holds</span></span><br><span class="line"><span class="comment">// values of any type.</span></span><br><span class="line"><span class="keyword">type</span> List[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">next *List[T]</span><br><span class="line">val  T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go also supports generic types. A type can be parameterized with a type parameter, which could be useful for implementing generic data structures.</p><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><h3 id="1-Goroutines"><a href="#1-Goroutines" class="headerlink" title="1.Goroutines"></a>1.Goroutines</h3><p>A <em>goroutine</em> is a lightweight thread managed by the Go runtime.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// starts a new goroutine running</span></span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Channels"><a href="#2-Channels" class="headerlink" title="2.Channels"></a>2.Channels</h3><p>Channels are a typed conduit through which you can send and receive values with the channel operator, &lt;-.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// Send v to channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// Receive from ch, and assign value to v.</span></span><br></pre></td></tr></table></figure><p>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Buffered-Channels"><a href="#3-Buffered-Channels" class="headerlink" title="3.Buffered Channels"></a>3.Buffered Channels</h3><p>Channels can be <em>buffered</em>. Provide the buffer length as the second argument to make to initialize a buffered channel:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sends to a buffered channel block only when the buffer is full. Receives block when the buffer is empty.</p><h3 id="4-Range-and-Close"><a href="#4-Range-and-Close" class="headerlink" title="4.Range and Close"></a>4.Range and Close</h3><p>A sender can <strong>close</strong> <strong>a channel to indicate that no more values will be sent</strong>. Receivers can <strong>test whether a channel has been closed</strong> by assigning a second parameter to the receive expression: after</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure><p>ok is false if there are no more values to receive and the channel is closed.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="comment">// The loop for i := range c receives values from the channel</span></span><br><span class="line">    <span class="comment">// repeatedly until it is closed.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.</p><p><strong>Another note:</strong> Channels aren’t like files; you don’t usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop.</p><h3 id="5-Select"><a href="#5-Select" class="headerlink" title="5.Select"></a>5.Select</h3><p>The select statement lets a goroutine wait on multiple communication operations.</p><p>A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x, y = y, x+y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">quit &lt;- <span class="number">0</span></span><br><span class="line">&#125;()</span><br><span class="line">fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while,The default case in a select is run if no other case is ready.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tick := time.Tick(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">boom := time.After(<span class="number">500</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-tick:</span><br><span class="line">fmt.Println(<span class="string">&quot;tick.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-boom:</span><br><span class="line">fmt.Println(<span class="string">&quot;BOOM!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;    .&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-sync-Mutex"><a href="#6-sync-Mutex" class="headerlink" title="6.sync.Mutex"></a>6.sync.Mutex</h3><p>We’ve seen how channels are great for communication among goroutines.</p><p>But what if we don’t need communication? What if we just want to make sure only one goroutine can access a variable at a time to avoid conflicts?</p><p>This concept is called <em>mutual exclusion</em>, and the conventional name for the data structure that provides it is <em>mutex</em>.</p><p>Go’s standard library provides mutual exclusion with <a href="https://golang.google.cn/pkg/sync/#Mutex">sync.Mutex</a> and its two methods:</p><ul><li>Lock</li><li>Unlock</li></ul><p>We can define a block of code to be executed in mutual exclusion by surrounding it with a call to Lock and Unlock as shown on the Inc method.</p><p>We can also use defer to ensure the mutex will be unlocked as in the Value method</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// SafeCounter is safe to use concurrently.</span></span><br><span class="line"><span class="keyword">type</span> SafeCounter <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line">v  <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Inc(key <span class="type">string</span>) &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line">c.v[key]++</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Value returns the current value of the counter for the given key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *SafeCounter)</span></span> Value(key <span class="type">string</span>) <span class="type">int</span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="comment">// Lock so only one goroutine at a time can access the map c.v.</span></span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> c.v[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := SafeCounter&#123;v: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> c.Inc(<span class="string">&quot;somekey&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(c.Value(<span class="string">&quot;somekey&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P125 验证回文串</title>
      <link href="/posts/125/"/>
      <url>/posts/125/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-17</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P125 验证回文串" href="https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P125 验证回文串</p><p class="url">https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>判断用双指针肯定快点，这里直接用标准库的 reverse 了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    string original;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        s[i] = s[i] - (<span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &amp;&amp; !(s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        s[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="string">&#x27;*&#x27;</span>), s.<span class="built_in">end</span>());</span><br><span class="line">    original = s;</span><br><span class="line">    std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">strcmp</span>(s.<span class="built_in">c_str</span>(), original.<span class="built_in">c_str</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 字符串 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3349 检测相邻递增子数组 I</title>
      <link href="/posts/3349/"/>
      <url>/posts/3349/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-14</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3349 检测相邻递增子数组 I" href="https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-i/description/?envType=daily-question&envId=2025-10-14"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3349 检测相邻递增子数组 I</p><p class="url">https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-i/description/?envType=daily-question&envId=2025-10-14</p></div></a></div></p><p>用两个指针分别比对即可，如果在某处不匹配，那么直接把指针移向这个位置重新开始匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hasIncreasingSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = k;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"> loop:</span><br><span class="line">    <span class="keyword">while</span> (b + k - <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[a + i] &gt; nums[a + i - <span class="number">1</span>] &amp;&amp; nums[b + i] &gt; nums[b + i - <span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          a += i;</span><br><span class="line">          b = a + k;</span><br><span class="line">          <span class="keyword">goto</span> loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution s;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.<span class="built_in">hasIncreasingSubarrays</span>(vec, <span class="number">3</span>));</span><br><span class="line">  vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.<span class="built_in">hasIncreasingSubarrays</span>(vec, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3539 魔法序列的数组乘积之和</title>
      <link href="/posts/3539/"/>
      <url>/posts/3539/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3539 魔法序列的数组乘积之和" href="https://leetcode.cn/problems/find-sum-of-array-product-of-magical-sequences/?envType=daily-question&envId=2025-10-12"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3539 魔法序列的数组乘积之和</p><p class="url">https://leetcode.cn/problems/find-sum-of-array-product-of-magical-sequences/?envType=daily-question&envId=2025-10-12</p></div></a></div></p><h2 id="尝试穷举"><a href="#尝试穷举" class="headerlink" title="尝试穷举"></a>尝试穷举</h2><p>我最开始只想到了穷举，但是穷举也没穷举完整，难受了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::stack;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>; <span class="comment">// 10^9 + 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">magicalSeq</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;seq, <span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 魔法序列：seq 的序列长度为 m。</span></span><br><span class="line">    <span class="comment">// 0 &lt;= seq[i] &lt; nums.length</span></span><br><span class="line">    <span class="comment">// 2^seq[0] + 2^seq[1] + ... + 2^seq[m - 1] 的 二进制形式 有 m 个 置位。</span></span><br><span class="line">    <span class="comment">// 也就是说&#123;seq[0], seq[1] ..seq[M-1]&#125;中,如果两个数相同</span></span><br><span class="line">    <span class="comment">// 递归地将相同的数合并成一个原来的数值+1，直到没有相同地数为止</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> set = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (seq.<span class="built_in">size</span>() != m) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(seq.<span class="built_in">begin</span>(), seq.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seq[<span class="number">0</span>] &lt; <span class="number">0</span> || seq[m - <span class="number">1</span>] &gt;= length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">st</span>(seq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      val = st.<span class="built_in">top</span>();</span><br><span class="line">      st.<span class="built_in">pop</span>();</span><br><span class="line">      set++;</span><br><span class="line">      <span class="keyword">if</span> (!st.<span class="built_in">empty</span>() &amp;&amp; val == st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        st.<span class="built_in">top</span>()++;</span><br><span class="line">        set--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (set == k) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">magicalSum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> magical_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> array_mul;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="type">int</span> res_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &lt;= n) &#123;</span><br><span class="line">      <span class="comment">// 生成长度为m的nums的所有子序列</span></span><br><span class="line">      <span class="comment">// predict数组，类似于SVE指令</span></span><br><span class="line">      <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">predict</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="comment">// 从字典序最小的开始</span></span><br><span class="line">      std::<span class="built_in">fill</span>(predict.<span class="built_in">end</span>() - m, predict.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (predict[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(i);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">      &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(predict.<span class="built_in">begin</span>(), predict.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res_size = result.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 判断是不是magic sequence</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; res_size; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">magicalSeq</span>(result[i], m, k, n)) &#123;</span><br><span class="line">        <span class="comment">// 如果是magic sequence，计算它的全排列的数组乘积</span></span><br><span class="line">        <span class="comment">// 但如果数字相同，排列不同，数组乘积是一样的</span></span><br><span class="line">        <span class="comment">// 因此直接乘以 m 的阶乘</span></span><br><span class="line">        array_mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">          array_mul = (array_mul * nums[result[i][j]]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">          array_mul = (array_mul * j) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        magical_sum = (magical_sum + array_mul) % MOD;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> magical_sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>这题题解还是用动态规划，不过这动态规划诗人握持。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数 <code>M</code> 和 <code>K</code>，和一个整数数组 <code>nums</code>。</p><p>一个整数序列 <code>seq</code> 如果满足以下条件，被称为 <strong>魔法</strong> 序列：</p><ul><li><code>seq</code> 的序列长度为 <code>M</code>。</li><li><code>0 &lt;= seq[i] &lt; nums.length</code></li><li><code>2^seq[0] + 2^seq[1] + ... + 2^seq[M - 1]</code> 的 <strong>二进制形式</strong> 有 <code>K</code> 个 <strong>置位</strong>。</li></ul><p>这个序列的 <strong>数组乘积</strong> 定义为 <code>prod(seq) = (nums[seq[0]] * nums[seq[1]] * ... * nums[seq[M - 1]])</code>。</p><p>返回所有有效 <strong>魔法</strong> 序列的 <strong>数组乘积</strong> 的 <strong>总和</strong> 。</p><p>由于答案可能很大，返回结果对 <code>10^9 + 7</code> <strong>取模</strong>。</p><p><strong>置位</strong> 是指一个数字的二进制表示中值为 1 的位。</p><p>我们要做的是：</p><ul><li>给定数组 <code>nums</code>，长度 <code>n</code>  </li><li>取长度为 <code>M</code> 的序列 <code>seq</code>（可以重复选择 nums 中的元素）  </li><li>条件：<code>2^seq[0] + ... + 2^seq[M-1]</code> 二进制中有 <code>K</code> 个 1  </li><li>数组乘积：<code>prod(seq) = nums[seq[0]] * ... * nums[seq[M-1]]</code>  </li><li>目标：所有魔法序列数组乘积的和（mod 1e9+7）  </li></ul><h3 id="序列排列数"><a href="#序列排列数" class="headerlink" title="序列排列数"></a><strong>序列排列数</strong></h3><p>假设我们从 <code>nums</code> 下标 <code>0..n-1</code> 取数：</p><ul><li>每个数 <code>i</code> 取了 <code>r_i</code> 个  </li><li>总数满足：<code>r_0 + r_1 + ... + r_&#123;n-1&#125; = M</code>  </li></ul><p>长度为 M 的排列数：</p><script type="math/tex; mode=display">\frac{M!}{r_0! \, r_1! \, ... \, r_{n-1}!}</script><blockquote><p> <strong>长度为 M 的排列数公式</strong></p><p><strong>不考虑重复数字的排列数</strong></p><ul><li>如果 <strong>所有数字都不同</strong>，长度为 M 的序列排列数就是 <strong>M!</strong><ul><li>因为 M 个不同的元素可以有 M! 种排列</li></ul></li></ul><p><strong>考虑重复数字</strong></p><ul><li>如果某些数字重复出现，例如：</li></ul><script type="math/tex; mode=display">seq = [a, a, b, b, b, c]</script><ul><li>重复的数字交换不会产生新序列</li><li>在组合数学中，我们要 <strong>除以每个重复数字的阶乘</strong>，消除重复排列的影响</li><li>假设数字 i 出现了 <code>r_i</code> 次，总排列数公式为：</li></ul><script type="math/tex; mode=display">\text{排列数} = \frac{M!}{r_0! \, r_1! \, \dots \, r_{n-1}!}</script><p>这是经典的<strong>多重集排列公式</strong>：长度为 M 的排列数 = 总元素阶乘 / 每种重复元素的阶乘</p></blockquote><h3 id="数组乘积"><a href="#数组乘积" class="headerlink" title="数组乘积"></a><strong>数组乘积</strong></h3><script type="math/tex; mode=display">\prod_{i=0}^{n-1} nums[i]^{r_i} \cdot \frac{M!}{r_0! \, r_1! \, ... \, r_{n-1}!}</script><blockquote><p><strong>数组乘积公式</strong></p><p>序列的数组乘积定义为：</p><script type="math/tex; mode=display">\text{prod(seq)} = nums[seq[0]] \cdot nums[seq[1]] \cdot \dots \cdot nums[seq[M-1]]</script><ul><li>如果数字 i 在序列中出现了 <code>r_i</code> 次，则乘积可以写成：</li></ul><script type="math/tex; mode=display">\prod_{i=0}^{n-1} nums[i]^{r_i}</script><ul><li><strong>结合排列数</strong>，某一序列{ r<em>0, r_1, r_2, … ,r</em>{n-1} }序列总贡献为：</li></ul><script type="math/tex; mode=display">\text{总贡献} = \frac{M!}{r_0! \, r_1! \, ... \, r_{n-1}!} \cdot \prod_{i=0}^{n-1} nums[i]^{r_i}</script><ul><li>解释：<ul><li>每种长度为 M 的序列对应的数组乘积是 <code>∏ nums[i]^r_i</code></li><li>总共有 <code>M! / ∏ r_i!</code> 种排列（因为重复数字排列不算新的序列）</li><li>所以 <strong>乘起来就是该组合的总贡献</strong></li></ul></li></ul></blockquote><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a><strong>动态规划思路</strong></h3><p>用DP模拟二进制加法进位规律</p><ul><li>枚举所有可能的 <code>r_i</code>（每个数出现次数）很复杂  </li><li>动态规划的思路：<strong>逐个考虑 nums 中的数字</strong>  </li></ul><h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a><strong>状态定义</strong></h3><ul><li><code>f[i][j][p][q]</code> 表示：<ul><li>已考虑前 <code>i</code> 个数（nums[0..i]）  </li><li>已取总数 <code>j</code>  </li><li>当前 mask(进位状态) 的低 i 位和为 <code>p</code>  </li><li>低 i 位的置位数为 <code>q</code>  </li><li>值 = 对应所有序列 <code>∏ r_t! * nums[t]^r_t</code> 的和，也就是所有这些情况的贡献之和</li></ul></li></ul><h3 id="转移公式"><a href="#转移公式" class="headerlink" title="转移公式"></a><strong>转移公式</strong></h3><p>当考虑第 <code>i+1</code> 个数：</p><ul><li>假设选了 <code>r</code> 个 <code>nums[i+1]</code>  </li><li>新状态：</li></ul><script type="math/tex; mode=display">f[i+1][j+r][\lfloor p/2 \rfloor + r][q + (p \bmod 2)] += f[i][j][p][q] * nums[i+1]^r * r!</script><ul><li><code>p/2</code> 和 <code>p%2</code> 的作用：<ul><li>模拟 mask 的二进制从低位到高位拆开  </li><li><code>p % 2</code> = 低位的置位数  </li><li><code>p / 2</code> = 上移一位后的 mask  </li></ul></li></ul><p><strong>初始化</strong></p><ul><li>对 <code>i=0</code>，也就是第一个数字：</li></ul><script type="math/tex; mode=display">f[0][j][j][0] = nums[0]^j * j!</script><ul><li>低 0 位置位数 = 0</li></ul><hr><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ul><li>mask 总置位数 = 高位 mask 的置位数 + 低位 q  </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_popcount(p) + q == K)</span><br><span class="line">    res += f[n<span class="number">-1</span>][M][p][q] * M!</span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码中利用到了很多技巧，这里先介绍以下</p><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p><strong>核心思想</strong></p><p>利用指数的<strong>二进制表示</strong>和<strong>幂的拆分性质</strong>：</p><script type="math/tex; mode=display">x^y = x^{(b_0·2^0 + b_1·2^1 + ... + b_k·2^k)} = \prod_{i | b_i=1} x^{2^i}</script><p>也就是说：</p><ul><li>把 <code>y</code> 看成二进制；</li><li>每次平方底数，相当于翻倍指数；</li><li>如果当前二进制位是 1，就把这一项乘进结果</li></ul><p><strong>举例</strong></p><p>假设我们要计算：</p><script type="math/tex; mode=display">3^{13}</script><p>13 的二进制是：<code>1101₂ = 8 + 4 + 0 + 1</code></p><p>所以：</p><script type="math/tex; mode=display">3^{13} = 3^{8} × 3^{4} × 3^{1}</script><p>我们可以通过不断平方得到这些幂次：</p><div class="table-container"><table><thead><tr><th>步骤</th><th>幂次</th><th>结果</th></tr></thead><tbody><tr><td>3¹</td><td>3</td><td></td></tr><tr><td>3²</td><td>9</td><td></td></tr><tr><td>3⁴</td><td>81</td><td></td></tr><tr><td>3⁸</td><td>6561</td></tr></tbody></table></div><p>所以：</p><script type="math/tex; mode=display">3^{13} = 3⁸ × 3⁴ × 3¹ = 6561 × 81 × 3 = 1594323</script><p><strong>对应算法逻辑</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cur = x;  <span class="comment">// 当前底数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res *= cur;  <span class="comment">// 当前位是1 → 把当前幂次乘进去</span></span><br><span class="line">        &#125;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;         <span class="comment">// 右移一位，相当于除以2</span></span><br><span class="line">        cur *= cur;      <span class="comment">// 底数平方 → 指数翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>根据<strong>费马小定理（Fermat’s Little Theorem）</strong>：</p><script type="math/tex; mode=display">a^{p-1} ≡ 1 \pmod{p}</script><p>所以：</p><script type="math/tex; mode=display">a^{p-2} ≡ a^{-1} \pmod{p}</script><p>费马小定理要求p必须是一个质数</p><p>也就是说：</p><blockquote><p>一个数的模逆元 = 这个数的 (mod - 2) 次方 取模。</p></blockquote><h4 id="最终代码实现"><a href="#最终代码实现" class="headerlink" title="最终代码实现"></a>最终代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickmul</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>, cur = x % mod;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">      <span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        res = res * cur % mod;</span><br><span class="line">      &#125;</span><br><span class="line">      y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      cur = cur * cur % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">magicalSum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算1~m的阶乘</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">fac</span><span class="params">(m + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ifac[i]=(i!)^(−1) mod mod</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ifac</span><span class="params">(m + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      <span class="comment">// 利用费马小定理计算每个i的模逆元</span></span><br><span class="line">      ifac[i] = <span class="built_in">quickmul</span>(i, mod - <span class="number">2</span>, mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用递推关系把单个整数的逆元变成阶乘逆元</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">      ifac[i] = ifac[i - <span class="number">1</span>] * ifac[i] % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// numsPower[i][j] 表示 nums[i] 的 j 次幂模 mod</span></span><br><span class="line">    <span class="comment">// 如果i在序列中出现了j次，那么这个序列的乘积就是遍历所有序列i，</span></span><br><span class="line">    <span class="comment">// 累乘numsPower[i][j]</span></span><br><span class="line">    <span class="function">vector <span class="title">numsPower</span><span class="params">(n, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m + <span class="number">1</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        numsPower[i][j] = numsPower[i][j - <span class="number">1</span>] * nums[i] % mod;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector <span class="title">f</span><span class="params">(n, vector(m + <span class="number">1</span>, vector(m * <span class="number">2</span> + <span class="number">1</span>, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;(k + <span class="number">1</span>, <span class="number">0</span>))))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">      f[<span class="number">0</span>][j][j][<span class="number">0</span>] = numsPower[<span class="number">0</span>][j] * ifac[j] % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt;= m * <span class="number">2</span>; p++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> q = <span class="number">0</span>; q &lt;= k; q++) &#123;</span><br><span class="line">            <span class="type">int</span> q2 = p % <span class="number">2</span> + q;</span><br><span class="line">            <span class="keyword">if</span> (q2 &gt; k) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r + j &lt;= m; r++) &#123;</span><br><span class="line">              <span class="type">int</span> p2 = p / <span class="number">2</span> + r;</span><br><span class="line">              f[i + <span class="number">1</span>][j + r][p2][q2] +=</span><br><span class="line">                  f[i][j][p][q] * numsPower[i + <span class="number">1</span>][r] % mod * ifac[r] % mod;</span><br><span class="line">              f[i + <span class="number">1</span>][j + r][p2][q2] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">0</span>; p &lt;= m * <span class="number">2</span>; p++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> q = <span class="number">0</span>; q &lt;= k; q++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(p) + q == k) &#123;</span><br><span class="line">          res = (res + f[n - <span class="number">1</span>][m][p][q] * fac[m] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P58 最后一个单词的长度</title>
      <link href="/posts/58/"/>
      <url>/posts/58/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P58 最后一个单词的长度" href="https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P58 最后一个单词的长度</p><p class="url">https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>直接查找两个点，第一个是最后一个单词的结束单词，第二个是最后一个单词开始的前一个。注意start要初始化为-1，是为了应对s = ‘a’这种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = len - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (std::<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">        end = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!std::<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">        start = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 字符串 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3186 施咒的最大总伤害</title>
      <link href="/posts/3186/"/>
      <url>/posts/3186/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-11</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3186 施咒的最大总伤害" href="https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/?envType=daily-question&envId=2025-10-11"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3186 施咒的最大总伤害</p><p class="url">https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/?envType=daily-question&envId=2025-10-11</p></div></a></div></p><p>由于可能存在相同伤害的咒语，而如果选择了有多个同伤害的咒语，那么总伤害要加上该伤害*该伤害咒语的数量。因此我们可以先保存每个伤害值的咒语数量，然后将power去重。<br>将power去重排序后，令 f(i) 表示从第 0 到 i 种咒语中选择，并且最后选择第 i 种咒语的最大总伤害，可列出状态转移方程：</p><script type="math/tex; mode=display">f[i] = \text{power}[i] + \max_{0\le j < i, \, power[j] \le power[i] - 2} f[j]</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumTotalDamage</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;power)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 令 f(i) 表示从第 0 到 i 种咒语中选择，并且最后选择第 i 种咒语的最大总伤害</span></span><br><span class="line">    <span class="comment">// f(i) = max(f(j), j&lt; i &amp;&amp; power[j] &lt; power[i]-2) + power[i] * mp[power[i]]</span></span><br><span class="line">    <span class="type">int</span> i, j, n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> max = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">long</span>, <span class="type">long</span>&gt; count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p : power) &#123;</span><br><span class="line">      count[p]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    power.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(power.<span class="built_in">begin</span>(), power.<span class="built_in">end</span>()), power.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(power.<span class="built_in">begin</span>(), power.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    n = power.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">f</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    f[<span class="number">0</span>] = power[<span class="number">0</span>] * count[power[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &lt; i &amp;&amp; power[j] &lt; power[i] - <span class="number">2</span>) &#123;</span><br><span class="line">        max = std::<span class="built_in">max</span>(max, f[j]);</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      f[i] = max + power[i] * count[power[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = *std::<span class="built_in">max_element</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3147 从魔法师身上吸取的最大能量</title>
      <link href="/posts/3147/"/>
      <url>/posts/3147/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-10</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3147 从魔法师身上吸取的最大能量" href="https://leetcode.cn/problems/taking-maximum-energy-from-the-mystic-dungeon/?envType=daily-question&envId=2025-10-10"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3147 从魔法师身上吸取的最大能量</p><p class="url">https://leetcode.cn/problems/taking-maximum-energy-from-the-mystic-dungeon/?envType=daily-question&envId=2025-10-10</p></div></a></div></p><h1 id="从后向前遍历"><a href="#从后向前遍历" class="headerlink" title="从后向前遍历"></a>从后向前遍历</h1><p>假设需要从 0..k-1 开始，一共有路径{0..k-1} - {n-1-k..n-1}<br>每条路径起点为 0~k-1，计算每条路径的从某一起点开始的最大能量，然后从这几个路径的最大能量中找最大的。<br>对于一条路径的最大能量就是找从一个起点开始到最后一个值的最大和，那么不妨从最后一个起点向前遍历，记录最大和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maximumEnergy</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;energy, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = energy.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">way</span><span class="params">(n, INT_MIN)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">// 每条路径</span></span><br><span class="line">      j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i + j * k &lt; n) &#123;</span><br><span class="line">        j++;</span><br><span class="line">      &#125;</span><br><span class="line">      j--;</span><br><span class="line">      total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        total += energy[i + j * k];</span><br><span class="line">        way[i] = std::<span class="built_in">max</span>(way[i], total);</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *std::<span class="built_in">max_element</span>(way.<span class="built_in">begin</span>(), way.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution s;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">-10</span>, <span class="number">-5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.<span class="built_in">maximumEnergy</span>(vec, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>因为最大能量和以前的状态有关，所以也可以用动态规划来解决：<br>假设 dp[i]为到达第 i 个魔法师所获得的最大能量,那么</p><script type="math/tex; mode=display">\text dp[i] = \text max(energy[i] \space,\space dp[i-k] + \text energy[i])</script><p>边界条件：</p><script type="math/tex; mode=display">  \text dp[i] = energy[i] \space \text(i<k)</script><p>由于最终到到达没有魔法师的区域，那么必须要到达最后 k 的魔法师。因此最终最大值从最后 k 个 dp 里找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maximumEnergy</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;energy, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = energy.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">copy</span>(energy.<span class="built_in">begin</span>(), energy.<span class="built_in">end</span>(), dp.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; n; i++) &#123;</span><br><span class="line">      dp[i] = std::<span class="built_in">max</span>(energy[i], dp[i - k] + energy[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = *std::<span class="built_in">max_element</span>(dp.<span class="built_in">end</span>() - k, dp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校园网连接脚本</title>
      <link href="/posts/50007/"/>
      <url>/posts/50007/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-09</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>首先先启用 wlan，然后让 wlan 连接校园网，树莓派可以用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> raspi-config</span><br></pre></td></tr></table></figure><p>然后在 System Option 里面,Wireless LAN 输入 ssid 和 passphrase</p><p>或者写入/etc/wpa_supplicant/wpa_supplicant.conf</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ctrl_interface</span>=DIR=/run/wpa_supplicant <span class="attribute">GROUP</span>=netdev</span><br><span class="line"><span class="attribute">update_config</span>=1</span><br><span class="line"><span class="attribute">country</span>=CN</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">    <span class="attribute">ssid</span>=<span class="string">&quot;HNU&quot;</span></span><br><span class="line">    <span class="attribute">key_mgmt</span>=NONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启 wpa_supplicant 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart wpa_supplicant</span><br></pre></td></tr></table></figure><p>上述操作后通过 ifconfig 命令查看 wlan 的 inet 是否有 ip 地址了，有了说明已经连接上了校园网，下一步通过认证即可。</p><p>如果没有成功，则调用以下命令查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u wpa_supplicant -n 50 --no-pager</span><br></pre></td></tr></table></figure><p>抓包：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510091252499.png" alt="fiddler抓包"></p><p>通过抓包可写如下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先获取 wlan0 的 IPv4 和 MAC</span></span><br><span class="line">IP=$(ip -4 -o addr show wlan0 | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> | <span class="built_in">cut</span> -d/ -f1)</span><br><span class="line">MAC=$(<span class="built_in">cat</span> /sys/class/net/wlan0/address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USER=<span class="string">&quot;,0,your_student_number&quot;</span></span><br><span class="line">PASS=<span class="string">&quot;your_password&quot;</span></span><br><span class="line"></span><br><span class="line">curl -s --get <span class="string">&quot;https://web.hnu.edu.cn:802/eportal/portal/login&quot;</span> \</span><br><span class="line">     --data-urlencode <span class="string">&quot;callback=dr1003&quot;</span> \</span><br><span class="line">     --data-urlencode <span class="string">&quot;login_method=1&quot;</span> \</span><br><span class="line">     --data-urlencode <span class="string">&quot;user_account=<span class="variable">$&#123;USER&#125;</span>&quot;</span> \</span><br><span class="line">     --data-urlencode <span class="string">&quot;user_password=<span class="variable">$&#123;PASS&#125;</span>&quot;</span> \</span><br><span class="line">     --data-urlencode <span class="string">&quot;wlan_user_ip=<span class="variable">$&#123;IP&#125;</span>&quot;</span> \</span><br><span class="line">     --data-urlencode <span class="string">&quot;wlan_user_mac=<span class="variable">$&#123;MAC&#125;</span>&quot;</span> \</span><br><span class="line">     --data-urlencode <span class="string">&quot;terminal_type=1&quot;</span> \</span><br><span class="line">     --insecure \</span><br><span class="line">     -D - \</span><br><span class="line">    | sed -n <span class="string">&#x27;1,200p&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上面脚本后，测试是否连接成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P28 找出字符串中第一个匹配项的下标</title>
      <link href="/posts/28/"/>
      <url>/posts/28/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-06</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P28 找出字符串中第一个匹配项的下标" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P28 找出字符串中第一个匹配项的下标</p><p class="url">https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>这题考察KMP的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//设置哨兵</span></span><br><span class="line">        s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        p.<span class="built_in">insert</span>(p.<span class="built_in">begin</span>(),<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//预处理next数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> p[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//匹配过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j <span class="keyword">and</span> s[i] != p[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i - m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>可以直接用C++的string.find函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123; <span class="keyword">return</span> haystack.<span class="built_in">find</span>(needle); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P134 加油站</title>
      <link href="/posts/134/"/>
      <url>/posts/134/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-05</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P134 加油站" href="https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P134 加油站</p><p class="url">https://leetcode.cn/problems/gas-station/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>非贪心算法：基于这样一个事实，如果从i到某一点j之后发现油不够了，那么i~j之间的所有点，因为假设i~j某一点k，从k出发，少了i~k的油量(从i出发能到k说明到k时油量&gt;=0)更不可能到达j+1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;gas, vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// int start = -1;</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> curr_gas;</span><br><span class="line">    <span class="type">int</span> i, idx;</span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//   // 到达i前至少有多少油才能去下一个</span></span><br><span class="line">    <span class="comment">//   if (gas[i] - cost[i] &gt;= 0) &#123;</span></span><br><span class="line">    <span class="comment">//     start = i;</span></span><br><span class="line">    <span class="comment">//     break;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// if (start == -1) &#123;</span></span><br><span class="line">    <span class="comment">//   return -1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">      curr_gas = <span class="number">0</span>;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 走一圈</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        idx = (start + i) % n;</span><br><span class="line">        curr_gas += gas[idx] - cost[idx];</span><br><span class="line">        <span class="keyword">if</span> (curr_gas &lt; <span class="number">0</span>) &#123;      <span class="comment">// 路线失败</span></span><br><span class="line">          start = start + i + <span class="number">1</span>; <span class="comment">// 直接跳过失败区间</span></span><br><span class="line">          <span class="comment">// 成功绕一圈</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == n)</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>标准的贪心解法：<br>我们是要找一个起点 start，使得从 start 出发沿环路绕一圈，油量永远 ≥ 0。</p><ol><li>首先，同样地如果从i到某一点j之后发现油不够了，那么i~j之间的所有点，因为假设i~j某一点k，从k出发，少了i~k的油量更不可能到达j+1；</li><li>其次对于全部环路总油量total：如果 total &lt; 0，说明整个环路油量不够，无论起点哪儿都不可能成功 → 返回 -1,如果 total &gt;= 0，一定存在唯一一个可以成功的起点，这就是贪心方法最后返回的 start。</li><li>再者，我们从 0 遍历到 n-1 时，已经筛掉了所有不可能的起点。并且题目保证“<strong>如果存在解，则 保证 它是 唯一 的</strong>”。若最终 total &gt;= 0，说明从最后一个 start 出发是可行的。这就说明了只需要遍历一遍是可行的。</li></ol><p>那为什么只需遍历0~n-1就结束了呢？</p><p>形象一点来讲：当 curr_gas &lt; 0 时我们总是把起点重置到“油量曲线最低谷”的下一个位置，所以最终的 start 是全局最低点之后的第一个站；而 total &gt;= 0 说明从最低点之后开始，油量永远不会再跌破 0，因此能绕一整圈。</p><p>用反证法：假设最终该解法返回start,在start~n-1之间有一点k，因为结果是唯一的，如果start绕不了一圈，而是k能绕一圈，但是由于start能够到达k，所以start应该也能绕一圈，与前提存在解则唯一矛盾，因此只需遍历只需要在total&gt;=0的情况下，存在start可以到达n-1就是所需结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;       <span class="comment">// 总油量差</span></span><br><span class="line">        <span class="type">int</span> curr_gas = <span class="number">0</span>;    <span class="comment">// 当前区间油量差</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;       <span class="comment">// 当前起点</span></span><br><span class="line">        <span class="type">int</span> diff;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            diff = gas[i] - cost[i];</span><br><span class="line">            total += diff;</span><br><span class="line">            curr_gas += diff;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前区间油量为负，则不可能从 start 到 i+1</span></span><br><span class="line">            <span class="keyword">if</span> (curr_gas &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 下一站作为新的起点</span></span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                curr_gas = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总油量小于 0，说明无解</span></span><br><span class="line">        <span class="keyword">return</span> (total &gt;= <span class="number">0</span>) ? start : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 贪心 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P238 除自身以外数组的乘积</title>
      <link href="/posts/238/"/>
      <url>/posts/238/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-05</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P238 除自身以外数组的乘积" href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P238 除自身以外数组的乘积</p><p class="url">https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div><br>前缀和（Prefix Sum） 是算法中最常见、最实用的“预处理技巧”之一。它可以让你 快速求任意区间的和，从而极大地加速计算。</p><p>给定一个数组：</p><script type="math/tex; mode=display">nums = [a₁, a₂, a₃, ..., aₙ]</script><p>我们定义它的 前缀和数组 prefix 为：(即前 i 个数的和)</p><script type="math/tex; mode=display">prefix[i] = a₁ + a₂ + ... + aᵢ</script><p>并约定：prefix[0] = 0  </p><p>这题是乘法，所以prefix[0] = 1;<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// n&gt;=2</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">suffix</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n)</span></span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      prefix[i] = nums[i - <span class="number">1</span>] * prefix[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    suffix[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      suffix[i] = nums[i + <span class="number">1</span>] * suffix[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      result[i] = prefix[i] * suffix[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P417 太平洋大西洋水流问题</title>
      <link href="/posts/417/"/>
      <url>/posts/417/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-05</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P417 太平洋大西洋水流问题" href="https://leetcode.cn/problems/pacific-atlantic-water-flow/description/?envType=daily-question&envId=2025-10-05"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P417 太平洋大西洋水流问题</p><p class="url">https://leetcode.cn/problems/pacific-atlantic-water-flow/description/?envType=daily-question&envId=2025-10-05</p></div></a></div></p><p><strong>多源BFS</strong>就是从多个起点（sources）同时开始 BFS。它的关键思想是：把多个“源点”都放入队列作为初始层（第0层），然后一次 BFS 把它们同时向外扩展。这相当于所有源点一起“扩散波动”，每个节点第一次被访问到的层数就是到最近源点的最短距离。</p><p>这个题如果用普通BFS要对每个顶点都得做一次BFS，因此用多源BFS会更好，即如果一个单元格能流到某海洋(太平洋或大西洋)那么高于它的邻居必定也能流到该单元格能到达的海洋。<br>初始化时让岛岸边的所有点入队，即边界上的所有单元格，每次出队一个单元格，如果该单元格的邻居中高度高于该单元格的，那么该单元格能到达的海洋，这个邻居也能到达。<br>关键问题是如何处理重复的问题，每个单元格有两个状态，只有固定了这两个状态，确定这两个状态不会改变了，才是处理完成的。因此如果在四个邻居的处理中某个邻居的状态没有发生改变，就不让它入队，将发生状态改变的邻居入队。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;heights) &#123;</span><br><span class="line">    <span class="type">int</span> m = heights.<span class="built_in">size</span>(), n = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> neighbor_i, neighbor_j;</span><br><span class="line">    <span class="comment">// (i-1, j) (i,j+1) (i+1,j)  (i,j-1)</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; <span class="built_in">vec</span>(m, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(n, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;));</span><br><span class="line">    <span class="type">bool</span> updated = <span class="literal">false</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一行和最后一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      vec[<span class="number">0</span>][j].first = <span class="number">1</span>;</span><br><span class="line">      vec[m - <span class="number">1</span>][j].second = <span class="number">1</span>;</span><br><span class="line">      que.<span class="built_in">push</span>(&#123;<span class="number">0</span>, j&#125;);</span><br><span class="line">      que.<span class="built_in">push</span>(&#123;m - <span class="number">1</span>, j&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一列和最后一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      vec[i][<span class="number">0</span>].first = <span class="number">1</span>;</span><br><span class="line">      vec[i][n - <span class="number">1</span>].second = <span class="number">1</span>;</span><br><span class="line">      que.<span class="built_in">push</span>(&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">      que.<span class="built_in">push</span>(&#123;i, n - <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      i = que.<span class="built_in">front</span>().first;</span><br><span class="line">      j = que.<span class="built_in">front</span>().second;</span><br><span class="line"></span><br><span class="line">      que.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">// 可以到Ocean，那么高于它的邻居也可以到</span></span><br><span class="line">      <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++) &#123;</span><br><span class="line">        neighbor_i = i + arr[k];</span><br><span class="line">        neighbor_j = j + arr[k + <span class="number">1</span>];</span><br><span class="line">        updated = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((neighbor_i &gt;= <span class="number">0</span> &amp;&amp; neighbor_i &lt; m &amp;&amp; neighbor_j &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">             neighbor_j &lt; n) &amp;&amp;</span><br><span class="line">            heights[neighbor_i][neighbor_j] &gt;= heights[i][j]) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (vec[i][j].first == <span class="number">1</span> &amp;&amp; vec[neighbor_i][neighbor_j].first != <span class="number">1</span>) &#123;</span><br><span class="line">            vec[neighbor_i][neighbor_j].first = <span class="number">1</span>;</span><br><span class="line">            updated = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (vec[i][j].second == <span class="number">1</span> &amp;&amp;</span><br><span class="line">              vec[neighbor_i][neighbor_j].second != <span class="number">1</span>) &#123;</span><br><span class="line">            vec[neighbor_i][neighbor_j].second = <span class="number">1</span>;</span><br><span class="line">            updated = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 邻居加入que，只有当邻居状态被改变时才加入</span></span><br><span class="line">          <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(&#123;neighbor_i, neighbor_j&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i][j].first == <span class="number">1</span> &amp;&amp; vec[i][j].second == <span class="number">1</span>) &#123;</span><br><span class="line">          result.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P380 O(1) 时间插入、删除和获取随机元素</title>
      <link href="/posts/380/"/>
      <url>/posts/380/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-04</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P380 O(1) 时间插入、删除和获取随机元素" href="https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P380 O(1) 时间插入、删除和获取随机元素</p><p class="url">https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>这题我本来以为 getRandom 只要概率相同即可，但是这个题检测时大概率设置了随机数种子，如果不是调用 rand()得出来的顺序必定和答案不同。<br>这题主要用 hashmap 存储 val,index，用 vector 做随机访问插入时直接放入 vector 的最后一位，删除时将被删除的元素与最后一个元素交换位置，然后弹出最后一个元素 pop_back(),要记得更改 hashmap 中因为交换而使得最后一个元素的 Index。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RandomizedSet</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (umap.<span class="built_in">count</span>(val) == <span class="number">0</span>) &#123;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">      umap[val] = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (umap.<span class="built_in">count</span>(val) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      umap[vec.<span class="built_in">back</span>()] = umap[val];</span><br><span class="line">      std::<span class="built_in">swap</span>(vec[umap[val]], vec.<span class="built_in">back</span>());</span><br><span class="line"></span><br><span class="line">      vec.<span class="built_in">pop_back</span>();</span><br><span class="line">      umap.<span class="built_in">erase</span>(val);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> vec[std::<span class="built_in">rand</span>() % vec.<span class="built_in">size</span>()]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P11 盛水最多的容器</title>
      <link href="/posts/11/"/>
      <url>/posts/11/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-04</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P11 盛水最多的容器" href="https://leetcode.cn/problems/container-with-most-water/description/?envType=daily-question&envId=2025-10-04"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P11 盛水最多的容器</p><p class="url">https://leetcode.cn/problems/container-with-most-water/description/?envType=daily-question&envId=2025-10-04</p></div></a></div></p><p>这题是经典的双指针题，但是我最开始的解法并未利用双指针，而是基于这样一个事实：<br>如果某一个端点构成容器的一侧，那么构成容器盛水最多的另一个端点是离它最远的且大于或等于它的高度的端点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从height最小的开始，离当前的端点最远且大于等于height的(左右都要寻找)</span></span><br><span class="line">    <span class="type">int</span> n, i, j;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> curr_height;</span><br><span class="line">    n = height.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      curr_height = height[i];</span><br><span class="line">      <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[j] &gt;= curr_height) &#123;</span><br><span class="line">          max = std::<span class="built_in">max</span>(max, curr_height * (j - i));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[j] &gt;= curr_height) &#123;</span><br><span class="line">          max = std::<span class="built_in">max</span>(max, curr_height * (i-j));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述解法虽然优化了暴力双循环，但最坏时间复杂度还是 O(n^2)还是不如双指针效率高：</p><ul><li>面积由 短板高度 × 宽度 决定。<blockquote><p>如果移动长板，宽度减少但高度不一定增加，所以面积不会变大。所以我们应该 始终移动短板指针，这样才有可能找到更大的面积。</p></blockquote></li></ul><p>时间复杂度 O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> h = std::<span class="built_in">min</span>(height[left], height[right]);</span><br><span class="line">            <span class="type">int</span> w = right - left;</span><br><span class="line">            max_area = std::<span class="built_in">max</span>(max_area, h * w);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动短板</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/posts/43000/"/>
      <url>/posts/43000/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-03</p></div></div><div class='timeline-item-content'><p>init</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-12</p></div></div><div class='timeline-item-content'><p>add next_permutation 生成序列的全排列</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-19</p></div></div><div class='timeline-item-content'><p>add string</p></div></div></div><hr><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="amp-与-amp-amp-，左值与右值"><a href="#amp-与-amp-amp-，左值与右值" class="headerlink" title="&amp; 与 &amp;&amp;，左值与右值"></a>&amp; 与 &amp;&amp;，左值与右值</h2><ul><li><p><strong>左值 (Lvalue)</strong></p><ul><li><p>有名字，可取地址。</p></li><li><p>可以出现在赋值符号左边。</p></li><li><p>例子：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int <span class="variable language_">x</span> = <span class="number">5</span>; <span class="comment">// x 是左值</span></span><br><span class="line"><span class="variable language_">x</span> = <span class="number">10</span>;    <span class="comment">// 可以赋值</span></span><br><span class="line">int* p = &amp;<span class="variable language_">x</span>; <span class="comment">// 可以取地址</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>右值 (Rvalue)</strong></p><ul><li><p>临时对象或字面量，没有名字，不能取地址。</p></li><li><p>通常出现在赋值符号右边。</p></li><li><p>例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> y = x + <span class="number">2</span>; <span class="comment">// x+2 是右值</span></span><br><span class="line"><span class="built_in">int</span> z = <span class="number">42</span>;    <span class="comment">// 42 是右值</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注意</strong>：右值可以绑定到 <strong>右值引用 (<code>&amp;&amp;</code>)</strong>。</p></blockquote></li><li><p>引用类型</p></li></ul><div class="table-container"><table><thead><tr><th>引用</th><th>含义</th></tr></thead><tbody><tr><td><code>T&amp;</code></td><td>左值引用（只能绑定到左值）</td></tr><tr><td><code>T&amp;&amp;</code></td><td>右值引用（只能绑定到右值）</td></tr></tbody></table></div><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;lref = a;   <span class="comment">// 左值引用，a 是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rref = <span class="number">5</span>;  <span class="comment">// 右值引用，5 是右值</span></span><br></pre></td></tr></table></figure><ul><li>左值引用可以修改左值：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lref = <span class="number">10</span>; <span class="comment">// a = 10</span></span><br></pre></td></tr></table></figure><ul><li>右值引用常用于移动语义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1); <span class="comment">// 右值引用允许移动资源</span></span><br></pre></td></tr></table></figure><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="引用头文件"><a href="#引用头文件" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a><strong>构造</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空 vector</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小，默认初始化为0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">// 5个元素，每个为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定大小和初始值</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">5</span>, <span class="number">42</span>)</span></span>;  <span class="comment">// 5个元素，每个为42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 initializer_list</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制另一个 vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v5</span><span class="params">(v4)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组构造</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v6</span><span class="params">(arr, arr + <span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h3><ul><li><p>返回的是元素的引用</p></li><li><p>带边界检查的访问如果越界会抛出 <strong>std::out_of_range</strong> 异常</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引访问（不做边界检查）</span></span><br><span class="line"><span class="type">int</span> a = v[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 at() 访问（带边界检查）</span></span><br><span class="line"><span class="type">int</span> b = v.<span class="built_in">at</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问首尾元素</span></span><br><span class="line"><span class="type">int</span> first = v.<span class="built_in">front</span>();</span><br><span class="line"><span class="type">int</span> last = v.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a><strong>修改元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v[<span class="number">2</span>] = <span class="number">10</span>;     <span class="comment">// 修改索引2的值</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">// 在末尾插入元素</span></span><br><span class="line">v.<span class="built_in">pop_back</span>();   <span class="comment">// 删除末尾元素</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">20</span>); <span class="comment">// 在索引1位置插入20</span></span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>);      <span class="comment">// 删除索引2的元素</span></span><br><span class="line">v.<span class="built_in">clear</span>();                   <span class="comment">// 清空所有元素</span></span><br></pre></td></tr></table></figure><h3 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a><strong>遍历元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    std::cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围 for（C++11+）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : v)</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container"><table><thead><tr><th>操作</th><th>时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td><code>v[i]</code></td><td>O(1)</td><td>随机访问</td></tr><tr><td><code>v.at(i)</code></td><td>O(1)</td><td>随机访问，带边界检查</td></tr><tr><td><code>push_back(x)</code></td><td>O(1) 摊销</td><td>平均常数时间，偶尔扩容 O(n)</td></tr><tr><td><code>pop_back()</code></td><td>O(1)</td><td>删除末尾元素</td></tr><tr><td><code>insert(v.begin() + i, x)</code></td><td>O(n)</td><td>插入到中间，平均移动 n/2 个元素</td></tr><tr><td><code>erase(v.begin() + i)</code></td><td>O(n)</td><td>删除中间元素，平均移动 n/2 个元素</td></tr><tr><td><code>front()</code> / <code>back()</code></td><td>O(1)</td><td>访问首尾元素</td></tr><tr><td><code>size()</code> / <code>empty()</code></td><td>O(1)</td><td>获取大小/是否为空</td></tr><tr><td><code>clear()</code></td><td>O(n)</td><td>清空元素（析构调用）</td></tr><tr><td><code>sort(v.begin(), v.end())</code></td><td>O(n log n)</td><td>使用 STL 算法排序</td></tr></tbody></table></div><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="引用头文件-1"><a href="#引用头文件-1" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br></pre></td></tr></table></figure><h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a><strong>构造</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空队列</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">queue&lt;<span class="type">int</span>&gt; <span class="title">q2</span><span class="params">(q1)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="访问队头队尾"><a href="#访问队头队尾" class="headerlink" title="访问队头队尾"></a>访问队头队尾</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队首/队尾元素</span></span><br><span class="line"><span class="type">int</span> front_val = q.<span class="built_in">front</span>();</span><br><span class="line"><span class="type">int</span> back_val  = q.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure><h3 id="入队出队"><a href="#入队出队" class="headerlink" title="入队出队"></a>入队出队</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队（尾部插入）</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队（头部删除）</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container"><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td><code>push()</code></td><td>O(1)</td></tr><tr><td><code>pop()</code></td><td>O(1)</td></tr><tr><td><code>front()</code></td><td>O(1)</td></tr><tr><td><code>back()</code></td><td>O(1)</td></tr><tr><td><code>empty()</code></td><td>O(1)</td></tr><tr><td><code>size()</code></td><td>O(1)</td></tr></tbody></table></div><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><ul><li><p>优先队列，内部默认使用大顶堆</p></li><li><p>出队时总是弹出队列中 <strong>最大的元素</strong>（默认大顶堆）。</p></li><li><p>可以自定义比较器实现 <strong>小顶堆</strong>。</p></li></ul><p>priority_queue 没有迭代器，只能利用 pop()和 top()实现遍历</p><h3 id="引用头文件-2"><a href="#引用头文件-2" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br></pre></td></tr></table></figure><h3 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h3><blockquote><p>priority_queue 的泛型参数中第一个是存储元素的类型，第二个是存储元素的容器，默认为 vector，第三个是元素的比较器</p></blockquote><div class="tip warning faa-horizontal animated"><p>注意 priority_queue 除了能弹出堆顶外，不支持直接修改或删除堆中某一个元素</p></div><ul><li>如果想要删除 priority_queue 中某一个元素，建议考虑能不能配合 unordered_map 实现<strong>懒删除</strong>(只有无效元素到堆顶了才删除，否则只做标记)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq1;</span><br><span class="line"><span class="comment">// 默认构造的全部参数</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,std::less&lt;<span class="type">int</span>&gt;&gt;;</span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">pq2</span><span class="params">(pq1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从容器构造</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function">priority_queue&lt;<span class="type">int</span>&gt; <span class="title">pq3</span><span class="params">(v.begin(), v.end())</span></span>; <span class="comment">// 默认最大堆</span></span><br></pre></td></tr></table></figure><h3 id="访问堆顶"><a href="#访问堆顶" class="headerlink" title="访问堆顶"></a><strong>访问堆顶</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"><span class="type">int</span> top_val = pq.<span class="built_in">top</span>(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h3 id="弹出堆顶元素"><a href="#弹出堆顶元素" class="headerlink" title="弹出堆顶元素"></a><strong>弹出堆顶元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pq.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><h3 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h3><p><strong>方法 1：使用 std::greater<int>实现小顶堆</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt;&gt; min_pq;</span><br></pre></td></tr></table></figure><p><strong>方法 2：自定义结构体/lambda</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125; <span class="comment">// 最小值优先</span></span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; pq_custom;</span><br></pre></td></tr></table></figure><p><strong>方法 3：如果是结构体，直接重载&lt;运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 &lt; 运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt; other.age;  <span class="comment">// 默认大顶堆，年龄大的优先</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Person&gt; pq;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container"><table><thead><tr><th>操作</th><th>平均复杂度</th></tr></thead><tbody><tr><td><code>push</code></td><td>O(log n)</td></tr><tr><td><code>pop</code></td><td>O(log n)</td></tr><tr><td><code>top</code></td><td>O(1)</td></tr><tr><td><code>size</code></td><td>O(1)</td></tr><tr><td><code>empty</code></td><td>O(1)</td></tr></tbody></table></div><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>栈，先进后出</p><p><code>stack</code> 没有迭代器，不能用 <code>for</code> 循环直接遍历。遍历只能通过 <code>top()</code> + <code>pop()</code>。</p><h3 id="引用头文件-3"><a href="#引用头文件-3" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::stack;</span><br></pre></td></tr></table></figure><h3 id="构造-3"><a href="#构造-3" class="headerlink" title="构造"></a>构造</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s1;          <span class="comment">// 空栈</span></span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;      <span class="comment">// 拷贝构造</span></span><br></pre></td></tr></table></figure><h3 id="入栈-出栈"><a href="#入栈-出栈" class="headerlink" title="入栈/出栈"></a>入栈/出栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="comment">// 入栈（push 到栈顶）</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈（pop 栈顶元素）</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><h3 id="访问栈顶元素"><a href="#访问栈顶元素" class="headerlink" title="访问栈顶元素"></a>访问栈顶元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看栈顶元素</span></span><br><span class="line"><span class="type">int</span> top_val = s.<span class="built_in">top</span>();  <span class="comment">// 栈顶元素</span></span><br></pre></td></tr></table></figure><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container"><table><thead><tr><th>操作</th><th>平均复杂度</th></tr></thead><tbody><tr><td><code>push</code></td><td>O(1)</td></tr><tr><td><code>pop</code></td><td>O(1)</td></tr><tr><td><code>top</code></td><td>O(1)</td></tr><tr><td><code>size</code></td><td>O(1)</td></tr><tr><td><code>empty</code></td><td>O(1)</td></tr></tbody></table></div><h2 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map, unordered_map"></a>map, unordered_map</h2><ul><li><p>map</p><ul><li><p><code>map</code> 是 <strong>有序关联容器</strong>，底层通常用 <strong>红黑树</strong> 实现。</p></li><li><p>每个元素是 <strong>key-value</strong> 对，key 唯一，自动按 key 排序。</p></li><li><p>适合需要 <strong>按键顺序访问</strong> 的场景。</p></li></ul></li><li><p>unordered_map</p><ul><li><code>unordered_map</code> 是 <strong>哈希表</strong>，无序存储 key-value。</li><li>查找、插入和删除平均时间复杂度为 O(1)。</li><li>适合快速查找，<strong>不关心顺序</strong>。</li></ul><blockquote><p>GCC 的 <code>unordered_map</code> 自 C++11 起有一个优化：</p><ul><li><strong>当某个桶内链表长度超过一定阈值（通常是 8）时，链表会转为红黑树</strong>。</li><li>这样可以防止 <strong>最坏情况哈希冲突导致的 O(n) 复杂度</strong>，把查找复杂度从 O(n) 降到 O(log n)。</li><li>也就是：<strong>链表 → 红黑树</strong>，而不是整个哈希表退化为红黑树。</li></ul></blockquote></li></ul><h3 id="引用头文件-4"><a href="#引用头文件-4" class="headerlink" title="引用头文件"></a>引用头文件</h3><p><strong>map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::map;</span><br></pre></td></tr></table></figure><p><strong>unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unordered_map</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br></pre></td></tr></table></figure><h3 id="构造-4"><a href="#构造-4" class="headerlink" title="构造"></a>构造</h3><p><strong>map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空 map</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">map&lt;<span class="type">int</span>, string&gt; <span class="title">m2</span><span class="params">(m1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; m3 = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p><strong>unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空表</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="function">unordered_map&lt;<span class="type">int</span>, string&gt; <span class="title">um2</span><span class="params">(um1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um3 = &#123;&#123;<span class="number">1</span>,<span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>,<span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h3 id="访问元素-1"><a href="#访问元素-1" class="headerlink" title="访问元素"></a>访问元素</h3><p><strong>map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line">string s = m[<span class="number">1</span>];       <span class="comment">// key 必须存在，否则会创建默认值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line">string s = m[<span class="number">1</span>];       <span class="comment">// key 必须存在，否则会创建默认值</span></span><br></pre></td></tr></table></figure><h3 id="插入，修改和元素"><a href="#插入，修改和元素" class="headerlink" title="插入，修改和元素"></a>插入，修改和元素</h3><p><strong>map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;     <span class="comment">// 插入或修改</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>unorder_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">um.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br><span class="line">um[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">um[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p><strong>map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> hasKey = um.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 0 或 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="number">2</span>);   <span class="comment">// 返回迭代器，找不到返回 m.end()</span></span><br><span class="line"><span class="type">bool</span> hasKey = um.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 0 或 1</span></span><br></pre></td></tr></table></figure><p><strong>unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = um.<span class="built_in">find</span>(<span class="number">2</span>);  <span class="comment">// 返回迭代器，找不到返回 um.end()</span></span><br><span class="line"><span class="type">bool</span> hasKey = um.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 0 或 1</span></span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p><strong>map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">1</span>);            <span class="comment">// 根据 key 删除</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());    <span class="comment">// 根据迭代器删除</span></span><br></pre></td></tr></table></figure><p><strong>unordered_map</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; um;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">um.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">m.<span class="built_in">erase</span>(um.<span class="built_in">begin</span>());    <span class="comment">// 根据迭代器删除</span></span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><strong>map</strong></p><blockquote><p>map 是按 key 有序遍历的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, value] : m) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unordered_map</strong></p><blockquote><p>注意：<code>unordered_map</code> 是无序的，遍历顺序不固定。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[key, value] : um) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义比较器（仅-map-支持）"><a href="#自定义比较器（仅-map-支持）" class="headerlink" title="自定义比较器（仅 map 支持）"></a>自定义比较器（仅 map 支持）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string, std::greater&lt;<span class="type">int</span>&gt;&gt; m; <span class="comment">// 按 key 降序</span></span><br></pre></td></tr></table></figure><h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>map</strong></p><div class="table-container"><table><thead><tr><th>操作</th><th>平均复杂度</th></tr></thead><tbody><tr><td>插入/删除</td><td>O(log n)</td></tr><tr><td>查找</td><td>O(log n)</td></tr><tr><td>遍历</td><td>O(n)</td></tr><tr><td>访问元素</td><td>O(log n)</td></tr></tbody></table></div><p><strong>unordered_map</strong></p><div class="table-container"><table><thead><tr><th>操作</th><th>平均复杂度</th><th>最坏复杂度</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(n)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(n)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(n)</td></tr><tr><td>遍历</td><td>O(n)</td><td>O(n)</td></tr></tbody></table></div><h2 id="set-unordered-set"><a href="#set-unordered-set" class="headerlink" title="set, unordered_set"></a>set, unordered_set</h2><ul><li><strong>set</strong><ul><li><code>set</code> 是 <strong>有序集合</strong>，底层通常用 <strong>红黑树</strong> 实现。</li><li>存储 <strong>唯一元素</strong>，自动按元素大小排序。</li><li>适合需要 <strong>有序访问和快速查找唯一元素</strong> 的场景。</li></ul></li><li><strong>unordered_set</strong><ul><li><code>unordered_set</code> 是 <strong>哈希表集合</strong>，无序存储唯一元素。</li><li>平均查找、插入和删除复杂度为 O(1)。</li><li>适合快速查找，不关心顺序。<blockquote><p>GCC 的 <code>unordered_set</code> 同样支持 <strong>链表长度超过阈值时桶内树化</strong>，避免最坏情况 O(n)。</p></blockquote></li></ul></li></ul><h3 id="引用头文件-5"><a href="#引用头文件-5" class="headerlink" title="引用头文件"></a>引用头文件</h3><p><strong>set</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::set;</span><br></pre></td></tr></table></figure><p><strong>unordered_set</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::unordered_set;</span><br></pre></td></tr></table></figure><hr><h3 id="构造-5"><a href="#构造-5" class="headerlink" title="构造"></a>构造</h3><p><strong>set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;               <span class="comment">// 空集合</span></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s2</span><span class="params">(s1)</span></span>;           <span class="comment">// 拷贝构造</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;   <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure><p><strong>unordered_set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us1;              <span class="comment">// 空集合</span></span><br><span class="line"><span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">us2</span><span class="params">(us1)</span></span>;         <span class="comment">// 拷贝构造</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us3 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure><hr><h3 id="插入和修改"><a href="#插入和修改" class="headerlink" title="插入和修改"></a>插入和修改</h3><p><strong>set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 插入元素</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 重复元素不会插入</span></span><br></pre></td></tr></table></figure><p><strong>unordered_set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line"></span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">us.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 重复元素不会插入</span></span><br></pre></td></tr></table></figure><hr><h3 id="查找元素-1"><a href="#查找元素-1" class="headerlink" title="查找元素"></a>查找元素</h3><p><strong>set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">2</span>);   <span class="comment">// 返回迭代器，找不到返回 s.end()</span></span><br><span class="line"><span class="type">bool</span> exists = s.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 返回 0 或 1</span></span><br></pre></td></tr></table></figure><p><strong>unordered_set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;<span class="type">int</span>&gt; us = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = us.<span class="built_in">find</span>(<span class="number">2</span>);   <span class="comment">// 返回迭代器，找不到返回 us.end()</span></span><br><span class="line"><span class="type">bool</span> exists = us.<span class="built_in">count</span>(<span class="number">2</span>); <span class="comment">// 返回 0 或 1</span></span><br></pre></td></tr></table></figure><h3 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h3><p><strong>set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(<span class="number">2</span>);        <span class="comment">// 根据元素值删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()); <span class="comment">// 根据迭代器删除</span></span><br></pre></td></tr></table></figure><p><strong>unordered_set</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">us.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">us.<span class="built_in">erase</span>(us.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p><strong>set</strong></p><blockquote><p>按元素升序遍历</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : s) &#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>unordered_set</strong></p><blockquote><p>遍历顺序不固定</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : us) &#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义比较器（仅-set-支持）"><a href="#自定义比较器（仅-set-支持）" class="headerlink" title="自定义比较器（仅 set 支持）"></a>自定义比较器（仅 set 支持）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>, std::greater&lt;<span class="type">int</span>&gt;&gt; s; <span class="comment">// 按降序排列</span></span><br></pre></td></tr></table></figure><h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>set</strong></p><div class="table-container"><table><thead><tr><th>操作</th><th>平均复杂度</th></tr></thead><tbody><tr><td>插入/删除</td><td>O(log n)</td></tr><tr><td>查找</td><td>O(log n)</td></tr><tr><td>遍历</td><td>O(n)</td></tr></tbody></table></div><p><strong>unordered_set</strong></p><div class="table-container"><table><thead><tr><th>操作</th><th>平均复杂度</th><th>最坏复杂度</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(n)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(n)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(n)</td></tr><tr><td>遍历</td><td>O(n)</td><td>O(n)</td></tr></tbody></table></div><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>绝大多数现代 C++ 编译器（如 GCC/Clang/MSVC）中的 <code>std::string</code> 实现类似：</p><ul><li>内部使用<strong>动态数组</strong>存储字符</li><li>结尾自动维护 <code>&#39;\0&#39;</code>（兼容 C-string）</li><li>每个 <code>string</code> 还维护 <code>size</code> 和 <code>capacity</code></li></ul><p>字符串扩容通常按照<strong>指数方式增长（如 2 倍）</strong>，以减少反复申请内存。</p><p><strong>小字符串优化（SSO - Small String Optimization）</strong></p><p>SSO 是 <code>std::string</code> 的核心性能优化技术。</p><p> <strong>目的：减少堆内存分配，加快小字符串操作</strong></p><p>当字符串长度较短（通常 ≤ 15 字符），很多实现会<strong>直接存放在对象内部的小缓冲区</strong>中，而不分配堆内存。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 很可能不分配堆内存（SSO）</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>避免频繁 <code>new/delete</code></li><li>提高性能</li><li>减少内存碎片</li></ul><h3 id="引用头文件-6"><a href="#引用头文件-6" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure><h3 id="构造-6"><a href="#构造-6" class="headerlink" title="构造"></a>构造</h3><div class="table-container"><table><thead><tr><th>构造方式</th><th>原型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>默认构造</td><td><code>string()</code></td><td>创建空字符串</td><td><code>string s1; // &quot;&quot;</code></td></tr><tr><td>拷贝构造</td><td><code>string(const string&amp; str)</code></td><td>拷贝已有字符串</td><td><code>string s2(s1);</code></td></tr><tr><td>移动构造</td><td><code>string(string&amp;&amp; str)</code></td><td>移动已有字符串（C++11 后）</td><td><code>string s3(std::move(s1));</code></td></tr><tr><td>C 字符串</td><td><code>string(const char* s)</code></td><td>从以 <code>\0</code> 结尾的 C 字符串构造</td><td><code>string s4(&quot;hello&quot;);</code></td></tr><tr><td>C 字符串 + 长度</td><td><code>string(const char* s, size_t n)</code></td><td>只取前 n 个字符</td><td><code>string s5(&quot;hello world&quot;, 5); // &quot;hello&quot;</code></td></tr><tr><td>重复字符</td><td><code>string(size_t n, char c)</code></td><td>创建 n 个相同字符组成的字符串</td><td><code>string s6(4, &#39;a&#39;); // &quot;aaaa&quot;</code></td></tr><tr><td>区间构造</td><td><code>template&lt;class InputIt&gt; string(InputIt first, InputIt last)</code></td><td>用迭代器区间初始化</td><td><code>vector&lt;char&gt; v&#123;&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;; string s7(v.begin(), v.end());</code></td></tr><tr><td>initializer_list</td><td><code>string(std::initializer_list&lt;char&gt; ilist)</code></td><td>用列表初始化字符（C++11）</td><td><code>string s8(&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;); // &quot;abc&quot;</code></td></tr></tbody></table></div><p><strong>默认构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">cout &lt;&lt; s<span class="number">1.</span><span class="built_in">size</span>(); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li><strong>易错点</strong>：空字符串的 <code>c_str()</code> 仍然有效，返回 <code>&quot;&quot;</code>。</li></ul><hr><p><strong>拷贝构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;</span><br><span class="line">cout &lt;&lt; s3; <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>性能建议</strong>：大字符串尽量使用 <code>const string&amp;</code> 传参，避免拷贝</li></ul><hr><p><strong>移动构造（C++11+）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(std::move(s2))</span></span>;</span><br></pre></td></tr></table></figure><ul><li><strong>特性</strong>：<code>s2</code> 的内容被移动，原对象为空</li><li><strong>优势</strong>：避免拷贝内存，提高性能</li></ul><hr><p><strong>C 字符串构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(<span class="string">&quot;hello world&quot;</span>, <span class="number">5</span>)</span></span>; <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>使用场景</strong>：从字面量或 C 风格数组初始化</li><li><strong>性能建议</strong>：如果长度已知，用第二个参数避免多余扫描</li><li><strong>易错点</strong>：传入非 <code>\0</code> 结尾字符串时，必须指明长度</li></ul><hr><p><strong>重复字符构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>; <span class="comment">// &quot;xxxxx&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>区间构造（迭代器）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">char</span>&gt; v&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="function">string <span class="title">s8</span><span class="params">(v.begin(), v.end())</span></span>; <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>initializer_list 构造（C++11+）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s9</span><span class="params">(&#123;<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;)</span></span>; <span class="comment">// &quot;xyz&quot;</span></span><br></pre></td></tr></table></figure><h3 id="访问与赋值操作"><a href="#访问与赋值操作" class="headerlink" title="访问与赋值操作"></a>访问与赋值操作</h3><p><strong>下标访问 <code>operator[]</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> c = s[<span class="number">1</span>]; <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>;    <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>说明</strong>：</p><ul><li><p>不进行边界检查，访问越界会导致未定义行为。</p></li><li><p>移动构造或扩容后，指向原字符的指针或引用可能失效。</p></li></ul></li></ul><p><strong>安全访问</strong> <code>at()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = s.<span class="built_in">at</span>(<span class="number">1</span>); <span class="comment">// &#x27;e&#x27;</span></span><br><span class="line">s.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="string">&#x27;H&#x27;</span>;    <span class="comment">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：<ul><li>会进行范围检查，越界时抛 <code>std::out_of_range</code> 异常。</li></ul></li></ul><hr><p><strong>访问首尾字符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> f = s.<span class="built_in">front</span>(); <span class="comment">// &#x27;H&#x27;</span></span><br><span class="line"><span class="type">char</span> b = s.<span class="built_in">back</span>();  <span class="comment">// &#x27;o&#x27;</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">front</span>() = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">s.<span class="built_in">back</span>()  = <span class="string">&#x27;!&#x27;</span>;    <span class="comment">// &quot;hello!&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：<ul><li>当字符串为空时调用 <code>front()</code> 或 <code>back()</code> 是未定义行为。</li></ul></li><li><strong>易错点</strong>：<ul><li>空字符串访问会触发 UB（未定义行为）。</li></ul></li></ul><hr><p><strong>字符串赋值 assign()</strong></p><p><code>assign()</code> 是 <code>std::string</code> 赋值的多用途函数，重载丰富：</p><div class="table-container"><table><thead><tr><th>原型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>string&amp; assign(const string&amp; str)</code></td><td>拷贝另一个字符串</td><td><code>s.assign(s2);</code></td></tr><tr><td><code>string&amp; assign(string&amp;&amp; str)</code></td><td>移动另一个字符串</td><td><code>s.assign(std::move(s2));</code></td></tr><tr><td><code>string&amp; assign(const string&amp; str, size_t pos, size_t count)</code></td><td>从 str 的子串赋值</td><td><code>s.assign(s2, 1, 3); // 取 s2[1..3]</code></td></tr><tr><td><code>string&amp; assign(const char* s)</code></td><td>C 字符串赋值</td><td><code>s.assign(&quot;world&quot;);</code></td></tr><tr><td><code>string&amp; assign(const char* s, size_t n)</code></td><td>前 n 个字符赋值</td><td><code>s.assign(&quot;hello world&quot;, 5); // &quot;hello&quot;</code></td></tr><tr><td><code>string&amp; assign(size_t n, char c)</code></td><td>重复字符赋值</td><td><code>s.assign(4, &#39;x&#39;); // &quot;xxxx&quot;</code></td></tr><tr><td><code>template&lt;class InputIt&gt; string&amp; assign(InputIt first, InputIt last)</code></td><td>区间赋值</td><td><code>vector&lt;char&gt; v&#123;&#39;a&#39;,&#39;b&#39;&#125;; s.assign(v.begin(), v.end());</code></td></tr><tr><td><code>string&amp; assign(initializer_list&lt;char&gt; il)</code></td><td>列表赋值（C++11+）</td><td><code>s.assign(&#123;&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;); // &quot;xyz&quot;</code></td></tr></tbody></table></div><h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h3><p><strong>追加append</strong></p><div class="table-container"><table><thead><tr><th>原型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>string&amp; append(const string&amp; str)</code></td><td>追加整个字符串</td><td><code>s.append(s2);</code></td></tr><tr><td><code>string&amp; append(const string&amp; str, size_t pos, size_t count)</code></td><td>追加 str 的子串</td><td><code>s.append(s2, 1, 3);</code></td></tr><tr><td><code>string&amp; append(const char* s)</code></td><td>追加 C 字符串</td><td><code>s.append(&quot;world&quot;);</code></td></tr><tr><td><code>string&amp; append(const char* s, size_t n)</code></td><td>追加 C 字符串前 n 个字符</td><td><code>s.append(&quot;hello world&quot;, 5); // &quot;hello&quot;</code></td></tr><tr><td><code>string&amp; append(size_t n, char c)</code></td><td>追加 n 个相同字符</td><td><code>s.append(3, &#39;!&#39;); // &quot;!!!&quot;</code></td></tr><tr><td><code>template&lt;class InputIt&gt; string&amp; append(InputIt first, InputIt last)</code></td><td>追加区间</td><td><code>vector&lt;char&gt; v&#123;&#39;a&#39;,&#39;b&#39;&#125;; s.append(v.begin(), v.end());</code></td></tr><tr><td><code>string&amp; push_back(char c)</code></td><td>追加单个字符</td><td><code>s.push_back(&#39;x&#39;);</code></td></tr></tbody></table></div><p><strong>性能建议</strong></p><p>优化拼接操作 —— 默认拼接效率低</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.<span class="title function_ invoke__">reserve</span>(<span class="number">1000</span>);  <span class="comment">// 建议预留空间减少扩容</span></span><br></pre></td></tr></table></figure><ul><li>频繁修改时建议用 <code>std::ostringstream</code> 或 <code>std::string_view</code></li></ul><p><strong>插入insert</strong></p><div class="table-container"><table><thead><tr><th>原型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>string&amp; insert(size_t pos, const string&amp; str)</code></td><td>在 pos 插入整个字符串</td><td><code>s.insert(2, s2);</code></td></tr><tr><td><code>string&amp; insert(size_t pos, const string&amp; str, size_t subpos, size_t count)</code></td><td>插入 str 子串</td><td><code>s.insert(1, s2, 0, 2);</code></td></tr><tr><td><code>string&amp; insert(size_t pos, const char* s)</code></td><td>插入 C 字符串</td><td><code>s.insert(0, &quot;Hi&quot;);</code></td></tr><tr><td><code>string&amp; insert(size_t pos, const char* s, size_t n)</code></td><td>插入 C 字符串前 n 个字符</td><td><code>s.insert(0, &quot;Hello World&quot;, 5);</code></td></tr><tr><td><code>string&amp; insert(size_t pos, size_t n, char c)</code></td><td>插入 n 个相同字符</td><td><code>s.insert(3, 4, &#39;*&#39;);</code></td></tr><tr><td><code>iterator insert(const_iterator p, char c)</code></td><td>插入单字符</td><td><code>s.insert(s.begin()+1, &#39;x&#39;);</code></td></tr><tr><td><code>template&lt;class InputIt&gt; void insert(const_iterator p, InputIt first, InputIt last)</code></td><td>插入区间</td><td><code>s.insert(s.begin(), v.begin(), v.end());</code></td></tr></tbody></table></div><p><strong>删除erase</strong></p><div class="table-container"><table><thead><tr><th>原型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>string&amp; erase(size_t pos = 0, size_t count = npos)</code></td><td>从 pos 开始删除 count 个字符</td><td><code>s.erase(2,3);</code></td></tr><tr><td><code>iterator erase(const_iterator p)</code></td><td>删除迭代器指向字符</td><td><code>s.erase(s.begin()+1);</code></td></tr><tr><td><code>iterator erase(const_iterator first, const_iterator last)</code></td><td>删除区间</td><td><code>s.erase(s.begin(), s.begin()+3);</code></td></tr></tbody></table></div><p><strong>替换replace</strong></p><div class="table-container"><table><thead><tr><th>原型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>string&amp; replace(size_t pos, size_t count, const string&amp; str)</code></td><td>替换 pos 起 count 个字符为 str</td><td><code>s.replace(0,2,&quot;Hi&quot;);</code></td></tr><tr><td><code>string&amp; replace(size_t pos, size_t count, const string&amp; str, size_t subpos, size_t subcount)</code></td><td>替换为 str 子串</td><td><code>s.replace(0,2,s2,1,2);</code></td></tr><tr><td><code>string&amp; replace(size_t pos, size_t count, const char* s)</code></td><td>替换为 C 字符串</td><td><code>s.replace(0,2,&quot;OK&quot;);</code></td></tr><tr><td><code>string&amp; replace(size_t pos, size_t count, const char* s, size_t n)</code></td><td>替换为 C 字符串前 n 个字符</td><td><code>s.replace(0,2,&quot;Hello World&quot;,5);</code></td></tr><tr><td><code>string&amp; replace(size_t pos, size_t count, size_t n, char c)</code></td><td>替换为 n 个相同字符</td><td><code>s.replace(0,2,3,&#39;*&#39;);</code></td></tr><tr><td><code>iterator replace(const_iterator first, const_iterator last, InputIt first2, InputIt last2)</code></td><td>替换迭代器区间</td><td><code>s.replace(s.begin(), s.begin()+2,v.begin(),v.end());</code></td></tr></tbody></table></div><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><div class="table-container"><table><thead><tr><th>函数原型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>size_t find(const string&amp; str, size_t pos=0) const</code></td><td>从 pos 开始查找子串首次出现位置</td><td><code>s.find(&quot;world&quot;); // 6</code></td></tr><tr><td><code>size_t find(const char* s, size_t pos=0) const</code></td><td>从 pos 开始查找 C 字符串</td><td><code>s.find(&quot;lo&quot;); // 3</code></td></tr><tr><td><code>size_t find(const char* s, size_t pos, size_t n) const</code></td><td>查找 C 字符串前 n 个字符</td><td><code>s.find(&quot;hello world&quot;, 0, 5); // 查找 &quot;hello&quot;</code></td></tr><tr><td><code>size_t find(char c, size_t pos=0) const</code></td><td>查找字符首次出现位置</td><td><code>s.find(&#39;o&#39;); // 4</code></td></tr><tr><td><code>size_t rfind(const string&amp; str, size_t pos=npos) const</code></td><td>从右向左查找子串</td><td><code>s.rfind(&quot;lo&quot;);</code></td></tr><tr><td><code>size_t rfind(char c, size_t pos=npos) const</code></td><td>从右向左查找字符</td><td><code>s.rfind(&#39;o&#39;);</code></td></tr><tr><td><code>size_t find_first_of(const string&amp; chars, size_t pos=0) const</code></td><td>查找任意指定字符集合首次出现</td><td><code>s.find_first_of(&quot;aeiou&quot;);</code></td></tr><tr><td><code>size_t find_last_of(const string&amp; chars, size_t pos=npos) const</code></td><td>查找任意字符集合最后一次出现</td><td><code>s.find_last_of(&quot;aeiou&quot;);</code></td></tr><tr><td><code>size_t find_first_not_of(const string&amp; chars, size_t pos=0) const</code></td><td>查找第一个不属于字符集合的位置</td><td><code>s.find_first_not_of(&quot;aeiou&quot;);</code></td></tr><tr><td><code>size_t find_last_not_of(const string&amp; chars, size_t pos=npos) const</code></td><td>查找最后一个不属于字符集合的位置</td><td><code>s.find_last_not_of(&quot;aeiou&quot;);</code></td></tr></tbody></table></div><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><div class="table-container"><table><thead><tr><th>函数原型</th><th>说明</th><th>示例</th><th>性能</th></tr></thead><tbody><tr><td><code>int compare(const string&amp; str) const</code></td><td>比较整个字符串与 str</td><td><code>s.compare(&quot;hello&quot;);</code></td><td>O(min(n, m))</td></tr><tr><td><code>int compare(size_t pos, size_t count, const string&amp; str) const</code></td><td>比较子串 <code>[pos, pos+count)</code> 与 str</td><td><code>s.compare(0,2,&quot;he&quot;);</code></td><td>O(count)</td></tr><tr><td><code>int compare(size_t pos, size_t count, const string&amp; str, size_t subpos, size_t subcount) const</code></td><td>比较 s 子串与 str 子串</td><td><code>s.compare(0,2,s2,1,2);</code></td><td>O(subcount)</td></tr><tr><td><code>int compare(const char* s) const</code></td><td>与 C 字符串比较</td><td><code>s.compare(&quot;hello&quot;);</code></td><td>O(n)</td></tr><tr><td><code>int compare(size_t pos, size_t count, const char* s) const</code></td><td>比较子串与 C 字符串</td><td><code>s.compare(0,2,&quot;he&quot;);</code></td><td>O(count)</td></tr><tr><td><code>int compare(size_t pos, size_t count, const char* s, size_t n) const</code></td><td>比较子串与 C 字符串前 n 个字符</td><td><code>s.compare(0,2,&quot;hello&quot;,2); // &quot;he&quot;</code></td><td>O(n)</td></tr></tbody></table></div><p>返回值：</p><ul><li><p>返回值小于0     s&lt;str, </p></li><li><p>返回值等于0     s==str,</p></li><li><p>返回值大于0     s&gt;str</p></li></ul><p>也可以用运算符比较</p><div class="table-container"><table><thead><tr><th>运算符</th><th>功能</th><th>示例</th><th>返回类型</th><th>比较方式</th></tr></thead><tbody><tr><td><code>==</code></td><td>判断是否相等</td><td><code>s == &quot;hello&quot;</code></td><td><code>bool</code></td><td>大小写敏感 &amp; 按字符逐一比较</td></tr><tr><td><code>!=</code></td><td>判断是否不相等</td><td><code>s != t</code></td><td><code>bool</code></td><td>同上</td></tr><tr><td><code>&lt;</code></td><td>按字典序小于</td><td><code>&quot;abc&quot; &lt; &quot;abd&quot;</code></td><td><code>bool</code></td><td>按 ASCII/Unicode 比较</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>&quot;abc&quot; &lt;= &quot;abc&quot;</code></td><td><code>bool</code></td><td>同上</td></tr><tr><td><code>&gt;</code></td><td>按字典序大于</td><td><code>&quot;dog&quot; &gt; &quot;cat&quot;</code></td><td><code>bool</code></td><td>同上</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>&quot;hi&quot; &gt;= &quot;ha&quot;</code></td><td><code>bool</code></td><td>同上</td></tr></tbody></table></div><h3 id="字串"><a href="#字串" class="headerlink" title="字串"></a>字串</h3><div class="table-container"><table><thead><tr><th>函数原型</th><th>说明</th><th>示例</th><th>返回值</th><th>注意</th><th>性能</th></tr></thead><tbody><tr><td><code>string substr(size_t pos = 0, size_t count = npos) const</code></td><td>从位置 <code>pos</code> 开始，截取长度为 <code>count</code> 的子串</td><td><code>s.substr(2, 4)</code></td><td>返回新 string</td><td><code>pos &gt; size()</code> 抛异常</td><td>会产生新字符串拷贝，注意性能</td></tr></tbody></table></div><h3 id="字符检查与大小写转换"><a href="#字符检查与大小写转换" class="headerlink" title="字符检查与大小写转换"></a>字符检查与大小写转换</h3><p>需要引入c标准库</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>常用字符判断函数</strong></p><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>isalnum(c)</code></td><td>是否为字母或数字</td><td><code>&#39;A&#39;,&#39;z&#39;,&#39;3&#39;</code></td></tr><tr><td><code>isalpha(c)</code></td><td>是否为字母</td><td><code>&#39;A&#39;,&#39;b&#39;</code></td></tr><tr><td><code>isdigit(c)</code></td><td>是否为数字</td><td><code>&#39;0&#39;~&#39;9&#39;</code></td></tr><tr><td><code>islower(c)</code></td><td>是否为小写字母</td><td><code>&#39;a&#39;</code></td></tr><tr><td><code>isupper(c)</code></td><td>是否为大写字母</td><td><code>&#39;Z&#39;</code></td></tr><tr><td><code>isspace(c)</code></td><td>是否为空白字符（空格/换行/制表）</td><td><code>&#39; &#39;,&#39;\n&#39;,&#39;\t&#39;</code></td></tr><tr><td><code>ispunct(c)</code></td><td>是否为标点符号</td><td><code>&#39;,&#39; &#39;.&#39; &#39;!&#39;</code></td></tr><tr><td><code>isxdigit(c)</code></td><td>是否为十六进制数字</td><td><code>&#39;0&#39;~&#39;9&#39;,&#39;a&#39;~&#39;f&#39;</code></td></tr><tr><td><code>isprint(c)</code></td><td>是否为可打印字符</td><td>普通字符</td></tr><tr><td><code>iscntrl(c)</code></td><td>是否控制字符</td><td><code>&#39;\n&#39; &#39;\r&#39;</code></td></tr></tbody></table></div><p><strong>大小写转换函数</strong></p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>tolower(c)</code></td><td>字符转小写</td><td><code>tolower(&#39;A&#39;) → &#39;a&#39;</code></td></tr><tr><td><code>toupper(c)</code></td><td>字符转大写</td><td><code>toupper(&#39;b&#39;) → &#39;B&#39;</code></td></tr></tbody></table></div><p>这两个函数<strong>只作用于单个字符</strong>，要处理字符串需要配合 <code>transform()</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;HeLLo&quot;</span>;</span><br><span class="line">std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::tolower);  <span class="comment">// s = &quot;hello&quot;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>::tolower</code> 里的 <code>::</code> 指的是<strong>全局作用域运算符</strong>，表示用 <strong>全局的 tolower 函数</strong>，避免与某些类成员同名造成歧义。</p></blockquote><h3 id="字符串与数字的转换"><a href="#字符串与数字的转换" class="headerlink" title="字符串与数字的转换"></a>字符串与数字的转换</h3><p><strong>字符串 → 整型转换函数表</strong></p><div class="table-container"><table><thead><tr><th>函数</th><th>函数原型</th><th>参数说明</th><th>返回值说明</th><th>示例</th></tr></thead><tbody><tr><td><code>stoi</code></td><td><code>int stoi(const string&amp; str, size_t* pos = 0, int base = 10);</code></td><td><code>str</code>: 输入字符串 <code>pos</code>: 返回成功转换的字符数 <code>base</code>: 进制（2~36）</td><td>转换后的 <code>int</code></td><td><code>stoi(&quot;123&quot;) → 123</code> <code>stoi(&quot;1A&quot;, nullptr, 16) → 26</code></td></tr><tr><td><code>stol</code></td><td><code>long stol(const string&amp; str, size_t* pos = 0, int base = 10);</code></td><td>同上</td><td>转换为 <code>long</code></td><td><code>stol(&quot;99999&quot;) → 99999L</code></td></tr><tr><td><code>stoll</code></td><td><code>long long stoll(const string&amp; str, size_t* pos = 0, int base = 10);</code></td><td>同上</td><td>转换为 <code>long long</code></td><td><code>stoll(&quot;1234567890123&quot;)</code></td></tr><tr><td><code>stoi</code> (C字符串)</td><td><code>int stoi(const char* str, size_t* pos = 0, int base = 10);</code></td><td><code>str</code>: C风格字符串</td><td>转换为 <code>int</code></td><td><code>stoi(&quot;42&quot;) → 42</code></td></tr></tbody></table></div><hr><p><strong>字符串 → 浮点型转换函数表</strong></p><div class="table-container"><table><thead><tr><th>函数</th><th>函数原型</th><th>参数说明</th><th>返回值说明</th><th>示例</th></tr></thead><tbody><tr><td><code>stof</code></td><td><code>float stof(const string&amp; str, size_t* pos = 0);</code></td><td><code>str</code>: 字符串 <code>pos</code>: 返回解析字符长度</td><td>转为 <code>float</code></td><td><code>stof(&quot;3.14&quot;) → 3.14f</code></td></tr><tr><td><code>stod</code></td><td><code>double stod(const string&amp; str, size_t* pos = 0);</code></td><td>同上</td><td>转为 <code>double</code></td><td><code>stod(&quot;2.71828&quot;)</code></td></tr><tr><td><code>stold</code></td><td><code>long double stold(const string&amp; str, size_t* pos = 0);</code></td><td>同上</td><td>转为 <code>long double</code></td><td><code>stold(&quot;1.6180339887&quot;)</code></td></tr></tbody></table></div><hr><p><strong>数字 → 字符串转换 (<code>to_string</code>)</strong></p><div class="table-container"><table><thead><tr><th>函数</th><th>函数原型</th><th>参数说明</th><th>返回值说明</th><th>示例</th></tr></thead><tbody><tr><td><code>to_string</code></td><td><code>string to_string(int value);</code></td><td><code>value</code>: 数字</td><td>返回转换后的字符串</td><td><code>to_string(42) → &quot;42&quot;</code></td></tr><tr><td><code>to_string</code></td><td><code>string to_string(double value);</code></td><td>同上</td><td>浮点转字符串</td><td><code>to_string(3.14) → &quot;3.140000&quot;</code></td></tr><tr><td><code>to_string</code></td><td><code>string to_string(long long value);</code></td><td>同上</td><td>支持长整型</td><td><code>to_string(1234567890123)</code></td></tr></tbody></table></div><hr><p><strong>返回值与异常总结</strong></p><div class="table-container"><table><thead><tr><th>情况</th><th>行为</th></tr></thead><tbody><tr><td>输入不是数字</td><td>抛出 <code>std::invalid_argument</code></td></tr><tr><td>数字超出范围</td><td>抛出 <code>std::out_of_range</code></td></tr><tr><td>自动去除前导空格</td><td>✅ 支持 <code>&quot;  123&quot;</code></td></tr><tr><td>支持符号</td><td>✅ <code>&quot;-42&quot;</code> <code>&quot; +88&quot;</code></td></tr><tr><td>支持部分解析</td><td>✅ <code>&quot;123abc&quot;</code> → 123</td></tr></tbody></table></div><h3 id="字符串与流"><a href="#字符串与流" class="headerlink" title="字符串与流"></a>字符串与流</h3><p><strong>引入头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"><span class="keyword">using</span> std::istringstream;</span><br><span class="line"><span class="keyword">using</span> std::ostringstream;</span><br></pre></td></tr></table></figure><p>三个类</p><div class="table-container"><table><thead><tr><th>类名</th><th>作用</th><th>场景</th></tr></thead><tbody><tr><td><code>stringstream</code></td><td>读写都支持</td><td>通用</td></tr><tr><td><code>istringstream</code></td><td>只读输入流</td><td>解析字符串</td></tr><tr><td><code>ostringstream</code></td><td>只写输出流</td><td>构造字符串</td></tr></tbody></table></div><p>常用操作：</p><h3 id="常用函数总览表"><a href="#常用函数总览表" class="headerlink" title="常用函数总览表"></a>常用函数总览表</h3><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td><code>str()</code></td><td>获取/设置内部字符串</td><td><code>ss.str(&quot;123 456&quot;)</code></td></tr><tr><td><code>clear()</code></td><td>清空流状态</td><td>必须在重复使用时调用</td></tr><tr><td><code>operator&gt;&gt;</code></td><td>提取数据（按空白分割）</td><td><code>ss &gt;&gt; x;</code></td></tr><tr><td><code>operator&lt;&lt;</code></td><td>插入数据</td><td><code>ss &lt;&lt; 42;</code></td></tr><tr><td><code>getline()</code></td><td>按行读取</td><td><code>getline(ss, s)</code></td></tr><tr><td><code>good()</code> <code>fail()</code></td><td>检查流状态</td><td>判断解析是否成功</td></tr></tbody></table></div><blockquote><p>注意重复使用时必须调用clear</p></blockquote><p>举例：</p><p>分割字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;apple banana orange&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>用途</th><th>方法</th><th>示例</th><th>说明</th><th>易错点</th></tr></thead><tbody><tr><td>空白分词</td><td><code>ss &gt;&gt; word</code></td><td><code>ss &gt;&gt; w1 &gt;&gt; w2</code></td><td>按空格、换行、制表符切分</td><td>遇到逗号等非空白不会分割</td></tr><tr><td>自定义分隔符</td><td><code>getline(ss, word, &#39;,&#39;)</code></td><td><code>getline(ss, word, &#39;,&#39;);</code></td><td>按 <code>,</code> 切分</td><td>必须用 <code>getline</code>，<code>&gt;&gt;</code> 无法自定义分隔符</td></tr><tr><td>解析数字</td><td><code>ss &gt;&gt; num</code></td><td><code>int x; ss &gt;&gt; x;</code></td><td>字符串数字 → int/double</td><td>非数字会使流失败，需检查 <code>ss.fail()</code></td></tr><tr><td>拼接字符串</td><td><code>oss &lt;&lt; val</code></td><td><code>oss &lt;&lt; &quot;ID=&quot; &lt;&lt; 5;</code></td><td>高效构造动态字符串</td><td>输出结束后 <code>oss.str()</code> 才能获取完整内容</td></tr></tbody></table></div><h2 id="multiset-multimap"><a href="#multiset-multimap" class="headerlink" title="multiset/multimap"></a>multiset/multimap</h2><p><strong>multiset<T></strong></p><ul><li>元素 <strong>可重复</strong>，自动按 key 排序</li><li>底层通常使用 <strong>红黑树</strong></li><li>不支持通过下标访问，只能用迭代器</li><li>适合需要 <strong>快速查找和按顺序遍历重复元素</strong></li></ul><p><strong>multimap<K,V></strong></p><ul><li>key <strong>可重复</strong>，按 key 排序</li><li>底层通常使用 <strong>红黑树</strong></li><li>可以通过 <code>equal_range</code> 查找某个 key 的所有元素</li></ul><h3 id="引用头文件-7"><a href="#引用头文件-7" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::multiset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::multimap;</span><br></pre></td></tr></table></figure><h3 id="构造-7"><a href="#构造-7" class="headerlink" title="构造"></a><strong>构造</strong></h3><p><strong>multiset</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multiset&lt;<span class="type">int</span>&gt; ms;            <span class="comment">// 空 multiset</span></span><br><span class="line"><span class="function">multiset&lt;<span class="type">int</span>&gt; <span class="title">ms2</span><span class="params">(ms)</span></span>;        <span class="comment">// 拷贝构造</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; ms3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure><p><strong>multimap</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>,string&gt; mm;            <span class="comment">// 空 multimap</span></span><br><span class="line"><span class="function">multimap&lt;<span class="type">int</span>,string&gt; <span class="title">mm2</span><span class="params">(mm)</span></span>;       <span class="comment">// 拷贝构造</span></span><br><span class="line">multimap&lt;<span class="type">int</span>,string&gt; mm3 = &#123;&#123;<span class="number">1</span>,<span class="string">&quot;a&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;b&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;c&quot;</span>&#125;&#125;; <span class="comment">// 初始化列表</span></span><br></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a><strong>插入元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">2</span>); <span class="comment">// 可以重复</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line">mm.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,<span class="string">&quot;b&quot;</span>&#125;);</span><br><span class="line">mm.<span class="built_in">insert</span>(&#123;<span class="number">2</span>,<span class="string">&quot;c&quot;</span>&#125;); <span class="comment">// key 可以重复</span></span><br></pre></td></tr></table></figure><h3 id="查找元素-2"><a href="#查找元素-2" class="headerlink" title="查找元素"></a><strong>查找元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="keyword">auto</span> it = ms.<span class="built_in">find</span>(<span class="number">2</span>);       <span class="comment">// 返回第一个 2 的迭代器</span></span><br><span class="line"><span class="type">size_t</span> cnt = ms.<span class="built_in">count</span>(<span class="number">2</span>);   <span class="comment">// 2 出现的次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line"><span class="keyword">auto</span> range = mm.<span class="built_in">equal_range</span>(<span class="number">2</span>); <span class="comment">// 返回 key=2 的元素区间 [first, second)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">    cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素-2"><a href="#删除元素-2" class="headerlink" title="删除元素"></a><strong>删除元素</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line">ms.<span class="built_in">erase</span>(<span class="number">2</span>);          <span class="comment">// 删除所有值为 2 的元素</span></span><br><span class="line"><span class="keyword">auto</span> it = ms.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">ms.<span class="built_in">erase</span>(it);         <span class="comment">// 删除单个迭代器指向的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line">mm.<span class="built_in">erase</span>(<span class="number">2</span>);          <span class="comment">// 删除所有 key=2 的元素</span></span><br><span class="line"><span class="keyword">auto</span> it2 = mm.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">mm.<span class="built_in">erase</span>(it2);        <span class="comment">// 删除单个迭代器指向的元素</span></span><br></pre></td></tr></table></figure><h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a><strong>遍历</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// multiset</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : ms) &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// multimap</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key,value] : mm) &#123;</span><br><span class="line">    cout &lt;&lt; key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h3><div class="table-container"><table><thead><tr><th>操作</th><th>multiset / multimap</th></tr></thead><tbody><tr><td>插入</td><td>O(log n)</td></tr><tr><td>查找</td><td>O(log n)</td></tr><tr><td>删除</td><td>O(log n)</td></tr><tr><td>遍历</td><td>O(n)</td></tr></tbody></table></div><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><h3 id="引用头文件-8"><a href="#引用头文件-8" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br></pre></td></tr></table></figure><h3 id="构造-8"><a href="#构造-8" class="headerlink" title="构造"></a><strong>构造</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt; tp =&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> tp2 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;hi&quot;</span>); <span class="comment">// 自动推断类型</span></span><br></pre></td></tr></table></figure><h3 id="访问元素-2"><a href="#访问元素-2" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h3><ul><li>不能像 pair 一样访问，使用 std::get<0>(tuple)<blockquote><p>注意，这里 get<index>要求 index 是常量，编译期可知的常量，因此不能利用它来遍历</p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tp);</span><br><span class="line"><span class="type">int</span> b = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tp);</span><br><span class="line"><span class="type">int</span> c = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(tp);</span><br></pre></td></tr></table></figure><ul><li>c++17 起可以用结构化绑定,这样更优雅些</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> [a, b, c] = tuple;</span><br></pre></td></tr></table></figure><ul><li>也可以使用 std::tie</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">std::<span class="built_in">tie</span>(a, b, std::ignore) = tp;</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a><strong>修改</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t) = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a><strong>获取长度</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tuple 长度</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> n = std::tuple_size&lt;<span class="keyword">decltype</span>(tp)&gt;::value; <span class="comment">// n=3</span></span><br></pre></td></tr></table></figure><h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a><strong>遍历</strong></h3><p>不常用，使用结构化绑定 + fold 表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> tp = <span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.5</span>, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fold expression 遍历</span></span><br><span class="line">std::<span class="built_in">apply</span>([](<span class="keyword">auto</span>&amp;&amp;... args) &#123;</span><br><span class="line">    ((cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), ...);</span><br><span class="line">&#125;, tp);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="引用头文件-9"><a href="#引用头文件-9" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p><strong>基本用法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">// std::greater&lt;int&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 按非递减顺序排序（升序）</span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 按非递增顺序排序（降序）</span></span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),std::greater&lt;<span class="type">int</span>&gt;)</span><br></pre></td></tr></table></figure><p><strong>自定义比较器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; people = &#123;&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;, &#123;<span class="string">&quot;Carol&quot;</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄升序</span></span><br><span class="line">std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](<span class="type">const</span> Person &amp;a, <span class="type">const</span> Person &amp;b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.age &lt; b.age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按年龄降序</span></span><br><span class="line">std::<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), [](<span class="type">const</span> Person &amp;a, <span class="type">const</span> Person &amp;b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.age &gt; b.age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="tip warning faa-horizontal animated"><p>std::sort 的标准要求是 稳定性不保证，如果需要稳定排序请使用 std::stable_sort</p></div><blockquote><ul><li><strong>稳定排序</strong>：如果两个元素相等，排序前它们的相对顺序在排序后保持不变。</li><li><strong>不稳定排序</strong>：相等元素的相对顺序在排序后可能被打乱。</li></ul></blockquote><h3 id="min-max"><a href="#min-max" class="headerlink" title="min, max"></a>min, max</h3><p><strong>基本用法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mi = std::<span class="built_in">min</span>(a, b); <span class="comment">// mi = 5</span></span><br><span class="line"><span class="type">int</span> ma = std::<span class="built_in">max</span>(a, b); <span class="comment">// ma = 10</span></span><br></pre></td></tr></table></figure><p><strong>自定义比较器</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p1&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;, p2&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回年龄小的</span></span><br><span class="line"><span class="keyword">auto</span> youngest = std::<span class="built_in">min</span>(p1, p2, [](<span class="type">const</span> Person &amp;x, <span class="type">const</span> Person &amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> oldest = std::<span class="built_in">max</span>(p1, p2, [](<span class="type">const</span> Person &amp;x, <span class="type">const</span> Person &amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.age &lt; y.age;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>可接受 initializer_list (C++11 及以上)</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> x = std::min(&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;); // x = <span class="number">1</span></span><br><span class="line"><span class="attribute">int</span> y = std::max(&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;); // y = <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="min-element-max-element"><a href="#min-element-max-element" class="headerlink" title="min_element/max_element"></a>min_element/max_element</h3><p>min_element 和 max_element 返回的迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// 查找最小/最大值</span></span><br><span class="line"><span class="type">int</span> mn = *std::<span class="built_in">min_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> mx = *std::<span class="built_in">max_element</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>反转有序容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>&#125;;</span><br><span class="line">std::<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li>顺序查找区间内第一个等于给定值的元素，返回迭代器。找不到返回 <code>end</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">// it 指向 5</span></span><br><span class="line"><span class="keyword">if</span>(it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><ul><li>统计区间内某个值出现的次数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> cnt = std::<span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>); <span class="comment">// cnt = 3</span></span><br></pre></td></tr></table></figure><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单参数变换（Unary Operation）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> UnaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">(InputIt first, InputIt last, OutputIt d_first, UnaryOperation unary_op)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双参数变换（Binary Operation）</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIt1, <span class="keyword">class</span> InputIt2, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> BinaryOperation&gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">(InputIt1 first1, InputIt1 last1, InputIt2 first2,</span></span></span><br><span class="line"><span class="params"><span class="function">                   OutputIt d_first, BinaryOperation binary_op)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::tolower);</span><br></pre></td></tr></table></figure><p>使用的是 <strong>单参数版本</strong>（Unary Operation），意思是：</p><ul><li>输入区间：<code>[s.begin(), s.end())</code></li><li>输出区间起始：<code>s.begin()</code>（原地修改字符串）</li><li>对每个字符应用操作：<code>::tolower</code></li></ul><blockquote><p> <code>::tolower</code> 里的 <code>::</code> 指的是<strong>全局作用域运算符</strong>，表示用 <strong>全局的 tolower 函数</strong>，避免与某些类成员同名造成歧义。</p></blockquote><p>也可以不使用 <code>tolower</code>，传你自己的处理逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), [](<span class="type">char</span> c) &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span> ? c - <span class="number">32</span> : c;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><strong>双参数变换</strong></p><p>两个数组元素相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(a.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// result[i] = a[i] + b[i]</span></span><br><span class="line">    <span class="built_in">transform</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), result.<span class="built_in">begin</span>(),</span><br><span class="line">              [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : result) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：11 22 33 44</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><ul><li>对已排序序列执行二分查找，返回 <code>bool</code>，判断是否存在</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">bool</span> found = std::<span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound/upper_bound"></a>lower_bound/upper_bound</h3><ul><li><strong>返回迭代器</strong>，<strong>要求序列已排序</strong></li><li><code>lower_bound(begin,end,val)</code>：返回第一个 <strong>&gt;= val</strong> 的位置</li><li><code>upper_bound(begin,end,val)</code>：返回第一个 <strong>&gt; val</strong> 的位置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> lb = std::<span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>); <span class="comment">// 指向第一个 2</span></span><br><span class="line"><span class="keyword">auto</span> ub = std::<span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>); <span class="comment">// 指向 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> distance = std::<span class="built_in">distance</span>(std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), startTime),</span><br><span class="line">                         std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), endTime));</span><br></pre></td></tr></table></figure><h3 id="equal-range"><a href="#equal-range" class="headerlink" title="equal_range"></a>equal_range</h3><ul><li>返回 <code>[lower_bound, upper_bound)</code> 的迭代器对，区间包含所有等于给定值的元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> range = std::<span class="built_in">equal_range</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 输出所有 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="next-permutation-prev-permutation"><a href="#next-permutation-prev-permutation" class="headerlink" title="next_permutation/prev_permutation"></a>next_permutation/prev_permutation</h3><p>生成下一个字典序排列，可以用于<strong>生成一个序列的全排列</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// v是字典序列最小</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : v) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>也用于<strong>生成一个数组的所有长度为 m 的数字组合</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化标记数组</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">select</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">fill</span>(select.<span class="built_in">end</span>() - m, select.<span class="built_in">end</span>(), <span class="number">1</span>); <span class="comment">// 后 m 个为 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 select 生成组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (select[i]) std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(select.<span class="built_in">begin</span>(), select.<span class="built_in">end</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>也可以使用 prev_permutation</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span>; <span class="comment">// 组合长度</span></span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建选择标记数组</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">select</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">fill</span>(select.<span class="built_in">begin</span>(), select.<span class="built_in">begin</span>() + m, <span class="number">1</span>); <span class="comment">// 前 m 个选中</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 用 prev_permutation 生成所有组合</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; combo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (select[i]) combo.<span class="built_in">push_back</span>(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(combo);</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">prev_permutation</span>(select.<span class="built_in">begin</span>(), select.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : c) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><ul><li><code>fill(begin,end,val)</code>：填充整个区间为指定值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">7</span>); <span class="comment">// v = &#123;7,7,7,7,7&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">select</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">fill</span>(select.<span class="built_in">begin</span>(), select.<span class="built_in">begin</span>() + m, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><ul><li><code>iota(begin,end,start)</code>：生成连续整数序列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">iota</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">10</span>); <span class="comment">// v = &#123;10,11,12,13,14&#125;</span></span><br></pre></td></tr></table></figure><h3 id="copy-swap-replace-remove-remove-if"><a href="#copy-swap-replace-remove-remove-if" class="headerlink" title="copy / swap / replace / remove / remove_if"></a><strong>copy / swap / replace / remove / remove_if</strong></h3><ul><li><code>copy(begin,end,out_it)</code>：拷贝区间到另一容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dst</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">std::<span class="built_in">copy</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dst.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><ul><li><code>swap(a,b)</code> / <code>iter_swap(it1,it2)</code>：交换元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">swap</span>(a,b);</span><br><span class="line">std::<span class="built_in">iter_swap</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>()<span class="number">+1</span>);</span><br></pre></td></tr></table></figure><ul><li><code>replace(begin,end,old_val,new_val)</code>：替换区间内元素</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li><code>remove(begin,end,val)</code> / <code>remove_if(begin,end,pred)</code>：逻辑移除（需要配合 <code>erase</code>）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>), v.<span class="built_in">end</span>());</span><br><span class="line">v.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>; &#125;), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="set-operations（集合操作）"><a href="#set-operations（集合操作）" class="headerlink" title="set operations（集合操作）"></a>set operations（集合操作）</h3><ul><li>序列必须 <strong>已排序</strong></li><li><code>merge(a,b,out)</code>：合并两个已排序序列</li><li><code>set_union(a,b,out)</code>：并集</li><li><code>set_intersection(a,b,out)</code>：交集</li><li><code>set_difference(a,b,out)</code>：差集</li><li><code>unique(begin,end)</code>：去除相邻重复元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a = &#123;1,2,2,3&#125;;</span><br><span class="line">vector&lt;int&gt; b = &#123;2,3,4&#125;;</span><br><span class="line">vector&lt;int&gt; out;</span><br><span class="line"></span><br><span class="line">std::set_union(a.begin(),a.end(),b.begin(),b.end(),std::back_inserter(out));</span><br><span class="line">// out = &#123;1,2,2,3,4&#125;</span><br><span class="line"></span><br><span class="line">a.erase(std::unique(a.begin(),a.end()), a.end()); // 去重 a = &#123;1,2,3&#125;</span><br></pre></td></tr></table></figure><h3 id="accumulate-all-of-any-of-none-of-for-each"><a href="#accumulate-all-of-any-of-none-of-for-each" class="headerlink" title="accumulate / all_of / any_of / none_of / for_each"></a><strong>accumulate / all_of / any_of / none_of / for_each</strong></h3><ul><li><code>accumulate(begin,end,init)</code>：区间求和（或自定义操作）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = std::<span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// sum = 6</span></span><br></pre></td></tr></table></figure><ul><li><code>all_of(begin,end,pred)</code> / <code>any_of</code> / <code>none_of</code>：判断区间元素是否满足条件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> all_even = std::<span class="built_in">all_of</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>; &#125;);</span><br><span class="line"><span class="type">bool</span> any_even = std::<span class="built_in">any_of</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x%<span class="number">2</span>==<span class="number">0</span>; &#125;);</span><br></pre></td></tr></table></figure><ul><li><code>for_each(begin,end,f)</code>：区间遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> &amp;x)&#123; x++; &#125;);</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-7"><a href="#时间复杂度-7" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><div class="table-container"><table><thead><tr><th>算法</th><th>功能</th><th>时间复杂度</th><th>示例代码</th></tr></thead><tbody><tr><td><strong>sort</strong></td><td>排序（不稳定）</td><td><code>O(n log n)</code></td><td><code>std::sort(v.begin(), v.end());</code></td></tr><tr><td><strong>stable_sort</strong></td><td>稳定排序</td><td><code>O(n log² n)</code> 最坏，平均 <code>O(n log n)</code></td><td><code>std::stable_sort(v.begin(), v.end());</code></td></tr><tr><td><strong>min / max</strong></td><td>两数取最小/最大</td><td><code>O(1)</code></td><td><code>std::min(a,b); std::max(a,b);</code></td></tr><tr><td><strong>min_element / max_element</strong></td><td>区间最小/最大元素迭代器</td><td><code>O(n)</code></td><td><code>*std::min_element(v.begin(), v.end());</code></td></tr><tr><td><strong>reverse</strong></td><td>反转区间</td><td><code>O(n)</code></td><td><code>std::reverse(v.begin(), v.end());</code></td></tr><tr><td><strong>find</strong></td><td>顺序查找</td><td><code>O(n)</code></td><td><code>auto it = std::find(v.begin(),v.end(),5);</code></td></tr><tr><td><strong>count</strong></td><td>统计出现次数</td><td><code>O(n)</code></td><td><code>std::count(v.begin(),v.end(),2);</code></td></tr><tr><td><strong>binary_search</strong></td><td>是否存在（二分，需有序）</td><td><code>O(log n)</code></td><td><code>std::binary_search(v.begin(),v.end(),5);</code></td></tr><tr><td><strong>lower_bound</strong></td><td>第一个 <strong>&gt;= val</strong>（二分）</td><td><code>O(log n)</code></td><td><code>auto it=std::lower_bound(v.begin(),v.end(),2);</code></td></tr><tr><td><strong>upper_bound</strong></td><td>第一个 <strong>&gt; val</strong>（二分）</td><td><code>O(log n)</code></td><td><code>auto it=std::upper_bound(v.begin(),v.end(),2);</code></td></tr><tr><td><strong>equal_range</strong></td><td>返回等于 val 的区间</td><td><code>O(log n)</code></td><td><code>auto r=std::equal_range(v.begin(),v.end(),2);</code></td></tr><tr><td><strong>fill</strong></td><td>区间赋值</td><td><code>O(n)</code></td><td><code>std::fill(v.begin(), v.end(), 7);</code></td></tr><tr><td><strong>iota</strong></td><td>连续赋值（需 <code>&lt;numeric&gt;</code>）</td><td><code>O(n)</code></td><td><code>std::iota(v.begin(),v.end(),10);</code></td></tr><tr><td><strong>copy</strong></td><td>拷贝区间</td><td><code>O(n)</code></td><td><code>std::copy(src.begin(),src.end(),dst.begin());</code></td></tr><tr><td><strong>swap / iter_swap</strong></td><td>交换元素</td><td><code>O(1)</code></td><td><code>std::swap(a,b);</code></td></tr><tr><td><strong>replace</strong></td><td>替换指定值</td><td><code>O(n)</code></td><td><code>std::replace(v.begin(),v.end(),2,5);</code></td></tr><tr><td><strong>remove / remove_if</strong></td><td>逻辑删除（需 <code>erase</code>）</td><td><code>O(n)</code></td><td><code>v.erase(std::remove(v.begin(),v.end(),5),v.end());</code></td></tr><tr><td><strong>unique</strong></td><td>去除相邻重复（逻辑删除）</td><td><code>O(n)</code></td><td><code>v.erase(std::unique(v.begin(),v.end()),v.end());</code></td></tr><tr><td><strong>set_union</strong></td><td>并集（需有序）</td><td><code>O(n+m)</code></td><td><code>std::set_union(a.begin(),a.end(),b.begin(),b.end(),back_inserter(out));</code></td></tr><tr><td><strong>set_intersection</strong></td><td>交集（需有序）</td><td><code>O(n+m)</code></td><td><code>std::set_intersection(...);</code></td></tr><tr><td><strong>set_difference</strong></td><td>差集（需有序）</td><td><code>O(n+m)</code></td><td><code>std::set_difference(...);</code></td></tr><tr><td><strong>merge</strong></td><td>合并两个有序序列</td><td><code>O(n+m)</code></td><td><code>std::merge(a.begin(),a.end(),b.begin(),b.end(),out.begin());</code></td></tr><tr><td><strong>accumulate</strong></td><td>区间累加（需 <code>&lt;numeric&gt;</code>）</td><td><code>O(n)</code></td><td><code>int sum=std::accumulate(v.begin(),v.end(),0);</code></td></tr><tr><td><strong>all_of / any_of / none_of</strong></td><td>区间条件判断</td><td><code>O(n)</code></td><td><code>std::all_of(v.begin(),v.end(),[](int x)&#123;return x%2==0;&#125;);</code></td></tr><tr><td><strong>for_each</strong></td><td>遍历执行函数</td><td><code>O(n)</code></td><td><code>std::for_each(v.begin(),v.end(),[](int &amp;x)&#123;x++;&#125;);</code></td></tr></tbody></table></div><h2 id="utility"><a href="#utility" class="headerlink" title="utility"></a>utility</h2><h3 id="引用头文件-10"><a href="#引用头文件-10" class="headerlink" title="引用头文件"></a>引用头文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><h4 id="引用头文件-11"><a href="#引用头文件-11" class="headerlink" title="引用头文件"></a><strong>引用头文件</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br></pre></td></tr></table></figure><h4 id="构造-9"><a href="#构造-9" class="headerlink" title="构造"></a><strong>构造</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> p = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 自动推断类型</span></span><br></pre></td></tr></table></figure><h4 id="访问元素-3"><a href="#访问元素-3" class="headerlink" title="访问元素"></a><strong>访问元素</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = p.first;</span><br><span class="line"><span class="type">int</span> b = p.second;</span><br></pre></td></tr></table></figure><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><p>std::move 其实是将参数 t 转换为一个右值引用类型，不会拷贝内存，不会释放资源，不会调用构造函数和析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 std::vector<int> 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; b = std::<span class="built_in">move</span>(a);</span><br></pre></td></tr></table></figure><p>这里：std::move(a) 把 a 变成右值引用。编译器会选择 vector 的移动构造函数，而不是拷贝构造。<br>移动构造函数做的事：</p><ul><li>把 a 的内部指针直接“偷走”，交给 b。</li><li>把 a 的指针设为空，避免析构时释放同一块内存。</li></ul><p>所以最后：b 持有 {1,2,3} 的数据。a 变成空的（size()==0，但仍然是合法对象）</p><p>总结：<br>nums1 = std::move(vec);</p><ul><li>旧内容自动释放（移动赋值内部完成）</li><li>新内容接管</li><li>vec 变空<br>不需要自己手动调用析构函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P407 接雨水II</title>
      <link href="/posts/407/"/>
      <url>/posts/407/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-03</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P407 接雨水II" href="https://leetcode.cn/problems/trapping-rain-water-ii/description/?envType=daily-question&envId=2025-10-03"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P407 接雨水II</p><p class="url">https://leetcode.cn/problems/trapping-rain-water-ii/description/?envType=daily-question&envId=2025-10-03</p></div></a></div></p><ul><li><p>边界格子永远不能存水<br>因为水会从边界流走，所以水池的边界就是矩阵的四周。</p></li><li><p>从最矮的边界开始填充<br>类似「木桶效应」，水位由最低的边界决定。因此我们需要 动态维护当前最低的边界高度。</p></li><li><p>算法步骤（小根堆 + BFS）</p><ul><li>把 所有边界格子（四周一圈）放进 最小堆（优先队列，按高度从小到大排序），并标记为已访问。</li><li>每次从堆里弹出一个当前最低的格子，记作 cell。</li><li>扫描它的 4 个方向的邻居：<ul><li>如果邻居没访问过：若邻居高度 &lt; cell 的高度，说明这里能积水，积水量是 cell高度 - 邻居高度。更新邻居的「有效高度」为 max(邻居高度, cell高度)（水填满了之后，它的高度相当于水面）。把邻居加入堆。</li></ul></li><li>不断重复，直到堆为空。</li></ul></li></ul><p>这样，整个算法就相当于「从最矮的边界往里灌水」。</p><p>举个例子<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  <span class="comment">[5,5,5,5]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[5,1,1,5]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[5,1,1,5]</span>,</span></span><br><span class="line"><span class="comment">  <span class="comment">[5,5,5,5]</span></span></span><br><span class="line"><span class="comment">]</span></span><br></pre></td></tr></table></figure><br>外圈高度全是 5，中间是 1。从边界出发，堆里最低高度是 5。处理到中间格子时，发现高度 1，比边界水位 5 低 → 能装 4 个水。每个内部格子装 4，最后得到 4*4=16。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> priority_queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt;,</span><br><span class="line">                       std::greater&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt;</span><br><span class="line">    min_heap;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">trapRainWater</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;heightMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m = heightMap.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = heightMap[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    min_heap pq;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visit</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">2</span> || n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || i == m - <span class="number">1</span> || j == <span class="number">0</span> || j == n - <span class="number">1</span>) &#123;</span><br><span class="line">          pq.<span class="built_in">push</span>(&#123;heightMap[i][j], i, j&#125;);</span><br><span class="line">          visit[i][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dirs[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">auto</span> [h, x, y] = pq.<span class="built_in">top</span>();</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="comment">// 遍历堆顶的上下左右</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dirs[k];</span><br><span class="line">        <span class="type">int</span> ny = y + dirs[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !visit[nx][ny]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (heightMap[nx][ny] &lt; h) &#123;</span><br><span class="line">            res += h - heightMap[nx][ny];</span><br><span class="line">          &#125;</span><br><span class="line">          visit[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">          pq.<span class="built_in">push</span>(&#123;std::<span class="built_in">max</span>(heightMap[nx][ny], h), nx, ny&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> BFS </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P274 H指数</title>
      <link href="/posts/274/"/>
      <url>/posts/274/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-03</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P274 H指数" href="https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P274 H指数</p><p class="url">https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>排序后，此时 citations[i]表示有 n-i 个论文大于等于 citations[i]，我们直接遍历 h 找最大值即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文</span></span><br><span class="line">  <span class="comment">// 并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数</span></span><br><span class="line">  <span class="comment">// 是其中最大的那个。</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;citations)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    n = citations.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    std::<span class="built_in">sort</span>(citations.<span class="built_in">begin</span>(), citations.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">// 遍历h</span></span><br><span class="line">      <span class="keyword">if</span> (citations[n - i] &gt;= i) &#123;</span><br><span class="line">        h = std::<span class="built_in">max</span>(h, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 排序 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL2 Archlinux镜像网络模式无法访问网络的问题</title>
      <link href="/posts/50005/"/>
      <url>/posts/50005/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-03</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>在 Win11 + WSL2 archlinux 的 mirrored 网络模式下，重启后有概率会触发无法 WSL 访问网络但 Windows 可以访问的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510031811227.png" alt="环境"></p><p>wsl 配置</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[wsl2]</span></span><br><span class="line"><span class="attr">dnsTunneling</span>=<span class="literal">true</span>         <span class="comment"># DNS隧道（解决某些网络问题）</span></span><br><span class="line"><span class="attr">firewall</span>=<span class="literal">true</span>            <span class="comment"># 启用防火墙集成</span></span><br><span class="line"><span class="attr">autoProxy</span>=<span class="literal">true</span>          <span class="comment"># 自动同步Windows代理设置</span></span><br><span class="line"><span class="attr">networkingMode</span>=Mirrored</span><br><span class="line"></span><br><span class="line"><span class="section">[experimental]</span></span><br><span class="line"><span class="attr">hostAddressLoopback</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">bestEffortDnsParsing</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="ping-网关"><a href="#ping-网关" class="headerlink" title="ping 网关"></a>ping 网关</h1><p>先确认能不能 ping 通网关。</p><ul><li>如果能 ping 通 IP 但不能访问域名 → 是 DNS 问题</li><li>连 IP 都 ping 不通 → 是 网络转发 / 网卡 / 防火墙问题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 8.8.8.8</span><br></pre></td></tr></table></figure><h1 id="DNS-问题"><a href="#DNS-问题" class="headerlink" title="DNS 问题"></a>DNS 问题</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> emacs /etc/resolve.conf</span><br><span class="line"><span class="comment"># 写入如下配置</span></span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 1.1.1.1</span><br></pre></td></tr></table></figure><p>为避免每次重启被覆盖，可以关闭自动生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&quot;echo &#x27;[network]&#x27; &gt; /etc/wsl.conf&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&quot;echo &#x27;generateResolvConf = false&#x27; &gt;&gt; /etc/wsl.conf&quot;</span></span><br></pre></td></tr></table></figure><p>重启 WSL</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br></pre></td></tr></table></figure><p>查看网络是否恢复</p><h1 id="防火墙问题"><a href="#防火墙问题" class="headerlink" title="防火墙问题"></a>防火墙问题</h1><p>打开 windows 安全中心的防火墙和网络保护：<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510031217361.png" alt="防火墙和网络保护"><br>点击允许应用通过防火墙，将 C:\Windows\System32\wsl.exe 加入。<br>再次查看网络是否恢复。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P45 跳跃游戏II</title>
      <link href="/posts/45/"/>
      <url>/posts/45/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-02</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P45 跳跃游戏II" href="https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P45 跳跃游戏II</p><p class="url">https://leetcode.cn/problems/jump-game-ii/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>我最先想到的是动态规划<br>令 dp[i] 表示到达 i 的最小跳跃次数，-1表示不可达，那么对于0 &lt;= j &lt; i<br>如果j可以到达 i ,即 nums[j] + j &gt;= i 且 dp[j] != -1</p><script type="math/tex; mode=display"> dp[i] = min (dp[j] +1)</script><p>如果没有可达的j那么</p><script type="math/tex; mode=display"> dp[i] = -1</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i]表示到达i的最小跳跃次数,-1表示不可达</span></span><br><span class="line">    <span class="comment">// 对于 0&lt;=j &lt;i</span></span><br><span class="line">    <span class="comment">// if(nums[j] + j &gt;= i ) dp[i] = dp[j] +1;</span></span><br><span class="line">    <span class="comment">// 如果不存在这样的j,dp[i] = -1;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      min = INT_MAX;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] + j &gt;= i &amp;&amp; dp[j] != <span class="number">-1</span> &amp;&amp; dp[j] + <span class="number">1</span> &lt; min) &#123;</span><br><span class="line">          min = dp[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (min != INT_MAX) &#123;</span><br><span class="line">        dp[i] = min;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[i] = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这道题其实是经典的贪心题，从后往前看，最后一个位置一定是之前某个位置跳过来的，但是这个之前的位置可能有多个，那么我们就贪心地选择最远的那个(因为反正都是多一步，选择离起点更近的必定能减少跳跃次数，这因为如果两个点都能到达最后一个位置，a的位置靠前，b的位置靠后，那么我们肯定会选择a，因为到达a的step必定小于等于b的step)。选择后，选择的这个位置就成了新的最后一个位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> position = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; position; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt;= position) &#123;</span><br><span class="line">                    position = i;</span><br><span class="line">                    steps++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P55 跳跃游戏</title>
      <link href="/posts/55/"/>
      <url>/posts/55/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-02</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P55 跳跃游戏" href="https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P55 跳跃游戏</p><p class="url">https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>我最先想到的是用队列遍历，BFS解法，用栈应该也行，可以看到这个复杂度相当大。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"><span class="keyword">using</span> std::unordered_set;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> jmp;</span><br><span class="line">    <span class="type">int</span> curr;</span><br><span class="line">    <span class="type">int</span> i, tmp;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    uset.<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      curr = que.<span class="built_in">front</span>();</span><br><span class="line">      jmp = nums[curr];</span><br><span class="line">      <span class="keyword">if</span> (jmp == <span class="number">0</span>) &#123;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        uset.<span class="built_in">erase</span>(curr);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= jmp; i++) &#123;</span><br><span class="line">        tmp = curr + i;</span><br><span class="line">        <span class="keyword">if</span> (tmp == n - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp &lt; n &amp;&amp; uset.<span class="built_in">count</span>(tmp) == <span class="number">0</span>) &#123;</span><br><span class="line">          que.<span class="built_in">push</span>(tmp);</span><br><span class="line">          uset.<span class="built_in">insert</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      uset.<span class="built_in">erase</span>(curr);</span><br><span class="line">      que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (!que.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution S;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, S.<span class="built_in">canJump</span>(vec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看了评论有一个解法很有趣，采用贪心策略，不用想具体过程，能跳多远就跳多远，如果跳过了最后的位置之后，那么必定能跳到最后位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max_jump = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=max_jump &amp;&amp; i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">            max_jump = std::<span class="built_in">max</span>(max_jump, i+nums[i]);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> (max_jump&gt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这题也可以用动态规划，时间复杂度O(n^2)<br>dp[i] = true 表示能到达i, dp[i] = false 表示不能到达i<br>那么对于位置i，如果存在j( 0 &lt;= j &lt; i )能到达，并且j出发的最大跳跃距离能覆盖i，即：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j+nums[j]&gt;=i)&#123;</span><br><span class="line">  dp[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  dp[j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; j + nums[j] &gt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">// 只要能到达，就不用再继续找</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3100 换水问题II</title>
      <link href="/posts/3100/"/>
      <url>/posts/3100/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-02</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3100 换水问题II" href="https://leetcode.cn/problems/water-bottles-ii/description/?envType=daily-question&envId=2025-10-02"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3100 换水问题II</p><p class="url">https://leetcode.cn/problems/water-bottles-ii/description/?envType=daily-question&envId=2025-10-02</p></div></a></div></p><p>总是喝完所有水，如果没水就交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxBottlesDrunk</span><span class="params">(<span class="type">int</span> numBottles, <span class="type">int</span> numExchange)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> full_bottles = numBottles;</span><br><span class="line">    <span class="type">int</span> empty_bottles = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num_exchange = numExchange;</span><br><span class="line">    <span class="type">int</span> bottle_drunk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (full_bottles &gt; <span class="number">0</span> || empty_bottles &gt;= num_exchange) &#123;</span><br><span class="line">      <span class="comment">// drink</span></span><br><span class="line">      bottle_drunk += full_bottles;</span><br><span class="line">      empty_bottles += full_bottles;</span><br><span class="line">      full_bottles = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// exchange</span></span><br><span class="line">      <span class="keyword">while</span> (empty_bottles &gt;= num_exchange) &#123;</span><br><span class="line">        empty_bottles -= num_exchange;</span><br><span class="line">        num_exchange++;</span><br><span class="line">        full_bottles++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bottle_drunk;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P122 买卖股票的最佳时机 II</title>
      <link href="/posts/122/"/>
      <url>/posts/122/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-01</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P122 买卖股票的最佳时机 II" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P122 买卖股票的最佳时机 II</p><p class="url">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>假设 dp[i][0]表示第 i 天的最大利润且不持有股票,dp[i][1]表示第 i 天最大利润且持有股票<br>那么:</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</script><p>第 i 天不持有股票可能是昨天就不持有,今天也不买入,也有可能是昨天持有,今天卖出(这里直接+prices[i]是因为买入股票时我们直接-prices[i],可以理解为我们维护的是当前的余额)</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1])</script><p>第 i 天持有股票可能是昨天就持有,今天也不买入,也有可能是昨天持有,今天买入(这里直接-prices[i]是因为买入股票时我们直接+prices[i],可以理解为我们维护的是当前的余额)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp[i][0] 第i天最大利润并且不持有股票</span></span><br><span class="line">    <span class="comment">// dp[i][1] 第i天最大利润且持有股票</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    n = prices.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="comment">// dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])</span></span><br><span class="line">    <span class="comment">// dp[i][1] = max(dp[i-1][0]-prices[i], dp[i-1][1])</span></span><br><span class="line">    dp[<span class="number">0</span>].first = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>].second = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      dp[i].first = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>].first, dp[i - <span class="number">1</span>].second + prices[i]);</span><br><span class="line">      dp[i].second = std::<span class="built_in">max</span>(dp[i - <span class="number">1</span>].first - prices[i], dp[i - <span class="number">1</span>].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>].first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P121 买股票的最佳时机</title>
      <link href="/posts/121/"/>
      <url>/posts/121/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-01</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P121 买卖股票的最佳时机" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P121 买卖股票的最佳时机</p><p class="url">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>维护两个值即可,一个是当前最低的价格,一个是历史最大利润.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> max_profit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min_price = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      max_profit = std::<span class="built_in">max</span>(prices[i] - min_price, max_profit);</span><br><span class="line">      min_price = std::<span class="built_in">min</span>(prices[i], min_price);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_profit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 数组 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2221 数组的三角和</title>
      <link href="/posts/2221/"/>
      <url>/posts/2221/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-01</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2221 数组的三角和" href="https://leetcode.cn/problems/find-triangular-sum-of-an-array/description/?envType=daily-question&envId=2025-10-01"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2221 数组的三角和</p><p class="url">https://leetcode.cn/problems/find-triangular-sum-of-an-array/description/?envType=daily-question&envId=2025-10-01</p></div></a></div></p><p>数学模拟</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">triangularSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> bound;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      bound = n - k;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; bound - <span class="number">1</span>) &#123;</span><br><span class="line">        nums[i] = (nums[i] + nums[i + <span class="number">1</span>]) % <span class="number">10</span>;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P1518 换水问题</title>
      <link href="/posts/1518/"/>
      <url>/posts/1518/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-01</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P1518 换水问题" href="https://leetcode.cn/problems/water-bottles/description/?envType=daily-question&envId=2025-10-01"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P1518 换水问题</p><p class="url">https://leetcode.cn/problems/water-bottles/description/?envType=daily-question&envId=2025-10-01</p></div></a></div></p><p>简单的数学模拟题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numWaterBottles</span><span class="params">(<span class="type">int</span> numBottles, <span class="type">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每numExchange个bottles喝完可以换一瓶bottle</span></span><br><span class="line">    <span class="type">int</span> exchange_bootles = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> total_water = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      exchange_bootles = numBottles / numExchange;</span><br><span class="line">      numBottles = numBottles % numExchange;</span><br><span class="line">      numBottles += exchange_bootles;</span><br><span class="line">      total_water += exchange_bootles * numExchange;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (numBottles &gt;= numExchange);</span><br><span class="line">    total_water += numBottles;</span><br><span class="line">    <span class="keyword">return</span> total_water;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P189 轮转数组</title>
      <link href="/posts/189/"/>
      <url>/posts/189/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-29</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P189 轮转数组" href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P189 轮转数组</p><p class="url">https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>用额外数组的方式。这种方法时间复杂度在 O(n)，但是开辟额外数组也会花时间空间复杂度也是 O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line"></span><br><span class="line">    n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      pos = (i + k) % n;</span><br><span class="line">      vec[pos] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nums = std::<span class="built_in">move</span>(vec);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另一种巧妙的方式：<br>我们将数组的元素向右移动 k 次后，尾部<strong>k mod n</strong>个元素会移动至数组头部，其余元素向后移动 kmodn 个位置。</p><p>该方法为数组的翻转：我们可以先将所有元素翻转，这样尾部的<strong>k mod n</strong>个元素就被移至数组头部，然后我们再翻转 [0,k mod n−1] 区间的元素和 [k mod n,n−1] 区间的元素即能得到最后的答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P169 多数元素</title>
      <link href="/posts/169/"/>
      <url>/posts/169/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-29</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P169 多数元素" href="https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P169 多数元素</p><p class="url">https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>排序后直接返回中间那个元素就行<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P80 删除有序数组中的重复项 II</title>
      <link href="/posts/80/"/>
      <url>/posts/80/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-29</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P80 删除有序数组中的重复项 II" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P80 删除有序数组中的重复项 II</p><p class="url">https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>这种简单直接的方法还是可以过的，但是效率很低很低，几乎是擦边过。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    n = nums.<span class="built_in">size</span>();</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= <span class="number">2</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] == nums[i - <span class="number">2</span>]) &#123;</span><br><span class="line">        nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>() + i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>采用双指针方法更为高效(快慢指针)，在原数组上“覆盖掉”多余的元素。</p><ul><li>慢指针（slow）：指向当前结果数组的末尾。</li><li>快指针（fast）：遍历整个数组。<br>如果 slow &lt; 2，直接保留（因为前两个元素无论如何都要保留）。<br>如果 nums[fast] != nums[slow - 2]，说明新数字还没超过 2 次， 覆盖num[slow]的值。<br>否则跳过。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">2</span>, fast = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                ++slow;</span><br><span class="line">            &#125;</span><br><span class="line">            ++fast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P1039 多边形三角剖分的最低得分</title>
      <link href="/posts/1039/"/>
      <url>/posts/1039/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-29</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P1039 多边形三角剖分的最低得分" href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/?envType=daily-question&envId=2025-09-29"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P1039 多边形三角剖分的最低得分</p><p class="url">https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/?envType=daily-question&envId=2025-09-29</p></div></a></div></p><p>该题显然存在子问题，可以向动态规划考虑。假定从 i 到 k 区间的顶点，k 处于 i 到 k 之间但不等于 i 或 k,那么该问题等于 i 到 k 的多变形最小剖分分数+k 到 j 的多边形最小剖分分数+i,j,k 组成的多边形面积，因为不论怎么划分，i 和 j 必定要和其区间的一个顶点组成一个三角形。由此可列出状态转移方程：</p><script type="math/tex; mode=display">dp[i][j] =min{ dp[i][k] + dp[k][j] + values[i] *values[j] *values[k]}</script><blockquote><p>dp[i][j] 表示第 i 个顶点到第 j 个顶点的凸多边形的最小三角形剖分分数，k 为 i~j 内任意一个顶点不包括 i 和 j</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// dp[i][j] 第i个顶点到第j个顶点的凸多边形的最小三角形剖分分数</span></span><br><span class="line">  <span class="comment">// k为i~j内任意一个顶点不包括i和j</span></span><br><span class="line">  <span class="comment">// dp[i][j] =min k&#123; dp[i][k] + dp[k][j]+ values[i] *values[j] *values[k]&#125;</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">minScoreTriangulation</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;values)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> vertex; <span class="comment">// i~j共有多少个顶点</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    n = values.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (vertex = <span class="number">2</span>; vertex &lt; n; vertex++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i + vertex &lt; n; i++) &#123;</span><br><span class="line">        j = i + vertex;</span><br><span class="line">        dp[i][j] = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">          dp[i][j] = std::<span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j] +</span><br><span class="line">                                            values[i] * values[j] * values[k]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/posts/43001/"/>
      <url>/posts/43001/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-28</p></div></div><div class='timeline-item-content'><p>add 绪论</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-18</p></div></div><div class='timeline-item-content'><p>add 线性表，栈，队列，数组，串</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-20</p></div></div><div class='timeline-item-content'><p>add 树，图</p></div></div></div><hr><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h2><blockquote><p>数据的逻辑结构是指数据元素之间的关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的</p></blockquote><ul><li>线性结构<ul><li>线性表<ul><li>数组</li><li>栈</li><li>队列</li></ul></li></ul></li><li>非线性结构<ul><li>集合</li><li>树形结构<ul><li>一般树</li><li>二叉树</li></ul></li><li>图状结构<ul><li>有向图</li><li>无向图</li></ul></li></ul></li></ul><h2 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h2><p>存储结构是指数据结构在计算机中的表示，也称物理结构</p><ul><li>顺序存储</li></ul><blockquote><p>顺序存储是指把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中；</p></blockquote><ul><li>链式存储</li></ul><blockquote><p>链式存储借助指示元素存储地址的指针来表示元素之间的逻辑关系；</p></blockquote><ul><li>索引存储</li></ul><blockquote><p>索引存储是指在存储元素信息的同时，还建立附加的索引表。索引表中的每项都称为索引项，索引项的一般形式是(关键字 key，地址 address);</p></blockquote><ul><li>散列存储</li></ul><blockquote><p>散列存储是根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储。</p></blockquote><h2 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h2><ul><li>有穷性</li></ul><blockquote><p>有穷性是指一个算法必须总在执行有穷步后结束，且每一步都在有穷时间内完成；</p></blockquote><ul><li>确定性</li></ul><blockquote><p>确定性是指算法中每条指令都必须有正确的含义，对于相同的输入只能得出相同的输出；</p></blockquote><ul><li>可行性</li></ul><blockquote><p>可行性是指算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现；</p></blockquote><ul><li>输入</li></ul><blockquote><p>输入是指一个算法有0或多个输入，这些输入取自于某个特定的对象的集合</p></blockquote><ul><li>输出</li></ul><blockquote><p>输出是指一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。</p></blockquote><h2 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><script type="math/tex; mode=display">T(n) = O(f(n))</script><p>加法规则：</p><script type="math/tex; mode=display">T(n) = T_1(n)+T_2(n)=O(f(n)) + O(g(n)) = O(max(f(n),g(n)))</script><p>常见的渐进时间复杂度</p><script type="math/tex; mode=display">O(1) < O(log_2^n) < O(n) < O(nlog^n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)</script><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><script type="math/tex; mode=display">S(n) = O(g(n))</script><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p><strong>定义</strong>：线性表是具有<strong>相同数据类型</strong>的n(n&gt;=0)个数据元素的有限序列。</p><p>线性表一般表示为：</p><script type="math/tex; mode=display">L = (a_1,a_2,a_3,...,a_i,a_{i+1}, ..., a_n)</script><h2 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示"></a>线性表的顺序表示</h2><blockquote><p>线性表的顺序存储也称顺序表，其特点是表中元素的逻辑顺序与其物理顺序相同。线性表是一种<strong>随机存取</strong>的存储结构</p></blockquote><h3 id="C语言描述"><a href="#C语言描述" class="headerlink" title="C语言描述"></a>C语言描述</h3><ul><li>静态分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];</span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><ul><li>动态分配</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure><h3 id="C-描述"><a href="#C-描述" class="headerlink" title="C++描述"></a>C++描述</h3><p>一般使用标准库vector，也可以自定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *data;  </span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> new_capacity)</span> </span>&#123;</span><br><span class="line">        T* new_data = <span class="keyword">new</span> T[new_capacity];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            new_data[i] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        data = new_data;</span><br><span class="line">        capacity = new_capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">capacity</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SeqList</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Rust描述"><a href="#Rust描述" class="headerlink" title="Rust描述"></a>Rust描述</h3><p>Rust中一般用标准库的Vec，自己写要用许多unsafe API</p><h3 id="基本操作时间复杂度"><a href="#基本操作时间复杂度" class="headerlink" title="基本操作时间复杂度"></a>基本操作时间复杂度</h3><div class="table-container"><table><thead><tr><th>操作</th><th>最好情况</th><th>最坏情况</th><th>平均情况</th><th>备注</th></tr></thead><tbody><tr><td>按位置插入</td><td>O(1)（表尾）</td><td>O(n)（表头）</td><td>O(n)</td><td>表尾插入均摊 O(1)</td></tr><tr><td>按位置删除</td><td>O(1)（表尾）</td><td>O(n)（表头）</td><td>O(n)</td><td>表尾删除 O(1)</td></tr><tr><td>按下标访问</td><td>O(1)</td><td>O(1)</td><td>O(1)</td><td>数组随机访问</td></tr><tr><td>查找（顺序）</td><td>O(1)</td><td>O(n)</td><td>O(n)</td><td>如果无序只能顺序查找</td></tr></tbody></table></div><h3 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h3><p><strong>对长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素</strong></p><p>一种解法：用k记录顺序表L中不等于x的元素的个数，扫描时将不等于x的元素移动到下标k的位置，并更新k值。扫描结束后修改L的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_x</span><span class="params">(Sqlist &amp;L, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; L.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] != x)&#123;</span><br><span class="line">            L.data[k] = L.data[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表的链式表示"><a href="#线性表的链式表示" class="headerlink" title="线性表的链式表示"></a>线性表的链式表示</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>线性表的链式存储又称单链表。</p><h4 id="C语言描述-1"><a href="#C语言描述-1" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure><p>这个C语言定义的效果是</p><div class="table-container"><table><thead><tr><th>部分</th><th>含义</th></tr></thead><tbody><tr><td><code>struct Node &#123; ... &#125;;</code></td><td>定义了一个结构体类型，标签名是 <code>Node</code>（即 <code>struct Node</code>）</td></tr><tr><td><code>LNode</code></td><td>给 <code>struct Node</code> 起了一个<strong>类型别名</strong></td></tr><tr><td><code>*LinkList</code></td><td>给 <code>struct Node*</code>（即该结构体指针）起了一个别名为LinkList</td></tr></tbody></table></div><h4 id="C-描述-1"><a href="#C-描述-1" class="headerlink" title="C++描述"></a>C++描述</h4><p>TODO</p><h4 id="Rust描述-1"><a href="#Rust描述-1" class="headerlink" title="Rust描述"></a>Rust描述</h4><p>TODO</p><h4 id="头结点"><a href="#头结点" class="headerlink" title="头结点"></a>头结点</h4><p>通常用<strong>头指针</strong>来标识一个单链表，头指针为NULL时表示一个空表。此外，为了操作上的方便，在单链表第一个结点之前附加一个结点，称为<strong>头节点</strong>。</p><ul><li><p>头节点的数据域可以不设置任何信息，也可以记录表长等信息。</p></li><li><p>引入头节点可以带来两个优点：</p><ul><li>由于第一个数据节点的位置被放在头节点的指针域中，因此在链表上的第一个位置上的操作和在表的其他位置上的操作一致，无需进行特殊处理</li><li>无论链表是否为空，其头指针都是指向头节点的非空指针（空表中头节点的指针域为NULL）,因此空表和非空表的处理也就得到了统一。</li></ul></li></ul><h4 id="头插法建立单链表"><a href="#头插法建立单链表" class="headerlink" title="头插法建立单链表"></a>头插法建立单链表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插法建立单链表</span></span><br><span class="line">LinkList <span class="title function_">LinkListInit_HeadInsert</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  LinkList L;</span><br><span class="line">  LNode *node;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">  L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) != EOF) &#123;</span><br><span class="line">    node = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    node-&gt;data = x;</span><br><span class="line">    node-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h4><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>单链表中只有一个指向其后继的指针，使得单链表只能从头节点依次顺序地向后遍历。双链表节点中有两个指针prior和next，分别指向前驱节点和后继节点。</p><h4 id="C语言描述-2"><a href="#C语言描述-2" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br></pre></td></tr></table></figure><h4 id="C-描述-2"><a href="#C-描述-2" class="headerlink" title="C++描述"></a>C++描述</h4><p>TODO</p><h4 id="Rust描述-2"><a href="#Rust描述-2" class="headerlink" title="Rust描述"></a>Rust描述</h4><p>TODO</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p>循环单链表和单链表的区别在于，表中的最后一个节点的指针不是NULL，而改为指向头节点，从而整个链表形成一个环。</p><h5 id="C语言描述-3"><a href="#C语言描述-3" class="headerlink" title="C语言描述"></a>C语言描述</h5><h5 id="C-描述-3"><a href="#C-描述-3" class="headerlink" title="C++描述"></a>C++描述</h5><h5 id="Rust描述-3"><a href="#Rust描述-3" class="headerlink" title="Rust描述"></a>Rust描述</h5><h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><p>循环双链表相比于循环单链表，其头节点的prior指针要指向尾节点</p><h5 id="C语言描述-4"><a href="#C语言描述-4" class="headerlink" title="C语言描述"></a>C语言描述</h5><h5 id="C-描述-4"><a href="#C-描述-4" class="headerlink" title="C++描述"></a>C++描述</h5><h5 id="Rust描述-4"><a href="#Rust描述-4" class="headerlink" title="Rust描述"></a>Rust描述</h5><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>静态链表借助数组来描述线性表的链式存储结构，节点也有数据域data和指针域next，与前面的链表中的指针不同的是，这里的指针是节点的相对地址（数组下标），又称游标。和顺序表相同，静态链表也要预先分配一块连续的内存地址空间。</p><p>例如：</p><div class="table-container"><table><thead><tr><th>下标</th><th>data</th><th>next</th></tr></thead><tbody><tr><td>0</td><td></td><td>4</td></tr><tr><td>1</td><td>头结点</td><td>2</td></tr><tr><td>2</td><td>10</td><td>3</td></tr><tr><td>3</td><td>20</td><td>5</td></tr><tr><td>4</td><td></td><td>6</td></tr><tr><td>5</td><td>30</td><td>-1</td></tr><tr><td>6</td><td></td><td>-1</td></tr></tbody></table></div><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">主链表部分：</span><br><span class="line">┌──────┬──────┬──────┐      ┌──────┬──────┬──────┐      ┌──────┬──────┬──────┐</span><br><span class="line">│ <span class="attribute">idx</span>=1│ data │ next │ ---&gt; │ <span class="attribute">idx</span>=2│  10  │ next │ ---&gt; │ <span class="attribute">idx</span>=3│  20  │ next │ ---&gt; [<span class="attribute">idx</span>=5│ 30 │ -1│]</span><br><span class="line">└──────┴──────┴──────┘      └──────┴──────┴──────┘      └──────┴──────┴──────┘</span><br><span class="line"></span><br><span class="line">空闲链表部分：</span><br><span class="line">┌──────┬──────┬──────┐      ┌──────┬──────┬──────┐</span><br><span class="line">│ <span class="attribute">idx</span>=0│  —   │  4   │ ---&gt; │ <span class="attribute">idx</span>=4│  —   │  6   │ ---&gt; [<span class="attribute">idx</span>=6│ — │ -1│]</span><br><span class="line">└──────┴──────┴──────┘      └──────┴──────┴──────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="C语言描述-5"><a href="#C语言描述-5" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br></pre></td></tr></table></figure><h4 id="C-描述-5"><a href="#C-描述-5" class="headerlink" title="C++描述"></a>C++描述</h4><h4 id="Rust描述-5"><a href="#Rust描述-5" class="headerlink" title="Rust描述"></a>Rust描述</h4><h3 id="经典题目-1"><a href="#经典题目-1" class="headerlink" title="经典题目"></a>经典题目</h3><h4 id="检测单链表是否存在环"><a href="#检测单链表是否存在环" class="headerlink" title="检测单链表是否存在环"></a>检测单链表是否存在环</h4><p><strong>单链表有环是指单链表的最后一个结点的指针指向了链表中的某个节点（通常单链表的最后一个节点的指针是空的）。试编写算法判断单链表是否存在环</strong></p><h4 id="求两个单链表的公共节点"><a href="#求两个单链表的公共节点" class="headerlink" title="求两个单链表的公共节点"></a>求两个单链表的公共节点</h4><h1 id="栈，队列和数组"><a href="#栈，队列和数组" class="headerlink" title="栈，队列和数组"></a>栈，队列和数组</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>栈（Stack）</strong>是只允许<strong>在一端进行插入或删除操作的线性表</strong>。</p><ul><li><strong>栈顶（Top）</strong> 线性表允许进行插入删除的那一端</li><li><strong>栈底（Bottom）</strong> 固定的。不允许进行插入和删除的另外一端</li></ul><p>栈的特性可以明显的概括为<strong>后进先出（Last In First Out，LIFO）</strong></p><p>栈的数学性质：</p><blockquote><p><strong>n 个不同元素进栈，其可能的出栈序列个数为第 n 个 Catalan 数（卡特兰数）</strong></p></blockquote><p>公式为：</p><script type="math/tex; mode=display">C_n = \frac{1}{n+1} C_{2n}^n = \frac{(2n)!}{n! (n+1)!}</script><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><h4 id="C语言描述-6"><a href="#C语言描述-6" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data[MaxSize];</span><br><span class="line">    <span class="comment">// 栈顶指针</span></span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h4 id="C-描述-6"><a href="#C-描述-6" class="headerlink" title="C++描述"></a>C++描述</h4><p>TODO</p><h4 id="Rust描述-6"><a href="#Rust描述-6" class="headerlink" title="Rust描述"></a>Rust描述</h4><p>TODO</p><h4 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h4><p>利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下标:  <span class="number"> 0 </span> <span class="number"> 1 </span> <span class="number"> 2 </span> <span class="number"> 3 </span> <span class="number"> 4 </span> <span class="number"> 5 </span> <span class="number"> 6 </span> <span class="number"> 7 </span> <span class="number"> 8 </span>  9</span><br><span class="line">        ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">Stack1→ │10 │20 │30 │   │   │   │   │   │40 │50 │ ←Stack2</span><br><span class="line">        └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">         ↑                   ↑                   ↑</span><br><span class="line">       base1                mid                base2</span><br><span class="line">         ↑                                       ↑</span><br><span class="line">       top1=2                               top2=8</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>共享栈是为了更有效地利用地址空间。当且仅当两个栈相邻时发生栈满上溢。</p><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>采用链式存储的栈称为<strong>链栈</strong>，<strong>链栈</strong>的优点</p><ul><li>便于多个栈共享存储空间和提高效率</li><li>不存在栈满上溢的情况</li></ul><p>链栈通常采用单链表实现，并规定所有操作都是在表头进行。</p><h4 id="C语言描述-7"><a href="#C语言描述-7" class="headerlink" title="C语言描述"></a>C语言描述</h4><p>这里规定链栈没有头节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LiStack;</span><br></pre></td></tr></table></figure><h4 id="C-描述-7"><a href="#C-描述-7" class="headerlink" title="C++描述"></a>C++描述</h4><p>TODO</p><h4 id="Rust描述-7"><a href="#Rust描述-7" class="headerlink" title="Rust描述"></a>Rust描述</h4><p>TODO</p><h3 id="经典应用"><a href="#经典应用" class="headerlink" title="经典应用"></a>经典应用</h3><h4 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h4><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><h4 id="递归转为栈实现"><a href="#递归转为栈实现" class="headerlink" title="递归转为栈实现"></a>递归转为栈实现</h4><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列（Queue）</strong>也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的一端进行删除。</p><ul><li><strong>队头（Front）</strong> 允许删除的一端，也称<strong>队首</strong></li><li><p><strong>队尾（Rear）</strong> 允许插入的一端</p></li><li><p><strong>入队（EnQueue）</strong> 向队尾插入元素</p></li><li><strong>出队（DeQueue）</strong> 队头删除元素</li></ul><p>队列的特性可简单概括为<strong>先进先出（First In First Out，FIFO）</strong></p><h3 id="队列的顺序存储结构"><a href="#队列的顺序存储结构" class="headerlink" title="队列的顺序存储结构"></a>队列的顺序存储结构</h3><h4 id="C语言描述-8"><a href="#C语言描述-8" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h4 id="C-描述-8"><a href="#C-描述-8" class="headerlink" title="C++描述"></a>C++描述</h4><p>TODO</p><h4 id="Rust描述-8"><a href="#Rust描述-8" class="headerlink" title="Rust描述"></a>Rust描述</h4><p><strong>判断队空</strong></p><p><strong>Q.rear == Q.front</strong>==0</p><p><strong>判断队满</strong></p><p>由于：</p><ul><li>进队操作：队不满时，先送值到队尾元素，再将队尾指针+1</li><li>出队操作：队不为空时，先取队头元素值，再将队头指针+1</li></ul><p>因此不能用“<strong>Q.rear==MaxSize</strong> ”作为队列满的条件，整个问题使用循环队列来解决</p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>将顺序队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为<strong>循环队列</strong></p><ul><li>当队首指针 <strong>Q.front == MaxSize -1</strong>后，再前进一个位置到0</li><li>初始化：<strong>Q.front = Q.rear = 0</strong></li><li>队首指针进1：<strong>Q.front = (Q.front + 1) % MaxSize</strong></li><li>队尾指针进1：<strong>Q.rear = (Q.rear + 1) % MaxSize</strong></li><li><p><strong>判断队满三种方式</strong></p><ul><li><p>牺牲一个单元来区分队空队满，入队时少用一个队列单元，这是较为普遍的做法，约定以”队头指针在队尾指针的下一位置作为队满的标志”</p><ul><li><strong>队满条件</strong> : <strong>(Q.rear + 1) % MaxSize == Q.front</strong></li><li><strong>队空条件</strong>: <strong>(Q.front == Q.rear)</strong></li><li><strong>队列中元素的个数</strong>: <strong>(Q.rear - Q.front + MaxSize) % MaxSize</strong></li></ul></li><li><p>新增一个表示元素个数的数据成员<strong>size</strong>，这样队空队满的情况下都有<strong>Q.rear == Q.front</strong></p><ul><li><strong>队满条件</strong> : <strong>Q.size == MaxSize</strong></li><li><strong>队空条件</strong>: <strong>Q.size = 0</strong></li><li><strong>队列中元素的个数</strong>: <strong>size</strong></li></ul></li><li><p>新增<strong>tag</strong>数据成员。tag为0时表示最近执行了一次删除；tag为1时表示最近执行了一次插入</p><ul><li><strong>队满条件</strong> : 当<strong>tag</strong>等于0时，若因删除导致<strong>Q.front == Q.rear</strong>则队空；</li><li><strong>队空条件</strong>:  当<strong>tag</strong>等于1时，因插入导致<strong>Q.front == Q.rear</strong>则为队满；</li><li><p><strong>队列中元素个数</strong></p><script type="math/tex; mode=display">\text{队列中元素个数} =\begin{cases}0, & \text{if } (front == rear \text{ and } tag == 0) \\MaxSize, & \text{if } (front == rear \text{ and } tag == 1) \\(rear - front + MaxSize) \% MaxSize, & \text{otherwise}\end{cases}</script></li></ul></li></ul></li></ul><h3 id="队列的链式存储结构"><a href="#队列的链式存储结构" class="headerlink" title="队列的链式存储结构"></a>队列的链式存储结构</h3><p>通常将链式队列设计成一个<strong>带头结点</strong>的单链表。</p><h4 id="C语言描述-9"><a href="#C语言描述-9" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;</span><br><span class="line">&#125;*LinkQueue;</span><br></pre></td></tr></table></figure><h4 id="C-描述-9"><a href="#C-描述-9" class="headerlink" title="C++描述"></a>C++描述</h4><p>TODO</p><h4 id="Rust描述-9"><a href="#Rust描述-9" class="headerlink" title="Rust描述"></a>Rust描述</h4><p>TODO</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列是指允许两端都可以进行入队和出队操作的队列。将队列的两端称为前端和后端。</p><h4 id="输入受限的双端队列"><a href="#输入受限的双端队列" class="headerlink" title="输入受限的双端队列"></a>输入受限的双端队列</h4><p>允许在一端进行插入和删除，但在另一端只允许插入。</p><h4 id="输出受限的双端队列"><a href="#输出受限的双端队列" class="headerlink" title="输出受限的双端队列"></a>输出受限的双端队列</h4><p>允许在一端进行插入和删除，但在另一端只允许删除。</p><h3 id="经典应用-1"><a href="#经典应用-1" class="headerlink" title="经典应用"></a>经典应用</h3><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><h2 id="数组与特殊矩阵"><a href="#数组与特殊矩阵" class="headerlink" title="数组与特殊矩阵"></a>数组与特殊矩阵</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>大多数语言都提供了数组数据类型。</p><h3 id="特殊矩阵的压缩"><a href="#特殊矩阵的压缩" class="headerlink" title="特殊矩阵的压缩"></a>特殊矩阵的压缩</h3><h4 id="对称矩阵（Symmetric-Matrix）"><a href="#对称矩阵（Symmetric-Matrix）" class="headerlink" title="对称矩阵（Symmetric Matrix）"></a>对称矩阵（Symmetric Matrix）</h4><ul><li><strong>性质</strong>：矩阵 $A = [a<em>{ij}]$ 满足 $a</em>{ij} = a_{ji}$。</li><li><strong>压缩方法</strong>：只存储矩阵的<strong>上三角或下三角部分</strong>，例如存储上三角（包括对角线）的元素。</li></ul><p>如果矩阵是 $n \times n$，元素按行存储上三角：</p><script type="math/tex; mode=display">\text{存储顺序： } a_{11}, a_{12}, \dots, a_{1n}, a_{22}, a_{23}, \dots, a_{2n}, \dots, a_{nn}</script><ul><li><strong>下标映射公式</strong>（存储到一维数组 <code>B[k]</code>）：</li></ul><script type="math/tex; mode=display">k = \frac{i(i-1)}{2} + j - 1 \quad (i \le j)</script><p>其中 $i, j$ 从 1 开始计数。</p><ul><li><strong>存储空间</strong>：$\frac{n(n+1)}{2}$ 个元素。</li></ul><h4 id="三角矩阵（Triangular-Matrix）"><a href="#三角矩阵（Triangular-Matrix）" class="headerlink" title="三角矩阵（Triangular Matrix）"></a>三角矩阵（Triangular Matrix）</h4><ul><li><strong>性质</strong>：<ul><li>上三角矩阵：所有元素 $a_{ij} = 0$ 当 $i &gt; j$</li><li>下三角矩阵：所有元素 $a_{ij} = 0$ 当 $i &lt; j$</li></ul></li><li><strong>压缩方法</strong>：只存储非零的三角部分。</li></ul><h5 id="上三角矩阵按行存储公式："><a href="#上三角矩阵按行存储公式：" class="headerlink" title="上三角矩阵按行存储公式："></a>上三角矩阵按行存储公式：</h5><script type="math/tex; mode=display">k = \frac{i(i-1)}{2} + j - 1 \quad (i \le j)</script><h5 id="下三角矩阵按行存储公式："><a href="#下三角矩阵按行存储公式：" class="headerlink" title="下三角矩阵按行存储公式："></a>下三角矩阵按行存储公式：</h5><script type="math/tex; mode=display">k = \frac{i(2n-i+1)}{2} + (j-i) \quad (i \ge j)</script><ul><li><strong>存储空间</strong>：$\frac{n(n+1)}{2}$ 个元素。</li></ul><hr><h4 id="三对角矩阵-带状矩阵（Tridiagonal-Banded-Matrix）"><a href="#三对角矩阵-带状矩阵（Tridiagonal-Banded-Matrix）" class="headerlink" title="三对角矩阵 / 带状矩阵（Tridiagonal / Banded Matrix）"></a>三对角矩阵 / 带状矩阵（Tridiagonal / Banded Matrix）</h4><ul><li><strong>性质</strong>：矩阵只有主对角线、上对角线和下对角线有非零元素，其余为 0。</li></ul><script type="math/tex; mode=display">A = \begin{bmatrix}a_1 & b_1 & 0 & \dots & 0 \\c_1 & a_2 & b_2 & \dots & 0 \\0 & c_2 & a_3 & \dots & 0 \\\vdots & \vdots & \vdots & \ddots & b_{n-1} \\0 & 0 & 0 & c_{n-1} & a_n\end{bmatrix}</script><ul><li><strong>压缩方法</strong>：存三个一维数组：<ul><li><code>A[1..n]</code> 存主对角线 $a_i$</li><li><code>B[1..n-1]</code> 存上对角线 $b_i$</li><li><code>C[1..n-1]</code> 存下对角线 $c_i$</li></ul></li><li><strong>访问公式</strong>：</li></ul><script type="math/tex; mode=display">a_{i,i} = A[i], \quad a_{i,i+1} = B[i], \quad a_{i+1,i} = C[i]</script><ul><li><strong>存储空间</strong>：$3n - 2$ 个元素，比普通 $n^2$ 大幅节省。</li></ul><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p>矩阵中非零元素的个数t，相对矩阵元素的个数s来说非常少，即$s \gg t$的矩阵称为<strong>稀疏矩阵</strong>。</p><p>若采用常规方法存储稀疏矩阵相当浪费空间，因此仅存储非零元素。但通常非零元素的分布非常没有规律，所以还要存储非零元素的行和列。</p><p>因此，将非零元素及对应的行和列构成一个三元组</p><script type="math/tex; mode=display">(\text 行标, 列标, 值)</script><p>然后按某种规律存储这个三元组。<strong>稀疏矩阵压缩存储后失去了随机存取的特性</strong>。</p><p>稀疏矩阵的三元组既可以采用<strong>数组存储，</strong>也可以采用<strong>十字链表法</strong>存储。</p><p><strong>三元组顺序表（数组存储）</strong></p><ul><li>将稀疏矩阵中的非零元素按照行优先或列优先顺序存储为三元组 <code>(行标, 列标, 值)</code>。</li><li>常用顺序：<ul><li><strong>行优先</strong>：按行从上到下、每行从左到右存储。</li><li><strong>列优先</strong>：按列从左到右、每列从上到下存储。</li></ul></li><li>适用于矩阵非零元素不频繁修改的情况。</li></ul><p><strong>十字链表存储（Cross Linked List / Orthogonal List）</strong></p><ul><li>对于动态修改的稀疏矩阵较适用。</li><li>每个非零元素节点包含：<ul><li>值</li><li>行标</li><li>列标</li><li>行指针（指向同一行的下一个非零元素）</li><li>列指针（指向同一列的下一个非零元素）</li></ul></li><li>可以实现行和列的快速遍历，适合矩阵乘法和转置等操作。</li></ul><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h2><p>子串的定位操作通常称为串的<strong>模式匹配</strong>，它求的是子串（通常称为模式串）在主串中的位置。</p><h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><p>模式串 <code>p</code> 与主串 <code>s</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">S: <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">P: <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c</span><br><span class="line">   ↑ 从这里开始和主串对齐</span><br><span class="line"></span><br><span class="line">步骤<span class="number">1</span>：</span><br><span class="line">S: <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">P: <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c</span><br><span class="line">   <span class="selector-tag">a</span> = <span class="selector-tag">a</span> ✅</span><br><span class="line">     <span class="selector-tag">b</span> ≠ <span class="selector-tag">a</span> ❌ 失配 → 模式右移一位</span><br><span class="line"></span><br><span class="line">步骤<span class="number">2</span>：</span><br><span class="line">S: <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">  P: <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c</span><br><span class="line">     <span class="selector-tag">a</span> ≠ <span class="selector-tag">b</span> ❌ → 继续右移一位</span><br><span class="line"></span><br><span class="line">步骤<span class="number">3</span>：</span><br><span class="line">S: <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">    P: <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c</span><br><span class="line">       <span class="selector-tag">a</span> = <span class="selector-tag">a</span> ✅</span><br><span class="line">         <span class="selector-tag">b</span> = <span class="selector-tag">b</span> ✅</span><br><span class="line">           c = <span class="selector-tag">a</span> ❌ → 右移一位</span><br><span class="line"></span><br><span class="line">步骤<span class="number">4</span>：</span><br><span class="line">S: <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">      P: <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c</span><br><span class="line">         <span class="selector-tag">b</span> ≠ <span class="selector-tag">a</span> ❌ → 右移一位</span><br><span class="line"></span><br><span class="line">步骤<span class="number">5</span>：</span><br><span class="line">S: <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">        P: <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c</span><br><span class="line">           c = <span class="selector-tag">a</span> ❌ → 右移一位</span><br><span class="line"></span><br><span class="line">步骤<span class="number">6</span>：</span><br><span class="line">S: <span class="selector-tag">a</span> <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c <span class="selector-tag">b</span> <span class="selector-tag">a</span> <span class="selector-tag">b</span></span><br><span class="line">          P: <span class="selector-tag">a</span> <span class="selector-tag">b</span> c <span class="selector-tag">a</span> c</span><br><span class="line">             <span class="selector-tag">a</span> = <span class="selector-tag">a</span> ✅</span><br><span class="line">               <span class="selector-tag">b</span> = <span class="selector-tag">b</span> ✅</span><br><span class="line">                 c = c ✅</span><br><span class="line">                   <span class="selector-tag">a</span> = <span class="selector-tag">a</span> ✅</span><br><span class="line">                     c = c ✅ ✅ 匹配成功！</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">naive_match</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s_len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> p_len = <span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;s_len &amp;&amp; j&lt;p_len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>;<span class="comment">//退回去重新匹配</span></span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == p_len)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最坏情况</strong>：$O(n \cdot m)$，其中 $n$ 是主串长度，$m$ 是模式串长度。</p><ul><li>例如主串 <code>&quot;aaaaaaab&quot;</code> 和模式串 <code>&quot;aaaab&quot;</code>，每次匹配失败都需要回溯多个字符。</li></ul><p><strong>平均情况</strong>：通常小于最坏情况，但仍然可能接近 $O(n \cdot m)$。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>推荐讲解非常好的文章：</p><div class="tag link"><a class="link-card" title="" href=""><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text"></p><p class="url"></p></div></a></div><p>朴素模式匹配算法中，每次匹配失败都是将模式串（要匹配的子串）后移一位从头开始比较。</p><p>几个概念：</p><ul><li><strong>前缀</strong>：包含首字母，不包含尾字母的所有子串</li><li><strong>后缀</strong>：包含尾字母，不包含首字母的所有子串</li><li><strong>PM(Partial Match)</strong> 部分匹配值，即下面的表格</li></ul><p>下面以”ABCDABD”作为要匹配的子串来举例：</p><div class="table-container"><table><thead><tr><th>子串</th><th>前缀集合（不含完整串）</th><th>后缀集合（不含完整串）</th><th>最长相等前后缀长度</th></tr></thead><tbody><tr><td>A</td><td>（空）</td><td>（空）</td><td>0</td></tr><tr><td>AB</td><td>A</td><td>B</td><td>0</td></tr><tr><td>ABC</td><td>A, AB</td><td>C, BC</td><td>0</td></tr><tr><td>ABCD</td><td>A, AB, ABC</td><td>D, CD, BCD</td><td>0</td></tr><tr><td>ABCDA</td><td>A, AB, ABC, ABCD</td><td>A, DA, CDA, BCDA</td><td>1（A）</td></tr><tr><td>ABCDAB</td><td>A, AB, ABC, ABCD, ABCDA</td><td>B, AB, DAB, CDAB, BCDAB</td><td>2  (AB)</td></tr><tr><td>ABCDABD</td><td>A, AB, ABC, ABCD, ABCDA, ABCDAB</td><td>D, BD, ABD, DABD, CDABD, BCDABD</td><td>0</td></tr></tbody></table></div><p>则PM表为</p><div class="table-container"><table><thead><tr><th>编号</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>String[i]</td><td>A</td><td>B</td><td>C</td><td>D</td><td>A</td><td>B</td><td>D</td></tr><tr><td>PM</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table></div><ul><li>如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510182144699.png" alt="img"></p><ul><li><ol><li>因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510182144807.png" alt="img"></p><ul><li><ol><li>继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据<strong>PM</strong>表可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 = 4 位，从<strong>PM[i] = 2</strong> 即下标为2的地方重新开始匹配</li></ol></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202510182144752.png" alt="img"></p><p>我们可以定义一个<strong>next</strong>数组：当模式串的第j个(从0开始)匹配失败时，从模式串的第next[j]个继续向后匹配。</p><p><strong>KMP 里的 next 数组</strong>有两种写法：</p><p><strong>PM 表 = 前缀函数 π(i)</strong>（也叫<strong>lps 数组</strong>，Longest Prefix Suffix）。</p><ul><li><p><strong>有些教材里 next 就等于 PM（lps）</strong> </p></li><li><p><strong>有些教材里 next 是 PM 的变形</strong></p><ul><li><p><strong>next[0] = -1</strong> （表示完全重新开始匹配）</p></li><li><p><strong>next[i] = PM[i-1]</strong></p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetNext</span><span class="params">(<span class="type">char</span> *p, <span class="type">int</span> next[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//p[k]表示前缀，p[j]表示后缀</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) &#123;</span><br><span class="line">++k;</span><br><span class="line">++j;</span><br><span class="line">next[j] = k;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k = next[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">KmpSearch</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *p, <span class="type">int</span> next[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen) &#123;</span><br><span class="line"><span class="comment">//如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++</span></span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]</span></span><br><span class="line"><span class="comment">//next[j]即为j所对应的next值</span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j == pLen)</span><br><span class="line"><span class="keyword">return</span> i - j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[A] --&gt; B[B]</span><br><span class="line">    A --&gt; C[C]</span><br><span class="line">    B --&gt; D[D]</span><br><span class="line">    B --&gt; E[E]</span><br><span class="line">    C --&gt; F[F]</span><br><span class="line">    C --&gt; G[G]</span><br><span class="line">    E --&gt; H[H]</span><br><span class="line">    E --&gt; I[I]</span><br><span class="line"></span><br><span class="line">    style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    style D fill:#9f9,stroke:#333</span><br><span class="line">    style F fill:#9f9,stroke:#333</span><br><span class="line">    style G fill:#9f9,stroke:#333</span><br><span class="line">    style H fill:#9f9,stroke:#333</span><br><span class="line">    style I fill:#9f9,stroke:#333</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>结点的分类</p><ul><li><p><strong>根节点 (Root)</strong></p><ul><li><p>树的顶端节点。</p></li><li><p>示例：<code>A</code> 是根节点。</p></li></ul></li><li><p><strong>双亲 (Parent)</strong></p><ul><li><p>节点的直接上一层节点。</p></li><li><p>示例：<code>B</code> 的父节点是 <code>A</code>。</p></li></ul></li><li><p><strong>兄弟 (Sibling)</strong></p><ul><li><p>具有同一个父节点的节点互为兄弟。</p></li><li><p>示例：<code>D</code> 和 <code>E</code> 是兄弟，<code>F</code> 和 <code>G</code> 是兄弟。</p></li></ul></li><li><p><strong>子节点 </strong></p><ul><li>子节点：父节点直接连接的节点。</li><li>示例：<code>D</code>、<code>E</code> 是 <code>B</code> 的子节点。</li></ul></li><li><p><strong>子孙</strong></p><ul><li>节点的所有后代，包括子节点。</li><li>示例：<code>H</code>、<code>I</code> 是 <code>B</code> 的子孙。</li></ul></li><li><strong>分支节点 (Internal Node)</strong><ul><li>有子节点的节点。</li><li>示例：<code>A</code>、<code>B</code>、<code>C</code>、<code>E</code> 都是分支节点。</li></ul></li><li><strong>叶节点 (Leaf Node)</strong><ul><li>没有子节点的节点。</li><li>示例：<code>D</code>、<code>F</code>、<code>G</code>、<code>H</code>、<code>I</code> 是叶节点。</li></ul></li></ul></li><li><p>结点的属性</p><ul><li><p><strong>结点的深度 (Depth)</strong></p><ul><li><p>从根节点到该节点的路径长度（边数）。（自顶向下）</p></li><li><p>示例：<code>A</code> 深度 0，<code>B</code> 深度 1，<code>D</code> 深度 2。</p></li></ul></li><li><p><strong>结点的高度 (Height)</strong></p><ul><li><p>从该节点到最深叶节点的最长路径长度。（自底向上）</p></li><li><p>示例：<code>B</code> 高度 2（最长路径 B→E→H 或 B→E→I）。</p></li><li><p><strong>结点的层次 (Level)</strong></p><ul><li><p>层次 = 深度 + 1</p></li><li><p>示例：根节点 A 层次 1，B 层次 2。</p></li></ul></li><li><p><strong>度 (Degree)</strong></p><ul><li>一个节点拥有子节点的个数。</li><li>示例：<code>B</code> 的度是 2（<code>D</code>、<code>E</code>）。</li></ul></li></ul></li></ul></li><li><p>树的分类</p><ul><li><p><strong>度为m的树</strong></p><ul><li>任意结点度数不大于m</li><li>至少有一个结点的度数为m</li><li>一定为非空树，因此至少有m+1个结点</li></ul></li><li><p><strong>m叉树</strong></p><ul><li>任意节点度数不大于m</li><li>可以是空树</li></ul></li><li><p><strong>有序树 / 无序树 (Ordered / Unordered Tree)</strong></p><ul><li><p><strong>有序树</strong>：树中结点的各个子树从左到右是有次序的，不能互换，即子节点有固定顺序。</p></li><li><p><strong>无序树</strong>：子节点顺序不重要。</p></li></ul></li><li><p><strong>森林 (Forest)</strong></p><ul><li><p>多棵互不相连的树组成的集合。</p></li><li><p>如果去掉根节点 A，就形成两棵树 B 树和 C 树，组成森林。</p></li></ul></li></ul></li><li><p>其他概念</p><ul><li><strong>路径 (Path)</strong><ul><li>从一个节点到另一个节点经过的节点序列。</li><li>示例：A→B→E→H 是一条路径。</li></ul></li><li><strong>路径长度 (Path Length)</strong><ul><li>路径上边的数量。</li><li>示例：A→B→E→H，路径长度 = 3。</li></ul></li></ul></li></ul><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><ol><li><strong>树中的结点数等于所有结点度数之和+1</strong><ul><li>证明很简单，除了根节点，其他所有节点头上都有一条边</li></ul></li><li><p><strong>度为 $m$ 的树第 $i$ 层上至多有 $m^{i-1}$ 个结点($i \ge 1$)</strong></p></li><li><p><strong>高度为 $h$ 的 $m$ 叉树至多有 $ \frac{m^h-1}{m-1}$ 个结点</strong> </p></li><li><p><strong>具有 $n$ 个结点的 $m$ 叉树的最小高度是 $ \lceil log_m^{(n(m-1)+1)} \rceil$</strong></p><ul><li>证明：高度最小的情况下，尽量让每个节点都有 $m$ 个孩子那么：</li><li>$\frac{m^{h-1}-1}{m-1} &lt; n \le \frac{m^h-1}{m-1} $</li></ul></li></ol><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><blockquote><p>二叉树是有序树</p></blockquote><h3 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h3><ul><li><p><strong>满二叉树</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    style B fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style C fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style D fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style E fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style F fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style G fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style H fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style I fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style J fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style K fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style L fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style M fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style N fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style O fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line"></span><br><span class="line">    A((1)) --&gt; B((2))</span><br><span class="line">    A --&gt; C((3))</span><br><span class="line">    B --&gt; D((4))</span><br><span class="line">    B --&gt; E((5))</span><br><span class="line">    C --&gt; F((6))</span><br><span class="line">    C --&gt; G((7))</span><br><span class="line">    D --&gt; H((8))</span><br><span class="line">    D --&gt; I((9))</span><br><span class="line">    E --&gt; J((10))</span><br><span class="line">    E --&gt; K((11))</span><br><span class="line">    F --&gt; L((12))</span><br><span class="line">    F --&gt; M((13))</span><br><span class="line">    G --&gt; N((14))</span><br><span class="line">    G --&gt; O((15))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>高度为 $h$ ，且含有$ 2^h-1$个结点的二叉树称为满二叉树</p></li><li><p>满二叉树除了叶子节点外每个结点的度数为2</p></li><li><p><strong>可以对满二叉树进行按层序编号</strong>, 对于节点编号为 $i$ 的结点：</p><ul><li><p>左孩子编号：$2i$</p></li><li><p>右孩子编号：$2i+1$</p></li><li><p>父节点编号：$\lfloor i/2 \rfloor$</p></li></ul></li></ul><ul><li><p><strong>完全二叉树</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    style A fill:#f9f,stroke:#333,stroke-width:2px</span><br><span class="line">    style B fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style C fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style D fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style E fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style F fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style G fill:#9cf,stroke:#333,stroke-width:1px</span><br><span class="line">    style H fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style I fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style J fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style K fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line">    style L fill:#9f9,stroke:#333,stroke-width:1px</span><br><span class="line"></span><br><span class="line">    A((1)) --&gt; B((2))</span><br><span class="line">    A --&gt; C((3))</span><br><span class="line">    B --&gt; D((4))</span><br><span class="line">    B --&gt; E((5))</span><br><span class="line">    C --&gt; F((6))</span><br><span class="line">    C --&gt; G((7))</span><br><span class="line">    D --&gt; H((8))</span><br><span class="line">    D --&gt; I((9))</span><br><span class="line">    E --&gt; J((10))</span><br><span class="line">    E --&gt; K((11))</span><br><span class="line">    F --&gt; L((12))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li>高度为$h$，有$n$个结点的二叉树，当且仅当其每个结点都与高度为$h$的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树</li><li>若$ i \le \lfloor \frac{n}{2} \rfloor$ ，则结点 $i$ 为分支结点</li><li>叶节点只可能在层次最大的两层出现，对于最大层次的叶节点，都一次排列在该层最左边的位置上。</li><li><strong>若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子。</strong></li><li>按层序编号后，一旦出现某个结点（序号为 $i$ ）为叶子结点或只有左孩子，则编号大于 $i$ 的结点均为叶结点</li><li>若 $n$ 为奇数，则每个分支节点都右左孩子和右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为 $\frac{n}{2}$ ）只有左孩子，没有右孩子 其余结点左右孩子都有</li></ul><ul><li><strong>二叉排序树</strong><ul><li>左子树上所有结点的关键字均小于根节点的关键字，右子树上所有结点的关键字均大于根结点的关键字；左子树和右子树又都是一棵二叉排序树。</li></ul></li><li><strong>平衡二叉树</strong><ul><li>树上<strong>任意一个结点的左子树和右子树的深度之差不超过1</strong></li></ul></li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li><p><strong>非空二叉树上的叶节点数等于度为2的结点数加1，即 $ n_0 = n_2+1 $</strong> </p></li><li><p><strong>非空二叉树上第 $ k $ 层上至多有 $2^{(k-1)}$ 个结点（$ k \ge 1 $）</strong></p></li><li>高度为 $h$的二叉树之多有 $2^h-1$个结点（$h\ge1$）</li><li><p>具有$n$个结点的<strong>完全二叉树</strong>的高度为 $ \lceil log_2^{(n+1)} \rceil$ 或 $ \lfloor log_2^n \rfloor + 1 $</p></li><li><p>对<strong>完全二叉树</strong>结点进行编号，有如下关系</p></li></ol><p>假设结点按 <strong>层序编号</strong>（根节点编号为 1），则：</p><div class="table-container"><table><thead><tr><th>关系</th><th>表达式</th></tr></thead><tbody><tr><td>左孩子</td><td>$\text{left}(i) = 2i$</td></tr><tr><td>右孩子</td><td>$\text{right}(i) = 2i + 1$</td></tr><tr><td>父节点</td><td>$\text{parent}(i) = \lfloor i/2 \rfloor$</td></tr></tbody></table></div><ul><li>如果编号 $i &gt; \lfloor n/2 \rfloor$，则结点 $i$ 为叶节点或仅有左孩子</li><li>结点 $i$ 的层次或深度为（depth/level） = $\lfloor \log_2 (\text{i}) \rfloor + 1$</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p><strong>顺序存储结构</strong></p><p>数组存储，按照完全二叉树的方式来存储，用0或-1表示空结点。</p><p><strong>链式存储</strong></p><h4 id="C语言描述-10"><a href="#C语言描述-10" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><p>容易验证，在含有$n$个结点的二叉链表中，含有 $n+1$个空指针域。</p><blockquote><p>n个结点，2n个指针域，n-1个结点头上有一个指针指向自己，故有n+1个空指针域</p></blockquote><h4 id="C-描述-10"><a href="#C-描述-10" class="headerlink" title="C++描述"></a>C++描述</h4><p>TODO</p><h4 id="Rust描述-10"><a href="#Rust描述-10" class="headerlink" title="Rust描述"></a>Rust描述</h4><p>TODO</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>先访问根节点，再遍历左子树，再遍历右子树</p><h5 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a><strong>递归写法</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);</span><br><span class="line">        PreOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a><strong>非递归写法</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack *S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !isEmpty(S))&#123;<span class="comment">//栈不为空或p不为空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S, p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    DestroyStack(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先访问左子树，再访问根节点，再访问右子树</p><h5 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a><strong>递归写法</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);</span><br><span class="line">        visit(T);</span><br><span class="line">        InOrder(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归写法-1"><a href="#非递归写法-1" class="headerlink" title="非递归写法"></a><strong>非递归写法</strong></h5><ol><li>沿着根结点的左孩子，依次入栈，直到左孩子为空，说明已经可以找到可以输出的结点</li><li>栈顶元素出栈并访问，若其有右孩子则继续执行1，否则继续执行2</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack *S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    <span class="keyword">while</span>(p || !isEmpty(S))&#123;<span class="comment">//栈不为空或p不为空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Pop(S, p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    DestroyStack(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先访问左子树，再访问右子树，再访问根节点</p><h5 id="递归写法-2"><a href="#递归写法-2" class="headerlink" title="递归写法"></a><strong>递归写法</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);</span><br><span class="line">        PostOrder(T-&gt;rchild);</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="非递归写法-2"><a href="#非递归写法-2" class="headerlink" title="非递归写法"></a><strong>非递归写法</strong></h5><ol><li>沿着根的左孩子，依次入栈，直到左孩子为空；</li><li>读栈顶元素：若其右孩子不为空，且未被访问过，将右子树执行1，否则栈顶元素出栈并访问</li></ol><p>若栈顶元素想要出栈访问，要么右子树为空，要么右子树已经访问完（此时左子树早已访问完）因此我们需要用一个辅助指针，表示最近一次访问的结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack *S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTNode *p = T;</span><br><span class="line">    BiTNode *r= <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p || !isEmpty(S))&#123;<span class="comment">//栈不为空或p不为空时循环</span></span><br><span class="line">        <span class="keyword">if</span>(p)&#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            GetTop(S,p);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)&#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Pop(S, p);</span><br><span class="line">            visit(p);</span><br><span class="line">                r = p;</span><br><span class="line">            p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    DestroyStack(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层次遍历-1"><a href="#层次遍历-1" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>按照从第一层到最后一层，从左到右的顺序进行遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">    Queue *Q;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    EnQueue(Q, T);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(Q, p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(Q, p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyQueue(Q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="术语-2"><a href="#术语-2" class="headerlink" title="术语"></a>术语</h2><p><strong>基本概念</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>有向图（Directed Graph）</strong></td><td>图中的边有方向，如 $A \rightarrow B$</td></tr><tr><td><strong>无向图（Undirected Graph）</strong></td><td>边没有方向，如 $A - B$，表示双向关系</td></tr></tbody></table></div><p><strong>按边结构分类</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>简单图（Simple Graph）</strong></td><td>不允许 <strong>自环</strong>（从自己连自己）和 <strong>重边</strong>（两点之间多条边）</td></tr><tr><td><strong>多重图（Multigraph）</strong></td><td>允许自环和重边</td></tr></tbody></table></div><hr><p><strong>特殊图</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>完全图（Complete Graph）</strong></td><td>任意两个顶点之间都有一条边。无向完全图记作 $K_n$，有 $\frac{n(n-1)}{2}$ 条边</td></tr><tr><td><strong>子图（Subgraph）</strong></td><td>从原图中取部分顶点和边组成的图</td></tr></tbody></table></div><p><strong>图的连通性</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>连通（Connected）</strong></td><td>无向图中，任意两顶点都有路径相连</td></tr><tr><td><strong>连通图</strong></td><td>图是整体连通的</td></tr><tr><td><strong>连通分量</strong></td><td>无向图中极大的连通子图（不能再扩大的连通片）</td></tr><tr><td><strong>强连通图</strong></td><td>在有向图中，任意两点 $u$ 和 $v$ 都存在互相可达的路径</td></tr><tr><td><strong>强连通分量</strong></td><td>有向图中最大的强连通子图</td></tr></tbody></table></div><p><strong>树相关</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>生成树（Spanning Tree）</strong></td><td>连通无向图中包含所有顶点且边数最少（$n-1$）的树</td></tr><tr><td><strong>生成森林（Spanning Forest）</strong></td><td>对于不连通的图，由各连通分量分别生成树组成的集合</td></tr></tbody></table></div><p><strong>顶点和边性质</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>顶点的度（Degree）</strong></td><td>与顶点相连的边数（无向图中）</td></tr><tr><td><strong>入度（In-degree）</strong></td><td>有向图中指向该顶点的边数</td></tr><tr><td><strong>出度（Out-degree）</strong></td><td>有向图中从该顶点指出去的边数</td></tr><tr><td><strong>边的权（Weight）</strong></td><td>边上附加的值（如距离、时间、费用等）</td></tr><tr><td><strong>网（Network）</strong></td><td>权图（带边权的图）又称网</td></tr><tr><td><strong>稠密图（Dense Graph）</strong></td><td>边数很多的图，模糊的概念</td></tr><tr><td><strong>稀疏图（Sparse Graph）</strong></td><td>边数很少的图，模糊的概念</td></tr></tbody></table></div><p><strong>路径与距离</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td><strong>路径</strong></td><td>顶点序列，任意相邻两点间有边连接</td></tr><tr><td><strong>路径长度</strong></td><td>该路径上边的数量（或权值总和）</td></tr><tr><td><strong>回路（Cycle）</strong></td><td>起点和终点相同的路径</td></tr><tr><td><strong>简单路径</strong></td><td>路径中顶点不重复</td></tr><tr><td><strong>简单回路</strong></td><td>回路中除起点终点外其他顶点不重复</td></tr><tr><td><strong>距离</strong></td><td>两顶点间最短路径的长度</td></tr></tbody></table></div><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p><strong>无向图</strong>：</p><ul><li>如果 <code>i</code> 和 <code>j</code> 有边：<code>Edge[i][j] = Edge[j][i] = 1</code></li><li>如果无边：<code>Edge[i][j] = Edge[j][i] = 0</code></li></ul><p><strong>有向图</strong>：</p><ul><li>如果有 <code>i → j</code> 的边：<code>Edge[i][j] = 1</code></li><li>如果没有：<code>Edge[i][j] = 0</code></li></ul><p><strong>网（带权图）</strong>：</p><ul><li>如果 <code>i → j</code> 的权为 <code>w</code>，则 <code>Edge[i][j] = w</code></li><li>无边时一般设为 <code>∞</code>（或一个非常大的数）</li></ul><h4 id="C语言描述-11"><a href="#C语言描述-11" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];              <span class="comment">// 顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//邻接矩阵</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h4 id="C-描述-11"><a href="#C-描述-11" class="headerlink" title="C++描述"></a>C++描述</h4><p>TODO</p><h4 id="Rust描述-11"><a href="#Rust描述-11" class="headerlink" title="Rust描述"></a>Rust描述</h4><p>TODO</p><h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><h4 id="C语言描述-12"><a href="#C语言描述-12" class="headerlink" title="C语言描述"></a>C语言描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span><span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧指向的顶点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// InfoType info // 边权值</span></span><br><span class="line">&#125;ArchNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span><span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data; <span class="comment">// 顶点信息</span></span><br><span class="line">    ArchNode *first; <span class="comment">//指向第一条依附于该顶点的弧的指针</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;<span class="comment">///邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="C-描述-12"><a href="#C-描述-12" class="headerlink" title="C++描述"></a>C++描述</h4><h4 id="Rust描述-12"><a href="#Rust描述-12" class="headerlink" title="Rust描述"></a>Rust描述</h4><h3 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> tailvex;             <span class="comment">// 弧尾（出发点）</span></span><br><span class="line">    <span class="type">int</span> headvex;             <span class="comment">// 弧头（终点）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">hlink</span>;</span>   <span class="comment">// 指向下一个以同一个弧头为头的弧</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">tlink</span>;</span>   <span class="comment">// 指向下一个以同一个弧尾为尾的弧</span></span><br><span class="line">    <span class="type">int</span> info;                <span class="comment">// 权值（可选）</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;               <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *firstin;        <span class="comment">// 指向第一个入弧</span></span><br><span class="line">    ArcNode *firstout;       <span class="comment">// 指向第一个出弧</span></span><br><span class="line">&#125; VexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VexNode xlist[MaxVertexNum]; <span class="comment">// 顶点表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;          <span class="comment">// 顶点数、弧数</span></span><br><span class="line">&#125; OLGraph; <span class="comment">// Orthogonal List Graph</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h3><p>邻接多重表是无向图的另一种链式存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> ivex, jvex;                 <span class="comment">// 边的两个顶点编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> *<span class="title">ilink</span>, *<span class="title">jlink</span>;</span>   <span class="comment">// 分别指向连接ivex和jvex的下一条边</span></span><br><span class="line">&#125; ENode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;                     <span class="comment">// 顶点信息</span></span><br><span class="line">    ENode *firstedge;             <span class="comment">// 第一条依附该顶点的边</span></span><br><span class="line">&#125; VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VNode adjList[MaxVertexNum];</span><br><span class="line">    <span class="type">int</span> vexnum, edgenum;</span><br><span class="line">&#125; AMLGraph;  <span class="comment">// 邻接多重表：Adjacency Multilist Graph</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFSTraverse</span><span class="params">(Graph G)</span></span><br><span class="line">    Queue *Q;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.vexnum;i++)&#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.vexnum;i++)&#123;<span class="comment">//对每个连通分量调用BFS</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            BFS(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    DestroyQueue(Q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span>&#123;<span class="comment">//从顶点v触发，广度优先遍历G</span></span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    Enqueue(Q, v);</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);</span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G,v);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,v,w<span class="comment">//将v的所有未访问的邻接点入队</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">                visit(w);</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                EnQueue(Q,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果图为非带权图，可以通过BFS来求单源最短路径问题，主要利用广度优先遍历是按照距离从进到远来遍历图中每个顶点的的性质来决定的。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="递归形式"><a href="#递归形式" class="headerlink" title="递归形式"></a>递归形式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v&lt;G.vexnum;v++)&#123;</span><br><span class="line">        visited[v]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">0</span>;v&lt;G.vexnum;v++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])&#123;</span><br><span class="line">            DFS(G,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">    visit(v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(w = FirstNeighbor(G,v); w&gt;=<span class="number">0</span> ; w = NextNeighbor(G,v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归形式"><a href="#非递归形式" class="headerlink" title="非递归形式"></a>非递归形式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS_Non_RC</span><span class="params">(AGraph &amp;G, <span class="type">int</span> v)</span>&#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    Stack *S;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.num;i++)&#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Push(S,v);</span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//表示已经入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!isEmpty(S))&#123;</span><br><span class="line">        k = Pop(S);</span><br><span class="line">        visit(k);</span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G,k);w&gt;=<span class="number">0</span>;w=NextNeighbor(G,k,w))&#123;</span><br><span class="line">           <span class="keyword">if</span>(!visited[w])&#123;</span><br><span class="line">               Push(S,w);</span><br><span class="line">               visited[w] = <span class="literal">true</span>;</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    DestroyStack(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p><strong>思想</strong>：从一个点开始，每次选择<strong>代价最小的边</strong>把新的顶点加入生成树</p><p><strong>更适合</strong>：<strong>稠密图</strong>（邻接矩阵）</p><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p><strong>思想</strong>：把图的所有边按权值排序，从小到大选择边，只要<strong>不成环</strong>就选</p><p><strong>适合</strong>：<strong>稀疏图</strong></p><p><strong>用到并查集</strong>避免形成环路</p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><p>单源最短路径问题</p><h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><p>各个顶点之间的最短路径</p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AArch64 ASM</title>
      <link href="/posts/50003/"/>
      <url>/posts/50003/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-28</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><p><strong>ARM 常用寄存器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/ARM%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="ARM寄存器"></p><p><strong>指令分类</strong>：</p><ol><li>内存加载和存储指令</li><li>多字节内存加载和存储</li><li>算数和移位指令</li><li>移位操作</li><li>位操作指令</li><li>条件操作</li><li>跳转指令</li><li>独占访存指令</li><li>内存屏障指令</li><li>异常处理指令</li><li>系统寄存器访问指令</li></ol><h3 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h3><ol><li>LDR</li><li>STR</li></ol><h4 id="练习-1：ldr-指令"><a href="#练习-1：ldr-指令" class="headerlink" title="练习 1：ldr 指令"></a>练习 1：ldr 指令</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281510440.png" alt="练习1: ldr指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281510415.png" alt="练习1代码"></p><p>注意 lsl #3 中间不要有分号</p><p>当扩展为 lsl 时，amount 只能为#0 或#3(ARM 文档定义)</p><h4 id="练习-2：ldr-前变基模式和后变基模式"><a href="#练习-2：ldr-前变基模式和后变基模式" class="headerlink" title="练习 2：ldr 前变基模式和后变基模式"></a>练习 2：ldr 前变基模式和后变基模式</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281510825.png" alt="练习2"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281512954.png" alt="练习2代码"></p><h4 id="练习-3：str-的前变基和后变基模式"><a href="#练习-3：str-的前变基和后变基模式" class="headerlink" title="练习 3：str 的前变基和后变基模式"></a>练习 3：str 的前变基和后变基模式</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281513703.png" alt="练习3"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281513069.png" alt="练习3调试"></p><h4 id="ldr-标签-literal"><a href="#ldr-标签-literal" class="headerlink" title="ldr 标签(literal)"></a>ldr 标签(literal)</h4><p>读取<strong>PC+label</strong>的值</p><h4 id="练习-4：ldr-伪指令"><a href="#练习-4：ldr-伪指令" class="headerlink" title="练习 4：ldr 伪指令"></a>练习 4：ldr 伪指令</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281513336.png" alt="练习4: ldr伪指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281514877.png" alt="练习4代码"></p><ul><li>指令：每一条指令都对应一种 CPU 操作</li><li>伪指令：对编译器发出的命令，它是在对源程序汇编期间由汇编程序处理的操作，它们可以完成如处理处理器选择，定义程序模式，定义数据，分配存储区，指示程序结束等功能，总之，可以分解为几条指令的集合</li><li>ldr 指令既可以是大范围的地址读取伪指令，也可以是内存访问指令，而当它的第二个参数前面有“=”时，表示伪指令，否则表示内存访问指令</li><li>ldr 伪指令没有立即数访问限制</li></ul><p>ldr x6, MY_LABEL 是内存访问指令</p><p>ldr x7, =MY_LABEL 是 ldr 伪指令</p><h4 id="练习-5：实现-memcpy-汇编"><a href="#练习-5：实现-memcpy-汇编" class="headerlink" title="练习 5：实现 memcpy 汇编"></a>练习 5：实现 memcpy 汇编</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281514480.png" alt="练习5"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281515539.png" alt="练习5代码"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281515126.png" alt="练习5代码及调试"></p><p>可以看到 0xffffffff 没有复制过去，这是因为起始地址没有四字节对齐</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281516499.png" alt="练习5代码"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281516985.png" alt="对齐起始地址"></p><h4 id="mov-指令"><a href="#mov-指令" class="headerlink" title="mov 指令"></a>mov 指令</h4><ol><li>16 位立即数</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281516493.png" alt="mov指令"></p><h4 id="ldp-和-stp"><a href="#ldp-和-stp" class="headerlink" title="ldp 和 stp"></a>ldp 和 stp</h4><blockquote><p>A32 指令集中提供<strong>LDM</strong>和<strong>STM</strong>来实现多字节内存加载和存储，到了 A64 指令集，不再提供 LDM 和 STM 指令，而是采用 LDP 和 STP 指令</p></blockquote><ul><li>ldp 和 stp 可以一条指令加载和存储 16 个字节</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281516078.png" alt="LDP和STP"></p><h4 id="练习-6-memset"><a href="#练习-6-memset" class="headerlink" title="练习 6: memset"></a>练习 6: memset</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281516426.png" alt="练习6"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281517160.png" alt="练习6代码"></p><h4 id="练习-7：坑"><a href="#练习-7：坑" class="headerlink" title="练习 7：坑"></a>练习 7：坑</h4><ol><li><p>加载一个很大的数值到通用寄存器，例如 0xffff_0000_ffff_ffff</p></li><li><p>加载一个寄存器的值，例如 sctrl_el1 寄存器</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281517268.png" alt="SCTLR_EL1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281517785.png" alt="练习7 坑2"></p><p>3.</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281518147.png" alt="练习7：坑3"></p><p>4.</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281518015.png" alt="练习7：坑4"></p><p>5.</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281518564.png" alt="练习7：坑5"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281518390.png" alt="练习7：坑5调试"></p><p>注意使用 ldr 时，可能产生 literal pool, 最好用 adrp 指令</p><h4 id="存储指令变种"><a href="#存储指令变种" class="headerlink" title="存储指令变种"></a>存储指令变种</h4><div class="table-container"><table><thead><tr><th>指令</th><th>含义（全称）</th><th>访问大小</th><th>符号扩展</th></tr></thead><tbody><tr><td><strong>LDR</strong></td><td>Load Register</td><td>32 位（W 寄存器）或 64 位（X 寄存器）</td><td>无符号</td></tr><tr><td><strong>LDRSW</strong></td><td>Load Register Signed Word</td><td>32 位 → 符号扩展到 64 位</td><td>有符号</td></tr><tr><td><strong>LDRB</strong></td><td>Load Register Byte</td><td>8 位 → 零扩展到 32/64 位</td><td>无符号</td></tr><tr><td><strong>LDRSB</strong></td><td>Load Register Signed Byte</td><td>8 位 → 符号扩展到 32/64 位</td><td>有符号</td></tr><tr><td><strong>LDRH</strong></td><td>Load Register Halfword</td><td>16 位 → 零扩展到 32/64 位</td><td>无符号</td></tr><tr><td><strong>LDRSH</strong></td><td>Load Register Signed Halfword</td><td>16 位 → 符号扩展到 32/64 位</td><td>有符号</td></tr><tr><td><strong>LDRQ</strong></td><td>Load Register Quadword (NEON/SIMD 寄存器)</td><td>128 位（V 寄存器）</td><td>无符号</td></tr><tr><td><strong>STR</strong></td><td>Store Register</td><td>32 位或 64 位</td><td>无符号</td></tr><tr><td><strong>STRB</strong></td><td>Store Register Byte</td><td>8 位</td><td>无符号</td></tr><tr><td><strong>STRH</strong></td><td>Store Register Halfword</td><td>16 位</td><td>无符号</td></tr></tbody></table></div><p><strong>补充说明</strong></p><ul><li><strong>无符号加载 (LDR, LDRB, LDRH)</strong>：高位部分填充 <code>0</code>。</li><li><strong>有符号加载 (LDRSB, LDRSH, LDRSW)</strong>：会进行符号扩展（最高位是 1 则扩展为 1）。</li><li>如果访问和存储 4 个字节或 8 个字节都是用 ldr 和 str，只不过目标寄存器使用 wn 或者 xn</li><li><code>STR</code> 系列指令不存在有符号版本，因为存储时“原封不动”写入内存，<strong>不会进行符号扩展、零扩展或任何填充操作</strong>，但要注意寄存器位宽，如 xn 和 wn 时不同的。</li><li>AArch64 默认小端序（低地址存低字节）。</li><li>还有一类<strong>原子加载/存储指令</strong>（<code>LDAXR</code>、<code>STLXR</code>等）用于锁操作</li></ul><h3 id="算数与移位指令"><a href="#算数与移位指令" class="headerlink" title="算数与移位指令"></a>算数与移位指令</h3><p>pstate 处理器状态中四个条件操作码 NZCV</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281519910.png" alt="NZCV条件标志域"></p><h4 id="add-加法指令"><a href="#add-加法指令" class="headerlink" title="add 加法指令"></a>add 加法指令</h4><h5 id="普通的加法指令-add"><a href="#普通的加法指令-add" class="headerlink" title="普通的加法指令 add"></a>普通的加法指令 add</h5><ul><li>使用寄存器的加法</li><li>使用立即数的加法</li><li>使用移位操作的加法</li></ul><h5 id="adds-指令-影响条件标志位-进位"><a href="#adds-指令-影响条件标志位-进位" class="headerlink" title="adds 指令-影响条件标志位(进位)"></a>adds 指令-影响条件标志位(进位)</h5><p>主要影响 C 标志位(无符号溢出)</p><h4 id="sub-减法指令"><a href="#sub-减法指令" class="headerlink" title="sub 减法指令"></a>sub 减法指令</h4><h5 id="普通的减法指令"><a href="#普通的减法指令" class="headerlink" title="普通的减法指令"></a>普通的减法指令</h5><h5 id="subs-指令-影响条件标志位-C-标志位"><a href="#subs-指令-影响条件标志位-C-标志位" class="headerlink" title="subs 指令-影响条件标志位(C 标志位)"></a>subs 指令-影响条件标志位(C 标志位)</h5><h4 id="adc-指令-带进位的加法指令"><a href="#adc-指令-带进位的加法指令" class="headerlink" title="adc 指令(带进位的加法指令)"></a>adc 指令(带进位的加法指令)</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281520110.png" alt="ADC指令"></p><h4 id="sbc-指令-带进位的减法指令"><a href="#sbc-指令-带进位的减法指令" class="headerlink" title="sbc 指令(带进位的减法指令)"></a>sbc 指令(带进位的减法指令)</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281520218.png" alt="SBC指令"></p><p>Wd = Wn - Wm-1+ C</p><h4 id="cmp-比较指令"><a href="#cmp-比较指令" class="headerlink" title="cmp 比较指令"></a>cmp 比较指令</h4><blockquote><p>比较两个数的大小，内部使用 subs 指令来实现，影响 C 标志位</p></blockquote><p>等同于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBS XZR, &lt;Xn&gt;, #&lt;imm&gt;</span><br></pre></td></tr></table></figure><p>当 x1 和 x2 都为无符号数时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp x1, x2</span><br></pre></td></tr></table></figure><p>x1-x2 = x1+ ~x2+1(发生溢出)</p><p>当 x1&gt;= x2 时，C=1</p><p>当 x1&lt;x2 时 C=0</p><h4 id="练习-1-adds-和-cmp-指令的-C-条件标志位"><a href="#练习-1-adds-和-cmp-指令的-C-条件标志位" class="headerlink" title="练习 1 adds 和 cmp 指令的 C 条件标志位"></a>练习 1 adds 和 cmp 指令的 C 条件标志位</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281520095.png" alt="练习1：adds和cmp指令的C条件标志位"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281521890.png" alt="练习1代码"></p><div class="table-container"><table><thead><tr><th>位</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>31</td><td>N</td><td>结果为负数</td></tr><tr><td>30</td><td>Z</td><td>结果为零</td></tr><tr><td>29</td><td>C</td><td>无符号比较无借位（Carry）</td></tr><tr><td>28</td><td>V</td><td>有符号溢出</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281521034.png" alt="练习1调试"></p><h4 id="练习-2-cmp-和-sbc-指令"><a href="#练习-2-cmp-和-sbc-指令" class="headerlink" title="练习 2 cmp 和 sbc 指令"></a>练习 2 cmp 和 sbc 指令</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281521159.png" alt="练习2 cmp和sbc指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281522515.png" alt="练习2代码"></p><h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h4><ul><li>lsl 逻辑左移</li><li>lsr 逻辑右移</li><li>asr 算数右移</li><li>ror 循环右移</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281522183.png" alt="移位操作"></p><h4 id="按位与操作"><a href="#按位与操作" class="headerlink" title="按位与操作"></a>按位与操作</h4><ul><li><strong>and</strong> 与操作</li><li><strong>ands</strong> 带进位的与操作，影响 Z 标志位</li></ul><h4 id="按位或操作"><a href="#按位或操作" class="headerlink" title="按位或操作"></a>按位或操作</h4><ul><li><strong>orr</strong> 或操作</li><li><strong>eor</strong> 异或操作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281522079.png" alt="异或"></p><h4 id="按位清除"><a href="#按位清除" class="headerlink" title="按位清除"></a>按位清除</h4><ul><li><strong>bic</strong> 位清零指令</li></ul><p>不常见</p><h4 id="练习-3：测试-ands-指令以及-Z-标志位"><a href="#练习-3：测试-ands-指令以及-Z-标志位" class="headerlink" title="练习 3：测试 ands 指令以及 Z 标志位"></a>练习 3：测试 ands 指令以及 Z 标志位</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281523308.png" alt="练习3：ands指令以及Z标志位"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281523754.png" alt="练习3代码"></p><h4 id="位段插入操作"><a href="#位段插入操作" class="headerlink" title="位段插入操作"></a>位段插入操作</h4><blockquote><p>位段(bitfield)</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281525078.png" alt="位段插入操作"></p><h5 id="bfi-位段插入指令"><a href="#bfi-位段插入指令" class="headerlink" title="bfi 位段插入指令"></a><strong>bfi</strong> 位段插入指令</h5><blockquote><p>bitfield insert</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281526528.png" alt="位段插入指令"></p><ul><li><p><strong>Xd</strong>：目标寄存器（Destination）</p></li><li><p><strong>Xn</strong>：源寄存器（Source）</p></li><li><p><strong>lsb</strong>：<strong>Least Significant Bit</strong>，即 <strong>目标寄存器 Xd 中要开始插入的最低位位置索引</strong>（从 0 开始计数）。</p></li><li><p><strong>width</strong>：要插入的位宽（bit 数）。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281526731.png" alt="bfi位段插入指令"></p><h5 id="ubfx-无符号数的位段提取指令"><a href="#ubfx-无符号数的位段提取指令" class="headerlink" title="ubfx 无符号数的位段提取指令"></a>ubfx 无符号数的位段提取指令</h5><h5 id="sbfx-有符号数的位段提取指令"><a href="#sbfx-有符号数的位段提取指令" class="headerlink" title="sbfx 有符号数的位段提取指令"></a>sbfx 有符号数的位段提取指令</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281526965.png" alt="sbfx有符号数的位段提取指令"></p><p>注意是从 0 开始计数</p><h4 id="练习-4：测试-bitfield-指令"><a href="#练习-4：测试-bitfield-指令" class="headerlink" title="练习 4：测试 bitfield 指令"></a>练习 4：测试 bitfield 指令</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281527450.png" alt="练习4: 测试bitfield指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281528651.png" alt="练习4代码及调试"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281533783.png" alt="练习4调试"></p><h4 id="乘法和除法指令"><a href="#乘法和除法指令" class="headerlink" title="乘法和除法指令"></a>乘法和除法指令</h4><p>乘法：</p><div class="table-container"><table><thead><tr><th>指令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>MADD</strong></td><td>Multiply-Add：<code>Xd = (Xn * Xm) + Xa</code></td></tr><tr><td><strong>MNEG</strong></td><td>Multiply-Negate：<code>Xd = -(Xn * Xm)</code></td></tr><tr><td><strong>MSUB</strong></td><td>Multiply-Subtract：<code>Xd = Xa - (Xn * Xm)</code></td></tr><tr><td><strong>MUL</strong></td><td>Multiply：<code>Xd = Xn * Xm</code>（低 64 位结果）</td></tr><tr><td><strong>SMADDL</strong></td><td>Signed Multiply-Add Long：32 位*32 位 → 64 位，加上加数</td></tr><tr><td><strong>SMNEGL</strong></td><td>Signed Multiply-Negate Long：32 位*32 位 → 64 位，取负</td></tr><tr><td><strong>SMSUBL</strong></td><td>Signed Multiply-Subtract Long：32 位*32 位 → 64 位，执行减法</td></tr><tr><td><strong>SMULH</strong></td><td>Signed Multiply returning High half：取 128 位结果的高 64 位（有符号）</td></tr><tr><td><strong>SMULL</strong></td><td>Signed Multiply Long：32 位*32 位 → 64 位</td></tr><tr><td><strong>UMADDL</strong></td><td>Unsigned Multiply-Add Long：无符号版本</td></tr><tr><td><strong>UMNEGL</strong></td><td>Unsigned Multiply-Negate Long：无符号版本</td></tr><tr><td><strong>UMSUBL</strong></td><td>Unsigned Multiply-Subtract Long：无符号版本</td></tr><tr><td><strong>UMULH</strong></td><td>Unsigned Multiply returning High half：取高 64 位（无符号）</td></tr><tr><td><strong>UMULL</strong></td><td>Unsigned Multiply Long：无符号 32 位*32 位 → 64 位</td></tr></tbody></table></div><p>除法：</p><div class="table-container"><table><thead><tr><th>指令</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>SDIV</strong></td><td>Signed Divide：有符号除法</td></tr><tr><td><strong>UDIV</strong></td><td>Unsigned Divide：无符号除法</td></tr></tbody></table></div><h3 id="比较与跳转指令"><a href="#比较与跳转指令" class="headerlink" title="比较与跳转指令"></a>比较与跳转指令</h3><h4 id="练习-5：使用-bitfield-指令来读取寄存器"><a href="#练习-5：使用-bitfield-指令来读取寄存器" class="headerlink" title="练习 5：使用 bitfield 指令来读取寄存器"></a>练习 5：使用 bitfield 指令来读取寄存器</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281533866.png" alt="练习5"></p><blockquote><p>注意 ubfx 这类指令只能对普通寄存器的值进行位域提取，不能直接提取系统寄存器，因此需要先用 msr 把系统寄存器存入通用寄存器</p></blockquote><p>读取系统寄存器(move register from system)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mrs x1, ID_AA64ISAR0_EL1</span><br></pre></td></tr></table></figure><p>写入系统寄存器(move system from register)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msr ID_AA64ISAR0_EL1, x1</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 但注意：很多 CPU 特性寄存器（如 <code>ID_AA64ISAR0_EL1</code>）是 <strong>只读的</strong>，所以 <code>MSR</code> 往这个寄存器写入通常会触发异常，不能随意修改。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281534502.png" alt="练习5代码及调试"></p><h4 id="零计数指令-clz"><a href="#零计数指令-clz" class="headerlink" title="零计数指令 clz"></a>零计数指令 clz</h4><blockquote><p>clz: 计算最高为 1 的比特位前面有几个 0</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281553353.png" alt="CLZ指令"></p><h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><h5 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h5><blockquote><p>比较两个数</p></blockquote><p>cmp x1, x2</p><p>x1-x2</p><h5 id="cmn"><a href="#cmn" class="headerlink" title="cmn"></a>cmn</h5><blockquote><p>负向比较</p></blockquote><p>cmn x1, x2</p><p>x1+x2</p><h5 id="条件操作后缀"><a href="#条件操作后缀" class="headerlink" title="条件操作后缀"></a>条件操作后缀</h5><div class="table-container"><table><thead><tr><th>条件后缀</th><th>含义</th><th>标志</th><th>条件码</th><th>缩写说明</th></tr></thead><tbody><tr><td>EQ</td><td>相等</td><td>Z=1</td><td>0b0000</td><td>Equal</td></tr><tr><td>NE</td><td>不相等</td><td>Z=0</td><td>0b0001</td><td>Not Equal</td></tr><tr><td>CS/HS</td><td>无符号数大于或等于</td><td>C=1</td><td>0b0010</td><td>Carry Set / Higher or Same</td></tr><tr><td>CC/LO</td><td>无符号数小于</td><td>C=0</td><td>0b0011</td><td>Carry Clear / Lower</td></tr><tr><td>MI</td><td>负数</td><td>N=1</td><td>0b0100</td><td>Minus</td></tr><tr><td>PL</td><td>正数或零</td><td>N=0</td><td>0b0101</td><td>Plus</td></tr><tr><td>VS</td><td>溢出</td><td>V=1</td><td>0b0110</td><td>Overflow Set</td></tr><tr><td>VC</td><td>未溢出</td><td>V=0</td><td>0b0111</td><td>Overflow Clear</td></tr><tr><td>HI</td><td>无符号数大于</td><td>(C=1) &amp;&amp; (Z=0)</td><td>0b1000</td><td>Higher</td></tr><tr><td>LS</td><td>无符号数小于或等于</td><td>(C=0) ∨ (Z=1)</td><td>0b1001</td><td>Lower or Same</td></tr><tr><td>GE</td><td>带符号数大于或等于</td><td>N = V</td><td>0b1010</td><td>Greater or Equal</td></tr><tr><td>LT</td><td>带符号数小于</td><td>N ≠ V</td><td>0b1011</td><td>Less Than</td></tr><tr><td>GT</td><td>带符号数大于</td><td>(Z=0) &amp;&amp; (N=V)</td><td>0b1100</td><td>Greater Than</td></tr><tr><td>LE</td><td>带符号数小于或等于</td><td>(Z=1) ∨ (N≠V)</td><td>0b1101</td><td>Less or Equal</td></tr><tr><td>AL</td><td>无条件执行</td><td>—</td><td>0b1110</td><td>Always</td></tr><tr><td>NV</td><td>无条件执行</td><td>—</td><td>0b1111</td><td>Never (保留，一般不用)</td></tr></tbody></table></div><h4 id="练习-1：cmp-cmn-指令以及条件操作后缀"><a href="#练习-1：cmp-cmn-指令以及条件操作后缀" class="headerlink" title="练习 1：cmp/cmn 指令以及条件操作后缀"></a>练习 1：cmp/cmn 指令以及条件操作后缀</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281534431.png" alt="实验1：cmp/cmn指令以及条件操作后缀"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281535847.png" alt="练习1代码及调试"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281535990.png" alt="练习1代码"></p><h4 id="NZCV-寄存器结构图"><a href="#NZCV-寄存器结构图" class="headerlink" title="NZCV 寄存器结构图"></a><strong>NZCV 寄存器结构图</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281535429.png" alt="NZCV寄存器结构图"></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌───┬───┬───┬───┐</span><br><span class="line">│ <span class="built_in">N</span> │ <span class="variable">Z</span> │ <span class="built_in">C</span> │ <span class="variable">V</span> │</span><br><span class="line">└───┴───┴───┴───┘</span><br><span class="line"> <span class="number">31</span>  <span class="number">30</span>  <span class="number">29</span>  <span class="number">28</span>   ← 在 <span class="variable">PSTATE</span> 或 <span class="variable">NZCV</span> 系统寄存器的位位置</span><br></pre></td></tr></table></figure><p><strong>N (Negative flag)</strong></p><ul><li>结果为负数（有符号数最高位为 1） → N=1</li><li>否则 N=0</li></ul><p><strong>Z (Zero flag)</strong></p><ul><li>结果等于 0 → Z=1</li><li>否则 Z=0</li></ul><p><strong>C (Carry flag)</strong></p><ul><li>加法：有进位 → C=1</li><li>减法：无借位（即操作数 1 ≥ 操作数 2） → C=1</li><li>否则 C=0</li></ul><p><strong>V (Overflow flag)</strong></p><ul><li>有符号加/减法溢出（结果超出可表示范围） → V=1</li><li>否则 V=0</li></ul><h4 id="条件选择指令"><a href="#条件选择指令" class="headerlink" title="条件选择指令"></a>条件选择指令</h4><blockquote><p>搭配 cmp 指令来使用</p></blockquote><h5 id="csel"><a href="#csel" class="headerlink" title="csel"></a>csel</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281536572.png" alt="条件选择指令 csel"></p><h5 id="cset"><a href="#cset" class="headerlink" title="cset"></a>cset</h5><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281536198.png" alt="条件选择指令 cset"></p><h5 id="csinc"><a href="#csinc" class="headerlink" title="csinc"></a>csinc</h5><blockquote><p><strong>Conditional Select Increment</strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281537698.png" alt="条件选择指令 csinc"></p><h4 id="练习-2：条件选择指令"><a href="#练习-2：条件选择指令" class="headerlink" title="练习 2：条件选择指令"></a>练习 2：条件选择指令</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281537488.png" alt="练习2 条件选择指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281538849.png" alt="练习2 代码及其调试"></p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><h5 id="b-无条件跳转"><a href="#b-无条件跳转" class="headerlink" title="b 无条件跳转"></a>b 无条件跳转</h5><blockquote><p>跳转指令，无条件的跳转指令，不返回</p><p>跳转范围：PC+/- 128MB</p></blockquote><h5 id="b-cnd-有条件跳转指令"><a href="#b-cnd-有条件跳转指令" class="headerlink" title="b.cnd 有条件跳转指令"></a>b.cnd 有条件跳转指令</h5><blockquote><p>有条件的跳转指令，不返回</p><p>cnd 为条件操作后缀</p><p>跳转范围：PC+/- 1MB</p></blockquote><h5 id="bx-跳转到寄存器指定地址处"><a href="#bx-跳转到寄存器指定地址处" class="headerlink" title="bx 跳转到寄存器指定地址处"></a>bx 跳转到寄存器指定地址处</h5><blockquote><p>跳转到寄存器指定的地址处，不返回</p></blockquote><h5 id="bl-Branch-with-Link-带返回地址的跳转"><a href="#bl-Branch-with-Link-带返回地址的跳转" class="headerlink" title="bl (Branch with Link)带返回地址的跳转"></a>bl (Branch with Link)带返回地址的跳转</h5><blockquote><p>带返回地址(PC+4 =&gt; x30)，适用于 call 子函数</p><p>返回地址保存到 x30 中，保存的是父函数的 PC+4</p><p>跳转范围：PC+/- 128MB</p></blockquote><h5 id="blx-Branch-with-Link-to-Register"><a href="#blx-Branch-with-Link-to-Register" class="headerlink" title="blx (Branch with Link to Register)"></a>blx (Branch with Link to Register)</h5><blockquote><p>跳转到寄存器指定的地址处，可以返回</p><p>返回地址保存到 x30 中，保存的是父函数的 PC+4</p></blockquote><h4 id="返回指令"><a href="#返回指令" class="headerlink" title="返回指令"></a>返回指令</h4><h5 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h5><blockquote><p>从子函数中返回，通常是 x30 里保存了返回地址</p></blockquote><h5 id="eret"><a href="#eret" class="headerlink" title="eret"></a>eret</h5><blockquote><p>从当前的异常模式返回，通常可以实现模式的切换，例如 EL1 切换到 EL0</p><p>它从当前的异常模式中返回，它会从 SPSR 中恢复 PSTATE，从 ELR 中获取跳转地址，并返回到该地址</p></blockquote><h4 id="练习-3：-为啥-ret-之后就跑飞了"><a href="#练习-3：-为啥-ret-之后就跑飞了" class="headerlink" title="练习 3： 为啥 ret 之后就跑飞了"></a>练习 3： 为啥 ret 之后就跑飞了</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281538578.png" alt="练习3: 为什么ret后就跑飞了"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281539851.png" alt="练习3代码"></p><p><strong>陷阱与坑</strong></p><blockquote><p>bl 指令：用于 call 子函数，它把返回地址写入到 x30 寄存器，返回地址为 PC+4</p><p>在一个函数里调用 bl 来 call 子函数，有可能会把父函数的 lr 寄存器给冲走，然后父函数的 ret 返回就跑飞了</p></blockquote><p>简单来讲就是子函数更改了 x30 寄存器的值，返回时没有恢复</p><h4 id="比较并跳转指令"><a href="#比较并跳转指令" class="headerlink" title="比较并跳转指令"></a>比较并跳转指令</h4><h5 id="cbz-cbnz-tbz-tbnz"><a href="#cbz-cbnz-tbz-tbnz" class="headerlink" title="cbz cbnz tbz tbnz"></a>cbz cbnz tbz tbnz</h5><div class="table-container"><table><thead><tr><th>指令</th><th>缩写含义</th><th>作用描述</th></tr></thead><tbody><tr><td><strong>CBZ</strong></td><td><em>Compare and Branch if Zero</em></td><td>检查指定寄存器的值是否为零，若为零则跳转到目标地址，跳转范围+/- 1MB。</td></tr><tr><td><strong>CBNZ</strong></td><td><em>Compare and Branch if Non-Zero</em></td><td>检查指定寄存器的值是否非零，若非零则跳转到目标地址，跳转范围+/- 1MB。</td></tr><tr><td><strong>TBZ</strong></td><td><em>Test Bit and Branch if Zero</em></td><td>检查指定寄存器的某一位（bit）是否为 0，若该位为 0 则跳转到目标地址，跳转范围+/- 32KB。</td></tr><tr><td><strong>TBNZ</strong></td><td><em>Test Bit and Branch if Non-Zero</em></td><td>检查指定寄存器的某一位（bit）是否为 1，若该位为 1 则跳转到目标地址，跳转范围+/- 32KB。</td></tr></tbody></table></div><h3 id="其他重要的指令"><a href="#其他重要的指令" class="headerlink" title="其他重要的指令"></a>其他重要的指令</h3><h4 id="PC-相对地址加载指令"><a href="#PC-相对地址加载指令" class="headerlink" title="PC 相对地址加载指令"></a>PC 相对地址加载指令</h4><ul><li>adr 指令，加载 PC 相对地址的 label 的地址，范围为+/- 1MB</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281539740.png" alt="adr指令"></p><ul><li>adrp 指令，加载 PC 相对地址的 label 的地址，它只加载 label 所属的 4KB 对齐的地址，范围为+/- 4GB</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281539698.png" alt="adrp指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281555627.png" alt="adrp指令图解"></p><h4 id="练习-1：-测试-adrp-和-ldr-指令"><a href="#练习-1：-测试-adrp-和-ldr-指令" class="headerlink" title="练习 1： 测试 adrp 和 ldr 指令"></a>练习 1： 测试 adrp 和 ldr 指令</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281540433.png" alt="练习1: 测试adrp和ldr指令"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281540313.png" alt="练习1代码"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281540748.png" alt="练习1调试"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281540382.png" alt="练习1调试"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281541316.png" alt="练习1调试"></p><h4 id="adrp-和-ldr-究竟有什么不同"><a href="#adrp-和-ldr-究竟有什么不同" class="headerlink" title="adrp 和 ldr 究竟有什么不同"></a>adrp 和 ldr 究竟有什么不同</h4><p>陷阱与坑：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281541759.png" alt="adrp和ldr究竟有什么不同"></p><ul><li>ldr 伪指令：加载的绝对地址</li><li><p>adrp 指令：加载的 PC 相对地址</p></li><li><p>当链接地址 = 运行地址时</p></li></ul><blockquote><p>ldr 伪指令 加载的地址 = adrp 指令加载的地址</p></blockquote><ul><li>当链接地址!=运行地址时</li></ul><blockquote><p>ldr 伪指令地址：加载的时链接地址（或称为虚拟地址）</p><p>adrp 指令：加载的时当前运行地址的 PC 值+label 的 offset，即 label 在当前运行时的地址（或者称为物理内存）</p></blockquote><h4 id="练习-2：adrp-和-ldr-指令的陷阱"><a href="#练习-2：adrp-和-ldr-指令的陷阱" class="headerlink" title="练习 2：adrp 和 ldr 指令的陷阱"></a>练习 2：adrp 和 ldr 指令的陷阱</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281541510.png" alt="练习2: adrp和ldr指令的陷阱"></p><h4 id="内存独占加载和存储指令"><a href="#内存独占加载和存储指令" class="headerlink" title="内存独占加载和存储指令"></a>内存独占加载和存储指令</h4><ul><li>ldxr 指令</li></ul><blockquote><p>内存独占加载指令，从内存中以独占 exclusive 的方式加载内存的地址到通用寄存器</p></blockquote><ul><li>stxr 指令</li></ul><blockquote><p>内存独占存储指令</p></blockquote><ol><li>ldrx 是加载内存，不过它会通过独占监视器来监视这个内存的访问，监视器会把这个内存地址标记为独占访问，保证其独占的方式来访问</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281542169.png" alt="内存独占加载指令 ldrx"></p><ol><li>stxr 是有条件的存储内存，刚才 ldxr 标记的内存地址被独占的方式存储了，注意第一个寄存器为 w0</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281542053.png" alt="内存独占存储指令 stxr"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281543300.png" alt="内存独占加载和存储指令原理"></p><ul><li>ldxr 指令和 stxr 指令通常需要配对使用</li><li>Linux 内核常常用来实现 atomic 的访问，例如 atomic_write()，atomic_set_bit()</li><li>spinlock 机制可以简单地使用 ldxr 和 stxr 指令来实现</li></ul><h4 id="练习-3：ldxr-和-stxr-指令的使用"><a href="#练习-3：ldxr-和-stxr-指令的使用" class="headerlink" title="练习 3：ldxr 和 stxr 指令的使用"></a>练习 3：ldxr 和 stxr 指令的使用</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281543030.png" alt="练习3: ldxr和stxr指令的使用"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281544535.png" alt="练习3代码"></p><h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><div class="table-container"><table><thead><tr><th>指令</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>SVC #imm</strong></td><td><strong>系统调用指令</strong>(Supervisor Call)</td><td>应用程序通过 <code>SVC</code> 指令从用户态跳转到内核态操作系统，通常进入 EL1 异常级别，用于触发系统调用</td></tr><tr><td><strong>HVC #imm</strong></td><td><strong>虚拟化系统调用指令</strong>(Hypervisor Call)</td><td>主机操作系统通过 <code>HVC</code> 指令从 EL1 进入 EL2，调用虚拟化管理程序（Hypervisor），用于虚拟化支持场景</td></tr><tr><td><strong>SMC #imm</strong></td><td><strong>安全监控系统调用指令</strong>(Secure Monitor Call)</td><td>主机操作系统或监控程序通过 <code>SMC</code> 指令从普通世界（Non-secure World）进入安全世界（Secure World），通常触发 EL3 异常，用于 TrustZone 安全机制</td></tr></tbody></table></div><h4 id="系统寄存器访问指令"><a href="#系统寄存器访问指令" class="headerlink" title="系统寄存器访问指令"></a>系统寄存器访问指令</h4><div class="table-container"><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><strong>MRS</strong></td><td>读取系统寄存器的值到通用寄存器（Move Register from System）</td></tr><tr><td><strong>MSR</strong></td><td>将通用寄存器的值写入系统寄存器（Move Register to System）</td></tr></tbody></table></div><h4 id="内存屏障指令"><a href="#内存屏障指令" class="headerlink" title="内存屏障指令"></a>内存屏障指令</h4><div class="table-container"><table><thead><tr><th>指令</th><th>全称</th><th>作用</th><th>强度</th><th>示例用途</th></tr></thead><tbody><tr><td><strong>DMB</strong></td><td>Data Memory Barrier</td><td>保证<strong>内存访问指令的执行顺序</strong>（如写后读不会乱序）</td><td>中等</td><td>多核间共享数据通信</td></tr><tr><td><strong>DSB</strong></td><td>Data Synchronization Barrier</td><td><strong>等待所有内存访问完成</strong>后再执行后续指令</td><td>强</td><td>外设寄存器读写前后，缓存同步</td></tr><tr><td><strong>ISB</strong></td><td>Instruction Synchronization Barrier</td><td><strong>清除指令流水线和缓存</strong>，强制重新取指</td><td>特殊</td><td>改变系统状态寄存器后，强制刷新指令</td></tr></tbody></table></div><ol><li>DMB</li></ol><p>作用： 保证内存访问的先后顺序，但不阻塞执行。<br>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str x0, [x1]     // 写数据</span><br><span class="line">dmb sy           // 确保写操作完成</span><br><span class="line">ldr x2, [x3]     // 再读其他数据</span><br></pre></td></tr></table></figure><ol><li>DSB</li></ol><p>作用： 必须等待之前所有内存操作完成，再继续执行后续指令。<br>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str x0, [x1]     // 写数据</span><br><span class="line">dsb sy           // 等待写入完成</span><br><span class="line">isb              // 保证后面执行的是最新的代码</span><br></pre></td></tr></table></figure><ol><li>ISB</li></ol><p>作用： 清除 CPU 指令预取缓存，通常在修改系统控制寄存器后用。<br>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msr sctlr_el1, x0  // 修改系统控制寄存器</span><br><span class="line">isb                // 强制刷新指令流</span><br></pre></td></tr></table></figure><p><strong>DMB/DSB 指令参数详解(内存屏障的粒度与作用范围)</strong></p><div class="table-container"><table><thead><tr><th>参数</th><th>访问顺序控制</th><th>共享范围</th><th>说明</th></tr></thead><tbody><tr><td><code>SY</code></td><td>读/写</td><td>全系统共享</td><td>最强，<strong>所有处理器和设备</strong>可见，常用于设备驱动或关键同步</td></tr><tr><td><code>ST</code></td><td>写</td><td>全系统共享</td><td>只对<strong>写操作</strong>建立顺序</td></tr><tr><td><code>LD</code></td><td>读</td><td>全系统共享</td><td>只对<strong>读操作</strong>建立顺序</td></tr><tr><td><code>ISH</code></td><td>读/写</td><td><strong>Inner Shareable（内部共享）</strong></td><td>多核共享同一个 L2 cache 时使用</td></tr><tr><td><code>ISHST</code></td><td>写</td><td>Inner 共享</td><td>内部共享域的<strong>写操作屏障</strong></td></tr><tr><td><code>ISHLD</code></td><td>读</td><td>Inner 共享</td><td>内部共享域的<strong>读操作屏障</strong></td></tr><tr><td><code>NSH</code></td><td>读/写</td><td><strong>Non-shareable（不共享）</strong></td><td>本核私有内存使用</td></tr><tr><td><code>NSHST</code></td><td>写</td><td>不共享</td><td>本核私有写屏障</td></tr><tr><td><code>NSHLD</code></td><td>读</td><td>不共享</td><td>本核私有读屏障</td></tr><tr><td><code>OSH</code></td><td>读/写</td><td><strong>Outer Shareable（外部共享）</strong></td><td>多个 L2 之间共享时使用</td></tr><tr><td><code>OSHST</code></td><td>写</td><td>Outer 共享</td><td>外部共享写屏障</td></tr><tr><td><code>OSHLT</code></td><td>读</td><td>Outer 共享</td><td>外部共享读屏障</td></tr></tbody></table></div><h3 id="Overview-总结"><a href="#Overview-总结" class="headerlink" title="Overview 总结"></a>Overview 总结</h3><ul><li>运行在 aarch64 execution state 的指令集，64 是指它的运行环境，而不是指令长度</li><li>指令长度是 32bit，而不是 64bit</li><li>31 个通用寄存器，xn 为 64bit，wn 为 32bit</li><li>零寄存器：xzr, wzr</li><li>pc 不是通用寄存器，通常不能直接返回</li><li>x30 用作链接寄存器 lr，用于函数返回</li><li>ELR_ELx 用于从异常返回</li><li>每个异常等级都有自己的栈 SP，例如 SP_EL0, SP_EL1</li><li><p>SP 不是通用寄存器</p></li><li><p>SIMD 和浮点运算的寄存器</p></li><li><p>Qn（126bit，16 字节），Dn（64bit）,Sn（32bit）， Hn（16bit）,Bn（Bn）</p></li><li><p><code>PSTATE</code>（Processor State Register）<strong>不是单独存在的一个物理寄存器</strong>，而是<strong>多个位段组成的处理器状态集合</strong>。</p></li><li><p><code>PSTATE</code> 的值控制 CPU 的当前状态，包括异常屏蔽、当前异常级别、条件码等。</p></li></ul><div class="table-container"><table><thead><tr><th>字段</th><th>含义说明</th></tr></thead><tbody><tr><td><code>NZCV</code></td><td>条件码标志位（ALU Flags）用于条件跳转等：<strong>N</strong>（负号）、<strong>Z</strong>（零）、<strong>C</strong>（进位）、<strong>V</strong>（溢出）</td></tr><tr><td><code>Q</code></td><td>溢出标志位位，仅 AArch32 用某些 SIMD 操作溢出时设置</td></tr><tr><td><code>DAIF</code></td><td>异常屏蔽位：<strong>D</strong>：调试异常屏蔽<strong>A</strong>：SError 屏蔽<strong>I</strong>：IRQ 中断屏蔽<strong>F</strong>：FIQ 中断屏蔽</td></tr><tr><td><code>SPSel</code></td><td>SP 寄存器选择（仅 AArch64）控制是使用 <code>SP_EL0</code> 还是 <code>SP_ELx</code></td></tr><tr><td><code>CurrentEL</code></td><td>当前异常级别（EL0/EL1/EL2/EL3）影响特权级访问和执行</td></tr><tr><td><code>E</code></td><td>字节序选择（AArch32）控制数据访问是小端或大端</td></tr><tr><td><code>IL</code></td><td>非法指令标志设为 1 时，<strong>所有指令都会被当作 UNDEFINED 执行</strong>，调试用</td></tr><tr><td><code>SS</code></td><td>单步执行标志（Software Stepping）与调试器联合使用，每次执行一条指令后触发异常</td></tr></tbody></table></div><ul><li>加载和存储指令</li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>类型</th><th>数据大小</th><th>是否符号扩展</th><th>存储/加载目标</th></tr></thead><tbody><tr><td><code>LDR</code></td><td>普通加载</td><td>依寄存器</td><td>否</td><td>任意位宽</td></tr><tr><td><code>LDRSW</code></td><td>加载有符号 word</td><td>32-bit</td><td>✔（符号扩展至 64-bit）</td><td><strong>Xn only</strong></td></tr><tr><td><code>LDRB</code></td><td>加载字节</td><td>8-bit</td><td>否</td><td>Wn/Xn</td></tr><tr><td><code>LDRSB</code></td><td>加载符号字节</td><td>8-bit</td><td>✔</td><td>Wn 或 Xn</td></tr><tr><td><code>LDRH</code></td><td>加载半字</td><td>16-bit</td><td>否</td><td>Wn/Xn</td></tr><tr><td><code>LDRSH</code></td><td>加载符号半字</td><td>16-bit</td><td>✔</td><td>Wn 或 Xn</td></tr><tr><td><code>STRB</code></td><td>存储字节</td><td>8-bit</td><td>N/A</td><td>—</td></tr><tr><td><code>STRH</code></td><td>存储半字</td><td>16-bit</td><td>N/A</td><td>—</td></tr></tbody></table></div><p>指令后缀含义</p><div class="table-container"><table><thead><tr><th>后缀</th><th>含义</th></tr></thead><tbody><tr><td><code>B</code></td><td>Byte（8-bit）</td></tr><tr><td><code>H</code></td><td>Halfword（16-bit）</td></tr><tr><td><code>W</code></td><td>Word（32-bit）</td></tr><tr><td><code>S</code></td><td>Sign-extended（符号扩展）</td></tr><tr><td>无后缀</td><td>默认按目标寄存器位数加载或存储</td></tr></tbody></table></div><ul><li>多字节加载和存储指令<ul><li>A64 指令集已经把 ldm，stm，push，pop 指令删掉</li><li>ldp 和 stp 来实现多字节加载和存储指令</li></ul></li></ul><p><strong>与 PC 相关的指令</strong></p><p><code>ldr x0, =label</code>（伪指令）</p><ul><li><strong>含义</strong>：加载 <code>label</code> 的地址（<strong>链接地址</strong>）到 <code>x0</code>。</li><li><strong>实现方式</strong>：汇编器会在 <code>.rodata</code> 区域生成一个常量表，<code>ldr</code> 实际上是从常量表中加载地址。</li><li><strong>适用场景</strong>：任何位置都能使用，但<strong>依赖链接时地址信息</strong>，在支持重定位的系统中要谨慎。</li></ul><hr><p><code>ldr x0, label</code></p><ul><li><strong>含义</strong>：将 <code>label</code> 地址处的值加载到 <code>x0</code> 中。</li><li><strong>注意</strong>：这里的 <code>label</code> 是个地址，指向的数据会被加载到寄存器中（不是加载地址本身）。</li><li><strong>区别于上面</strong>：这个不是加载地址，而是<strong>通过地址去读取数据</strong>。</li></ul><hr><p><code>adr x0, .</code></p><ul><li><strong>含义</strong>：把当前 PC 的值加载到 <code>x0</code> 中。</li><li><strong>常用场景</strong>：定位当前代码位置（如实现 Position-Independent Code）。</li></ul><hr><p><code>adrp x0, label</code></p><ul><li><strong>含义</strong>：将 <code>label</code> 所在 page 的<strong>页首地址（4KB 对齐）</strong>加载到 <code>x0</code> 中。</li><li><strong>用途</strong>：<ul><li>多用于 <strong>位置无关代码（PIC）</strong>。</li><li>搭配 <code>add</code> 实现完整地址加载：</li></ul></li></ul><div class="table-container"><table><thead><tr><th>标志位</th><th>含义</th><th>常见触发情况</th></tr></thead><tbody><tr><td><code>N</code></td><td>Negative（负号）标志位：结果为负时置位</td><td>如 <code>subs x0, x1, x2</code> 得到负数</td></tr><tr><td><code>Z</code></td><td>Zero（零）标志位：结果为零时置位</td><td>如 <code>subs x0, x1, x1</code>，结果为 0</td></tr><tr><td><code>C</code></td><td>Carry（进位）标志位：无符号加法进位/无符号减法借位</td><td>如 <code>adds</code>, <code>subs</code>, <code>adc</code>, <code>sbc</code></td></tr><tr><td><code>V</code></td><td>Overflow（溢出）标志位：有符号数加减运算时溢出</td><td>如 <code>adds</code>, <code>subs</code> 溢出</td></tr></tbody></table></div><p>推荐查阅文档</p><p><strong>arm8.6 Chapter C3 A64 Instruction Set Overview</strong></p><h3 id="QEMU-能跑但板子不能跑的陷阱与坑"><a href="#QEMU-能跑但板子不能跑的陷阱与坑" class="headerlink" title="QEMU 能跑但板子不能跑的陷阱与坑"></a>QEMU 能跑但板子不能跑的陷阱与坑</h3><h4 id="坑-1：ldr-指令加载宏"><a href="#坑-1：ldr-指令加载宏" class="headerlink" title="坑 1：ldr 指令加载宏"></a>坑 1：ldr 指令加载宏</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281545985.png" alt="坑1: ldr指令加载宏"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281545915.png" alt="ldr指令加载宏问题调试"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281546904.png" alt="ARM文档解释"></p><p>在裸机编程中，没有 enable MMU，因此内存属性一律被视为 Device memory</p><p>ldr 指令访问 8 个字节，如果地址不是 8 个字节对齐，那么会触发 alignment 异常，也就是 Data abort</p><p>解决办法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldr x6, MY_LABEL</span><br><span class="line">// 修改</span><br><span class="line">ldr w6, MY_LABEL</span><br></pre></td></tr></table></figure><h4 id="坑-2-ldr-指令加载字符串"><a href="#坑-2-ldr-指令加载字符串" class="headerlink" title="坑 2: ldr 指令加载字符串"></a><strong>坑 2: ldr 指令加载字符串</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281546036.png" alt="坑2: ldr指令加载字符串"></p><p>这也是 alignment 导致的，因为不能保证 string1 的起始地址是 8 个字节对齐</p><p>解决办法：让 string1 按 8 个字节对齐</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281547163.png" alt="坑2的解决办法"></p><h4 id="对齐访问总结"><a href="#对齐访问总结" class="headerlink" title="对齐访问总结"></a>对齐访问总结</h4><ul><li>对于 normal memory，支持不对齐访问。（需要 enable MMU，并设置内存属性为 normal）</li><li>可以单独设置不对齐访问时触发异常（设置 SCTLR_Elx.A）</li><li>对于 Device memory，不对齐访问会触发 Data Abort 异常<ul><li>没有 enable MMU 的系统，例如我们的实验代访问 DDR 编程访问 device memory</li></ul></li><li>指令预取，需要 4 个字节对齐，否则会触发异常</li></ul><ol><li>Normal memory 支持不对齐访问</li></ol><ul><li><strong>条件</strong>：<ul><li>启用了 <strong>MMU</strong>（Memory Management Unit）；</li><li>并且该内存区域的属性被设置为 <strong>Normal memory</strong>；</li></ul></li><li><strong>结果</strong>：<ul><li>支持对字（4 字节）、半字（2 字节）、字节（1 字节）的不对齐访问；</li><li>可实现跨边界访问，不触发异常；</li></ul></li></ul><ol><li>配置不对齐访问异常（SCTLR_ELx.A 位）</li></ol><ul><li><strong>SCTLR_EL1.A</strong> 控制是否允许 <strong>不对齐访问</strong>（Alignment Check）：<ul><li><code>A = 0</code>（默认）：允许不对齐访问（如果 memory 类型允许）；</li><li><code>A = 1</code>：<strong>强制对齐访问</strong>，一旦发生不对齐访问，则触发 <strong>Alignment fault 异常（Data Abort）</strong>；</li></ul></li></ul><ol><li>Device memory 不支持不对齐访问</li></ol><ul><li><strong>特点</strong>：<ul><li>无论 MMU 是否启用，Device memory 类型都<strong>不允许不对齐访问</strong>；</li></ul></li><li><strong>后果</strong>：<ul><li>一旦访问未对齐的地址（如访问 <code>0x1003</code> 的 32-bit 数据），将触发 <strong>Data Abort 异常</strong>；</li></ul></li><li><strong>应用示例</strong>：<ul><li>实验环境中直接映射访问 <strong>DDR、外设寄存器</strong> 等，通常被定义为 Device memory 类型；</li><li>访问这些区域时必须对齐，如访问 32-bit 数据必须 4 字节对齐；</li></ul></li></ul><ol><li>指令预取要求</li></ol><ul><li><strong>指令取址</strong> 必须是 <strong>4 字节对齐</strong>（即地址最低两位必须为 0）；</li><li>否则会触发 <strong>Instruction Abort 异常</strong>；</li><li>原因：ARMv8 指令以 4 字节为基本单位存储和取指，无法从非对齐位置解码执行指令。</li></ul><h4 id="坑-3：存储指令数据大小"><a href="#坑-3：存储指令数据大小" class="headerlink" title="坑 3：存储指令数据大小"></a><strong>坑 3：存储指令数据大小</strong></h4><p>使用 str 指令来设置寄存器，一定要注意寄存器的位宽，否则会出现死机问题</p><p>树莓派 4b 上的寄存器位宽都是 32bit 的，也就是 4 个字节</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281547346.png" alt="坑3: 存储指令数据大小"></p><h4 id="坑-4：ldxr-的大坑"><a href="#坑-4：ldxr-的大坑" class="headerlink" title="坑 4：ldxr 的大坑"></a>坑 4：ldxr 的大坑</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281547572.png" alt="坑4：ldxr的大坑"></p><p><strong>ldxr 指令的使用会有很多限制</strong></p><ol><li>首先确保访问的内存是 normal memory 并且是 sharable</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281548815.png" alt="ldxr指令要求内存是normal memory并且是sharable的"></p><ol><li>如果访问 device memory，例如 MMU 没有打开的情况，那就需要 CPU IP 核心支持以独占的方式访问 device memory，这个需要查询具体 CPU IP 手册的描述</li></ol><p>例如： Cortex-A72 MPCore Processor Technical Reference Manual 第 6.45 章节</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281548939.png" alt="在Cortex-A72没有打开MMU时以独占方式访问device memory会出错"></p><p>解决方法：</p><p>填充好页表，使能 MMU 和 cache，才能使用 ldxr 和 stxr</p><h3 id="在汇编中实现串口打印功能"><a href="#在汇编中实现串口打印功能" class="headerlink" title="在汇编中实现串口打印功能"></a>在汇编中实现串口打印功能</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281549929.png" alt="大作业: 在汇编中实现串口打印功能"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509281556610.png" alt="大作业预期结果"></p><p>🧱 1. GPIO 初始化（引脚复用配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ldr x1, =GPFSEL1</span><br><span class="line">ldr w0, [x1]</span><br><span class="line">and w0, w0, #0xffff8fff    // 清除 GPIO14 功能选择位（bit 12-14）</span><br><span class="line">orr w0, w0, #0x4000        // 设置 GPIO14 为 ALT0 (UART0_TXD)</span><br><span class="line">and w0, w0, #0xfffc7fff    // 清除 GPIO15 功能选择位（bit 15-17）</span><br><span class="line">orr w0, w0, #0x20000       // 设置 GPIO15 为 ALT0 (UART0_RXD)</span><br><span class="line">str w0, [x1]</span><br></pre></td></tr></table></figure><p>✅ 作用：将 GPIO14 和 GPIO15 设置为 UART 功能（ALT0 模式）。<br>🧱 2. 禁用上拉/下拉（仅 Pi 3B 配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_BOARD_PI3B</span><br><span class="line">ldr x1, =GPPUD</span><br><span class="line">str wzr,[x1]</span><br><span class="line"></span><br><span class="line">// delay 150 cycles</span><br><span class="line">mov x0, #150</span><br><span class="line">1:</span><br><span class="line">sub x0, x0, #1</span><br><span class="line">cmp x0, #0</span><br><span class="line">bne 1b</span><br><span class="line"></span><br><span class="line">ldr x1, =GPPUDCLK0</span><br><span class="line">ldr w2, #0xc000   // 对 GPIO14 和 GPIO15 生效</span><br><span class="line">str w2, [x1]</span><br><span class="line"></span><br><span class="line">// delay again</span><br><span class="line">mov x0, #150</span><br><span class="line">2:</span><br><span class="line">sub x0, x0, #1</span><br><span class="line">cmp x0, #0</span><br><span class="line">bne 2b</span><br><span class="line"></span><br><span class="line">ldr x1, =GPPUDCLK0</span><br><span class="line">str wzr, [x1]</span><br><span class="line">isb</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>✅ 对 GPIO14/15 禁用上拉/下拉，符合 BCM2837 的初始化流程。<br>🧱 3. UART 初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 禁用 UART</span><br><span class="line">ldr x1, =U_CR_REG</span><br><span class="line">str wzr, [x1]</span><br><span class="line"></span><br><span class="line">// 设置波特率</span><br><span class="line">ldr x1, =U_IBRD_REG</span><br><span class="line">mov w2, #26          // Integer Baud Rate Divisor</span><br><span class="line">str w2, [x1]</span><br><span class="line"></span><br><span class="line">ldr x1, =U_FBRD_REG</span><br><span class="line">mov w2, #3           // Fractional Baud Rate Divisor</span><br><span class="line">str w2, [x1]</span><br><span class="line"></span><br><span class="line">// 设置数据格式</span><br><span class="line">ldr x1, =U_LCRH_REG</span><br><span class="line">mov w2, #0x70        // FIFO enable + 8-bit word length</span><br><span class="line">str w2, [x1]</span><br><span class="line"></span><br><span class="line">// 禁用中断</span><br><span class="line">ldr x1, =U_IMSC_REG</span><br><span class="line">str wzr, [x1]</span><br><span class="line"></span><br><span class="line">// 使能 UART (TX/RX/UART enable)</span><br><span class="line">ldr x1, =U_CR_REG</span><br><span class="line">mov w2, #0x301       // UARTEN | TXE | RXE</span><br><span class="line">str w2, [x1]</span><br><span class="line">isb</span><br></pre></td></tr></table></figure><p>✅ 正确配置波特率和数据格式（8N1, FIFO），最后使能 UART。</p><p>你使用的是：</p><pre><code>波特率 = UARTCLK / (16 * (IBRD + FBRD/64))假设 UARTCLK = 48 MHz，则波特率约为 115200。</code></pre><p>🧱 4. 单个字符输出函数 put_uart</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">put_uart:</span><br><span class="line">ldr x1, =U_FR_REG</span><br><span class="line">1:</span><br><span class="line">ldr w2, [x1]</span><br><span class="line">and w2, w2, #0x20       // 检查 TXFF (Transmit FIFO full)</span><br><span class="line">cmp w2, #0</span><br><span class="line">b.ne 1b                 // 如果 FIFO 满，则等待</span><br><span class="line"></span><br><span class="line">ldr x1, =U_DATA_REG</span><br><span class="line">str w0, [x1]            // 写入字符</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>✅ 会等待 FIFO 可用后发送字符。</p><p>🧱 5. 字符串输出函数 put_string_uart</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">put_string_uart:</span><br><span class="line">mov x4, x0              // x0: 指向字符串</span><br><span class="line">mov x6, x30             // 保存返回地址</span><br><span class="line">1:</span><br><span class="line">ldrb w0, [x4]           // 读取一个字节（字符）</span><br><span class="line">bl put_uart</span><br><span class="line">add x4, x4, 1</span><br><span class="line">cmp w0, #0</span><br><span class="line">bne 1b</span><br><span class="line">mov x30, x6</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>✅ 输入：x0 = 字符串地址，将其打印出来直到遇到 NULL（0x00）。</p>]]></content>
      
      
      <categories>
          
          <category> arm64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P26 删除有序数组中的重复项</title>
      <link href="/posts/26/"/>
      <url>/posts/26/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-28</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P26 删除有序数组中的重复项" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P26 删除有序数组中的重复项</p><p class="url">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>std::unique 是 C++ <algorithm> 里的函数，它并不会真正删除容器里的元素，而是 将相邻的重复元素“移到后面”，并返回一个指向“新的逻辑末尾”的迭代器。配合 erase 可以实现删除重复元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        nums.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>()),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P27 移除元素</title>
      <link href="/posts/27/"/>
      <url>/posts/27/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-28</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P27 移除元素" href="https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P27 移除元素</p><p class="url">https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>简单但经典双指针题目，就像她经典的印花长裙~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, k;</span><br><span class="line"></span><br><span class="line">    k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= k) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(nums[i], nums[k]);</span><br><span class="line">        k--;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P976 三角形的最大周长</title>
      <link href="/posts/976/"/>
      <url>/posts/976/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-28</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P976 三角形的最大周长" href="https://leetcode.cn/problems/largest-perimeter-triangle/?envType=daily-question&envId=2025-09-28"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P976 三角形的最大周长</p><p class="url">https://leetcode.cn/problems/largest-perimeter-triangle/?envType=daily-question&envId=2025-09-28</p></div></a></div><br>此题求最大周长，我们知道要求任意三角形两边之和大于第三边，其实就是最小边+次大边&gt;最大边即可，本题要求最大周长，那么当最大边固定时，次大边+最小边如果小于该最大边，那么说明该最大边太大了，我们需要让最大边小一些。也就是说我们只需要给所有的边数排序后，从后向前遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">largestPerimeter</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 固定最大边nums[k]，双指针找次大边nums[j]和最小边nums[i]</span></span><br><span class="line">    <span class="keyword">for</span> (k = n - <span class="number">1</span>; k &gt;= <span class="number">2</span>; k--) &#123;</span><br><span class="line">      length = nums[k - <span class="number">1</span>] + nums[k - <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">if</span> (nums[k] &lt; length) &#123;</span><br><span class="line">        <span class="keyword">return</span> length + nums[k];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC内嵌汇编</title>
      <link href="/posts/50002/"/>
      <url>/posts/50002/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>参考文档：</p><div class="tag link"><a class="link-card" title="gcc" href="https://gcc.gnu.org/onlinedocs/gcc.pdf"><div class="left"><img src="https://gcc.gnu.org/favicon.ico"/></div><div class="right"><p class="text">gcc</p><p class="url">https://gcc.gnu.org/onlinedocs/gcc.pdf</p></div></a></div><blockquote><p>内嵌汇编（Inline Assembly Language）在 C 语言中嵌入汇编代码</p></blockquote><p>目的：</p><ul><li>优化：针对特定重要代码(time-sensitive 进行优化)</li><li>C 语言需要访问某些特殊指令来实现特殊功能，比如内存屏障指令</li></ul><p>内存汇编两种模式</p><ul><li>基础内嵌汇编</li><li>扩展内嵌汇编</li></ul><h3 id="基础内嵌汇编"><a href="#基础内嵌汇编" class="headerlink" title="基础内嵌汇编"></a>基础内嵌汇编</h3><p><strong>格式：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="keyword">asm</span>-qualifiers(AssemblerInstructions)</span><br></pre></td></tr></table></figure><ul><li>asm 关键字：表明这是一个 GNU 扩展</li><li><p>修饰词（qualifiers）</p><ul><li>volatile：在基础内嵌汇编中通常不需要这个修饰词</li><li>inline：内联，asm 汇编的代码会尽可能小</li></ul></li><li><p>汇编代码块（AssemblerInstructions）</p><ul><li><p>GCC 编译器把内嵌汇编当成一个字符串</p></li><li><p>GCC 编译不会去解析和分析内嵌汇编</p></li><li><p>多条汇编指令，需要使用”\n\t“来换行</p></li><li><p>GCC 的优化器，可以移动汇编指令的前后位置。如果你需要保存汇编指令的顺序，最后使用多个内嵌汇编的方式</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807225346177.png" alt="基础内嵌汇编的例子"></p><h3 id="扩展内嵌汇编"><a href="#扩展内嵌汇编" class="headerlink" title="扩展内嵌汇编"></a>扩展内嵌汇编</h3><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807225554976.png" alt="扩展内嵌汇编"></p><ul><li>格式<ul><li>asm 关键字：表明这个是一个 GNU 扩展</li><li>修饰词(asm-qualifiers)<ul><li>volatile：用来关闭 GCC 优化</li><li>inline 内联，asm 汇编的代码会尽可能小</li><li>goto 在内嵌会便利会跳转到 C 语言的标签里</li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807225535346.png" alt="扩展内嵌汇编的例子"></p><ul><li><p>输出部：</p><blockquote><p>用于描述在指令部中<strong>可以被修改的 C 语言变量</strong>以及约束条件</p></blockquote><ul><li>每个输出约束通常以”=”开头，接着的字母表示对操作数类型的说明，然后是关于变量结合的约束</li><li>输出部通常使用”=“或者”+”作为输出约束，其中”<strong>=“表示被修饰的操作数只具有可写属性</strong>，”<strong>+“表示被修饰的操作数只具有可读可写属性</strong></li><li>输出部可以是空的</li></ul></li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;=/+&quot;</span> <span class="punctuation">+</span> 约束修饰符 <span class="punctuation">+</span> 变量</span><br></pre></td></tr></table></figure><ul><li><p>输入部</p><blockquote><p>用来描述在指令部<strong>只能被读取访问的 C 语言变量</strong>以及约束条件</p></blockquote><ul><li>输入部描述的参数是只有只读属性，不要试图修改输入部的参数内容，因为 GCC 编译器假定，输入部的参数的内容在内嵌汇编之前和之后都是一致的</li><li>在输入部中不能使用”=”或者”+“约束条件，否则编译器会报错</li><li>输入部可以是空的</li></ul></li><li><p>损坏部（Clobbers）</p><ul><li>“memory”告诉 GCC 编译器内联汇编指令改变了内存中的值，强迫编译器在执行该汇编代码前存储所有缓存中的值，在执行完汇编代码之后重新加载该值，目的是防止编译乱序</li><li>”cc”表示内嵌汇编代码修改了状态寄存器相关的标志位</li></ul></li><li><p>指令部的参数表示</p><ul><li>%0 对应输出输入部的第一个参数，%1 表示第二个参数</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807232638621.png" alt="指令部"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807232843751.png" alt="linux内核中的例子"></p><p><strong>输出和输入部的约束修饰符</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807232923213.png" alt="GCC内联操作符和修饰符"></p><p><strong>输出部和输入部的约束修饰符——通用</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807232959031.png" alt="输出部和输入部通用的约束修饰符"></p><p><strong>输出部和输入部的约束修饰符——ARM64</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807233047966.png" alt="ARM64特有的输出部和输入部约束修饰符"></p><p><strong>汇编符号名字来代替前缀%</strong></p><ul><li><p><code>%[name]</code> → 引用约束变量</p></li><li><p><code>%w[name]</code> → 引用 <strong>低 32 位寄存器</strong>（如 <code>w0, w1</code>）</p></li><li><p><code>%x[name]</code> → 引用 <strong>完整 64 位寄存器</strong>（如 <code>x0, x1</code>）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807233254708.png" alt="汇编符号名字代替前缀%"></p><h4 id="实验-1：实现简单的-memcpy-函数"><a href="#实验-1：实现简单的-memcpy-函数" class="headerlink" title="实验 1：实现简单的 memcpy 函数"></a>实验 1：实现简单的 memcpy 函数</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807233332933.png" alt="实验1"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250808105751008.png" alt="实验代码"></p><h3 id="陷阱与坑"><a href="#陷阱与坑" class="headerlink" title="陷阱与坑"></a>陷阱与坑</h3><ul><li><strong>GDB 不能单步调试内嵌汇编</strong></li><li><strong>输出部和输入部的修饰符不能用错</strong>，否则程序会跑错</li></ul><h4 id="实验-3：使用内嵌汇编实现-memset-函数"><a href="#实验-3：使用内嵌汇编实现-memset-函数" class="headerlink" title="实验 3：使用内嵌汇编实现 memset 函数"></a>实验 3：使用内嵌汇编实现 memset 函数</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250808225407690.png" alt="实验3代码"></p><h3 id="内嵌汇编的高级玩法：和宏结合"><a href="#内嵌汇编的高级玩法：和宏结合" class="headerlink" title="内嵌汇编的高级玩法：和宏结合"></a>内嵌汇编的高级玩法：和宏结合</h3><ul><li>技巧 1：使用了 C 语言的#运算符。在带参数的宏中，“#”运算符作为一个预处理运算符，可以把记号转换为字符串</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250808225815839.png" alt="linux内核中的例子"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_OP(op, asm_op) \</span></span><br><span class="line"><span class="meta">static inline void atomic_##op(int i, atomic_t *v) &#123; \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__( \</span></span><br><span class="line"><span class="meta">        asm_op <span class="string">&quot; %1, %0&quot;</span> \</span></span><br><span class="line"><span class="meta">        : <span class="string">&quot;+m&quot;</span> (v-&gt;counter) \</span></span><br><span class="line"><span class="meta">        : <span class="string">&quot;ir&quot;</span> (i)); \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以用这个宏来生成多个原子操作函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC_OP(add, <span class="string">&quot;addl&quot;</span>)</span><br><span class="line">ATOMIC_OP(sub, <span class="string">&quot;subl&quot;</span>)</span><br></pre></td></tr></table></figure><p>这会展开为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_add</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;addl %1, %0&quot;</span></span><br><span class="line">        : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span><br><span class="line">        : <span class="string">&quot;ir&quot;</span> (i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">atomic_sub</span><span class="params">(<span class="type">int</span> i, <span class="type">atomic_t</span> *v)</span> &#123;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">        <span class="string">&quot;subl %1, %0&quot;</span></span><br><span class="line">        : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span><br><span class="line">        : <span class="string">&quot;ir&quot;</span> (i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片中的这个宏使用 <code>#asm_op</code> 是因为 <strong>它需要将宏参数 <code>asm_op</code> 转换成字符串字面量</strong>，用于字符串拼接或输出。这种语法叫做 <strong>宏字符串化（stringification）</strong></p><p><code>asm_op</code> 是宏参数，<strong>在宏展开时会替换为你提供的值</strong>（比如 <code>&quot;addl&quot;</code>）。</p><p>它已经是一个字符串，比如你调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ATOMIC_OP(add, &quot;addl&quot;)</span><br></pre></td></tr></table></figure><p>宏展开后是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;addl %1, %0&quot;</span></span><br><span class="line">    : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span><br><span class="line">    : <span class="string">&quot;ir&quot;</span> (i));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> ATOMIC_OP(add, addl)</span><br></pre></td></tr></table></figure><p>宏展开后是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">    addl <span class="string">&quot;%1, %0&quot;</span></span><br><span class="line">    : <span class="string">&quot;+m&quot;</span> (v-&gt;counter)</span><br><span class="line">    : <span class="string">&quot;ir&quot;</span> (i));</span><br></pre></td></tr></table></figure><p>则不是</p><p><code>##name</code> —— <strong>符号连接（token pasting）运算符</strong></p><ul><li><p>把宏参数和前后的标识符直接拼接成一个新的标识符（不是字符串）。</p></li><li><p>常用来生成变量名、函数名等。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAKE_FUNC(name) void func_##name(void) &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">MAKE_FUNC(test); <span class="comment">// 展开成：void func_test(void) &#123;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="实验-4：使用内嵌汇编与宏的结合"><a href="#实验-4：使用内嵌汇编与宏的结合" class="headerlink" title="实验 4：使用内嵌汇编与宏的结合"></a>实验 4：使用内嵌汇编与宏的结合</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250808230527386.png" alt="实验4"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809090720797.png" alt="实验4代码"></p><h4 id="实验-5：实现读写系统寄存器的宏"><a href="#实验-5：实现读写系统寄存器的宏" class="headerlink" title="实验 5：实现读写系统寄存器的宏"></a>实验 5：实现读写系统寄存器的宏</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809090751064.png" alt="实验5"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809095412295.png" alt="实验5代码"></p><p>这里用到了<strong>GNU C 的语句表达式 (statement expression)</strong> 语法:</p><p><strong><code>(&#123; ... &#125;)</code> 是什么</strong></p><ul><li><p>这是 GNU 扩展，不是标准 C。</p></li><li><p>它让一段代码块既能像语句一样执行，也能<strong>返回一个值</strong>。</p></li><li><p>语法规则：</p><blockquote><p><code>(&#123; statement1; statement2; ...; expression; &#125;)</code><br>代码块里最后的那个 <strong>表达式</strong>（不加分号）就是返回值。</p></blockquote></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809101048717.png" alt="实验5另一种写法"></p><h3 id="内嵌汇编：goto"><a href="#内嵌汇编：goto" class="headerlink" title="内嵌汇编：goto"></a>内嵌汇编：goto</h3><blockquote><p>内嵌汇编的 goto 模板，可以跳转到 C 语言的 label 标签里</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809090847056.png" alt="goto内嵌汇编"></p><ul><li>Goto 模板的输出部必须为空</li><li>新增一个 gotolabels 的部，里面列出了 C 语言的 label，是允许跳转的 label</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809090955403.png" alt="goto内嵌汇编的一个例子"></p><h4 id="实验-6：goto-模板的内嵌汇编"><a href="#实验-6：goto-模板的内嵌汇编" class="headerlink" title="实验 6：goto 模板的内嵌汇编"></a>实验 6：goto 模板的内嵌汇编</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809091027525.png" alt="实验6"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250809102425122.png" alt="实验6代码"></p><p><code>%l[label]</code> 是 GCC 内联汇编中 <code>asm goto</code> 语法的特殊写法，表示跳转到 C 代码中的标签 <code>label</code>。</p><p>详细解释：</p><ul><li><code>%l[...]</code> 是告诉编译器这是一个<strong>标签符号</strong>（label），而不是普通的寄存器或立即数。</li><li><code>label</code> 是你在 C 代码里定义的标签名，比如你代码中的 <code>label:</code>。</li><li><code>asm goto</code> 允许汇编代码通过条件跳转直接跳转到 C 代码中的某个标签，实现条件分支。</li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU LD</title>
      <link href="/posts/50001/"/>
      <url>/posts/50001/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><div class="tag link"><a class="link-card" title="ld" href="https://sourceware.org/binutils/docs/ld.pdf"><div class="left"><img src="https://sourceware.org/favicon.ico"/></div><div class="right"><p class="text">ld</p><p class="url">https://sourceware.org/binutils/docs/ld.pdf</p></div></a></div><ul><li>链接器是一个程序，将一个或多个由编译器或汇编器生成的目标文件外加库链接为一个可执行文件</li><li>GNU Linker 采用 AT&amp;T 链接脚本语言</li></ul><h4 id="ld-命令"><a href="#ld-命令" class="headerlink" title="ld 命令"></a>ld 命令</h4><ul><li>aarch64-linux-gnu-ld</li><li>常用参数<ul><li>-T 指定链接脚本</li><li>-Map 输出一个符号表文件</li><li>-o 输出最终可执行二进制文件</li></ul></li></ul><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">. = 0x10000;</span><br><span class="line">.text : &#123;* (.text)&#125;</span><br><span class="line">. = 0x8000000</span><br><span class="line">.data : &#123;*(.data)&#125;</span><br><span class="line">.bss : &#123;*(.bss)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>输入段(input section)，输出段(output section)</li><li>每个段包括 name 和大小</li><li>段的属性<ul><li>loadable 运行时会加载这些段的内容到内存</li><li>allocatable 运行时不会加载段的内容</li></ul></li><li>段的地址<ul><li><strong>VMA</strong>(virtual memory address) 虚拟地址，运行时的地址</li><li><strong>LMA</strong>(load memory address) 加载地址</li><li><strong>通常 ROM 的地址为加载地址，而 RAM 的地址为 VMA</strong></li></ul></li></ul><h4 id="链接脚本命令"><a href="#链接脚本命令" class="headerlink" title="链接脚本命令"></a>链接脚本命令</h4><ul><li>ENTRY(symbol) 设置程序的入口函数</li><li><p>链接程序有如下几种方式来设置入口点：</p><ul><li>使用-e 参数</li><li>使用 ENTRY(symbol)</li><li>在.text 的最开始的地方</li><li>0 地址</li></ul></li><li><p>INCLUDE filename 引入 filename 链接脚本</p></li><li>OUTPUT filename 输出二进制文件，类似在命令行里使用“-o filename”</li><li>OUTPUT_FORMAT(bfd) 输出 BFD 格式</li><li>OUTPUT_ARCH(bfdarch) 输出处理器体系结构格式</li></ul><h4 id="符号赋值"><a href="#符号赋值" class="headerlink" title="符号赋值"></a>符号赋值</h4><ul><li>符号也可以像 C 语言一样赋值</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144008126.png" alt="符号也可以像C语言一样赋值"></p><ul><li>“.” 表示 location counter，表示当前位置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144044005.png" alt="&quot;.&quot;表示当前位置"></p><h4 id="符号的引用"><a href="#符号的引用" class="headerlink" title="符号的引用"></a>符号的引用</h4><ul><li>高级语言中常常需要引用链接脚本定义的符号</li><li><p>在 C 语言里，定义一个变量并初始化一个变量。例如 int foo = 100</p><ul><li>编译器会在符号表定义了一个符号 foo</li><li>编译器会在内存中为符号存储 100</li></ul></li><li><p>在链接脚本中定义一个变量</p><ul><li><strong>链接器仅仅在符号表里定义这个符号，没有分配内存来存储变量的值</strong></li></ul></li><li>访问链接脚本定义的变量：<strong>访问的时变量的地址，不能访问变量的值</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144340025.png" alt="链接器仅仅在符号表里定义这个符号，没有分配内存来存储变量的值"></p><ul><li>我们可以在每个段设置一些符号，以方便 C 语言访问每个段的起始地址和结束地址</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144449580.png" alt="设置段的起始地址和结束地址"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144531159.png" alt="Linux内核中的例子"></p><h4 id="SECTIONS-命令"><a href="#SECTIONS-命令" class="headerlink" title="SECTIONS 命令"></a>SECTIONS 命令</h4><ul><li>SECTIONS 命令：告诉链接器如何把输入段(input sections)映射到输出段(output sections)，以及如何在内存中摆放这些输出段</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144744861.png" alt="SECTIONS命令"></p><ul><li>输出 section 的描述符</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806144807073.png" alt="输出section的描述符"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806153841387.png" alt="输出section的描述符解释"></p><h4 id="LMA-加载地址"><a href="#LMA-加载地址" class="headerlink" title="LMA 加载地址"></a>LMA 加载地址</h4><ul><li>每个段都有<strong>VMA</strong>（虚拟地址，运行地址）以及<strong>LMA</strong>（加载地址）</li><li>在输出段描述符中<strong>使用”AT”来指定 LMA</strong></li><li><strong>如果没有通过”AT”来指定 LMA，通常 LMA=VMA</strong></li><li>构建<strong>一个基于 ROM 的映像文件常常会设置输出段的虚拟地址和加载地址不一致</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806154638115.png" alt="通过&quot;AT&quot;来指定LMA"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806154806423.png" alt="输出段的虚拟地址和加载地址不一致"></p><ul><li>data 段的加载地址和链接地址（虚拟地址）不一样，因此程序的初始化需要把 data 段从 ROM 的加载地址复制到 SDRAM 中的虚拟地址中</li><li>数据加载地址在_etext 起始的地方，数据段的运行地址是在_data 起始的地方，数据段的大小为“_edata-_data”,下面这段代码把数据段从_etext 起始的地方复制到_data 起始的地方</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806155249116.png" alt="把data段从ROM的加载地址复制到SDRAM的虚拟地址中"></p><h4 id="常见的内建函数"><a href="#常见的内建函数" class="headerlink" title="常见的内建函数"></a>常见的内建函数</h4><h5 id="ADDR-section"><a href="#ADDR-section" class="headerlink" title="ADDR(section)"></a>ADDR(section)</h5><blockquote><p>返回前面已经定义过的段的 VMA 地址</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806155401495.png" alt="ADDR(section)"></p><h5 id="ALIGN-n"><a href="#ALIGN-n" class="headerlink" title="ALIGN(n)"></a>ALIGN(n)</h5><blockquote><p>返回下一个与 n 字节对齐的地址，它是基于当前的位置(location counter)来计算对齐地址的</p><p>注意这里是 n 个字节，而不是 2^n 个字节（与汇编器的.align 区分）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806155545710.png" alt="ALIGN(n)"></p><h5 id="SIZEOF-section"><a href="#SIZEOF-section" class="headerlink" title="SIZEOF(section)"></a>SIZEOF(section)</h5><blockquote><p>返回一个段的大小</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806161245829.png" alt="SIZEOF(section)"></p><h5 id="MAX-exp1-exp2-MIN-exp1-exp2"><a href="#MAX-exp1-exp2-MIN-exp1-exp2" class="headerlink" title="MAX(exp1, exp2) / MIN(exp1, exp2)"></a>MAX(exp1, exp2) / MIN(exp1, exp2)</h5><blockquote><p>返回两个表达式的最大值或最小值</p></blockquote><h4 id="实验-1：打印每个段的内存布局"><a href="#实验-1：打印每个段的内存布局" class="headerlink" title="实验 1：打印每个段的内存布局"></a>实验 1：打印每个段的内存布局</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806161417469.png" alt="实验一"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806162136414.png" alt="输出结果"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806224541291.png" alt="C语言中的定义以获取链接脚本的定义的地址"></p><ol><li><strong>链接器导出的符号是地址，不是变量值</strong></li></ol><p>链接脚本中的这些符号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_text = .;</span><br></pre></td></tr></table></figure><p>定义的不是变量本身，而是一个 地址标签（symbol address）。在 C 中没有对应“地址标签”的语法，因此只能通过某种“变量”来间接引用这个地址。</p><p>用 char[] 声明它，其实是在说：</p><blockquote><p>“这是一段起始于 _text 的内存区域，我关心的是它的地址，而不是它的具体内容。”</p></blockquote><ol><li><p><strong>char[] 是一种“单位最小”的内存表示，方便做指针运算</strong></p><p>char 是 C 中最小的可寻址单位（1 字节）。</p><p>所以用 char[] 类型，我们就可以直接进行精确的地址操作：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _text[], _etext[];</span><br><span class="line"><span class="type">size_t</span> text_size = _etext - _text;  <span class="comment">// 计算段长度（字节）</span></span><br></pre></td></tr></table></figure><p>如果你写成 int[] 或 void*，这个计算就可能出错，或者无法编译。</p><ol><li>char[] vs char* 的差异：<strong>链接器符号是“数组地址”而非指针变量</strong></li></ol><p>虽然你也可以写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *_text;</span><br></pre></td></tr></table></figure><p>但这其实意味着 _text 是一个“指向字符的变量”，而不是一个地址标签。</p><blockquote><p>char *_text; 说明编译器要去“取变量 _text 的值”，它必须由代码赋值。<br>而 char _text[]; 是“声明链接器会提供这个地址”，不会生成额外符号或变量。</p></blockquote><p>所以推荐使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _text[];</span><br></pre></td></tr></table></figure><h4 id="实验-2：加载地址不等于运行地址"><a href="#实验-2：加载地址不等于运行地址" class="headerlink" title="实验 2：加载地址不等于运行地址"></a>实验 2：加载地址不等于运行地址</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806161556892.png" alt="实验2"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807221445041.png" alt="链接脚本"></p><p>需要把代码从装载地址拷贝到运行地址</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807221516225.png" alt="把代码从装载地址拷贝到运行地址"></p><h4 id="实验-3：分析-Linux5-0-内核的链接脚本"><a href="#实验-3：分析-Linux5-0-内核的链接脚本" class="headerlink" title="实验 3：分析 Linux5.0 内核的链接脚本"></a>实验 3：分析 Linux5.0 内核的链接脚本</h4><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250806161726598.png" alt="实验3"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807221613565.png" alt="vmlinux.lds.S总体框架"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250807221621624.png" alt="链接文件内容"></p><h4 id="运行地址，装载地址，链接地址"><a href="#运行地址，装载地址，链接地址" class="headerlink" title="运行地址，装载地址，链接地址"></a>运行地址，装载地址，链接地址</h4><h5 id="链接地址（Link-Address）"><a href="#链接地址（Link-Address）" class="headerlink" title="链接地址（Link Address）"></a>链接地址（Link Address）</h5><p>定义：</p><blockquote><p>编译器和链接器在生成可执行文件（如 ELF 文件）时，为各段（如 .text, .data, .bss 等）分配的地址。</p></blockquote><p>特征：</p><ul><li>是编译阶段由 链接器设定的地址。</li><li>可以通过链接脚本 (ld script) 显式设置，比如 . = 0x80000;。</li><li>可执行文件中的节表（section headers）或段表（program headers）中就记录了这些地址。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text : &#123; *(.text) &#125; &gt; 0x80000</span><br></pre></td></tr></table></figure><p>表示 .text 段的 链接地址是 0x80000。</p><h5 id="装载地址（Load-Address）"><a href="#装载地址（Load-Address）" class="headerlink" title="装载地址（Load Address）"></a>装载地址（Load Address）</h5><p>定义：</p><blockquote><p>可执行文件中的内容被加载到内存中的位置，也就是 操作系统/bootloader 将文件装入内存的位置。</p></blockquote><p>特征：</p><ul><li>通常等于链接地址，但在某些情况下（如动态链接、加载地址重定位）可以不同。</li><li>由 操作系统或 bootloader 决定，也可以通过 objcopy 等工具进行重新定位。</li></ul><p>例子：</p><ul><li>你的 ELF 文件 .text 段链接地址是 0x80000，bootloader 将它加载到 0x100000，那么：<ul><li>链接地址 ≠ 装载地址</li><li>如果没有做重定位，程序运行会出错（因为代码中有绝对地址）</li></ul></li></ul><h5 id="运行地址（Runtime-Execution-Address）"><a href="#运行地址（Runtime-Execution-Address）" class="headerlink" title="运行地址（Runtime/Execution Address）"></a>运行地址（Runtime/Execution Address）</h5><p>定义：</p><blockquote><p>程序在执行时，CPU 实际访问的内存地址。</p></blockquote><p>特征：</p><ul><li><p>通常 = 装载地址（程序加载到哪里就从哪里执行）</p></li><li><p>如果启用了 MMU（内存管理单元），运行地址是虚拟地址，由 MMU 映射到物理装载地址。</p></li><li><p>在裸机程序中，一般 = 链接地址 = 装载地址 = 运行地址。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU AS</title>
      <link href="/posts/50000/"/>
      <url>/posts/50000/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>参考文档：</p><div class="tag link"><a class="link-card" title="gas" href="https://sourceware.org/binutils/docs/as.pdf"><div class="left"><img src="https://sourceware.org/favicon.ico"/></div><div class="right"><p class="text">gas</p><p class="url">https://sourceware.org/binutils/docs/as.pdf</p></div></a></div><p>ARM64 的汇编器</p><ul><li>ARM 公司的官方的汇编器</li><li>GNU AS 汇编器：aarch64-linux-gnu-as</li><li>gcc 采用 as 作为其汇编器，所以汇编代码是 AT&amp;T 的<ul><li>AT&amp;T：源自贝尔实验室，为开发 UNIX 系统而产生的汇编语法</li><li>ARM 格式：arm 官方汇编语法</li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>label: <strong>任何以冒号结尾的标识符都被认为是一个标号</strong></li><li><strong>注释</strong>：<ul><li>// 表示注释</li><li># 在一行的开始，表示注释整行</li></ul></li><li>指令，伪指令，寄存器可以全部都是大写或者小写，GNU 风格默认小写</li></ul><h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><blockquote><p>代表它所在的地址，也可以当作变量或者函数来使用</p></blockquote><ul><li>全局 symbol, 可以用.global 来声明</li><li>局部 symbol，主要在局部范围内使用，开头以 0-99 直接的数字为标号名，通常和 b 指令结合使用</li><li>f: 指示编译向前搜索</li><li>b:指示编译器向后搜索</li></ul><h4 id="对齐伪指令"><a href="#对齐伪指令" class="headerlink" title="对齐伪指令"></a>对齐伪指令</h4><ul><li>.align 对齐，填充数据来实现对齐。可以填充 0 或者使用 nop 指令。<ul><li>告诉汇编程序,align 后面的汇编必须从下一个能被 2^n 整除的地址开始分配</li><li>ARM64 系统中，第一个参数表示 2^n 大小</li></ul></li></ul><h4 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h4><h5 id="整数与浮点伪指令汇总"><a href="#整数与浮点伪指令汇总" class="headerlink" title="整数与浮点伪指令汇总"></a>整数与浮点伪指令汇总</h5><div class="table-container"><table><thead><tr><th>指令</th><th>数据类型/作用</th><th>字节数</th><th>补充说明</th></tr></thead><tbody><tr><td><code>.byte</code></td><td>定义 8 位整数</td><td>1 B</td><td>通常用于字符、控制位</td></tr><tr><td><code>.hword</code></td><td>定义 16 位整数（half-word）</td><td>2 B</td><td>某些架构中也叫<code>.short</code></td></tr><tr><td><code>.int</code>/<code>.long</code></td><td>定义 32 位整数</td><td>4 B</td><td><code>.int</code> 是别名，效果一样</td></tr><tr><td><code>.quad</code></td><td>定义 64 位整数（quad-word）</td><td>8 B</td><td>在 AArch64 中非常常用</td></tr><tr><td><code>.float</code></td><td>定义 IEEE-754 单精度浮点数（32 位）</td><td>4 B</td><td>等价于 C 语言中的 <code>float</code></td></tr></tbody></table></div><h5 id="字符串定义伪指令"><a href="#字符串定义伪指令" class="headerlink" title="字符串定义伪指令"></a>字符串定义伪指令</h5><div class="table-container"><table><thead><tr><th>指令</th><th>功能说明</th></tr></thead><tbody><tr><td><code>.ascii &quot;str&quot;</code></td><td>将字符串原样插入，不自动添加 <code>\0</code>，适用于非 C 风格字符串</td></tr><tr><td><code>.asciz &quot;str&quot;</code></td><td>在字符串末尾<strong>自动追加一个空字符 <code>\0</code></strong>，适用于 C 字符串（推荐）</td></tr></tbody></table></div><h5 id="rept-…-endr：重复块定义"><a href="#rept-…-endr：重复块定义" class="headerlink" title=".rept … .endr：重复块定义"></a>.rept … .endr：重复块定义</h5><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rept &lt;count&gt;</span><br><span class="line">  &lt;内容&gt;</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure><p>作用：重复某段汇编代码或数据定义若干次，适用于初始化数组或填充空间。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rept 3</span><br><span class="line">    .long 0</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.long 0</span><br><span class="line">.long 0</span><br><span class="line">.long 0</span><br></pre></td></tr></table></figure><h5 id="equ-set：常量定义（赋值操作）"><a href="#equ-set：常量定义（赋值操作）" class="headerlink" title=".equ / .set：常量定义（赋值操作）"></a>.equ / .set：常量定义（赋值操作）</h5><p>这两个指令完全等价，只是语法风格略不同。<br>.equ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.equ abcd, 0x45</span><br></pre></td></tr></table></figure><p>让 abcd 成为 常量宏定义，值为 0x45。<br>.set</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.set abcd, 0x45</span><br></pre></td></tr></table></figure><p>同样效果，也定义 abcd 为 0x45。</p><p>典型用途：用于定义寄存器地址、常量位掩码等。<br>常见用法示例（结合 .equ 与 .rept）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.equ LED_BASE, 0x3F200000</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">.rept 4</span><br><span class="line">    .int LED_BASE</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure><p>表示将 LED_BASE 这个地址填充 4 次，每次 4 字节，共 16 字节。</p><p><code>.equ</code> 与 C 的 <code>#define</code> 区别：</p><div class="table-container"><table><thead><tr><th><code>.equ</code> / <code>.set</code></th><th><code>#define</code></th></tr></thead><tbody><tr><td>汇编阶段赋值，数值不可变</td><td>预处理阶段文本替换</td></tr><tr><td>可用于表达式（如 <code>.equ val, 4+5</code>）</td><td>只做文本拼接</td></tr><tr><td>不可用于条件编译</td><td>可与 <code>#ifdef</code> 等配合使用</td></tr></tbody></table></div><h5 id="函数相关的伪指令"><a href="#函数相关的伪指令" class="headerlink" title="函数相关的伪指令"></a>函数相关的伪指令</h5><div class="table-container"><table><thead><tr><th>伪操作</th><th>作用说明</th></tr></thead><tbody><tr><td><code>.global</code></td><td>定义一个全局的符号</td></tr><tr><td><code>.include</code></td><td>引用头文件</td></tr><tr><td><code>.if .else .endif</code></td><td>控制语句结构，用于条件编译</td></tr></tbody></table></div><h5 id="if-语句伪操作"><a href="#if-语句伪操作" class="headerlink" title="if 语句伪操作"></a>if 语句伪操作</h5><div class="table-container"><table><thead><tr><th>指令</th><th>含义说明</th></tr></thead><tbody><tr><td><code>.ifdef symbol</code></td><td>判断 <code>symbol</code> 是否已定义</td></tr><tr><td><code>.ifndef symbol</code></td><td>判断 <code>symbol</code> 是否<strong>未</strong>定义</td></tr><tr><td><code>.ifc str1,str2</code></td><td>判断字符串 <code>str1</code> 与 <code>str2</code> 是否相等</td></tr><tr><td><code>.ifeq expr</code></td><td>判断表达式 <code>expr</code> 的值是否为 0</td></tr><tr><td><code>.ifeqs str1,str2</code></td><td>等价于 <code>.ifc str1,str2</code></td></tr><tr><td><code>.ifge expr</code></td><td>判断表达式 <code>expr</code> 的值是否 ≥ 0</td></tr><tr><td><code>.ifle expr</code></td><td>判断表达式 <code>expr</code> 的值是否 ≤ 0</td></tr><tr><td><code>.ifne expr</code></td><td>判断表达式 <code>expr</code> 的值是否 ≠ 0</td></tr></tbody></table></div><h5 id="与段相关的伪操作"><a href="#与段相关的伪操作" class="headerlink" title="与段相关的伪操作"></a>与段相关的伪操作</h5><ul><li>.section 表示接下来的汇编会链接到哪个段里，例如代码段，数据段等</li><li>每一个段以段名为开始，以下一个段名或者文件尾为结束</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section name, &quot;flags&quot;</span><br></pre></td></tr></table></figure><p>后面可以添加 flags，表示段的属性</p><div class="table-container"><table><thead><tr><th>标志</th><th>含义说明</th></tr></thead><tbody><tr><td><code>a</code></td><td><strong>allocatable</strong>：该段在运行时需要被加载到内存中。</td></tr><tr><td><code>d</code></td><td><strong>GNU_MBIND section</strong>：GNU 使用的特殊绑定段。</td></tr><tr><td><code>e</code></td><td><strong>excluded</strong>：该段不会被包含在可执行文件或共享库中。</td></tr><tr><td><code>w</code></td><td><strong>writable</strong>：该段可写。</td></tr><tr><td><code>x</code></td><td><strong>executable</strong>：该段包含可执行代码。</td></tr><tr><td><code>M</code></td><td><strong>mergeable</strong>：可以和其他具有相同属性的段合并（通常用于只读字符串等）。</td></tr><tr><td><code>S</code></td><td><strong>string</strong>：该段包含以 0 结尾的字符串。</td></tr><tr><td><code>G</code></td><td><strong>group</strong>：该段属于某个 section group（如 COMDAT）。</td></tr><tr><td><code>T</code></td><td><strong>thread-local-storage</strong>：该段用于线程局部存储（TLS）。</td></tr><tr><td><code>?</code></td><td><strong>unspecified group</strong>：该段属于前一个 section 的 group（如果有的话）。</td></tr></tbody></table></div><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.section &quot;.idmap.text&quot;,&quot;awx&quot;</span><br></pre></td></tr></table></figure><p><code>.pushsection &lt;name&gt;</code><br>将接下来的代码或数据<strong>插入到指定的 section（段）中</strong>，同时<strong>保存当前 section 状态</strong>。</p><p><code>.popsection</code><br>表示<strong>结束前面的 push</strong>，并<strong>恢复原来的 section</strong>。</p><ul><li><p><strong>成对使用</strong>。</p></li><li><p>作用仅在 <code>pushsection</code> 和 <code>popsection</code> 之间的代码，对其他代码没有影响。</p></li><li><p>其余代码仍然属于原先的段，比如 <code>.text</code> 或 <code>.data</code>。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    .text</span><br><span class="line">    .globl _start</span><br><span class="line">_start:</span><br><span class="line">    nop             // 在默认的 .text 段中</span><br><span class="line"></span><br><span class="line">    .pushsection .mydata, &quot;a&quot;</span><br><span class="line">    .long 0x12345678  // 被插入到 .mydata 段中</span><br><span class="line">    .popsection</span><br><span class="line"></span><br><span class="line">    nop             // 又回到 .text 段</span><br></pre></td></tr></table></figure><p><code>_start</code> 和两个 <code>nop</code> 都属于 <code>.text</code> 段；</p><p><code>.long 0x12345678</code> 被插入到了自定义的 <code>.mydata</code> 段中。</p><h5 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h5><ul><li>.macro 和.endm 组成一个宏</li><li>.macro 后面跟着的是宏的名称，在后面是宏的参数</li><li>在宏里使用参数，需要添加前缀“\”</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.macro plus1 p, p1</span><br></pre></td></tr></table></figure><blockquote><p>定义了一个名为 plus1 的宏，有两个参数 p 和 p1</p><p>在宏里使用参数需要前缀,”\p”表示第一个参数,”\p1”属于第二个参数</p></blockquote><ul><li>宏参数定义的时候可以设置一个初始化值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.macro reserve_str p1=0 p2</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数 p1 有一个初始化的值，0。这个时候可以使用 reserve_str a,b 或者 reserve_str, b 来调用这个宏</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250805162753780.png" alt="在宏里使用参数可能出现的问题"></p><p>解决办法：</p><ul><li>使用空格或者使用 altmacro+&amp;</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250805162907493.png" alt="使用空格或者使用altmacro+&amp;"></p><ul><li>使用”\()“表示连接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250805163001419.png" alt="使用&quot;()&quot;表示连接"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250805163128544.png" alt="linux内核使用&quot;()&quot;的例子"></p><h4 id="ARM64-特有的特性"><a href="#ARM64-特有的特性" class="headerlink" title="ARM64 特有的特性"></a>ARM64 特有的特性</h4><h5 id="ARM64-编译选项"><a href="#ARM64-编译选项" class="headerlink" title="ARM64 编译选项"></a>ARM64 编译选项</h5><ul><li>-EB：用于大端模式的 CPU，-EL：用于小端模式的 CPU</li><li>-mabi：指定 ABI 模式，ilp32 用于 ELF32，lp64 用于 ELF64，默认值为 lp64</li><li>-mcpu=processor+extension：指定 CPU 型号，例如 cortex-a72</li><li>-march=，用于指定支持的架构，例如 armv8.2-a</li><li>ARM64 支持的 extension，见 GNU 汇编器 as_v2.34 9.1.2 章</li></ul><h5 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h5><ul><li>//表示注释</li><li>#若在一行开始表示注释，不在一行开始也可表示立即数</li><li>:low12 表示低 12 位</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp x0, foo</span><br><span class="line">ldr x0, [x0, #:lo12:foo]</span><br></pre></td></tr></table></figure><ul><li>ldr 伪操作</li><li>.bss 切换到 bss 段</li><li>.dword/.xword 64 位数据</li><li>name .reg register_name 为寄存器命名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo .req w0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经典150题 P88 合并两个有序数组</title>
      <link href="/posts/88/"/>
      <url>/posts/88/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P88 合并两个有序数组" href="https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P88 合并两个有序数组</p><p class="url">https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150</p></div></a></div></p><p>这题其实可以原地合并，因为 num1 后 n 个元素为 0，可以从后往前合并。但下面的代码未考虑到这点。<br>注意 std::move，它其实是将参数 t 转换为一个右值引用类型，不会拷贝内存，不会释放资源，不会调用构造函数和析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 std::vector<int> 为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; b = std::<span class="built_in">move</span>(a);</span><br></pre></td></tr></table></figure><p>这里：std::move(a) 把 a 变成右值引用。编译器会选择 vector 的移动构造函数，而不是拷贝构造。<br>移动构造函数做的事：</p><ul><li>把 a 的内部指针直接“偷走”，交给 b。</li><li>把 a 的指针设为空，避免析构时释放同一块内存。</li></ul><p>所以最后：b 持有 {1,2,3} 的数据。a 变成空的（size()==0，但仍然是合法对象）</p><p>总结：<br>nums1 = std::move(vec);</p><ul><li>旧内容自动释放（移动赋值内部完成）</li><li>新内容接管</li><li>vec 变空<br>不需要自己手动调用析构函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &lt;= nums2[j])</span><br><span class="line">          vec.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          vec.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; m &amp;&amp; j &gt;= n) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums1 = std::<span class="built_in">move</span>(vec);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 排序 </tag>
            
            <tag> leetcode面试经典150题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P812 最大三角形面积</title>
      <link href="/posts/812/"/>
      <url>/posts/812/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-27</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P812 最大三角形面积" href="https://leetcode.cn/problems/largest-triangle-area/?envType=daily-question&envId=2025-09-27"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P812 最大三角形面积</p><p class="url">https://leetcode.cn/problems/largest-triangle-area/?envType=daily-question&envId=2025-09-27</p></div></a></div></p><p>此题不用考虑太多，主要是考察几何知识，直接枚举即可。<br>三角形计算面积为：</p><script type="math/tex; mode=display">S = \frac{1}{2} \left| x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) \right|</script><p>假设这三个点，第一个点 i 在 points 数组左边，第二个点的数组位置位于两点之间，第三个点在右边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">largestTriangleArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;points)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> x1, x2, x3;</span><br><span class="line">    <span class="type">int</span> y1, y2, y3;</span><br><span class="line">    <span class="type">double</span> max_area = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> area;</span><br><span class="line"></span><br><span class="line">    n = points.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">          x1 = points[i][<span class="number">0</span>];</span><br><span class="line">          x2 = points[j][<span class="number">0</span>];</span><br><span class="line">          x3 = points[k][<span class="number">0</span>];</span><br><span class="line">          y1 = points[i][<span class="number">1</span>];</span><br><span class="line">          y2 = points[j][<span class="number">1</span>];</span><br><span class="line">          y3 = points[k][<span class="number">1</span>];</span><br><span class="line">          area =</span><br><span class="line">              <span class="number">0.5</span> * std::<span class="built_in">fabs</span>(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));</span><br><span class="line">          <span class="keyword">if</span> (area &gt; max_area) &#123;</span><br><span class="line">            max_area = area;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_area;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 穷举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P611 有效三角形的个数</title>
      <link href="/posts/611/"/>
      <url>/posts/611/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-26</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P611 有效三角形的个数" href="https://leetcode.cn/problems/valid-triangle-number/description/?envType=daily-question&envId=2025-09-26"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P611 有效三角形的个数</p><p class="url">https://leetcode.cn/problems/valid-triangle-number/description/?envType=daily-question&envId=2025-09-26</p></div></a></div></p><p>此题固定套路是先固定最大的边，然后通过双指针一个从前向后(表示最小边)，一个从后向前(表示次大边)，如果前面那个指针指向的值和后面那个指针指向的值加起来满足了三角形构成条件，那么最小边可以取两个指针之间的任意值，然后可以令次大的边变小些，看是否满足。如果不满足，说明最小的边太小了，让最小的边变大些，因为是最小边，所以其值不能大于次大边。两个指针相遇时，说明已经遍历完了最大边是当前固定的最大边时的情况，此时令最大边小些，然后最小边和次大边重新开始遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数</span></span><br><span class="line">  <span class="comment">// 1 &lt;= nums.length &lt;= 1000</span></span><br><span class="line">  <span class="comment">// 0 &lt;= nums[i] &lt;= 1000</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">triangleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三角形两边之和大于第三边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(nums)</span></span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 去重,去重前需要先排序</span></span><br><span class="line">    <span class="comment">// vec.erase(std::unique(vec.begin(), vec.end()), vec.end());</span></span><br><span class="line"></span><br><span class="line">    n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 先固定最大边,k为三角形中最大的边,其次是j,i是最小的</span></span><br><span class="line">    <span class="keyword">for</span> (k = n - <span class="number">1</span>; k &gt;= <span class="number">2</span>; k--) &#123;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      j = k - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] &gt; nums[k]) &#123;</span><br><span class="line">          <span class="comment">// 因为j是从k-1向前遍历,i从0向后遍历</span></span><br><span class="line">          <span class="comment">// 所以如果 nums[i] + nums[j] &gt; nums[k]</span></span><br><span class="line">          <span class="comment">// 所有 [i,j-1] 都和 j, k 可以组成三角形</span></span><br><span class="line">          res += (j - i);</span><br><span class="line">          --j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不满足三角形构成条件说明i太小了</span></span><br><span class="line">          <span class="comment">// 令i++,直到i==j时退出循环</span></span><br><span class="line">          <span class="comment">// 因为此时k和j固定,任何一个i都无法满足三角形构成条件</span></span><br><span class="line">          <span class="comment">// 说明k太大了,令k--</span></span><br><span class="line">          i++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P120 三角形最小路径和</title>
      <link href="/posts/120/"/>
      <url>/posts/120/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-25</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P120 三角形最小路径和" href="https://leetcode.cn/problems/triangle/description/?envType=daily-question&envId=2025-09-25"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P120 三角形最小路径和</p><p class="url">https://leetcode.cn/problems/triangle/description/?envType=daily-question&envId=2025-09-25</p></div></a></div></p><p>假设 dp[i][j] 表示从第 i+1 行第 j+1 列出来的路径和最小值</p><ul><li>当 j!=0 &amp;&amp; j!=i 时<script type="math/tex; mode=display">  dp[i][j] = min(dp[i-1][j-1] + dp[i-1][j]) + triangle[i][j]</script></li><li>当 j==0 时<script type="math/tex; mode=display">dp[i][j] = dp[i-1][0] + triangle[i][j]</script></li><li>当 j==i 时<script type="math/tex; mode=display">dp[i][j] = dp[i-1][j-1] + triangle[i][j]</script>实际这题 dp 用一维数组存就够用了，每一层计算过后就不再需要，可以覆盖上一层。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">minimumTotal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;triangle)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = triangle.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> min = INT_MAX;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="comment">// dp[i][j] 表示从第i+1行第j+1列出来的最小值</span></span><br><span class="line">    <span class="comment">// 当j!=0 &amp;&amp; j!=i时</span></span><br><span class="line">    <span class="comment">// dp[i][j] = min &#123;dp[i-1][j-1] + dp[i-1][j]&#125; + triangle[i][j]</span></span><br><span class="line">    <span class="comment">// 当j==0 时 dp[i][j] = dp[i-1][0] + triangle[i][j]</span></span><br><span class="line">    <span class="comment">// 当j==i 时 dp[i][j] = dp[i-1][j-1] + triangle[i][j]</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 从第二行开始，也就是i==1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i) &#123;</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle[i][j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dp[i][j] = std::<span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dp[n - <span class="number">1</span>][j] &lt; min) &#123;</span><br><span class="line">        min = dp[n - <span class="number">1</span>][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P166 分数到小数</title>
      <link href="/posts/166/"/>
      <url>/posts/166/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P166 分数到小数" href="https://leetcode.cn/problems/fraction-to-recurring-decimal/description/?envType=daily-question&envId=2025-09-26"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P166 分数到小数</p><p class="url">https://leetcode.cn/problems/fraction-to-recurring-decimal/description/?envType=daily-question&envId=2025-09-26</p></div></a></div></p><p>我采用模拟的方法，拼尽全力终于战胜，特殊情况太多了，最好是用 gdb 一次次调试发现代码中没有考虑到的地方再完善。<br>注意不要先除以最大公因数，因为最大公因数的计算时间复杂度要高于长除法。<br>此外最好先计算整数部分，再计算小数部分，我的这个解法没有考虑这个导致代码有点复杂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> dividend;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> divisor;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> quotient;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> reminder;</span><br><span class="line">    <span class="type">int</span> dot = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> bracket = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 记录结果</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res_vec;</span><br><span class="line">    <span class="comment">// 记录numerator的每一位</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numerator_vec;</span><br><span class="line">    <span class="comment">// 记录所有被除数</span></span><br><span class="line">    unordered_map&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; div_map;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0除以任何数都为0</span></span><br><span class="line">    <span class="keyword">if</span> (numerator == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((numerator &lt; <span class="number">0</span> &amp;&amp; denominator &gt; <span class="number">0</span>) ||</span><br><span class="line">        (numerator &gt; <span class="number">0</span> &amp;&amp; denominator &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">      negative = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不用abs主要是因为abs返回的是unsigned int存在范围问题</span></span><br><span class="line">    dividend = std::<span class="built_in">llabs</span>((<span class="type">long</span> <span class="type">long</span>)numerator);</span><br><span class="line">    divisor = std::<span class="built_in">llabs</span>((<span class="type">long</span> <span class="type">long</span>)denominator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先都除以最大公因数</span></span><br><span class="line">    <span class="comment">// n = std::gcd(dividend, divisor);</span></span><br><span class="line">    <span class="comment">// dividend /= n;</span></span><br><span class="line">    <span class="comment">// divisor /= n;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将numerator每一位放入numerator_vec中</span></span><br><span class="line">    <span class="keyword">while</span> (dividend != <span class="number">0</span>) &#123;</span><br><span class="line">      numerator_vec.<span class="built_in">insert</span>(numerator_vec.<span class="built_in">begin</span>(), dividend % <span class="number">10</span>);</span><br><span class="line">      dividend /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dividend = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 高精度除法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个被除数</span></span><br><span class="line">    n = numerator_vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; dividend &lt; divisor) &#123;</span><br><span class="line">      dividend = dividend * <span class="number">10</span> + numerator_vec[i];</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 记录被除数</span></span><br><span class="line">      <span class="keyword">if</span> (div_map.<span class="built_in">find</span>(dividend) != div_map.<span class="built_in">end</span>() &amp;&amp; dot &gt; <span class="number">0</span>) &#123; <span class="comment">// 重复了</span></span><br><span class="line">        bracket = div_map[dividend];                            <span class="comment">// 重复的位置</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        div_map[dividend] = res_vec.<span class="built_in">size</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 商 = 被除数/除数</span></span><br><span class="line">      quotient = dividend / divisor;</span><br><span class="line">      <span class="comment">// 余数 = 被除数/除数</span></span><br><span class="line">      reminder = dividend % divisor;</span><br><span class="line">      res_vec.<span class="built_in">push_back</span>(quotient);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &lt; numerator_vec.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        dividend = reminder * <span class="number">10</span> + numerator_vec[i];</span><br><span class="line">        i++;</span><br><span class="line">        reminder = <span class="number">1</span>; <span class="comment">// 防止退出循环</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dividend = reminder * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (dot &lt; <span class="number">0</span>)</span><br><span class="line">          dot = res_vec.<span class="built_in">size</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (reminder != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bracket &gt;= <span class="number">0</span> &amp;&amp; dot &gt; <span class="number">0</span> &amp;&amp; bracket &lt; dot) &#123;</span><br><span class="line">      n = dot - bracket;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res_vec.<span class="built_in">push_back</span>(res_vec[i + bracket]);</span><br><span class="line">      &#125;</span><br><span class="line">      bracket = dot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = res_vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 构建字符串</span></span><br><span class="line">    <span class="keyword">if</span> (negative) &#123;</span><br><span class="line">      res += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == dot) &#123;</span><br><span class="line">        res += <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (i == bracket) &#123;</span><br><span class="line">        res += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      res += <span class="string">&#x27;0&#x27;</span> + res_vec[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bracket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      res += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution s;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">420</span>, <span class="number">226</span>).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">-22</span>, <span class="number">-2</span>).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">500</span>, <span class="number">10</span>).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">4</span>, <span class="number">333</span>).<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.<span class="built_in">fractionToDecimal</span>(<span class="number">50</span>, <span class="number">8</span>).<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>官方方法也是模拟长除法，但不同的是我是记录了被除数，这个解法记录的是余数从而判断是否产生了循环小数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> numeratorLong = numerator;</span><br><span class="line">        <span class="type">long</span> denominatorLong = denominator;</span><br><span class="line">        <span class="keyword">if</span> (numeratorLong % denominatorLong == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">to_string</span>(numeratorLong / denominatorLong);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">if</span> (numeratorLong &lt; <span class="number">0</span> ^ denominatorLong &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整数部分</span></span><br><span class="line">        numeratorLong = <span class="built_in">abs</span>(numeratorLong);</span><br><span class="line">        denominatorLong = <span class="built_in">abs</span>(denominatorLong);</span><br><span class="line">        <span class="type">long</span> integerPart = numeratorLong / denominatorLong;</span><br><span class="line">        ans += <span class="built_in">to_string</span>(integerPart);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小数部分</span></span><br><span class="line">        string fractionPart;</span><br><span class="line">        unordered_map&lt;<span class="type">long</span>, <span class="type">int</span>&gt; remainderIndexMap;</span><br><span class="line">        <span class="type">long</span> remainder = numeratorLong % denominatorLong;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span> &amp;&amp; !remainderIndexMap.<span class="built_in">count</span>(remainder)) &#123;</span><br><span class="line">            remainderIndexMap[remainder] = index;</span><br><span class="line">            remainder *= <span class="number">10</span>;</span><br><span class="line">            fractionPart += <span class="built_in">to_string</span>(remainder / denominatorLong);</span><br><span class="line">            remainder %= denominatorLong;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123; <span class="comment">// 有循环节</span></span><br><span class="line">            <span class="type">int</span> insertIndex = remainderIndexMap[remainder];</span><br><span class="line">            fractionPart = fractionPart.<span class="built_in">substr</span>(<span class="number">0</span>,insertIndex) + <span class="string">&#x27;(&#x27;</span> + fractionPart.<span class="built_in">substr</span>(insertIndex);</span><br><span class="line">            fractionPart.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += fractionPart;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P165 比较版本号</title>
      <link href="/posts/165/"/>
      <url>/posts/165/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P165 比较版本号" href="https://leetcode.cn/problems/compare-version-numbers/description/?envType=daily-question&envId=2025-09-23"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P165 比较版本号</p><p class="url">https://leetcode.cn/problems/compare-version-numbers/description/?envType=daily-question&envId=2025-09-23</p></div></a></div><br>这题比较简单，不过还是注意下 stringstream 的用法吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string version1, string version2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="type">int</span> v1, v2;</span><br><span class="line">    <span class="type">int</span> revision_number;</span><br><span class="line">    string revision_number_str;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec1, vec2;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(version1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, revision_number_str, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        revision_number = std::<span class="built_in">stoi</span>(revision_number_str);</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception e) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;illegal input: %s\n&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      vec<span class="number">1.</span><span class="built_in">push_back</span>(revision_number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖缓冲区内容</span></span><br><span class="line">    ss.<span class="built_in">str</span>(version2);</span><br><span class="line">    <span class="comment">// 重置状态位</span></span><br><span class="line">    ss.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, revision_number_str, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        revision_number = std::<span class="built_in">stoi</span>(revision_number_str);</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::exception e) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Illegal input: %s\n&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      vec<span class="number">2.</span><span class="built_in">push_back</span>(revision_number);</span><br><span class="line">    &#125;</span><br><span class="line">    n = vec<span class="number">1.</span><span class="built_in">size</span>() &gt; vec<span class="number">2.</span><span class="built_in">size</span>() ? vec<span class="number">1.</span><span class="built_in">size</span>() : vec<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// 赋值</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; vec<span class="number">1.</span><span class="built_in">size</span>())</span><br><span class="line">        v1 = vec1[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; vec<span class="number">2.</span><span class="built_in">size</span>())</span><br><span class="line">        v2 = vec2[i];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (v1 &lt; v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v1 &gt; v2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3005 最大频率元素计数</title>
      <link href="/posts/3005/"/>
      <url>/posts/3005/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-22</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3005 最大频率元素计数" href="https://leetcode.cn/problems/count-elements-with-maximum-frequency/description/?envType=daily-question&envId=2025-09-22"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3005 最大频率元素计数</p><p class="url">https://leetcode.cn/problems/count-elements-with-maximum-frequency/description/?envType=daily-question&envId=2025-09-22</p></div></a></div></p><p>这题主要利用数组下标作为元素的标识，数组元素记录频率。<br>第一次遍历记录所有元素的频率，第二次遍历找到频率的最大值，第三次遍历将所有最大值频率的相加。总体复杂度 O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 1 &lt;= nums[i] &lt;= 100</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">maxFrequencyElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> max = INT_MIN;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> array[<span class="number">101</span>];</span><br><span class="line">    <span class="built_in">memset</span>(array, <span class="number">0</span>, <span class="number">101</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      array[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">        max = array[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] == max) &#123;</span><br><span class="line">        res += array[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P1912 设计电影租界系统</title>
      <link href="/posts/1912/"/>
      <url>/posts/1912/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-21</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="p1912 设计电影租界系统" href="https://leetcode.cn/problems/design-movie-rental-system/description/?envType=daily-question&envId=2025-09-21"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">p1912 设计电影租界系统</p><p class="url">https://leetcode.cn/problems/design-movie-rental-system/description/?envType=daily-question&envId=2025-09-21</p></div></a></div></p><p>题目给的 n 个商店没有用到，思路主要是用利用 set 的有序性，将排序时间放入到插入删除中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::set;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> shop;</span><br><span class="line">  <span class="type">int</span> movie;</span><br><span class="line">  <span class="type">int</span> price;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Movie &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (price != other.price)</span><br><span class="line">      <span class="keyword">return</span> price &lt; other.price;</span><br><span class="line">    <span class="keyword">if</span> (shop != other.shop)</span><br><span class="line">      <span class="keyword">return</span> shop &lt; other.shop;</span><br><span class="line">    <span class="keyword">return</span> movie &lt; other.movie;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MovieRentingSystem</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// map&lt;movies, map&lt;shop,price&gt;&gt; 存放全局数据data map</span></span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dmap;</span><br><span class="line">  <span class="comment">// map&lt;movie, set&lt;Movie&gt;&gt; 未借出的map</span></span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, set&lt;Movie&gt;&gt; umap;</span><br><span class="line">  <span class="comment">// set&lt;Movies&gt; 表示已经借出</span></span><br><span class="line">  set&lt;Movie&gt; rented;</span><br><span class="line">  <span class="comment">// set&lt;Movies&gt; 表示未借出</span></span><br><span class="line">  set&lt;Movie&gt; unrented;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> shop_num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// [shopi, moviei, pricei]</span></span><br><span class="line">  <span class="built_in">MovieRentingSystem</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;entries) &#123;</span><br><span class="line">    <span class="type">int</span> shop, movie, price;</span><br><span class="line">    shop_num = n;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; vec : entries) &#123;</span><br><span class="line">      shop = vec[<span class="number">0</span>];</span><br><span class="line">      movie = vec[<span class="number">1</span>];</span><br><span class="line">      price = vec[<span class="number">2</span>];</span><br><span class="line">      <span class="comment">// 全局数据</span></span><br><span class="line">      dmap[movie][shop] = price;</span><br><span class="line">      <span class="comment">// 未租赁的set</span></span><br><span class="line">      unrented.<span class="built_in">insert</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">      <span class="comment">// 未租赁的map</span></span><br><span class="line">      umap[movie].<span class="built_in">insert</span>(&#123;&#123;shop, movie, price&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到拥有指定电影且 未借出 的商店中 最便宜的 5 个</span></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">search</span><span class="params">(<span class="type">int</span> movie)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    set&lt;Movie&gt; &amp;tmp_set = umap[movie];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = tmp_set.<span class="built_in">begin</span>(); it != tmp_set.<span class="built_in">end</span>() &amp;&amp; cnt &lt; <span class="number">5</span>;</span><br><span class="line">         it++, cnt++) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(it-&gt;shop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从指定商店借出指定电影，题目保证指定电影在指定商店未借出</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rent</span><span class="params">(<span class="type">int</span> shop, <span class="type">int</span> movie)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> price = dmap[movie][shop];</span><br><span class="line">    rented.<span class="built_in">insert</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    unrented.<span class="built_in">erase</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    umap[movie].<span class="built_in">erase</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    <span class="keyword">if</span> (umap[movie].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      umap.<span class="built_in">erase</span>(movie);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在指定商店返还 之前已借出 的指定电影</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">drop</span><span class="params">(<span class="type">int</span> shop, <span class="type">int</span> movie)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> price = dmap[movie][shop];</span><br><span class="line">    unrented.<span class="built_in">insert</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    rented.<span class="built_in">erase</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">    umap[movie].<span class="built_in">insert</span>(&#123;shop, movie, price&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回 最便宜的 5 部已借出电影 （可能有重复的电影 ID）</span></span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">report</span>() &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = rented.<span class="built_in">begin</span>(); it != rented.<span class="built_in">end</span>() &amp;&amp; cnt &lt; <span class="number">5</span>; it++, cnt++) &#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">      vec.<span class="built_in">push_back</span>(it-&gt;shop);</span><br><span class="line">      vec.<span class="built_in">push_back</span>(it-&gt;movie);</span><br><span class="line">      res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovieRentingSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovieRentingSystem* obj = new MovieRentingSystem(n, entries);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;search(movie);</span></span><br><span class="line"><span class="comment"> * obj-&gt;rent(shop,movie);</span></span><br><span class="line"><span class="comment"> * obj-&gt;drop(shop,movie);</span></span><br><span class="line"><span class="comment"> * vector&lt;vector&lt;int&gt;&gt; param_4 = obj-&gt;report();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出辅助函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">vec_to_str</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    s += std::<span class="built_in">to_string</span>(v[i]);</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> != v.<span class="built_in">size</span>())</span><br><span class="line">      s += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">mat_to_str</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;m)</span> </span>&#123;</span><br><span class="line">  string s = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    s += <span class="built_in">vec_to_str</span>(m[i]);</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> != m.<span class="built_in">size</span>())</span><br><span class="line">      s += <span class="string">&quot;, &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; entries = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line">  vector&lt;string&gt; outputs;</span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="function">MovieRentingSystem <span class="title">obj</span><span class="params">(<span class="number">3</span>, entries)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// search(1)</span></span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="built_in">vec_to_str</span>(obj.<span class="built_in">search</span>(<span class="number">1</span>)));</span><br><span class="line">  <span class="comment">// rent(0,1)</span></span><br><span class="line">  obj.<span class="built_in">rent</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="comment">// rent(1,2)</span></span><br><span class="line">  obj.<span class="built_in">rent</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="comment">// report()</span></span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="built_in">mat_to_str</span>(obj.<span class="built_in">report</span>()));</span><br><span class="line">  <span class="comment">// drop(1,2)</span></span><br><span class="line">  obj.<span class="built_in">drop</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="comment">// search(2)</span></span><br><span class="line">  outputs.<span class="built_in">push_back</span>(<span class="built_in">vec_to_str</span>(obj.<span class="built_in">search</span>(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印最终结果</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; outputs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    cout &lt;&lt; outputs[i];</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> != outputs.<span class="built_in">size</span>())</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 设计题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3508 设计路由器</title>
      <link href="/posts/3508/"/>
      <url>/posts/3508/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-20</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3508 设计路由器" href="https://leetcode.cn/problems/implement-router/description/?envType=daily-question&envId=2025-09-20"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3508 设计路由器</p><p class="url">https://leetcode.cn/problems/implement-router/description/?envType=daily-question&envId=2025-09-20</p></div></a></div></p><p>这题很容易超时，主要是因为这个时间本来就是有序的，如果认为是无序的那么基本就超时了，比如用 multiset 存 timestamp 以求其有序，但实际上用简单的 vector 存就行。</p><p>注意 std::distance 这个函数，有的迭代器不支持减法只能用这个求其距离</p><p>注意 std::set 如果存入 class 或者 struct 那么得实现比较的 operator,因为 set 是有序的</p><ul><li>std::lower_bound<ul><li>作用: 返回第一个 大于等于 (&gt;=) 指定值的元素的迭代器。 - 如果值存在: 返回该值的第一个位置。 - 如果值不存在: 返回比目标值 大的第一个元素 位置。 - 如果所有元素都小于目标值: 返回 end() 迭代器。<blockquote><p>反向查找小于目标值的元素: std::lower_bound 返回的迭代器减一，即 std::lower_bound(vec.begin(), vec.end(), target) - 1。</p></blockquote></li></ul></li><li>std::upper_bound<ul><li>作用: 返回第一个 大于 (&gt;) 指定值的元素的迭代器。 - 如果值存在: 跳过所有相同值，返回比目标值 大的第一个元素 位置。 - 如果值不存在: 返回比目标值 大的第一个元素 位置。 - 如果所有元素都小于等于目标值: 返回 end() 迭代器。<blockquote><p>反向查找小于等于目标值的元素: std::upper_bound 返回的迭代器减一，即 std::upper_bound(vec.begin(), vec.end(), target) - 1。</p></blockquote></li></ul></li></ul><p>注意 写 operator&lt;时</p><ul><li>参数必须是 const Movie&amp;（不能接受非 const 引用）</li><li>函数本身必须是 const（不会修改 *this）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::map;</span><br><span class="line"><span class="keyword">using</span> std::queue;</span><br><span class="line"><span class="keyword">using</span> std::set;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Packet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> source;</span><br><span class="line">  <span class="type">int</span> destination;</span><br><span class="line">  <span class="type">int</span> timestamp;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Packet &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (destination != other.destination)</span><br><span class="line">      <span class="keyword">return</span> destination &lt; other.destination;</span><br><span class="line">    <span class="keyword">if</span> (timestamp != other.timestamp)</span><br><span class="line">      <span class="keyword">return</span> timestamp &lt; other.timestamp;</span><br><span class="line">    <span class="keyword">return</span> source &lt; other.source;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Router</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  set&lt;Packet&gt; router_set;</span><br><span class="line">  queue&lt;Packet&gt; fifo;</span><br><span class="line">  <span class="comment">// destination-&gt;[timestamp array]</span></span><br><span class="line">  map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; router_map;</span><br><span class="line">  <span class="type">int</span> memoryLimit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Router</span>(<span class="type">int</span> memoryLimit) &#123; <span class="keyword">this</span>-&gt;memoryLimit = memoryLimit; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">addPacket</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Packet</span> newPacket = &#123;source, destination, timestamp&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (router_set.<span class="built_in">find</span>(newPacket) != router_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (router_set.<span class="built_in">size</span>() &gt;= memoryLimit ||</span><br><span class="line">        fifo.<span class="built_in">size</span>() &gt;= memoryLimit) &#123; <span class="comment">// out of memory</span></span><br><span class="line">      Packet s = fifo.<span class="built_in">front</span>();</span><br><span class="line">      fifo.<span class="built_in">pop</span>();</span><br><span class="line">      router_set.<span class="built_in">erase</span>(s);</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; &amp;timestamp_array = router_map[s.destination];</span><br><span class="line">      timestamp_array.<span class="built_in">erase</span>(</span><br><span class="line">          <span class="built_in">find</span>(timestamp_array.<span class="built_in">begin</span>(), timestamp_array.<span class="built_in">end</span>(), s.timestamp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router_set.<span class="built_in">insert</span>(newPacket);</span><br><span class="line">    fifo.<span class="built_in">push</span>(newPacket);</span><br><span class="line"></span><br><span class="line">    router_map[destination].<span class="built_in">push_back</span>(timestamp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">forwardPacket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (fifo.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Packet resPacket = fifo.<span class="built_in">front</span>();</span><br><span class="line">    fifo.<span class="built_in">pop</span>();</span><br><span class="line">    res = &#123;resPacket.source, resPacket.destination, resPacket.timestamp&#125;;</span><br><span class="line">    router_set.<span class="built_in">erase</span>(resPacket);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; &amp;timestamp_array = router_map[resPacket.destination];</span><br><span class="line">    timestamp_array.<span class="built_in">erase</span>(<span class="built_in">find</span>(timestamp_array.<span class="built_in">begin</span>(), timestamp_array.<span class="built_in">end</span>(),</span><br><span class="line">                               resPacket.timestamp));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">(<span class="type">int</span> destination, <span class="type">int</span> startTime, <span class="type">int</span> endTime)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; &amp;vec = router_map[destination];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">distance</span>(std::<span class="built_in">lower_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), startTime),</span><br><span class="line">                         std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), endTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Router object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Router* obj = new Router(memoryLimit);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;addPacket(source,destination,timestamp);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;forwardPacket();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getCount(destination,startTime,endTime);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 设计题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 p3484 设计电子表格</title>
      <link href="/posts/3484/"/>
      <url>/posts/3484/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-19</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="p3484 设计电子表格" href="https://leetcode.cn/problems/design-spreadsheet/description/?envType=daily-question&envId=2025-09-19"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">p3484 设计电子表格</p><p class="url">https://leetcode.cn/problems/design-spreadsheet/description/?envType=daily-question&envId=2025-09-19</p></div></a></div></p><p>这题直接模拟是可以过的，用哈希表会更好，因为行列是唯一的可以作为键值，这样就免去很多字符串转 int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Spreadsheet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sheet;</span><br><span class="line">  <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">get_row_and_column</span><span class="params">(<span class="type">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> column = s[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      row = std::<span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="built_in">catch</span> (std::exception &amp;e) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    row = row - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;row, column&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Spreadsheet</span>(<span class="type">int</span> rows) &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    sheet.<span class="built_in">assign</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setCell</span><span class="params">(string cell, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [row, column] = <span class="built_in">get_row_and_column</span>(cell);</span><br><span class="line">    sheet[row][column] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">resetCell</span><span class="params">(string cell)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [row, column] = <span class="built_in">get_row_and_column</span>(cell);</span><br><span class="line">    sheet[row][column] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(string formula)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res_value = <span class="number">0</span>;</span><br><span class="line">    string formula_s = formula.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="function">std::stringstream <span class="title">ss</span><span class="params">(formula_s)</span></span>;</span><br><span class="line">    vector&lt;string&gt; values;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, token, <span class="string">&#x27;+&#x27;</span>)) &#123;</span><br><span class="line">      values.<span class="built_in">push_back</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> int_value;</span><br><span class="line">    <span class="keyword">for</span> (string value : values) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        int_value = std::<span class="built_in">stoi</span>(value);</span><br><span class="line">      &#125; <span class="built_in">catch</span> (std::invalid_argument) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [row, column] = <span class="built_in">get_row_and_column</span>(value);</span><br><span class="line">        int_value = sheet[row][column];</span><br><span class="line">      &#125;</span><br><span class="line">      res_value += int_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Spreadsheet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Spreadsheet* obj = new Spreadsheet(rows);</span></span><br><span class="line"><span class="comment"> * obj-&gt;setCell(cell,value);</span></span><br><span class="line"><span class="comment"> * obj-&gt;resetCell(cell);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getValue(formula);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// [&quot;Spreadsheet&quot;,&quot;getValue&quot;]</span></span><br><span class="line">  <span class="comment">// [[458],[&quot;=O126+10272&quot;]]</span></span><br><span class="line"></span><br><span class="line">  Spreadsheet *obj = <span class="keyword">new</span> <span class="built_in">Spreadsheet</span>(<span class="number">458</span>);</span><br><span class="line">  <span class="type">int</span> result = obj-&gt;<span class="built_in">getValue</span>(<span class="string">&quot;=O126+10272&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result is %d\n&quot;</span>, result);</span><br><span class="line">  <span class="keyword">delete</span> obj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 设计题 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3408 设计任务管理器</title>
      <link href="/posts/3408/"/>
      <url>/posts/3408/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-18</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3408 设计任务管理器" href="https://leetcode.cn/problems/design-task-manager/description/?envType=daily-question&envId=2025-09-18"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3408 设计任务管理器</p><p class="url">https://leetcode.cn/problems/design-task-manager/description/?envType=daily-question&envId=2025-09-18</p></div></a></div></p><h2 id="自定义最大堆，TLE"><a href="#自定义最大堆，TLE" class="headerlink" title="自定义最大堆，TLE"></a>自定义最大堆，TLE</h2><p>这题很自然想到用堆实现，但是要自定义实现堆，C++的 priority_queue 虽然也是堆，但是不提供修改元素的方法，使用受较大限制<br>但是下面的写法纯用堆 660/663 个通过，660 的测试用例 TLE 了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = std::less&lt;T&gt;&gt; <span class="keyword">class</span> Heap &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Heap</span>() &#123;&#125;</span><br><span class="line">  <span class="type">void</span> <span class="built_in">push</span>(T val) &#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(val);</span><br><span class="line">    <span class="built_in">shiftUp</span>(vec.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(vec[<span class="number">0</span>], vec.<span class="built_in">back</span>());</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">shiftDown</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> vec.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> vec.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shiftUp</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">cmp</span>(vec[<span class="built_in">parent</span>(index)], vec[index])) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// vec[index]返回的是元素的引用而不是拷贝</span></span><br><span class="line">      <span class="built_in">swap</span>(vec[<span class="built_in">parent</span>(index)], vec[index]);</span><br><span class="line">      index = <span class="built_in">parent</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">shiftDown</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = vec.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="type">size_t</span> left = <span class="built_in">left_child</span>(index);</span><br><span class="line">      <span class="type">size_t</span> right = <span class="built_in">right_child</span>(index);</span><br><span class="line">      <span class="type">size_t</span> largest = index;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (left &lt; n &amp;&amp; <span class="built_in">cmp</span>(vec[largest], vec[left]))</span><br><span class="line">        largest = left;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; n &amp;&amp; <span class="built_in">cmp</span>(vec[largest], vec[right]))</span><br><span class="line">        largest = right;</span><br><span class="line">      <span class="keyword">if</span> (largest == index)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">swap</span>(vec[index], vec[largest]);</span><br><span class="line">      index = largest;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">left_child</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">right_child</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * index + <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">parent</span><span class="params">(<span class="type">size_t</span> index)</span> </span>&#123; <span class="keyword">return</span> (index - <span class="number">1</span>) / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;T&gt; vec;</span><br><span class="line">  Compare cmp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskManager</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;tasks) &#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; task : tasks) &#123;</span><br><span class="line">      max_heap.<span class="built_in">push</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> taskId, <span class="type">int</span> priority)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(userId);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(taskId);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(priority);</span><br><span class="line">    <span class="comment">// 拷贝</span></span><br><span class="line">    max_heap.<span class="built_in">push</span>(vec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">edit</span><span class="params">(<span class="type">int</span> taskId, <span class="type">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> oldPriority;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_heap.vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (max_heap.vec[i][<span class="number">1</span>] == taskId) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        oldPriority = max_heap.vec[i][<span class="number">2</span>];</span><br><span class="line">        max_heap.vec[i][<span class="number">2</span>] = newPriority;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldPriority &lt; newPriority) &#123;</span><br><span class="line">      max_heap.<span class="built_in">shiftUp</span>(index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max_heap.<span class="built_in">shiftDown</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rmv</span><span class="params">(<span class="type">int</span> taskId)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> oldPriority;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_heap.vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (max_heap.vec[i][<span class="number">1</span>] == taskId) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        oldPriority = max_heap.vec[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == max_heap.vec.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">      max_heap.vec.<span class="built_in">pop_back</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(max_heap.vec.<span class="built_in">back</span>(), max_heap.vec[index]);</span><br><span class="line">    max_heap.vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldPriority &gt; max_heap.vec[index][<span class="number">2</span>]) &#123;</span><br><span class="line">      max_heap.<span class="built_in">shiftDown</span>(index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      max_heap.<span class="built_in">shiftUp</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> userId;</span><br><span class="line">    <span class="keyword">if</span> (max_heap.vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    userId = max_heap.<span class="built_in">top</span>()[<span class="number">0</span>];</span><br><span class="line">    max_heap.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> userId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Compare</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (a[<span class="number">2</span>] != b[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]; <span class="comment">// priority 小的优先级低</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  Heap&lt;vector&lt;<span class="type">int</span>&gt;, Compare&gt; max_heap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TaskManager object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TaskManager* obj = new TaskManager(tasks);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(userId,taskId,priority);</span></span><br><span class="line"><span class="comment"> * obj-&gt;edit(taskId,newPriority);</span></span><br><span class="line"><span class="comment"> * obj-&gt;rmv(taskId);</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;execTop();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Step 1: 初始化任务</span></span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tasks = &#123;&#123;<span class="number">10</span>, <span class="number">26</span>, <span class="number">25</span>&#125;&#125;; <span class="comment">// 用户 10，任务 26，优先级 25</span></span><br><span class="line">  <span class="function">TaskManager <span class="title">taskManager</span><span class="params">(tasks)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 2: 删除任务 26</span></span><br><span class="line">  taskManager.<span class="built_in">rmv</span>(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> topUser = taskManager.<span class="built_in">execTop</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;execTop() -&gt; &quot;</span> &lt;&lt; topUser &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最大堆-懒删除"><a href="#最大堆-懒删除" class="headerlink" title="最大堆 + 懒删除"></a>最大堆 + 懒删除</h2><p>我们之前说 priority_queue 不能删除。使用懒删除的方法，只要这个应该删除的元素不是最大值就不删除它。<br>经过此题我算是明白为什么 priority_queue 不提供修改或删除非堆顶元素的方法了。<br>懒删除点赞 👍</p><div class="tip warning faa-horizontal animated"><p>注意该题懒删除”懒删”的有两种： 1.修改产生的，taskId 可能在堆里重复出现，因此最后只通过 taskId 是否在 map 中存在是不行的； 2.删除产生的，taskId 消失；</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::pair;</span><br><span class="line"><span class="keyword">using</span> std::priority_queue;</span><br><span class="line"><span class="keyword">using</span> std::unordered_map;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManager</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; map;</span><br><span class="line">  priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">TaskManager</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;tasks) &#123;</span><br><span class="line">    <span class="type">int</span> userId, taskId, priority;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;task : tasks) &#123;</span><br><span class="line">      userId = task[<span class="number">0</span>];</span><br><span class="line">      taskId = task[<span class="number">1</span>];</span><br><span class="line">      priority = task[<span class="number">2</span>];</span><br><span class="line">      map[taskId] = &#123;priority, userId&#125;;</span><br><span class="line">      heap.<span class="built_in">emplace</span>(priority, taskId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> userId, <span class="type">int</span> taskId, <span class="type">int</span> priority)</span> </span>&#123;</span><br><span class="line">    heap.<span class="built_in">emplace</span>(priority, taskId);</span><br><span class="line">    map[taskId] = &#123;priority, userId&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">edit</span><span class="params">(<span class="type">int</span> taskId, <span class="type">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="built_in">find</span>(taskId) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      map[taskId].first = newPriority;</span><br><span class="line">      heap.<span class="built_in">emplace</span>(newPriority, taskId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">rmv</span><span class="params">(<span class="type">int</span> taskId)</span> </span>&#123; map.<span class="built_in">erase</span>(taskId); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">execTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> top_userId, top_taskId, top_priority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      top_priority = heap.<span class="built_in">top</span>().first;</span><br><span class="line">      top_taskId = heap.<span class="built_in">top</span>().second;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (map.<span class="built_in">find</span>(top_taskId) != map.<span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">          map[top_taskId].first == top_priority) &#123; <span class="comment">// 存在,且priority相同</span></span><br><span class="line">        top_userId = map[top_taskId].second;</span><br><span class="line">        map.<span class="built_in">erase</span>(top_taskId);</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top_userId;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 应该删除的元素</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TaskManager object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TaskManager* obj = new TaskManager(tasks);</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(userId,taskId,priority);</span></span><br><span class="line"><span class="comment"> * obj-&gt;edit(taskId,newPriority);</span></span><br><span class="line"><span class="comment"> * obj-&gt;rmv(taskId);</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;execTop();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 heap.emplace(…) 是 C++ 标准库 priority_queue 的一个成员函数，用来 在堆中直接原地构造元素，而不是先创建对象再拷贝或移动进去。它和 push() 功能类似，但通常比 push() 更高效，尤其是构造复杂对象时。</p><p>语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;T&gt; heap;</span><br><span class="line">heap.<span class="built_in">emplace</span>(args...);</span><br></pre></td></tr></table></figure><p>args… 会被直接传给 T 的构造函数<br>等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heap.<span class="built_in">push</span>(<span class="built_in">T</span>(args...));</span><br></pre></td></tr></table></figure><p>但 emplace 避免了 临时对象的创建。<br>举例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 push</span></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(p);   <span class="comment">// 会拷贝 p 到堆里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 emplace</span></span><br><span class="line">    heap.<span class="built_in">emplace</span>(<span class="number">2</span>, <span class="number">200</span>); <span class="comment">// 直接在堆中构造 pair&lt;int,int&gt;(2,200)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; heap.<span class="built_in">top</span>().first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; heap.<span class="built_in">top</span>().second &lt;&lt; endl;</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 设计题 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 懒删除 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2349 设计数字容器系统</title>
      <link href="/posts/2349/"/>
      <url>/posts/2349/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-17</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2349 设计数字容器系统" href="https://leetcode.cn/problems/design-a-number-container-system/description/?envType=daily-question&envId=2025-09-17"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2349 设计数字容器系统</p><p class="url">https://leetcode.cn/problems/design-a-number-container-system/description/?envType=daily-question&envId=2025-09-17</p></div></a></div></p><p>这题主要利用空间换时间的思想，根据提示的 index 和 number 的大小范围可以断定暴力解法肯定 TLE，而事实也的确如此。<br>利用 set 的特性：std::set 内部是平衡二叉搜索树（通常是红黑树）。树中 最小元素总是在最左边 → set.begin() 指向最左叶子节点。因此 rbegin() 则返回 最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberContainers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NumberContainers</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map.<span class="built_in">count</span>(index)) &#123; <span class="comment">// map中原本有该index</span></span><br><span class="line">      <span class="type">int</span> last_number = map[index];</span><br><span class="line">      min_map[last_number].<span class="built_in">erase</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    map[index] = number;</span><br><span class="line">    min_map[number].<span class="built_in">insert</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (min_map.<span class="built_in">count</span>(number) &amp;&amp; !min_map[number].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> *min_map[number].<span class="built_in">begin</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">  std::map&lt;<span class="type">int</span>, std::set&lt;<span class="type">int</span>&gt;&gt; min_map;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumberContainers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> *      NumberContainers* obj = new NumberContainers();</span></span><br><span class="line"><span class="comment"> * obj-&gt;change(index,number);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;find(number);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 设计题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2197 替换数组中的非互质数</title>
      <link href="/posts/2197/"/>
      <url>/posts/2197/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-16</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2197 替换数组中的非互质数" href="https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/description/?envType=daily-question&envId=2025-09-16"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2197 替换数组中的非互质数</p><p class="url">https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/description/?envType=daily-question&envId=2025-09-16</p></div></a></div></p><p><numeric>中有 std::lcm 和 std::gcd 分别用于计算最小公倍数和最大公约数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">replaceNonCoprimes</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 用 nums[0..top] 作为“栈”</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// std::gcd最大公约数 greatest common divisor</span></span><br><span class="line">      <span class="comment">// 如果栈顶 nums[top] 和当前 nums[i] 不是互质，就合并.</span></span><br><span class="line">      <span class="comment">// 一个数可能会和多个前面的数连续不互质。</span></span><br><span class="line">      <span class="comment">// 所以必须不断往回合并，直到和栈顶互质为止。</span></span><br><span class="line">      <span class="keyword">while</span> (top &gt;= <span class="number">0</span> <span class="keyword">and</span> std::<span class="built_in">gcd</span>(nums[top], nums[i]) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// std::lcm最小公倍数 least common multiple</span></span><br><span class="line">        nums[i] = std::<span class="built_in">lcm</span>(nums[top], nums[i]);</span><br><span class="line">        <span class="comment">// 弹出栈顶，继续和新的栈顶比较</span></span><br><span class="line">        top--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 把合并后的结果压回栈顶</span></span><br><span class="line">      nums[++top] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="built_in">resize</span>(top + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P1935 可以输入的最大单词数</title>
      <link href="/posts/1935/"/>
      <url>/posts/1935/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-15</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P1935 可以输入的最大单词数" href="https://leetcode.cn/problems/maximum-number-of-words-you-can-type/description/?envType=daily-question&envId=2025-09-15"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P1935 可以输入的最大单词数</p><p class="url">https://leetcode.cn/problems/maximum-number-of-words-you-can-type/description/?envType=daily-question&envId=2025-09-15</p></div></a></div></p><p>这题简单,主要注意下 C++怎么分割字符串吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::stringstream;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">canBeTypedWords</span><span class="params">(string text, string brokenLetters)</span> </span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    vector&lt;string&gt; words;</span><br><span class="line">    <span class="type">int</span> broken = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, token, <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">      words.<span class="built_in">push_back</span>(token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (string word : words) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> ch : brokenLetters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.<span class="built_in">find</span>(ch) != string::npos) &#123;</span><br><span class="line">          broken++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> words.<span class="built_in">size</span>() - broken;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Solution s;</span><br><span class="line">  <span class="type">int</span> res = s.<span class="built_in">canBeTypedWords</span>(<span class="built_in">string</span>(<span class="string">&quot;hello world&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;ad&quot;</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P966 元音拼写检查器</title>
      <link href="/posts/966/"/>
      <url>/posts/966/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-15</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P966 元音拼写检查器" href="https://leetcode.cn/problems/vowel-spellchecker/description/?envType=daily-question&envId=2025-09-14"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P966 元音拼写检查器</p><p class="url">https://leetcode.cn/problems/vowel-spellchecker/description/?envType=daily-question&envId=2025-09-14</p></div></a></div></p><p>最开始使用暴力搜索的方法，但是 TLE 了，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">      c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcomplexcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> len1, len2;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  len1 = <span class="built_in">strlen</span>(str1);</span><br><span class="line">  len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len1 &amp;&amp; i &lt; len2; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str1[i] == str2[i]) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isVowel(str1[i]) &amp;&amp; isVowel(str2[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">tolower</span>(str1[i]) == <span class="built_in">tolower</span>(str2[i])) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> str1[i] - str2[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (str1[i] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; str2[i] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str1[i] - str2[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> **<span class="title function_">spellchecker</span><span class="params">(<span class="type">char</span> **wordlist, <span class="type">int</span> wordlistSize, <span class="type">char</span> **queries,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> queriesSize, <span class="type">int</span> *returnSize)</span> &#123;</span><br><span class="line">  <span class="type">char</span> **returnArray;</span><br><span class="line">  <span class="type">char</span> *totally_matched;</span><br><span class="line">  <span class="type">char</span> *case_matched;</span><br><span class="line">  <span class="type">char</span> *vowel_matched;</span><br><span class="line">  <span class="type">char</span> *complex_matched;</span><br><span class="line"></span><br><span class="line">  *returnSize = queriesSize;</span><br><span class="line">  returnArray = (<span class="type">char</span> **)<span class="built_in">malloc</span>(queriesSize * <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queriesSize; i++) &#123;</span><br><span class="line">    totally_matched = <span class="literal">NULL</span>;</span><br><span class="line">    case_matched = <span class="literal">NULL</span>;</span><br><span class="line">    vowel_matched = <span class="literal">NULL</span>;</span><br><span class="line">    complex_matched = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wordlistSize; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(wordlist[j], queries[i]) == <span class="number">0</span> &amp;&amp; totally_matched == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        totally_matched = wordlist[j];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(wordlist[j], queries[i]) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 case_matched == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        case_matched = wordlist[j];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcomplexcmp(wordlist[j], queries[i]) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 complex_matched == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        complex_matched = wordlist[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (totally_matched) &#123;</span><br><span class="line">      returnArray[i] = strdup(totally_matched);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (case_matched) &#123;</span><br><span class="line">      returnArray[i] = strdup(case_matched);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (complex_matched) &#123;</span><br><span class="line">      returnArray[i] = strdup(complex_matched);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      returnArray[i] = strdup(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> returnArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> *wordlist[] = &#123;<span class="string">&quot;KiTe&quot;</span>, <span class="string">&quot;kite&quot;</span>, <span class="string">&quot;hare&quot;</span>, <span class="string">&quot;Hare&quot;</span>&#125;;</span><br><span class="line">  <span class="type">int</span> wordlistSize = <span class="number">4</span>;</span><br><span class="line">  <span class="type">char</span> *queries[] = &#123;<span class="string">&quot;kite&quot;</span>, <span class="string">&quot;Kite&quot;</span>, <span class="string">&quot;KiTe&quot;</span>, <span class="string">&quot;Hare&quot;</span>, <span class="string">&quot;HARE&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Hear&quot;</span>, <span class="string">&quot;hear&quot;</span>, <span class="string">&quot;keti&quot;</span>, <span class="string">&quot;keet&quot;</span>, <span class="string">&quot;keto&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> queriesSize = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> returnSize = queriesSize;</span><br><span class="line">  <span class="type">char</span> **returnArray;</span><br><span class="line">  returnArray =</span><br><span class="line">      spellchecker(wordlist, wordlistSize, queries, queriesSize, &amp;returnSize);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; returnSize; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s, &quot;</span>, returnArray[i]);</span><br><span class="line">    <span class="built_in">free</span>(returnArray[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(returnArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用哈希表查找能从 O(n^2)降低到 O(n)，下面是官方推荐的 C++写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 存储未处理的字符串</span></span><br><span class="line">  unordered_set&lt;string&gt; words_perfect;</span><br><span class="line">  <span class="comment">// 存储小写后的字符串和原字符串的映射</span></span><br><span class="line">  unordered_map&lt;string, string&gt; words_cap;</span><br><span class="line">  <span class="comment">// 存储将元音字母都转换为*的字符串和原字符串的映射</span></span><br><span class="line">  unordered_map&lt;string, string&gt; words_vow;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将元音字母都转换为*</span></span><br><span class="line">  <span class="function">string <span class="title">devowel</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">      ans += <span class="built_in">isVowel</span>(c) ? <span class="string">&#x27;*&#x27;</span> : c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是否是元音字母</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">isVowel</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    c = <span class="built_in">tolower</span>(c);</span><br><span class="line">    <span class="keyword">return</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">match</span><span class="params">(string query)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完全匹配</span></span><br><span class="line">    <span class="keyword">if</span> (words_perfect.<span class="built_in">count</span>(query)) &#123;</span><br><span class="line">      <span class="keyword">return</span> query;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 大小写</span></span><br><span class="line">    string queryL;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : query) &#123;</span><br><span class="line">      queryL += <span class="built_in">tolower</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (words_cap.<span class="built_in">count</span>(queryL)) &#123;</span><br><span class="line">      <span class="keyword">return</span> words_cap[queryL];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都转为小写字母后，查找元音字母</span></span><br><span class="line">    string queryLV = <span class="built_in">devowel</span>(queryL);</span><br><span class="line">    <span class="keyword">if</span> (words_vow.<span class="built_in">count</span>(queryLV)) &#123;</span><br><span class="line">      <span class="keyword">return</span> words_vow[queryLV];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">spellchecker</span><span class="params">(vector&lt;string&gt; &amp;wordlist,</span></span></span><br><span class="line"><span class="params"><span class="function">                              vector&lt;string&gt; &amp;queries)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//填充set和两个map</span></span><br><span class="line">    <span class="keyword">for</span> (string word : wordlist) &#123;</span><br><span class="line">      words_perfect.<span class="built_in">insert</span>(word);</span><br><span class="line">      string wordlow;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">        wordlow += <span class="built_in">tolower</span>(c);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!words_cap.<span class="built_in">count</span>(wordlow)) &#123;</span><br><span class="line">        words_cap[wordlow] = word;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 都转成小写字母后再将元音字母转为*</span></span><br><span class="line">      string wordlowDV = <span class="built_in">devowel</span>(wordlow);</span><br><span class="line">      <span class="keyword">if</span> (!words_vow.<span class="built_in">count</span>(wordlowDV)) &#123;</span><br><span class="line">        words_vow[wordlowDV] = word;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (string query : queries) &#123;</span><br><span class="line">      ans.<span class="built_in">push_back</span>(<span class="built_in">match</span>(query));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>平均时间复杂度</strong></p><div class="table-container"><table><thead><tr><th>操作</th><th>unordered_set</th><th>unordered_map</th></tr></thead><tbody><tr><td>插入</td><td>O(1)</td><td>O(1)</td></tr><tr><td>查找</td><td>O(1)</td><td>O(1)</td></tr><tr><td>删除</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div><ul><li>这里的 <strong>O(1)</strong> 是 <strong>平均复杂度</strong>，假设哈希函数分布均匀，冲突较少。</li><li>主要优点：<strong>比 std::set/std::map（基于红黑树）快</strong>，红黑树的查找是 O(log n)。</li></ul><p><strong>最坏情况时间复杂度</strong></p><ul><li>最坏情况下，如果所有元素都被哈希到同一个桶（hash collision），退化成 <strong>链表</strong>：<ul><li>查找、插入、删除都变为 <strong>O(n)</strong>。</li></ul></li><li>C++ 标准库实现通常用 <strong>桶 + 链表（或红黑树）</strong>，在冲突过多时，会把链表转换成红黑树，从而降低最坏情况复杂度：<ul><li>C++11 以后，unordered_map/unordered_set 的单个桶链表长度超过一定阈值（通常是 8），会转换成红黑树，保证最坏复杂度 <strong>O(log n)</strong>。</li></ul></li></ul><hr><p><strong>空间复杂度</strong></p><ul><li>平均 O(n)，存储哈希表和元素。</li><li>哈希表需要额外的桶数组，占用额外空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3541 找到频率最高的元音和辅音</title>
      <link href="/posts/3541/"/>
      <url>/posts/3541/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-13</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3541找到频率最高的元音和辅音" href="https://leetcode.cn/problems/find-most-frequent-vowel-and-consonant/description/?envType=daily-question&envId=2025-09-13"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3541找到频率最高的元音和辅音</p><p class="url">https://leetcode.cn/problems/find-most-frequent-vowel-and-consonant/description/?envType=daily-question&envId=2025-09-13</p></div></a></div></p><p>利用计数排序思想，空间换时间，复杂度 O(n)<br><div class="tag link"><a class="link-card" title="ASCII码表" href="https://www.runoob.com/w3cnote/ascii.html"><div class="left"><img src="https://static.char123.com/images/favicon.ico"/></div><div class="right"><p class="text">ASCII码表</p><p class="url">https://www.runoob.com/w3cnote/ascii.html</p></div></a></div><br><div class="tag link"><a class="link-card" title="计数排序" href="https://www.runoob.com/w3cnote/counting-sort.html"><div class="left"><img src="https://static.char123.com/images/favicon.ico"/></div><div class="right"><p class="text">计数排序</p><p class="url">https://www.runoob.com/w3cnote/counting-sort.html</p></div></a></div></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">      c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxFreqSum</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">58</span>];</span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="number">58</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    arr[s[i] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> vowel_max = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> consonant_max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">58</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isVowel(<span class="string">&#x27;A&#x27;</span> + i) &amp;&amp; arr[i] &gt; vowel_max) &#123;</span><br><span class="line">      vowel_max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isVowel(<span class="string">&#x27;A&#x27;</span> + i) &amp;&amp; arr[i] &gt; consonant_max) &#123;</span><br><span class="line">      consonant_max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vowel_max + consonant_max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  n = maxFreqSum(<span class="string">&quot;successes&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P3227 字符串元音游戏</title>
      <link href="/posts/3227/"/>
      <url>/posts/3227/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P3227字符串元音游戏" href="https://leetcode.cn/problems/vowels-game-in-a-string/description/?envType=daily-question&envId=2025-09-12"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P3227字符串元音游戏</p><p class="url">https://leetcode.cn/problems/vowels-game-in-a-string/description/?envType=daily-question&envId=2025-09-12</p></div></a></div></p><p>这题可以画一个状态机来看</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509121103619.png" alt="image-20250912110341407"></p><p>小红先手，如果整个串的元音字母是奇数，那么直接拿所有的串，小红胜</p><p>小红先手，如果整个串的元音字母是偶数，除非是 0 个，小红先手就输了；如果是非零，那么再拿一个奇数个元音字母字串后，至少还剩下 2-1=1 个元音子串，而这时小明要拿偶数个，只能拿 0 个，因此必定可以进入状态机的第三个，整个串剩下奇数个，而轮到小红拿奇数个了，直接拿走所有串，小红胜出。</p><p>因此，只要这个字符串有元音字母，就是小红胜出，fou’ze</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">      c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">doesAliceWin</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  <span class="type">int</span> vowel_num = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="comment">// 统计所有的元音数目</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVowel(s[i])) &#123;</span><br><span class="line">      vowel_num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vowel_num == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (vowel_num % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 偶数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 奇数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust language basics</title>
      <link href="/posts/42871/"/>
      <url>/posts/42871/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-11</p></div></div><div class='timeline-item-content'><p>init</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-19</p></div></div><div class='timeline-item-content'><p>modify some format errors</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-22</p></div></div><div class='timeline-item-content'><p>move something to another post</p></div></div></div><hr><h1 id="安装与调试"><a href="#安装与调试" class="headerlink" title="安装与调试"></a>安装与调试</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Linux 情况下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"><span class="comment"># 按照提示进行安装</span></span><br><span class="line">rustc --version</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>Linux 下使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rust-gdb target/debug/your_program</span><br></pre></td></tr></table></figure><h1 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>cargo new 项目名称</p><p>帮助信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Create a new cargo package at &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Usage: cargo.exe new [OPTIONS] &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Arguments:</span><br><span class="line">  &lt;path&gt;</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -q, --quiet                Do not <span class="built_in">print</span> cargo <span class="built_in">log</span> messages</span><br><span class="line">      --registry &lt;REGISTRY&gt;  Registry to use</span><br><span class="line">      --vcs &lt;VCS&gt;            Initialize a new repository <span class="keyword">for</span> the given version control system (git, hg, pijul, or fossil) or <span class="keyword">do</span> not initialize any version control at all (none), overriding a global configuration. [possible values: git, hg, pijul, fossil, none]</span><br><span class="line">      --bin                  Use a binary (application) template [default]</span><br><span class="line">  -v, --verbose...           Use verbose output (-vv very verbose/build.rs output)</span><br><span class="line">      --lib                  Use a library template</span><br><span class="line">      --color &lt;WHEN&gt;         Coloring: auto, always, never</span><br><span class="line">      --edition &lt;YEAR&gt;       Edition to <span class="built_in">set</span> <span class="keyword">for</span> the crate generated [possible values: 2015, 2018, 2021]</span><br><span class="line">      --frozen               Require Cargo.lock and cache are up to <span class="built_in">date</span></span><br><span class="line">      --name &lt;NAME&gt;          Set the resulting package name, defaults to the directory name</span><br><span class="line">      --locked               Require Cargo.lock is up to <span class="built_in">date</span></span><br><span class="line">      --offline              Run without accessing the network</span><br><span class="line">      --config &lt;KEY=VALUE&gt;   Override a configuration value</span><br><span class="line">  -Z &lt;FLAG&gt;                  Unstable (nightly-only) flags to Cargo, see <span class="string">&#x27;cargo -Z help&#x27;</span> <span class="keyword">for</span> details</span><br><span class="line">  -h, --<span class="built_in">help</span>                 Print <span class="built_in">help</span> information</span><br><span class="line"></span><br><span class="line">Run `cargo <span class="built_in">help</span> new` <span class="keyword">for</span> more detailed information.</span><br></pre></td></tr></table></figure><p><strong>Cargo.toml</strong></p><p>TOML(Tom’s Obvious,Minimal Language)格式，是 Cargo 的配置格式</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span><span class="comment">#区域标题，表示一下面是用来配置包package的</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello&quot;</span> <span class="comment">#项目名称</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> <span class="comment">#项目版本</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">&quot;cauchy &lt;731005515@qq.com&gt;&quot;</span>] <span class="comment">#作者</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> <span class="comment">#使用的Rust版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span><span class="comment">#依赖项</span></span><br></pre></td></tr></table></figure><p>在 Rust 中，代码的包叫做<strong>crate</strong></p><h2 id="构建-Cargo-项目"><a href="#构建-Cargo-项目" class="headerlink" title="构建 Cargo 项目"></a>构建 Cargo 项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure><p>创建可执行文件 target/debug/hello_cargo 或 target\debug\hello_cargo.exe(Windows)</p><p>运行.\target\debug\hello_cargo.exe</p><p>第一次运行会生成 cargo.lock 文件</p><p>该文件负责追踪项目依赖的精确版本，不需要手动修改该文件</p><h2 id="构建和运行-Cargo-项目"><a href="#构建和运行-Cargo-项目" class="headerlink" title="构建和运行 Cargo 项目"></a>构建和运行 Cargo 项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><p>如果之前编译过且代码没有修改的话会直接执行</p><h2 id="cargo-check"><a href="#cargo-check" class="headerlink" title="cargo check"></a>cargo check</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo check</span><br></pre></td></tr></table></figure><p>检查代码，确保能通过编译，但是不产生任何可执行文件</p><p>cargo check 比 cargo build 快得多</p><h2 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br></pre></td></tr></table></figure><p>编译时会进行优化，代码运行的更快但是编译时间更长</p><p>会在 target/release 而不是 target/debug 生成可执行文件</p><h1 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h1><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><p>声明使用<strong>let</strong>关键字</p><p>默认情况下，变量是不可变的(immutable)</p><p>声明变量时，前面加上<strong>mut</strong>关键字，就可以使变量可变</p><p>let mut x = 3;</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h3><p>类似于不可变变量，<em><strong>常量(constants)</strong></em> 是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p><p>1.不允许对常量使用 mut。常量不光默认不能变，它总是不能变。</p><p>2.声明常量使用 const 关键字而不是 let，并且 <strong><em>必须</em></strong> <strong>注明值的类型</strong>。</p><p>3.<strong>常量可以在任何作用域中声明</strong>，包括全局作用域，</p><p>4.最后一个区别是，常量只能被设置为<strong>常量表达式</strong>，而<strong>不可以是其他任何只能在运行时计算出的值</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> MAX_POINTS:<span class="type">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure><p>命名规范:全部大写，下划线间隔</p><h3 id="隐藏-shadow"><a href="#隐藏-shadow" class="headerlink" title="隐藏(shadow)"></a>隐藏(shadow)</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以定义一个与之前变量同名的新变量,<strong>新的变量会 shadow 之前声明的同名变量</strong></p><p>shadow 和把变量标记为 mut<strong>是不一样的</strong></p><ul><li>如果不适用 let 关键字，那么给非 mut 的变量赋值会导致编译时错误</li><li>使用 let 声明的同名新变量，也是不可变的</li><li>使用 let 声明的同名新变量，<strong>他的类型可以与之前不同</strong></li></ul><h3 id="允许未使用的变量"><a href="#允许未使用的变量" class="headerlink" title="允许未使用的变量"></a>允许未使用的变量</h3><p>两种方式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Rust 是<strong>静态编译语言</strong>，编译时必须知道所有变量的类型</p><h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><p>Rust 有四种基本的标量类型：<strong>整型</strong>、<strong>浮点型</strong>、<strong>布尔类型</strong>和<strong>字符类型</strong></p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>如果我们没有显式的给予变量一个类型，那编译器会自动帮我们推导一个类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;i32&quot;</span>.<span class="title function_ invoke__">to_string</span>(),<span class="title function_ invoke__">type_of</span>(&amp;x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下函数可以获取传入参数的类型，并返回类型的字符串形式</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">type_of</span>&lt;T&gt;(_: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::any::type_name::&lt;T&gt;())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整数如果不赋予类型默认为 i32 类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">u16</span> = <span class="number">38_u8</span> <span class="keyword">as</span> <span class="type">u16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th><strong>长度</strong></th><th><strong>有符号</strong></th><th><strong>无符号</strong></th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>u8</td></tr><tr><td>16-bit</td><td>i16</td><td>u16</td></tr><tr><td>32-bit</td><td>i32</td><td>u32</td></tr><tr><td>64-bit</td><td>i64</td><td>u64</td></tr><tr><td>128-bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr></tbody></table></div><p>isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">i8</span>::MAX, <span class="number">127</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX, <span class="number">255</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>整型字面值</strong></p><div class="table-container"><table><thead><tr><th><strong>数字字面值</strong></th><th><strong>例子</strong></th></tr></thead><tbody><tr><td>Decimal (十进制)</td><td>98_222</td></tr><tr><td>Hex (十六进制)</td><td>0xff</td></tr><tr><td>Octal (八进制)</td><td>0o77</td></tr><tr><td>Binary (二进制)</td><td>0b1111_0000</td></tr><tr><td>Byte (单字节字符)(仅限于 u8)</td><td>b’A’</td></tr></tbody></table></div><p>Rust 的数字类型默认是 i32。isize 或 usize 主要作为某些集合的索引。</p><p><strong>整形溢出</strong></p><p>比方说有一个 u8 ，它可以存放从零到 255 的值。那么当你将其修改为 256 时会发生什么呢？这被称为 “整型溢出”（<strong>integer overflow</strong> ），这会导致以下两种行为之一的发生。当<strong>在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em></strong>，这个术语被 Rust 用来表明程序因错误而退出。</p><p><strong>在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码回绕（<em>two’s complement wrapping</em>）的操作</strong>。简而言之，比此类型能容纳最大值还大的值会回绕到最小值，值 256 变成 0，值 257 变成 1，依此类推。依赖整型回绕被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，Wrapping。 为了显式地处理溢出的可能性，你可以使用标准库在原生数值类型上提供的以下方法:</p><ul><li>所有模式下都可以使用 <strong>wrapping_* 方法进行回绕</strong>，如 wrapping_add</li><li>如果 <strong>checked_* 方法</strong>出现溢出，则返回 None 值</li><li>用 <strong>overflowing_* 方法</strong>返回值和一个布尔值，表示是否出现溢出</li><li>用 <strong>saturating_* 方法</strong>在值的最小值或最大值处进行饱和处理</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决代码中的错误和 `panic`</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">251_u8</span> + <span class="number">8</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">i8</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">251</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">247_u8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">i8</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">119</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">251_u16</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = <span class="type">u16</span>::<span class="title function_ invoke__">checked_add</span>(<span class="number">251</span>, <span class="number">8</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,v1,v2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浮点数采用 IEEE-754 标准表示。f32 是单精度浮点数，f64 是双精度浮点数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1_000.000_1</span>; <span class="comment">// f64</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">0.12</span>; <span class="comment">// f32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="number">0.01_f64</span>; <span class="comment">// f64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数值运算</strong></p><p>Rust 中的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取余。整数除法会<strong>向下舍入</strong>到最接近的整数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>);<span class="comment">//报错</span></span><br><span class="line"> &#125;</span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>assertion failed: `(left == right)`</span><br><span class="line">  left: `<span class="number">0.30000000000000004</span>`,</span><br><span class="line"> right: `<span class="number">0.3</span>`<span class="string">&#x27;, src<span class="char escape_">\m</span>ain.rs:5:5</span></span><br></pre></td></tr></table></figure><p>两种修改方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="number">0.1</span>+<span class="number">0.2</span>&gt;=<span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="number">0.1_f32</span>+<span class="number">0.2_f32</span>==<span class="number">0.3_f32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_something</span>&lt;T &gt;(something:T)</span><br><span class="line"><span class="keyword">where</span> T : Display</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,something);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 整数加法</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1u32</span> + <span class="number">2</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数减法</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1i32</span> - <span class="number">2</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">1i8</span> - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">3</span> * <span class="number">50</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">9</span> / <span class="number">3</span> == <span class="number">3</span>); <span class="comment">// error ! 修改它让代码工作</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="number">24</span> % <span class="number">5</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑与或非操作</span></span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(<span class="literal">true</span> || <span class="literal">false</span>  );</span><br><span class="line">    <span class="title function_ invoke__">print_something</span>(!<span class="literal">true</span>  );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 位操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 AND 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> &amp; <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 OR 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> | <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;</span>, <span class="number">0b0011u32</span> ^ <span class="number">0b0101</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;</span>, <span class="number">1u32</span> &lt;&lt; <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;</span>, <span class="number">0x80u32</span> &gt;&gt; <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> -<span class="number">3</span>..<span class="number">2</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;i is &#123;&#125;&quot;</span>,i);<span class="comment">//-3到1不包括2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,c);<span class="comment">//a-z包括z</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="comment">// 解决代码中的错误和 `panic`</span></span><br><span class="line"><span class="keyword">use</span> std::ops::&#123;Range, RangeInclusive&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..<span class="number">5</span>), Range&#123; start: <span class="number">1</span>, end: <span class="number">5</span> &#125;);</span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..=<span class="number">5</span>), RangeInclusive::<span class="title function_ invoke__">new</span>(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>Rust 中的布尔类型使用 bool 表示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span> &amp;&amp; <span class="literal">false</span> || <span class="literal">true</span>;<span class="comment">//布尔运算</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(t, f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>Rust 的 char 类型是语言中最原生的字母类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span>: <span class="type">char</span> = <span class="string">&#x27;ℤ&#x27;</span>; <span class="comment">// with explicit type annotation</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_char</span>(c1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_char</span>(c : <span class="type">char</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用单引号声明 char 字面量，而与之相反的是，使用双引号声明字符串字面量。Rust 的 char 类型的大小为<strong>四个字节</strong>(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。Unicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。不过，“字符” 并不是一个 Unicode 中的概念，所以人直觉上的 “字符” 可能与 Rust 中的 char 并不符合。</p><p><strong>大小</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::mem::size_of_val;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;c1),<span class="number">4</span>); <span class="comment">//一个字符4个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;c2),<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_v</span>: () = ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = (<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(_v, <span class="title function_ invoke__">implicitly_ret_unit</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">implicitly_ret_unit</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I will return a ()&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单元类型所占的内存为 0！！！</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::size_of_val;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unit</span>: () = ();</span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">size_of_val</span>(&amp;unit) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p><h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组<strong>长度固定</strong>：一旦声明，其长度不会增大或缩小</p><p>使用包含在圆括号中的逗号分隔的值列表来创建一个元组。元组中的每一个位置都有一个类型，而且这些不同值的<strong>类型也不必是相同的</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tup 变量绑定到整个元组上，因为元组是一个单独的复合元素。为了从元组中获取单个值，可以使用<strong>模式匹配</strong>（pattern matching）来<strong>解构</strong>（destructure）元组值，像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (x, y, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    (y,z,x) = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(y, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(z, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序首先创建了一个元组并绑定到 tup 变量上。接着使用了 let 和一个模式将 tup 分成了三个不同的变量，x、y 和 z。这叫做 <strong>解构</strong>（<strong><em>destructuring</em></strong>），因为它将一个元组拆成了三个部分。</p><p>也可以<strong>使用点号（.）后跟值的索引来直接访问它们</strong>。元组的第一个索引值是 0。例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</p><p><strong>过长的元组无法打印</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复代码错误</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">too_long_tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;too long tuple: &#123;:?&#125;&quot;</span>, too_long_tuple);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修复</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">too_long_tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;too long tuple: &#123;:?&#125;&quot;</span>, too_long_tuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>与元组不同，数组中的每个元素的类型必须相同。Rust 中的数组与一些其他语言中的数组不同，Rust 中的数组长度是固定的。</p><p><strong>数组的类型是[T; Length]</strong>，<strong>数组的长度是类型签名的一部分，因此数组的长度必须在编译期就已知，</strong></p><p>vector 类型是标准库提供的一个 允许 增长和缩小长度的类似数组的集合类型。当不确定是应该使用数组还是 vector 的时候，那么很可能应该使用 vector。</p><p>可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。</p><p>let a: [i32; 5] = [1, 2, 3, 4, 5];</p><p>这里，i32 是每个元素的类型。分号之后，数字 5 表明该数组包含五个元素。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 很多时候，我们可以忽略数组的部分类型，也可以忽略全部类型，让编译器帮助我们推导</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr0</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">char</span>; <span class="number">3</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组分配在栈上， `std::mem::size_of_val` 函数会返回整个数组占用的内存空间</span></span><br><span class="line">    <span class="comment">// 数组中的每个 char 元素占用 4 字节的内存空间，因为在 Rust 中， char 是 Unicode 字符</span></span><br><span class="line">    <span class="built_in">assert!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;arr) == <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过在方括号中指定初始值加分号再加元素个数的方式来创建一个<strong>每个元素都为相同值的数组</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>; <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>变量名为 a 的数组将包含 5 个元素，这些元素的值最初都将被设置为 3。这种写法与 let a = [3, 3, 3, 3, 3]; 效果相同，但更简洁。</p><p><strong>访问数组元素</strong></p><p>数组是可以在栈(stack)上分配的已知固定大小的单个内存块。可以使用索引来访问数组的元素，像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Sunfei&quot;</span>), <span class="string">&quot;Sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>()];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name0</span> = names.<span class="title function_ invoke__">get</span>(<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是下标索引就存在越界的风险了</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_name1</span> = &amp;names[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无效的数组访问</strong></p><p>如果我们访问数组结尾之后的元素，程序在索引操作中使用一个无效的值时导致 <strong>运行时</strong> 错误。程序带着错误信息退出。当<strong>尝试用索引访问一个元素时，Rust 会检查指定的索引是否小于数组的长度。如果索引超出了数组长度，Rust 会 <em>panic</em></strong>，这是 Rust 术语，它用于程序因为错误而退出的情况。</p><p><strong>这种检查必须在运行时进行</strong>，特别是在某些情况下，因为编译器不可能知道用户在以后运行代码时将输入什么值。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="使用-as-进行基本类型转换"><a href="#使用-as-进行基本类型转换" class="headerlink" title="使用 as 进行基本类型转换"></a>使用 as 进行基本类型转换</h3><p>1.Rust 并<strong>没有为基本类型提供隐式的类型转换( coercion )</strong>，但是我们可以通过 as 来进行显式地转换。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">decimal</span> = <span class="number">97.123_f32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">integer</span>: <span class="type">u8</span> = decimal <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c1</span>: <span class="type">char</span> = decimal <span class="keyword">as</span> <span class="type">u8</span> <span class="keyword">as</span> <span class="type">char</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c2</span> = integer <span class="keyword">as</span> <span class="type">char</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;c1 is &#123;&#125;&quot;</span>,c1);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(integer, <span class="string">&#x27;b&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.<strong>默认情况下, 数值溢出会导致编译错误</strong>，但是我们可以通过添加一行全局注解 <strong>#![allow(overflowing_literals)]</strong> 的方式来避免编译错误(溢出还是会发生)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(overflowing_literals)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="type">u8</span>::MAX, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">1000</span> <span class="keyword">as</span> <span class="type">u8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.当将任何数值转换成无符号整型 T 时，如果当前的数值不在新类型的范围内，我们可以<strong>对当前数值进行加值或减值操作( 增加或减少 T::MAX + 1 )</strong>，直到最新的值在新类型的范围内，假设我们要将 300 转成 u8 类型，由于 u8 最大值是 255，因此 300 不在新类型的范围内并且大于新类型的最大值，因此我们需要减去 T::MAX + 1，也就是 300 - 256 = 44。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(overflowing_literals)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">1000</span> <span class="keyword">as</span> <span class="type">u16</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">1000</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">232</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事实上，之前说的规则对于正整数而言，就是如下的取模</span></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;1000 mod 256 is : &#123;&#125;&quot;</span>, <span class="number">1000</span> % <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert_eq!</span>(-<span class="number">1_i8</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从 Rust 1.45 开始，当浮点数超出目标整数的范围时，转化会直接取正整数取值范围的最大或最小值</span></span><br><span class="line">  <span class="built_in">assert_eq!</span>(<span class="number">300.1_f32</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="built_in">assert_eq!</span>(-<span class="number">100.1_f32</span> <span class="keyword">as</span> <span class="type">u8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的浮点数转换有一点性能损耗，如果对于某段代码有极致的性能要求，</span></span><br><span class="line">    <span class="comment">// 可以考虑下面的方法，但是这些方法的结果可能会溢出并且返回一些无意义的值</span></span><br><span class="line">    <span class="comment">// 总之，请小心使用</span></span><br><span class="line">  <span class="keyword">unsafe</span> &#123;</span><br><span class="line">      <span class="comment">// 300.0 is 44</span></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;300.0 is &#123;&#125;&quot;</span>, <span class="number">300.0_f32</span>.to_int_unchecked::&lt;<span class="type">u8</span>&gt;());</span><br><span class="line">      <span class="comment">// -100.0 as u8 is 156</span></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;-100.0 as u8 is &#123;&#125;&quot;</span>, (-<span class="number">100.0_f32</span>).to_int_unchecked::&lt;<span class="type">u8</span>&gt;());</span><br><span class="line">      <span class="comment">// nan as u8 is 0</span></span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;nan as u8 is &#123;&#125;&quot;</span>, <span class="type">f32</span>::NAN.to_int_unchecked::&lt;<span class="type">u8</span>&gt;());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.裸指针可以和代表内存地址的整数互相转换</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">values</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span>: *<span class="keyword">mut</span> <span class="type">i32</span> = values.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_address</span> = p1 <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second_address</span> = first_address + <span class="number">4</span>; <span class="comment">// 4 == std::mem::size_of::&lt;i32&gt;()</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = second_address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *p2 += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(values[<span class="number">1</span>], <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> :[<span class="type">u64</span>; <span class="number">13</span>] = [<span class="number">0</span>; <span class="number">13</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;arr), <span class="number">8</span> * <span class="number">13</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: *<span class="keyword">const</span> [<span class="type">u64</span>] = &amp;arr;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = a <span class="keyword">as</span> *<span class="keyword">const</span> [<span class="type">u8</span>];</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;*b), <span class="number">13</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="From-Into"><a href="#From-Into" class="headerlink" title="From/Into"></a>From/Into</h3><ol><li>From 特征允许让一个类型<strong>定义如何基于另一个类型来创建自己</strong>，因此它提供了一个很方便的类型转换的方式。</li><li><strong>From 和 Into 是配对的，我们只要实现了前者，那后者就会自动被实现</strong>：只要实现了 impl From<T> for U， 就可以使用以下两个方法: let u: U = U::from(T) 和 let u:U = T.into()，前者由 From 特征提供，而后者由自动实现的 Into 特征提供。</li><li>需要注意的是，当使用 into 方法时，需要进行显式地类型标注，因为编译器很可能无法帮我们推导出所需的类型。</li></ol><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_str</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下三个转换都依赖于一个事实：String 实现了 From&lt;&amp;str&gt; 特征</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(my_str);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = my_str.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="comment">// 这里需要显式地类型标注</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string3</span>: <span class="type">String</span> = my_str.<span class="title function_ invoke__">into</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">     <span class="comment">// impl From&lt;bool&gt; for i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span>:<span class="type">i32</span> = <span class="literal">false</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i2</span>:<span class="type">i32</span> = <span class="type">i32</span>::<span class="title function_ invoke__">from</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, i2);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两种方式修复下面的错误</span></span><br><span class="line">    <span class="comment">// 1. 哪个类型实现 From 特征 : impl From&lt;char&gt; for ? , 我们可以查看一下之前提到的文档，来找到合适的类型</span></span><br><span class="line">    <span class="comment">// 2. 上一章节中介绍过的某个关键字</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i3</span>: <span class="type">i32</span> = <span class="string">&#x27;a&#x27;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两种方法来解决错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&#x27;a&#x27;</span> <span class="keyword">as</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="comment">// impl From&lt;bool&gt; for i32</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">i1</span>:<span class="type">i32</span> = <span class="literal">false</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"> <span class="keyword">let</span> <span class="variable">i2</span>:<span class="type">i32</span> = <span class="type">i32</span>::<span class="title function_ invoke__">from</span>(<span class="literal">false</span>);</span><br><span class="line"> <span class="built_in">assert_eq!</span>(i1, i2);</span><br><span class="line"> <span class="built_in">assert_eq!</span>(i1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">i3</span>:<span class="type">u32</span> = <span class="string">&#x27;a&#x27;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="string">&#x27;a&#x27;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">     <span class="comment">// impl From&lt;bool&gt; for i32</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i1</span>:<span class="type">i32</span> = <span class="literal">false</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i2</span>:<span class="type">i32</span> = <span class="type">i32</span>::<span class="title function_ invoke__">from</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, i2);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i3</span>: <span class="type">u32</span> = <span class="string">&#x27;a&#x27;</span> <span class="keyword">as</span> <span class="type">u32</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为自定义类型实现-From-特征"><a href="#为自定义类型实现-From-特征" class="headerlink" title="为自定义类型实现 From 特征"></a>为自定义类型实现 From 特征</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From 被包含在 `std::prelude` 中，因此我们没必要手动将其引入到当前作用域来</span></span><br><span class="line"><span class="comment">// use std::convert::From;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 `from` 方法</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(item: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Number &#123; value: item &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填空</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = Number::<span class="title function_ invoke__">from</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(num.value, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: Number = <span class="number">30</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(num.value, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行错误处理时，为我们自定义的错误类型实现 From 特征是非常有用。这样就可以<strong>通过 ? 自动将某个错误类型转换成我们自定义的错误类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">IoError</span>(io::Error),</span><br><span class="line">    <span class="title function_ invoke__">ParseError</span>(num::ParseIntError),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">IoError</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> <span class="title class_">CliError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: num::ParseIntError) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        CliError::<span class="title function_ invoke__">ParseError</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">open_and_parse_file</span>(file_name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="comment">// ? automatically converts io::Error to CliError</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(&amp;file_name)?;</span><br><span class="line">    <span class="comment">// num::ParseIntError -&gt; CliError</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span>: <span class="type">i32</span> = contents.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>()?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TryFrom-TryInto"><a href="#TryFrom-TryInto" class="headerlink" title="TryFrom / TryInto"></a>TryFrom / TryInto</h3><p>类似于 From 和 Into, TryFrom 和 TryInto 也是用于类型转换的泛型特征。</p><p>但是又与 From/Into 不同, <strong>TryFrom 和 TryInto 可以对转换后的失败进行处理，然后返回一个 Result</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">i16</span> = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Into 特征拥有一个方法`into`,</span></span><br><span class="line">  <span class="comment">// 因此 TryInto 有一个方法是 ?</span></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">u8</span> = <span class="keyword">match</span> n.<span class="title function_ invoke__">try_into</span>() &#123;</span><br><span class="line">      <span class="title function_ invoke__">Ok</span>(n) =&gt; n,</span><br><span class="line">      <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">          <span class="built_in">println!</span>(<span class="string">&quot;there is an error when converting: &#123;:?&#125;, but we catch it&quot;</span>, e.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">          <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert_eq!</span>(n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EvenNum</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TryFrom</span>&lt;<span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">EvenNum</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现 `try_from`</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">try_from</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> value % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNum</span>(value))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(EvenNum::<span class="title function_ invoke__">try_from</span>(<span class="number">8</span>), <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNum</span>(<span class="number">8</span>)));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(EvenNum::<span class="title function_ invoke__">try_from</span>(<span class="number">5</span>), <span class="title function_ invoke__">Err</span>(()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;EvenNum, ()&gt; = <span class="number">8i32</span>.<span class="title function_ invoke__">try_into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">EvenNum</span>(<span class="number">8</span>)));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>: <span class="type">Result</span>&lt;EvenNum, ()&gt; = <span class="number">5i32</span>.<span class="title function_ invoke__">try_into</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result,<span class="title function_ invoke__">Err</span>(()));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它转换"><a href="#其它转换" class="headerlink" title="其它转换"></a>其它转换</h3><h4 id="将任何类型转换成-String"><a href="#将任何类型转换成-String" class="headerlink" title="将任何类型转换成 String"></a>将任何类型转换成 String</h4><p>只要为一个类型实现了 ToString，就可以将任何类型转换成 String。事实上，这种方式并不是最好的，可以利用 fmt::Display trait？它可以控制一个类型如何打印，在实现它的时候还会自动实现 ToString。因为 to_string 是基于 fmt::Display 实现的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;The point is (&#123;&#125;, &#123;&#125;)&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(origin.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;The point is (0, 0)&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, origin), <span class="string">&quot;The point is (0, 0)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解析-String"><a href="#解析-String" class="headerlink" title="解析 String"></a>解析 String</h4><p>使用 parse 方法可以将一个 String 转换成 i32 数字，这是因为在标准库中为 i32 类型实现了 FromStr: : impl FromStr for i32</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// To use `from_str` method, you needs to introduce this trait into the current scope.</span></span><br><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">parsed</span>: <span class="type">i32</span> = <span class="string">&quot;5&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">turbo_parsed</span> = <span class="string">&quot;10&quot;</span>.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">from_str</span> = <span class="type">i32</span>::<span class="title function_ invoke__">from_str</span>(<span class="string">&quot;20&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">sum</span> = parsed + turbo_parsed + from_str;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义实现-FromStr-特征"><a href="#自定义实现-FromStr-特征" class="headerlink" title="自定义实现 FromStr 特征"></a>自定义实现 FromStr 特征</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>::FromStr;</span><br><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">FromStr</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// 关联类型: 在一个 trait 里定义的、与这个 trait“绑定”的类型参数。</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Err</span> = ParseIntError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_str</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="keyword">Self</span>, <span class="keyword">Self</span>::<span class="literal">Err</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">coords</span>: <span class="type">Vec</span>&lt;&amp;<span class="type">str</span>&gt; = s.<span class="title function_ invoke__">trim_matches</span>(|p| p == <span class="string">&#x27;(&#x27;</span> || p == <span class="string">&#x27;)&#x27;</span> )</span><br><span class="line">                                 .<span class="title function_ invoke__">split</span>(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">                                 .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x_fromstr</span> = coords[<span class="number">0</span>].parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">y_fromstr</span> = coords[<span class="number">1</span>].parse::&lt;<span class="type">i32</span>&gt;()?;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Point &#123; x: x_fromstr, y: y_fromstr &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = <span class="string">&quot;(3,4)&quot;</span>.parse::&lt;Point&gt;();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(p.<span class="title function_ invoke__">unwrap</span>(), Point&#123; x: <span class="number">3</span>, y: <span class="number">4</span>&#125; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="transmute"><a href="#transmute" class="headerlink" title="transmute"></a>transmute</h4><p><strong>std::mem::transmute</strong> 是一个 unsafe 函数，可以<strong>把一个类型按位解释为另一个类型</strong>，其中这两个类型<strong>必须有同样的位数( bits )</strong>。</p><p>transmute 相当于将一个类型按位移动到另一个类型，它会将源值的所有位拷贝到目标值中，然后遗忘源值。该函数跟 C 语言中的 memcpy 函数类似。</p><p>正因为此，<strong>transmute</strong> <strong>非常非常不安全!</strong> 调用者必须要自己保证代码的安全性，当然这也是 unsafe 的目的。</p><p><strong>示例</strong></p><p>1.transmute 可以将一个指针转换成一个函数指针，该转换并不具备可移植性，原因是在不同机器上，函数指针和数据指针可能有不同的位数( size )。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pointer</span> = foo <span class="keyword">as</span> *<span class="title function_ invoke__">const</span> ();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">function</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        std::mem::transmute::&lt;*<span class="title function_ invoke__">const</span> (), <span class="title function_ invoke__">fn</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt;(pointer)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">function</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.transmute 还可以扩展或缩短一个不变量的生命周期，即<strong>生命周期的“非法转换</strong>!</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// R 是一个包装了引用的结构体。它里面不存放 i32 本身，而是存放对 i32 的引用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">extend_lifetime</span>&lt;<span class="symbol">&#x27;b</span>&gt;(r: R&lt;<span class="symbol">&#x27;b</span>&gt;) <span class="punctuation">-&gt;</span> R&lt;<span class="symbol">&#x27;static</span>&gt; &#123;</span><br><span class="line">    std::mem::transmute::&lt;R&lt;<span class="symbol">&#x27;b</span>&gt;, R&lt;<span class="symbol">&#x27;static</span>&gt;&gt;(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">shorten_invariant_lifetime</span>&lt;<span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;c</span>&gt;(r: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> R&lt;<span class="symbol">&#x27;static</span>&gt;)</span><br><span class="line">                                             <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> R&lt;<span class="symbol">&#x27;c</span>&gt; &#123;</span><br><span class="line">    std::mem::transmute::&lt;&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> R&lt;<span class="symbol">&#x27;static</span>&gt;, &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> R&lt;<span class="symbol">&#x27;c</span>&gt;&gt;(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.事实上我们还可以使用一些安全的方法来替代 transmute.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">/*Turning raw bytes(&amp;[u8]) to u32, f64, etc.: */</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_bytes</span> = [<span class="number">0x78</span>, <span class="number">0x56</span>, <span class="number">0x34</span>, <span class="number">0x12</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;[<span class="type">u8</span>; <span class="number">4</span>], <span class="type">u32</span>&gt;(raw_bytes) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use `u32::from_ne_bytes` instead</span></span><br><span class="line">    <span class="comment">// 按本机的端序</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_ne_bytes</span>(raw_bytes);</span><br><span class="line">    <span class="comment">// or use `u32::from_le_bytes` or `u32::from_be_bytes` to specify the endianness</span></span><br><span class="line">    <span class="comment">// 小端</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_le_bytes</span>(raw_bytes);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(num, <span class="number">0x12345678</span>);</span><br><span class="line">    <span class="comment">// 大端</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="type">u32</span>::<span class="title function_ invoke__">from_be_bytes</span>(raw_bytes);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(num, <span class="number">0x78563412</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Turning a pointer into a usize: */</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = &amp;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr_num_transmute</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;&amp;<span class="type">i32</span>, <span class="type">usize</span>&gt;(ptr) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use an `as` cast instead</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr_num_cast</span> = ptr <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span> <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Turning an &amp;mut T into an &amp;mut U: */</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = &amp;<span class="keyword">mut</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val_transmuted</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;&amp;<span class="keyword">mut</span> <span class="type">i32</span>, &amp;<span class="keyword">mut</span> <span class="type">u32</span>&gt;(ptr) &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr as *mut i32：把 &amp;mut i32 转成原始指针 *mut i32。</span></span><br><span class="line">    <span class="comment">// as *mut u32：把原始指针再转换成 *mut u32。</span></span><br><span class="line">    <span class="comment">// &amp;mut *(...)：再把原始指针转换回可变引用。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">val_casts</span> = <span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> *(ptr <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u32</span>) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Turning an &amp;str into a &amp;[u8]: */</span></span><br><span class="line">    <span class="comment">// this is not a good way to do this.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;&amp;<span class="type">str</span>, &amp;[<span class="type">u8</span>]&gt;(<span class="string">&quot;Rust&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">82</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">116</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You could use `str::as_bytes`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = <span class="string">&quot;Rust&quot;</span>.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">82</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">116</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Or, just use a byte string, if you have control over the string</span></span><br><span class="line">    <span class="comment">// literal</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">b&quot;Rust&quot;</span>, &amp;[<span class="number">82</span>, <span class="number">117</span>, <span class="number">115</span>, <span class="number">116</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Rust 代码中的<strong>函数和变量名</strong>使用 <strong><em>snake case</em></strong> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词</p><p>我们在 Rust 中通过输入 fn 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>我们可以定义为拥有 <strong>参数</strong>（<em>parameters</em>）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（<em>arguments</em>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当定义多个参数时，使用逗号分隔</p><h3 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h3><p>函数体由一系列的语句和一个可选的结尾表达式构成。</p><p><strong>语句</strong>（<em>Statements</em>）<strong>是执行一些操作但不返回值的指令</strong>。</p><p><strong>表达式</strong>（<em>Expressions</em>）<strong>计算并产生一个值</strong>。</p><p>语句不返回值，表达式会计算出一个值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x_squared</span> = x * x;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x_cube</span> = x_squared * x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面表达式的值将被赋给 `y`</span></span><br><span class="line">        x_cube + x_squared + x</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = &#123;</span><br><span class="line">        <span class="comment">// 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()`</span></span><br><span class="line">        <span class="number">2</span> * x;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;:?&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y is &#123;:?&#125;&quot;</span>, y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;z is &#123;:?&#125;&quot;</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 let y = 6; 中的 6 是一个表达式，它计算出的值是 6。<strong>函数调用是一个表达式</strong>。<strong>宏调用是一个表达式</strong>。<strong>用大括号创建的一个新的块作用域也是一个表达式</strong>，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is: &#123;y&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个表达式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个代码块，它的值是 4。表达式的结尾没有分号。如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>不对返回值命名，但要在箭头（-&gt;）后声明它的类型</p><p>在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">plus_one</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="返回类型为"><a href="#返回类型为" class="headerlink" title="返回类型为()"></a><strong>返回类型为()</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="title function_ invoke__">type_of</span>(&amp;<span class="built_in">println!</span>(<span class="string">&quot;helloworld&quot;</span>)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">type_of</span>&lt;T&gt;(_: &amp;T) <span class="punctuation">-&gt;</span> <span class="type">String</span>&#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,std::any::type_name::&lt;T&gt;())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//helloworld</span></span><br><span class="line"><span class="comment">//()</span></span><br></pre></td></tr></table></figure><h4 id="返回类型为-never"><a href="#返回类型为-never" class="headerlink" title="返回类型为 never"></a>返回类型为 never</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="comment">// implement this function, don&#x27;t modify fn signatures</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;I return nothing&quot;</span>);</span><br><span class="line">        <span class="comment">// sleeping for 1 second to avoid exhausting the cpu resource</span></span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">never_return</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发散函数（Diverging-function）"><a href="#发散函数（Diverging-function）" class="headerlink" title="发散函数（Diverging function）"></a>发散函数（Diverging function）</h4><p>发散函数( Diverging function )不会返回任何值，因此它们可以用于替代需要返回任何值的地方</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_option</span>(tp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> tp &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里与其返回一个 None，不如使用发散函数替代</span></span><br><span class="line">    <span class="title function_ invoke__">never_return_fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用三种方法实现以下发散函数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_option</span>(tp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> tp &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">never_return_fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPLEMENT this function</span></span><br><span class="line"><span class="comment">// DON&#x27;T change any code else</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">unimplemented!</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IMPLEMENT this function in THREE ways</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPLEMENT this function in THREE ways</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    todo!();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IMPLEMENT this function in THREE ways</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The difference between unimplemented! and [todo] is that while <strong>todo! conveys an intent of implementing the functionality later and the message is “not yet implemented”, unimplemented! makes no such claims. Its message is “not implemented”</strong>. Also some IDEs will mark todo!s.</p><p><strong>调用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">get_option</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_option</span>(tp: <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> tp &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">never_return_fn</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IMPLEMENT this function</span></span><br><span class="line"><span class="comment">// DON&#x27;T change any code else</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">never_return_fn</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        std::thread::<span class="title function_ invoke__">sleep</span>(std::time::Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 unimplemented!()和 todo!();会报以下错误</p><p>thread ‘main’ panicked at ‘not implemented’, src\main.rs:24:5</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">_v</span> = <span class="keyword">match</span> b &#123;</span><br><span class="line">        <span class="literal">true</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 发散函数也可以用于 `match` 表达式，用于替代任何类型的值</span></span><br><span class="line">        <span class="literal">false</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;we have no value for `false`, but we can panic&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 表达式中与条件关联的代码块有时被叫做 *arms</p><p>if/else 可以用作表达式来进行赋值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">big_n</span> =</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">10</span> &amp;&amp; n &gt; -<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot; 数字太小，先增加 10 倍再说&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="number">10</span> * n</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;数字太大，我们得让它减半&quot;</span>);</span><br><span class="line"></span><br><span class="line">            n / <span class="number">2</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; -&gt; &#123;&#125;&quot;</span>, n, big_n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>1.代码中的<strong>条件必须是 bool</strong> 值。如果条件不是 bool 值，我们将得到一个错误。Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 if 的条件。</p><p>2.如果使用了多于 1 个 else if 最好使用 match 对代码进行重构</p><h3 id="在-let-语句中使用-if"><a href="#在-let-语句中使用-if" class="headerlink" title="在 let 语句中使用 if"></a>在 let 语句中使用 if</h3><p>因为 if 是一个表达式，我们可以在 let 语句的右侧使用它</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 的每个分支的可能的返回值都必须是相同类型</p><p><strong>注意</strong></p><p>if 代码块中的表达式返回一个整数，而 else 代码块中的表达式返回一个字符串。这不可行，因为变量必须只有一个类型。Rust 需要在编译时就确切的知道变量的类型</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="从循环中返回值"><a href="#从循环中返回值" class="headerlink" title="从循环中返回值"></a>从循环中返回值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;result&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环标签"><a href="#循环标签" class="headerlink" title="循环标签"></a>循环标签</h5><p>如果存在嵌套循环，break 和 continue 应用于此时最内层的循环。你可以选择在一个循环上指定一个 <strong>循环标签</strong>（<em>loop label</em>），然后将标签与 break 或 continue 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            remaining -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;element&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环遍历集合元素相较于 while 循环，增强了代码安全性，并消除了可能由于超出数组的结尾或遍历长度不够而缺少一些元素而导致的 bug</p><p><strong>对于没有实现 copy 的可迭代对象 for in 会取得所有权</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">names</span> = [<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;liming&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hanmeimei&quot;</span>)];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">name</span> <span class="keyword">in</span> &amp;names &#123;</span><br><span class="line">        <span class="comment">// do something with name...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, names);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// numbers中的元素实现了 Copy，因此无需转移所有权</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        <span class="comment">// do something with name...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过索引和值的方式迭代数组"><a href="#通过索引和值的方式迭代数组" class="headerlink" title="通过索引和值的方式迭代数组"></a>通过索引和值的方式迭代数组</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过索引和值的方式迭代数组 `a`</span></span><br><span class="line">    <span class="keyword">for</span> (i,v) <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>,i+<span class="number">1</span>,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Range</strong></p><p>它是标准库提供的类型，用来生成从一个数字开始到另一个数字之前结束的所有数字的序列。(不包括结束的数字)</p><p>rev 方法可以反转 range</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;number&#125;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="所有权，引用与借用"><a href="#所有权，引用与借用" class="headerlink" title="所有权，引用与借用"></a>所有权，引用与借用</h1><h2 id="栈（Stack）与堆（Heap）"><a href="#栈（Stack）与堆（Heap）" class="headerlink" title="栈（Stack）与堆（Heap）"></a>栈（Stack）与堆（Heap）</h2><p>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 <strong>后进先出</strong>（<em>last in, first out</em>）。</p><p>增加数据叫做 <strong>进栈</strong>（<em>pushing onto the stack</em>），而移出数据叫做 <strong>出栈</strong>（<em>popping off the stack</em>）。栈中的所有数据都必须占用已知且固定的大小。</p><p><strong>在编译时大小未知或大小可能变化的数据，要存储在堆上</strong>。 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 <strong>指针</strong>（<em>pointer</em>）。这个过程称作 <strong>在堆上分配内存</strong>（<em>allocating on the heap</em>），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。<strong>因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上</strong>，不过当需要实际数据时，必须访问指针。</p><p><strong>入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。</strong>相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。</p><p>访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存），出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。</p><p>当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</p><p>跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间，这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑栈和堆了，不过明白了所有权的主要目的就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。</p><h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ol><li><strong>Rust 中的每一个值都有一个 所有者（owner）</strong></li><li><strong>值在任一时刻有且只有一个所有者。</strong></li><li><strong>当所有者（变量）离开作用域，这个值将被丢弃。</strong></li></ol><p>所有权的例子：</p><p>修改下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">give_ownership</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能修改下面的代码!</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">give_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="comment">// convert String to Vec</span></span><br><span class="line">    <span class="comment">// 将 String 转换成 Vec 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_s</span> = s.<span class="title function_ invoke__">into_bytes</span>();<span class="comment">//into_bytes会转移所有权</span></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">give_ownership</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only modify the code below!</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">give_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="comment">// convert String to Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_s</span> = s.<span class="title function_ invoke__">as_bytes</span>();<span class="comment">//as_bytes不会转移所有权</span></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">give_ownership</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only modify the code below!</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">give_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="当所有权转移时，可变性也可以随之改变。"><a href="#当所有权转移时，可变性也可以随之改变。" class="headerlink" title="当所有权转移时，可变性也可以随之改变。"></a>当所有权转移时，可变性也可以随之改变。</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = s;</span><br><span class="line"></span><br><span class="line">    s1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量与作用域"><a href="#变量与作用域" class="headerlink" title="变量与作用域"></a>变量与作用域</h2><p>作用域是一个项（item）在程序中有效的范围。假设有这样一个变量：</p><p>let s = “hello”;</p><p>变量 s 绑定到了一个字符串字面值，这个字符串值是<strong>硬编码</strong>进程序代码中的。这个变量从声明的点开始直到当前 <strong>作用域</strong> 结束时都是有效的。示例 4-1 中的注释标明了变量 s 在何处是有效的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效, 它尚未声明</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// 从此处起，s 是有效的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// 此作用域已结束，s 不再有效</span></span><br></pre></td></tr></table></figure><ul><li>当 s<strong>进入作用域</strong> 时，它就是有效的。</li><li>这一直持续到它 <strong>离开作用域</strong> 为止。</li></ul><h2 id="str-和-amp-str"><a href="#str-和-amp-str" class="headerlink" title="str 和&amp;str"></a>str 和&amp;str</h2><p>正常情况下我们无法使用 str 类型，但是可以使用 &amp;str 来替代</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="type">str</span> = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要使用 str 类型，只能配合 Box。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;hello, world&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="title function_ invoke__">greetings</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greetings</span>(s: <span class="type">Box</span>&lt;<span class="type">str</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&amp; 可以用来将 Box<str> 转换为 &amp;str 类型</strong> , Rust 的 <strong>Deref coercion</strong> 会把 <code>&amp;Box&lt;str&gt;</code> 自动转换为 <code>&amp;str</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;hello, world&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="title function_ invoke__">greetings</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greetings</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h2><p>String 是定义在标准库中的类型，分配在堆上，可以动态的增长。它的底层存储是动态字节数组的方式( Vec<u8> )，但是与字节数组不同，<strong>String 是 UTF-8 编码</strong>。</p><blockquote><p><strong>Unicode 和编码方式的区别</strong></p><ul><li><strong>Unicode</strong><ul><li>是一个字符集（character set），规定了每个字符对应一个唯一的 <strong>码点（code point）</strong></li><li>码点形式：<code>U+0000</code> ~ <code>U+10FFFF</code></li><li>例如：<ul><li><code>U+4F60</code> → ‘你’</li><li><code>U+1F600</code> → 😀</li></ul></li></ul></li><li><strong>UTF-8 / UTF-16 / UTF-32</strong><ul><li>是把 Unicode 码点转换成 <strong>字节序列</strong> 的具体方法</li><li>也就是说，Unicode 是“字符表”，UTF-8 是“如何存储或传输这些字符的编码规则”</li></ul></li></ul></blockquote><p>String.chars()和 String.bytes()分别以 Unicode 字符和字节遍历。</p><ul><li><strong>一个 Unicode 字符的长度不是固定的</strong></li><li><strong>一个 Unicode 字符并不一定是一个完整显示的字符</strong></li></ul><p>在 Unicode 和文本处理里，<strong>字符簇（grapheme cluster）</strong> 是一个用户感知的“字符单位”，也就是说，它是用户看到的一个完整字符，但它可能由 <strong>多个 Unicode 标量值（<code>char</code>）组成</strong>。</p><p>简单来说：</p><ul><li>一个字符簇 ≈ “一个完整显示字符”</li><li>不同于 Rust 的 <code>char</code>，<code>char</code> 是单个 Unicode 标量值（可能是一个字母、一个汉字、或一个 emoji 的组成部分）</li><li>一个字符簇可能包含：<ul><li>基础字符 + 组合符号（比如重音符）</li><li>emoji 组合（如 👨‍👩‍👧‍👦 家庭表情，由多个 emoji 和零宽连接符组成）</li></ul></li></ul><p>要遍历字符簇，需要第三方包，比如：</p><div class="tag link"><a class="link-card" title="" href=""><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text"></p><p class="url"></p></div></a></div><p>String 管理被分配到堆上的数据，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>可以</strong> 修改此类字符串 ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world!&quot;</span>); <span class="comment">// push_str() 在字符串后追加字面值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s); <span class="comment">// 将打印 `hello, world!`</span></span><br></pre></td></tr></table></figure><h2 id="内存与分配"><a href="#内存与分配" class="headerlink" title="内存与分配"></a>内存与分配</h2><p>就<strong>字符串字面值</strong>来说，我们在编译时就知道其内容，所以<strong>文本被直接硬编码进最终的可执行文件</strong>中。这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。</p><p>对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：</p><ul><li>必须在运行时向内存分配器（memory allocator）请求内存。</li><li>需要一个当我们处理完 String 时将内存返回给分配器的方法。（某些语言的垃圾回收 GC）</li></ul><p>Rust 采取了一个不同的策略：<strong>内存在拥有它的变量离开作用域后就被自动释放</strong>。下面是示例 4-1 中作用域例子的一个使用 String 而不是字符串字面值的版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        let s = String::from(&quot;hello&quot;); // 从此处起，s 是有效的</span><br><span class="line"></span><br><span class="line">        // 使用 s</span><br><span class="line">    &#125;                                  // 此作用域已结束，</span><br><span class="line">                                       // s 不再有效</span><br></pre></td></tr></table></figure><p>这是一个将 String 需要的内存返回给分配器的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop">drop</a>，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。</p><h2 id="变量与数据交互的方式"><a href="#变量与数据交互的方式" class="headerlink" title="变量与数据交互的方式"></a>变量与数据交互的方式</h2><h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><p><strong>栈数据</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>将 5 绑定到 x；接着生成一个值 x 的拷贝并绑定到 y”。现在有了两个变量，x 和 y，都等于 5</p><p>因为整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中。</p><p>对于此类数据，移动和克隆没有区别</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure><p>一个 String 由 3 部分组成：</p><ol><li>一个指向存放字符串内容的内存的指针</li><li>一个长度 len,指存放字符串内容所需的字节数</li><li>一个容量 capacity,指 String 从操作系统中总共获得内存的总字节数</li></ol><p>上面这些<strong>存放在栈上</strong>，存放字符串内容的部分存放在堆上</p><p>当我们将 s1 赋值给 s2，如果 String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。我们并没有复制指针指向的堆上数据。</p><p>当变量离开时，会调用 drop,导致 double free</p><p>为了保证内存安全</p><ul><li>Rust 没有尝试复制被分配的内存</li><li>Rust 让 s1 失效，即变量 s1 离开作用域时不需要释放任何东西（对应所有权规则 2:值在任一时刻有且只有一个所有者）</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br><span class="line">warning: unused variable: `s2`</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">3</span>:<span class="number">9</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  |         ^^ help: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_s2`</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="meta">#[warn(unused_variables)]</span>` on by default</span><br><span class="line"></span><br><span class="line">error[E0382]: borrow of moved value: `s1`</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">5</span>:<span class="number">28</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  |         -- <span class="keyword">move</span> occurs because `s1` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line"><span class="number">3</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line"><span class="number">4</span> |</span><br><span class="line"><span class="number">5</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br><span class="line">  |                            ^^ value borrowed here after <span class="keyword">move</span></span><br><span class="line">  |</span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` which comes from the expansion of the <span class="keyword">macro</span> `println` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">warning: `loop_test` (bin <span class="string">&quot;loop_test&quot;</span>) generated <span class="number">1</span> warning</span><br><span class="line">error: could not compile `loop_test` due to previous error; <span class="number">1</span> warning emitted</span><br></pre></td></tr></table></figure><p>rust 的这种方式不同于浅拷贝，因为<strong>在浅拷贝的同时让被拷贝者失效了</strong>，因此使用新的术语：移动(Move)</p><p><strong>隐含的设计原则</strong> : <strong>rust 不会自动创建数据的深拷贝</strong></p><p>因为就运行性能而言，任何自动赋值的操作都是廉价的。</p><h4 id="部分-move"><a href="#部分-move" class="headerlink" title="部分 move"></a>部分 move</h4><p>当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生：<strong>变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。</strong></p><p>在这种情况下，<strong>原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用</strong>，也就是之前被引用的那部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug)]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        name: <span class="type">String</span>,</span><br><span class="line">        age: <span class="type">Box</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Alice&quot;</span>),</span><br><span class="line">        age: <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">20</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name`</span></span><br><span class="line">    <span class="comment">// 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Person</span> &#123; name, <span class="keyword">ref</span> age &#125; = person;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s age is &#123;&#125;&quot;</span>, age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s name is &#123;&#125;&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它</span></span><br><span class="line">    <span class="comment">//println!(&quot;The person struct is &#123;:?&#125;&quot;, person);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;</span>, person.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>如果相对 heap 的数据进行深拷贝，而不仅仅时 stack 上面的数据，可以使用 clone 方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span>=<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>=s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,s1,s2);</span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = (<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s1, s2) = t.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;</span>, s1, s2, t); <span class="comment">// -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><strong>Copy trait</strong>,可以用于像整数这样完全放在 stack 上面的类型</p><ul><li>如果一个类型实现了 Copy trait，那么旧的变量在赋值后仍然可用</li><li>如果一个类型或该类型的一部分实现了 Drop trait，那么 Rust 不允许让它再去实现 Copy trait 了</li></ul><p><strong>任何简单标量及其组合类型都是 Copy 的</strong></p><p><strong>任何需要分配内存或某种资源的都不是 Copy 的</strong></p><p>一些拥有 Copy trait 的类型：</p><ul><li>所有整数类型，比如 u32。</li><li>布尔类型，bool，它的值是 true 和 false。</li><li>所有浮点数类型，比如 f64。</li><li>字符类型，char。</li><li>元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。</li></ul><h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，</span></span><br><span class="line">                                    <span class="comment">// 所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 没有特殊之处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。</span></span><br><span class="line">  <span class="comment">// 占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。没有特殊之处</span></span><br></pre></td></tr></table></figure><p>当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。</p><h3 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h3><p>返回值也可以转移所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 转移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 离开作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership 会将</span></span><br><span class="line">                                             <span class="comment">// 返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;yours&quot;</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string</span></span><br><span class="line">                                             <span class="comment">// 并移出给调用的函数</span></span><br><span class="line">                                             <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line">                                                      <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的所有权总是遵循相同的模式：</p><ul><li><strong>将值赋给另一个变量时移动它</strong>。</li><li>当持<strong>有堆中数据值的变量离开作用域</strong>时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。</li></ul><p>如果让函数获得所得值而不获得所有权，需要把传入的参数返回</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (s2, len) = <span class="title function_ invoke__">calculate_length</span>(s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> (<span class="type">String</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = s.<span class="title function_ invoke__">len</span>(); <span class="comment">// len() 返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样过于麻烦，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 <strong>引用</strong>（<em>references</em>）。</p><h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用</strong>（<em>reference</em>）像一个指针，因为<strong>它是一个地址</strong>，我们可以由此访问储存于该地址的属于其他变量的数据。</p><p>与指针不同，<strong>引用确保指向某个特定类型的有效值。</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">   <span class="comment">// 填写空白处</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">p</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;x 的内存地址是 &#123;:p&#125;&quot;</span>, p); <span class="comment">// output: 0x16fa3ac84</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：与使用 &amp; 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符 “ * “</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br></pre></td></tr></table></figure><p>&amp;s1 语法让我们创建一个 <strong>指向</strong> 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以<strong>当引用停止使用时，它所指向的值也不会被丢弃</strong>。</p><p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）</p><p>正如变量默认是不可变的，引用也一样。<strong>引用（默认）不允许修改引用的值。</strong></p><h3 id="rust-会在某些情况下自动解引用"><a href="#rust-会在某些情况下自动解引用" class="headerlink" title="rust 会在某些情况下自动解引用"></a>rust 会在某些情况下自动解引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">    p.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">borrow_object</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">borrow_object</span>(s: &amp;<span class="type">String</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">push_str</span>(&amp;<span class="keyword">mut</span> s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">push_str</span>(s: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变引用有一个很大的限制：<strong>某一时刻只能存在一个可变引用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure><p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p><ul><li>两个或更多指针同时访问同一数据。</li><li>至少有一个指针被用来写入数据。</li><li>没有同步数据访问的机制。</li></ul><p>可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <strong>同时</strong> 拥有：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure><p>另外一个限制：<strong>不可以同时拥有一个可变引用和一个不可变的引用</strong></p><p>但是<strong>多个不可变的引用是可以的</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br></pre></td></tr></table></figure><h3 id="悬空引用（悬垂引用-Dangling-References"><a href="#悬空引用（悬垂引用-Dangling-References" class="headerlink" title="悬空引用（悬垂引用 Dangling References)"></a>悬空引用（悬垂引用 Dangling References)</h3><p>在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p><p>让我们尝试创建一个悬垂引用，Rust 会通过一个编译时错误来避免：</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">//s在函数结束后就drop了</span></span><br><span class="line">    &amp;s<span class="comment">//返回引用，但是函数结束后该地址就被释放掉了</span></span><br><span class="line">&#125;</span><br><span class="line">Compiling loop_test v0.<span class="number">1.0</span> (C:\Users\cauchy\Desktop\rust\loop_test)</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">5</span>:<span class="number">16</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> | <span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">  |                ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function<span class="symbol">&#x27;s</span> <span class="keyword">return</span> <span class="keyword">type</span> <span class="title class_">contains</span> a borrowed value, but there is no value <span class="keyword">for</span> <span class="title class_">it</span> to be borrowed from</span><br><span class="line">help: consider using the `<span class="symbol">&#x27;static</span>` lifetime</span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> | <span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">String</span> &#123;</span><br><span class="line">  |                 +++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br><span class="line">error: could not compile `loop_test` due to previous error</span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>ref 与 &amp; 类似，可以用来获取一个值的引用，但是它们的用法有所不同。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ref</span> r2 = c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(*r1, *r2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个内存地址的字符串是否相等</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">get_addr</span>(r1),<span class="title function_ invoke__">get_addr</span>(r2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取传入引用的内存地址的字符串形式</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_addr</span>(r: &amp;<span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用规则-借用规则-总结"><a href="#引用规则-借用规则-总结" class="headerlink" title="引用规则(借用规则)总结"></a>引用规则(借用规则)总结</h3><ul><li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li><li>引用必须总是有效的。</li></ul><p>Ok: 从可变对象借用不可变</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">borrow_object</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">borrow_object</span>(s: &amp;<span class="type">String</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="None-Lexical-Lifetimes-NLL"><a href="#None-Lexical-Lifetimes-NLL" class="headerlink" title="None Lexical Lifetimes(NLL)"></a>None Lexical Lifetimes(NLL)</h3><p><strong>非词法作用域生命周期</strong></p><div class="tag link"><a class="link-card" title="" href=""><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text"></p><p class="url"></p></div></a></div><p>例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释掉一行代码让它工作</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    r1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    r2.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,r1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释掉 println 即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    r1.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;world&quot;</span>);<span class="comment">//rust编译器知道这之后r1对s的借用生命周期结束了</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    r2.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//println!(&quot;&#123;&#125;&quot;,r1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = &amp;<span class="keyword">mut</span> x; <span class="comment">// mutable borrow</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); <span class="comment">// later used</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码顺利编译，因为编译器知道 x 的可变借用并没有持续到作用域结尾，而是在 x 被再次使用之前就结束了，所以这里不存在冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(&quot;hello, &quot;);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;mut s;</span><br><span class="line">    let r2 = &amp;mut s;</span><br><span class="line"></span><br><span class="line">    // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time</span><br><span class="line">    // 你不能同时使用 r1 和 r2</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入 r1.push_str(“world”);即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">warning: unused variable: `r2`</span><br><span class="line"> --&gt; src/main.rs:5:9</span><br><span class="line">  |</span><br><span class="line">5 |     <span class="built_in">let</span> r2 = &amp;mut s;</span><br><span class="line">  |         ^^ <span class="built_in">help</span>: <span class="keyword">if</span> this is intentional, prefix it with an underscore: `_r2`</span><br><span class="line">  |</span><br><span class="line">  = note: `#[warn(unused_variables)]` on by default</span><br><span class="line"></span><br><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a <span class="keyword">time</span></span><br><span class="line"> --&gt; src/main.rs:5:14</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     <span class="built_in">let</span> r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">...</span><br><span class="line">9 |     r1.push_str(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">  |     -- first borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br><span class="line">warning: `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) generated 1 warning</span><br><span class="line">error: could not compile `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) due to 1 previous error; 1 warning emitted</span><br></pre></td></tr></table></figure><h2 id="切片类型-Slice"><a href="#切片类型-Slice" class="headerlink" title="切片类型 Slice"></a>切片类型 Slice</h2><p><strong><em>slice</em></strong> 允许你引用集合中一段连续的元素序列，而不用引用整个集合。slice 是一类引用，所以它没有所有权。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数接收一个用空格分隔单词的字符串，并返回在该字符串中找到的第一个单词。如果函数在该字符串中并未找到空格，则整个字符串就是一个单词，所以应该返回整个字符串。</p><p>first_word 函数有一个参数 &amp;String。因为我们不需要所有权，所以这没有问题。不过应该返回什么呢？我们并没有一个真正获取 <strong>部分</strong> 字符串的办法。不过，我们可以返回单词结尾的索引，结尾由一个空格表示</p><p>因为需要逐个元素的检查 String 中的值是否为空格，需要用 as_bytes 方法将 String 转化为字节数组：</p><p>let bytes = s.as_bytes();</p><p>接下来，使用 iter 方法在字节数组上创建一个迭代器：</p><p>for (i, &amp;item) in bytes.iter().enumerate() {</p><p>因为 enumerate 方法返回一个元组，我们可以使用模式来解构，所以在 for 循环中，我们指定了一个模式，其中元组中的 i 是索引而元组中的 &amp;item 是单个字节。因为我们从 .iter().enumerate() 中获取了集合元素的引用，所以模式中使用了 &amp;。</p><p>不过这有一个问题。我们返回了一个独立的 usize，不过它只在 &amp;String 的上下文中才是一个有意义的数字。换句话说，因为它是一个与 String 相分离的值，无法保证将来它仍然有效。</p><h3 id="字符串切片-string-slice"><a href="#字符串切片-string-slice" class="headerlink" title="字符串切片 string slice"></a>字符串切片 string slice</h3><p><strong>字符串 slice</strong>（<em>string slice</em>）是 String 中一部分值的引用，它看起来像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> s = String::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> hello = &amp;s[0..5];</span><br><span class="line">    <span class="built_in">let</span> world = &amp;s[6..11];</span><br></pre></td></tr></table></figure><p><strong>[开始索引..终止索引]</strong></p><p><strong>[starting_index..ending_index]</strong></p><p>其中 starting_index 是 slice 的第一个位置，ending_index 则是 slice <strong>最后一个位置的后一个值。</strong></p><p>如果想要从索引 0 开始，可以不写两个点号之前的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>如果 slice 包含 String 的最后一个字节，也可以舍弃尾部的数字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..];</span><br></pre></td></tr></table></figure><p>也可以同时舍弃这两个值来获取整个字符串的 slice</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<strong>字符串 slice range 的索引必须位于有效的 UTF-8 字符边界内，</strong>如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;你好，世界&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,slice);</span><br><span class="line">    <span class="built_in">assert!</span>(slice == <span class="string">&quot;你&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at src/main.rs:3:19:</span><br><span class="line">byte index 2 is not a char boundary; it is inside <span class="string">&#x27;你&#x27;</span> (bytes 0..3) of `你好，世界`</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br></pre></td></tr></table></figure><p>rust 中 String 索引操作 <code>s[i]</code> 不直接返回字符，因为 UTF-8 是可变长度编码。需要使用 <code>chars()</code> 或 <code>bytes()</code> 来遍历或操作字符串内容。比如 <code>chars()</code> 可以迭代 Unicode 字符，而<code>bytes()</code>单个字节。</p><p>重写函数，返回一个 slice(字符串切片返回值可以写成：&amp;str)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>(); <span class="comment">// 错误! s需要是一个可变引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first word is: &#123;&#125;&quot;</span>, word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 clear 需要清空 String，它尝试获取一个可变引用。在调用 clear 之后的 println! 使用了 word 中的引用，所以这个不可变的引用在此时必须仍然有效。Rust 不允许 clear 中的可变引用和 word 中的不可变引用同时存在，因此编译失败</p><h3 id="字符串字面值就是-slice"><a href="#字符串字面值就是-slice" class="headerlink" title="字符串字面值就是 slice"></a>字符串字面值就是 slice</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里 s 的类型是 &amp;str：<strong>它是一个指向二进制程序特定位置的 slice,</strong>这也就是为什么字符串字面值是不可变的；&amp;str 是一个不可变引用。</p><h3 id="字符串-slice-作为参数"><a href="#字符串-slice-作为参数" class="headerlink" title="字符串 slice 作为参数"></a>字符串 slice 作为参数</h3><p>在知道了能够获取字面值和 String 的 slice 后，我们对 first_word 做了改进，这是它的签名：</p><p>fn first_word(s: &amp;String) -&gt; &amp;str {</p><p>而更有经验的 Rustacean 会编写出如下的签名，因为它使得可以对 &amp;String 值和 &amp;str 值使用相同的函数：</p><p>fn first_word(s: &amp;str) -&gt; &amp;str {</p><p>如果有一个字符串 slice，可以直接传递它。如果有一个 String，则可以传递整个 String 的 slice 或对 String 的引用。这种灵活性利用了 <em>deref coercions</em> 的优势，定义一个获取字符串 slice 而不是 String 引用的函数使得我们的 API 更加通用并且不会丢失任何功能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于 `String`（的 slice），整体或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string[..]);</span><br><span class="line">    <span class="comment">// `first_word` 也适用于 `String` 的引用，</span></span><br><span class="line">    <span class="comment">// 这等价于整个 `String` 的 slice</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `first_word` 适用于字符串字面值，整体或全部</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[<span class="number">0</span>..<span class="number">6</span>]);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(&amp;my_string_literal[..]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为字符串字面值已经是字符串 slice 了</span></span><br><span class="line">    <span class="comment">// 这也是适用的，无需 slice 语法！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">word</span> = <span class="title function_ invoke__">first_word</span>(my_string_literal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&amp;String 可以被隐式地转换为&amp;str 类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里, &amp;s 是 `&amp;String` 类型，但是 `first_character` 函数需要的是 `&amp;str` 类型。</span></span><br><span class="line">    <span class="comment">// 尽管两个类型不一样，但是代码仍然可以工作，原因是 `&amp;String` 会被隐式地转换成 `&amp;str` 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ch</span> = <span class="title function_ invoke__">first_character</span>(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the first character is: &#123;&#125;&quot;</span>, ch);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_character</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他类型的-slice"><a href="#其他类型的-slice" class="headerlink" title="其他类型的 slice"></a>其他类型的 slice</h3><p>字符串 slice，是针对字符串的。不过也有更通用的 slice 类型。考虑一下这个数组：</p><p>let a = [1, 2, 3, 4, 5];</p><p>就跟我们想要获取字符串的一部分那样，我们也会想要引用数组的一部分。我们可以这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>这个 slice 的类型是 &amp;[i32]。它跟字符串 slice 的工作方式一样，通过存储第一个集合元素的引用和一个集合总长度。你可以对其他所有集合使用这类 slice。</p><p>切片跟数组相似，但是<strong>切片的长度无法在编译期得知</strong>，因此你<strong>无法直接使用切片类型</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复代码中的错误，不要新增代码行!</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: [<span class="type">i32</span>] = arr[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: <span class="type">str</span> = <span class="string">&quot;hello, world&quot;</span> <span class="keyword">as</span> <span class="type">str</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修复后</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: &amp;[<span class="type">i32</span>] = &amp;arr[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: &amp;<span class="type">str</span> = <span class="string">&quot;hello, world&quot;</span> <span class="keyword">as</span> &amp;<span class="type">str</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个切片引用占用了<strong>2 个字</strong>大小的内存空间( 从现在开始，为了简洁性考虑，如无特殊原因，我们统一使用切片来特指切片引用 )。 该切片的<strong>第一个字是指向数据的指针，第二个字是切片的长度</strong>。</li><li>字的大小取决于处理器架构，例如在 x86-64 上，字的大小是 64 位也就是 8 个字节，那么一个切片引用就是 16 个字节大小。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">let</span> arr: [char; 3] = [<span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;国&#x27;</span>, <span class="string">&#x27;人&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">let</span> slice = &amp;arr[..2];</span><br><span class="line"></span><br><span class="line">    assert!(std::mem::size_of_val(&amp;slice) == 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>切片( 引用 )可以用来<strong>借用数组的某个连续的部分</strong>，对应的签名是 &amp;[T]，可以与数组的签名对比下 [T; Length]。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="built_in">let</span> arr: [i32; 5] = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> slice: &amp;[i32] = &amp;arr[1..4];</span><br><span class="line">  assert_eq!(slice, &amp;[2, 3, 4]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><p>需要使用 struct 关键字并为整个结构体提供一个名字。</p><p>在大括号中，定义每一部分数据的名字和类型，我们称为 <strong>字段</strong>（<em>field</em>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在实例化一个结构体时将它整体标记为可变的，但是 Rust <strong>不允许我们将结构体的某个字段专门指定为可变的.</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>),</span><br><span class="line">        age,</span><br><span class="line">    &#125;;</span><br><span class="line">    p.age = <span class="number">30</span>;</span><br><span class="line">    p.name = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunfei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的</p><h2 id="字段初始化简写"><a href="#字段初始化简写" class="headerlink" title="字段初始化简写"></a>字段初始化简写</h2><p>当字段名与字段值对应的变量名相同时，就可以使用字段初始化简写的方式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Struct-更新语法"><a href="#Struct-更新语法" class="headerlink" title="Struct 更新语法"></a>Struct 更新语法</h2><p>基于 现有的 struct 实例创建一个新的实例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 struct 更新语法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tuple-Struct-元组结构体"><a href="#Tuple-Struct-元组结构体" class="headerlink" title="Tuple Struct 元组结构体"></a>Tuple Struct 元组结构体</h2><p>元组结构体有着结构体名称提供的含义，但没有具体的字段名，只有字段的类型。</p><p>适用于给整个元组取一个名字，并使元组成为与其他元组不同的类型时</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问此类结构体，与访问元组相同：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = <span class="title function_ invoke__">Point</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, p.<span class="number">0</span>, p.<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="没有任何字段的类单元结构体（unit-like-structs）"><a href="#没有任何字段的类单元结构体（unit-like-structs）" class="headerlink" title="没有任何字段的类单元结构体（unit-like structs）"></a>没有任何字段的类单元结构体（unit-like structs）</h2><p><strong>没有任何字段的类单元结构体</strong>,它们类似于 ()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="struct-中的所有权"><a href="#struct-中的所有权" class="headerlink" title="struct 中的所有权"></a>struct 中的所有权</h2><p>在示例 5-1 中的 User 结构体的定义中，我们使用了自身拥有所有权的 String 类型而不是 &amp;str 字符串 slice 类型。这是一个有意而为之的选择，因为我们想要<strong>这个结构体拥有它所有的数据</strong>，<strong>为此只要整个结构体是有效的话其数据也是有效的。</strong></p><p>可以使结构体存储被其他对象拥有的数据的引用，不过这么做的话需要用上 <strong>生命周期</strong>（<em>lifetimes</em>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：缺少生命周期标识符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:3:15</span><br><span class="line">  |</span><br><span class="line">3 |     username: &amp;str,</span><br><span class="line">  |               ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="built_in">help</span>: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">1 ~ struct User&lt;<span class="string">&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="string">2 |     active: bool,</span></span><br><span class="line"><span class="string">3 ~     username: &amp;&#x27;</span>a str,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src/main.rs:4:12</span><br><span class="line">  |</span><br><span class="line">4 |     email: &amp;str,</span><br><span class="line">  |            ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line"><span class="built_in">help</span>: consider introducing a named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">1 ~ struct User&lt;<span class="string">&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="string">2 |     active: bool,</span></span><br><span class="line"><span class="string">3 |     username: &amp;str,</span></span><br><span class="line"><span class="string">4 ~     email: &amp;&#x27;</span>a str,</span><br><span class="line">  |</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0106`.</span><br><span class="line">error: could not compile `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) due to 2 previous errors</span><br></pre></td></tr></table></figure><h2 id="打印-struct"><a href="#打印-struct" class="headerlink" title="打印 struct"></a>打印 struct</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span>=Rectangle&#123;</span><br><span class="line">        width:<span class="number">30</span>,</span><br><span class="line">        length:<span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="title function_ invoke__">area</span>(&amp;rect));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,rect)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(rect: &amp;Rectangle)<span class="punctuation">-&gt;</span><span class="type">u32</span>&#123;</span><br><span class="line">    rect.width*rect.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="struct-的方法"><a href="#struct-的方法" class="headerlink" title="struct 的方法"></a>struct 的方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">u32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.width*<span class="keyword">self</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span>=Rectangle&#123;</span><br><span class="line">        width:<span class="number">30</span>,</span><br><span class="line">        length:<span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,rect.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,rect)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 impl 块里面定义方法</li><li><strong>方法的第一个参数可以是&amp;self，也可以获得其所有权或可变借用，和其他参数一样</strong></li><li>更良好的代码组织</li></ol><h2 id="方法调用的运算符"><a href="#方法调用的运算符" class="headerlink" title="方法调用的运算符"></a>方法调用的运算符</h2><p>在 C/C++ 语言中，有两个不同的运算符来调用方法：. 直接在对象上调用方法，而 -&gt; 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。换句话说，如果 object 是一个指针，那么 object-&gt;something() 就像 (*object).something() 一样。</p><p>Rust 并没有一个与 -&gt; 等效的运算符；相反，Rust 有一个叫 <strong>自动引用和解引用</strong>（<em>automatic referencing and dereferencing</em>）的功能。<strong>方法调用</strong>是 Rust 中<strong>少数几个拥有这种行为的地方</strong>。</p><p>它是这样工作的：当使用 object.something() 调用方法时，Rust 会自动为 object 添加 &amp;、&amp;mut 或 * 以便使 object 与方法签名匹配。也就是说，这些代码是等价的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1.distance(&amp;p2);</span><br><span class="line">(&amp;p1).distance(&amp;p2);</span><br></pre></td></tr></table></figure><p>这种自动引用的行为之所以有效，是因为<strong>方法有一个明确的接收者</strong>———— <strong>self 的类型</strong>。在给出接收者和方法名的前提下，Rust 可以明确地计算出方法是仅仅读取（&amp;self），做出修改（&amp;mut self）或者是获取所有权（self）。</p><h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有在 impl 块中定义的函数被称为 <strong>关联函数</strong>（<em>associated functions</em>）</p><p>不是方法的关联函数经常被用作返回一个结构体新实例的构造函数。这些函数的名称通常为 new ，但 <strong>new 并不是一个关键字</strong>。</p><p><strong>使用结构体名和 :: 语法来调用这个关联函数：比如 let sq = Rectangle::square(3)</strong>;。这个函数位于结构体的命名空间中：:: 语法用于关联函数和模块创建的命名空间</p><p>每个结构体都允许拥有多个 impl 块。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Point` 的关联函数都放在下面的 `impl` 语句块中</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="comment">// 关联函数的使用方法跟构造器非常类似</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">origin</span>() <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x: <span class="number">0.0</span>, y: <span class="number">0.0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另外一个关联函数，有两个参数</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123; x: x, y: y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    p1: Point,</span><br><span class="line">    p2: Point,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个方法</span></span><br><span class="line">    <span class="comment">// `&amp;self` 是 `self: &amp;Self` 的语法糖</span></span><br><span class="line">    <span class="comment">// `Self` 是当前调用对象的类型，对于本例来说 `Self` = `Rectangle`</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="comment">// 使用点操作符可以访问 `self` 中的结构体字段</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x1, y: y1 &#125; = <span class="keyword">self</span>.p1;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x2, y: y2 &#125; = <span class="keyword">self</span>.p2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// `abs` 是一个 `f64` 类型的方法，会返回调用者的绝对值</span></span><br><span class="line">        ((x1 - x2) * (y1 - y2)).<span class="title function_ invoke__">abs</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">perimeter</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x1, y: y1 &#125; = <span class="keyword">self</span>.p1;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: x2, y: y2 &#125; = <span class="keyword">self</span>.p2;</span><br><span class="line"></span><br><span class="line">        <span class="number">2.0</span> * ((x1 - x2).<span class="title function_ invoke__">abs</span>() + (y1 - y2).<span class="title function_ invoke__">abs</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法要求调用者是可变的，`&amp;mut self` 是 `self: &amp;mut Self` 的语法糖</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">translate</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, x: <span class="type">f64</span>, y: <span class="type">f64</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.p1.x += x;</span><br><span class="line">        <span class="keyword">self</span>.p2.x += x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.p1.y += y;</span><br><span class="line">        <span class="keyword">self</span>.p2.y += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Pair` 持有两个分配在堆上的整数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>(<span class="type">Box</span>&lt;<span class="type">i32</span>&gt;, <span class="type">Box</span>&lt;<span class="type">i32</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法会拿走调用者的所有权</span></span><br><span class="line">    <span class="comment">// `self` 是 `self: Self` 的语法糖</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">destroy</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">Pair</span>(first, second) = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Destroying Pair(&#123;&#125;, &#123;&#125;)&quot;</span>, first, second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `first` 和 `second` 在这里超出作用域并被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rectangle</span> = Rectangle &#123;</span><br><span class="line">        <span class="comment">// 关联函数的调用不是通过点操作符，而是使用 `::`</span></span><br><span class="line">        p1: Point::<span class="title function_ invoke__">origin</span>(),</span><br><span class="line">        p2: Point::<span class="title function_ invoke__">new</span>(<span class="number">3.0</span>, <span class="number">4.0</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法才是通过点操作符调用</span></span><br><span class="line">    <span class="comment">// 注意，这里的方法需要的是 `&amp;self` 但是我们并没有使用 `(&amp;rectangle).perimeter()` 来调用，原因在于：</span></span><br><span class="line">    <span class="comment">// 编译器会帮我们自动取引用</span></span><br><span class="line">    <span class="comment">//  `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Rectangle perimeter: &#123;&#125;&quot;</span>, rectangle.<span class="title function_ invoke__">perimeter</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Rectangle area: &#123;&#125;&quot;</span>, rectangle.<span class="title function_ invoke__">area</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">square</span> = Rectangle &#123;</span><br><span class="line">        p1: Point::<span class="title function_ invoke__">origin</span>(),</span><br><span class="line">        p2: Point::<span class="title function_ invoke__">new</span>(<span class="number">1.0</span>, <span class="number">1.0</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误！`rectangle` 是不可变的，但是这个方法要求一个可变的对象</span></span><br><span class="line">    <span class="comment">//rectangle.translate(1.0, 0.0);</span></span><br><span class="line">    <span class="comment">// TODO ^ 试着反注释此行，看看会发生什么</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以！可变对象可以调用可变的方法</span></span><br><span class="line">    square.<span class="title function_ invoke__">translate</span>(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = <span class="title function_ invoke__">Pair</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">1</span>), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    pair.<span class="title function_ invoke__">destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! 上一个 `destroy` 调用拿走了 `pair` 的所有权</span></span><br><span class="line">    <span class="comment">//pair.destroy();</span></span><br><span class="line">    <span class="comment">// TODO ^ 试着反注释此行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在代码中定义一个 IpAddrKind 枚举来表现这个概念并列出可能的 IP 地址类型，V4 和 V6。这被称为枚举的 <strong>成员</strong>（<em>variants</em>）：</p><p>在创建枚举时，你可以使用显式的<strong>整数</strong>设定枚举成员的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Number</span> &#123;</span><br><span class="line">    Zero,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Number1</span> &#123;</span><br><span class="line">    Zero = <span class="number">0</span>,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，不能用小数</span></span><br><span class="line"><span class="comment">//enum Number2 &#123;</span></span><br><span class="line"><span class="comment">//    Zero = 0.0,</span></span><br><span class="line"><span class="comment">//    One = 1.0,</span></span><br><span class="line"><span class="comment">//    Two = 2.0,</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C-like enum</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Number2</span> &#123;</span><br><span class="line">    Zero = <span class="number">0</span>,</span><br><span class="line">    One = <span class="number">1</span>,</span><br><span class="line">    Two = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 通过 `as` 可以将枚举值强转为整数类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(Number::One <span class="keyword">as</span> <span class="type">u8</span>, Number1::One <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Number1::One <span class="keyword">as</span> <span class="type">u8</span>, Number2::One <span class="keyword">as</span> <span class="type">u8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>可以像这样创建 IpAddrKind 两个不同成员的实例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br></pre></td></tr></table></figure><p>枚举成员中的值可以使用模式匹配来获取</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Move&#123;x: <span class="number">1</span>, y: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Message</span>::Move&#123;x:a,y: b&#125; = msg &#123;</span><br><span class="line">    <span class="comment">// 也可以写成</span></span><br><span class="line">    <span class="comment">// if let Message::Move&#123;x, y&#125; = msg &#123;</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(a, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;不要让这行代码运行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将数据附加到枚举的变体中"><a href="#将数据附加到枚举的变体中" class="headerlink" title="将数据附加到枚举的变体中"></a>将数据附加到枚举的变体中</h2><p>使用 struct</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">       V4,</span><br><span class="line">       V6,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">       kind: IpAddrKind,</span><br><span class="line">       address: <span class="type">String</span>,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">home</span> = IpAddr &#123;</span><br><span class="line">       kind: IpAddrKind::V4,</span><br><span class="line">       address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>),</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr &#123;</span><br><span class="line">       kind: IpAddrKind::V6,</span><br><span class="line">       address: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>),</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>仅仅使用枚举并将数据直接放进每一个枚举成员而不是将枚举作为结构体的一部分。IpAddr 枚举的新定义表明了 V4 和 V6 成员都关联了 String 值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">       <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">       <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><p>我们<strong>直接将数据附加到枚举的每个成员上</strong>，这样就不需要一个额外的结构体了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">       <span class="title function_ invoke__">V4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">       <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure><p>注意虽然标准库中包含一个 IpAddr 的定义，仍然可以创建和使用我们自己的定义而不会有冲突，因为我们并没有将标准库中的定义引入作用域。</p><p>枚举可以嵌入多种类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Quit 没有关联任何数据。</li><li>Move 类似结构体包含命名字段。</li><li>Write 包含单独一个 String。</li><li>ChangeColor 包含三个 i32。</li></ul><h2 id="枚举中定义函数"><a href="#枚举中定义函数" class="headerlink" title="枚举中定义函数"></a>枚举中定义函数</h2><p>结构体和枚举还有另一个相似点：就像<strong>可以使用 impl 来为结构体定义方法那样，也可以在枚举上定义方法</strong>。这是一个定义于我们 Message 枚举上的叫做 call 的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">       <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">           <span class="comment">// 在这里定义方法体</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">   m.<span class="title function_ invoke__">call</span>();</span><br></pre></td></tr></table></figure><p>方法体使用了 self 来获取调用方法的值。这个例子中，创建了一个值为 Message::Write(String::from(“hello”)) 的变量 m，而且这就是当 m.call() 运行时 call 方法中的 self 的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TrafficLightColor</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Yellow,</span><br><span class="line">    Green,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement TrafficLightColor with a method</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">TrafficLightColor</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">color</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            TrafficLightColor::Red =&gt; <span class="string">&quot;red&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            TrafficLightColor::Yellow =&gt; <span class="string">&quot;yellow&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            TrafficLightColor::Green =&gt; <span class="string">&quot;green&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = TrafficLightColor::Yellow;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(c.<span class="title function_ invoke__">color</span>(), <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Option-枚举"><a href="#Option-枚举" class="headerlink" title="Option 枚举"></a>Option 枚举</h2><p><strong>定义于标准库中，在 prelude(预导入模块中)</strong></p><p><strong>Rust 没有 Null</strong>，提供了类似于 Null 概念的枚举-Option<T>,它定义于标准库中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">some_char</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure><p>当有一个 Some 值时，我们就知道存在一个值，而这个值保存在 Some 中。当有个 None 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，Option<T> 为什么就比空值要好呢？</p><p>简而言之，因为 Option<T> 和 T（这里 T 可以是任何类型）是不同的类型，编译器不允许像一个肯定有效的值那样使用 Option<T>。例如，这段代码不能编译，因为它尝试将 Option<i8> 与 i8 相加：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i8</span> = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Option</span>&lt;<span class="type">i8</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">sum</span> = x + y;</span><br></pre></td></tr></table></figure><p>事实上，错误信息意味着 Rust 不知道该如何将 Option<i8> 与 i8 相加，因为它们的类型不同。当在 Rust 中拥有一个像 i8 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 Option<i8>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p><p>换句话说，在对 Option<T> 进行 T 的运算之前必须将其转换为 T。</p><p>为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 Option<T> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 Option<T> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。</p><p>这是 Rust 的一个经过深思熟虑的设计决策，来<strong>限制空值的泛滥</strong>以增加 Rust 代码的安全性。</p><h2 id="枚举实现链表"><a href="#枚举实现链表" class="headerlink" title="枚举实现链表"></a>枚举实现链表</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="comment">// Cons: 链表中包含有值的节点，节点是元组类型，第一个元素是节点的值，第二个元素是指向下一个节点的指针</span></span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">u32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    <span class="comment">// Nil: 链表中的最后一个节点，用于说明链表的结束</span></span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为枚举实现一些方法</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="comment">// 创建空的链表</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> List &#123;</span><br><span class="line">        <span class="comment">// 因为没有节点，所以直接返回 Nil 节点</span></span><br><span class="line">        <span class="comment">// 枚举成员 Nil 的类型是 List</span></span><br><span class="line">        Nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在老的链表前面新增一个节点，并返回新的链表</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">prepend</span>(<span class="keyword">self</span>, elem: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> List &#123;</span><br><span class="line">        <span class="title function_ invoke__">Cons</span>(elem, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的长度</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">len</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// 这里我们不能拿走 tail 的所有权，因此需要获取它的引用，递归计算</span></span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_,<span class="keyword">ref</span> tail) =&gt; <span class="number">1</span> + tail.<span class="title function_ invoke__">len</span>(),</span><br><span class="line">            <span class="comment">// 空链表的长度为 0</span></span><br><span class="line">            Nil =&gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回链表的字符串表现形式，用于打印输出</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">stringify</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(head, <span class="keyword">ref</span> tail) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 递归生成字符串</span></span><br><span class="line">                <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, head, tail.<span class="title function_ invoke__">stringify</span>())</span><br><span class="line">            &#125;,</span><br><span class="line">            Nil =&gt; &#123;</span><br><span class="line">                <span class="built_in">format!</span>(<span class="string">&quot;Nil&quot;</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的链表(也是空的)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">list</span> = List::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一些元素</span></span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">1</span>);</span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">2</span>);</span><br><span class="line">    list = list.<span class="title function_ invoke__">prepend</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印列表的当前状态</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;链表的长度是: &#123;&#125;&quot;</span>, list.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, list.<span class="title function_ invoke__">stringify</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><h2 id="match-控制流结构"><a href="#match-控制流结构" class="headerlink" title="match 控制流结构"></a>match 控制流结构</h2><p>Rust 有一个叫做 match 的极为强大的控制流运算符，它允许我们将<strong>一个值</strong>与<strong>一系列的模式</strong>相比较，并根据相匹配的模式执行相应代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="matches"><a href="#matches" class="headerlink" title="matches!"></a>matches!</h3><p>matches!看起来像 match, 但是它可以做一些特别的事情</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">alphabets</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;9&#x27;</span> , <span class="string">&#x27;Y&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill the blank with `matches!` to make the code work</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ab</span> <span class="keyword">in</span> alphabets &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(matches!(ab, <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> | <span class="string">&#x27;A&#x27;</span>..=<span class="string">&#x27;Z&#x27;</span> | <span class="string">&#x27;0&#x27;</span>..=<span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的代码会报错，原因是枚举默认没有实现 PartialEq，所以不能用==比较</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="keyword">if</span> e == MyEnum::Foo &#123; <span class="comment">// 修复错误，只能修改本行代码</span></span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(count, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">Compiling demo v0.<span class="number">1.0</span> (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">error[E0369]: binary operation `==` cannot be applied to <span class="keyword">type</span> `MyEnum`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">13</span>:<span class="number">14</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |         <span class="keyword">if</span> e == MyEnum::Foo &#123; <span class="comment">// 修复错误，只能修改本行代码</span></span><br><span class="line">   |            - ^^ ----------- MyEnum</span><br><span class="line">   |            |</span><br><span class="line">   |            MyEnum</span><br><span class="line">   |</span><br><span class="line">note: an implementation of `<span class="built_in">PartialEq</span>&lt;_&gt;` might be missing <span class="keyword">for</span> `MyEnum`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">3</span>:<span class="number">1</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">3</span>  | <span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">   | ^^^^^^^^^^^ must implement `<span class="built_in">PartialEq</span>&lt;_&gt;`</span><br><span class="line">help: consider annotating `MyEnum` with `<span class="meta">#[derive(PartialEq)]</span>`</span><br><span class="line">   |</span><br><span class="line"><span class="number">3</span>  | <span class="meta">#[derive(PartialEq)]</span></span><br><span class="line">   |</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0369`.</span><br><span class="line">error: could not compile `demo` due to previous error</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="keyword">if</span> matches!(e, MyEnum::Foo) &#123; <span class="comment">// 修复错误，只能修改本行代码</span></span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(count, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h3><p>匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。这也就是如何从枚举成员中提取值的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 这样可以立刻看到州的名称</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>= Coin::<span class="title function_ invoke__">Quarter</span>(UsState::Alaska);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="title function_ invoke__">value_in_cents</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option"></a>匹配 Option<T></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">     <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">     &#125;</span><br><span class="line">&#125;<span class="comment">//它获取一个 Option&lt;i32&gt; ，如果其中含有一个值，将其加一。如果其中没有值，函数应该返回 None 值，而不尝试执行任何操作。</span></span><br></pre></td></tr></table></figure><h3 id="match-匹配必须穷举所有的可能性"><a href="#match-匹配必须穷举所有的可能性" class="headerlink" title="match 匹配必须穷举所有的可能性"></a>match 匹配必须穷举所有的可能性</h3><p>使用<strong>_占位符</strong>(必须放到最后面)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> dice_roll &#123;</span><br><span class="line">    <span class="number">3</span> =&gt; <span class="title function_ invoke__">add_fancy_hat</span>(),</span><br><span class="line">    <span class="number">7</span> =&gt; <span class="title function_ invoke__">remove_fancy_hat</span>(),</span><br><span class="line">    _ =&gt; <span class="title function_ invoke__">reroll</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if-let-简洁控制流"><a href="#if-let-简洁控制流" class="headerlink" title="if let 简洁控制流"></a>if let 简洁控制流</h2><p>处理只关心一种模式匹配而忽略其它匹配的情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">match</span> config_max &#123;</span><br><span class="line">      <span class="title function_ invoke__">Some</span>(max) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max),</span><br><span class="line">      _ =&gt; (),</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用 if let</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">config_max</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(max) = config_max &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;The maximum is configured to be &#123;&#125;&quot;</span>, max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，模式是 Some(max)，max 绑定为 Some 中的值。接着可以在 if let 代码块中使用 max 了，就跟在对应的 match 分支中一样。模式不匹配时 if let 块中的代码不会执行。</p><p>放弃了穷举的可能性</p><p><strong>可以把 if let 看作是 match 的语法糖</strong></p><p><strong>搭配 else 使用</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) = coin &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       count += <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配中的变量遮蔽"><a href="#模式匹配中的变量遮蔽" class="headerlink" title="模式匹配中的变量遮蔽"></a>模式匹配中的变量遮蔽</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="title function_ invoke__">Some</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(age) = age &#123; <span class="comment">// 创建一个新的变量，该变量与之前的 `age` 变量同名</span></span><br><span class="line">       <span class="built_in">assert_eq!</span>(age, <span class="number">30</span>);</span><br><span class="line">    &#125; <span class="comment">// 新的 `age` 变量在这里超出作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> age &#123;</span><br><span class="line">        <span class="comment">// `match` 也能实现变量遮蔽</span></span><br><span class="line">        <span class="title function_ invoke__">Some</span>(age) =&gt;  <span class="built_in">println!</span>(<span class="string">&quot;age 是一个新的变量，它的值是 &#123;&#125;&quot;</span>,age),</span><br><span class="line">        _ =&gt; ()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//age 是一个新的变量，它的值是 30</span></span><br></pre></td></tr></table></figure><h1 id="Workspace-Package-Crate-Module"><a href="#Workspace-Package-Crate-Module" class="headerlink" title="Workspace, Package,Crate,Module"></a>Workspace, Package,Crate,Module</h1><ul><li><strong>包</strong>（<em>Packages</em>）： Cargo 的一个功能，它允许你构建、测试和分享 crate。</li><li><strong>Crate</strong> ：一个模块的树形结构，它形成了库或二进制项目。</li><li><strong>模块</strong>（<em>Modules</em>）和 <strong>use</strong>： 允许你控制作用域和路径的私有性。</li><li><strong>路径</strong>（<em>path</em>）：一个命名例如结构体、函数或模块等项的方式</li></ul><div class="table-container"><table><thead><tr><th>层级</th><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>📦 <strong>Package</strong></td><td>“包”，Cargo 管理的单位（一个项目）</td><td>包含一个或多个 crate，以及 <code>Cargo.toml</code></td><td>整个项目目录</td></tr><tr><td>🧩 <strong>Crate</strong></td><td>“单个编译单元”，可以是库或可执行程序</td><td>每次 <code>rustc</code> 编译的就是一个 crate</td><td><code>src/lib.rs</code> 或 <code>src/main.rs</code></td></tr><tr><td>📁 <strong>Module</strong></td><td>模块，组织 crate 内部代码的结构</td><td>类似 C++ 的命名空间或 Python 的模块</td><td><code>mod network;</code></td></tr><tr><td>🛣️ <strong>Path</strong></td><td>用来访问模块、结构体、函数的路径</td><td>类似 <code>std::io::Write</code></td><td><code>crate::foo::bar()</code></td></tr></tbody></table></div><p><strong>Crate 的类型</strong></p><ul><li><strong>binary</strong></li><li><strong>library</strong></li></ul><p>每个 crate 是一个独立的编译单元。<br>Rust 编译器一次只编译一个 crate。</p><p><strong>Crate Root</strong></p><p>是源代码文件，Rust 编译器从这里开始，组成 Crate 的根 Module。<br>Crate Root 是 <strong>Rust 编译器构建 crate 时的起点文件</strong>，<br>它决定了 <strong>模块树（module tree）</strong> 的最顶层结构。</p><hr><p><strong>举个例子</strong></p><p>假设我们有一个最简单的项目：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_project/</span><br><span class="line">├── Cargo<span class="selector-class">.toml</span></span><br><span class="line">└── <span class="attribute">src</span>/</span><br><span class="line">    ├── <span class="selector-tag">main</span><span class="selector-class">.rs</span></span><br><span class="line">    └── lib.rs</span><br></pre></td></tr></table></figure><p>这两个文件都是 <strong>可能的 crate root</strong>。</p><div class="table-container"><table><thead><tr><th>文件</th><th>crate 类型</th><th>作用</th></tr></thead><tbody><tr><td><code>src/main.rs</code></td><td>binary crate root</td><td>程序入口点（必须包含 <code>fn main()</code>）</td></tr><tr><td><code>src/lib.rs</code></td><td>library crate root</td><td>库的入口点（定义库的模块结构）</td></tr></tbody></table></div><hr><p><strong>编译器的工作逻辑</strong></p><p>当运行<code>cargo build</code>时：</p><p>Cargo 会：</p><ol><li>读取 <code>Cargo.toml</code>；</li><li>找到当前 package 里的 <strong>crate roots</strong>（例如 <code>src/main.rs</code>、<code>src/lib.rs</code>）；</li><li>对每个 crate root 调用编译器，从这个文件开始构建整个 crate 的模块树。</li></ol><p><strong>一个 Package</strong></p><ul><li>包含 1 个 Cargo.toml，它描述了如何构建这些 Crates</li><li><strong>只能包含 0-1 个 library crate</strong></li><li><strong>可以包含任意数量的 binary crate</strong></li><li>但必须<strong>至少包含一个 crate</strong>（library 或者 binary)</li></ul><p>举例：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_package<span class="symbol">/</span></span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── src<span class="symbol">/</span></span><br><span class="line">│   ├── lib.rs          <span class="comment"># library crate</span></span><br><span class="line">│   ├── main.rs         <span class="comment"># 主 binary crate</span></span><br><span class="line">│   └── bin<span class="symbol">/</span></span><br><span class="line">│       ├── tool1.rs    <span class="comment"># 第二个 binary crate</span></span><br><span class="line">│       └── tool2.rs    <span class="comment"># 第三个 binary crate</span></span><br></pre></td></tr></table></figure><p>在 Cargo.toml 里无需特别配置。运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.rs</span></span><br><span class="line">cargo run</span><br><span class="line"><span class="comment"># tool1.rs</span></span><br><span class="line">cargo run --bin tool1</span><br><span class="line"><span class="comment"># tool2.rs</span></span><br><span class="line">cargo run --bin tool1</span><br></pre></td></tr></table></figure><p><strong>workspace</strong></p><p>workspace 是多个 package 的集合，每个 package 都可以有自己的 library crate。如下例子：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_workspace<span class="symbol">/</span></span><br><span class="line">├── Cargo.toml          <span class="comment"># workspace 声明</span></span><br><span class="line">├── app<span class="symbol">/</span>                <span class="comment"># 一个 binary crate package</span></span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src<span class="symbol">/main.rs</span></span><br><span class="line">├── utils<span class="symbol">/</span>              <span class="comment"># 一个 library crate package</span></span><br><span class="line">│   ├── Cargo.toml</span><br><span class="line">│   └── src<span class="symbol">/lib.rs</span></span><br><span class="line">└── network<span class="symbol">/</span>            <span class="comment"># 另一个 library crate package</span></span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src<span class="symbol">/lib.rs</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>workspace 声明的 toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [<span class="string">&quot;app&quot;</span>, <span class="string">&quot;utils&quot;</span>, <span class="string">&quot;network&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="Cargo-的惯例"><a href="#Cargo-的惯例" class="headerlink" title="Cargo 的惯例"></a>Cargo 的惯例</h2><p>src/main.rs</p><ul><li>binary crate 的 crate root</li><li><strong>crate 名与 package 名相同</strong></li></ul><p>src/lib.rs</p><ul><li>package 包含一个 Library crate</li><li>library crate 的 crate root</li><li>crate 名与 package 名相同</li></ul><p>一个 package 可以同时包含 src/main.rs 和 src/lib.rs</p><p>一个 Package 可以有多个 binary crate：</p><p>文件放在 src/bin 下，每个文件都是单独的 binary crate</p><h2 id="定义-module-来控制作用域和私有性"><a href="#定义-module-来控制作用域和私有性" class="headerlink" title="定义 module 来控制作用域和私有性"></a>定义 module 来控制作用域和私有性</h2><p><strong>Module</strong></p><ul><li>在一个 crate 内，将 crate 进行分组</li><li>控制项目（item) 的私有性,public,private</li></ul><p><strong>建立 module</strong></p><ul><li>mod 关键字</li><li>可嵌套</li><li>可包含其他项的定义(struct,enum,常量,trait，函数等)的定义</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的模块树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure><p>src/main.rs 和 src/lib.rs 叫做 crate roots</p><ul><li>这两个文件(任意一个)的内容形成了名为 crate 的模块，位于整个模块树的根部</li><li>整个模块树在隐式的 crate 模块下</li></ul><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>为了在 Rust 的模块中找到某个条目，需要使用<strong>路径</strong></p><ul><li><strong>绝对路径</strong>从 crate root 开始，使用 crate 名或字面值 crate</li><li><strong>相对路径</strong>从当前模块开始，使用 self，super 或当前模块的标识符</li></ul><p>路径至少由一个标识符组成，标识符之间使用::</p><p>src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;<span class="comment">//共有的</span></span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="私有边界（privacy-boundary"><a href="#私有边界（privacy-boundary" class="headerlink" title="私有边界（privacy boundary)"></a>私有边界（privacy boundary)</h2><ul><li>Rust 的所有条目(函数，方法，struct,enum,模块,常量) <strong>默认都是私有的</strong></li><li><strong>父级模块无法访问所有子模块的私有条目</strong></li><li>子模块里可以使用<strong>所有</strong>祖先模块中的条目</li><li><strong>同级模块</strong>可以<strong>互相调用</strong></li><li><strong>pub 关键字可以标记为公共的</strong></li></ul><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super:用来访问父级模块路径中的内容，类似于文件系统中的..</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-struct"><a href="#pub-struct" class="headerlink" title="pub struct"></a>pub struct</h2><p><strong>pub 放在 struct 前</strong>：</p><ul><li>struct 是公共的</li><li><strong>struct 的字段默认是私有的</strong>，<strong>字段前面加 pub 就可以设为公有的</strong></li></ul><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 在夏天订购一个黑麦土司作为早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    <span class="comment">// 改变主意更换想要面包的类型</span></span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I&#x27;d like &#123;&#125; toast please&quot;</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果取消下一行的注释代码不能编译；</span></span><br><span class="line">    <span class="comment">// 不允许查看或修改早餐附带的季节水果</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from(&quot;blueberries&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-enum"><a href="#pub-enum" class="headerlink" title="pub enum"></a>pub enum</h2><p>把 pub 放在 enum 前：</p><ul><li>enum 是公共的</li><li><strong>enum 的变体默认也都是公共的（不需要加 pub 关键字)</strong></li></ul><h2 id="use-关键字"><a href="#use-关键字" class="headerlink" title="use 关键字"></a>use 关键字</h2><p>使用 use 关键字将路径引入作用域</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>仍然遵循私有性规则</li><li>使用 use 来指定相对路径</li></ul><h2 id="use-的习惯用法"><a href="#use-的习惯用法" class="headerlink" title="use 的习惯用法"></a>use 的习惯用法</h2><ul><li>函数:将函数的父级模块引入到作用域(指定到父级)</li></ul><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> self::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct,enum,其他:指定完整路径(指定到本身)</li></ul><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个具有相同名称的项带入作用域</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-as-关键字提供新的名称"><a href="#使用-as-关键字提供新的名称" class="headerlink" title="使用 as 关键字提供新的名称"></a>使用 as 关键字提供新的名称</h2><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-use-重导出"><a href="#pub-use-重导出" class="headerlink" title="pub use 重导出"></a>pub use 重导出</h2><p>使用 use 将路径（名称）导入到作用域内后，<strong>该名称在此作用域内是私有的</strong></p><p>如果你希望 <strong>外部模块也能通过你的路径访问</strong> 那个条目（比如函数、结构体、模块等），就可以用 pub use，re-export 重导出</p><p>pub use：重导出</p><ul><li>将条目引入到作用域</li><li>该条目可以被<strong>外部代码</strong>引入到它们的作用域</li></ul><h2 id="pub-in-Crate"><a href="#pub-in-Crate" class="headerlink" title="pub(in Crate)"></a>pub(in Crate)</h2><p>有时我们希望某一个项只对特定的包可见，那么就可以使用 pub(in Crate) 语法.</p><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> a &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> I: <span class="type">i32</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">semisecret</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">use</span> self::b::c::J;</span><br><span class="line">        x + J</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bar</span>(z: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">semisecret</span>(I) * z</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">foo</span>(y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">semisecret</span>(I) + y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> b &#123;</span><br><span class="line">        <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::a) <span class="keyword">mod</span> c &#123;</span><br><span class="line">            <span class="title function_ invoke__">pub</span>(<span class="keyword">in</span> crate::a) <span class="keyword">const</span> J: <span class="type">i32</span> = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用外部包-package"><a href="#使用外部包-package" class="headerlink" title="使用外部包(package)"></a>使用外部包(package)</h2><p>1.Cargo.toml 添加依赖的包</p><p>2.use 将特定条目引入到作用域</p><ul><li>标准库 std 也被当做外部包，但是不需要修改 Cargo.toml 来包含 std</li><li>需要使用 use 将 std 中的特定条目引入当前作用域</li></ul><h2 id="使用嵌套路径清理大量的-use-语句"><a href="#使用嵌套路径清理大量的-use-语句" class="headerlink" title="使用嵌套路径清理大量的 use 语句"></a>使用嵌套路径清理大量的 use 语句</h2><p><strong>路径相同的部分::{路径差异的部分}</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering,io&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()</span><br></pre></td></tr></table></figure><p>如果两个 use 路径之一是另一个的子路径</p><p>使用 self</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//use std::io;</span></span><br><span class="line"><span class="comment">//use std::io::Write;</span></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>,Write&#125;</span><br></pre></td></tr></table></figure><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符*"></a>通配符*</h2><p>使用*可以把路径中所有的公共条目都引入到作用域</p><p>谨慎使用</p><p>应用场景：</p><ul><li>prelude</li><li>测试，将所有被测试代码引入到 tests 模块</li></ul><h2 id="将模块拆分为不同的文件"><a href="#将模块拆分为不同的文件" class="headerlink" title="将模块拆分为不同的文件"></a>将模块拆分为不同的文件</h2><p>模块定义时，如果模块名后面时”;”，而不是代码块</p><ul><li><strong>Rust 会从模块同名的文件中加载内容</strong></li><li><strong>模块树不会发生变化</strong></li></ul><p>示例:</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 ：声明 front<em>of_house 模块，其内容将位于 _src/front_of_house.rs</em></p><p><em>src/front_of_house.rs</em> 会获取 front_of_house 模块的定义内容，如示例所示。</p><p>文件名: src/front_of_house.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><p><strong>定义模块 <code>front_of_house</code></strong></p><p><strong>方式一</strong>：直接在文件中写模块内容</p><p>文件：<code>src/front_of_house.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里 <code>front_of_house</code> 模块直接定义了子模块 <code>hosting</code>。</li><li>好处：简单，模块小的时候可以这样写。</li></ul><hr><p><strong>方式二</strong>：把子模块拆到单独文件</p><ol><li>在 <code>front_of_house.rs</code> 中只声明子模块：</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br></pre></td></tr></table></figure><ol><li>创建目录和文件结构：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">src</span>/</span><br><span class="line">├── lib<span class="selector-class">.rs</span></span><br><span class="line">├── front_of_house<span class="selector-class">.rs</span>      ← front_of_house 模块的主体</span><br><span class="line">└── front_of_house/        ← front_of_house 的子模块目录</span><br><span class="line">    └── hosting<span class="selector-class">.rs</span>         ← 子模块 hosting 的实现</span><br></pre></td></tr></table></figure><ol><li>在 <code>hosting.rs</code> 中写实际内容：</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>这时 <code>hosting</code> 的内容完全放到 <code>hosting.rs</code>。</li><li>好处：模块大时，拆开文件更清晰、可维护。</li></ul><p><strong>传统风格</strong></p><p>Rust Edition 2018 前，使用下面这种风格</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">src</span>/</span><br><span class="line">└── front_of_house/</span><br><span class="line">    ├── mod<span class="selector-class">.rs</span>       <span class="comment">// front_of_house 模块本体</span></span><br><span class="line">    └── hosting<span class="selector-class">.rs</span>   <span class="comment">// front_of_house 的子模块</span></span><br></pre></td></tr></table></figure><h1 id="常见集合"><a href="#常见集合" class="headerlink" title="常见集合"></a>常见集合</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vec<T> 叫做 vector</p><h3 id="创建-vector"><a href="#创建-vector" class="headerlink" title="创建 vector"></a>创建 vector</h3><p><strong>Vec::new 函数</strong></p><p>let v:Vec<i32>=Vec::new();</p><p>使用初始值创建 Vec<T>,使用<strong>vec!</strong>宏</p><p>let v = vec![1,2,3];</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>(arr);</span><br><span class="line">   <span class="title function_ invoke__">is_vec</span>(v);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">   <span class="title function_ invoke__">is_vec</span>(v);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// vec!(..) 和 vec![..] 是同样的宏，宏可以使用 []、()、&#123;&#125;三种形式，因此...</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   <span class="title function_ invoke__">is_vec</span>(v);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...在下面的代码中, v 是 Vec&lt;[u8; 3]&gt; , 而不是 Vec&lt;u8&gt;</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>(arr);</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>:<span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;=<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="删除-Vector"><a href="#删除-Vector" class="headerlink" title="删除 Vector"></a>删除 Vector</h3><p>类似于任何其他的 struct，vector 在其离开作用域时会被释放</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理变量 v</span></span><br><span class="line">&#125; <span class="comment">// &lt;- 这里 v 离开作用域并被丢弃</span></span><br></pre></td></tr></table></figure><h3 id="读取-Vector-中的值"><a href="#读取-Vector-中的值" class="headerlink" title="读取 Vector 中的值"></a>读取 Vector 中的值</h3><ul><li>索引方式</li><li>get 方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用索引方法访问超出数组元素的值时，程序会 panic</strong></li><li><strong>而使用 get 方法访问时程序会返回一个 None</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v.<span class="title function_ invoke__">get</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = v.<span class="title function_ invoke__">get</span>(i) &#123;</span><br><span class="line">            v[i] = x + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v.<span class="title function_ invoke__">push</span>(i + <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,v), <span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用借用规则"><a href="#引用借用规则" class="headerlink" title="引用借用规则"></a>引用借用规则</h3><p>当我们获取了 vector 的第一个元素的不可变引用并尝试在 vector 末尾增加一个元素的时候，如果尝试在函数的后面引用这个元素是行不通的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">first</span> = &amp;v[<span class="number">0</span>];<span class="comment">//不可变的借用</span></span><br><span class="line"></span><br><span class="line">   v.<span class="title function_ invoke__">push</span>(<span class="number">6</span>);<span class="comment">//可变的借用</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;The first element is: &#123;&#125;&quot;</span>, first);<span class="comment">//不可变的借用</span></span><br></pre></td></tr></table></figure><p>为什么第一个元素的引用会关心 vector 结尾的变化？不能这么做的原因是由于 vector 的工作方式：在 vector 的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的情况下，<strong>可能会要求分配新内存并将老的元素拷贝到新的空间中</strong>。这时，<strong>第一个元素的引用就指向了被释放的内存。借用规则阻止程序陷入这种状况</strong>。</p><h3 id="遍历-Vector"><a href="#遍历-Vector" class="headerlink" title="遍历 Vector"></a>遍历 Vector</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们也可以遍历可变 vector 的每一个元素的可变引用以便能改变他们</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">   <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">       *i += <span class="number">50</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>为了修改可变引用所指向的值，在使用 += 运算符之前必须使用解引用运算符（*）获取 i 中的值。</p><h3 id="扩展-Vector"><a href="#扩展-Vector" class="headerlink" title="扩展 Vector"></a>扩展 Vector</h3><p>Vec 可以使用 extend 方法进行扩展</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">    v1.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    v1.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// v1 is [1,2,3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v2</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    v2.<span class="title function_ invoke__">extend</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// v2 is [1,2,3]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,v1), <span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,v2));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-enum-来使-Vec-存储多种数据类型"><a href="#使用-enum-来使-Vec-存储多种数据类型" class="headerlink" title="使用 enum 来使 Vec 存储多种数据类型"></a>使用 enum 来使 Vec 存储多种数据类型</h3><p>定义一个枚举，以便能在 vector 中存放不同类型的数据</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SpreadsheetCell</span> &#123;</span><br><span class="line">       <span class="title function_ invoke__">Int</span>(<span class="type">i32</span>),</span><br><span class="line">       <span class="title function_ invoke__">Float</span>(<span class="type">f64</span>),</span><br><span class="line">       <span class="title function_ invoke__">Text</span>(<span class="type">String</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">row</span> = <span class="built_in">vec!</span>[</span><br><span class="line">       SpreadsheetCell::<span class="title function_ invoke__">Int</span>(<span class="number">3</span>),</span><br><span class="line">       SpreadsheetCell::<span class="title function_ invoke__">Text</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">       SpreadsheetCell::<span class="title function_ invoke__">Float</span>(<span class="number">10.12</span>),</span><br><span class="line">   ];</span><br></pre></td></tr></table></figure><h3 id="使用特征对象来使-Vec-存储多种数据类型"><a href="#使用特征对象来使-Vec-存储多种数据类型" class="headerlink" title="使用特征对象来使 Vec 存储多种数据类型"></a>使用特征对象来使 Vec 存储多种数据类型</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V4</span>(<span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V4</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv4: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V6</span>(<span class="type">String</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V6</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv6: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> IpAddr&gt;&gt; = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ip</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        ip.<span class="title function_ invoke__">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将-X-类型转换-From-Into-特征-成-Vec"><a href="#将-X-类型转换-From-Into-特征-成-Vec" class="headerlink" title="将 X 类型转换(From/Into 特征)成 Vec"></a>将 X 类型转换(From/Into 特征)成 Vec</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// array -&gt; Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>(arr);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = arr.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1, v2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// String -&gt; Vec</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt; = s.<span class="title function_ invoke__">into</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span> = s.<span class="title function_ invoke__">into_bytes</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1, v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v3</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">from</span>(s);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, v3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>与 String 的切片类似， Vec 也可以使用切片。如果说 Vec 是可变的，那它的切片就是不可变或者说只读的，我们可以通过 &amp; 来获取切片。</p><p>在 Rust 中，<strong>将切片作为参数进行传递是更常见的使用方式</strong>，例如当一个函数只需要可读性时，那传递 Vec 或 String 的切片 &amp;[T] / &amp;str 会更加适合。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice1</span> = &amp;v[..];</span><br><span class="line">    <span class="comment">// 越界访问将导致 panic.</span></span><br><span class="line">    <span class="comment">// 修改时必须使用 `v.len`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice2</span> = &amp;v[<span class="number">0</span>..v.<span class="title function_ invoke__">len</span>()];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice1, slice2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切片是只读的</span></span><br><span class="line">    <span class="comment">// 注意：切片和 `&amp;Vec` 是不同的类型，后者仅仅是 `Vec` 的引用，并可以通过解引用直接获取 `Vec`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vec_ref</span>: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = &amp;<span class="keyword">mut</span> v;</span><br><span class="line">    (*vec_ref).<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice3</span> = &amp;<span class="keyword">mut</span> v[<span class="number">0</span>..];</span><br><span class="line">    <span class="comment">// slice3.push(4);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice3, &amp;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p>容量 capacity 是已经分配好的内存空间，用于存储未来添加到 Vec 中的元素。而长度 len 则是当前 Vec 中已经存储的元素数量。如果要添加新元素时，长度将要超过已有的容量，那容量会自动进行增长：Rust 会重新分配一块更大的内存空间，然后将之前的 Vec 拷贝过去，因此，这里就会发生新的内存分配</p><p>若这段代码会频繁发生，那频繁的内存分配会大幅影响我们系统的性能，最好的办法就是提前分配好足够的容量，尽量减少内存分配。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">capacity</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于提前设置了足够的容量，这里的循环不会造成任何内存分配...</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        vec.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">capacity</span>(), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...但是下面的代码会造成新的内存分配</span></span><br><span class="line">    vec.<span class="title function_ invoke__">push</span>(<span class="number">11</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(vec.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填写一个合适的值，在 `for` 循环运行的过程中，不会造成任何内存分配</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">vec</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">        vec.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">len</span>(), <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec.<span class="title function_ invoke__">capacity</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要为 Vec 实现了 From<T> 特征，那么 T 就可以被转换成 Vec。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>字符串是 Byte 的集合</li><li>UFT-8 编码</li><li>一些方法能将 byte 解析为文本</li></ul><h3 id="字符串是什么？"><a href="#字符串是什么？" class="headerlink" title="字符串是什么？"></a>字符串是什么？</h3><p>Rust 的核心语言层面，只有一个字符串类型:字符串切片 str（或者&amp;str）</p><ul><li>字符串切片:对存储在其它地方,UTF-8 编码的字符串引用</li><li>字符串的字面值：存储在二进制文件中，也是字符串切片</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, 世界&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice1</span> = &amp;s[<span class="number">0</span>..<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//提示: `h` 在 UTF-8 编码中只占用 1 个字节</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice1, <span class="string">&quot;h&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice2</span> = &amp;s[<span class="number">7</span>..<span class="number">10</span>];<span class="comment">// 提示: `中` 在 UTF-8 编码中占用 3 个字节</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(slice2, <span class="string">&quot;世&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代 s 中的所有字符</span></span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">7</span> &#123;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(c, <span class="string">&#x27;世&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上 String 是一个<strong>智能指针</strong>，它作为一个结构体存储在栈上，然后指向存储在堆上的字符串底层数据。</p><p>存储在栈上的智能指针结构体由三部分组成：一个指针只指向堆上的字节数组，已使用的长度以及已分配的容量 capacity (已使用的长度小于等于已分配的容量，当容量不够时，会重新分配内存空间)。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">story</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust By Practice&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻止 String 的数据被自动 drop</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">story</span> = mem::ManuallyDrop::<span class="title function_ invoke__">new</span>(story);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = story.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = story.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">capacity</span> = story.<span class="title function_ invoke__">capacity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">16</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以基于 ptr 指针、长度和容量来重新构建 String.</span></span><br><span class="line">    <span class="comment">// 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="keyword">unsafe</span> &#123; <span class="type">String</span>::<span class="title function_ invoke__">from_raw_parts</span>(ptr, len, capacity) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(*story, s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它字符串类型"><a href="#其它字符串类型" class="headerlink" title="其它字符串类型"></a><strong>其它字符串类型</strong></h3><p><strong>String 类型</strong></p><p>来自标准库，也是 UTF-8 编码</p><p>String vs Str：拥有或借用的变体</p><p><strong>其他字符串类型</strong></p><p><strong>OsString</strong> / <strong>OsStr</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::OsString;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">os_string</span> = OsString::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    os_string.<span class="title function_ invoke__">push</span>(<span class="string">&quot; world&quot;</span>); <span class="comment">// 可变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要用于处理文件路径、命令行参数、环境变量等系统字符串。</p><p><strong>CString</strong> / <strong>CStr</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ffi::CString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c_string</span> = CString::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;NUL found!&quot;</span>);</span><br></pre></td></tr></table></figure><p>来自 <code>std::ffi</code>，用于 <strong>与 C 语言接口交互</strong>。</p><p><strong>特点</strong>：</p><ul><li>以 <strong>NUL 结尾</strong> (<code>\0</code>) 的字符串。</li><li><code>CString</code> 拥有数据，保证没有内部 NUL。</li><li><code>CStr</code> 是不可变借用，类似于 <code>&amp;str</code>。</li></ul><blockquote><p><code>CString</code> 没有提供类似 <code>push_str</code> 或索引访问的方法修改内容，一旦创建，就<strong>不能修改内部字节</strong>。</p></blockquote><h3 id="String-与-amp-str-的转换"><a href="#String-与-amp-str-的转换" class="headerlink" title="String 与&amp;str 的转换"></a>String 与&amp;str 的转换</h3><p><strong>使用 to_string()</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello, world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="title function_ invoke__">greetings</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greetings</span>(s: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 String::from()</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">greetings</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greetings</span>(s: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 你可以使用转义的方式来输出想要的字符，这里我们使用十六进制的值，例如 \x73 会被转义成小写字母 &#x27;s&#x27;</span></span><br><span class="line">    <span class="comment">// 填空以输出 &quot;I&#x27;m writing Rust&quot;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">byte_escape</span> = <span class="string">&quot;I&#x27;m writing Ru\x73__!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;What are you doing\x3F (\\x3F means ?) &#123;&#125;&quot;</span>, byte_escape);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以使用 Unicode 形式的转义字符</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unicode_codepoint</span> = <span class="string">&quot;\u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">character_name</span> = <span class="string">&quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;</span>,</span><br><span class="line">                unicode_codepoint, character_name );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还能使用 \ 来连接多行字符串</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">long_string</span> = <span class="string">&quot;String literals</span></span><br><span class="line"><span class="string">                        can span multiple lines.</span></span><br><span class="line"><span class="string">                        The linebreak and indentation here \</span></span><br><span class="line"><span class="string">                         can be escaped too!&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, long_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有时候需要转义的字符很多，我们会希望使用更方便的方式来书写字符串: raw string.</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_str</span> = <span class="string">r&quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, raw_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字符串包含双引号，可以在开头和结尾加 #</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotes</span> = <span class="string">r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, quotes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果还是有歧义，可以继续增加，没有限制</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">longer_delimiter</span> = <span class="string">r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, longer_delimiter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_str</span> = <span class="string">&quot;Escapes don&#x27;t work here: \x3F \u&#123;211D&#125;&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(raw_str, <span class="string">&quot;Escapes don&#x27;t work here: ? ℝ&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you need quotes in a raw string, add a pair of #s</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">quotes</span> = <span class="string">r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, quotes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you need &quot;# in your string, just use more #s in the delimiter.</span></span><br><span class="line">    <span class="comment">// You can use up to 65535 #s.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">delimiter</span> = <span class="string">r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, delimiter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill the blank</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">long_delimiter</span> = <span class="string">r###&quot;Hello, &quot;##&quot;&quot;###</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(long_delimiter, <span class="string">&quot;Hello, \&quot;##\&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 r#”标记一个原始字符串的开始，”#标记一个字符串的结束，如果还是有歧义可以继续加#</p><h3 id="创建一个新的-String"><a href="#创建一个新的-String" class="headerlink" title="创建一个新的 String"></a>创建一个新的 String</h3><p>String::new()</p><p>let mut s = String::new();</p><p>使用 to_string()</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">data</span> = <span class="string">&quot;initial contents&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = data.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该方法也可直接用于字符串字面值：</span></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;initial contents&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure><p>也可以使用 string::from()</p><p>let s = String::from(“initial contents”);</p><h3 id="更新-String"><a href="#更新-String" class="headerlink" title="更新 String"></a>更新 String</h3><h4 id="push-str"><a href="#push-str" class="headerlink" title="push_str()"></a><strong>push_str()</strong></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">   s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;bar&quot;</span>);</span><br></pre></td></tr></table></figure><p>push_str()方法不会获得参数的所有权</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">   s1.<span class="title function_ invoke__">push_str</span>(s2);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">   s1.<span class="title function_ invoke__">push_str</span>(&amp;s2);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;s2 is &#123;&#125;&quot;</span>, s2);</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push()"></a><strong>push()</strong></h4><p>push 方法被定义为获取一个单独的字符作为参数，并附加到 String 中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">   s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;l&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="连接字符串"><a href="#连接字符串" class="headerlink" title="+连接字符串"></a><strong>+连接字符串</strong></h4><p><strong>只能将</strong> <strong>String</strong> <strong>跟</strong> <strong>&amp;str</strong> <strong>类型进行拼接，并且</strong> <strong>String</strong> <strong>的所有权在此过程中会被 move</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2; <span class="comment">// 注意 s1 被移动了，不能继续使用</span></span><br></pre></td></tr></table></figure><p>+ 运算符使用了 add 函数，这个函数签名看起来像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br></pre></td></tr></table></figure><p>这并不是标准库中实际的签名；</p><p>但是&amp;s2 的类型是 &amp;String 而不是 &amp;str。那么为什么还能编译呢</p><p>之所以能够在 add 调用中使用 &amp;s2 是因为 &amp;String 可以被 <strong>强转</strong>（<em>coerced</em>）成 &amp;str。当 add 函数被调用时，Rust 使用了一个被称为 <strong>Deref 强制转换</strong>（<em>deref coercion</em>）的技术，你可以将其理解为它把 &amp;s2 变成了 &amp;s2[..]。</p><h4 id="format"><a href="#format" class="headerlink" title="format!"></a>format!</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = s1 + <span class="string">&quot;-&quot;</span> + &amp;s2 + <span class="string">&quot;-&quot;</span> + &amp;s3;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s3</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure><p>宏 format! 生成的代码使用引用所以<strong>不会获取任何参数的所有权</strong></p><p><code>s1</code>, <code>s2</code>, <code>s3</code> 都是借用。</p><p>Rust 会 <strong>把内容复制到新字符串</strong>（堆上分配）：</p><ul><li>原来的字符串不受影响。</li><li>这里的复制是必需的，因为生成了新的独立字符串。</li></ul><h3 id="按索引的形式进行访问String"><a href="#按索引的形式进行访问String" class="headerlink" title="按索引的形式进行访问String"></a>按索引的形式进行访问<strong>String</strong></h3><p>Rust 的字符串<strong>不支持索引语法</strong>访问</p><p><strong>内部表现</strong></p><p>String 是一个 Vec<u8> 的封装。</p><p>let hello = String::from(“Hola”);</p><p>在这里，len 的值是 4 ，这意味着储存字符串 “Hola” 的 Vec 的长度是四个字节：这里每一个字母的 UTF-8 编码都占用一个字节。</p><p>（注意这个字符串中的首字母是西里尔字母的 Ze 而不是阿拉伯数字 3 。）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br></pre></td></tr></table></figure><p>当问及这个字符是多长的时候有人可能会说是 12。然而，Rust 的回答是 24。这是使用 UTF-8 编码 “Здравствуйте” 所需要的字节数，这是因为每个 Unicode 标量值需要两个字节存储。</p><p><strong>因此一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值</strong></p><h3 id="字节字符串"><a href="#字节字符串" class="headerlink" title="字节字符串"></a>字节字符串</h3><p>字节字符串或者说字节数组</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 注意，这并不是 `&amp;str` 类型了！</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytestring</span>: &amp;[<span class="type">u8</span>; <span class="number">21</span>] = <span class="string">b&quot;this is a byte string&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组没有实现 `Display` 特征，因此只能使用 `Debug` 的方式去打印</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A byte string: &#123;:?&#125;&quot;</span>, bytestring);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组也可以使用转义</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">escaped</span> = <span class="string">b&quot;\x52\x75\x73\x74 as bytes&quot;</span>;</span><br><span class="line">    <span class="comment">// ...但是不支持 unicode 转义</span></span><br><span class="line">    <span class="comment">// let escaped = b&quot;\u&#123;211D&#125; is not allowed&quot;;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Some escaped bytes: &#123;:?&#125;&quot;</span>, escaped);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// raw string</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">raw_bytestring</span> = <span class="string">br&quot;\u&#123;211D&#125; is not escaped here&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, raw_bytestring);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节数组转成 `str` 类型可能会失败</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(my_str) = <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(raw_bytestring) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;And the same as text: &#x27;&#123;&#125;&#x27;&quot;</span>, my_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_quotes</span> = <span class="string">br#&quot;You can also use &quot;fancier&quot; formatting, \</span></span><br><span class="line"><span class="string">                    like with normal raw strings&quot;#</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组可以不是 UTF-8 格式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">shift_jis</span> = <span class="string">b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;</span>; <span class="comment">// &quot;ようこそ&quot; in SHIFT-JIS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是它们未必能转换成 `str` 类型</span></span><br><span class="line">    <span class="keyword">match</span> <span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(shift_jis) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(my_str) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Conversion successful: &#x27;&#123;&#125;&#x27;&quot;</span>, my_str),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Conversion failed: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字节-标量值-字型簇"><a href="#字节-标量值-字型簇" class="headerlink" title="字节,标量值,字型簇"></a>字节,标量值,字型簇</h3><p>Rust 有三种看待字符串的方式：</p><ul><li>字节 Byte</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="string">&quot;नमस्ते&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> w.<span class="title function_ invoke__">bytes</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">224</span><br><span class="line">164</span><br><span class="line">168</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">174</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">184</span><br><span class="line">224</span><br><span class="line">165</span><br><span class="line">141</span><br><span class="line">224</span><br><span class="line">164</span><br><span class="line">164</span><br><span class="line">224</span><br><span class="line">165</span><br><span class="line">135</span><br></pre></td></tr></table></figure><ul><li>标量值 Scalar Values</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="string">&quot;नमस्ते&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> w.<span class="title function_ invoke__">chars</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">न</span><br><span class="line">म</span><br><span class="line">स</span><br><span class="line">्</span><br><span class="line">त</span><br><span class="line">े</span><br></pre></td></tr></table></figure><ul><li>字形簇 Grapheme Clusters（最接近所谓的字母）</li></ul><p>获取比较复杂，标准库中已经不提供了。 需要借助第三方库。</p><div class="tag link"><a class="link-card" title="" href=""><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text"></p><p class="url"></p></div></a></div><blockquote><p>Rust 不允许对 String 进行索引的一个原因:</p><p>索引操作应该小号一个常量时间 O(1)</p><p>而 String 无法保证：需要遍历所有的内容，来确定有多少个合法的字符</p></blockquote><h3 id="切割-String"><a href="#切割-String" class="headerlink" title="切割 String"></a>切割 String</h3><p>字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。因此，如果你真的希望使用索引创建字符串 slice 时，Rust 会要求你更明确一些。为了更明确索引并表明你需要一个字符串 slice，相比使用 [] 和单个值的索引，可以使用 [] 和一个 range 来创建含特定字节的字符串 slice：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = &amp;hello[<span class="number">0</span>..<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>s 会是一个 &amp;str，它包含字符串的头四个字节。早些时候，我们提到了这些字母都是两个字节长的，所以这意味着 s 将会是 “Зд”。</p><p>如果获取 &amp;hello[0..1] 会发生什么呢？答案是：Rust 在运行时会 panic</p><p>因此<strong>切割时不能跨越字符串边界</strong></p><h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><p>无法通过索引的方式去访问字符串中的某个字符，但是可以使用切片的方式 &amp;s1[start..end] ，但是 start 和 end 必须准确落在字符的边界处.</p><ul><li>对于标量值: chars()方法</li><li>对于字节: bytes()方法、</li><li>对于字形簇:很复杂，标准库未提供，中英文都不需要关注字符簇，利用 chars 就可以遍历中英文</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi,中国&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = &amp;s1[<span class="number">0</span>..<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(h, <span class="string">&quot;h&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h1</span> = &amp;s1[<span class="number">3</span>..<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(h1, <span class="string">&quot;中&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;你好，世界&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">//你</span></span><br><span class="line"><span class="comment">//好</span></span><br><span class="line"><span class="comment">//，</span></span><br><span class="line"><span class="comment">//世</span></span><br><span class="line"><span class="comment">//界</span></span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 默认使用 SipHash 1-3 哈希算法，该算法对于抵抗 HashDos 攻击非常有效。在性能方面，如果你的 key 是中型大小的，那该算法非常不错，但是如果是小型的 key( 例如整数 )亦或是大型的 key ( 例如字符串 )，那你需要采用社区提供的其它算法来提高性能。</p><p>哈希表的算法是基于 Google 的 <a href="https://abseil.io/blog/20180927-swisstables">SwissTable</a>，你可以在<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h">这里</a>找到 C++ 的实现。</p><h3 id="创建-HashMap"><a href="#创建-HashMap" class="headerlink" title="创建 HashMap"></a>创建 HashMap<K,V></h3><p><strong>创建空 HashMap:new()函数</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"><span class="comment">//let mut scores:HashMap&lt;String,i32&gt; = HashMap::new();</span></span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure><ul><li>HashMap 用的较少，<strong>不在 Prelude 中</strong></li><li>标准库对其支持较少，<strong>没有内置的宏来创建 HashMap</strong></li><li>数据存在 heap 中</li><li>同构的，即 K 必须为一种类型，V 为另一种类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams</span> = [</span><br><span class="line">        (<span class="string">&quot;Chinese Team&quot;</span>, <span class="number">100</span>),</span><br><span class="line">        (<span class="string">&quot;American Team&quot;</span>, <span class="number">10</span>),</span><br><span class="line">        (<span class="string">&quot;France Team&quot;</span>, <span class="number">50</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">teams_map1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">team</span> <span class="keyword">in</span> &amp;teams &#123;</span><br><span class="line">        teams_map1.<span class="title function_ invoke__">insert</span>(team.<span class="number">0</span>, team.<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams_map2</span>: HashMap&lt;_,_&gt; = teams.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="comment">// let teams_map2 = HashMap::from(teams);</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(teams_map1, teams_map2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>collect 方法创建 HashMap</strong></p><p>collect 方法可以将数据收集进一系列的集合类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">initial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span>: HashMap&lt;_, _&gt; =</span><br><span class="line">        teams.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">zip</span>(initial_scores.<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br></pre></td></tr></table></figure><p>如果队伍的名字和初始分数分别在两个 vector 中，可以使用 <strong>zip</strong> 方法来<strong>创建一个元组的迭代器</strong>，其中 “Blue” 与 10 是一对，依此类推。接着就可以使用 collect 方法将这个元组的迭代器转换成一个 HashMap</p><h3 id="HashMap-和所有权"><a href="#HashMap-和所有权" class="headerlink" title="HashMap 和所有权"></a>HashMap 和所有权</h3><ul><li>对于实现了 Copy trait 的类型（如 i32)，值会被复制到 HashMap 中</li><li>对于拥有所有权的值（例如 String)，值会被移动，所有权会转移给 HashMap</li><li>如果把引用插入到 HashMap，值本身不会移动但是在 HashMap 有效的期间，被引用的值必须保持有效</li></ul><h3 id="访问-HashMap-中的值"><a href="#访问-HashMap-中的值" class="headerlink" title="访问 HashMap 中的值"></a>访问 HashMap 中的值</h3><p><strong>get 方法</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br></pre></td></tr></table></figure><p><strong>for 循环遍历 HashMap</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这会以<strong>任意顺序</strong>打印出每一个键值对：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yellow: 50</span><br><span class="line">Blue: 10</span><br></pre></td></tr></table></figure><p><strong>索引与 get 方法</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Sunface&quot;</span>, <span class="number">98</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Daniel&quot;</span>, <span class="number">95</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Ashley&quot;</span>, <span class="number">69</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Katie&quot;</span>, <span class="number">58</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 返回一个 Option&lt;&amp;V&gt; 枚举值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(<span class="string">&quot;Sunface&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(score, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">98</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> scores.<span class="title function_ invoke__">contains_key</span>(<span class="string">&quot;Daniel&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 索引返回一个值 V</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">score</span> = scores[<span class="string">&quot;Daniel&quot;</span>];</span><br><span class="line">        <span class="built_in">assert_eq!</span>(score, <span class="number">95</span>);</span><br><span class="line">        scores.<span class="title function_ invoke__">remove</span>(<span class="string">&quot;Daniel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(scores.<span class="title function_ invoke__">len</span>(), <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (name, score) <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The score of &#123;&#125; is &#123;&#125;&quot;</span>, name, score)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新-HashMap"><a href="#更新-HashMap" class="headerlink" title="更新 HashMap"></a>更新 HashMap</h3><h4 id="覆盖一个值"><a href="#覆盖一个值" class="headerlink" title="覆盖一个值"></a>覆盖一个值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure><p>这会打印出 {“Blue”: 25}。原始的值 10 则被覆盖了</p><h4 id="只在键没有对应值时插入"><a href="#只在键没有对应值时插入" class="headerlink" title="只在键没有对应值时插入"></a>只在键没有对应值时插入</h4><p>使用 entry 方法<strong>只在键没有对应一个值时插入</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">e</span>=scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,e);</span><br><span class="line">e.<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Entry</span><span class="params">(VacantEntry(<span class="string">&quot;Yellow&quot;</span>)</span></span>)</span><br><span class="line">&#123;<span class="string">&quot;Blue&quot;</span>: <span class="number">10</span>, <span class="string">&quot;Yellow&quot;</span>: <span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>entry 方法</strong></p><p>检查指定的 K 是否对应一个 V</p><p>参数为 K,返回 enum Entry:代表值是否存在</p><p>Entry 的<strong>or_insert()方法</strong>:</p><p>返回:</p><ul><li>如果 K 存在，返回到对应的 V 的一个可变引用</li><li>如果 K 不存在，将方法参数作为 K 的新值插进去，返回到这个值的可变引用</li></ul><h4 id="根据旧值更新一个值"><a href="#根据旧值更新一个值" class="headerlink" title="根据旧值更新一个值"></a>根据旧值更新一个值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br></pre></td></tr></table></figure><p>这里 or_insert 返回的是一个可变引用，指向刚 entry 方法插入的键对应的值</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>HashMap 默认使用一种叫做 SipHash 的哈希函数，它可以抵御涉及哈希表（hash table）<a href="https://kaisery.github.io/trpl-zh-cn/ch08-03-hash-maps.html#siphash">1</a> 的拒绝服务（Denial of Service, DoS）攻击。然而这并不是可用的最快的算法，不过为了更高的安全性值得付出一些性能的代价。如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 <em>hasher</em> 来切换为其它函数。hasher 是一个实现了 BuildHasher trait 的类型。我们并不需要从头开始实现你自己的 hasher；crates.io 上有许多常用哈希算法的 hasher 的库。</p><h3 id="HashMap-key-的限制"><a href="#HashMap-key-的限制" class="headerlink" title="HashMap key 的限制"></a>HashMap key 的限制</h3><p>任何实现了 Eq 和 Hash 特征的类型都可以用于 HashMap 的 key，包括:</p><ul><li>bool (虽然很少用到，因为它只能表达两种 key)</li><li>int, uint 以及它们的变体，例如 u8、i32 等</li><li>String 和 &amp;str (提示: HashMap 的 key 是 String 类型时，你其实可以使用 &amp;str 配合 get 方法进行查询</li></ul><p>需要注意的是，f32 和 f64 并没有实现 Hash，原因是 <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems">浮点数精度</a> 的问题会导致它们无法进行相等比较。</p><p>如果一个集合类型的所有字段都实现了 Eq 和 Hash,那该集合类型会自动实现 Eq 和 Hash。例如 Vec<T> 要实现 Hash，那么首先需要 T 实现 Hash。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提示: `derive` 是实现一些常用特征的好办法</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Hash, Eq, PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Viking</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    country: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Viking</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="type">str</span>, country: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Viking &#123;</span><br><span class="line">        Viking &#123;</span><br><span class="line">            name: name.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            country: country.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用 HashMap 来存储 viking 的生命值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vikings</span> = HashMap::<span class="title function_ invoke__">from</span>([</span><br><span class="line">        (Viking::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Einar&quot;</span>, <span class="string">&quot;Norway&quot;</span>), <span class="number">25</span>),</span><br><span class="line">        (Viking::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Olaf&quot;</span>, <span class="string">&quot;Denmark&quot;</span>), <span class="number">24</span>),</span><br><span class="line">        (Viking::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Harald&quot;</span>, <span class="string">&quot;Iceland&quot;</span>), <span class="number">12</span>),</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 derive 的方式来打印 viking 的当前状态</span></span><br><span class="line">    <span class="keyword">for</span> (viking, health) <span class="keyword">in</span> &amp;vikings &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; has &#123;&#125; hp&quot;</span>, viking, health);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容量-1"><a href="#容量-1" class="headerlink" title="容量"></a>容量</h3><p>关于容量，我们在之前的 Vector 中有详细的介绍，而 HashMap 也可以调整容量: 你可以通过 HashMap::with_capacity(uint) 使用指定的容量来初始化，或者使用 HashMap::new() ，后者会提供一个默认的初始化容量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt; = HashMap::<span class="title function_ invoke__">with_capacity</span>(<span class="number">100</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 事实上，虽然我们使用了 100 容量来初始化，但是 map 的容量很可能会比 100 更多</span></span><br><span class="line">    <span class="built_in">assert!</span>(map.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对容量进行收缩，你提供的值仅仅是一个允许的最小值，实际上，Rust 会根据当前存储的数据量进行自动设置，当然，这个值会尽量靠近你提供的值，同时还可能会预留一些调整空间</span></span><br><span class="line"></span><br><span class="line">    map.<span class="title function_ invoke__">shrink_to</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(map.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让 Rust  自行调整到一个合适的值，剩余策略同上</span></span><br><span class="line">    map.<span class="title function_ invoke__">shrink_to_fit</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(map.<span class="title function_ invoke__">capacity</span>() &gt;= <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>对于实现了 Copy 特征的类型，例如 i32，那类型的值会被拷贝到 HashMap 中。而对于有所有权的类型，例如 String，它们的值的所有权将被转移到 HashMap 中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">v1</span> = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m1</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">  m1.<span class="title function_ invoke__">insert</span>(v1, v1);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;</span>, v1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="variable">v2</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m2</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">  <span class="comment">// 所有权在这里发生了转移</span></span><br><span class="line">  m2.<span class="title function_ invoke__">insert</span>(v2, v1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert_eq!</span>(v2, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方-Hash-库"><a href="#第三方-Hash-库" class="headerlink" title="第三方 Hash 库"></a>第三方 Hash 库</h3><p>在开头，我们提到过如果现有的 SipHash 1-3 的性能无法满足需求，那么可以使用社区提供的替代算法。</p><p>例如其中一个社区库的使用方式如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::hash::BuildHasherDefault;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="comment">// 引入第三方的哈希函数</span></span><br><span class="line"><span class="keyword">use</span> twox_hash::XxHash64;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hash</span>: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = <span class="built_in">Default</span>::<span class="title function_ invoke__">default</span>();</span><br><span class="line">hash.<span class="title function_ invoke__">insert</span>(<span class="number">42</span>, <span class="string">&quot;the answer&quot;</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(hash.<span class="title function_ invoke__">get</span>(&amp;<span class="number">42</span>), <span class="title function_ invoke__">Some</span>(&amp;<span class="string">&quot;the answer&quot;</span>));</span><br></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>大部分情况下，在编译时提示错误，并处理</p><p><strong>错误的分类</strong></p><ul><li>可恢复:</li></ul><p>例如文件未找到，可再次尝试</p><ul><li>不可恢复</li></ul><p>bug,例如访问索引超出范围</p><p><strong>Rust 没有类似 C++/Java 的异常机制</strong></p><ul><li>可恢复的错误:<strong>Result<T,E></strong></li><li>不可恢复:panic!宏</li></ul><h2 id="不可恢复的错误与-panic"><a href="#不可恢复的错误与-panic" class="headerlink" title="不可恢复的错误与 panic!"></a>不可恢复的错误与 panic!</h2><p>当 panic!宏执行</p><ul><li><strong>程序打印一个错误信息</strong></li><li><strong>展开(unwind),清理调用栈(Stack)</strong></li><li><strong>退出程序</strong></li></ul><h3 id="panic-‘abort’"><a href="#panic-‘abort’" class="headerlink" title="panic = ‘abort’"></a>panic = ‘abort’</h3><p>默认情况下，当 panic 发生</p><ul><li>程序展开调用栈(工作量大)</li></ul><p>Rust 沿着调用栈往回走，清理每个遇到的函数中的数据</p><ul><li>或立即中止调用栈 abort</li></ul><p>不进行清理，直接停止程序，内存需要由 OS 进行清理</p><p><strong>想让二进制文件更小，把设置从“展开”改为“中止”</strong></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">panic</span> = <span class="string">&#x27;abort&#x27;</span></span><br></pre></td></tr></table></figure><p>自己写的代码中内 panic</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以依赖的代码中：外部 panic</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">vector</span>=<span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    vector[<span class="number">100</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Compiling demo v0.1.0 (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.18s</span><br><span class="line">     Running `target\debug\demo.exe`</span><br><span class="line">thread <span class="string">&#x27;main&#x27;</span> panicked at <span class="string">&#x27;index out of bounds: the len is 3 but the index is 100&#x27;</span>, src\main.rs:3:5</span><br><span class="line">note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace</span><br><span class="line">error: process didn<span class="string">&#x27;t exit successfully: `target\debug\demo.exe` (exit code: 101)</span></span><br></pre></td></tr></table></figure><h3 id="通过调用-panic-的函数的回溯信息来定位引起问题的代码"><a href="#通过调用-panic-的函数的回溯信息来定位引起问题的代码" class="headerlink" title="通过调用 panic!的函数的回溯信息来定位引起问题的代码"></a>通过调用 panic!的函数的回溯信息来定位引起问题的代码</h3><p>使用以下命令运行代码(Windows cmd)</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> RUST_BACKTRACE=<span class="number">1</span> &amp;&amp; cargo run</span><br></pre></td></tr></table></figure><p>Windows Poweshell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$Env:RUST_BACKTRACE</span>=<span class="number">1</span> <span class="operator">-and</span> (cargo run)</span><br></pre></td></tr></table></figure><p>linux 下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> RUST_BACKTRACE=1 &amp;&amp; cargo run</span><br></pre></td></tr></table></figure><p>更详细的信息</p><p><strong>RUST_BACKTRACE=full</strong></p><p>为了获取带有调试信息的回溯，必须启用调试符号(不带—release)</p><h2 id="Result-枚举与可恢复的错误"><a href="#Result-枚举与可恢复的错误" class="headerlink" title="Result 枚举与可恢复的错误"></a>Result 枚举与可恢复的错误</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T 代表成功时返回的 Ok 成员中的数据的类型，</p><p>而 E 代表失败时返回的 Err 成员中的错误的类型</p><p>Result 及其变体也是由 prelude 带入作用域的</p><p>打开文件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配不同的错误"><a href="#匹配不同的错误" class="headerlink" title="匹配不同的错误"></a>匹配不同的错误</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>unrap_or_else()</strong> 和 <strong>闭包（closure）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">        <span class="keyword">if</span> error.<span class="title function_ invoke__">kind</span>() == ErrorKind::NotFound &#123;</span><br><span class="line">            File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap_or_else</span>(|error| &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unwrap"><a href="#unwrap" class="headerlink" title="unwrap"></a>unwrap</h3><p>match 表达式的一个快捷方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, error),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 Result 结果是 Ok，返回 Ok 里面的值</li><li>如果 Result 结果是 Err,调用 panic!宏</li></ul><h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><p>可自定义错误信息的 unwrap</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h2><p>将错误传播给调用者</p><p><strong>自定义实现</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="？运算符"><a href="#？运算符" class="headerlink" title="？运算符"></a>？运算符</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>? 被定义为与自定义传播错误的示例中定义的处理 Result 值的 match 表达式有着完全相同的工作方式。</p><p>如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将继续执行。</p><p>如果值是 Err，Err 中的值将作为整个函数的返回值，<strong>就好像使用了</strong> <strong>return</strong> <strong>关键字一样</strong>，这样错误值就被传播给了调用者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_file2</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="title function_ invoke__">read_file1</span>().<span class="title function_ invoke__">unwrap_err</span>().<span class="title function_ invoke__">to_string</span>(), <span class="title function_ invoke__">read_file2</span>().<span class="title function_ invoke__">unwrap_err</span>().<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="？与-from-函数"><a href="#？与-from-函数" class="headerlink" title="？与 from 函数"></a>？与 from 函数</h2><p>Trait std::convert::From 上的 from 函数</p><ul><li>用于错误之间的转换</li><li>被？所应用的错误，会隐式地被 from 函数处理</li><li>当? 调用 from 函数时:</li></ul><p>它所接收地错误类型会被转化为当前函数返回类型所定义的错误类型</p><p>用于: <strong>针对不同的错误原因，返回同一种错误类型</strong></p><p>只要每个错误类型实现了转换为所返回的错误类型的 from 函数</p><p>可以在 ? 之后直接使用<strong>链式方法调用</strong>来进一步缩短代码</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Io</span>(io::Error),</span><br><span class="line">    Parse,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 MyError 实现 Display（可选但常用）</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            MyError::<span class="title function_ invoke__">Io</span>(e) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;IO error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">            MyError::Parse =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse error&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> MyError &#123;</span><br><span class="line">        MyError::<span class="title function_ invoke__">Io</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="？与-main-函数"><a href="#？与-main-函数" class="headerlink" title="？与 main 函数"></a>？与 main 函数</h2><p>main 函数的返回类型为()类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map，and-then"><a href="#map，and-then" class="headerlink" title="map，and_then"></a>map，and_then</h2><p><strong>map 示例 —— 修改 <code>Ok</code> 里的值</strong></p><p>只处理 <code>Ok</code> 的值并返回新的 <code>Result</code>，不会改变错误类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">map</span>(|n| n * <span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(y, <span class="title function_ invoke__">Ok</span>(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>如果是错误呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">Result</span>&lt;<span class="type">i32</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">map</span>(|n| n * <span class="number">3</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(y, <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error&quot;</span>));  <span class="comment">// 错误会原样返回</span></span><br></pre></td></tr></table></figure><p><strong>and_then 示例 —— 链式 Result 操作</strong></p><p><code>and_then</code>处理 <code>Ok</code>，并继续返回一个 <code>Result</code>（链式逻辑）， 适合把多个可能出错的步骤串起来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">sq_then_to_string</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(<span class="string">&quot;negative&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>((x * x).<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">Ok</span>(<span class="number">3</span>).<span class="title function_ invoke__">and_then</span>(sq_then_to_string);</span><br><span class="line"><span class="built_in">assert_eq!</span>(result, <span class="title function_ invoke__">Ok</span>(<span class="string">&quot;9&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br></pre></td></tr></table></figure><p>如果出错，自动停止链式计算：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;bad&quot;</span>).<span class="title function_ invoke__">and_then</span>(sq_then_to_string);</span><br><span class="line"><span class="built_in">assert_eq!</span>(result, <span class="title function_ invoke__">Err</span>(<span class="string">&quot;bad&quot;</span>));</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With the return type rewritten, we use pattern matching without `unwrap()`.</span></span><br><span class="line"><span class="comment">// But it&#x27;s so Verbose..</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">multiply</span>(n1_str: &amp;<span class="type">str</span>, n2_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> n1_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n1)  =&gt; &#123;</span><br><span class="line">            <span class="keyword">match</span> n2_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(n2)  =&gt; &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(n1 * n2)</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rewriting `multiply` to make it succinct</span></span><br><span class="line"><span class="comment">// You  MUST USING `and_then` and `map` here</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">multiply1</span>(n1_str: &amp;<span class="type">str</span>, n2_str: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="comment">// IMPLEMENT...</span></span><br><span class="line">    n1_str.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">and_then</span>(|n1| &#123;</span><br><span class="line">        n2_str.parse::&lt;<span class="type">i32</span>&gt;().<span class="title function_ invoke__">map</span>(|n2| n1 * n2)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>(result: <span class="type">Result</span>&lt;<span class="type">i32</span>, ParseIntError&gt;) &#123;</span><br><span class="line">    <span class="keyword">match</span> result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(n)  =&gt; <span class="built_in">println!</span>(<span class="string">&quot;n is &#123;&#125;&quot;</span>, n),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error: &#123;&#125;&quot;</span>, e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// This still presents a reasonable answer.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">twenty</span> = <span class="title function_ invoke__">multiply1</span>(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print</span>(twenty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following now provides a much more helpful error message.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tt</span> = <span class="title function_ invoke__">multiply</span>(<span class="string">&quot;t&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print</span>(tt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="何时-panic"><a href="#何时-panic" class="headerlink" title="何时 panic!"></a>何时 panic!</h2><h3 id="总体原则"><a href="#总体原则" class="headerlink" title="总体原则"></a><strong>总体原则</strong></h3><ul><li>在定义一个<strong>可能失败的函数时，优先考虑返回 Result</strong></li><li>否则就 panic!</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>演示某些概念：unwrap</li><li>原型代码:unwrap,expect</li><li>测试:unwrap,expect</li></ul><p><strong>有时你比编译器掌握更多的信息</strong></p><ul><li>你可以确定 Result 就是 Ok:<strong>unwrap</strong></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::net::IpAddr;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">home</span>: IpAddr = <span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>调用你的代码，传入无意义的参数值:<strong>panic!</strong></p><ul><li><p>调用外部不可控代码，返回非法状态，你无法修复:<strong>panic!</strong></p></li><li><p>如果失败是可预期的：<strong>Result</strong></p></li><li><p>当你的代码对值进行操作，首先应该验证这些值:<strong>panic!</strong> （assert!）</p></li></ul><h3 id="创建自定义类型进行有效性验证"><a href="#创建自定义类型进行有效性验证" class="headerlink" title="创建自定义类型进行有效性验证"></a>创建自定义类型进行有效性验证</h3><p>一种实现方式是将猜测解析成 i32 而不仅仅是 u32，来默许输入负数，接着检查数字是否在范围内：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">i32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess &lt; <span class="number">1</span> || guess &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The secret number will be between 1 and 100.&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>if 表达式检查了值是否超出范围，告诉用户出了什么问题，并调用 continue 开始下一次循环，请求另一个猜测。if 表达式之后，就可以在知道 guess 在 1 到 100 之间的情况下与秘密数字作比较了。</p><p>相反我们可以创建一个新类型来将验证放入创建其实例的函数中，而不是到处重复这些检查。这样就可以安全的在函数签名中使用新类型并相信他们接收到的值。示例 中展示了一个定义 Guess 类型的方法，只有在 new 函数接收到 1 到 100 之间的值时才会创建 Guess 的实例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们实现了一个借用了 self 的方法 value，它没有任何其他参数并返回一个 i32。这类方法有时被称为 <em>getter</em>，因为它的目的就是返回对应字段的数据。这样的公有方法是必要的，因为 Guess 结构体的 value 字段是私有的。私有的字段 value 是很重要的，这样使用 Guess 结构体的代码将不允许直接设置 value 的值：调用者 <strong>必须</strong> 使用 Guess::new 方法来创建一个 Guess 的实例，这就确保了不会存在一个 value 没有通过 Guess::new 函数的条件检查的 Guess。</p><p>于是，一个接收（或返回） 1 到 100 之间数字的函数就可以声明为接收（或返回） Guess 的实例，而不是 i32，同时其函数体中也无需进行任何额外的检查。</p><h2 id="在-fn-main-中使用-Result"><a href="#在-fn-main-中使用-Result" class="headerlink" title="在 fn main 中使用 Result"></a>在 fn main 中使用 Result</h2><p>一个典型的 main 函数长这样:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上 main 函数还可以返回一个 Result 类型：如果 main 函数内部发生了错误，那该错误会被返回并且打印出一条错误的 debug 信息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_str</span> = <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">match</span> number_str.parse::&lt;<span class="type">i32</span>&gt;() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(number)  =&gt; number,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, number);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="函数中定义泛型"><a href="#函数中定义泛型" class="headerlink" title="函数中定义泛型"></a>函数中定义泛型</h2><p>寻找 vec 中的最大值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_i32</span>(list: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">largest_char</span>(list: &amp;[<span class="type">char</span>]) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest_i32</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest_char</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用泛型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiling demo v0.1.0 (C:\Users\cauchy\Desktop\rust\demo)</span><br><span class="line">error[E0369]: binary operation `&gt;` cannot be applied to type `T`</span><br><span class="line"> --&gt; src\main.rs:5:17</span><br><span class="line">  |</span><br><span class="line">5 |         if item &gt; largest &#123;</span><br><span class="line">  |            ---- ^ ------- T</span><br><span class="line">  |            |</span><br><span class="line">  |            T</span><br><span class="line">  |</span><br><span class="line">help: consider restricting type parameter `T`</span><br><span class="line">  |</span><br><span class="line">1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">  |             ++++++++++++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0369`.</span><br><span class="line">error: could not compile `demo` due to previous error</span><br></pre></td></tr></table></figure><p>简单来说，这个错误表明 largest 的函数体不能适用于 T 的所有可能的类型</p><p>因为在函数体需要比较 T 类型的值，不过它只能用于我们知道如何排序的类型。为了开启比较功能，标准库中定义的 std::cmp::PartialOrd trait 可以实现类型的比较功能.</p><p>修改：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="built_in">PartialOrd</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> *item &gt; *largest &#123;<span class="comment">// 这里不用加*也可以，因为rust为引用类型实现了PartialOrd,前提是被引用的类型 T: PartialOrd</span></span><br><span class="line"></span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体中定义泛型"><a href="#结构体中定义泛型" class="headerlink" title="结构体中定义泛型"></a>结构体中定义泛型</h2><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举中定义泛型"><a href="#枚举中定义泛型" class="headerlink" title="枚举中定义泛型"></a>枚举中定义泛型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举也可以拥有多个泛型类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法定义中的泛型"><a href="#方法定义中的泛型" class="headerlink" title="方法定义中的泛型"></a>方法定义中的泛型</h2><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把 T 放在 impl 关键字后,表示在类型 T 上实现方法:impl<T> Point<T></li><li>只针对具体类型实现方法:impl Point<f32></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point&#123;x: <span class="number">5.0_f32</span>, y: <span class="number">10.0_f32</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,p.<span class="title function_ invoke__">distance_from_origin</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct 里的泛型类型参数可以和方法的泛型类型参数不同</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;X1, Y1&gt; &#123;</span><br><span class="line">    x: X1,</span><br><span class="line">    y: Y1,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">mixup</span>&lt;X2, Y2&gt;(<span class="keyword">self</span>, other: Point&lt;X2, Y2&gt;) <span class="punctuation">-&gt;</span> Point&lt;X1, Y2&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123; x: <span class="string">&quot;Hello&quot;</span>, y: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = p1.<span class="title function_ invoke__">mixup</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const-泛型"><a href="#const-泛型" class="headerlink" title="const 泛型"></a>const 泛型</h2><p>针对类型实现的泛型，所有的泛型都是为了抽象不同的类型，那有没有针对值的泛型？答案就是 Const 泛型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ArrayPair</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    left: [T; N],</span><br><span class="line">    right: [T; N],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; <span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">ArrayPair</span>&lt;T, N&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;<span class="keyword">const</span> N: <span class="type">usize</span>&gt;() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>&lt;T, <span class="keyword">const</span> M: <span class="type">usize</span>&gt;() &#123;</span><br><span class="line">    foo::&lt;M&gt;(); <span class="comment">// ok: 符合第一种</span></span><br><span class="line">    foo::&lt;<span class="number">2021</span>&gt;(); <span class="comment">// ok: 符合第二种</span></span><br><span class="line">    foo::&lt;&#123;<span class="number">20</span> * <span class="number">100</span> + <span class="number">20</span> * <span class="number">10</span> + <span class="number">1</span>&#125;&gt;(); <span class="comment">// ok: 符合第三种</span></span><br><span class="line"></span><br><span class="line">    foo::&lt;&#123; M + <span class="number">1</span> &#125;&gt;(); <span class="comment">// error: 违背第三种，const 表达式中不能有泛型参数 M</span></span><br><span class="line">    foo::&lt;&#123; std::mem::size_of::&lt;T&gt;() &#125;&gt;(); <span class="comment">// error: 泛型表达式包含了泛型参数 T</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span>: [<span class="type">u8</span>; M]; <span class="comment">// ok: 符合第一种</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_</span>: [<span class="type">u8</span>; std::mem::size_of::&lt;T&gt;()]; <span class="comment">// error: 泛型表达式包含了泛型参数 T</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前，const 泛型参数只能使用以下形式的实参:</p><ul><li><p>一个单独的 const 泛型参数</p></li><li><p>一个字面量 (i.e. 整数, 布尔值或字符).</p></li><li><p>一个具体的 const 表达式( 表达式中不能包含任何 泛型参数)</p></li></ul></li><li><p>const 泛型还能帮我们避免一些运行时检查，提升性能</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">MinSlice</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> head: [T; N],</span><br><span class="line">    <span class="keyword">pub</span> tail: [T],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">u8</span>] = <span class="string">b&quot;Hello, world&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference</span>: <span class="type">Option</span>&lt;&amp;<span class="type">u8</span>&gt; = slice.<span class="title function_ invoke__">get</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="comment">// 我们知道 `.get` 返回的是 `Some(b&#x27; &#x27;)`</span></span><br><span class="line">    <span class="comment">// 但编译器不知道</span></span><br><span class="line">    <span class="built_in">assert!</span>(reference.<span class="title function_ invoke__">is_some</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">u8</span>] = <span class="string">b&quot;Hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当编译构建 MinSlice 时会进行长度检查，也就是在编译期我们就知道它的长度是 12</span></span><br><span class="line">    <span class="comment">// 在运行期，一旦 `unwrap` 成功，在 `MinSlice` 的作用域内，就再无需任何检查</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">minslice</span> = MinSlice::&lt;<span class="type">u8</span>, <span class="number">12</span>&gt;::<span class="title function_ invoke__">from_slice</span>(slice).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span>: <span class="type">u8</span> = minslice.head[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(value, <span class="string">b&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`</p><p><T, const N: usize> 是结构体类型的一部分，和数组类型一样，这意味着长度不同会导致类型不同： <strong>Array<i32, 3> 和 Array<i32, 4> 是不同的类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Array</span>&lt;T, <span class="keyword">const</span> N: <span class="type">usize</span>&gt; &#123;</span><br><span class="line">    data : [T; N]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arrays</span> = [</span><br><span class="line">        Array&#123;</span><br><span class="line">            data: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        Array &#123;</span><br><span class="line">            data: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        Array &#123;</span><br><span class="line">            data: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填空</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填空</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_array</span>&lt;__&gt;(__) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">print_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line">    <span class="title function_ invoke__">print_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">print_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line">    <span class="title function_ invoke__">print_array</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时我们希望能<strong>限制一个变量占用内存的大小</strong>，例如在嵌入式环境中，此时 const 泛型参数的第三种形式 const 表达式 就非常适合:</p><p>下面的代码用到了 feature，需要 nightly 编译器</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(incomplete_features)]</span></span><br><span class="line"><span class="meta">#![feature(generic_const_exprs)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check_size</span>&lt;T&gt;(val: T)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; <span class="number">768</span> &#125;&gt;: IsTrue,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fix the errors in main</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([<span class="number">0u8</span>; <span class="number">767</span>]);</span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([<span class="number">0i32</span>; <span class="number">191</span>]);</span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([<span class="string">&quot;hello你好&quot;</span>; <span class="number">47</span>]); <span class="comment">// &amp;str is a string reference, containing a pointer and string length in it, so it takes two word long, in x86-64, 1 word = 8 bytes</span></span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([(); <span class="number">31</span>].<span class="title function_ invoke__">map</span>(|_| <span class="string">&quot;hello你好&quot;</span>.<span class="title function_ invoke__">to_string</span>()));  <span class="comment">// String is a smart pointer struct, it has three fields: pointer, length and capacity, each takes 8 bytes</span></span><br><span class="line">    <span class="title function_ invoke__">check_size</span>([<span class="string">&#x27;中&#x27;</span>; <span class="number">191</span>]); <span class="comment">// A char takes 4 bytes in Rust</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Assert</span>&lt;<span class="keyword">const</span> CHECK: <span class="type">bool</span>&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">IsTrue</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IsTrue</span> <span class="keyword">for</span> <span class="title class_">Assert</span>&lt;<span class="literal">true</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型代码的性能"><a href="#泛型代码的性能" class="headerlink" title="泛型代码的性能"></a>泛型代码的性能</h2><p>Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。</p><p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>（<em>monomorphization</em>）来保证效率。<strong>单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fn main()&#123;</span></span><br><span class="line"><span class="comment">//    let integer = Some(5);</span></span><br><span class="line"><span class="comment">//    let float = Some(5.0);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">i32</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Option_f64</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Option_i32::<span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Option_f64::<span class="title function_ invoke__">Some</span>(<span class="number">5.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时，rust 会将 Option 泛型展开为 Option<i32>和 Option<i64>类型</p><h1 id="Trait：定义共同行为"><a href="#Trait：定义共同行为" class="headerlink" title="Trait：定义共同行为"></a>Trait：定义共同行为</h1><p>trait 告诉 Rust 编译器，某种类型具有哪些并且可以与其他类型共享的功能</p><h2 id="定义一个-trait"><a href="#定义一个-trait" class="headerlink" title="定义一个 trait"></a>定义一个 trait</h2><p>把方法签名放在一起，来定义实现某种目的所必需的一组行为</p><ul><li>关键字：trait</li><li>只有方法签名，没有具体实现</li></ul><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在类型上实现-trait"><a href="#在类型上实现-trait" class="headerlink" title="在类型上实现 trait"></a>在类型上实现 trait</h2><p>与为类型实现方法类似</p><p>不同之处：impl Xxxx for Tweet{….}</p><p>文件: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件 src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> demo::&#123;Summary,Tweet&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tweet</span> = Tweet&#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebook&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;of course,sa you probably...&quot;</span>),</span><br><span class="line">        reply:<span class="literal">false</span>,</span><br><span class="line">        retweet:<span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new tweet:&#123;&#125;&quot;</span>,tweet.<span class="title function_ invoke__">summary</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo 就是 Cargo.toml 文件中的[package]项的 name</p><h2 id="实现-trait-的约束"><a href="#实现-trait-的约束" class="headerlink" title="实现 trait 的约束"></a>实现 trait 的约束</h2><p>可以在某个类型上实现某个 trait 的前提条件是:</p><ul><li>整个类型 <strong>或</strong> 这个 trait 是在本地 crate 里定义的</li></ul><p><strong>无法为外部类型实现外部 trait</strong></p><p>这个限制是被称为 <strong>相干性</strong>（<em>coherence</em>） 的程序属性的一部分，或者更具体的说是 <strong>孤儿规则</strong>（<em>orphan rule</em>），其得名于不存在父类型。这条规则确保了其他人编写的代码不会破坏你代码，反之亦然。没有这条规则的话，两个 crate 可以分别对相同类型实现相同的 trait，而 Rust 将无从得知应该使用哪一个实现。</p><p>简而言之：<strong>类型和 trait 都不是你写的</strong>，<strong>那你就没有资格给它们加 impl</strong>。</p><h2 id="trait-中的函数的默认实现"><a href="#trait-中的函数的默认实现" class="headerlink" title="trait 中的函数的默认实现"></a>trait 中的函数的默认实现</h2><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="comment">//fn summarize(&amp;self) -&gt; String &#123;</span></span><br><span class="line">    <span class="comment">//    format!(&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;, self.headline, self.author, self.location)</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="comment">//默认实现的重写的实现</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认实现允许调用相同 trait 中的其他方法</strong>，<strong>哪怕这些方法没有默认实现</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:无法从方法的重写实现里面调用默认的实现</p><h2 id="trait-作为参数"><a href="#trait-作为参数" class="headerlink" title="trait 作为参数"></a>trait 作为参数</h2><h3 id="impl-triat-语法："><a href="#impl-triat-语法：" class="headerlink" title="impl triat 语法："></a>impl triat 语法：</h3><p>适用于简单情况,是 trait bound 的语法糖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait-bound-语法："><a href="#trait-bound-语法：" class="headerlink" title="trait bound 语法："></a>trait bound 语法：</h3><p>适用于复杂情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item1: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>, item2: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这适用于 item1 和 item2 允许是不同类型的情况（只要它们都实现了 Summary）。不过如果你希望强制它们都是相同类型呢？这只有在使用 trait bound 时才有可能：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-指定多个-traint-bound"><a href="#使用-指定多个-traint-bound" class="headerlink" title="使用+指定多个 traint bound"></a>使用+指定多个 traint bound</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-where-简化-trait-bound"><a href="#使用-where-简化-trait-bound" class="headerlink" title="使用 where 简化 trait bound"></a>使用 where 简化 trait bound</h3><p>fn some_function<T: Display + Clone, U: Clone + Debug>(t: &amp;T, u: &amp;U) -&gt; i32 {</p><p>使用 where 从句</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="返回实现了-trait-的类型"><a href="#返回实现了-trait-的类型" class="headerlink" title="返回实现了 trait 的类型"></a>返回实现了 trait 的类型</h2><p>也可以在返回值中使用 impl Trait 语法，来返回实现了某个 trait 的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这只适用于<strong>返回单一类型的情况</strong>。例如，这段代码的返回值类型指定为返回 impl Summary，但是返回了 NewsArticle 或 Tweet 就行不通：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>(switch: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> switch &#123;</span><br><span class="line">        NewsArticle &#123;</span><br><span class="line">            headline: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;Penguins win the Stanley Cup Championship!&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            location: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Pittsburgh, PA, USA&quot;</span>),</span><br><span class="line">            author: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Iceburgh&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;The Pittsburgh Penguins once again are the best \</span></span><br><span class="line"><span class="string">                 hockey team in the NHL.&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tweet &#123;</span><br><span class="line">            username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">                <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">            ),</span><br><span class="line">            reply: <span class="literal">false</span>,</span><br><span class="line">            retweet: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尝试返回 NewsArticle 或 Tweet。这不能编译，因为 impl Trait 工作方式的限制。</p><p>可以使用 dyn trait 对象</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sheep</span> &#123;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cow</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Sheep</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;baaaaah!&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Cow</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">noise</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;moooooo!&quot;</span>.<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个类型，该类型实现了 Animal 特征，但是我们并不能在编译期获知具体返回了哪个类型</span></span><br><span class="line"><span class="comment">// 修复这里的错误，你可以使用虚假的随机，也可以使用特征对象</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">random_animal</span>(random_number: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Animal&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> random_number &lt; <span class="number">0.5</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Sheep &#123;&#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Cow &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">random_number</span> = <span class="number">0.234</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">animal</span> = <span class="title function_ invoke__">random_animal</span>(random_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;</span>, animal.<span class="title function_ invoke__">noise</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特征对象-在数组中使用特征对象"><a href="#特征对象-在数组中使用特征对象" class="headerlink" title="特征对象,在数组中使用特征对象"></a>特征对象,在数组中使用特征对象</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">quack</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Duck</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Look, the duck is flying&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Swan</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Swan</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Look, the duck.. oh sorry, the swan is flying&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Bird</span> <span class="keyword">for</span> <span class="title class_">Duck</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">quack</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;duck duck&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Bird</span> <span class="keyword">for</span> <span class="title class_">Swan</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">quack</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;swan swan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 填空</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">birds</span> :[<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Bird&gt;;<span class="number">2</span>]=[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Duck&#123;&#125;),<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Swan&#123;&#125;)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">bird</span> <span class="keyword">in</span> birds &#123;</span><br><span class="line">        bird.<span class="title function_ invoke__">quack</span>();</span><br><span class="line">        <span class="comment">// 当 duck 和 swan 变成 bird 后，它们都忘了如何翱翔于天际，只记得该怎么叫唤了。。</span></span><br><span class="line">        <span class="comment">// 因此，以下代码会报错</span></span><br><span class="line">        <span class="comment">// bird.fly();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-dyn-和-Box"><a href="#amp-dyn-和-Box" class="headerlink" title="&amp;dyn 和 Box"></a>&amp;dyn 和 Box<dyn></h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;u8: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;f64: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1.1f64</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">8u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw x</span></span><br><span class="line">    <span class="title function_ invoke__">draw_with_box</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// draw y</span></span><br><span class="line">    <span class="title function_ invoke__">draw_with_ref</span>(&amp;y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_with_box</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw_with_ref</span>(x: &amp;<span class="keyword">dyn</span> Draw) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态分发和动态分发-Static-and-Dynamic-dispatch"><a href="#静态分发和动态分发-Static-and-Dynamic-dispatch" class="headerlink" title="静态分发和动态分发 Static and Dynamic dispatch"></a>静态分发和动态分发 Static and Dynamic dispatch</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">method</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">method</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="built_in">format!</span>(<span class="string">&quot;u8: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">method</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="built_in">format!</span>(<span class="string">&quot;string: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement below with generics</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_dispatch</span>&lt;T: Foo&gt;(x: T) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">method</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// implement below with trait objects</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dynamic_dispatch</span>(x: &amp;<span class="keyword">dyn</span> Foo) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">method</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5u8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="string">&quot;Hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">static_dispatch</span>(x);</span><br><span class="line">    <span class="title function_ invoke__">dynamic_dispatch</span>(&amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-trait-bounds-来修复-largest-函数"><a href="#使用-trait-bounds-来修复-largest-函数" class="headerlink" title="使用 trait bounds 来修复 largest 函数"></a>使用 trait bounds 来修复 largest 函数</h2><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_list</span> = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest number is &#123;&#125;&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_list</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;q&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest char is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果并不希望限制 largest 函数只能用于实现了 Copy trait 的类型，我们可以在 T 的 trait bounds 中指定 Clone 而不是 Copy。并克隆 slice 的每一个值使得 largest 函数拥有其所有权。使用 clone 函数意味着对于类似 String 这样拥有堆上数据的类型，会潜在的分配更多堆上空间，而堆分配在涉及大量数据时可能会相当缓慢。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = list[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; &amp;largest &#123;</span><br><span class="line">            largest = item.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_list</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;str_list)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest word is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者 largest 直接返回一个引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Clone</span>&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">largest</span> = &amp;list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">item</span> <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; &amp;largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_list</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">largest</span>(&amp;str_list)</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The largest word is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-trait-bound-有条件地实现方法"><a href="#使用-trait-bound-有条件地实现方法" class="headerlink" title="使用 trait bound 有条件地实现方法"></a>使用 trait bound 有条件地实现方法</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为满足 trait bound 的所有类型上实现 trait 叫做<strong>覆盖实现(blanket implementations)</strong></p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">impl&lt;T: Display&gt; ToString for T &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为标准库有了这些 blanket implementation，我们可以对任何实现了 Display trait 的类型调用由 ToString 定义的 to_string 方法。例如，可以将整型转换为对应的 String 值，因为整型实现了 Display：</p><p>let s = 3.to_string();</p><h2 id="Derive-宏派生实现"><a href="#Derive-宏派生实现" class="headerlink" title="Derive 宏派生实现"></a>Derive 宏派生实现</h2><p>我们可以使用 #[derive] 属性来派生一些特征，对于这些特征编译器会自动进行默认实现，对于日常代码开发而言，这是非常方便的，例如大家经常用到的 Debug 特征，就是直接通过派生来获取默认实现，而无需我们手动去完成这个工作。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Centimeters`, 一个元组结构体，可以被比较大小</span></span><br><span class="line"><span class="meta">#[derive(PartialEq, PartialOrd)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Centimeters</span>(<span class="type">f64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `Inches`, 一个元组结构体可以被打印</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Inches</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Inches</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">to_centimeters</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> Centimeters &#123;</span><br><span class="line">        <span class="keyword">let</span> &amp;<span class="title function_ invoke__">Inches</span>(inches) = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Centimeters</span>(inches <span class="keyword">as</span> <span class="type">f64</span> * <span class="number">2.54</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一些属性让代码工作</span></span><br><span class="line"><span class="comment">// 不要修改其它代码！</span></span><br><span class="line"><span class="meta">#[derive(Debug,PartialEq,PartialOrd)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seconds</span>(<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_one_second</span> = <span class="title function_ invoke__">Seconds</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;One second looks like: &#123;:?&#125;&quot;</span>, _one_second);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_this_is_true</span> = _one_second == _one_second;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_this_is_true</span> = _one_second &gt; _one_second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">foot</span> = <span class="title function_ invoke__">Inches</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;One foot equals &#123;:?&#125;&quot;</span>, foot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">meter</span> = <span class="title function_ invoke__">Centimeters</span>(<span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cmp</span> =</span><br><span class="line">        <span class="keyword">if</span> foot.<span class="title function_ invoke__">to_centimeters</span>() &lt; meter &#123;</span><br><span class="line">            <span class="string">&quot;smaller&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="string">&quot;bigger&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;One foot is &#123;&#125; than one meter.&quot;</span>, cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul><li>Rust 的每个引用都有自己的生命周期</li><li><strong>生命周期：引用保持有效的作用域</strong></li><li>大多数情况下：生命周期是隐式的，可被推断的</li><li>当引用的生命周期可能以不同的方式互相关联时：手动标注生命周期</li></ul><p>生命周期存在的目标是:<strong>避免悬空引用</strong></p><p>尝试使用离开作用域的值的引用会失败</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">           r = &amp;x;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="借用检查器"><a href="#借用检查器" class="headerlink" title="借用检查器"></a>借用检查器</h2><p>Rust 编译器有一个 <strong>借用检查器</strong>（<em>borrow checker</em>），它比较作用域来确保所有的借用都是有效的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                             <span class="comment">//          |</span></span><br><span class="line">       &#123;                     <span class="comment">//          |</span></span><br><span class="line">           <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">           r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">       &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                             <span class="comment">//          |</span></span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//          |</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里将 r 的生命周期标记为 ‘a 并将 x 的生命周期标记为 ‘b。如你所见，内部的 ‘b 块要比外部的生命周期 ‘a 小得多。在编译时，Rust 比较这两个生命周期的大小，并发现 r 拥有生命周期 ‘a，不过它引用了一个拥有生命周期 ‘b 的对象。程序被拒绝编译，因为生命周期 ‘b 比生命周期 ‘a 要小：被引用的对象比它的引用者存在的时间更短。</p><h2 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"> --&gt; src\main.rs:1:33</span><br><span class="line">  |</span><br><span class="line">1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;</span><br><span class="line">  |               ----     ----     ^ expected named lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = <span class="built_in">help</span>: this <span class="keyword">function</span><span class="string">&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span></span><br><span class="line"><span class="string">help: consider introducing a named lifetime parameter</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">1 | fn longest&lt;&#x27;</span>a&gt;(x: &amp;<span class="string">&#x27;a str, y: &amp;&#x27;</span>a str) -&gt; &amp;<span class="string">&#x27;a str &#123;</span></span><br><span class="line"><span class="string">  |           ++++     ++          ++          ++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0106`.</span></span><br><span class="line"><span class="string">error: could not compile `demo` due to previous error</span></span><br></pre></td></tr></table></figure><p>标识生命周期</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示返回值的生命周期是传入参数的两个引用的生命周期的重叠部分。</p><h2 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h2><ul><li>生命周期的标注不会改变引用的生命周期的长度</li><li>当制定了泛型生命周期参数，函数可以接受带有任何生命周期的引用</li><li>生命周期的标注：<strong>描述了多个引用的生命周期的关系，但不影响生命周期</strong></li><li><p>生命周期的参数名: 以 ‘ 开头，通常全小写且非常短，很多人使用 ‘a</p></li><li><p>生命周期标注的位置</p></li></ul><p><strong>在引用的&amp;符号后</strong>，使用空格将标注和引用类型分开</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 带有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 带有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><p>泛型生命周期参数声明在:<strong>函数名和参数列表之间的&lt;&gt;里</strong></p><p>fn longest&lt;’a&gt;(x: &amp;’a str, y: &amp;’a str) -&gt; &amp;’a str {</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实际含义是 longest 函数返回的引用的生命周期与传入该函数的引用的生命周期的较小者一致。</p><p>记住通过在函数签名中指定生命周期参数时，我们并没有改变任何传入值或返回值的生命周期，而是指出任何不满足这个约束条件的值都将被借用检查器拒绝。注意 longest 函数并不需要知道 x 和 y 具体会存在多久，而只需要知道有某个可以被 ‘a 替代的作用域将会满足这个签名。</p><p>当具体的引用被传递给 longest 时，被 ‘a 所替代的具体生命周期是 x 的作用域与 y 的作用域<strong>相重叠的那一部分</strong>。换一种说法就是泛型生命周期 ‘a 的具体生命周期等同于 x 和 y 的生命周期中<strong>较小的那一个</strong>。因为我们用相同的生命周期参数 ‘a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。</p><p>使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，string1 直到外部作用域结束都是有效的，string2 则在内部作用域中是有效的，而 result 则引用了一些直到内部作用域结束都是有效的值。借用检查器认可这些代码；它能够编译和运行，并打印出 The longest string is long string is long。</p><p>修改</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;long string is long&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">        result = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行出错</p><p>错误表明为了保证 println! 中的 result 是有效的，string2 需要直到外部作用域结束都是有效的。Rust 知道这些是因为（longest）函数的参数和返回值都使用了相同的生命周期参数 ‘a。</p><h2 id="深入理解声明周期"><a href="#深入理解声明周期" class="headerlink" title="深入理解声明周期"></a>深入理解声明周期</h2><ul><li><strong>指定生命周期参数的正确方式依赖函数实现的具体功能</strong></li></ul><p>如果将 longest 函数的实现修改为总是返回第一个参数而不是最长的字符串 slice，就不需要为参数 y 指定一个生命周期。如下代码将能够编译：</p><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。</strong></li></ul><p>如果返回的引用 <strong>没有</strong> 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;really long string&quot;</span>);</span><br><span class="line">    result.<span class="title function_ invoke__">as_str</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错</p><p>综上，生命周期语法是用于<strong>将函数的多个参数与其返回值的生命周期进行关联的</strong>。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。</p><h2 id="结构体定义中的生命周期注解"><a href="#结构体定义中的生命周期注解" class="headerlink" title="结构体定义中的生命周期注解"></a>结构体定义中的生命周期注解</h2><p>struct 里可包括：</p><ul><li>自持有类型</li><li>引用:需要在每个引用上添加声明周期标注</li></ul><p>文件名: src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示结构体的生命周期和其成员 part 的生命周期相同。</p><h2 id="生命周期的省略"><a href="#生命周期的省略" class="headerlink" title="生命周期的省略"></a>生命周期的省略</h2><p><strong>Lifetime Elision</strong></p><p>在 Rust 引用分析中所编入的模式称为<strong>生命周期省略规则</strong>（<em>lifetime elision rules</em>）</p><p>这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。</p><p>函数或方法的参数的生命周期被称为 <strong>输入生命周期</strong>（<em>input lifetimes</em>），而返回值的生命周期被称为 <strong>输出生命周期</strong>（<em>output lifetimes</em>）。</p><p>编译器采用<strong>三条规则</strong>来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则<strong>适用于</strong> <strong>fn</strong> <strong>定义，以及</strong> <strong>impl</strong> <strong>块</strong>。</p><ul><li><strong>规则 1</strong>：<strong>每个引用类型的参数都有自己的声明周期</strong></li><li><strong>规则 2</strong>：<strong>如果只有 1 个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数</strong></li><li><strong>规则 3</strong>：<strong>如果有多个输入生命周期参数，但其中一个是&amp;self 或&amp;mut self(是方法)，那么 self 的生命周期就会被赋给所有的输出生命周期参数</strong></li></ul><p>例子:</p><p>假设我们自己就是编译器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure><p>接着编译器应用第一条规则，也就是<strong>每个引用参数都有其自己的生命周期</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure><p>对于第二条规则，因为这里正好只有一个输入生命周期参数所以是适用的。第二条规则表明输入参数的生命周期将被赋予输出生命周期参数，所以现在签名看起来像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_word</span>&lt;<span class="symbol">&#x27;a</span>&gt;(s: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br></pre></td></tr></table></figure><p>现在这个函数签名中的所有引用都有了生命周期，如此编译器可以继续它的分析而无须程序员标记这个函数签名中的生命周期。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x:&amp;<span class="type">str</span>,y:&amp;<span class="type">str</span>)<span class="punctuation">-&gt;</span>&amp;<span class="type">str</span>&#123;</span><br></pre></td></tr></table></figure><p>应用第一条规则</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>,<span class="symbol">&#x27;b</span>&gt;(x:&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,y:&amp;<span class="symbol">&#x27;b</span> <span class="type">str</span>)<span class="punctuation">-&gt;</span>&amp;<span class="type">str</span>&#123;</span><br></pre></td></tr></table></figure><p>第二条规则不适用，第三条不适用，所以编译器报错</p><h2 id="方法定义中的生命周期标注"><a href="#方法定义中的生命周期标注" class="headerlink" title="方法定义中的生命周期标注"></a>方法定义中的生命周期标注</h2><p>当为带有生命周期的结构体实现方法时，其语法依然类似泛型类型参数的语法。</p><p>在哪里声明生命周期参数，依赖于：</p><ul><li><strong>生命周期参数是否同结构体字段或方法参数和返回值相关</strong>。</li></ul><p>struct 字段的生命周期名:</p><ul><li>在 impl 后声明</li><li>在 struct 名后使用</li><li>这些生命周期是 struct 类型的一部分</li></ul><p>impl 块内的方法签名中:</p><ul><li>引用必须绑定于 struct 字段引用的声明周期，或者引用是独立的也可以</li><li>生命周期省略规则经常使得方法中的生命周期标注不是必须的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt;&#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是一个适用于第三条生命周期省略规则的例子</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">announce_and_return_part</span>(&amp;<span class="keyword">self</span>, announcement: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);</span><br><span class="line">        <span class="keyword">self</span>.part</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael.Some year ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not found a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt&#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>announce_and_return_part 这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 &amp;self 和 announcement 他们各自的生命周期。接着，因为其中一个参数是 &amp;self，返回值类型被赋予了 &amp;self 的生命周期，这样所有的生命周期都被计算出来了。</p><h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p>‘static，其生命周期<strong>能够</strong>存活于整个程序期间。</p><p><strong>所有的字符串字面值都拥有</strong> <strong>‘static</strong> <strong>生命周期</strong></p><p>let s: &amp;’static str = “I have a static lifetime.”;</p><p>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 ‘static 的。</p><h2 id="结合泛型类型参数、trait-bounds-和生命周期"><a href="#结合泛型类型参数、trait-bounds-和生命周期" class="headerlink" title="结合泛型类型参数、trait bounds 和生命周期"></a>结合泛型类型参数、trait bounds 和生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest_with_an_announcement</span>&lt;<span class="symbol">&#x27;a</span>, T&gt;(</span><br><span class="line">    x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    ann: T,</span><br><span class="line">) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编写自动化测试"><a href="#编写自动化测试" class="headerlink" title="编写自动化测试"></a>编写自动化测试</h1><p>Rust 中的测试函数是用来验证非测试代码是否是按照期望的方式运行的。测试函数体通常执行如下三种操作：</p><ol><li>设置任何所需的数据或状态(Arrange)</li><li>运行需要测试的代码(Act)</li><li>断言（Assert）其结果是我们所期望的</li></ol><h2 id="测试函数剖析"><a href="#测试函数剖析" class="headerlink" title="测试函数剖析"></a>测试函数剖析</h2><h3 id="编写测试函数"><a href="#编写测试函数" class="headerlink" title="编写测试函数"></a>编写测试函数</h3><p>Rust 中的测试就是一个带有 test 属性注解的函数。属性（attribute）是关于 Rust 代码片段的元数据</p><p>为了将一个函数变成测试函数，需要在 fn 行之前加上 <strong>#[test]</strong></p><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><ul><li>使用 cargo test 命令运行所有测试函数</li></ul><p>Rust Hui 构建一个 Test Runner 的可执行文件，它会运行标注了 test 的函数，并报告其运行是否成功</p><ul><li>当使用 cargo 创建 library 项目时，会生成一个 test module,里面有一个 test 函数</li></ul><p>可以添加任意数量的 test module 或函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new 项目名 --lib</span><br></pre></td></tr></table></figure><p>src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(left: <span class="type">usize</span>, right: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    left + right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">add</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(result, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="测试失败"><a href="#测试失败" class="headerlink" title="测试失败"></a>测试失败</h3><ul><li>测试函数 panic 就表示失败</li><li>每个测试运行在一个新线程</li><li>当主线程看见某个测试线程挂掉了，那个测试标记为失败了</li></ul><h2 id="断言（Assert）"><a href="#断言（Assert）" class="headerlink" title="断言（Assert）"></a>断言（Assert）</h2><h3 id="使用-assert-宏检查测试结果"><a href="#使用-assert-宏检查测试结果" class="headerlink" title="使用 assert!宏检查测试结果"></a>使用 assert!宏检查测试结果</h3><p>assert!宏，来自标准库，用来确定某个状态是否为 true</p><ul><li>true，测试通过</li><li>false, 调用 panic！，测试失败</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">larger_can_hold_smaller</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">larger</span> = Rectangle &#123;</span><br><span class="line">            width: <span class="number">8</span>,</span><br><span class="line">            height: <span class="number">7</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">smaller</span> = Rectangle &#123;</span><br><span class="line">            width: <span class="number">5</span>,</span><br><span class="line">            height: <span class="number">1</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert!</span>(larger.<span class="title function_ invoke__">can_hold</span>(&amp;smaller));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-assert-eq-和-assert-ne-宏来测试相等"><a href="#使用-assert-eq-和-assert-ne-宏来测试相等" class="headerlink" title="使用 assert_eq! 和 assert_ne! 宏来测试相等"></a>使用 assert_eq! 和 assert_ne! 宏来测试相等</h3><ul><li>都来自于标准库</li><li>判断两个参数是否相等或不等</li><li>实际上，它们使用的就是==和！=运算符的 assert!</li><li>断言失败，会自动打印出两个参数的值</li></ul><p>使用 debug 格式打印参数：要求参数实现了 PartialEq 和 Debug Traits（所有基本类型和标准库大部分类型都实现了）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_two</span>(a: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">4</span>, <span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><p>可以向 assert!、assert_eq! 和 assert_ne! 宏传递一个可选的失败信息参数，可以在测试失败时将自定义失败信息一同打印出来。</p><ul><li>assert! 宏的第一个参数必填，自定义消息作为第二个参数</li><li>assert_eq!和 assert_ne! 前两个参数必填，自定义消息作为第 3 个参数</li><li>自定义消息参数会被传递给 format!宏，可以使用{}占位符</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">greeting</span>(name: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;&#125;!&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greeting_contains_name</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">greeting</span>(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(result.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;Carol&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义错误信息</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greeting_contains_name</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">greeting</span>(<span class="string">&quot;Carol&quot;</span>);</span><br><span class="line">        <span class="built_in">assert!</span>(</span><br><span class="line">            result.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;Carol&quot;</span>),</span><br><span class="line">            <span class="string">&quot;Greeting did not contain name, value was `&#123;&#125;`&quot;</span>,</span><br><span class="line">            result</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="验证错误处理的情况"><a href="#验证错误处理的情况" class="headerlink" title="验证错误处理的情况"></a>验证错误处理的情况</h2><p>可验证代码在特定情况下是否发生了 panic</p><p><strong>should_panic</strong> 属性(attribute):</p><ul><li>函数 panic：测试通过</li><li>函数没有 panic：测试失败</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> || value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="让-should-panic-更精确"><a href="#让-should-panic-更精确" class="headerlink" title="让 should_panic 更精确"></a>让 should_panic 更精确</h3><p>可以给 should_panic 属性增加一个可选的 expected 参数。测试工具会确保错误信息中包含其提供的文本</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Guess</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be greater than or equal to 1, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Guess value must be less than or equal to 100, got &#123;&#125;.&quot;</span>,</span><br><span class="line">                value</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="meta">#[should_panic(expected = <span class="string">&quot;Guess value must be less than or equal to 100&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">greater_than_100</span>() &#123;</span><br><span class="line">        Guess::<span class="title function_ invoke__">new</span>(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在测试中使用-Result"><a href="#在测试中使用-Result" class="headerlink" title="在测试中使用 Result"></a>在测试中使用 Result<T,E></h2><p>无需 panic，可以使用 Result<T,E>作为返回类型编写测试</p><ul><li>返回 Ok:测试通过</li><li>返回 Err:测试失败</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_works</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="number">2</span> + <span class="number">2</span> == <span class="number">4</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;two plus two does not equal four&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<strong>不能对这些使用 Result<T, E> 的测试使用 #[should_panic] 注解</strong>。</p><p>因为运行失败时会返回 Err 而不会发生 panic</p><h2 id="控制测试运行"><a href="#控制测试运行" class="headerlink" title="控制测试运行"></a>控制测试运行</h2><p>改变 cargo test 的行为:添加命令行参数</p><p>默认行为:</p><ul><li><strong>并行运行</strong></li><li><strong>所有测试</strong></li><li>捕获（不显示）所有标准输出，使读取与测试结果相关的输出更容易</li></ul><p>命令行参数:</p><ul><li>针对 cargo test 的参数: 紧跟 cargo test 后</li></ul><p>cargo test —help</p><ul><li>针对测试可执行程序: 放在—之后</li></ul><p>cargo test — —help</p><h3 id="并行运行测试"><a href="#并行运行测试" class="headerlink" title="并行运行测试"></a>并行运行测试</h3><p>默认使用多个线程并行运行</p><p>要确保测试之间：</p><ul><li>不会相互依赖</li><li>不依赖于某个共享状态(环境，工作目录，环境变量等)</li></ul><h4 id="—test-threads-参数"><a href="#—test-threads-参数" class="headerlink" title="—test-threads 参数"></a>—test-threads 参数</h4><p>如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 —test-threads 参数和希望使用线程的数量给测试二进制文件。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span> -- --test-threads=1</span><br></pre></td></tr></table></figure><p>这里将测试线程设置为 1，告诉程序不要使用任何并行机制。这也会比并行运行花费更多时间，不过在有共享的状态时，测试就不会潜在的相互干扰了。</p><h3 id="显式函数输出"><a href="#显式函数输出" class="headerlink" title="显式函数输出"></a>显式函数输出</h3><p>默认，如果测试通过，Rust 的 test 库会捕获所有打印到标准输出的内容</p><p>比如 println!:</p><ul><li><strong>如果测试成功，我们将不会在终端看到 println! 的输出</strong>：只会看到说明测试通过的提示行。</li><li>如果<strong>测试失败了，则会看到所有标准输出和其他错误信息</strong>。</li></ul><p>如果你希望也能看到通过的测试中打印的值，也可以在结尾加上 —show-output 告诉 Rust 显示成功测试的输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span> -- --show-output</span><br></pre></td></tr></table></figure><h3 id="按名称运行测试的子集"><a href="#按名称运行测试的子集" class="headerlink" title="按名称运行测试的子集"></a>按名称运行测试的子集</h3><p>如果没有传递任何参数就运行测试，所有测试都会并行运行：</p><h4 id="运行单个测试"><a href="#运行单个测试" class="headerlink" title="运行单个测试"></a>运行单个测试</h4><p>可以向 cargo test 传递任意测试的名称来只运行这个测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo <span class="built_in">test</span> one_hundred</span><br></pre></td></tr></table></figure><h4 id="过滤运行多个测试"><a href="#过滤运行多个测试" class="headerlink" title="过滤运行多个测试"></a>过滤运行多个测试</h4><p>我们可以指定部分测试的名称，任何名称匹配这个名称的测试会被运行。例如，因为头两个测试的名称包含 add，可以通过 cargo test add 来运行这两个测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> add</span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished <span class="built_in">test</span> [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.61s</span><br><span class="line">     Running unittests (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 2 tests</span><br><span class="line"><span class="built_in">test</span> tests::add_three_and_two ... ok</span><br><span class="line"><span class="built_in">test</span> tests::add_two_and_two ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished <span class="keyword">in</span> 0.00s</span><br></pre></td></tr></table></figure><p>这运行了所有名字中带有 add 的测试，也过滤掉了名为 one_hundred 的测试。</p><h4 id="忽略某些测试"><a href="#忽略某些测试" class="headerlink" title="忽略某些测试"></a>忽略某些测试</h4><p>有时一些特定的测试执行起来是非常耗费时间的，所以在大多数运行 cargo test 的时候希望能排除他们</p><p>可以使用 ignore 属性来标记耗时的测试并排除他们，如下所示：</p><p>文件名: src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_works</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span> + <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="meta">#[ignore]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expensive_test</span>() &#123;</span><br><span class="line">    <span class="comment">// 需要运行一个小时的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于想要排除的测试，我们在 #[test] 之后增加了 #[ignore] 行。现在如果运行测试，就会发现 it_works 运行了，而 expensive_test 没有运行：</p><p>如果我们只希望运行被忽略的测试，可以使用 cargo test — —ignored</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> -- --ignored</span><br></pre></td></tr></table></figure><h2 id="测试组织"><a href="#测试组织" class="headerlink" title="测试组织"></a>测试组织</h2><p>Rust 社区倾向于根据测试的两个主要分类来考虑问题：</p><p><strong>单元测试</strong>（<em>unit tests</em>）与 <strong>集成测试</strong>（<em>integration tests</em>）</p><ul><li>元测试倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口。</li><li>而集成测试对于你的库来说则完全是外部的。它们与其他外部代码一样，通过相同的方式使用你的代码，只测试公有接口而且每个测试都有可能会测试多个模块。</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><strong>#[cfg(test)]标注 test 模块</strong></p><ul><li>只有运行 cargo test 才编译和运行代码</li><li>运行 cargo build 则不会</li><li>集成测试在不同的目录，它不需要#[cfg(test)]标注</li></ul><p><strong>cfg: configuration 配置</strong></p><p>告诉 Rust 下面的条目只有在指定的配置选项下才被包含</p><h4 id="测试私有函数"><a href="#测试私有函数" class="headerlink" title="测试私有函数"></a>测试私有函数</h4><p>测试社区中一直存在关于是否应该对私有函数直接进行测试的论战，而在其他语言中想要测试私有函数是一件困难的，甚至是不可能的事。不过无论你坚持哪种测试意识形态，<strong>Rust 的私有性规则确实允许你测试私有函数</strong>。</p><p>文件名: src/lib.rs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pub fn add_two(a: i32) -&gt; i32 &#123;</span><br><span class="line">    internal_adder(a, 2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn internal_adder(a: i32, b: i32) -&gt; i32 &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[cfg(test)]</span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    #[test]</span><br><span class="line">    fn internal() &#123;</span><br><span class="line">        assert_eq!(4, internal_adder(2, 2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例 11-12：测试私有函数</p><p>注意 internal_adder 函数并没有标记为 pub。同时 tests 也仅仅是另一个模块。正如 “路径用于引用模块树中的项”部分所说，子模块的项可以使用其上级模块的项。在测试中，我们通过 use super::* 将 test 模块的父模块的所有项引入了作用域，接着测试调用了 internal_adder。</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>在 Rust 里，集成测试完全位于测试库的外部</p><p>同其他使用库的代码一样使用库文件，也就是说它们只能调用一部分库中的公有 API 。集成测试的目的是测试库的多个部分能否一起正常工作。一些单独能正确运行的代码单元集成在一起也可能会出现问题，所以<strong>集成测试的覆盖率</strong>也是很重要的。</p><h4 id="tests-目录"><a href="#tests-目录" class="headerlink" title="tests 目录"></a>tests 目录</h4><ul><li>创建集成测试:tests 目录</li><li><strong>tests 目录下的每个测试文件都是单独的一个 crate</strong></li></ul><p>创建一个集成测试。保留示例 adder 中 <em>src/lib.rs</em> 的代码。创建一个 <em>tests</em> 目录，新建一个文件 <em>tests/integration_test.rs</em>，并输入示例中的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>并不需要将 <em>tests/integration_test.rs</em> 中的任何代码标注为 #[cfg(test)]。 <strong>tests 文件夹在 Cargo 中是一个特殊的文件夹</strong>， Cargo 只会在运行 cargo test 时编译这个目录中的文件。</li><li>需要将被测试库导入</li></ul><h4 id="运行指定的集成测试"><a href="#运行指定的集成测试" class="headerlink" title="运行指定的集成测试"></a>运行指定的集成测试</h4><p>运行一个特定的集成测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> 函数名</span><br></pre></td></tr></table></figure><p>运行某个测试文件内的所有测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span> --<span class="built_in">test</span> 文件名</span><br></pre></td></tr></table></figure><h4 id="集成测试中的子模块"><a href="#集成测试中的子模块" class="headerlink" title="集成测试中的子模块"></a>集成测试中的子模块</h4><p>随着集成测试的增加，你可能希望在 tests 目录增加更多文件以便更好的组织他们，例如根据测试的功能来将测试分组。正如我们之前提到的，每一个 <em>tests</em> 目录中的文件都被编译为单独的 crate。</p><p>将每个集成测试文件当作其自己的 crate 来对待，这更有助于创建单独的作用域，这种单独的作用域能提供更类似与最终使用者使用 crate 的环境。</p><p>例如，如果我们可以创建 一个<em>tests/common.rs</em> 文件并创建一个名叫 setup 的函数，我们希望这个函数能被多个测试文件的测试函数调用：</p><p>文件名: tests/common.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">setup</span>() &#123;</span><br><span class="line">    <span class="comment">// setup code specific to your library&#x27;s tests would go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果再次运行测试，将会在测试结果中看到一个新的对应 <em>common.rs</em> 文件的测试结果部分，即便这个文件并没有包含任何测试函数，也没有任何地方调用了 setup 函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span></span><br><span class="line">   Compiling adder v0.1.0 (file:///projects/adder)</span><br><span class="line">    Finished <span class="built_in">test</span> [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.89s</span><br><span class="line">     Running unittests (target/debug/deps/adder-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> tests::internal ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br><span class="line"></span><br><span class="line">     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> it_adds_two ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br><span class="line"></span><br><span class="line">   Doc-tests adder</span><br><span class="line"></span><br><span class="line">running 0 tests</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.00s</span><br></pre></td></tr></table></figure><p>我们并不想要 common 出现在测试结果中显示 running 0 tests 。我们只是希望其能被其他多个集成测试文件中调用罢了。</p><p>为了不让 common 出现在测试输出中，我们将<strong>创建</strong> <strong><em>tests/common/mod.rs</em></strong> ，<strong>而不是创建</strong> <strong><em>tests/common.rs</em></strong> 。这是一种 Rust 的命名规范，这样命名<strong>告诉 Rust 不要将</strong> <strong>common</strong> <strong>看作一个集成测试文件</strong>。将 setup 函数代码移动到 <em>tests/common/mod.rs</em> 并删除 <em>tests/common.rs</em> 文件之后，测试输出中将不会出现这一部分。<strong><em>tests</em> 目录中的子目录不会被作为单独的 crate 编译或作为一个测试结果部分出现在测试输出中</strong>。</p><p>一旦拥有了 <em>tests/common/mod.rs</em>，就可以将其作为模块以便在任何集成测试文件中使用。这里是一个 <em>tests/integration_test.rs</em> 中调用 setup 函数的 it_adds_two 测试的例子：</p><p>文件名: tests/integration_test.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> common;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">it_adds_two</span>() &#123;</span><br><span class="line">    common::<span class="title function_ invoke__">setup</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">4</span>, adder::<span class="title function_ invoke__">add_two</span>(<span class="number">2</span>));</span><br><span class="line">&#125;<span class="comment">//接着在测试函数中就可以调用 `common::setup()` 了。</span></span><br></pre></td></tr></table></figure><h4 id="针对-binary-crate-的集成测试"><a href="#针对-binary-crate-的集成测试" class="headerlink" title="针对 binary crate 的集成测试"></a>针对 binary crate 的集成测试</h4><ul><li><p>如果项目时 binary crate 只有含有 src/main.rs 没有 src/lib.rs：</p><ul><li><p>不能在 tests 目录下创建集成测试</p></li><li><p>无法把 main.rs 的函数导入作用域</p></li></ul></li><li><p>只有 library crate 在能暴露函数给其它 crate 使用</p></li><li>binary crate 意味着独立运行</li></ul><h1 id="IO-项目-构建命令行程序"><a href="#IO-项目-构建命令行程序" class="headerlink" title="IO 项目:构建命令行程序"></a>IO 项目:构建命令行程序</h1><h2 id="接收命令行参数"><a href="#接收命令行参数" class="headerlink" title="接收命令行参数"></a>接收命令行参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><p>std::env::args 在其任何参数包含无效 Unicode 字符时会 panic。</p><p>如果你需要接受包含无效 Unicode 字符的参数，使用 <strong>std::env::args_os</strong> 代替。这个函数<strong>返回 OsString 值</strong>而不是 String 值。这里出于简单考虑使用了 std::env::args，因为 OsString 值每个平台都不一样而且比 String 值处理起来更为复杂。</p><h2 id="二进制项目的关注与分离"><a href="#二进制项目的关注与分离" class="headerlink" title="二进制项目的关注与分离"></a>二进制项目的关注与分离</h2><p>main 函数负责多个任务的组织问题在许多二进制项目中很常见。所以 Rust 社区开发出一类在 main 函数开始变得庞大时进行二进制程序的关注分离的指导性过程。这些过程有如下步骤：</p><ul><li><strong>将程序拆分成 <em>main.rs</em> 和 <em>lib.rs</em> 并将程序的逻辑放入 <em>lib.rs</em> 中</strong>。</li><li>当命令行解析逻辑比较小时，可以保留在 <em>main.rs</em> 中。</li><li>当命令行解析开始变得复杂时，也同样将其从 <em>main.rs</em> 提取到 <em>lib.rs</em> 中。</li></ul><p>经过这些过程之后保留在 main 函数中的责任应该被限制为：</p><ul><li>使用参数值调用命令行解析逻辑</li><li>设置任何其他的配置</li><li>调用 <em>lib.rs</em> 中的 run 函数</li><li>如果 run 返回错误，则处理这个错误</li></ul><p>这个模式的一切就是为了关注分离：<em>main.rs</em> 处理程序运行，而 <em>lib.rs</em> 处理所有的真正的任务逻辑。因为不能直接测试 main 函数，这个结构通过将所有的程序逻辑移动到 <em>lib.rs</em> 的函数中使得我们可以测试他们。仅仅保留在 <em>main.rs</em> 中的代码将足够小以便阅读就可以验证其正确性。</p><h2 id="TDD-测试驱动开发"><a href="#TDD-测试驱动开发" class="headerlink" title="TDD 测试驱动开发"></a>TDD 测试驱动开发</h2><p>遵循测试驱动开发（Test Driven Development, TDD）的模式来逐步增加 minigrep 的搜索逻辑。这是一个软件开发技术，它遵循如下步骤：</p><ol><li>编写一个失败的测试，并运行它以确保它失败的原因是你所期望的。</li><li>编写或修改足够的代码来使新的测试通过。</li><li>重构刚刚增加或修改的代码，并确保测试仍然能通过。</li><li>从步骤 1 开始重复！</li></ol><p>这只是众多编写软件的方法之一，不过 TDD 有助于驱动代码的设计。在编写能使测试通过的代码之前编写测试有助于在开发过程中保持高测试覆盖率。</p><h2 id="编写-minigrep-代码"><a href="#编写-minigrep-代码" class="headerlink" title="编写 minigrep 代码"></a>编写 minigrep 代码</h2><p>src/lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(&amp;config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;With text:\n&#123;&#125;&quot;, contents);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="comment">// println!(&quot;Search for &#123;&#125;&quot;, query);</span></span><br><span class="line">        <span class="comment">// println!(&quot;In file &#123;&#125;&quot;, filename);</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">contains</span>(query) &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">query</span> = query.<span class="title function_ invoke__">to_lowercase</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> contents.<span class="title function_ invoke__">lines</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(&amp;query) &#123;</span><br><span class="line">            result.<span class="title function_ invoke__">push</span>(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,args);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(&amp;args).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments:&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config)&#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Application error: &#123;&#125;&quot;</span>,e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题 P2785 将字符串中的元音字母排序</title>
      <link href="/posts/2785/"/>
      <url>/posts/2785/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-09-11</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><p>题目：<br><div class="tag link"><a class="link-card" title="P2785将字符串中的元音字母排序" href="https://leetcode.cn/problems/sort-vowels-in-a-string/description/?envType=daily-question&envId=2025-09-11"><div class="left"><img src="https://leetcode.cn/favicon.ico"/></div><div class="right"><p class="text">P2785将字符串中的元音字母排序</p><p class="url">https://leetcode.cn/problems/sort-vowels-in-a-string/description/?envType=daily-question&envId=2025-09-11</p></div></a></div></p><p>我采用先提取再排序，最后覆盖的方法，算法复杂度为 O(nlogn)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isVowel</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span> || c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;i&#x27;</span> || c == <span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span> || c == <span class="string">&#x27;A&#x27;</span> ||</span><br><span class="line">      c == <span class="string">&#x27;E&#x27;</span> || c == <span class="string">&#x27;I&#x27;</span> || c == <span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递增</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">comparefunc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">char</span> *)a - *(<span class="type">char</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">sortVowels</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> vowel_count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> *str, *vowels;</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="comment">// 注意要复制len + 1个字节</span></span><br><span class="line">  str = <span class="built_in">malloc</span>((len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  <span class="built_in">strcpy</span>(str, s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVowel(str[i])) &#123;</span><br><span class="line">      vowel_count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  vowels = (<span class="type">char</span> *)<span class="built_in">malloc</span>(vowel_count * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; index &lt; vowel_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVowel(str[i])) &#123;</span><br><span class="line">      vowels[index] = str[i];</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  qsort(vowels, vowel_count, <span class="keyword">sizeof</span>(<span class="type">char</span>), comparefunc);</span><br><span class="line">  index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; index &lt; vowel_count; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isVowel(str[i])) &#123;</span><br><span class="line">      str[i] = vowels[index];</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(vowels);</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 常量字符串不可修改</span></span><br><span class="line">  <span class="type">char</span> *s = <span class="string">&quot;lEetcOde&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *str;</span><br><span class="line">  str = sortVowels(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  <span class="built_in">free</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>推荐方法，利用计数排序的思想，即开辟一个将要排序的数的区间大小的数组，将要排序的数放入对应下标的数组元素中计数，然后累加和可以求得每个数前面有多少个数，从而直接确定这个数在排序后的数组中的位置，算法复杂度在 O(n)</p><div class="tag link"><a class="link-card" title="ASCII码表" href="https://www.runoob.com/w3cnote/ascii.html"><div class="left"><img src="https://static.char123.com/images/favicon.ico"/></div><div class="right"><p class="text">ASCII码表</p><p class="url">https://www.runoob.com/w3cnote/ascii.html</p></div></a></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">sortVowels</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> vowels[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> cnt[<span class="number">58</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">58</span>; i++) &#123;</span><br><span class="line">        cnt[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> idx = vowels[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        cnt[idx] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">// cnt数组中不为-1的即为元音字母</span></span><br><span class="line">        <span class="type">int</span> idx = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[idx] != <span class="number">-1</span>) &#123;</span><br><span class="line">            cnt[idx]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *res = (<span class="type">char</span>*)<span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(res, s);</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> pos = res[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt[pos] != <span class="number">-1</span>) &#123;<span class="comment">//如果是元音字母</span></span><br><span class="line">            <span class="keyword">while</span> (cnt[idx] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                idx++;<span class="comment">//找到下一个元音字母</span></span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = idx + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            cnt[idx]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tag link"><a class="link-card" title="计数排序" href="https://www.runoob.com/w3cnote/counting-sort.html"><div class="left"><img src="https://static.char123.com/images/favicon.ico"/></div><div class="right"><p class="text">计数排序</p><p class="url">https://www.runoob.com/w3cnote/counting-sort.html</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> leetcode每日一题 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C</title>
      <link href="/posts/42882/"/>
      <url>/posts/42882/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-07-19</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="常见整数的范围"><a href="#常见整数的范围" class="headerlink" title="常见整数的范围"></a>常见整数的范围</h2><div class="table-container"><table><thead><tr><th>数据类型</th><th>字节数</th><th>十进制取值范围</th><th>科学计数法表示（约）</th></tr></thead><tbody><tr><td><code>char</code></td><td>1</td><td>-128 ~ 127</td><td>-1.28×10² ~ 1.27×10²</td></tr><tr><td><code>unsigned char</code></td><td>1</td><td>0 ~ 255</td><td>0 ~ 2.55×10²</td></tr><tr><td><code>short</code></td><td>2</td><td>-32,768 ~ 32,767</td><td>-3.28×10⁴ ~ 3.27×10⁴</td></tr><tr><td><code>unsigned short</code></td><td>2</td><td>0 ~ 65,535</td><td>0 ~ 6.55×10⁴</td></tr><tr><td><code>int</code></td><td>4</td><td>-2,147,483,648 ~ 2,147,483,647</td><td>-2.15×10⁹ ~ 2.15×10⁹</td></tr><tr><td><code>unsigned int</code></td><td>4</td><td>0 ~ 4,294,967,295</td><td>0 ~ 4.29×10⁹</td></tr><tr><td><code>long</code> (Linux 64 位)</td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td><td>±9.22×10¹⁸</td></tr><tr><td><code>unsigned long</code></td><td>8</td><td>0 ~ 18,446,744,073,709,551,615</td><td>0 ~ 1.84×10¹⁹</td></tr><tr><td><code>long long</code></td><td>8</td><td>-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807</td><td>±9.22×10¹⁸</td></tr><tr><td><code>unsigned long long</code></td><td>8</td><td>0 ~ 18,446,744,073,709,551,615</td><td>0 ~ 1.84×10¹⁹</td></tr></tbody></table></div><ul><li>long 的字节数在 不同平台上可能不同，如在 64 位 Linux 系统上通常为 8 字节。</li><li>实际大小和范围由编译器及目标平台的 data model 决定，如 LP64（Linux）/LLP64（Windows）</li></ul><h2 id="ASCII-表"><a href="#ASCII-表" class="headerlink" title="ASCII 表"></a>ASCII 表</h2><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509121053858.png" alt="ASCII可显示字符"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202509121053206.png" alt="ASCII控制字符"></p><h1 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h1><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>%c 和空白的区别</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br></pre></td></tr></table></figure><p>会 原封不动 读取一个字符，包括空格、制表符、换行 \n。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch);</span><br></pre></td></tr></table></figure><p>因为格式字符串里有个 空格，scanf 会先跳过所有 空白字符（space、\t、\n），再读一个有效字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x)!=EOF)</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>scanf 读取非法值时会返回 EOF</li><li>%d、%f 等数字格式符号：默认自动跳过空白。</li><li>%c：不会跳过空白，需要 “ %c” 才能忽略空格、换行。</li><li>原理：scanf 的格式字符串里，空白符（空格、\n、\t）意味着“匹配任意数量的空白”。</li></ul><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><p>getline() 的返回值是读取的字符数(包括换行符)</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>char **lineptr</code></td><td>指向一个 <code>char*</code> 指针（用来存储读入的字符串，函数内部会自动分配/扩展内存）</td></tr><tr><td><code>size_t *n</code></td><td>指向缓冲区大小（初始为 0），函数根据需要动态分配/扩展内存</td></tr><tr><td><code>FILE *stream</code></td><td>输入流，例如 <code>stdin</code>、文件句柄等</td></tr></tbody></table></div><p>返回值</p><ul><li>成功：返回读取到的字符数（包括换行符 <code>\n</code>，但不包括终止符 <code>\0</code>）</li><li>失败：返回 <code>-1</code>，并设置 <code>errno</code></li></ul><p>使用 getline 需要包含 GNU 扩展定义的 <stdio.h> 和 <stdlib.h>，但更关键的是在 某些非 POSIX 平台（如 Windows 或老标准 C 编译器） 中，getline() 并不是标准 C 函数。<br>综合解决方法（适用于 Linux/GCC 环境）：<br>确保你包含了以下头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选：启用 GNU 扩展</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用strcspn</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了 ssize_t 类型（带符号的 size_t），常用于 read, write, getline, readlink 等函数的返回值</span></span><br><span class="line"><span class="comment">// 是 POSIX 标准的一部分，不是 C 标准库的一部分，所以在 GNU/Linux 平台使用 POSIX API 时必须包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">// 启用 getline 所需的 GNU 扩展</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span>          <span class="comment">// 提供 errno</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>         <span class="comment">// 提供 strerror()</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一行文本（按 Ctrl+D 或 Ctrl+Z + Enter 结束）：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    errno = <span class="number">0</span>;  <span class="comment">// 使用前清零</span></span><br><span class="line">    nread = getline(&amp;line, &amp;len, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (feof(<span class="built_in">stdin</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入结束（EOF）\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 打印 errno 的值和对应信息</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;getline 失败，errno = %d: %s\n&quot;</span>, errno, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取了 %zd 字符：%s&quot;</span>, nread, line);</span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>printf 函数详解：<br>下面是 printf() 函数的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br></pre></td></tr></table></figure><p>参数</p><ul><li>format — 这是字符串，包含了要被写入到标准输出 stdout 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</li><li>format 标签属性是</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-attr">[flags]</span><span class="selector-attr">[width]</span><span class="selector-attr">[.precision]</span><span class="selector-attr">[length]</span>specifier</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">格式字符</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left">a, A</td><td style="text-align:left">以十六进制形式输出浮点数(C99 新增)。实例 <strong>printf(“pi=%a\n”, 3.14);</strong> 输出 <strong>pi=0x1.91eb86p+1</strong>。</td></tr><tr><td style="text-align:left">d</td><td style="text-align:left">以十进制形式输出带符号整数(正数不输出符号)</td></tr><tr><td style="text-align:left">o</td><td style="text-align:left">以八进制形式输出无符号整数(不输出前缀 0)</td></tr><tr><td style="text-align:left">x,X</td><td style="text-align:left">以十六进制形式输出无符号整数(不输出前缀 Ox)</td></tr><tr><td style="text-align:left">u</td><td style="text-align:left">以十进制形式输出无符号整数</td></tr><tr><td style="text-align:left">f</td><td style="text-align:left">以小数形式输出单、双精度实数</td></tr><tr><td style="text-align:left">e,E</td><td style="text-align:left">以指数形式输出单、双精度实数</td></tr><tr><td style="text-align:left">g,G</td><td style="text-align:left">以%f 或%e 中较短的输出宽度输出单、双精度实数</td></tr><tr><td style="text-align:left">c</td><td style="text-align:left">输出单个字符</td></tr><tr><td style="text-align:left">s</td><td style="text-align:left">输出字符串</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">输出指针地址</td></tr><tr><td style="text-align:left">lu</td><td style="text-align:left">32 位无符号整数</td></tr><tr><td style="text-align:left">llu</td><td style="text-align:left">64 位无符号整数</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">flags（标识）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-</td><td style="text-align:left">在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。</td></tr><tr><td style="text-align:left">空格</td><td style="text-align:left">如果没有写入任何符号，则在该值前面插入一个空格。</td></tr><tr><td style="text-align:left">#</td><td style="text-align:left">与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">width（宽度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">(number)</td><td style="text-align:left">要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">.precision（精度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">.number</td><td style="text-align:left">对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。 对于 g 和 G 说明符：要输出的最大有效位数。 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。 对于 c 类型：没有任何影响。 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。</td></tr><tr><td style="text-align:left">.*</td><td style="text-align:left">精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">length（长度）</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">h</td><td style="text-align:left">参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。</td></tr><tr><td style="text-align:left">l</td><td style="text-align:left">参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。</td></tr></tbody></table></div><ul><li><p>附加参数</p><blockquote><p>根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p></blockquote></li><li><p>返回值</p><blockquote><p>如果成功，则返回写入的字符总数，否则返回一个负数。</p></blockquote></li></ul><h2 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h2><h3 id="错误状态宏定义"><a href="#错误状态宏定义" class="headerlink" title="错误状态宏定义"></a>错误状态宏定义</h3><p>在 <code>&lt;math.h&gt;</code> 中，有一些宏用于表示数学函数的错误状态：</p><div class="table-container"><table><thead><tr><th style="text-align:left">宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>HUGE_VAL</code></td><td style="text-align:left">当函数结果溢出时返回的值（正无穷大）。此宏代表一个非常大的双精度浮点数，通常用来作为某些数学函数在结果超出可表示范围时的返回值。当一个函数的结果太大以至于无法用正常的浮点数表示（即发生上溢）时，会设置 errno 为 ERANGE（范围错误），并返回 HUGE_VAL 或其负值（对于负无穷大）。</td></tr><tr><td style="text-align:left"><code>HUGE_VALF</code></td><td style="text-align:left">当函数结果溢出时返回的值（正无穷大，浮点型）</td></tr><tr><td style="text-align:left"><code>HUGE_VALL</code></td><td style="text-align:left">当函数结果溢出时返回的值（正无穷大，长双精度）</td></tr><tr><td style="text-align:left"><code>INFINITY</code></td><td style="text-align:left">正无穷大</td></tr><tr><td style="text-align:left"><code>NAN</code></td><td style="text-align:left">非数字值（Not-A-Number）</td></tr><tr><td style="text-align:left"><code>FP_INFINITE</code></td><td style="text-align:left">表示无穷大</td></tr><tr><td style="text-align:left"><code>FP_NAN</code></td><td style="text-align:left">表示非数字值</td></tr><tr><td style="text-align:left"><code>FP_NORMAL</code></td><td style="text-align:left">表示正常的浮点数</td></tr><tr><td style="text-align:left"><code>FP_SUBNORMAL</code></td><td style="text-align:left">表示次正规数</td></tr><tr><td style="text-align:left"><code>FP_ZERO</code></td><td style="text-align:left">表示零</td></tr></tbody></table></div><h3 id="库函数-1"><a href="#库函数-1" class="headerlink" title="库函数"></a>库函数</h3><p>下面列出了头文件 math.h 中定义的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">double acos(double x)</td><td style="text-align:left">返回以弧度表示的 x 的反余弦。</td></tr><tr><td style="text-align:left">double asin(double x)</td><td style="text-align:left">返回以弧度表示的 x 的反正弦。</td></tr><tr><td style="text-align:left">double atan(double x)</td><td style="text-align:left">返回以弧度表示的 x 的反正切。</td></tr><tr><td style="text-align:left">double atan2(double y, double x)</td><td style="text-align:left">返回以弧度表示的 y/x 的反正切。y 和 x 的值的符号决定了正确的象限。</td></tr><tr><td style="text-align:left">double cos(double x)</td><td style="text-align:left">返回弧度角 x 的余弦。</td></tr><tr><td style="text-align:left">double cosh(double x)</td><td style="text-align:left">返回 x 的双曲余弦。</td></tr><tr><td style="text-align:left">double sin(double x)</td><td style="text-align:left">返回弧度角 x 的正弦。</td></tr><tr><td style="text-align:left">double sinh(double x)</td><td style="text-align:left">返回 x 的双曲正弦。</td></tr><tr><td style="text-align:left">double tanh(double x)</td><td style="text-align:left">返回 x 的双曲正切。</td></tr><tr><td style="text-align:left">double exp(double x)</td><td style="text-align:left">返回 e 的 x 次幂的值。</td></tr><tr><td style="text-align:left">double frexp(double x, int *exponent)</td><td style="text-align:left">把浮点数 x 分解成尾数和指数。返回值是尾数，并将指数存入 exponent 中。所得的值是 x = mantissa * 2 ^ exponent。</td></tr><tr><td style="text-align:left">double ldexp(double x, int exponent)</td><td style="text-align:left">返回 x 乘以 2 的 exponent 次幂。</td></tr><tr><td style="text-align:left">double log(double x)</td><td style="text-align:left">返回 x 的自然对数（基数为 e 的对数）。</td></tr><tr><td style="text-align:left">double log10(double x)</td><td style="text-align:left">返回 x 的常用对数（基数为 10 的对数）。</td></tr><tr><td style="text-align:left">double modf(double x, double *integer)</td><td style="text-align:left">返回值为小数部分（小数点后的部分），并设置 integer 为整数部分。</td></tr><tr><td style="text-align:left">double pow(double x, double y)</td><td style="text-align:left">返回 x 的 y 次幂。</td></tr><tr><td style="text-align:left">double sqrt(double x)</td><td style="text-align:left">返回 x 的平方根。</td></tr><tr><td style="text-align:left">double ceil(double x)</td><td style="text-align:left">返回大于或等于 x 的最小的整数值。</td></tr><tr><td style="text-align:left">double fabs(double x)</td><td style="text-align:left">返回 x 的绝对值。</td></tr><tr><td style="text-align:left">double floor(double x)</td><td style="text-align:left">返回小于或等于 x 的最大的整数值。</td></tr><tr><td style="text-align:left">double fmod(double x, double y)</td><td style="text-align:left">返回 x 除以 y 的余数。</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>函数名</th><th>作用</th><th>向哪边取整</th></tr></thead><tbody><tr><td><code>round()</code></td><td>四舍五入</td><td>到最近整数</td></tr><tr><td><code>floor()</code></td><td>向下取整（不大于原数的最大整数）</td><td>向 -∞</td></tr><tr><td><code>ceil()</code></td><td>向上取整（不小于原数的最小整数）</td><td>向 +∞</td></tr><tr><td><code>trunc()</code></td><td>去除小数部分（直接截断）</td><td>向 0</td></tr></tbody></table></div><h3 id="常用数学常量"><a href="#常用数学常量" class="headerlink" title="常用数学常量"></a>常用数学常量</h3><p>以下是 <code>&lt;math.h&gt;</code> 中定义的一些常用数学常量：</p><div class="table-container"><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>M_PI</code></td><td style="text-align:left">3.14159265358979323846</td><td style="text-align:left">圆周率 π</td></tr><tr><td style="text-align:left"><code>M_E</code></td><td style="text-align:left">2.71828182845904523536</td><td style="text-align:left">自然对数的底数 e</td></tr><tr><td style="text-align:left"><code>M_LOG2E</code></td><td style="text-align:left">1.44269504088896340736</td><td style="text-align:left">log2(e)</td></tr><tr><td style="text-align:left"><code>M_LOG10E</code></td><td style="text-align:left">0.43429448190325182765</td><td style="text-align:left">log10(e)</td></tr><tr><td style="text-align:left"><code>M_LN2</code></td><td style="text-align:left">0.69314718055994530942</td><td style="text-align:left">ln(2)</td></tr><tr><td style="text-align:left"><code>M_LN10</code></td><td style="text-align:left">2.30258509299404568402</td><td style="text-align:left">ln(10)</td></tr><tr><td style="text-align:left"><code>M_PI_2</code></td><td style="text-align:left">1.57079632679489661923</td><td style="text-align:left">π/2</td></tr><tr><td style="text-align:left"><code>M_PI_4</code></td><td style="text-align:left">0.78539816339744830962</td><td style="text-align:left">π/4</td></tr><tr><td style="text-align:left"><code>M_1_PI</code></td><td style="text-align:left">0.31830988618379067154</td><td style="text-align:left">1/π</td></tr><tr><td style="text-align:left"><code>M_2_PI</code></td><td style="text-align:left">0.63661977236758134308</td><td style="text-align:left">2/π</td></tr><tr><td style="text-align:left"><code>M_2_SQRTPI</code></td><td style="text-align:left">1.12837916709551257390</td><td style="text-align:left">2/√π</td></tr><tr><td style="text-align:left"><code>M_SQRT2</code></td><td style="text-align:left">1.41421356237309504880</td><td style="text-align:left">√2</td></tr><tr><td style="text-align:left"><code>M_SQRT1_2</code></td><td style="text-align:left">0.70710678118654752440</td><td style="text-align:left">1/√2</td></tr></tbody></table></div><h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><h3 id="strdup"><a href="#strdup" class="headerlink" title="strdup"></a>strdup</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure><p>相当于 strcpy 但是会自动分配内存</p><h3 id="strtok"><a href="#strtok" class="headerlink" title="strtok"></a>strtok</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span></span><br></pre></td></tr></table></figure><p>参数<br>str: 要分割的字符串。在第一次调用时，传入要分割的字符串；后续调用时，传入 NULL，表示继续分割同一个字符串。<br>delim: 分隔符字符串。strtok() 会根据这个字符串中的任意一个字符来分割 str。</p><p>返回值<br>返回指向下一个标记的指针。如果没有更多的标记，则返回 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取第一个子字符串 */</span></span><br><span class="line">token = strtok(str, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 继续获取其他的子字符串 */</span></span><br><span class="line"><span class="keyword">while</span>( token != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">&quot;%s\n&quot;</span>, token );</span><br><span class="line"></span><br><span class="line">   token = strtok(<span class="literal">NULL</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项</p><ol><li>修改原字符串: strtok() 会修改传入的字符串，将分隔符替换为 \0（空字符）。因此，原始字符串会被破坏。</li><li>不可重入: strtok() 使用静态缓冲区来保存状态，因此它不是线程安全的。如果在多线程环境中使用，可以考虑使用 strtok_r()（可重入版本）。</li><li>连续分隔符: 如果字符串中有连续的分隔符，strtok() 会忽略它们，并返回下一个有效的标记。</li></ol><p>可重入版本：strtok_r()<br>strtok_r() 是 strtok() 的可重入版本，它允许你在多线程环境中安全地使用。它的原型如下：</p><p>char <em>strtok_r(char </em>str, const char <em>delim, char **saveptr);<br>saveptr: 是一个指向 char</em> 的指针，用于保存分割的状态。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;This is a sample string&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *token;</span><br><span class="line">    <span class="type">char</span> *saveptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次调用 strtok_r，传入要分割的字符串</span></span><br><span class="line">    token = strtok_r(str, <span class="string">&quot; &quot;</span>, &amp;saveptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继续调用 strtok_r，直到返回 NULL</span></span><br><span class="line">    <span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, token);</span><br><span class="line">        token = strtok_r(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>, &amp;saveptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strcspn"><a href="#strcspn" class="headerlink" title="strcspn"></a>strcspn</h3><p>strcspn 是 C 标准库 <string.h> 中的一个字符串处理函数，用于查找目标字符串中第一个匹配指定字符集合的字符的位置。</p><ul><li>函数原型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *reject)</span>;</span><br></pre></td></tr></table></figure><ul><li>功能说明</li></ul><p>它返回字符串 s 中第一个包含 reject 中任意字符的位置（索引），如果 s 中不包含 reject 中的任何字符，就返回 strlen(s)。</p><blockquote><p>💡 “cspn” 全称是 complement span，意思是：返回“不是 reject 的最长前缀”长度</p></blockquote><ul><li>示例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> pos = <span class="built_in">strcspn</span>(str, <span class="string">&quot;,!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个 &#x27;,&#x27; 或 &#x27;!&#x27; 的位置是：%zu\n&quot;</span>, pos);  <span class="comment">// 输出 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="strspn"><a href="#strspn" class="headerlink" title="strspn"></a>strspn</h3><p>strspn 是 C 语言标准库 <string.h> 中的函数，用来计算一个字符串开头有多少字符全部属于指定的字符集合。<br>strspn 这个函数名来自 “string span” 的缩写，意思是“字符串的跨度”或“字符串中连续满足条件的前缀长度”。</p><p>对比 strcspn</p><div class="table-container"><table><thead><tr><th>函数名</th><th>含义说明</th></tr></thead><tbody><tr><td><code>strspn</code></td><td>span of characters <strong>in</strong> accept</td></tr><tr><td><code>strcspn</code></td><td>span of characters <strong>not in</strong> reject</td></tr></tbody></table></div><p>也就是说：</p><ul><li><p>strspn(s, accept)：从开头开始，统计多少字符在 accept 中</p></li><li><p>strcspn(s, reject)：从开头开始，统计多少字符不在 reject 中</p></li><li><p>函数原型</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">const</span> <span class="type">char</span> *accept)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>功能说明</li></ul><p>strspn(s, accept) 会返回字符串 s 开头连续有多少个字符，全部都出现在 accept 中。</p><ol><li>它不会跳过字符，也不会检查整个字符串；</li><li>一旦遇到一个不属于 accept 的字符，就停止统计；</li><li>返回值是一个 size_t 类型（即无符号整数），表示匹配的长度。</li></ol><ul><li>示例</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = <span class="string">&quot;abcabc123&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *accept = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">strspn</span>(s, accept);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;前缀长度为：%zu\n&quot;</span>, len);  <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>✨ 分析：<br>字符串 s = “abcabc123”<br>以 “a”, “b”, “c” 开头，刚好连着 6 个字符都在 “abc” 中<br>第 7 个字符是 ‘1’，不在 “abc” 中 → 统计停止<br>所以返回 6</p></li><li><p>应用场景<br>📌 检查字符串开头是否只包含某些字符</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strspn</span>(s, <span class="string">&quot;0123456789&quot;</span>) == <span class="built_in">strlen</span>(s)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s 是纯数字\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📌 跳过前缀中所有合法字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot; \t\n hello&quot;</span>;</span><br><span class="line">s += <span class="built_in">strspn</span>(s, <span class="string">&quot; \t\n&quot;</span>);  <span class="comment">// 跳过所有空白字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;剩下：%s\n&quot;</span>, s);  <span class="comment">// 输出 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h3><p>你可以在标准库函数调用失败时，通过读取 <code>errno</code> 的值来判断失败的<strong>具体原因</strong>，然后使用 <code>perror()</code> 或 <code>strerror(errno)</code> 获取对应的错误描述。</p><hr><p>示例：使用 <code>errno</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;no-such-file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印错误编号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno = %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;error code = %d\n&quot;</span>, errno);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印错误描述</span></span><br><span class="line">        perror(<span class="string">&quot;fopen 失败&quot;</span>);           <span class="comment">// 推荐：自动添加前缀</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 或者手动打印错误信息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;错误信息: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">errno = 2</span><br><span class="line"><span class="keyword">error </span>code = 2</span><br><span class="line">fopen 失败: No such file or directory</span><br><span class="line">错误信息: No such file or directory</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP BombLab AArch64</title>
      <link href="/posts/42881/"/>
      <url>/posts/42881/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>win11 WSL2：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/CCECAA6776058E5E7B3BD5CD47C415D9.png" alt="硬件环境"></p><p>环境搭建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/SJTU-IPADS/OS-Course-Lab.git</span><br><span class="line"><span class="built_in">cd</span> OS-Course-Lab/Lab0</span><br><span class="line"><span class="built_in">sudo</span> apt-get install qemu-user gdb-multiarch</span><br></pre></td></tr></table></figure><p>terminal1<br>可以把答案写在 ans.txt 上，这样已经解过的就不用再敲了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-aarch64 -g 1234 ./bomb &lt; ans.txt</span><br></pre></td></tr></table></figure><p>terminal2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch -ex <span class="string">&quot;set architecture aarch64&quot;</span> -ex <span class="string">&quot;target remote localhost:1234&quot;</span> -ex <span class="string">&quot;file bomb&quot;</span></span><br></pre></td></tr></table></figure><h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>main 函数是有 C 代码的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;phases.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span>* input;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Type in your defuse password!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_0(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_1(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_2(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_3(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_4(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_5(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Congrats! You have defused all phases!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 read_line 的返回值作为参数传递给 phase_x</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225404452.png" alt="image-20250629225404452"></p><p>可以看到，main 函数每次调用 read_line 读取输入，随后调用 phase_x 函数，随后调用 phase_defused 打印信息</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225341441.png" alt="image-20250629225341441"></p><p>函数开头（栈帧设置）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400b10: a9bf7bfd    stp x29, x30, [sp, #-16]!    // 保存帧指针和返回地址到栈上，sp -= 16</span><br><span class="line">400b14: 910003fd    mov x29, sp                  // 设置新的帧指针 x29 = sp</span><br></pre></td></tr></table></figure><p>获取 fgets 的目标缓冲区（x0），准备调用 <code>_IO_fgets</code>：</p><p>该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>可以看到第一个参数是 char*（x0），第二个参数为 int（w1），第三个参数为一个结构体指针（x2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400b18: f00004e0    adrp x0, 49f000</span><br><span class="line">400b1c: f946d000    ldr x0, [x0, #3488]</span><br><span class="line">400b20: f9400002    ldr x2, [x0]                 // FILE *stream</span><br><span class="line"></span><br><span class="line">400b24: 52800a21    mov w1, #0x51                // w1 = 81，最多读取 81 字节</span><br><span class="line"></span><br><span class="line">400b28: d0000500    adrp x0, 4a2000</span><br><span class="line">400b2c: 9104e000    add x0, x0, #0x138           // x0 = 0x4a2000 + 0x138，x0 是目标 buffer 指针</span><br><span class="line"></span><br><span class="line">400b30: 94004a78    bl  413510 &lt;_IO_fgets&gt;       // 调用 _IO_fgets(buffer, 81, stream)</span><br></pre></td></tr></table></figure><blockquote><p>到这里，函数已经从输入中读取了一行字符串到 <code>0x4a2138</code> 地址。</p></blockquote><p>处理 fgets 结果：遍历字符串查找换行符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">400b34: d2800000    mov x0, #0                   // x0 = 0，作为字符串偏移索引</span><br><span class="line"></span><br><span class="line">// 再次构造 x2 = buffer 基址</span><br><span class="line">400b38: d0000502    adrp x2, 4a2000</span><br><span class="line">400b3c: 9104e042    add x2, x2, #0x138           // x2 = buffer</span><br><span class="line"></span><br><span class="line">400b40: 38626801    ldrb w1, [x0, x2]            // w1 = buffer[x0]</span><br><span class="line">400b44: 34000141    cbz w1, 400b6c               // 如果 w1 == 0，字符串结束，跳到 return</span><br><span class="line">400b48: 7100283f    cmp w1, #0xa                 // 检查是否是换行符 &#x27;\n&#x27;</span><br><span class="line">400b4c: 540000a0    b.eq 400b60                  // 是换行符，跳转到去掉换行符</span><br><span class="line">400b50: 91000400    add x0, x0, #1               // x0++，继续检查下一个字符</span><br><span class="line">400b54: f101401f    cmp x0, #0x50                // 最多检查 0x50 字节（最多 80 字节）</span><br><span class="line">400b58: 54ffff41    b.ne 400b40                  // 没到头就继续循环</span><br></pre></td></tr></table></figure><p>如果没有在前 80 字节找到 ‘\n’，调用 <code>explode</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400b5c: 97ffffe6    bl 400af4 &lt;explode&gt;          // 没有 &#x27;\n&#x27;，爆炸</span><br></pre></td></tr></table></figure><p>如果找到了换行符 <code>\n</code>，把它替换为 <code>\0</code>（字符串结束）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">400b60: d0000501    adrp x1, 4a2000</span><br><span class="line">400b64: 9104e021    add x1, x1, #0x138           // x1 = buffer</span><br><span class="line">400b68: 3820c83f    strb wzr, [x1, w0, sxtw]     // buffer[x0] = 0（wzr是0寄存器）</span><br></pre></td></tr></table></figure><p>返回前恢复现场：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">400b6c: d0000500    adrp x0, 4a2000</span><br><span class="line">400b70: 9104e000    add x0, x0, #0x138           // x0 = buffer，作为返回值</span><br><span class="line"></span><br><span class="line">400b74: a8c17bfd    ldp x29, x30, [sp], #16      // 恢复帧指针和返回地址，sp += 16</span><br><span class="line">400b78: d65f03c0    ret                          // 返回</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225645707.png" alt="image-20250629225645707"></p><p>可以看到 phase_defused 函数读取一个全局变量值，然后减一</p><p>随后加载一个全局地址 0x464000+0x7c0 = 0x4647c0 作为参数调用 printf 打印</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630125413000.png" alt="image-20250630125413000"></p><p>而 w1 存的是最开始减一的全局变量的值，地址是 0x4a0000+ 80 = 0x4a0000 + 0x50 = 0x4a0050。</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630125539188.png" alt="image-20250630125539188"></p><h1 id="phase-0"><a href="#phase-0" class="headerlink" title="phase_0"></a>phase_0</h1><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624203514602.png" alt="image-20250624203514602"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stpx29, x30, [sp, #-16]!</span><br></pre></td></tr></table></figure><ul><li>作用：将 x29（frame pointer，帧指针）和 x30（link register，返回地址）压入栈中。这一步保存了调用者的帧指针和返回地址，便于后续恢复。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movx29, sp</span><br></pre></td></tr></table></figure><ul><li>作用：将当前的栈指针 sp 赋值给帧指针 x29，即建立当前函数的新栈帧。</li></ul><p>从现在开始，x29 就指向这个函数调用的栈底，方便以后访问局部变量或传递参数。</p><p>随后，函数先是调用 read_int 函数读取一个 int 值，将返回值存入 w0，然后对比 0x4a0000 + 0x54(84) = 0x4a0054 的值看是否相等。可通过 gdb examine 命令查看内存这个位置的值：</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624204122130.png" alt="image-20250624204122130"></p><p>可以看到是 2022</p><p>随后是 cmp 指令对比输入的值(存储在 x0)和 2022(存储在 x1)，如果不相等则跳到调用 explode 函数的那行，所以必须要相等。即输入值必须是 2022</p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>phase_1 和 phase_0 差不多</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624205525968.png" alt="image-20250624205525968"></p><p>可以看到函数把 0x4a0000+0x58(88) = 0x4a0058 地址的值装入 x1，然后调用 strcmp，其参数应该是 x0，x1，而 x0 是我们输入的值，也就是说让我们输入的字符串和这个 0x4a0058 地址的字符串进行比较，看返回值 w0 是否为 0，不为 0 就跳转到调用 explode 的那一行</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624205829889.png" alt="image-20250624205829889"></p><p>里需要注意的是 0x4a0058 地址存放的不是字符串，而是字符串的地址，所以要先读出这个地址，然后读字符串地址的字符串</p><p>答案为：”Fault Tolerance: Reliable Systems from Unreliable Components.”</p><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629223737226.png" alt="image-20250629223737226"></p><p>第一行开辟了 64 字节的栈空间，共可存放 64/8=8 个 64 位值，第一行将 x29 放在 sp，将 x30 放在 sp+8</p><p>随后保存 sp 到 x29 寄存器</p><p>随后将 x19, x20 寄存器的值放在 sp+16, sp+24 的位置，即</p><ul><li>sp —-&gt; x29</li><li>sp+8 —-&gt; x30</li><li>sp+16 —-&gt; x19</li><li>sp+24 —-&gt; x20</li></ul><p>随后 x1 = sp+ 0x20 = sp+32，作为 read_8_numbers 的第二个参数，随后调用 read_8_numbers 这个函数</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629224840291.png" alt="image-20250629224840291"></p><p>可以看到，该函数首先开辟 0x20 即 32 字节的栈空间 sp= sp-32，随后将 x29 存入 sp+16，x30 存入 sp+24</p><p>随后设置栈帧指针 x29 为 sp+0x10 即 sp+16</p><p>随后将 x1 放入 x2，x1 是 read_8_numbers 的第二个参数</p><p>随后，x1 = x1+0x1c = x1+ 28</p><p>将 x1 存入 sp+8</p><p>x1 = x2 + 0x18 =x1 + 24</p><p>将 x1 存入 sp</p><p>随后</p><ul><li><p>x7 = x2+ 0x14</p></li><li><p>x6 = x2 + 0x10</p></li><li>x5 = x2+0xc</li><li>x4 = x2+ 0x8</li><li>x3 = x2+0x4</li></ul><p>x1 是地址 0x464000+0x858 的值，是一个指针，这里可以明显看出来是一个数组起始地址，可以看到是格式化字符串，作为__isoc99_scanf 的第二个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是 x0，即从 read_line 返回后一直未变</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630140224444.png" alt="image-20250630140224444"></p><p>函数调用结束后比较返回值和 0x7 的大小，如果小于等于就爆炸，因此必须要输入 8 个数字。</p><p>函数返回后恢复原来的栈结构</p><ul><li>sp —-&gt; x29</li><li>sp+8 —-&gt; x30</li><li>sp+16 —-&gt; x19</li><li>sp+24 —-&gt; x20</li><li>sp+32 —-&gt; array 的首地址，共 8 个数字，也是第一个数字的地址 array[0]</li><li>sp+36 —-&gt; array[1]</li><li>sp+40 —-&gt; array[2]</li><li>sp+44 —-&gt; array[3]</li><li>sp+48 —-&gt; array[4]</li><li>sp+52 —-&gt; array[5]</li><li>sp+56 —-&gt; array[6]</li><li>sp+60 —-&gt; array[7]</li></ul><p>刚好占满 phase_2 最初开辟的 64 字节</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630142117435.png" alt="image-20250630142117435"></p><p>然后是对输入的 8 个数字的判断了，这里很容易看出第一个数字和第二个数字都必须为 1</p><p>随后是一个循环</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630142644664.png" alt="image-20250630142644664"></p><p>x19 = sp+0x20 = sp+32 即 array[0]</p><p>x20 = sp+0x38 = sp+56 即终止条件即(56-32)/4=6，即到第六个就停止</p><p>首先 b 0x4007d0 跳过一次 x19 的自增与和 x20 的比较</p><p>如果 x19 == x20 则跳到 phase_2+108 结束</p><p>否则，首先将 x19 作为地址加载到 w0（array[i]），将它下一个加载到 w1（array[i+1]）</p><p>令 w0 = array[i]+array[i+1] +4</p><p>w1 = array[i+2]</p><p>比较 w0 是否等于 w1,如果相等则跳到 phase_2+60，将 i++</p><p>如果不相等则爆炸</p><p>第一个数和第二个数必须为 1</p><p>那么第三个数字为 1+1+4=6</p><p>第四个数字为 1+6+4=11</p><p>第五个数字为 6+11+4=21</p><p>第六个数字为 11+21+4=36</p><p>第七个数字为 21+36+4=61</p><p>第八个数字为 61+36+4=101</p><p>故答案为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">6</span> <span class="number">11</span> <span class="number">21</span> <span class="number">36</span> <span class="number">61</span> <span class="number">101</span></span><br></pre></td></tr></table></figure><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB</title>
      <link href="/posts/42870/"/>
      <url>/posts/42870/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-07</p></div></div><div class='timeline-item-content'><p>add gdb in emacs</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-09</p></div></div><div class='timeline-item-content'><p>add complementary skills</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-10</p></div></div><div class='timeline-item-content'><p>add multithread debugging</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-13</p></div></div><div class='timeline-item-content'><p>add multiprocess debugging，remote debugging，coredump debugging，add memory problem check</p></div></div></div><hr><h1 id="gdb-配置"><a href="#gdb-配置" class="headerlink" title="gdb 配置"></a>gdb 配置</h1><h2 id="tui-模式下显示混乱"><a href="#tui-模式下显示混乱" class="headerlink" title="tui 模式下显示混乱"></a>tui 模式下显示混乱</h2><p>参考：<br><div class="tag link"><a class="link-card" title="gdb tui模式下显示混乱解决方案" href="https://blog.csdn.net/u012772347/article/details/142598998"><div class="left"><img src="https://g.csdnimg.cn/static/logo/favicon32.ico"/></div><div class="right"><p class="text">gdb tui模式下显示混乱解决方案</p><p class="url">https://blog.csdn.net/u012772347/article/details/142598998</p></div></a></div></p><p>总之是创建一个~/.gdbinit 文件然后写入如下内容</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define c</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">refresh</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">define n</span><br><span class="line">next</span><br><span class="line"><span class="keyword">refresh</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> debuginfod enabled <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> print pretty</span><br></pre></td></tr></table></figure><h2 id="gdb-看不到程序-printf-输出"><a href="#gdb-看不到程序-printf-输出" class="headerlink" title="gdb 看不到程序 printf 输出"></a>gdb 看不到程序 printf 输出</h2><p>这是因为输出存在缓冲区，使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call fflush(stdout)</span><br></pre></td></tr></table></figure><h2 id="io-输入输出使用不同的终端"><a href="#io-输入输出使用不同的终端" class="headerlink" title="io 输入输出使用不同的终端"></a>io 输入输出使用不同的终端</h2><p>缺省情况，gdb 和程序的输入输出使用同一终端，可以为程序指定单独的输入输出终端，先打开一个终端输入 tty 命令获取当前终端名称<br>然后启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -<span class="built_in">tty</span> /dev/pts/3 ./a.out</span><br></pre></td></tr></table></figure><h2 id="在-emacs-中使用-gdb"><a href="#在-emacs-中使用-gdb" class="headerlink" title="在 emacs 中使用 gdb"></a>在 emacs 中使用 gdb</h2><p>主要使用 gdb 的 MI 模式，参考<br><div class="tag link"><a class="link-card" title="my emacs configuration" href="https://even629.com/posts/28521/"><div class="left"><img src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">my emacs configuration</p><p class="url">https://even629.com/posts/28521/</p></div></a></div></p><h1 id="gdb-tui-模式"><a href="#gdb-tui-模式" class="headerlink" title="gdb tui 模式"></a>gdb tui 模式</h1><blockquote><p>TUI 模式下最多显示 3 个窗口，命令窗口始终存在</p></blockquote><h2 id="打开-tui-模式并打开源码"><a href="#打开-tui-模式并打开源码" class="headerlink" title="打开 tui 模式并打开源码"></a>打开 tui 模式并打开源码</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) layout <span class="attribute">src</span></span><br></pre></td></tr></table></figure><p>源码窗口代码行数前的断点</p><ul><li>B 表示已经命中过了，至少命中过一次</li><li>b 表示还没有命中的</li><li>+表示断点时是可用的</li><li>-表示断点是 disable 的</li></ul><h2 id="显示汇编窗口"><a href="#显示汇编窗口" class="headerlink" title="显示汇编窗口"></a>显示汇编窗口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) layout <span class="keyword">asm</span></span><br></pre></td></tr></table></figure><h2 id="显示寄存器窗口"><a href="#显示寄存器窗口" class="headerlink" title="显示寄存器窗口"></a>显示寄存器窗口</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">layout</span> reg</span><br></pre></td></tr></table></figure><h2 id="切分窗口"><a href="#切分窗口" class="headerlink" title="切分窗口"></a>切分窗口</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) layout <span class="built_in">split</span></span><br></pre></td></tr></table></figure><h2 id="切换窗口焦点"><a href="#切换窗口焦点" class="headerlink" title="切换窗口焦点"></a>切换窗口焦点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) focus src/<span class="keyword">asm</span>/reg/<span class="built_in">cmd</span></span><br><span class="line">(gdb) fs <span class="keyword">asm</span></span><br></pre></td></tr></table></figure><h2 id="查看当前拥有焦点的窗口"><a href="#查看当前拥有焦点的窗口" class="headerlink" title="查看当前拥有焦点的窗口"></a>查看当前拥有焦点的窗口</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">info</span> win</span><br></pre></td></tr></table></figure><h2 id="退出窗口模式"><a href="#退出窗口模式" class="headerlink" title="退出窗口模式"></a>退出窗口模式</h2><p><strong>Ctrl + x +a</strong></p><h1 id="启动-gdb"><a href="#启动-gdb" class="headerlink" title="启动 gdb"></a>启动 gdb</h1><h2 id="编译阶段：加入调试信息"><a href="#编译阶段：加入调试信息" class="headerlink" title="编译阶段：加入调试信息"></a>编译阶段：加入调试信息</h2><p>为了让 GDB 能看到函数名、变量名、源码行号，<strong>编译时必须加上 <code>-g</code> 参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello        <span class="comment"># 对 C 程序</span></span><br><span class="line">g++ -g hello.cpp -o hello      <span class="comment"># 对 C++ 程序</span></span><br></pre></td></tr></table></figure><p>否则 GDB 只能看到汇编和内存地址，无法进行源码级调试。</p><hr><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><h3 id="调试一个程序"><a href="#调试一个程序" class="headerlink" title="调试一个程序"></a><strong>调试一个程序</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program</span><br></pre></td></tr></table></figure><h4 id="设置程序运行参数"><a href="#设置程序运行参数" class="headerlink" title="设置程序运行参数"></a><strong>设置程序运行参数</strong></h4><ul><li><p><strong>设置运行参数（如命令行参数）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> args 10 20 30</span><br></pre></td></tr></table></figure></li><li><p><strong>查看当前设置的参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show args</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="设置运行环境变量"><a href="#设置运行环境变量" class="headerlink" title="设置运行环境变量"></a><strong>设置运行环境变量</strong></h4><ul><li><p><strong>设置程序运行路径（用于找可执行文件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path /your/bin/dir</span><br></pre></td></tr></table></figure></li><li><p><strong>查看运行路径设置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show paths</span><br></pre></td></tr></table></figure></li><li><p><strong>设置环境变量</strong>（例如传给 <code>main()</code> 程序用的环境）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> environment USER=yourname</span><br></pre></td></tr></table></figure></li><li><p><strong>查看环境变量</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show environment</span><br><span class="line">show environment USER</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="设置工作目录"><a href="#设置工作目录" class="headerlink" title="设置工作目录"></a><strong>设置工作目录</strong></h4><p>设置工作目录指的是程序运行时的当前目录</p><ul><li><p><strong>切换当前目录</strong>（等同于 shell 的 <code>cd</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/dir</span><br></pre></td></tr></table></figure></li><li><p><strong>查看当前目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="控制程序的输入输出"><a href="#控制程序的输入输出" class="headerlink" title="控制程序的输入输出"></a><strong>控制程序的输入输出</strong></h4><ul><li><p><strong>查看程序绑定的终端信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info terminal</span><br></pre></td></tr></table></figure></li><li><p><strong>重定向输出（如保存输出到文件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run &gt; output.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>指定程序输入输出使用的终端设备</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tty</span> /dev/pts/1</span><br></pre></td></tr></table></figure></li></ul><h3 id="调试-core-dump-文件"><a href="#调试-core-dump-文件" class="headerlink" title="调试 core dump 文件"></a><strong>调试 core dump 文件</strong></h3><p>Linux core dump：</p><blockquote><p>一般称之为核心转储、内核转储，我们统称为转储文件。是某个时刻某个进程的内存信息映射，即包含了生成转储文件时该进程的整个内存信息以及寄存器等信息。转储文件可以是某个进程的，也可以是整个系统的。可以是进程活着的时候生成的，也可以是进程或者系统崩溃的时候自动生成的。</p><p>为活着的进程创建 core dump 文件一般可以通过 gdb 来生成，使用 gdb 把进程 attach 进来以后，执行 generate-core-file 或者 gcore 命令来生成 core dump 文件。</p><p>我们更多时候是对崩溃产生的 core dump 文件进行分析。</p></blockquote><h4 id="为活着的进程产生-coredump-文件"><a href="#为活着的进程产生-coredump-文件" class="headerlink" title="为活着的进程产生 coredump 文件"></a>为活着的进程产生 coredump 文件</h4><p>通过 gcore 生成 core dump 文件，完全不影响程序的运行</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">gdb attach <span class="title">pid</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> gcore test.<span class="title">core</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> detach</span></span><br></pre></td></tr></table></figure><p>core dump 是程序崩溃后的转储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program core</span><br></pre></td></tr></table></figure><h4 id="打开-Linux-core-文件生成功能"><a href="#打开-Linux-core-文件生成功能" class="headerlink" title="打开 Linux core 文件生成功能"></a>打开 Linux core 文件生成功能</h4><p>Linux <strong>默认没有打开 core 文件生成功能</strong>，也就是发生段错误时不会<code>core dumped</code>。可以通过以下命令打开<code>core</code>文件的生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不限制产生 core 的大小</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p><code>unlimited</code> 意思是系统<strong>不限制 core 文件的大小</strong>，只要有足够的磁盘空间，会转存程序所占用的全部内存，如果需要限制系统产生 <code>core</code>的大小，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core 最大限制大小为 409600 字节</span></span><br><span class="line"><span class="built_in">ulimit</span> -c 409600</span><br></pre></td></tr></table></figure><p>可以配置生成的 coredump 文件的名字，可以不覆盖默认的 coredump 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;%e-%p-%t&quot;</span> &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><h4 id="关闭-Linux-core-文件生成功能"><a href="#关闭-Linux-core-文件生成功能" class="headerlink" title="关闭 Linux core 文件生成功能"></a>关闭 Linux core 文件生成功能</h4><p>把核心转储功能关闭，只需要将限制大小设为<code>0</code> 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c 0</span><br></pre></td></tr></table></figure><p><strong>注意，如果只是输入命令“<code>ulimit -c unlimited</code>”，这只会在当前终端有效，退出终端或者打开一个新的终端时是无效的</strong>。</p><p>例子：</p><p>编写一个简单的 C 程序，人为制造一个<code>Segmentation fault</code>错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给一个NULL指令赋值，会产生 Segmentation fault 错误</span></span><br><span class="line">  *p = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中定义了一个空指针变量 P，然后给空指针 P 赋值，运行程序就会<strong>产生一个段错误</strong>。</p><p>开启了<strong>核心转储</strong>后，就会产生一个<code>core</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译 hello.c 生成 hello 程序</span></span><br><span class="line">gcc -o hello hello.c -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行该程序</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>运行后，我们可以看到 <code>Segmentation fault (core dumped)</code> 提示信息，表示已经在当前目录下产生了一个<code>core</code>文件：</p><h3 id="调试正在运行的程序"><a href="#调试正在运行的程序" class="headerlink" title="调试正在运行的程序"></a><strong>调试正在运行的程序</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program &lt;PID&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>直接指定 PID 启动 GDB</strong>（需要有可执行程序路径）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program &lt;PID&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>在 GDB 内 attach 到某个 PID</strong>：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach &lt;PID&gt;</span><br><span class="line">(gdb) detach   # 取消 attach</span><br></pre></td></tr></table></figure><hr><h2 id="常用启动参数"><a href="#常用启动参数" class="headerlink" title="常用启动参数"></a>常用启动参数</h2><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-s</code> 或 <code>-symbols &lt;file&gt;</code></td><td>指定符号表文件</td></tr><tr><td><code>-se &lt;file&gt;</code></td><td>指定符号表文件，并关联到可执行文件</td></tr><tr><td><code>-c</code> 或 <code>-core &lt;file&gt;</code></td><td>指定 core dump 文件用于调试</td></tr><tr><td><code>-d</code> 或 <code>-directory &lt;dir&gt;</code></td><td>添加源码搜索路径（默认用 <code>$PATH</code>）</td></tr></tbody></table></div><p>退出输入 quit(q)即可</p><h2 id="gdb-中运行-Shell-命令"><a href="#gdb-中运行-Shell-命令" class="headerlink" title="gdb 中运行 Shell 命令"></a>gdb 中运行 Shell 命令</h2><p>在 GDB 中可以直接运行操作系统的命令，方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell &lt;命令字符串&gt;</span><br><span class="line">(gdb) !&lt;命令字符串&gt;</span><br></pre></td></tr></table></figure><p>example</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell <span class="built_in">ls</span> -l</span><br><span class="line">(gdb) shell <span class="built_in">cat</span> input.txt</span><br></pre></td></tr></table></figure><p>这会在 GDB 内部启动你系统的 shell（由环境变量 <code>SHELL</code> 决定），然后执行你写的命令。</p><p>GDB 也内置了一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) make &lt;参数&gt;</span><br></pre></td></tr></table></figure><p>它本质上等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell make &lt;参数&gt;</span><br></pre></td></tr></table></figure><p>也就是说，它会调用系统的 <code>make</code> 工具来重新编译程序，非常方便调试时快速修改代码后重新 build。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) pip i locals | grep test</span><br><span class="line">(gdb) | thread apply all bt | wc</span><br></pre></td></tr></table></figure><h2 id="gdb-调试输出日志保存"><a href="#gdb-调试输出日志保存" class="headerlink" title="gdb 调试输出日志保存"></a>gdb 调试输出日志保存</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 打开日志输出，off为关闭</span><br><span class="line">(gdb) set logging on</span><br><span class="line"># 设置输出文件</span><br><span class="line">(gdb) set logging file filename</span><br><span class="line"># 覆盖输出文件，默认为追加</span><br><span class="line">(gdb) set logging overwrite</span><br></pre></td></tr></table></figure><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="显示源代码"><a href="#显示源代码" class="headerlink" title="显示源代码"></a>显示源代码</h3><ul><li>显示源代码 <strong>list</strong> or <strong>l,</strong>默认显示 10 行</li><li>设置每次显示的行数：<strong>set listsize xx</strong></li><li>查看指定的函数代码：<strong>list test_fun</strong></li><li>查看指定文件指定行代码: <strong>list main.cpp:15</strong></li></ul><h3 id="搜索源代码"><a href="#搜索源代码" class="headerlink" title="搜索源代码"></a>搜索源代码</h3><ul><li><strong>search</strong> 正则表达式</li><li><strong>forward-search</strong> 正则表达式</li><li><strong>reverse-search</strong> 正则表达式</li></ul><p>（输入 search 命令后按回车会继续找下一个匹配的，通过 list 命令指定起始搜索位置）</p><p>设置源代码搜索目录</p><ul><li><strong>directory path</strong></li></ul><h2 id="断点-breakpoint"><a href="#断点-breakpoint" class="headerlink" title="断点 (breakpoint)"></a>断点 (breakpoint)</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h4 id="按函数名设置断点"><a href="#按函数名设置断点" class="headerlink" title="按函数名设置断点"></a>按函数名设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> <span class="keyword">function</span></span><br></pre></td></tr></table></figure><ul><li>在指定函数的<strong>入口</strong>处停下。</li><li>对于 C++ 可以写成：<ul><li><code>break ClassName::Function</code></li><li><code>break function(type1, type2)</code>（如果重载）</li></ul></li></ul><h4 id="按行号设置断点"><a href="#按行号设置断点" class="headerlink" title="按行号设置断点"></a>按行号设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> 42</span><br></pre></td></tr></table></figure><ul><li>在当前源文件的第 <strong>42 行</strong> 设断点。</li></ul><h4 id="相对当前行设置断点"><a href="#相对当前行设置断点" class="headerlink" title="相对当前行设置断点"></a>相对当前行设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> +5     // 当前行之后5行</span><br><span class="line"><span class="built_in">break</span> -3     // 当前行之前3行</span><br></pre></td></tr></table></figure><h4 id="指定文件-行号"><a href="#指定文件-行号" class="headerlink" title="指定文件 + 行号"></a>指定文件 + 行号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> filename.c:42</span><br></pre></td></tr></table></figure><ul><li>在 <code>filename.c</code> 的第 42 行设置断点。</li></ul><h4 id="指定文件-函数名"><a href="#指定文件-函数名" class="headerlink" title="指定文件 + 函数名"></a>指定文件 + 函数名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> filename.c:func</span><br></pre></td></tr></table></figure><ul><li>在 <code>filename.c</code> 中 <code>func</code> 函数的入口处设置断点。</li></ul><h4 id="按地址设置断点"><a href="#按地址设置断点" class="headerlink" title="按地址设置断点"></a>按地址设置断点</h4><p>常用于汇编调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> *0x4007d0</span><br></pre></td></tr></table></figure><ul><li>在程序内存地址 <code>0x4007d0</code> 处设置断点。</li></ul><h4 id="设置条件断点"><a href="#设置条件断点" class="headerlink" title="设置条件断点"></a>设置条件断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> func <span class="keyword">if</span> i == 100</span><br></pre></td></tr></table></figure><ul><li>当变量 <code>i == 100</code> 且执行到 <code>func</code> 函数时才停下。</li></ul><h4 id="设置下一条语句的断点（无参数）"><a href="#设置下一条语句的断点（无参数）" class="headerlink" title="设置下一条语句的断点（无参数）"></a>设置下一条语句的断点（无参数）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span></span><br></pre></td></tr></table></figure><ul><li>在“下一条将要执行”的语句处设断点。</li></ul><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><h4 id="查看所有断点"><a href="#查看所有断点" class="headerlink" title="查看所有断点"></a>查看所有断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure><h4 id="查看指定编号的断点"><a href="#查看指定编号的断点" class="headerlink" title="查看指定编号的断点"></a>查看指定编号的断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info <span class="built_in">break</span> 3</span><br></pre></td></tr></table></figure><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><h4 id="删除某一个断点"><a href="#删除某一个断点" class="headerlink" title="删除某一个断点"></a>删除某一个断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete &lt;编号&gt;</span><br><span class="line">del &lt;编号&gt;</span><br></pre></td></tr></table></figure><ul><li>例如：<code>delete 1</code> 表示删除编号为 1 的断点。</li></ul><h4 id="删除多个断点"><a href="#删除多个断点" class="headerlink" title="删除多个断点"></a>删除多个断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete 1 2 3</span><br></pre></td></tr></table></figure><ul><li>同时删除断点 1、2 和 3。</li></ul><h4 id="删除所有断点"><a href="#删除所有断点" class="headerlink" title="删除所有断点"></a>删除所有断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure><ul><li><strong>不加参数</strong>表示删除所有断点。GDB 会提示你确认（输入 <code>y</code>）。</li></ul><h3 id="为断点添加命令"><a href="#为断点添加命令" class="headerlink" title="为断点添加命令"></a>为断点添加命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands &lt;bnum&gt;</span><br><span class="line">...gdb命令序列...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> foo <span class="keyword">if</span> x &gt; 0</span><br><span class="line">commands</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;x is %d\n&quot;</span>, x</span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>作用：x &gt; 0 时断点命中，打印后自动继续，不用手动按 <code>c</code>。</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">b</span> <span class="number">31</span></span><br><span class="line">commands</span><br><span class="line">&gt;<span class="selector-tag">p</span> *curr</span><br><span class="line">&gt;<span class="selector-tag">p</span> prev</span><br><span class="line">&gt;end</span><br><span class="line"><span class="selector-tag">i</span> <span class="selector-tag">b</span></span><br></pre></td></tr></table></figure><p>为断点设置命令后当程序停到该断点时自动打印出这两个值；</p><p>commands 命令后面可以直接跟断点的序号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> <span class="selector-tag">b</span></span><br><span class="line">commands <span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="清除已有命令"><a href="#清除已有命令" class="headerlink" title="清除已有命令"></a>清除已有命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands &lt;bnum&gt;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="忽略断点次数（ignore）"><a href="#忽略断点次数（ignore）" class="headerlink" title="忽略断点次数（ignore）"></a>忽略断点次数（ignore）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignore &lt;bnum&gt; &lt;count&gt;   <span class="comment"># 忽略断点号 bnum 的触发 count 次</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignore 2 3</span><br></pre></td></tr></table></figure><blockquote><p>忽略断点 2 的前三次命中，第 4 次才真正中断。</p></blockquote><p>example</p><ul><li><p>调试循环或大函数中的问题时，建议使用：<br><code>break &lt;line&gt; if i == 9999</code><br>或<br><code>ignore &lt;bnum&gt; 9998</code></p></li><li><p>在你定位 bug 后，不要删断点，直接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> &lt;bnum&gt;  <span class="comment"># 保留断点以后复用</span></span><br></pre></td></tr></table></figure></li><li><p>想测试多个变量变化时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch a</span><br><span class="line">watch b</span><br></pre></td></tr></table></figure></li><li><p>想搞自动化调试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">silent</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;Reached here\n&quot;</span></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><h3 id="保存断点到文件并读取"><a href="#保存断点到文件并读取" class="headerlink" title="保存断点到文件并读取"></a>保存断点到文件并读取</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) save breakpoints d<span class="selector-class">.txt</span></span><br><span class="line">(gdb) !cat d<span class="selector-class">.txt</span></span><br></pre></td></tr></table></figure><p>关闭后重新打开，应用已经保存的断点信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">source</span> d.txt</span><br></pre></td></tr></table></figure><h2 id="观察点-watchpoint"><a href="#观察点-watchpoint" class="headerlink" title="观察点 (watchpoint)"></a>观察点 (watchpoint)</h2><blockquote><p>观察点是一个特殊的断点，当表达式的值发生变化时，它将中断下来。表达式可以是一个变量的值，也可以包含由运算符组合的一个或多个变量的值，例如’a+b’。有时被称为数据断点</p></blockquote><h3 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h3><h4 id="watch-lt-expr-gt"><a href="#watch-lt-expr-gt" class="headerlink" title="watch &lt;expr&gt;"></a><code>watch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 的 <strong>值被改变</strong> 时，程序会暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch x</span><br><span class="line">watch gdata+gdata2&gt;10</span><br></pre></td></tr></table></figure><p>当变量 <code>x</code> 的值发生变化时暂停。</p><p>任何一个线程满足 gdata+gdata2&gt;10 程序都会停下来</p></li></ul><h4 id="rwatch-lt-expr-gt"><a href="#rwatch-lt-expr-gt" class="headerlink" title="rwatch &lt;expr&gt;"></a><code>rwatch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 被<strong>读取</strong>时，程序暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwatch y</span><br></pre></td></tr></table></figure><p>当变量 <code>y</code> 被读取时暂停程序。</p></li></ul><h4 id="awatch-lt-expr-gt"><a href="#awatch-lt-expr-gt" class="headerlink" title="awatch &lt;expr&gt;"></a><code>awatch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 被<strong>读取或写入</strong>时，程序暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awatch z</span><br></pre></td></tr></table></figure><p>当变量 <code>z</code> 被读取或写入时都暂停。</p></li></ul><h3 id="查看当前观察点"><a href="#查看当前观察点" class="headerlink" title="查看当前观察点"></a>查看当前观察点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info watchpoints</span><br></pre></td></tr></table></figure><ul><li>显示所有设置的观察点（类似 <code>info breakpoints</code>）。</li></ul><h3 id="删除观察点"><a href="#删除观察点" class="headerlink" title="删除观察点"></a>删除观察点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &lt;编号&gt;</span><br></pre></td></tr></table></figure><ul><li>与删除断点的方式一样。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>观察点依赖于 <strong>目标架构是否支持硬件观察点</strong>（大多数支持）。</li><li>不支持的情况下，GDB 可能无法设置 <code>watch</code>、<code>rwatch</code> 等。</li><li>观察点数量受限，一般比断点少（通常是 4 个）。</li></ul><h2 id="捕获点-catchpoint"><a href="#捕获点-catchpoint" class="headerlink" title="捕获点 (catchpoint)"></a>捕获点 (catchpoint)</h2><blockquote><p>捕获点是一个特殊的断点，命令语法为：catch event，即捕获到 event 这个事件的时候，程序就会中断下来</p></blockquote><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch &lt;event&gt;</span><br></pre></td></tr></table></figure><p>也可以使用一次性的捕获点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcatch &lt;event&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="常见-catchpoint-类型"><a href="#常见-catchpoint-类型" class="headerlink" title="常见 catchpoint 类型"></a>常见 catchpoint 类型</h3><div class="table-container"><table><thead><tr><th>事件类型</th><th>描述说明</th></tr></thead><tbody><tr><td><code>throw</code></td><td>捕获 C++ 程序抛出异常的位置。</td></tr><tr><td><code>catch</code></td><td>捕获 C++ 程序捕获异常的位置。</td></tr><tr><td><code>exec</code></td><td>捕获程序调用 <code>exec()</code> 系统调用（替换进程映像）。</td></tr><tr><td><code>fork</code></td><td>捕获程序调用 <code>fork()</code> 系统调用（创建子进程）。</td></tr><tr><td><code>vfork</code></td><td>捕获 <code>vfork()</code> 调用（特殊类型的 <code>fork()</code>）。</td></tr><tr><td><code>load</code></td><td>捕获动态链接库的加载事件。</td></tr><tr><td><code>unload</code></td><td>捕获动态链接库的卸载事件。</td></tr></tbody></table></div><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch throw</span><br></pre></td></tr></table></figure><blockquote><p>在 C++ 抛出异常时中断程序。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch fork</span><br></pre></td></tr></table></figure><blockquote><p>在程序调用 <code>fork()</code> 时中断。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcatch <span class="built_in">exec</span></span><br></pre></td></tr></table></figure><blockquote><p>设置一次性的捕获点，在程序调用 <code>exec()</code> 系统调用时暂停，之后自动移除。</p></blockquote><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>catch assert</td><td>Catch failed Ada assertions, when raised.</td></tr><tr><td>catch catch</td><td>Catch an exception, when caught.</td></tr><tr><td>catch exception</td><td>Catch Ada exceptions, when raised.</td></tr><tr><td>catch exec</td><td>Catch calls to exec.</td></tr><tr><td>catch fork</td><td>Catch calls to fork.</td></tr><tr><td>catch handlers</td><td>Catch Ada exceptions, when handled.</td></tr><tr><td>catch load</td><td>Catch loads of shared libraries.</td></tr><tr><td>catch rethrow</td><td>Catch an exception, when rethrown.</td></tr><tr><td>catch signal</td><td>Catch signals by their names and/or numbers.</td></tr><tr><td>catch syscall</td><td>Catch system calls by their names, groups and/or numbers.</td></tr><tr><td>catch throw</td><td>Catch an exception, when thrown.</td></tr><tr><td>catch unload</td><td>Catch unloads of shared libraries.</td></tr><tr><td>catch vfork</td><td>Catch calls to vfork.</td></tr></tbody></table></div><h2 id="程序停止点清除"><a href="#程序停止点清除" class="headerlink" title="程序停止点清除"></a>程序停止点清除</h2><h3 id="清除停止点（clear）"><a href="#清除停止点（clear）" class="headerlink" title="清除停止点（clear）"></a>清除停止点（clear）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clear                    <span class="comment"># 清除当前位置所有停止点</span></span><br><span class="line">clear &lt;<span class="keyword">function</span>&gt;         <span class="comment"># 清除函数上的所有停止点</span></span><br><span class="line">clear &lt;filename:<span class="keyword">function</span>&gt;# 指定源文件和函数</span><br><span class="line">clear &lt;linenum&gt;          <span class="comment"># 清除当前文件某行的断点</span></span><br><span class="line">clear &lt;filename:linenum&gt; <span class="comment"># 指定文件+行号清除</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：<code>clear</code> 是基于“<strong>位置</strong>”清除，而非编号。</p></blockquote><h3 id="删除断点（delete）"><a href="#删除断点（delete）" class="headerlink" title="删除断点（delete）"></a>删除断点（delete）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete                   <span class="comment"># 删除所有断点</span></span><br><span class="line">delete &lt;bnum&gt;            <span class="comment"># 删除指定编号的断点</span></span><br><span class="line">delete &lt;range&gt;           <span class="comment"># 如 delete 3-5，删除编号 3 到 5 的断点</span></span><br><span class="line">d                        <span class="comment"># delete 的简写</span></span><br></pre></td></tr></table></figure><h3 id="禁用-启用断点（disable-enable）"><a href="#禁用-启用断点（disable-enable）" class="headerlink" title="禁用/启用断点（disable / enable）"></a>禁用/启用断点（disable / enable）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span>                  <span class="comment"># 禁用所有断点</span></span><br><span class="line"><span class="built_in">disable</span> &lt;bnum&gt; [range]   <span class="comment"># 禁用特定断点</span></span><br><span class="line">dis                      <span class="comment"># disable 的简写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">enable</span>                   <span class="comment"># 启用所有断点</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt;            <span class="comment"># 启用某个断点</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt; once       <span class="comment"># 执行一次后自动 disable</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt; delete     <span class="comment"># 执行一次后自动删除</span></span><br></pre></td></tr></table></figure><blockquote><p>推荐使用 <code>disable/enable</code> 管理调试状态，灵活又不丢失断点信息。</p></blockquote><hr><h2 id="设置-修改停止点的条件（condition）"><a href="#设置-修改停止点的条件（condition）" class="headerlink" title="设置 / 修改停止点的条件（condition）"></a>设置 / 修改停止点的条件（condition）</h2><h3 id="设置条件停止点（设置时）"><a href="#设置条件停止点（设置时）" class="headerlink" title="设置条件停止点（设置时）"></a>设置条件停止点（设置时）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> foo <span class="keyword">if</span> x &gt; 5</span><br><span class="line">watch var <span class="keyword">if</span> var == 0</span><br></pre></td></tr></table></figure><h3 id="修改断点条件（维护时）"><a href="#修改断点条件（维护时）" class="headerlink" title="修改断点条件（维护时）"></a>修改断点条件（维护时）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">condition &lt;bnum&gt; x &gt; 100     <span class="comment"># 修改断点编号为 bnum 的条件</span></span><br><span class="line">condition &lt;bnum&gt;            <span class="comment"># 清除断点条件</span></span><br></pre></td></tr></table></figure><hr><h2 id="调试程序执行"><a href="#调试程序执行" class="headerlink" title="调试程序执行"></a>调试程序执行</h2><h3 id="恢复程序运行（继续执行）"><a href="#恢复程序运行（继续执行）" class="headerlink" title="恢复程序运行（继续执行）"></a>恢复程序运行（继续执行）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>continue</code> / <code>c</code> / <code>fg</code></td><td>从当前断点处继续运行</td></tr><tr><td><code>continue &lt;ignore-count&gt;</code></td><td>忽略接下来的 <code>&lt;count&gt;</code> 次断点命中</td></tr><tr><td><code>run</code> / <code>r</code></td><td>重新启动程序（从头开始）</td></tr></tbody></table></div><blockquote><p>适用于程序刚停下，想跳过一些断点或继续往下执行。</p></blockquote><h3 id="单步调试（源代码级）"><a href="#单步调试（源代码级）" class="headerlink" title="单步调试（源代码级）"></a>单步调试（源代码级）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>step</code> / <code>s</code></td><td>单步执行，会进入函数（Step Into）</td></tr><tr><td><code>next</code> / <code>n</code></td><td>单步执行，不进入函数（Step Over）</td></tr><tr><td><code>step &lt;count&gt;</code> / <code>next &lt;count&gt;</code></td><td>连续执行 <code>&lt;count&gt;</code> 步</td></tr></tbody></table></div><blockquote><p>用于逐行查看程序逻辑，<code>step</code> 会进函数内部，<code>next</code> 则略过。</p></blockquote><h3 id="退出当前函数（函数级跳出）"><a href="#退出当前函数（函数级跳出）" class="headerlink" title="退出当前函数（函数级跳出）"></a>退出当前函数（函数级跳出）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>finish</code></td><td>继续运行到当前函数返回，并打印返回值和返回地址</td></tr></tbody></table></div><blockquote><p>非常实用，适合跟踪完某个函数后退出它。</p></blockquote><h3 id="跳出循环体-块（until）"><a href="#跳出循环体-块（until）" class="headerlink" title="跳出循环体 / 块（until）"></a>跳出循环体 / 块（until）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>until &lt;location&gt;</code> / <code>u</code></td><td>执行直到某个位置或当前块结束（适合退出循环）</td></tr></tbody></table></div><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> 42            <span class="comment"># 运行到当前文件的第 42 行</span></span><br><span class="line"><span class="keyword">until</span> main.c:100    <span class="comment"># 运行到 main.c 第 100 行</span></span><br></pre></td></tr></table></figure><blockquote><p>用于快速跳出 for/while 循环等结构块。</p></blockquote><h3 id="汇编级单步（指令级调试）"><a href="#汇编级单步（指令级调试）" class="headerlink" title="汇编级单步（指令级调试）"></a>汇编级单步（指令级调试）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>stepi</code> / <code>si</code></td><td>单步执行一条机器指令（Step Into）</td></tr><tr><td><code>nexti</code> / <code>ni</code></td><td>单步执行一条机器指令（Step Over）</td></tr></tbody></table></div><blockquote><p>用于底层跟踪，比如跟踪系统调用、libc 内部逻辑或 boot code。</p></blockquote><p>汇编查看建议：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display/i <span class="variable">$pc</span>     <span class="comment"># 实时显示当前执行指令</span></span><br></pre></td></tr></table></figure><h3 id="设置-step-mode-模式"><a href="#设置-step-mode-模式" class="headerlink" title="设置 step-mode 模式"></a>设置 step-mode 模式</h3><p>主要用于控制是否进入无符号函数</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>set step-mode on</code></td><td>即使没有 debug 符号也停住（默认 off）</td></tr><tr><td><code>set step-mode off</code></td><td>遇到无符号函数就跳过（默认）</td></tr></tbody></table></div><blockquote><p>对调试汇编或只含部分符号的库文件时很有用。</p></blockquote><h2 id="skip-跳过某个函数的单步执行"><a href="#skip-跳过某个函数的单步执行" class="headerlink" title="skip 跳过某个函数的单步执行"></a>skip 跳过某个函数的单步执行</h2><ul><li>skip function</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test_str</span>(test.<span class="built_in">get_str</span>());</span><br></pre></td></tr></table></figure><p>如果我们不关心 get_str()但是想要看 test_str()，执行 s 命令时会先进入 get_str()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">(gdb) finish</span><br><span class="line"></span><br><span class="line">(gdb) skip test_c::get_str</span><br><span class="line">(gdb) s</span><br></pre></td></tr></table></figure><p>skip 不是 jump，虽然 skip 了这个函数，但是实际上它还是会执行，只是跳过了调试</p><ul><li>skip file filename</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) skip file test.cpp</span><br></pre></td></tr></table></figure><ul><li>skip -gfi 通配符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> -gfi可以通过文件名通配符匹配的方式跳过</span><br><span class="line">(gdb) skip -gfi common/*.*</span><br></pre></td></tr></table></figure><h2 id="jump-命令跳转"><a href="#jump-命令跳转" class="headerlink" title="jump 命令跳转"></a>jump 命令跳转</h2><blockquote><p>在指定位置恢复执行，如果存在断点，执行到指定位置时将中断下来。如果没有断点，则不会停下来，因此，我们通常会在指定位置设置一个断点。跳转命令不会更改当前堆栈帧，堆栈指针，程序计数器以外的任何寄存器</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 向前跳转或向后跳转跳过某些行都可以，但跳转到别的函数的结果是不可预期的</span><br><span class="line">(gdb) jump location</span><br><span class="line">(gdb) j location</span><br><span class="line"></span><br><span class="line"># 可以用改变pc寄存器来实现跳转</span><br><span class="line">(gdb) i line 12</span><br><span class="line">(gdb) p $pc=0x5400000</span><br></pre></td></tr></table></figure><ul><li><strong>核心作用</strong>：强制程序<strong>跳转到指定位置执行</strong>（可以是任意行号或地址），直接 “跳过” 中间的执行步骤。</li></ul><h2 id="rn-反向执行"><a href="#rn-反向执行" class="headerlink" title="rn 反向执行"></a>rn 反向执行</h2><p>首先要执行 record 命令</p><blockquote><p>必须是 non-stop mode</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) record</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"># 反向执行一步</span><br><span class="line">(gdb) rn</span><br><span class="line"># 反向执行到这个函数的开始</span><br><span class="line">(gdb) reverse-fisnish</span><br><span class="line">(gdb) record stop</span><br></pre></td></tr></table></figure><ul><li><p><strong>核心作用</strong>：实现<strong>程序执行历史的回溯</strong>，让程序 “倒着跑”，用于排查已经发生的错误（如变量何时被意外修改）。</p><p><strong>停止模式（默认）</strong></p></li><li><p>当你执行 <code>run</code> 或 <code>continue</code> 时，<strong>整个程序和所有线程都会暂停/继续</strong>。</p></li><li>特点：<ul><li>简单、易用</li><li>线程调试时无法单独控制线程</li></ul></li><li>默认就是停止模式。</li></ul><p><strong>非停止模式（Non-stop mode）</strong></p><ul><li><p>每个线程可以单独暂停或继续，而不影响其他线程。</p></li><li><p>特点：</p><ul><li>可以在多线程程序中只暂停某一线程进行调试</li><li>支持更灵活的线程调试</li></ul></li><li><p>开启方法：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> non-<span class="built_in">stop</span> <span class="keyword">on</span></span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li>不支持某些功能，例如 <strong>process record</strong>（执行记录）和某些远程 target 功能</li></ul></li></ul><h1 id="查看运行时数据"><a href="#查看运行时数据" class="headerlink" title="查看运行时数据"></a>查看运行时数据</h1><p>程序暂停时，使用 print 命令（简写 p）或者用同义命令 inspect 查看当前程序的运行数据，格式为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="symbol">&lt;expr&gt;</span></span><br><span class="line"><span class="keyword">print</span>/<span class="symbol">&lt;f&gt;</span> <span class="symbol">&lt;expr&gt;</span></span><br></pre></td></tr></table></figure><ul><li><expr>为要调试的程序语言的表达式</li><li><f>是 format 的意思，比如按 16 进制输出就是/x</li></ul><h2 id="print-p-输出格式"><a href="#print-p-输出格式" class="headerlink" title="print(p)输出格式"></a>print(p)输出格式</h2><p>一般来说，GDB 会根据变量的类型输出变量的值。但你也可以自定义 GDB 的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整<br>型变量的中的位的情况。要做到这样，你可以使用 GDB 的数据显示格式：</p><ul><li>x 按十六进制格式显示变量。 (hex)</li><li>d 按十进制格式显示变量。 (decimal)</li><li>u 按十六进制格式显示无符号整型。 (unsinged hex)</li><li>o 按八进制格式显示变量。 (octal)</li><li>t 按二进制格式显示变量。 (two)</li><li>a 按十六进制格式显示变量。 (address)</li><li>c 按字符格式显示变量。 (char)</li><li>f 按浮点数格式显示变量。 (float)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p i</span><br><span class="line"><span class="variable">$21</span> = 101</span><br><span class="line">(gdb) p/a i</span><br><span class="line"><span class="variable">$22</span> = 0x65</span><br><span class="line">(gdb) p/c i</span><br><span class="line"><span class="variable">$23</span> = 101 <span class="string">&#x27;e&#x27;</span></span><br><span class="line">(gdb) p/f i</span><br><span class="line"><span class="variable">$24</span> = 1.41531145e-43 (gdb) p/x i</span><br><span class="line"><span class="variable">$25</span> = 0x65</span><br><span class="line">(gdb) p/t i</span><br><span class="line"><span class="variable">$26</span> = 1100101</span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式可以是当前程序运行中的 const 常量，变量，函数等内容，但不能是程序中定义的宏</p><h3 id="程序变量"><a href="#程序变量" class="headerlink" title="程序变量"></a>程序变量</h3><p>在 GDB 中，你可以随时查看以下三种变量的值：</p><ol><li>全局变量（所有文件可见的）</li><li>静态全局变量（当前文件可见的）</li><li>局部变量（当前 Scope 可见的）</li></ol><p>用 print 显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>::<span class="keyword">variable</span></span><br><span class="line"><span class="keyword">function</span>::<span class="keyword">variable</span></span><br></pre></td></tr></table></figure><p>example</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb) p <span class="string">&#x27;f2.c&#x27;</span>::x</span><br></pre></td></tr></table></figure><div class="tip warning faa-horizontal animated"><p>注意：如果你的程序编译时开启了优化选项，那么在用 GDB 调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在 GDB 调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU 的 C/C++编译器 GCC，你可以使用“-gstabs”选项来解决这个问题。</p></div><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="built_in">array</span> = (<span class="type">int</span> *) <span class="built_in">malloc</span> (len * <span class="keyword">sizeof</span> (<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>在 GDB 调试过程中，你可以以如下命令显示出这个动态数组的取值：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> *array<span class="keyword">@len</span></span><br></pre></td></tr></table></figure><p>@的左边是数组的首地址的值，也就是变量 array 所指向的内容，右边则是数据的长度，其保存在变量 len 中，其输出结果，大约是下面这个样子的：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p <span class="number">*a</span>rray@len</span><br><span class="line"><span class="variable">$1</span> = &#123;2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40&#125; 如果是静态数组的话，可以直接用 <span class="built_in">print</span> 数组名，就可以显示数组中所有数据的内容了。</span><br></pre></td></tr></table></figure><p>如果是静态数组的话，可以直接用 print 数组名，就可以显示数组中所有数据的内容了。</p><h2 id="examine-x-查看内存"><a href="#examine-x-查看内存" class="headerlink" title="examine(x)查看内存"></a>examine(x)查看内存</h2><p>使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="attribute">&lt;n/f/u&gt;</span> <span class="attribute">&lt;addr&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>n：显示的个数，即从内存地址 <addr> 开始，显示几个单位（默认为 1）。</p></li><li><p>f：显示格式，比如：</p><ul><li>x 十六进制</li><li>d 十进制</li><li>t 二进制</li><li>c 字符</li><li>f 浮点数</li><li>s 字符串</li><li>i 指令</li></ul></li><li><p>u：读取单位的大小，决定每次读取多少字节：</p><ul><li>b = 1 字节（byte）</li><li>h = 2 字节（half word）</li><li>w = 4 字节（word，默认）</li><li>g = 8 字节（giant/quad word）</li></ul></li></ul><h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><p>要查看寄存器的值，很简单，可以使用 info registers (i r)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看寄存器的情况。（除了浮点寄存器）</span></span><br><span class="line"><span class="built_in">info</span> all-registers</span><br><span class="line"><span class="comment"># 查看所有寄存器的情况。（包括浮点寄存器）</span></span><br><span class="line"><span class="built_in">info</span> registers &lt;regname <span class="built_in">..</span>.&gt;</span><br></pre></td></tr></table></figure><p>也可以使用 print 命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">p</span> <span class="variable">$eip</span>。</span><br></pre></td></tr></table></figure><p>查看所指定的寄存器的情况。<br>寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用 print 命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。</p><h2 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h2><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的 GDB 命令是 display。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">display</span> <span class="symbol">&lt;expr&gt;</span></span><br><span class="line"><span class="keyword">display</span>/<span class="symbol">&lt;fmt&gt;</span> <span class="symbol">&lt;expr&gt;</span></span><br><span class="line"><span class="keyword">display</span>/<span class="symbol">&lt;fmt&gt;</span> <span class="symbol">&lt;addr&gt;</span></span><br></pre></td></tr></table></figure><ul><li>expr 是一个表达式</li><li>fmt 表示显示的格式</li><li>addr 表示内存地址<br>当你用 display 设定好了一个或多个表达式后，只要你的程序被停下来，GDB 会自动显示你所设置的这些表达式的值。</li></ul><p>格式 i 和 s 同样被 display 支持，一个非常有用的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display/i <span class="variable">$pc</span></span><br></pre></td></tr></table></figure><p>$pc 是 GDB 的环境变量，表示着指令的地址，/i 则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形</p><h3 id="删除自动显示"><a href="#删除自动显示" class="headerlink" title="删除自动显示"></a>删除自动显示</h3><p>要删除自动显示可以用下面的命令</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undisplay &lt;dnums...&gt;</span><br><span class="line"><span class="keyword">delete</span> display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><ul><li>dnums 意为所设置好了的自动显式的编号。<br>如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</li></ul><h3 id="隐藏自动显示"><a href="#隐藏自动显示" class="headerlink" title="隐藏自动显示"></a>隐藏自动显示</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">disable</span> display &lt;dnums<span class="built_in">..</span>.&gt;</span><br><span class="line">(gdb) <span class="built_in">enable</span> display &lt;dnums<span class="built_in">..</span>.&gt;</span><br></pre></td></tr></table></figure><p>disable 和 enalbe 不删除自动显示的设置，而只是让其失效和恢复。</p><h3 id="查看设置的自动显示的信息"><a href="#查看设置的自动显示的信息" class="headerlink" title="查看设置的自动显示的信息"></a>查看设置的自动显示的信息</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">info</span> display</span><br></pre></td></tr></table></figure><p>查看 display 设置的自动显示的信息。GDB 会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否 enable。</p><h2 id="查看函数参数"><a href="#查看函数参数" class="headerlink" title="查看函数参数"></a>查看函数参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info args</span><br><span class="line">(gdb) i args</span><br><span class="line"></span><br><span class="line"># 查看都有哪些函数</span><br><span class="line">(gdb) info functions</span><br></pre></td></tr></table></figure><h2 id="查看局部变量"><a href="#查看局部变量" class="headerlink" title="查看局部变量"></a>查看局部变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info locals</span><br><span class="line">(gdb) i locals</span><br></pre></td></tr></table></figure><h2 id="运行中修改值"><a href="#运行中修改值" class="headerlink" title="运行中修改值"></a>运行中修改值</h2><h3 id="修改变量的值"><a href="#修改变量的值" class="headerlink" title="修改变量的值"></a>修改变量的值</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p test.<span class="attribute">age</span>=28</span><br><span class="line">(gdb) <span class="built_in">set</span> &#123;int&#125;&amp;test.gender = 110</span><br></pre></td></tr></table></figure><h3 id="修改寄存器的值"><a href="#修改寄存器的值" class="headerlink" title="修改寄存器的值"></a>修改寄存器的值</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">var</span> <span class="variable">$pc</span>=xxx</span><br><span class="line">p <span class="variable">$rip</span>=xxx</span><br></pre></td></tr></table></figure><p>可以配合 info 指令，查看某一行的地址，或查看某一个栈帧的地址</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">info</span> line 14</span><br><span class="line">p <span class="variable">$pc</span>=0x5555555553a3</span><br><span class="line"></span><br><span class="line"><span class="built_in">info</span> f 0</span><br></pre></td></tr></table></figure><h2 id="查看函数调用栈"><a href="#查看函数调用栈" class="headerlink" title="查看函数调用栈"></a>查看函数调用栈</h2><h3 id="backtrace-bt-查看栈回溯信息"><a href="#backtrace-bt-查看栈回溯信息" class="headerlink" title="backtrace/bt 查看栈回溯信息"></a><strong>backtrace/bt</strong> 查看栈回溯信息</h3><h3 id="frame-n-切换栈帧"><a href="#frame-n-切换栈帧" class="headerlink" title="frame n 切换栈帧"></a><strong>frame n</strong> 切换栈帧</h3><h3 id="info-f-n-查看栈帧信息"><a href="#info-f-n-查看栈帧信息" class="headerlink" title="info f n 查看栈帧信息"></a><strong>info f n</strong> 查看栈帧信息</h3><h2 id="查看数据类型信息"><a href="#查看数据类型信息" class="headerlink" title="查看数据类型信息"></a>查看数据类型信息</h2><h3 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a><strong>whatis</strong></h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) whatis test1</span><br><span class="line">(gdb) whatis test2</span><br><span class="line">(gdb) whatis node</span><br><span class="line">(gdb) whatis <span class="selector-tag">main</span></span><br><span class="line">(gdb) whatis test3<span class="selector-class">.test_fun2</span></span><br></pre></td></tr></table></figure><h3 id="ptype"><a href="#ptype" class="headerlink" title="ptype"></a><strong>ptype</strong></h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p<span class="keyword">type</span> test1</span><br></pre></td></tr></table></figure><p>可以显示这个类的成员变量，函数等</p><h4 id="ptype-m"><a href="#ptype-m" class="headerlink" title="ptype /m"></a>ptype /m</h4><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p<span class="keyword">type</span> /m test1</span><br></pre></td></tr></table></figure><p>不显示成员函数了</p><h4 id="ptype-t"><a href="#ptype-t" class="headerlink" title="ptype /t"></a>ptype /t</h4><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p<span class="keyword">type</span> /t test3</span><br></pre></td></tr></table></figure><p>不显示 typedef</p><h4 id="ptype-o"><a href="#ptype-o" class="headerlink" title="ptype /o"></a>ptype /o</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ptype /o <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure><p>查看结构体的偏移量和大小</p><h3 id="i-variables"><a href="#i-variables" class="headerlink" title="i variables"></a><strong>i variables</strong></h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i variables <span class="built_in">count</span></span><br></pre></td></tr></table></figure><p>会显示所有变量名含有 count 的变量的定义</p><h3 id="set-print-object-on"><a href="#set-print-object-on" class="headerlink" title="set print object on"></a>set print object on</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="built_in">print</span> object on</span><br><span class="line">(gdb) ptype test2</span><br></pre></td></tr></table></figure><p>set print object on 表示显示出类的派生类型</p><h2 id="调用内部外部函数"><a href="#调用内部外部函数" class="headerlink" title="调用内部外部函数"></a>调用内部外部函数</h2><ul><li>p 表达式</li></ul><blockquote><p>求表达式的值并显示结果值。表达式可以包括对正在调试的程序中的函数的调用，即使函数返回值是 void，也会显示</p></blockquote><ul><li>call 表达式</li></ul><blockquote><p>求表达式的值并显示结果值，如果是函数调用，返回值是 void 的话，不显示 void 返回值</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> <span class="built_in">sizeof</span>(int)</span><br><span class="line"><span class="selector-tag">p</span> <span class="built_in">strlen</span>(name)</span><br><span class="line"></span><br><span class="line">call (int)<span class="built_in">getpid</span>()</span><br><span class="line"></span><br><span class="line">call <span class="built_in">malloc</span>(<span class="number">10</span>)</span><br><span class="line">call <span class="built_in">strcpy</span>($<span class="number">5</span>,&quot;soft&quot;)</span><br></pre></td></tr></table></figure><p>还有 strcmp,printf 等</p><h1 id="多线程程序调试"><a href="#多线程程序调试" class="headerlink" title="多线程程序调试"></a>多线程程序调试</h1><h2 id="线程管理相关命令"><a href="#线程管理相关命令" class="headerlink" title="线程管理相关命令"></a>线程管理相关命令</h2><h3 id="info-threads"><a href="#info-threads" class="headerlink" title="info threads"></a>info threads</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">gdb</span>) info threads</span><br><span class="line">(<span class="name">gdb</span>) i threads</span><br></pre></td></tr></table></figure><p>查看所有线程信息，结果中序号前面有”*“表示当前线程</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251010211018276.png" alt="info threads"></p><ul><li>Thread 后面跟线程的地址</li><li>LWP 表示 Light Weight Process，轻量级线程（可以在命令行中使用 ps -aL 查看所有轻量级线程）</li><li>为给线程起名字时默认使用进程的名字</li></ul><h3 id="thread-find"><a href="#thread-find" class="headerlink" title="thread find"></a>thread find</h3><p>查找线程</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="function">thread find <span class="title">multh</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span> thread find 689519</span></span><br></pre></td></tr></table></figure><p>搜索的范围是线程，地址，lwp 以及线程名字，也就是 i threads 的前三项</p><h3 id="thread-num"><a href="#thread-num" class="headerlink" title="thread num"></a>thread num</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">gdb</span>) bt</span><br><span class="line">(<span class="name">gdb</span>) thread <span class="number">2</span></span><br><span class="line">(<span class="name">gdb</span>) bt</span><br></pre></td></tr></table></figure><p>切换线程，bt 只会显示当前线程的调用栈</p><h3 id="thread-name"><a href="#thread-name" class="headerlink" title="thread name"></a>thread name</h3><p>设置线程名字，设置的是当前线程的名字</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread name main</span><br></pre></td></tr></table></figure><h3 id="b-breakpoint-thread-id"><a href="#b-breakpoint-thread-id" class="headerlink" title="b breakpoint thread id"></a>b breakpoint thread id</h3><p>为线程单独设置断点</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b <span class="number">15</span> thread <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果用普通的 b 15，那么所有线程<strong>如果能执行到第 15 行</strong>都会停止下来</p><h3 id="thread-apply"><a href="#thread-apply" class="headerlink" title="thread apply"></a>thread apply</h3><p>为线程执行命令</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread <span class="built_in">apply</span> <span class="number">3</span> i <span class="built_in">args</span></span><br><span class="line">(gdb) thread <span class="built_in">apply</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> i <span class="built_in">args</span></span><br><span class="line">(gdb) thread <span class="built_in">apply</span> <span class="number">1</span>-<span class="number">3</span> <span class="number">5</span> i <span class="built_in">args</span></span><br><span class="line">(gdb) thread <span class="built_in">apply</span> all i locals</span><br></pre></td></tr></table></figure><p>-q 不显示线程信息</p><p>-s 不显示错误信息</p><p>这两个参数都要放在线程 id 后面</p><h3 id="set-scheduler-locking-off-on-step"><a href="#set-scheduler-locking-off-on-step" class="headerlink" title="set scheduler-locking off|on|step"></a>set scheduler-locking off|on|step</h3><p><code>set scheduler-locking</code> 通过设置锁定策略，限制其他线程的执行，确保调试焦点始终在目标线程上</p><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th><th>适用场景</th></tr></thead><tbody><tr><td><code>off</code></td><td>关闭锁定（默认），调度器可自由切换所有线程执行。</td><td>需观察多线程交互时（如线程同步、通信），允许其他线程自然执行。</td></tr><tr><td><code>on</code></td><td>开启完全锁定，<strong>只有当前被调试的线程能执行</strong>，其他线程被暂停。</td><td>专注调试单个线程的逻辑（如函数调用链、局部变量变化），避免其他线程干扰。</td></tr><tr><td><code>step</code></td><td>分步锁定，仅在单步执行（<code>step</code>）时锁定其他线程，<code>continue</code> 时解锁。</td><td>单步调试时需要隔离其他线程，但希望 <code>continue</code> 后程序能正常多线程运行。</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前 scheduler-locking 配置</span><br><span class="line">(gdb) show scheduler-locking</span><br><span class="line">scheduler-locking is off.</span><br><span class="line"></span><br><span class="line"># 设置为完全锁定（on），确保当前调试的线程独占核心</span><br><span class="line">(gdb) set scheduler-locking on</span><br><span class="line"></span><br><span class="line"># 单步执行内核代码时，设置为分步锁定（step）</span><br><span class="line">(gdb) set scheduler-locking step</span><br><span class="line"></span><br><span class="line"># 调试完成后，恢复为默认（off）</span><br><span class="line">(gdb) set scheduler-locking off</span><br></pre></td></tr></table></figure><p>打印线程事件信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show <span class="built_in">print</span> thread-events</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="built_in">print</span> thread-events off</span><br></pre></td></tr></table></figure><h2 id="多线程死锁调试"><a href="#多线程死锁调试" class="headerlink" title="多线程死锁调试"></a>多线程死锁调试</h2><p>死锁条件：</p><ul><li>互斥条件</li><li>保持和请求条件</li><li>不可剥夺条件</li><li>循环等待条件</li></ul><p>常用命令：</p><ul><li>thread 2</li><li>bt</li><li>f 2</li><li>p _mutex_2</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013210411803.png" alt="查看锁的owner"></p><p>解决死锁的方式：</p><ul><li>顺序使用锁</li><li>控制锁的作用范围</li><li>可以使用超时机制</li></ul><h1 id="多进程程序调试"><a href="#多进程程序调试" class="headerlink" title="多进程程序调试"></a>多进程程序调试</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="inferior"><a href="#inferior" class="headerlink" title="inferior"></a>inferior</h3><blockquote><p>gdb 使用 inferior 来表示一个被调试进程的状态，通常情况下，一个 inferior 代表一个进程，这是 gdb 内部的概念和对象，我们可以把运行的进程 attach 到 inferior 上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i inferiors</span><br><span class="line">(gdb) add-inferior</span><br><span class="line">(gdb) remove-inferior 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) !ps aux | grep rele</span><br><span class="line">(gdb) attach 2959251</span><br><span class="line"></span><br><span class="line">(gdb) i inferiors</span><br><span class="line">(gdb) detach inferior 2</span><br></pre></td></tr></table></figure><h3 id="set-schedule-multiple-on-off"><a href="#set-schedule-multiple-on-off" class="headerlink" title="set schedule-multiple on/off"></a>set schedule-multiple on/off</h3><p>允许多个进程同时执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show schedule-multiple</span><br><span class="line">(gdb) set schedule-mulitple on</span><br></pre></td></tr></table></figure><h2 id="调试子进程"><a href="#调试子进程" class="headerlink" title="调试子进程"></a>调试子进程</h2><p>默认情况下无法调试子进程</p><h3 id="set-follow-fork-mode-child-parent"><a href="#set-follow-fork-mode-child-parent" class="headerlink" title="set follow-fork-mode child/parent"></a>set follow-fork-mode child/parent</h3><blockquote><p>默认情况下，follow-fork-mode 为 parent，即调试跟着父进程走，设置为 child 时才会跟着子进程走</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set follow-fork-mode child</span><br><span class="line">(gdb) show follow-fork-mode</span><br></pre></td></tr></table></figure><h3 id="set-detach-on-fork-on-off"><a href="#set-detach-on-fork-on-off" class="headerlink" title="set detach-on-fork on/off"></a>set detach-on-fork on/off</h3><p>默认情况下，detach-on-fork 为 on，即调试子进程时，父进程继续执行，父进程有可能直接执行结束，无法调试父进程了。因此，如果想要同时调试父进程和子进程，需要</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">set</span> detach-<span class="keyword">on</span>-fork <span class="keyword">off</span></span><br></pre></td></tr></table></figure><h3 id="info-inferiors"><a href="#info-inferiors" class="headerlink" title="info inferiors"></a>info inferiors</h3><p>查看由 gdb 启动的进程，也就是 gdb 的子进程</p><h3 id="inferior-process-num"><a href="#inferior-process-num" class="headerlink" title="inferior process_num"></a>inferior process_num</h3><p>切换到 1 号子进程</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">gdb</span>) inferior <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="制作调试发行版"><a href="#制作调试发行版" class="headerlink" title="制作调试发行版"></a>制作调试发行版</h1><p>发行版需要一个没有调试信息的版本，同时也要保留有调试信息的版本，方便调试</p><h2 id="方法-1：去掉-g-参数和带有-g-参数的两个版本"><a href="#方法-1：去掉-g-参数和带有-g-参数的两个版本" class="headerlink" title="方法 1：去掉-g 参数和带有-g 参数的两个版本"></a>方法 1：去掉-g 参数和带有-g 参数的两个版本</h2><p>在 Makefile 中写两个编译任务，分别是带-g 参数和不带-g 参数的版本</p><h2 id="方法-2：strip-命令"><a href="#方法-2：strip-命令" class="headerlink" title="方法 2：strip 命令"></a>方法 2：strip 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strip -g debug_version.o release_version.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">gdb --symbol=debug_version.o -<span class="built_in">exec</span>=release_version.o</span><br></pre></td></tr></table></figure><h2 id="方法-3：objcopy-命令"><a href="#方法-3：objcopy-命令" class="headerlink" title="方法 3：objcopy 命令"></a>方法 3：objcopy 命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成纯调试符号文件</span></span><br><span class="line">objcopy --only-keep-debug debug_version.o debug.sym</span><br><span class="line"><span class="comment"># 调试</span></span><br><span class="line">gdb --symbol=debug.sym -<span class="built_in">exec</span>=release_version.o</span><br></pre></td></tr></table></figure><h1 id="直接编辑可执行文件"><a href="#直接编辑可执行文件" class="headerlink" title="直接编辑可执行文件"></a>直接编辑可执行文件</h1><p>gdb 启动时加入参数—write</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) gdb --write test.o</span><br><span class="line"># 显示源码对应的汇编和机器码</span><br><span class="line">(gdb) disassemble /mr check_some</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013202057070.png" alt="disassemble /mr"></p><p>我们要修改的是机器码，修改后直接退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &#123;unsigned char&#125;0x00000000000011b4=0x65</span><br><span class="line">(gdb) q</span><br></pre></td></tr></table></figure><h1 id="内存检查"><a href="#内存检查" class="headerlink" title="内存检查"></a>内存检查</h1><h2 id="内存泄漏检查"><a href="#内存泄漏检查" class="headerlink" title="内存泄漏检查"></a>内存泄漏检查</h2><h3 id="call-malloc-stats"><a href="#call-malloc-stats" class="headerlink" title="call malloc_stats()"></a>call malloc_stats()</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call <span class="built_in">malloc_stats</span>()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013203318444.png" alt="malloc_stats"></p><blockquote><p>Arena0 表示当前线程使用的内存数据</p><p>Total 表示整个进程使用的内存数据</p></blockquote><h3 id="call-malloc-info-0-stdout"><a href="#call-malloc-info-0-stdout" class="headerlink" title="call malloc_info(0, stdout)"></a>call malloc_info(0, stdout)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call malloc_info(0, stdout)</span><br></pre></td></tr></table></figure><p>输出的是 xml 格式，主要关注<strong>rest</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013203805307.png" alt="malloc_info"></p><h2 id="gcc-选项-fsanitize-address"><a href="#gcc-选项-fsanitize-address" class="headerlink" title="gcc 选项 -fsanitize=address"></a>gcc 选项 -fsanitize=address</h2><ul><li>检查内存泄漏</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013204508831.png" alt="memleak"></p><ul><li>检查堆溢出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013204826971.png" alt="heap_overflow"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013204758941.png" alt="heap_overflow"></p><ul><li>检查栈溢出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013204907479.png" alt="stack overflow"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013212246057.png" alt="stack size"></p><ul><li>检查全局内存溢出</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013204950685.png" alt="global memory overflow"></p><ul><li>检查释放后再使用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20251013205044920.png" alt="use after free"></p><h1 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h1><ol><li>服务器端/被调试机</li></ol><p>安装 gdbserver，启动 gdbserver</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> apt-get isntall gdbserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个端口可以任取，但不能和别的程序冲突，不能被防火墙ban</span></span><br><span class="line">gdbserver 10.20.50.83:9988 ./test.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果程序已经启动，先通过ps命令获取程序pid，然后</span></span><br><span class="line">gdbserver 10.20.50.83:9988 --attach pid</span><br></pre></td></tr></table></figure><ol><li>客户端/调试机</li></ol><p>gdb 远程连接并进行调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) target remote 10.20.50.83:9988</span><br><span class="line"># 远程程序输入quit不会导致远程程序结束</span><br><span class="line">(gdb) quit</span><br><span class="line"># 也可以使用detach</span><br><span class="line">(gdb) detach</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小Linux系统编译与运行</title>
      <link href="/posts/42869/"/>
      <url>/posts/42869/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-23</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>win11 WSL2：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/CCECAA6776058E5E7B3BD5CD47C415D9.png" alt="环境"></p><h1 id="busybox编译"><a href="#busybox编译" class="headerlink" title="busybox编译"></a>busybox编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.busybox.net/downloads/busybox-1.37.0.tar.bz2</span><br><span class="line">bzip2 -d busybox-1.37.0.tar.bz2</span><br><span class="line">tar xvf busybox-1.37.0.tar</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> busybox-1.37.0</span><br></pre></td></tr></table></figure><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>这个版本直接编译aarch64有点问题，需要打一个补丁：</p>   <div class="tag link"><a class="link-card" title="libbb/sha: add missing sha-NI guard" href="https://lists.busybox.net/pipermail/busybox/2024-September/090899.html"><div class="left"><img src="https://www.busybox.net/favicon.ico"/></div><div class="right"><p class="text">libbb/sha: add missing sha-NI guard</p><p class="url">https://lists.busybox.net/pipermail/busybox/2024-September/090899.html</p></div></a></div><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- clean</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"><span class="comment"># Settings</span></span><br><span class="line"><span class="comment"># --- Build Option</span></span><br><span class="line"><span class="comment">#   [*] Build static binary (no shared libs)</span></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- install</span><br></pre></td></tr></table></figure><h2 id="创建inittab-rcS和fstab文件"><a href="#创建inittab-rcS和fstab文件" class="headerlink" title="创建inittab,rcS和fstab文件"></a>创建inittab,rcS和fstab文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> _install</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p dev etc home lib mnt proc root sys tmp var</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> etc/inittab</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d/</span><br><span class="line"><span class="built_in">touch</span> etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 755 etc/inittab</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/init.d/rcS</span><br></pre></td></tr></table></figure><p>inittab语法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt;<span class="symbol">:&lt;runlevels&gt;</span><span class="symbol">:&lt;action&gt;</span><span class="symbol">:&lt;process&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>id : /dev/id</li><li>runlevels : 忽略</li><li>action : 何时执行，有以下选项 sysinit, respawn, askfirst, wait, once,restart, ctrlaltdel, and shutdown</li><li>process : 应用程序或脚本</li></ul><p>etc/inittab 写入以下内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure></p><p>etc/init.d/rcS写入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/bin/mount -a </span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="keyword">if</span> [ -e /proc/sys/kernel/hotplug ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure><br>etc/fstab写入如下内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#device mount-point type option dump fsck</span></span><br><span class="line">proc  /proc proc  defaults 0 0</span><br><span class="line">tmpfs /tmp tmpfs defaults 0 0</span><br><span class="line">none  /tmp  ramfs defaults 0 0</span><br><span class="line">sysfs /sys  sysfs defaults 0 0</span><br><span class="line">mdev  /dev  ramfs defaults 0 0</span><br></pre></td></tr></table></figure></p><h2 id="添加设备文件"><a href="#添加设备文件" class="headerlink" title="添加设备文件"></a>添加设备文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dev</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> console c 5 1</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> null c 1 3</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> busybox-1.37.0/_install</span><br><span class="line">find . | cpio -o -H newc | gzip -c &gt; ../initramfs.cpio.gz</span><br><span class="line"><span class="built_in">cp</span> ../initramfs.cpio.gz ~/tftp</span><br></pre></td></tr></table></figure><h1 id="Linux-内核编译"><a href="#Linux-内核编译" class="headerlink" title="Linux 内核编译"></a>Linux 内核编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install gcc-aarch64-linux-gnu</span><br><span class="line"><span class="built_in">sudo</span> apt install libssl-dev</span><br><span class="line"></span><br><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.238.tar.xz</span><br><span class="line">tar xvf linux-5.10.238.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.10.238</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- clean</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm64/boot/Image ~/tftp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="qemu运行"><a href="#qemu运行" class="headerlink" title="qemu运行"></a>qemu运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">  -cpu cortex-a57 \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -machine <span class="built_in">type</span>=virt \</span><br><span class="line">  -nographic \</span><br><span class="line">  -smp 2 \</span><br><span class="line">  -kernel ~/tftp/Image  \</span><br><span class="line">  -initrd ~/tftp/initramfs.cpio.gz   \</span><br><span class="line">  -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">  -device virtio-scsi-device</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">zhaohang@ZhaoHang:~/kernel/my_arm64_programming$ qemu-system-aarch64 \</span><br><span class="line">  -cpu cortex-a57 \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -machine <span class="built_in">type</span>=virt \</span><br><span class="line">  -nographic \</span><br><span class="line">  -smp 2 \</span><br><span class="line">  -kernel ~/tftp/Image  \</span><br><span class="line">  -initrd ~/tftp/initramfs.cpio.gz   \</span><br><span class="line">  -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">  -device virtio-scsi-device</span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd070]</span><br><span class="line">[    0.000000] Linux version 5.10.238 (zhaohang@ZhaoHang) (aarch64-linux-gnu-gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils <span class="keyword">for</span> Ubuntu) 2.38) <span class="comment">#2 SMP PREEMPT Mon Jun 23 13:01:18 CST 2025</span></span><br><span class="line">[    0.000000] random: crng init <span class="keyword">done</span></span><br><span class="line">[    0.000000] Machine model: linux,dummy-virt</span><br><span class="line">[    0.000000] efi: UEFI not found.</span><br><span class="line">[    0.000000] NUMA: No NUMA configuration found</span><br><span class="line">[    0.000000] NUMA: Faking a node at [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] NUMA: NODE_DATA [mem 0x5fef4b00-0x5fef6fff]</span><br><span class="line">[    0.000000] Zone ranges:</span><br><span class="line">[    0.000000]   DMA      [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000]   DMA32    empty</span><br><span class="line">[    0.000000]   Normal   empty</span><br><span class="line">[    0.000000] Movable zone start <span class="keyword">for</span> each node</span><br><span class="line">[    0.000000] Early memory node ranges</span><br><span class="line">[    0.000000]   node   0: [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] Initmem setup node 0 [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] cma: Reserved 32 MiB at 0x000000005c000000</span><br><span class="line">[    0.000000] psci: probing <span class="keyword">for</span> conduit method from DT.</span><br><span class="line">[    0.000000] psci: PSCIv1.1 detected <span class="keyword">in</span> firmware.</span><br><span class="line">[    0.000000] psci: Using standard PSCI v0.2 <span class="keyword">function</span> IDs</span><br><span class="line">[    0.000000] psci: Trusted OS migration not required</span><br><span class="line">[    0.000000] psci: SMC Calling Convention v1.0</span><br><span class="line">[    0.000000] percpu: Embedded 23 pages/cpu s56664 r8192 d29352 u94208</span><br><span class="line">[    0.000000] Detected PIPT I-cache on CPU0</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 832075</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 834220</span><br><span class="line">[    0.000000] CPU features: detected: EL2 vector hardening</span><br><span class="line">[    0.000000] CPU features: kernel page table isolation forced ON by KASLR</span><br><span class="line">[    0.000000] CPU features: detected: Kernel page table isolation (KPTI)</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-v2</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-v4</span><br><span class="line">[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or 1530923</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-BHB</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 1742098</span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 129024</span><br><span class="line">[    0.000000] Policy zone: DMA</span><br><span class="line">[    0.000000] Kernel <span class="built_in">command</span> line: rdinit=/linuxrc console=ttyAMA0</span><br><span class="line">[    0.000000] Dentry cache <span class="built_in">hash</span> table entries: 65536 (order: 7, 524288 bytes, linear)</span><br><span class="line">[    0.000000] Inode-cache <span class="built_in">hash</span> table entries: 32768 (order: 6, 262144 bytes, linear)</span><br><span class="line">[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span><br><span class="line">[    0.000000] Memory: 439372K/524288K available (14464K kernel code, 2810K rwdata, 7632K rodata, 5952K init, 512K bss, 52148K reserved, 32768K cma-reserved)</span><br><span class="line">[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=2, Nodes=1</span><br><span class="line">[    0.000000] rcu: Preemptible hierarchical RCU implementation.</span><br><span class="line">[    0.000000] rcu:     RCU event tracing is enabled.</span><br><span class="line">[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=256 to nr_cpu_ids=2.</span><br><span class="line">[    0.000000]  Trampoline variant of Tasks RCU enabled.</span><br><span class="line">[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.</span><br><span class="line">[    0.000000] rcu: Adjusting geometry <span class="keyword">for</span> rcu_fanout_leaf=16, nr_cpu_ids=2</span><br><span class="line">[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0</span><br><span class="line">[    0.000000] GICv2m: range[mem 0x08020000-0x08020fff], SPI[80:143]</span><br><span class="line">[    0.000000] arch_timer: cp15 timer(s) running at 62.50MHz (virt).</span><br><span class="line">[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x1cd42e208c, max_idle_ns: 881590405314 ns</span><br><span class="line">[    0.000135] sched_clock: 56 bits at 62MHz, resolution 16ns, wraps every 4398046511096ns</span><br><span class="line">[    0.005145] Console: colour dummy device 80x25</span><br><span class="line">[    0.006576] Calibrating delay loop (skipped), value calculated using timer frequency.. 125.00 BogoMIPS (lpj=250000)</span><br><span class="line">[    0.006668] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.007333] LSM: Security Framework initializing</span><br><span class="line">[    0.008050] Mount-cache <span class="built_in">hash</span> table entries: 1024 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.008075] Mountpoint-cache <span class="built_in">hash</span> table entries: 1024 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.025711] /cpus/cpu-map: empty cluster</span><br><span class="line">[    0.030337] rcu: Hierarchical SRCU implementation.</span><br><span class="line">[    0.032757] EFI services will not be available.</span><br><span class="line">[    0.033350] smp: Bringing up secondary CPUs ...</span><br><span class="line">[    0.036124] Detected PIPT I-cache on CPU1</span><br><span class="line">[    0.036589] CPU1: Booted secondary processor 0x0000000001 [0x411fd070]</span><br><span class="line">[    0.038611] smp: Brought up 1 node, 2 CPUs</span><br><span class="line">[    0.038641] SMP: Total of 2 processors activated.</span><br><span class="line">[    0.038684] CPU features: detected: 32-bit EL0 Support</span><br><span class="line">[    0.038732] CPU features: detected: CRC32 instructions</span><br><span class="line">[    0.038761] CPU features: detected: 32-bit EL1 Support</span><br><span class="line">[    0.087011] CPU: All CPU(s) started at EL1</span><br><span class="line">[    0.087320] alternatives: patching kernel code</span><br><span class="line">[    0.100786] devtmpfs: initialized</span><br><span class="line">[    0.106839] KASLR enabled</span><br><span class="line">[    0.107566] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns</span><br><span class="line">[    0.107783] futex <span class="built_in">hash</span> table entries: 512 (order: 3, 32768 bytes, linear)</span><br><span class="line">[    0.110482] pinctrl core: initialized pinctrl subsystem</span><br><span class="line">[    0.117149] DMI not present or invalid.</span><br><span class="line">[    0.123022] NET: Registered protocol family 16</span><br><span class="line">[    0.130687] DMA: preallocated 128 KiB GFP_KERNEL pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.130888] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.131032] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA32 pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.131170] audit: initializing netlink subsys (disabled)</span><br><span class="line">[    0.132726] audit: <span class="built_in">type</span>=2000 audit(0.124:1): state=initialized audit_enabled=0 res=1</span><br><span class="line">[    0.135229] thermal_sys: Registered thermal governor <span class="string">&#x27;step_wise&#x27;</span></span><br><span class="line">[    0.135284] thermal_sys: Registered thermal governor <span class="string">&#x27;power_allocator&#x27;</span></span><br><span class="line">[    0.135718] cpuidle: using governor menu</span><br><span class="line">[    0.136329] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.</span><br><span class="line">[    0.136815] ASID allocator initialised with 32768 entries</span><br><span class="line">[    0.139125] Serial: AMBA PL011 UART driver</span><br><span class="line">[    0.165966] 9000000.pl011: ttyAMA0 at MMIO 0x9000000 (irq = 47, base_baud = 0) is a PL011 rev1</span><br><span class="line">[    0.256055] printk: console [ttyAMA0] enabled</span><br><span class="line">[    0.275753] HugeTLB registered 1.00 GiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.276425] HugeTLB registered 32.0 MiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.278075] HugeTLB registered 2.00 MiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.279114] HugeTLB registered 64.0 KiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.287377] cryptd: max_cpu_qlen <span class="built_in">set</span> to 1000</span><br><span class="line">[    0.295509] ACPI: Interpreter disabled.</span><br><span class="line">[    0.298412] iommu: Default domain <span class="built_in">type</span>: Translated</span><br><span class="line">[    0.299715] vgaarb: loaded</span><br><span class="line">[    0.300806] SCSI subsystem initialized</span><br><span class="line">[    0.302702] usbcore: registered new interface driver usbfs</span><br><span class="line">[    0.303416] usbcore: registered new interface driver hub</span><br><span class="line">[    0.303948] usbcore: registered new device driver usb</span><br><span class="line">[    0.305361] pps_core: LinuxPPS API ver. 1 registered</span><br><span class="line">[    0.305774] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;</span><br><span class="line">[    0.306671] PTP clock support registered</span><br><span class="line">[    0.307422] EDAC MC: Ver: 3.0.0</span><br><span class="line">[    0.311302] FPGA manager framework</span><br><span class="line">[    0.312553] Advanced Linux Sound Architecture Driver Initialized.</span><br><span class="line">[    0.320481] clocksource: Switched to clocksource arch_sys_counter</span><br><span class="line">[    0.321721] VFS: Disk quotas dquot_6.6.0</span><br><span class="line">[    0.322248] VFS: Dquot-cache <span class="built_in">hash</span> table entries: 512 (order 0, 4096 bytes)</span><br><span class="line">[    0.325830] pnp: PnP ACPI: disabled</span><br><span class="line">[    0.352101] NET: Registered protocol family 2</span><br><span class="line">[    0.353501] IP idents <span class="built_in">hash</span> table entries: 8192 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.357091] tcp_listen_portaddr_hash <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes, linear)</span><br><span class="line">[    0.357844] TCP established <span class="built_in">hash</span> table entries: 4096 (order: 3, 32768 bytes, linear)</span><br><span class="line">[    0.358536] TCP <span class="built_in">bind</span> <span class="built_in">hash</span> table entries: 4096 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.359240] TCP: Hash tables configured (established 4096 <span class="built_in">bind</span> 4096)</span><br><span class="line">[    0.360804] UDP <span class="built_in">hash</span> table entries: 256 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.361461] UDP-Lite <span class="built_in">hash</span> table entries: 256 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.362658] NET: Registered protocol family 1</span><br><span class="line">[    0.366482] RPC: Registered named UNIX socket transport module.</span><br><span class="line">[    0.366894] RPC: Registered udp transport module.</span><br><span class="line">[    0.367151] RPC: Registered tcp transport module.</span><br><span class="line">[    0.367596] RPC: Registered tcp NFSv4.1 backchannel transport module.</span><br><span class="line">[    0.368532] PCI: CLS 0 bytes, default 64</span><br><span class="line">[    0.371336] Unpacking initramfs...</span><br><span class="line">[    0.423234] Freeing initrd memory: 1156K</span><br><span class="line">[    0.425734] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available</span><br><span class="line">[    0.426386] kvm [1]: HYP mode not available</span><br><span class="line">[    0.438866] Initialise system trusted keyrings</span><br><span class="line">[    0.441323] workingset: timestamp_bits=42 max_order=17 bucket_order=0</span><br><span class="line">[    0.449648] squashfs: version 4.0 (2009/01/31) Phillip Lougher</span><br><span class="line">[    0.451781] NFS: Registering the id_resolver key <span class="built_in">type</span></span><br><span class="line">[    0.452635] Key <span class="built_in">type</span> id_resolver registered</span><br><span class="line">[    0.452872] Key <span class="built_in">type</span> id_legacy registered</span><br><span class="line">[    0.453347] nfs4filelayout_init: NFSv4 File Layout Driver Registering...</span><br><span class="line">[    0.453801] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...</span><br><span class="line">[    0.454953] 9p: Installing v9fs 9p2000 file system support</span><br><span class="line">[    0.485329] Key <span class="built_in">type</span> asymmetric registered</span><br><span class="line">[    0.486010] Asymmetric key parser <span class="string">&#x27;x509&#x27;</span> registered</span><br><span class="line">[    0.486459] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 245)</span><br><span class="line">[    0.486881] io scheduler mq-deadline registered</span><br><span class="line">[    0.487275] io scheduler kyber registered</span><br><span class="line">[    0.498447] pl061_gpio 9030000.pl061: PL061 GPIO chip registered</span><br><span class="line">[    0.501854] pci-host-generic 4010000000.pcie: host bridge /pcie@10000000 ranges:</span><br><span class="line">[    0.502917] pci-host-generic 4010000000.pcie:       IO 0x003eff0000..0x003effffff -&gt; 0x0000000000</span><br><span class="line">[    0.503846] pci-host-generic 4010000000.pcie:      MEM 0x0010000000..0x003efeffff -&gt; 0x0010000000</span><br><span class="line">[    0.504662] pci-host-generic 4010000000.pcie:      MEM 0x8000000000..0xffffffffff -&gt; 0x8000000000</span><br><span class="line">[    0.505854] pci-host-generic 4010000000.pcie: ECAM at [mem 0x4010000000-0x401fffffff] <span class="keyword">for</span> [bus 00-ff]</span><br><span class="line">[    0.507028] pci-host-generic 4010000000.pcie: PCI host bridge to bus 0000:00</span><br><span class="line">[    0.507648] pci_bus 0000:00: root bus resource [bus 00-ff]</span><br><span class="line">[    0.508176] pci_bus 0000:00: root bus resource [io  0x0000-0xffff]</span><br><span class="line">[    0.509569] pci_bus 0000:00: root bus resource [mem 0x10000000-0x3efeffff]</span><br><span class="line">[    0.511529] pci_bus 0000:00: root bus resource [mem 0x8000000000-0xffffffffff]</span><br><span class="line">[    0.513307] pci 0000:00:00.0: [1b36:0008] <span class="built_in">type</span> 00 class 0x060000</span><br><span class="line">[    0.515919] pci 0000:00:01.0: [1af4:1000] <span class="built_in">type</span> 00 class 0x020000</span><br><span class="line">[    0.517340] pci 0000:00:01.0: reg 0x10: [io  0x0000-0x001f]</span><br><span class="line">[    0.517754] pci 0000:00:01.0: reg 0x14: [mem 0x00000000-0x00000fff]</span><br><span class="line">[    0.518388] pci 0000:00:01.0: reg 0x20: [mem 0x00000000-0x00003fff 64bit pref]</span><br><span class="line">[    0.518923] pci 0000:00:01.0: reg 0x30: [mem 0x00000000-0x0003ffff pref]</span><br><span class="line">[    0.521212] pci 0000:00:01.0: BAR 6: assigned [mem 0x10000000-0x1003ffff pref]</span><br><span class="line">[    0.522137] pci 0000:00:01.0: BAR 4: assigned [mem 0x8000000000-0x8000003fff 64bit pref]</span><br><span class="line">[    0.523076] pci 0000:00:01.0: BAR 1: assigned [mem 0x10040000-0x10040fff]</span><br><span class="line">[    0.523801] pci 0000:00:01.0: BAR 0: assigned [io  0x1000-0x101f]</span><br><span class="line">[    0.528448] EINJ: ACPI disabled.</span><br><span class="line">[    0.542283] virtio-pci 0000:00:01.0: enabling device (0000 -&gt; 0003)</span><br><span class="line">[    0.554485] Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled</span><br><span class="line">[    0.558302] SuperH (H)SCI(F) driver initialized</span><br><span class="line">[    0.559486] msm_serial: driver initialized</span><br><span class="line">[    0.561993] cacheinfo: Unable to detect cache hierarchy <span class="keyword">for</span> CPU 0</span><br><span class="line">[    0.575536] loop: module loaded</span><br><span class="line">[    0.577188] megasas: 07.714.04.00-rc1</span><br><span class="line">[    0.581247] physmap-flash 0.flash: physmap platform flash device: [mem 0x00000000-0x03ffffff]</span><br><span class="line">[    0.583156] 0.flash: Found 2 x16 devices at 0x0 <span class="keyword">in</span> 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000</span><br><span class="line">[    0.584568] Intel/Sharp Extended Query Table at 0x0031</span><br><span class="line">[    0.585746] Using buffer write method</span><br><span class="line">[    0.586466] physmap-flash 0.flash: physmap platform flash device: [mem 0x04000000-0x07ffffff]</span><br><span class="line">[    0.587833] 0.flash: Found 2 x16 devices at 0x0 <span class="keyword">in</span> 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000</span><br><span class="line">[    0.589950] Intel/Sharp Extended Query Table at 0x0031</span><br><span class="line">[    0.590679] Using buffer write method</span><br><span class="line">[    0.591154] Concatenating MTD devices:</span><br><span class="line">[    0.591566] (0): <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.591870] (1): <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.592172] into device <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.639324] tun: Universal TUN/TAP device driver, 1.6</span><br><span class="line">[    0.648697] thunder_xcv, ver 1.0</span><br><span class="line">[    0.649091] thunder_bgx, ver 1.0</span><br><span class="line">[    0.649532] nicpf, ver 1.0</span><br><span class="line">[    0.651118] hclge is initializing</span><br><span class="line">[    0.651699] hns3: Hisilicon Ethernet Network Driver <span class="keyword">for</span> Hip08 Family - version</span><br><span class="line">[    0.652969] hns3: Copyright (c) 2017 Huawei Corporation.</span><br><span class="line">[    0.654822] e1000: Intel(R) PRO/1000 Network Driver</span><br><span class="line">[    0.655566] e1000: Copyright (c) 1999-2006 Intel Corporation.</span><br><span class="line">[    0.656421] e1000e: Intel(R) PRO/1000 Network Driver</span><br><span class="line">[    0.657100] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.</span><br><span class="line">[    0.657828] igb: Intel(R) Gigabit Ethernet Network Driver</span><br><span class="line">[    0.658543] igb: Copyright (c) 2007-2014 Intel Corporation.</span><br><span class="line">[    0.659076] igbvf: Intel(R) Gigabit Virtual Function Network Driver</span><br><span class="line">[    0.659905] igbvf: Copyright (c) 2009 - 2012 Intel Corporation.</span><br><span class="line">[    0.661636] sky2: driver version 1.30</span><br><span class="line">[    0.663482] VFIO - User Level meta-driver version: 0.3</span><br><span class="line">[    0.666363] ehci_hcd: USB 2.0 <span class="string">&#x27;Enhanced&#x27;</span> Host Controller (EHCI) Driver</span><br><span class="line">[    0.666801] ehci-pci: EHCI PCI platform driver</span><br><span class="line">[    0.667200] ehci-platform: EHCI generic platform driver</span><br><span class="line">[    0.667555] ehci-orion: EHCI orion driver</span><br><span class="line">[    0.668162] ehci-exynos: EHCI Exynos driver</span><br><span class="line">[    0.669422] ohci_hcd: USB 1.1 <span class="string">&#x27;Open&#x27;</span> Host Controller (OHCI) Driver</span><br><span class="line">[    0.670008] ohci-pci: OHCI PCI platform driver</span><br><span class="line">[    0.670583] ohci-platform: OHCI generic platform driver</span><br><span class="line">[    0.671027] ohci-exynos: OHCI Exynos driver</span><br><span class="line">[    0.672066] usbcore: registered new interface driver usb-storage</span><br><span class="line">[    0.678548] rtc-pl031 9010000.pl031: registered as rtc0</span><br><span class="line">[    0.679438] rtc-pl031 9010000.pl031: setting system clock to 2025-06-23T05:12:11 UTC (1750655531)</span><br><span class="line">[    0.680812] i2c /dev entries driver</span><br><span class="line">[    0.687138] sdhci: Secure Digital Host Controller Interface driver</span><br><span class="line">[    0.687486] sdhci: Copyright(c) Pierre Ossman</span><br><span class="line">[    0.688175] Synopsys Designware Multimedia Card Interface Driver</span><br><span class="line">[    0.689770] sdhci-pltfm: SDHCI platform and OF driver helper</span><br><span class="line">[    0.691932] ledtrig-cpu: registered to indicate activity on CPUs</span><br><span class="line">[    0.694429] usbcore: registered new interface driver usbhid</span><br><span class="line">[    0.694654] usbhid: USB HID core driver</span><br><span class="line">[    0.700987] NET: Registered protocol family 17</span><br><span class="line">[    0.702090] 9pnet: Installing 9P2000 support</span><br><span class="line">[    0.702525] Key <span class="built_in">type</span> dns_resolver registered</span><br><span class="line">[    0.703492] registered taskstats version 1</span><br><span class="line">[    0.703776] Loading compiled-in X.509 certificates</span><br><span class="line">[    0.710892] input: gpio-keys as /devices/platform/gpio-keys/input/input0</span><br><span class="line">[    0.714806] clk: Disabling unused clocks</span><br><span class="line">[    0.715339] ALSA device list:</span><br><span class="line">[    0.715654]   No soundcards found.</span><br><span class="line">[    0.718941] uart-pl011 9000000.pl011: no DMA platform data</span><br><span class="line">[    0.752373] Freeing unused kernel memory: 5952K</span><br><span class="line">[    0.753454] Run /linuxrc as init process</span><br><span class="line"></span><br><span class="line">Please press Enter to activate this console.</span><br><span class="line">~ <span class="comment">#</span></span><br><span class="line">~ <span class="comment"># ls</span></span><br><span class="line">bin      etc      lib      mnt      root     sys      usr</span><br><span class="line">dev      home     linuxrc  proc     sbin     tmp      var</span><br></pre></td></tr></table></figure><br>ctrl-a x退出qemu</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AArch64 ASM Book</title>
      <link href="/posts/42868/"/>
      <url>/posts/42868/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-22</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="preknowledge"><a href="#preknowledge" class="headerlink" title="preknowledge"></a>preknowledge</h1><p>1 <strong>byte</strong> has 8 <strong>bits</strong></p><ul><li><strong>char</strong> has 1 <strong>byte</strong></li><li><strong>short</strong> has 2 <strong>byte</strong></li><li><strong>int</strong> has 4 <strong>byte</strong></li></ul><p>每个地址代表一个字节的存储单元<br><img src="https://raw.githubusercontent.com/even629/myPicGo/main/v2-b9e8babf753b1691039458592667121a_1440w.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><ul><li><p><strong>All</strong> AARCH64 instructions are 4 bytes in width.</p></li><li><p><strong>All</strong> AARCH64 pointers are 8 bytes in width†.</p><blockquote><p>While this is technically true, typically only the lower 39, 42 or 48 bits of addresses in Linux systems are used - i.e. the virtual address space of an ARM Linux process is smaller than 64 bits. The upper bits are set to zero when considering the address as an 8-byte value.</p></blockquote></li></ul><h1 id="register"><a href="#register" class="headerlink" title="register"></a>register</h1><h2 id="register-access-speed"><a href="#register-access-speed" class="headerlink" title="register access speed"></a>register access speed</h2><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/latency.png" alt="Latency"></p><blockquote><p>This says that if we liken accessing a register (which can be done at <em>least</em> once per CPU Clock Cycle) to one second, accessing RAM would be like a 3.5 to 5.5 minute wait.</p></blockquote><h2 id="register-type"><a href="#register-type" class="headerlink" title="register type"></a>register type</h2><ul><li>rn means register “of some type” number n.</li></ul><p>The kind of register is specified by a letter. Which register within a given type is specified by a number. There are some exceptions to this. Here is an introductory summary:</p><div class="table-container"><table><thead><tr><th>Letter</th><th>Type</th></tr></thead><tbody><tr><td>x</td><td>64 bit integer or pointer</td></tr><tr><td>w</td><td>32 bit <em>or smaller</em> integer</td></tr><tr><td>d</td><td>64 bit floats (doubles)</td></tr><tr><td>s</td><td>32 bit floats</td></tr></tbody></table></div><p>Some register types have been left out.</p><p>（Chapter 9.1）（Cortex-A Series Programmer’s Guide for ARMv8-A）</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511155518113.png" alt="image-20250511155518113"></p><ul><li>x29 是栈帧指针（FP）</li><li>x30 是链接寄存器（LR，即返回地址）</li><li>当函数返回值的类型过大（如超过 64 位，或为大型结构体、联合体），无法通过通用寄存器（X0~X7）直接传递时，调用者会预先分配一块内存作为 “返回结果的存储区域”，并将该区域的地址传递给被调用函数 —— 这块内存的地址就是 “Indirect Result Location”。被调用函数执行完毕后，会将结果写入该地址，而非通过寄存器返回。</li></ul><p>The registers used for floating point types (and vector operations) are coincident:</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210301586.png" alt="image-20250511210301586"></p><ul><li><code>q</code> registers are a massive 16 bytes wide - quad words.(vn 的别名，主要用于<strong>SIMD/Neon</strong> 指令中)</li><li><code>v</code> registers are also 16 bytes wide and are synonyms for the <code>q</code> registers.</li><li><code>d</code> registers for <code>doubles</code> which are 8 bytes wide - <strong>double precision</strong>. 2 per <code>v</code>.</li><li><code>s</code> registers for <code>floats</code> which are 4 bytes wide - <strong>single precisio</strong>n. 4 per <code>v</code>.</li><li><code>h</code> registers for <code>half precisions floats</code> which are 2 bytes wide. 8 per <code>v</code>.</li><li><code>b</code> registers for byte operations. 16 per <code>v</code>.</li></ul><h2 id="register-and-C-type"><a href="#register-and-C-type" class="headerlink" title="register and C type"></a>register and C type</h2><h3 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h3><div class="table-container"><table><thead><tr><th>This declares an integer</th><th>This IS an integer</th></tr></thead><tbody><tr><td>char</td><td>wn</td></tr><tr><td>short</td><td>wn</td></tr><tr><td>int</td><td>wn</td></tr><tr><td>long</td><td>xn</td></tr></tbody></table></div><h3 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h3><div class="table-container"><table><thead><tr><th>This declares a pointer</th><th>This IS a pointer</th></tr></thead><tbody><tr><td><em>type</em> *</td><td>xn</td></tr></tbody></table></div><p>All pointers are stored in x registers. X registers are 64 bits long but many operating systems do not support 64 bit address spaces because keeping track of that big of an address space itself would use a lot of space. Instead <strong>OS’s typically have 48 to 52 bit address spaces</strong>.</p><h3 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating Point"></a>Floating Point</h3><div class="table-container"><table><thead><tr><th>This declares a float</th><th>This IS a float</th></tr></thead><tbody><tr><td><code>float</code></td><td><code>sn</code></td></tr><tr><td><code>double</code></td><td><code>dn</code></td></tr><tr><td><code>__fp16</code> (half)</td><td><code>hn</code></td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210512600.png" alt="image-20250511210512600"></p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210539205.png" alt="image-20250511210539205"></p><p>vn 是真正的物理寄存器名，<strong>推荐使用</strong>, 支持最多类型的访问（浮点 + SIMD）</p><p>qn 是 vn 的别名，主要用于<strong>SIMD/Neon</strong> 指令中(<em>Single Instruction - Multiple Data</em>)</p><h1 id="instructions"><a href="#instructions" class="headerlink" title="instructions"></a>instructions</h1><h2 id="preknowledge-1"><a href="#preknowledge-1" class="headerlink" title="preknowledge"></a>preknowledge</h2><p><strong>EVERY</strong> AARCH64 instruction is 4 bytes wide. Everything the CPU needs to know about what the instruction is and what variation it might be plus what data it will use will be found in those 4 bytes.</p><ul><li>Most (but not all) AARCH64 instructions have three <em>operands</em>. These are read in the following way:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op     ra, rb, rc</span><br></pre></td></tr></table></figure><p>means:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ra</span> <span class="operator">=</span> rb op rc</span><br></pre></td></tr></table></figure><p>examples:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span>    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">1</span> <span class="comment">; means x0 = x0 - x1</span></span><br><span class="line">mov    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">1</span>     <span class="comment">; means x0 = x1</span></span><br></pre></td></tr></table></figure><ul><li><strong>[ ]</strong></li></ul><p>the <code>[</code> and <code>]</code> serve the same purpose of the asterisk in C and C++ indicating “dereference.” It means <strong>use what’s inside the brackets as an address for going out to memory</strong>.</p><p>when a <strong>!</strong> is at the end of <strong>[]</strong> , for example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stp     x21, x30, [sp, -16]!</span><br><span class="line"></span><br><span class="line">stp     x29, x30, [sp, -16]!</span><br></pre></td></tr></table></figure><blockquote><p>Lastly, the exclamation point means that the stack pointer should be changed (i.e. the -16 applied to it) <em>before</em> the value of the stack pointer is used as the address in memory to which the registers will be copied. Again, this is a <strong>predecrement</strong>.</p></blockquote><p>it means:</p><ol><li><code>sp = sp - 16</code>（栈指针向下移动 16 字节）</li><li>把 <code>x29</code> 存入 <code>[sp]</code>，把 <code>x30</code> 存入 <code>[sp + 8]</code></li></ol><p>对应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldp     x29, x30, [sp], 16</span><br></pre></td></tr></table></figure><p>it means:</p><ol><li>从 <code>[sp]</code> 读取 8 字节给 <code>x29</code>，从 <code>[sp + 8]</code> 读取 8 字节给 <code>x30</code></li><li><code>sp = sp + 16</code>（释放栈帧空间）</li></ol><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><blockquote><p>x29 是栈帧寄存器，但不是必须保存的</p></blockquote><h2 id="memory-access"><a href="#memory-access" class="headerlink" title="memory access"></a>memory access</h2><h3 id="ldr"><a href="#ldr" class="headerlink" title="ldr"></a>ldr</h3><blockquote><p><strong>load register</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr    x0, [sp]   // load 8 bytes from address specified by sp</span><br><span class="line">ldr    w0, [sp]   // load 4 bytes from address specified by sp</span><br><span class="line">ldrh   w0, [sp]   // load 2 bytes from address specified by sp</span><br><span class="line">ldrb   w0, [sp]   // load 1 byte  from address specified by sp</span><br></pre></td></tr></table></figure><p><strong>When misaligned accesses to RAM are made, the processor must slow down and access each byte individually. This is a big performance hit. Properly aligned access is critical to performance.</strong></p><h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><blockquote><p><strong>store register</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str    x0, [sp]   // store 8 bytes to address specified by sp</span><br><span class="line">str    w0, [sp]   // store 4 bytes to address specified by sp</span><br><span class="line">strh   w0, [sp]   // store 2 bytes to address specified by sp</span><br><span class="line">strb   w0, [sp]   // store 1 byte  to address specified by sp</span><br></pre></td></tr></table></figure><blockquote><p>Casting between integer types is in some cases accomplished by <code>anding</code> with <code>255</code> and <code>65535</code> (for <code>char</code> and <code>short</code>) or :</p><p>Whenever a narrower portion of a register is written to, the remainder of the register is zero’d out. That is: <code>ldrb</code> overwrites the least significant byte of an <code>x</code> register and zeros out the upper 7 bytes.</p></blockquote><h3 id="ldp"><a href="#ldp" class="headerlink" title="ldp"></a>ldp</h3><blockquote><p><strong>load pair, same as ldr but load a pair of value</strong></p></blockquote><h3 id="stp"><a href="#stp" class="headerlink" title="stp"></a>stp</h3><blockquote><p><strong>store pair, same as str but load a pair of value</strong></p></blockquote><p><strong>offsets</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) LDR Xt, [Xn|SP&#123;, #pimm&#125;] ; 64-bit general registers</span><br><span class="line">2) LDR Xt, [Xn|SP], #simm ; 64-bit general registers, Post-index</span><br><span class="line">3) LDR Xt, [Xn|SP, #simm]! ; 64-bit general registers, Pre-index</span><br></pre></td></tr></table></figure><ul><li><code>simm</code> can be in the range of -256 to 255 (10 byte signed value).</li><li><code>pimm</code> can be in the range of 0 to 32760 in multiples of 8.</li></ul><h3 id="three-patterns"><a href="#three-patterns" class="headerlink" title="three patterns"></a><strong>three patterns</strong></h3><ol><li>普通偏移模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn, #pimm]</span><br></pre></td></tr></table></figure><blockquote><p>从 <code>Xn + pimm</code> 的地址加载数据到 <code>Xt</code>；<strong>地址寄存器 <code>Xn</code> 不变</strong>；</p><p><code>pimm</code> 是一个 <strong>正的立即数（positive immediate）</strong>，必须是 8 的倍数，最大为 32760。</p></blockquote><ol><li>后变基模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn], #simm</span><br></pre></td></tr></table></figure><blockquote><p>先用 <code>Xn</code> 的原始值作为地址加载数据到 <code>Xt</code>，然后再用 <code>simm</code> 更新 <code>Xn</code>；<strong>地址寄存器 <code>Xn</code> 改变</strong>；</p></blockquote><ol><li>前变基模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn, #simm]!</span><br></pre></td></tr></table></figure><blockquote><p>先用 <code>Xn + simm</code> 作为地址加载数据到 <code>Xt</code>，并将更新后的地址写回 <code>Xn</code>；<strong>地址寄存器 <code>Xn</code> 改变</strong>；</p></blockquote><h3 id="pseudo-instruction"><a href="#pseudo-instruction" class="headerlink" title="pseudo instruction"></a>pseudo instruction</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr     x1, =label</span><br></pre></td></tr></table></figure><ul><li><p>the assembler puts the address of the label into a special region of memory called a “<strong>literal pool</strong>.” What matters is <strong>this region of memory is placed immediately after (therefore nearby) your code</strong>.</p></li><li><p>Then, the assembler computes the difference between the address of the current instruction (the <code>ldr</code> itself) and the address of the data in the literal pool made from the labeled data.</p></li><li><p>The assembler generates a different <code>ldr</code> instruction which uses the difference (or offset) of the data relative to the program counter (<code>pc</code>). The <code>pc</code> is non-other the address of the current instruction.</p></li><li><p>Because the literal pool for your code is located nearby your code, the offset from the current instruction to the data in the pool is a relatively <strong>small</strong> number. Small enough, to fit inside a four byte <code>ldr</code> instruction.</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr    x1, [pc, offset to data in literal pool]</span><br></pre></td></tr></table></figure><blockquote><p><em>A downside of this approach is that the literal pool, from which the address is loaded, resides in RAM. This means each of these <code>ldr</code> pseudo instructions incurs a memory reference.</em></p></blockquote><h3 id="literal-pool"><a href="#literal-pool" class="headerlink" title="literal pool"></a>literal pool</h3><p>compare</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr x1, =q</span><br><span class="line">ldr x1, q</span><br></pre></td></tr></table></figure><p>aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .global     main       // expose main to linker</span><br><span class="line">        .text                  // begin to write code</span><br><span class="line">        .align      2          // the code should certainly begin on an even address</span><br><span class="line"></span><br><span class="line">main:   str         x30, [sp, -16]!</span><br><span class="line"></span><br><span class="line">        ldr         x0, =fmt</span><br><span class="line">        ldr         x1, =q</span><br><span class="line">        ldr         x2, [x1]</span><br><span class="line">        bl          printf</span><br><span class="line"></span><br><span class="line">        ldr         x0, =fmt</span><br><span class="line">        ldr         x1, q</span><br><span class="line">        ldr         x2, [x1]</span><br><span class="line">        bl          printf</span><br><span class="line"></span><br><span class="line">        ldr         x30, [sp], 16</span><br><span class="line">        mov         w0, wzr</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">q:      .quad       0x1122334455667788</span><br><span class="line">fmt:    .asciz      &quot;address: %p value: %lx\n&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>disasembling the binary machine code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000000007a0 &lt;main&gt;:</span><br><span class="line"> 7a0:   f81f0ffe   str  x30, [sp, #-16]!</span><br><span class="line"> 7a4:   58000160   ldr  x0, 7d0 &lt;main+0x30&gt;</span><br><span class="line"> 7a8:   58000181   ldr  x1, 7d8 &lt;main+0x38&gt;</span><br><span class="line"> 7ac:   f9400022   ldr  x2, [x1]</span><br><span class="line"> 7b0:   97ffffb4   bl   680 &lt;printf@plt&gt;</span><br><span class="line"> 7b4:   580000e0   ldr  x0, 7d0 &lt;main+0x30&gt;</span><br><span class="line"> 7b8:   580842c1   ldr  x1, 11010 &lt;q&gt;</span><br><span class="line"> 7bc:   f9400022   ldr  x2, [x1]</span><br><span class="line"> 7c0:   97ffffb0   bl   680 &lt;printf@plt&gt;</span><br><span class="line"> 7c4:   f84107fe   ldr  x30, [sp], #16</span><br><span class="line"> 7c8:   2a1f03e0   mov  w0, wzr</span><br><span class="line"> 7cc:   d65f03c0   ret</span><br></pre></td></tr></table></figure><p>and</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000000000011010 &lt;q&gt;:</span><br><span class="line">   11010:   55667788</span><br><span class="line">   11014:   11223344</span><br></pre></td></tr></table></figure><ul><li><p>It says <code>000000000011010 &lt;q&gt;:</code>. This means that what comes next is the data corresponding to what is labeled <code>q</code> in our source code. Notice the relocatable address of <code>11010</code>. We will explain “relocatable address” below.</p></li><li><p>Now, look at the disassembled code on the line beginning with <code>7b8</code>. It reads <code>ldr x1, 11010</code>. So the disassembled executable is saying “go to address 11010 and fetch its contents” which are our <code>1122334455667788</code>.</p></li></ul><div class="table-container"><table><thead><tr><th>Instruction</th><th>Meaning</th></tr></thead><tbody><tr><td>ldr r, =label</td><td>Load the address of the label into r</td></tr><tr><td>ldr r, label</td><td>Load the value found at the label into r</td></tr></tbody></table></div><h3 id="relocation-of-address-when-executing"><a href="#relocation-of-address-when-executing" class="headerlink" title="relocation of address when executing"></a>relocation of address when executing</h3><blockquote><p>None of the addresses we have seen so far are the final addresses that will be used once the program is actually running. <strong>All addresses will be <em>relocated</em></strong>.</p></blockquote><p>One reason for this is a guard against malware. A technique called <strong>Address Space Layout Randomization (ASLR)</strong> prevents malware writers from being able to know ahead where to modify your executable in order to accomplish their nefarious purposes.</p><p><strong>64 bit ARM Linux kernels allocate 39, 42 or 48 bits for the size of a process’s virtual address space</strong>. Notice 42 and 48 bit values require 6 bytes to hold them. A virtual address space is all of the addresses a process can generate / use. Further, all addresses used by processes are virtual addresses.</p><p>using this can avoid literal pool</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp    x0, s</span><br><span class="line">add     x0, x0, :lo12:s</span><br></pre></td></tr></table></figure><h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><h4 id="loading-storing-various-sizes-of-integers"><a href="#loading-storing-various-sizes-of-integers" class="headerlink" title="loading (storing) various sizes of integers"></a>loading (storing) various sizes of integers</h4><div class="table-container"><table><thead><tr><th>Instruction</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td><code>ldr x0, [x1]</code></td><td style="text-align:left">Fetches a 64 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr><tr><td><code>ldr w0, [x1]</code></td><td style="text-align:left">Fetches a 32 bit value from the address specified by <code>x1</code> and places it in <code>w0</code></td></tr><tr><td><code>ldrh w0, [x1]</code></td><td style="text-align:left">Fetches a 16 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr><tr><td><code>ldrb w0, [x1]</code></td><td style="text-align:left">Fetches an 8 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr></tbody></table></div><ul><li>Pointers and longs use <code>x</code> registers.</li><li>All other integer sizes use <code>w</code> registers where the instruction itself specifies the size.</li></ul><h4 id="array-indexing"><a href="#array-indexing" class="headerlink" title="array indexing"></a>array indexing</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Sum</span><span class="params">(<span class="type">long</span> * values, <span class="type">long</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += values[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice we’re using the index variable <code>i</code> for nothing more than traipsing through the array. This is fantastically inefficient (in this case).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Sum</span><span class="params">(<span class="type">long</span> * values, <span class="type">long</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> * end = values + length;</span><br><span class="line">    <span class="keyword">while</span> (values &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += *(values++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice we don’t use an index variable any longer. Instead, we use the pointer itself for both the dereferencing <em>and</em> to tell us when to stop the loop.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    .global Sum</span><br><span class="line">    .text</span><br><span class="line">    .align  4</span><br><span class="line"></span><br><span class="line">//  x0 is the pointer to data</span><br><span class="line">//  x1 is the length and is reused as `end`</span><br><span class="line">//  x2 is the sum</span><br><span class="line">//  x3 is the current dereferenced value</span><br><span class="line"></span><br><span class="line">Sum:</span><br><span class="line">    mov     x2, xzr              // x2 = 0</span><br><span class="line">    add     x1, x0, x1, lsl 3    //  x1 = x0+x1*8</span><br><span class="line">    b       2f</span><br><span class="line"></span><br><span class="line">1:  ldr     x3, [x0], 8</span><br><span class="line">    add     x2, x2, x3</span><br><span class="line">2:  cmp     x0, x1</span><br><span class="line">    blt     1b</span><br><span class="line"></span><br><span class="line">    mov     x0, x2</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure><h4 id="faster-memory-copy"><a href="#faster-memory-copy" class="headerlink" title="faster memory copy"></a>faster memory copy</h4><p>Suppose you needed to <strong>copy 16 bytes of memory</strong> from one place to another. You might do it like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SillyCopy16</span><span class="params">(<span class="type">uint8_t</span> * dest, <span class="type">uint8_t</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        *(dest++) = *(src++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is especially silly as why would you go through 16 loops when you could have simply:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SillyCopy16</span><span class="params">(<span class="type">uint64_t</span> * dest, <span class="type">uint64_t</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(dest++) = *(src++); <span class="comment">// 3</span></span><br><span class="line">    *dest = *src;         <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:              // 1</span><br><span class="line">    ldr    x2, [x0], 8    // 2</span><br><span class="line">    str    x2, [x1], 8    // 3</span><br><span class="line">    ldr    x2, [x0]       // 4</span><br><span class="line">    str    x2, [x1]       // 5</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>using ldp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:</span><br><span class="line">    ldp    x2, x3, [x0]</span><br><span class="line">    stp    x2, x3, [x1]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>using q register</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:</span><br><span class="line">    ldr    q2, [x0]</span><br><span class="line">    str    q2, [x1]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h4 id="indexing-through-an-array-of-struct"><a href="#indexing-through-an-array-of-struct" class="headerlink" title="indexing through an array of struct"></a>indexing through an array of struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * fname;</span><br><span class="line">    <span class="type">char</span> * lname;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rand</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> Person * <span class="title function_">FindOldestPerson</span><span class="params">(<span class="keyword">struct</span> Person *, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person * <span class="title function_">OriginalFindOldestPerson</span><span class="params">(<span class="keyword">struct</span> Person * people, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> oldest_age = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">oldest_ptr</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (people)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">end_ptr</span> =</span> people + length;</span><br><span class="line">        <span class="keyword">while</span> (people &lt; end_ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (people-&gt;age &gt; oldest_age)</span><br><span class="line">            &#123;</span><br><span class="line">                oldest_age = people-&gt;age;</span><br><span class="line">                oldest_ptr = people;</span><br><span class="line">            &#125;</span><br><span class="line">            people++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldest_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH  20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">array</span>[<span class="title">LENGTH</span>];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>[i].age = rand() % <span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">oldest</span> =</span> FindOldestPerson(<span class="built_in">array</span>, LENGTH);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">array</span>[i].age);</span><br><span class="line">        <span class="keyword">if</span> (oldest == &amp;<span class="built_in">array</span>[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Line 11</code> tells us that somewhere else, there is a function called <code>FindOldestPerson</code>. That function must have a <code>.global</code> specifying the same name so that the linker can reconcile the reference to <code>FindOldestPerson</code>.</p><p><code>gcc</code> with <code>-O2</code> or <code>-O3</code> optimization rendered <code>OriginalFindOldestPerson()</code> into 18 lines of assembly language.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">        .global FindOldestPerson                                        // 1</span><br><span class="line">        .text                                                           // 2</span><br><span class="line">        .align  2                                                       // 3</span><br><span class="line">                                                                        // 4</span><br><span class="line">//  x0  has struct Person * people                                      // 5</span><br><span class="line">//      will be used for oldest_ptr as this is the return value         // 6</span><br><span class="line">//  w1  has int length                                                  // 7</span><br><span class="line">//  w2  used for oldest_age                                             // 8</span><br><span class="line">//  x3  used for Person *                                               // 9</span><br><span class="line">//  x4  used for end_ptr                                                // 10</span><br><span class="line">//  w5  used for scratch                                                // 11</span><br><span class="line">                                                                        // 12</span><br><span class="line">FindOldestPerson:                                                       // 13</span><br><span class="line">        cbz     x0, 99f             // short circuit                    // 14</span><br><span class="line">        mov     w2, wzr             // initial oldest age is 0          // 15</span><br><span class="line">        mov     x3, x0              // initialize loop pointer          // 16</span><br><span class="line">        mov     x0, xzr             // initialize return value          // 17</span><br><span class="line">        mov     w5, 24              // struct is 24 bytes wide          // 18</span><br><span class="line">        smaddl  x4, w1, w5, x3      // initialize end_ptr               // 19</span><br><span class="line">        b       10f                 // enter loop                       // 20</span><br><span class="line">                                                                        // 21</span><br><span class="line">1:      ldr     w5, [x3, p.age]     // fetch loop ptr -&gt; age            // 22</span><br><span class="line">        cmp     w2, w5              // compare to oldest_age            // 23</span><br><span class="line">        csel    w2, w2, w5, gt      // update based on cmp              // 24</span><br><span class="line">        csel    x0, x0, x3, gt      // update based on cmp              // 25</span><br><span class="line">        add     x3, x3, 24          // increment loop ptr               // 26</span><br><span class="line">10:     cmp     x3, x4              // has loop ptr reached end_ptr?    // 27</span><br><span class="line">        blt     1b                  // no, not yet                      // 28</span><br><span class="line">                                                                        // 29</span><br><span class="line">99:     ret                                                             // 30</span><br><span class="line">                                                                        // 31</span><br><span class="line">        .data                                                           // 32</span><br><span class="line">        .struct 0                                                       // 33</span><br><span class="line">p.fn:   .skip   8                                                       // 34</span><br><span class="line">p.ln:   .skip   8                                                       // 35</span><br><span class="line">p.age:  .skip   4                                                       // 36</span><br><span class="line">p.pad:  .skip   4                                                       // 37</span><br><span class="line">                                                                        // 38</span><br><span class="line">        .end                                                            // 39</span><br></pre></td></tr></table></figure><h2 id="control-flow"><a href="#control-flow" class="headerlink" title="control flow"></a>control flow</h2><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><blockquote><p><strong>compare</strong></p></blockquote><p>discards the result of the subtraction but keeps a record of whether or not the result was less than, equal to or greater than zero. It sets the condition bits</p><h3 id="br"><a href="#br" class="headerlink" title="br"></a>br</h3><blockquote><p>Branch to Register</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br &lt;register&gt;</span><br></pre></td></tr></table></figure><p>无条件跳转，类似于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> *(ptr)</span><br></pre></td></tr></table></figure><h3 id="ble"><a href="#ble" class="headerlink" title="ble"></a>ble</h3><blockquote><p><strong>Branch less or equal</strong></p></blockquote><h3 id="bl"><a href="#bl" class="headerlink" title="bl"></a>bl</h3><blockquote><p><strong>Branch with Link</strong></p></blockquote><p>跳转到一个函数（子程序）地址，并且保存返回地址到 <code>x30</code> 寄存器中（也叫 <code>lr</code>，Link Register）</p><h3 id="cbz"><a href="#cbz" class="headerlink" title="cbz"></a>cbz</h3><blockquote><p>Compare and Branch if Zero</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbz &lt;register&gt;, &lt;label&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>&lt;register&gt;</code> 中的值为 0，就跳转到 <code>&lt;label&gt;</code>。</p><p>否则继续执行下一条指令。</p><h3 id="csel"><a href="#csel" class="headerlink" title="csel"></a>csel</h3><blockquote><p>Conditional Select</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csel &lt;dest&gt;, &lt;src1&gt;, &lt;src2&gt;, &lt;condition&gt;</span><br></pre></td></tr></table></figure><p>如果满足 <code>&lt;condition&gt;</code>，则将 <code>&lt;src1&gt;</code> 的值赋给 <code>&lt;dest&gt;</code>；</p><p>否则将 <code>&lt;src2&gt;</code> 的值赋给 <code>&lt;dest&gt;</code>。</p><p>examples:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp w2, w5</span><br><span class="line">csel w2, w2, w5, gt    // 如果 w2 &gt; w5，则 w2 保持不变；否则更新为 w5</span><br></pre></td></tr></table></figure><p>这是<strong>无分支的条件赋值</strong>，比 <code>if-else</code> 更高效。</p><p>this is equal to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w2 = (w2 &gt; w5) ? w2 : w5;</span><br></pre></td></tr></table></figure><h3 id="calculate"><a href="#calculate" class="headerlink" title="calculate"></a>calculate</h3><h2 id="shift-Opertations"><a href="#shift-Opertations" class="headerlink" title="shift Opertations"></a>shift Opertations</h2><h3 id="lsl"><a href="#lsl" class="headerlink" title="lsl"></a>lsl</h3><blockquote><p>Logical Shift Left</p></blockquote><p>The LSL instruction performs multiplication by a power of 2.</p><h3 id="lsr"><a href="#lsr" class="headerlink" title="lsr"></a>lsr</h3><blockquote><p>Logical Shift Right</p></blockquote><p>The LSR instruction performs division by a power of 2.</p><h3 id="asr"><a href="#asr" class="headerlink" title="asr"></a>asr</h3><blockquote><p>Arithmetic Shift Right</p></blockquote><p>The ASR instruction performs division by a power of 2, preserving the sign bit.</p><h3 id="ror"><a href="#ror" class="headerlink" title="ror"></a>ror</h3><blockquote><p>rotate right</p></blockquote><p>The ROR instruction performs a bitwise rotation, wrapping the bits rotated from the LSB into the MSB.<br>即：<code>ROR</code> 指令执行<strong>按位右旋转</strong>操作：<strong>从最低有效位（LSB）被旋转出来的位，会重新被放入到最高有效位（MSB）的位置中。</strong></p><h2 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h2><h3 id="mvn"><a href="#mvn" class="headerlink" title="mvn"></a>mvn</h3><p>mvn (Move Not) 作用是 将操作数按位取反（bitwise NOT）后，放入目标寄存器。</p><h3 id="orr"><a href="#orr" class="headerlink" title="orr"></a>orr</h3><p>orr (bitwise inclusive OR) 对两个操作数执行<strong>按位或（bitwise OR）</strong>运算，然后将结果写入目标寄存器</p><h3 id="bfi"><a href="#bfi" class="headerlink" title="bfi"></a>bfi</h3><p>bfi (Bit Field Insert) 即“位字段插入”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfi &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;</span><br></pre></td></tr></table></figure><p><Xd>：目标寄存器（结果写到这里）</p><p><Xn>：源寄存器（从这里取低位的值）</p><p><lsb>：目标寄存器中开始插入的起始位（least significant bit 起始位）</p><p><width>：要插入多少位（宽度）</p><p>假设：</p><p>Xd = 0b1111 0000<br>Xn = 0b1011 (只用低 4 位)<br>lsb=1<br>width=3</p><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfi Xd, Xn, #1, #3</span><br></pre></td></tr></table></figure><p>结果：<br>将 Xn 的低 3 位 011 插入 Xd 的位 1~3 上，替换原值<br>结果是 Xd = 1111 0110</p><h3 id="ubfm"><a href="#ubfm" class="headerlink" title="ubfm"></a>ubfm</h3><p>ubfm = Unsigned BitField Move</p><p>基本格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfm &lt;dst&gt;, &lt;src&gt;, #lsb, #msb</span><br></pre></td></tr></table></figure><p><dst>：目标寄存器</p><p><src>：源寄存器<br>lsb：起始位（low bit index）<br>msb：结束位（high bit index）<br>这条指令从 src 中 提取一个无符号位字段（即一段连续的比特位），把它放到 dst 的低位（bit 0 开始），其他位清零或忽略<br>也就是说：</p><ol><li>从 src 的第 lsb 位开始，取到 msb 位</li><li>将这段 bit 字段提取出来</li><li>右对齐放到 dst 的低位（bit 0）<br>其他位全部清零<br>实例：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfm    w1, w2, #8, #15</span><br></pre></td></tr></table></figure><ol><li>从 w2 中提取 bit 8 到 bit 15（共 8 位）</li><li>把它放到 w1 的 bit 0~7</li></ol><h3 id="ubfiz"><a href="#ubfiz" class="headerlink" title="ubfiz"></a>ubfiz</h3><p>ubfiz (Unsigned Bit Field Insert Zeroed) 将一个无符号数的低位字段插入到另一个寄存器的指定位置，但目标寄存器在插入之前会被清零。<br>它其实是 ubfm（Unsigned Bit Field Move）的一个特化形式，和 UBFM 的语义类似。</p><p>指令格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfiz  &lt;dst&gt;, &lt;src&gt;, #lsb, #width</span><br></pre></td></tr></table></figure><p>简单来讲就是：ubfiz = 把 src 的低 width 位 插入到 dst 的 bit lsb 开始的位置，其余位置全部清零。</p><p>其中：</p><p><src>：来源寄存器（如 w1）</p><p><dst>：目标寄存器（如 w2），最终结果放在这里<br>lsb：目标中插入位置的起始 bit 位（从 0 开始）<br>width：要插入的位数（从 <src> 的最低位开始数）</p><p>目标寄存器其他位都会被清零。</p><p>举例说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfiz   w1, w1, #3, #5</span><br></pre></td></tr></table></figure><p>含义如下：</p><ol><li>从 w1 的 最低 5 位（bit 0 到 bit 4）提取出来</li><li>插入到目标（w1）寄存器的 bit 3 到 bit 7</li><li>w1 的其他所有位（02 和 831）清零</li></ol><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="adr"><a href="#adr" class="headerlink" title="adr"></a>adr</h3><blockquote><p>Address</p></blockquote><h3 id="adrp"><a href="#adrp" class="headerlink" title="adrp"></a>adrp</h3><blockquote><p>Address of page</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line"></span><br><span class="line">adrp x0, fmt</span><br><span class="line">add  x0, x0, :lo12:fmt    // 汇编器会自动提取 fmt 的低12位作为立即数,计算页偏移</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：把符号 <code>fmt</code> 所在的 <strong>4KB 对齐页的页地址</strong>加载到 <code>x0</code> 中。</li><li><code>adrp</code> = <em>Address of Page</em>。</li><li>它会忽略符号地址的低 12 位，只保留高位。</li><li>举例：如果 <code>fmt</code> 地址是 <code>0x400123</code>，那么 <code>adrp x0, fmt</code> 会将 <code>0x400000</code> 加载到 <code>x0</code>。</li><li><code>adrp x0, fmt</code> 会将 <code>fmt</code> 地址向下取整到最近的 <strong>4KB 边界</strong>（即清除低 12 位）</li></ul><blockquote><p>为什么不直接用 <code>ldr x0, =fmt</code>？</p></blockquote><ul><li>在 ARM64 下，使用 <code>ldr x0, =fmt</code> 可能隐式引入 <strong>文字常量池（literal pool）</strong>，不利于可重定位代码，尤其是在动态链接或 PIE (Position Independent Executable) 环境下。</li><li><code>adrp</code> + <code>add</code> 是 <strong>推荐的可重定位代码写法（relocatable and PIC-compliant）</strong>。</li><li>Linux 下的动态链接器（ld.so）支持这种模式更好。</li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>含义</th><th>支持的偏移范围</th><th>常用于</th></tr></thead><tbody><tr><td><code>adr</code></td><td>获取<strong>当前指令附近</strong>的地址</td><td>±1MB</td><td>局部跳转、临时变量等</td></tr><tr><td><code>adrp</code></td><td>获取<strong>4KB 页对齐的高地址部分</strong></td><td>±4GB（页对齐偏移）</td><td>获取全局变量地址、字符串、常量表地址等</td></tr></tbody></table></div><h3 id="smaddl"><a href="#smaddl" class="headerlink" title="smaddl"></a>smaddl</h3><blockquote><p>Signed Multiply Add Long</p><p>两个 <strong>32 位整数（有符号）</strong> 相乘后，加上一个 <strong>64 位整数</strong>，结果保存在一个 <strong>64 位寄存器</strong>中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smaddl &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</span><br></pre></td></tr></table></figure><p>执行如下操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xd = (<span class="type">int64_t</span>)(<span class="type">int32_t</span>)Wn * (<span class="type">int64_t</span>)(<span class="type">int32_t</span>)Wm + Xa;</span><br></pre></td></tr></table></figure><h1 id="programming"><a href="#programming" class="headerlink" title="programming"></a>programming</h1><h2 id="if-statement"><a href="#if-statement" class="headerlink" title="if statement"></a>if statement</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0</span><br><span class="line">    // Assume value of b is in x1</span><br><span class="line">    cmp     x0, x1</span><br><span class="line">    ble     1f</span><br><span class="line">    // CODE BLOCK</span><br><span class="line">1:</span><br></pre></td></tr></table></figure><p>If <code>a &gt; b</code> then <code>x0 - x1</code> will be <em>greater than zero</em>.</p><p>If <code>a == b</code> then <code>x0 - x1</code> will be <em>equal to zero</em>.</p><p>If <code>a &lt; b</code> then <code>x0 - x1</code> will be <em>less than zero</em>.</p><p><strong>ble</strong> means <strong>branch (a jump or goto) if the previous computation shows <code>less than or equal to</code> zero</strong></p><h4 id="a-rule-of-thumb"><a href="#a-rule-of-thumb" class="headerlink" title="a rule of thumb"></a>a rule of thumb</h4><ul><li><p><strong>In the higher level language, you want to <em>enter</em> the following code block if the condition is true. </strong></p></li><li><p><strong>In assembly language, you want to <em>avoid</em> the following code block if the condition is false.</strong></p></li></ul><h4 id="temporary-label"><a href="#temporary-label" class="headerlink" title="temporary label"></a>temporary label</h4><p>The target of the branch instruction is given as <code>1f</code>. This is an example of a <strong><em>temporary label</em></strong>.</p><p><strong>There are a lot of braces used in C and C++. Since labels frequently function as equivalents to <code>&#123;</code> and <code>&#125;</code>, there can be a lot of labels used in assembly language. But label is only a position label, it is not a scope </strong></p><p>A temporary label is a label made using just a number. Such labels can appear over and over again (i.e. they can be reused). They are made unique by virtue of their placement relative to where they are being used.</p><ul><li><code>1f</code> looks <code>f</code>orward in the code for the next label <code>1</code>.</li><li><code>1b</code> looks in the <code>b</code>ackward direction for the most recent label <code>1</code>.</li></ul><h3 id="if-else"><a href="#if-else" class="headerlink" title="if / else"></a>if / else</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK IF TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK IF FALSE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>There are two branches built into this code!</strong></p><p>in aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0</span><br><span class="line">    // Assume value of b is in x1</span><br><span class="line">    cmp     x0, x1</span><br><span class="line">    ble     1f</span><br><span class="line">    // CODE BLOCK IF TRUE</span><br><span class="line">    b       2f</span><br><span class="line">1:</span><br><span class="line">    // CODE BLOCK IF FALSE</span><br><span class="line">2:</span><br></pre></td></tr></table></figure><h4 id="a-complete-example"><a href="#a-complete-example" class="headerlink" title="a complete example"></a>a complete example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    .global main</span><br><span class="line">    .text</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    stp     x29, x30, [sp, -16]!</span><br><span class="line">    mov     x1, 10</span><br><span class="line">    mov     x0, 5</span><br><span class="line">    cmp     x0, x1</span><br><span class="line">    ble     1f</span><br><span class="line">    ldr     x0, =T                     //Pseudo Instruction 伪指令</span><br><span class="line">    bl      puts</span><br><span class="line">    b       2f</span><br><span class="line"></span><br><span class="line">1:  ldr     x0, =F</span><br><span class="line">    bl      puts</span><br><span class="line"></span><br><span class="line">2:  ldp     x29, x30, [sp], 16</span><br><span class="line">    mov     x0, xzr</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">F:  .asciz  &quot;FALSE&quot;</span><br><span class="line">T:  .asciz  &quot;TRUE&quot;</span><br><span class="line">    .end</span><br></pre></td></tr></table></figure><p><code>Line 11</code> is one way of loading the address represented by a label. In this case, the label <code>T</code> corresponds to the address to the first letter of the C string “TRUE”. <code>Line 15</code> loads the address of the C string containing “FALSE”.</p><p>The occurrences of <code>.asciz</code> on <code>line 23</code> and <code>line 24</code> are invocations of an <em>assembler directive</em> the creates a C string. Recall that <strong>C strings are NULL terminated</strong>. The NULL termination is indicated by the <code>z</code> which ends <code>.asciz</code>.</p><p>There is a similar directive <code>.ascii</code> that <em>does not NULL terminate</em> the string.</p><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><h3 id="while-loop"><a href="#while-loop" class="headerlink" title="while loop"></a>while loop</h3><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/while.jpeg" alt="while loop"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (a &gt;= b) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0</span><br><span class="line">    // Assume value of b is in x1</span><br><span class="line"></span><br><span class="line"> 1: cmp     x0, x1</span><br><span class="line">    blt     2f</span><br><span class="line">    // CODE BLOCK</span><br><span class="line">    b       1b</span><br><span class="line"></span><br><span class="line">2:</span><br></pre></td></tr></table></figure><h3 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span> up; decision; post step)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/for.jpeg" alt="for"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aarch64 (the flow chart on the left)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Assume i is implemented using x0</span></span><br><span class="line">    mov     x0, xzr</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>:  cmp     x0, <span class="number">10</span></span><br><span class="line">    bge     <span class="number">2f</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// CODE BLOCK</span></span><br><span class="line"></span><br><span class="line">    add     x0, x0, <span class="number">1</span></span><br><span class="line">    b       <span class="number">1b</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>:</span><br></pre></td></tr></table></figure><p>aarch64 (the flow chart on the right)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0</span><br><span class="line"></span><br><span class="line">    mov     x0, xzr</span><br><span class="line">    b       2f</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">    // CODE BLOCK</span><br><span class="line"></span><br><span class="line">    add     x0, x0, 1</span><br><span class="line">2:  cmp     x0, 10</span><br><span class="line">    blt     1b</span><br></pre></td></tr></table></figure><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;A&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;B&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0</span><br><span class="line"></span><br><span class="line">    mov x0, xzr</span><br><span class="line"></span><br><span class="line">1:  cmp x0, 10</span><br><span class="line">    bge 3f</span><br><span class="line">    // CODE BLOCK &quot;A&quot;.</span><br><span class="line">    // if (i == 5)</span><br><span class="line">    //      continue</span><br><span class="line"></span><br><span class="line">    cmp x0, 5</span><br><span class="line">    beq 2f</span><br><span class="line">    // CODE BLOCK &quot;B&quot;</span><br><span class="line"></span><br><span class="line">2:  add x0, x0, 1</span><br><span class="line">    b   1b</span><br><span class="line"></span><br><span class="line">3:</span><br></pre></td></tr></table></figure><p>another one</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0</span><br><span class="line"></span><br><span class="line">    mov x0, xzr</span><br><span class="line">    b   3f</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">    // CODE BLOCK &quot;A&quot;</span><br><span class="line"></span><br><span class="line">    // if (i == 5)</span><br><span class="line">    //      continue</span><br><span class="line"></span><br><span class="line">    cmp x0, 5</span><br><span class="line">    beq 2f</span><br><span class="line"></span><br><span class="line">    // CODE BLOCK &quot;B&quot;</span><br><span class="line"></span><br><span class="line">2:  add x0, x0, 1</span><br><span class="line">3:  cmp x0, 10</span><br><span class="line">    blt 1b</span><br></pre></td></tr></table></figure><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>The implementation of <code>break</code> is very similar to that of <code>continue</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;A&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;B&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0</span><br><span class="line"></span><br><span class="line">    mov x0, xzr</span><br><span class="line">    b   3f</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line"></span><br><span class="line">    // CODE BLOCK &quot;A&quot;</span><br><span class="line"></span><br><span class="line">    // if (i == 5)</span><br><span class="line">    //      break;</span><br><span class="line"></span><br><span class="line">    cmp x0, 5</span><br><span class="line">    beq 4f</span><br><span class="line"></span><br><span class="line">    // CODE BLOCK &quot;B&quot;</span><br><span class="line"></span><br><span class="line">2:  add x0, x0, 1</span><br><span class="line">3:  cmp x0, 10</span><br><span class="line">    blt 1b</span><br><span class="line"></span><br><span class="line">4:</span><br></pre></td></tr></table></figure><h2 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h2><h3 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h3><p><em>Data members exhibit <strong>natural alignment</strong>.</em></p><p>That is:</p><ul><li>a <code>long</code> will be found at addresses which are a multiple of 8.</li><li>an <code>int</code> will be found at addresses which are a multiple of 4.</li><li>a <code>short</code> will be found at addresses which are even.</li><li>a <code>char</code> can be found anywhere.</li></ul><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>布局：</p><div class="table-container"><table><thead><tr><th>Offset</th><th>Width</th><th>Member</th></tr></thead><tbody><tr><td>0</td><td>8byte</td><td>a</td></tr><tr><td>8</td><td>2byte</td><td>b</td></tr><tr><td>10</td><td>2</td><td>— gap —</td></tr><tr><td>12</td><td>4byte</td><td>c</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaaaaaaaaaaaaaa</span>, <span class="number">0xbbbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>A hex dump will show:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa aaaa aaaa aaaa bbbb 0000 cccc cccc</span><br></pre></td></tr></table></figure><p>Notice the gap filled in which zeros. Note, if this were a local variable, the zeros might be garbage.</p><p>change the order:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaa</span>, <span class="number">0xbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>A hex dump will show:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa 00bb cccc cccc</span><br></pre></td></tr></table></figure><p>Notice there is only one byte of gap before the <code>int c</code> starts.</p><p><em>why are the zeros to the left of the b’s?</em></p><p>This ARM processor is running as a <em>little endian</em> machine.</p><h3 id="defining-structs"><a href="#defining-structs" class="headerlink" title="defining structs"></a>defining structs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaa</span>, <span class="number">0xbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>Here is one way of defining and accessing the struct:</p><p><strong>硬编码字段偏移量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">bar:</span><br><span class="line">    .short 0xaaaa        // a: short 2 byte</span><br><span class="line">    .byte  0xbb          // b: char  1 byte</span><br><span class="line">    .byte  0x00          // padding</span><br><span class="line">    .word  0xcccccccc    // c: int   4 byte</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line">    .global main</span><br><span class="line">    .align 2</span><br><span class="line">main:</span><br><span class="line">    stp x29, x30, [sp, -16]!    // 保存栈帧</span><br><span class="line">    mov x29, sp</span><br><span class="line"></span><br><span class="line">    adrp x0, fmt</span><br><span class="line">    add  x0, x0, :lo12:fmt      // printf 格式字符串地址</span><br><span class="line"></span><br><span class="line">    adrp x1, bar</span><br><span class="line">    add  x1, x1, :lo12:bar      // bar 的地址</span><br><span class="line"></span><br><span class="line">    ldrh w2, [x1, 0]            // short a</span><br><span class="line">    ldrb w3, [x1, 2]            // char b</span><br><span class="line">    ldr  w4, [x1, 4]            // int  c</span><br><span class="line"></span><br><span class="line">    bl printf                   // 调用 printf(&amp;bar, a, b, c)</span><br><span class="line"></span><br><span class="line">    // 显式退出系统调用</span><br><span class="line">    mov     x8, #93       // syscall number for exit</span><br><span class="line">    mov     x0, xzr       // exit code 0</span><br><span class="line">    svc     0             // make syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>:lo12:fmt</code> 会被汇编器替换成 <code>fmt</code> 地址的低 12 位。</p><p><code>adrp x0, fmt</code> 会将 <code>fmt</code> 地址向下取整到最近的 <strong>4KB 边界</strong>（即清除低 12 位），然后加载这个“页基址”到 <code>x0</code>。</p><p>例如：<br>如果 <code>fmt = 0x12345678</code>，那么：</p><ul><li><code>adrp x0, fmt</code> 会得到 <code>0x12345000</code>（低 12 位清零）</li></ul><p>another way to define a structs is</p><p><strong>使用 <code>.equ</code> 伪指令定义符号常量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    .global main                // main 函数声明</span><br><span class="line">    .text</span><br><span class="line">    .p2align 2</span><br><span class="line"></span><br><span class="line">    .equ foo_a, 0               // like #define foo_a 0</span><br><span class="line">    .equ foo_b, 2               // like #define foo_b 2</span><br><span class="line">    .equ foo_c, 4               // like #define foo_c 4</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    stp     x29, x30, [sp, -16]!  // 保存 x29, x30 到栈上</span><br><span class="line">    mov     x29, sp               // 设置新的帧指针</span><br><span class="line"></span><br><span class="line">    // 加载 fmt 和 bar 的地址</span><br><span class="line">    ldr     x0, =fmt              // fmt 字符串的地址</span><br><span class="line">    ldr     x1, =bar              // bar 的地址</span><br><span class="line">    ldrh    w2, [x1, foo_a]       // 加载 bar.a 到 w2</span><br><span class="line">    ldrb    w3, [x1, foo_b]       // 加载 bar.b 到 w3</span><br><span class="line">    ldr     w4, [x1, foo_c]       // 加载 bar.c 到 w4</span><br><span class="line"></span><br><span class="line">    // 调用 printf，传递参数</span><br><span class="line">    mov     x0, x0               // 第一个参数：fmt 地址</span><br><span class="line">    mov     x1, w2               // 第二个参数：a 的值</span><br><span class="line">    mov     x2, w3               // 第三个参数：b 的值</span><br><span class="line">    mov     x3, w4               // 第四个参数：c 的值</span><br><span class="line">    bl      printf               // 调用 printf</span><br><span class="line"></span><br><span class="line">    // 恢复栈和寄存器</span><br><span class="line">    ldp     x29, x30, [sp], #16  // 恢复 x29 和 x30</span><br><span class="line">    ret                          // 返回</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">fmt:</span><br><span class="line">.asciz      &quot;%p a: 0x%lx b: %x c: %x\n&quot;   // printf 格式字符串</span><br><span class="line">bar:</span><br><span class="line">.short      0xaaaa                        // a</span><br><span class="line">    .byte       0xbb                          // b</span><br><span class="line">    .byte       0                               // padding</span><br><span class="line">    .word       0xcccccccc                    // c</span><br><span class="line"></span><br><span class="line">    .end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>the third way:(<strong>Linux only</strong>)</p><p><strong>使用 <code>.struct</code> 和字段标签自动推导偏移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    // 用 .struct 模拟 struct Foo 的字段偏移</span><br><span class="line">    .set  Foo, 0</span><br><span class="line">    .struct 0</span><br><span class="line">Foo_a:  .struct Foo_a + 2      // short a: 2字节</span><br><span class="line">Foo_b:  .struct Foo_b + 1      // char b: 1字节</span><br><span class="line">        .struct Foo_b + 1      // padding: 1字节</span><br><span class="line">Foo_c:  .struct Foo_b + 2      // int c: 从 offset 4 开始</span><br><span class="line">    // 现在 Foo_c 是偏移量 4</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">bar:</span><br><span class="line">    .short 0xaaaa              // a: short 2 byte</span><br><span class="line">    .byte  0xbb                // b: char  1 byte</span><br><span class="line">    .byte  0x00                // padding</span><br><span class="line">    .word  0xcccccccc          // c: int   4 byte</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line">    .global main</span><br><span class="line">    .align 2</span><br><span class="line">main:</span><br><span class="line">    stp x29, x30, [sp, -16]!   // 保存栈帧</span><br><span class="line">    mov x29, sp</span><br><span class="line"></span><br><span class="line">    adrp x0, fmt</span><br><span class="line">    add  x0, x0, :lo12:fmt     // printf 格式字符串地址</span><br><span class="line"></span><br><span class="line">    adrp x1, bar</span><br><span class="line">    add  x1, x1, :lo12:bar     // bar 的地址</span><br><span class="line"></span><br><span class="line">    ldrh w2, [x1, Foo_a]       // 加载 bar.a（short）</span><br><span class="line">    ldrb w3, [x1, Foo_b]       // 加载 bar.b（char）</span><br><span class="line">    ldr  w4, [x1, Foo_c]       // 加载 bar.c（int）</span><br><span class="line"></span><br><span class="line">    bl printf                  // printf(bar, a, b, c)</span><br><span class="line"></span><br><span class="line">    // 显式退出</span><br><span class="line">    mov     x8, #93            // syscall number for exit</span><br><span class="line">    mov     x0, xzr            // exit code 0</span><br><span class="line">    svc     0                  // syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="using-structs"><a href="#using-structs" class="headerlink" title="using structs"></a>using structs</h4><p>To summarize using <code>structs</code>:</p><ul><li>All <code>structs</code> have a base address</li><li><strong>The base address corresponds to the beginning of the first data member</strong></li><li>All subsequent data members are offsets relative to the first</li><li>In order to use a <code>struct</code> correctly, you must have first calculated the offsets of each data member</li><li>Sometimes there will be padding between data members due to the need to align all data members on natural boundaries.</li></ul><h4 id="this-pointer-in-c"><a href="#this-pointer-in-c" class="headerlink" title="this pointer in c++"></a>this pointer in c++</h4><ul><li><strong>Every non-static method call employs a hidden first parameter. That’s it. That’s the slight of hand. The hidden argument is the this pointer.</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestClass tc;</span><br><span class="line">tc.<span class="built_in">SetString</span>(test_string);</span><br></pre></td></tr></table></figure><p>看起来我们只传入了一个参数 test_string。但实际上编译器传入了两个参数：</p><ol><li><p>第一个是 this 指针：也就是 tc 的地址，传给寄存器 x0</p></li><li><p>第二个是 test_string，传给寄存器 x1</p></li></ol><p>在汇编里看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adrp x1, _test_string</span><br><span class="line">adrp x0, _tc         // 把 tc 对象地址放到 x0 —— 也就是 this 指针</span><br><span class="line">bl __ZN9TestClass9SetStringEPc</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><blockquote><p>The meaning and function of <code>const</code> only <code>partially</code> translates to assembly language.</p></blockquote><ul><li><code>const</code> local variables and <code>const</code> parameters are just like any other data to assembly language.</li><li><p>The constant nature of <code>const</code> local variables and parameters is implemented solely in the compiler.</p></li><li><p><strong><code>const</code> globals are made constant by the hardware</strong>. Attempting to modify a variable protected in this manner will be like poking a dragon. Best not to poke dragons.</p></li></ul><h2 id="switch-and-jump-table"><a href="#switch-and-jump-table" class="headerlink" title="switch and jump table"></a>switch and jump table</h2><blockquote><p>When the C++ optimizer is enabled, it will look at your cases and choose between three different constructs for implementing your <code>switch</code>.</p><p>And, it can use any combination of the following! Compiler writers are smart!</p></blockquote><ol><li>It may emit a long string of <code>if / else</code> constructs.</li><li>It may find the right <code>case</code> using a <em>binary search</em>.</li><li>Finally, it might use a <strong>jump table</strong>.</li></ol><p>Suppose our cases are largely consecutive. Given that all branch instructions are the same length in bytes, we can do math on the switch variable to somehow derive the address of the case we want.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    r = rand() &amp; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">switch</span> (r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0 returned&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1 returned&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;2 returned&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;3 returned&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;4 returned&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;5 returned&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;6 returned&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;7 returned&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice that the <code>case</code> values are all, in this case, consecutive.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jt:     b       0f</span><br><span class="line">        b       1f</span><br><span class="line">        b       2f</span><br><span class="line">        b       3f</span><br><span class="line">        b       4f</span><br><span class="line">        b       5f</span><br><span class="line">        b       6f</span><br><span class="line">        b       7f</span><br></pre></td></tr></table></figure><p><code>f</code> means forward, <code>b</code> means backward</p><p>At address <code>jt</code> there are a sequence of branch statements… jumps if you will. Being in a sequence, this is an example of a jump table. We’ll compute the index into this <em>array of instructions</em> and then branch to it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsl     x0, x0, 2</span><br><span class="line">ldr     x1, =jt</span><br><span class="line">add     x1, x1, x0</span><br><span class="line">br      x1</span><br></pre></td></tr></table></figure><ul><li>Line 2 loads the base address of the “instruction array” starting at address <code>jt</code>.</li></ul><p>complete example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        .align  4</span><br><span class="line">        .global main</span><br><span class="line"></span><br><span class="line">main:   str     x30, [sp, -16]!</span><br><span class="line">        mov     x0, xzr             // set up call to time(nullptr)</span><br><span class="line">        bl      time                // call time setting up srand</span><br><span class="line">        bl      srand               // call srand setting up rand</span><br><span class="line">        bl      rand                // get a random number</span><br><span class="line">        and     x0, x0, 7           // ensure its range is 0 to 7</span><br><span class="line">                                    // note use of x register is on purpose</span><br><span class="line">        lsl     x0, x0, 2           // multiply by 4</span><br><span class="line">        ldr     x1, =jt             // load base address of jump table</span><br><span class="line">        add     x1, x1, x0          // add offset to base address</span><br><span class="line">        br      x1</span><br><span class="line"></span><br><span class="line">// If, as in this case, all the &quot;cases&quot; have the same number of</span><br><span class="line">// instructions then this intermediate jump table can be omitted saving</span><br><span class="line">// some space and a tiny amount of time. To omit the intermediate jump</span><br><span class="line">// table, you&#x27;d multiply by 12 above and not 4. Twelve because each</span><br><span class="line">// &quot;case&quot; has 3 instructions (3 x 4 == 12).</span><br><span class="line"></span><br><span class="line">// Question for you: If you did omit the jump table, relative to what</span><br><span class="line">// would you jump (since &quot;jt&quot; would be gone).</span><br><span class="line"></span><br><span class="line">jt:     b       0f</span><br><span class="line">        b       1f</span><br><span class="line">        b       2f</span><br><span class="line">        b       3f</span><br><span class="line">        b       4f</span><br><span class="line">        b       5f</span><br><span class="line">        b       6f</span><br><span class="line">        b       7f</span><br><span class="line"></span><br><span class="line">0:      ldr     x0, =ZR</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">1:      ldr     x0, =ON</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">2:      ldr     x0, =TW</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">3:      ldr     x0, =TH</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">4:      ldr     x0, =FR</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">5:      ldr     x0, =FV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">6:      ldr     x0, =SX</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">7:      ldr     x0, =SV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">99:     mov     w0, wzr</span><br><span class="line">        ldr     x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">        .section    .rodata</span><br><span class="line"></span><br><span class="line">ZR:     .asciz      &quot;0 returned&quot;</span><br><span class="line">ON:     .asciz      &quot;1 returned&quot;</span><br><span class="line">TW:     .asciz      &quot;2 returned&quot;</span><br><span class="line">TH:     .asciz      &quot;3 returned&quot;</span><br><span class="line">FR:     .asciz      &quot;4 returned&quot;</span><br><span class="line">FV:     .asciz      &quot;5 returned&quot;</span><br><span class="line">SX:     .asciz      &quot;6 returned&quot;</span><br><span class="line">SV:     .asciz      &quot;7 returned&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><h3 id="implement-falling-through"><a href="#implement-falling-through" class="headerlink" title="implement falling through"></a>implement falling through</h3><p>If there is no break falling the code for a case, control will simply fall through to the next case</p><p>Here is a snippet from the program linked just above</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:      ldr     x0, =ZR</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">1:      ldr     x0, =ON</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br></pre></td></tr></table></figure><h3 id="implementing-gaps"><a href="#implementing-gaps" class="headerlink" title="implementing gaps"></a>implementing gaps</h3><p>The example above present shows 8 consecutive cases. What if there was no code for case 4? In other words, what if case 4 didn’t exit?</p><p>Here is the result:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2:      ldr     x0, =TW</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">3:      ldr     x0, =TH</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">4:      b       99f</span><br><span class="line"></span><br><span class="line">5:      ldr     x0, =FV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br></pre></td></tr></table></figure><h3 id="other-strategies-for-implementing-switch"><a href="#other-strategies-for-implementing-switch" class="headerlink" title="other strategies for implementing switch"></a>other strategies for implementing switch</h3><p>As indicated above, an optimizer has at least three tools available to it to implement complex <code>switch</code> statements. And, it can combine these tools.</p><ol><li>For example, suppose your cases boil down to two ranges of fairly consecutive values. For example, you have cases 0 to 9 and also cases 50 to 59. You can implement this as <strong>two jump tables with an <code>if / else</code> to select</strong> which one you use.</li></ol><p>假设你的 <code>switch</code> 语句中，<code>case</code> 值主要集中在<strong>两个小的连续范围内</strong>，例如：一组是 <code>case 0</code> 到 <code>case 9</code>,另一组是 <code>case 50</code> 到 <code>case 59</code>,那么可以用 <strong>两个跳转表</strong> 来处理这两个范围，再用一个 <code>if / else</code> 来决定使用哪一个跳转表。</p><ol><li>Suppose you have a large <code>switch</code> statement with widely ranging <code>case</code> values. In this case, you can implement a binary search to narrow down to a small range in which another technique becomes viable to narrow down to a single <code>case</code>.</li></ol><p>假设你有一个包含很多 <code>case</code> 分支的 <code>switch</code> 语句，而且这些 <code>case</code> 值之间的<strong>数值范围差异很大</strong>,比如 case 10, case 1000, case 50000…，那么可以<strong>先用二分查找法缩小查找范围</strong>，把目标值限制在一个<strong>较小的范围内</strong>，然后在这个范围内再用其他技术（比如跳转表、线性比较等）来确定最终对应哪个 <code>case</code> 分支。</p><ol><li>You might have need to implement <strong>hierarchical jump tables（分层跳转表）</strong>, for example.</li></ol><p>“分层跳转表”是一种优化结构，适用于以下情况：</p><ul><li><code>case</code> 值非常<strong>稀疏</strong>、<strong>范围极广</strong>（例如 <code>case 0, case 1000, case 2000...</code>)</li><li>但它们在<strong>局部范围内是稠密的</strong>（比如 <code>1000~1009</code>, <code>2000~2009</code>）</li></ul><p>你可以：</p><ol><li><strong>先用一个“一级跳转表”根据高位或区段跳转</strong>到一个子跳转表（子范围）。</li><li><strong>再在子跳转表中做具体跳转</strong>。<br>这就构成了一个“分层结构”——像树一样的跳转过程。</li></ol><h3 id="strategies-for-implementing-if-else"><a href="#strategies-for-implementing-if-else" class="headerlink" title="strategies for implementing if-else"></a>strategies for implementing if-else</h3><p>If you do choose to implement a long chain of <code>if / else</code> statements, consider how frequently a given case might be chosen. <strong>Put the most common cases at the top of the <code>if / else</code> sequence</strong>.</p><p><strong>This is known as making the common case fast.</strong></p><p>Making the common case fast is one of the Great Ideas in Computer Science. One, you would do well to remember no matter what language you’re working with.</p><h2 id="fucntions"><a href="#fucntions" class="headerlink" title="fucntions"></a>fucntions</h2><h3 id="bottom-line-concept"><a href="#bottom-line-concept" class="headerlink" title="bottom line concept"></a>bottom line concept</h3><p>The <code>bl</code> instruction is stands for Branch with Link. The Link concept is what enables a function (or method) to return to the instruction after the call.</p><p>Branch-with-link computes the address of the instruction following it.</p><blockquote><p>It places this address into register <code>x30</code> and then branches to the label provided. It makes one link of a trail of breadcrumbs to follow to get back following a <code>ret</code>.</p></blockquote><p><strong>This is why it is absolutely essential to backup <code>x30</code> inside your functions if they call other functions themselves.</strong></p><h4 id="a-example"><a href="#a-example" class="headerlink" title="a example"></a>a example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        .global main</span><br><span class="line">        .align  2</span><br><span class="line"></span><br><span class="line">main:   ldr     x0, =hw</span><br><span class="line">        bl      puts</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">hw:     .asciz  &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><p><strong>The program hung and had to be killed with ^C.</strong></p><p>Somebody called <code>main()</code> - it’s a function and someone called it with a <code>bl</code> instruction. At the moment <code>main()</code> entered, the address to which it needed to return was sitting in <code>x30</code>.</p><p>Then, <code>main()</code> called a function - in this case <code>puts()</code> but which function is called doesn’t matter - it called a function. In doing so, it overwrote the address to which <code>main()</code> needed to return with the address of line 7 in the code. That is where <code>puts()</code> needs to return.</p><p>So, when line 7 executes it puts the contents of <code>x30</code> into the program counter and branches to it.</p><p>Here is a fixed version of the code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        .global main</span><br><span class="line">        .align  2</span><br><span class="line"></span><br><span class="line">main:   str     x30, [sp, -16]!</span><br><span class="line">        ldr     x0, =hw</span><br><span class="line">        bl      puts</span><br><span class="line">        ldr     x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">hw:     .asciz  &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><p>In the AARCH64 Linux style calling convention, values are returned in <code>x0</code> and sometimes also returned in other scratch registers though this is uncommon.(Note that <code>x0</code> could also be <code>w0</code> or the first floating point register if the function is returning a <code>float</code> or <code>double</code>.)</p><p>If your functions call <em>any</em> other functions, <code>x30</code> must be backed up on the stack and then restored into <code>x30</code> before returning.</p><p>A function with more than one return value is not supported by C or C++ but they can be written in assembly language where the rules are yours to break.</p><h3 id="inline-functions"><a href="#inline-functions" class="headerlink" title="inline functions"></a>inline functions</h3><p>Functions that are declared as <em>inline</em> don’t actually make function calls. Instead, the code from the function is type checked and inserted directly where the “call” is made after adjusting for parameter names.</p><h3 id="passing-parameters-to-functions"><a href="#passing-parameters-to-functions" class="headerlink" title="passing parameters to functions"></a>passing parameters to functions</h3><p><strong>How parameters are passed to functions can be different from OS to OS.</strong> This chapter is written to the standard implemented for Linux.</p><p>For the purposes of the present discussion, we assume all parameters are <code>long int</code> and are therefore stored in <code>x</code> registers.</p><ul><li><p><strong>Up to 8 parameters can be passed directly via scratch registers.</strong>（These are <code>x0</code> through <code>x7</code>） Each parameter can be up to the size of an address, long or double (8 bytes).</p><ul><li><p><strong><em>Scratch</em> means the value of the register can be changed at will without any need to backup or restore their values across function calls.</strong></p></li><li><p><strong>This means that you cannot count on the contents of the scratch registers maintaining their value if your function makes any function calls.</strong></p></li></ul></li></ul><h4 id="a-example-1"><a href="#a-example-1" class="headerlink" title="a example"></a>a example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> p1, <span class="type">long</span> p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>is implemented as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func:   add x0, x0, x1</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>If you are the author of both the caller and the callee and both are in assembly language, you can play loosey goosey with how you return values. Specifically, you can return more than one value. <strong>But</strong> if you do so, you give up the possibility of calling these functions from C or C++.</p><h3 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">long</span> p1, <span class="type">const</span> <span class="type">long</span> p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>how would the assembly language change?</p><p>Answer: no change at all!</p><p><code>const</code> is an instruction to the compiler ordering it to prohibit changing the values of <code>p1</code> and <code>p2</code>. We’re smart humans and realize that our assembly language makes no attempt to change <code>p1</code> and <code>p2</code> so no changes are warranted.</p><h3 id="passing-pointers"><a href="#passing-pointers" class="headerlink" title="passing pointers"></a>passing pointers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> * p1, <span class="type">long</span> * p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    *p1 = *p1 + *p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func:   ldr x2, [x0]</span><br><span class="line">        ldr x3, [x1]</span><br><span class="line">        add x2, x2, x3</span><br><span class="line">        str x2, [x0]</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>The value of <code>x0</code> on return is, in the general sense, undefined because this is a <code>void</code> function.</p><h3 id="passing-reference"><a href="#passing-reference" class="headerlink" title="passing reference"></a>passing reference</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">func</span><span class="params">(<span class="type">long</span> &amp; p1, <span class="type">long</span> &amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func:   ldr x0, [x0]</span><br><span class="line">        ldr x1, [x1]</span><br><span class="line">        add x0, x0, x1</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>Passing by reference is also an instruction to the compiler to treat pointers a little differently - the differences don’t show up here so there the only change to our pointer passing version is how we return the answer.</p><h3 id="more-than-eight-parameters"><a href="#more-than-eight-parameters" class="headerlink" title="more than eight parameters"></a>more than eight parameters</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SillyFunction</span><span class="params">(<span class="type">long</span> p1, <span class="type">long</span> p2, <span class="type">long</span> p3, <span class="type">long</span> p4,</span></span><br><span class="line"><span class="params">                   <span class="type">long</span> p5, <span class="type">long</span> p6, <span class="type">long</span> p7, <span class="type">long</span> p8,</span></span><br><span class="line"><span class="params">                   <span class="type">long</span> p9)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This example hurts: %ld %ld\n&quot;</span>, p8, p9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SillyFunction(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        .global    main</span><br><span class="line"></span><br><span class="line">/*  Demonstration of using  more than 8 arguments to  a function.  This</span><br><span class="line">    demo is LINUX only as APPLE will put all arguments beyond the first</span><br><span class="line">    one on the stack anyway.</span><br><span class="line"></span><br><span class="line">    On LINUX, all parameters to a function beyond  the  eight go on the</span><br><span class="line">    stack.  The first 8 go in registers  x0  through  x7 as normal (for</span><br><span class="line">    LINUX).</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SillyFunction:</span><br><span class="line">        stp        x29, x30, [sp, -16]!    // Changes sp.</span><br><span class="line">        mov        x29, sp                 // set new sp</span><br><span class="line">        ldr        x0, =fmt</span><br><span class="line">        mov        x1, x7                  // 第八个参数</span><br><span class="line">        ldr        x2, [sp, 16]            // This does not alter the sp，第九个参数</span><br><span class="line">        bl         printf</span><br><span class="line">        ldp        x29, x30, [sp], 16      // Undoes change to sp.</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">        stp        x29, x30, [sp, -16]!    // sp down total of 16.</span><br><span class="line">        mov        x29, sp</span><br><span class="line">        mov        x0, 9</span><br><span class="line">        str        x0, [sp, -16]!          // sp down total of 32.</span><br><span class="line">        mov        x0, 1</span><br><span class="line">        mov        x1, 2</span><br><span class="line">        mov        x2, 3</span><br><span class="line">        mov        x3, 4</span><br><span class="line">        mov        x4, 5</span><br><span class="line">        mov        x5, 6</span><br><span class="line">        mov        x6, 7</span><br><span class="line">        mov        x7, 8</span><br><span class="line">        bl         SillyFunction</span><br><span class="line">        add        sp, sp, 16           // undoes change of sp by 16 due</span><br><span class="line">                                        // to function call.</span><br><span class="line">        ldp        x29, x30, [sp], 16   // undoes change to sp of 16.</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">fmt:    .asciz    &quot;This example hurts my brain: %ld %ld\n&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><p>After executing <code>Line 24</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    former contents of frame pointer</span><br><span class="line">sp + 8    return address for main</span><br></pre></td></tr></table></figure><p>After executing <code>Line 27</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    9</span><br><span class="line">sp + 8    garbage</span><br><span class="line">sp + 16   former contents of frame pointer</span><br><span class="line">sp + 24   return address for main</span><br></pre></td></tr></table></figure><p>After executing <code>Line 14</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    return address for SillyFunction</span><br><span class="line">sp + 8    garbage</span><br><span class="line">sp + 16   9</span><br><span class="line">sp + 24   garbage</span><br><span class="line">sp + 32   former contents of frame pointer</span><br><span class="line">sp + 40   return address for main</span><br></pre></td></tr></table></figure><p>This means that <code>Line 18</code> fetches <code>p9</code> from memory and puts its value into x2 (where it becomes the third argument to <code>printf()</code>).</p><blockquote><p>在 AArch64 中，栈空间常常是 <strong>以 16 字节为单位对齐</strong>分配的，但你可能 <strong>只写了其中的一部分数据</strong>，剩下的就没有被初始化，于是我们称它为 <strong>“garbage”（未定义的内容）</strong>。</p></blockquote><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><h3 id="examples-of-calling-some-common-C-runtime-functions"><a href="#examples-of-calling-some-common-C-runtime-functions" class="headerlink" title="examples of calling some common C runtime functions"></a>examples of calling some common C runtime functions</h3><p>There are, by the way, two broad types of functions within the C runtime.</p><ul><li><p>Some are implemented largely in the C runtime itself.</p></li><li><p>Others that exist in the C runtime act as wrappers for functions implemented within the OS itself. These are called “system calls”.</p></li></ul><p>For the purposes of calling functions in the C runtime, there is no practical difference between these two types. Note however, there are ways of calling system calls directly using the <code>svc</code> instruction.</p><p>“C runtime”（<strong>C 运行时</strong>）指的是一组在程序运行时提供支持的函数、变量和基础机制，<strong>主要用于支持 C 语言标准库和程序的初始化/终止</strong>。这套系统通常被称为 <strong>C runtime library（C 运行时库）</strong>，在不同平台中常见的实现有：</p><ul><li>GNU/Linux 下的 <strong>glibc</strong></li><li>Windows 下的 <strong>MSVCRT</strong></li><li>macOS 下的 <strong>libSystem.dylib（包含 libc）</strong></li></ul><p>C runtime 做了哪些事？</p><ol><li><strong>程序初始化</strong><ul><li>在 <code>main()</code> 执行之前，C runtime 会设置好堆栈、初始化全局变量、调用构造函数等。</li><li>典型入口点是 <code>_start</code> → <code>__libc_start_main()</code> → <code>main()</code>。</li></ul></li><li><strong>提供标准库函数</strong><ul><li>如 <code>printf()</code>, <code>malloc()</code>, <code>exit()</code>, <code>fopen()</code> 等，这些函数由 C runtime 实现或封装。</li></ul></li><li><strong>管理资源</strong><ul><li>比如内存分配、文件句柄、线程等的生命周期管理。</li></ul></li><li><strong>提供系统调用封装</strong><ul><li>比如你调用 <code>write()</code>，它其实是调用了一个 <strong>C runtime 提供的 wrapper</strong>，最终通过 <code>syscall</code> 或 <code>svc</code> 指令访问内核。</li></ul></li></ol><h3 id="system-calls"><a href="#system-calls" class="headerlink" title="system calls"></a>system calls</h3><p>Many C runtime functions are just wrappers for system calls. For example if you call open() from the C runtime, the function will perform a few bookkeeping operations and then make the actual system call.</p><h4 id="What-IS-a-system-call"><a href="#What-IS-a-system-call" class="headerlink" title="What IS a system call?"></a>What IS a system call?</h4><p>The short answer is a system call is a sort-of function call that is serviced by the operating system itself, within its own private region of memory and with access to internal features and data structures.</p><p>Our programs run in “userland”. The technical name for userland on the ARM64 processor is EL0 (Exception Level 0).</p><p>We can operate within the kernel’s space only through carefully controlled mechanisms - such as system calls. The technical name for where the kernel (or system) generally operates is called EL1.</p><p>There are two higher Exception Levels (EL2 and EL3) which are beyond the scope of this book.</p><h4 id="Mechanism-of-making-a-system-call"><a href="#Mechanism-of-making-a-system-call" class="headerlink" title="Mechanism of making a system call"></a>Mechanism of making a system call</h4><p>First, like any function call, parameters need to be set up. The first parameter goes in the first register, etc.</p><p>Second, a number associated with the specific system call we wish to make is loaded in a specific register (w8).</p><p>Finally, a special instruction svc causes a trap which elevates us out of userland into kernel space. Said differently, svc causes a transition from EL0 to EL1. There, various checks are done and the actual code for the system call is run.</p><p>A description of returning from a system call is beyond the scope of this book. Hint: just as there’s a special instruction that escalates from EL0 to EL1, there is a special instruction that does the reverse.</p><h4 id="the-number-associated-with-a-particular-system-call"><a href="#the-number-associated-with-a-particular-system-call" class="headerlink" title="the number associated with a particular system call"></a>the number associated with a particular system call</h4><p>reference:</p><div class="tag link"><a class="link-card" title="syscalls" href="https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html"><div class="left"><img src="/img/avatar.gif"/></div><div class="right"><p class="text">syscalls</p><p class="url">https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html</p></div></a></div><h4 id="example-getpid"><a href="#example-getpid" class="headerlink" title="example getpid()"></a>example getpid()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Greetings from: %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Written in assembly language using C runtime</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        .global main</span><br><span class="line">        .text</span><br><span class="line">        .align  2</span><br><span class="line"></span><br><span class="line">main:   stp     x29, x30, [sp, -16]!</span><br><span class="line">        bl      getpid</span><br><span class="line">        mov     w1, w0</span><br><span class="line">        ldr     x0, =fmt</span><br><span class="line">        bl      printf</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        mov     w0, wzr</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">fmt:    .asciz  &quot;Greetings from: %d\n&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><p>And finally: calling the system call directly</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        .global main</span><br><span class="line">        .text</span><br><span class="line">        .align  2</span><br><span class="line"></span><br><span class="line">main:   stp     x29, x30, [sp, -16]!</span><br><span class="line">        mov     x8, 172                 // getpid on ARM64</span><br><span class="line">        svc     0                       // trap to EL1</span><br><span class="line">        mov     w1, w0</span><br><span class="line">        ldr     x0, =fmt</span><br><span class="line">        bl      printf</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        mov     w0, wzr</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">fmt:    .asciz  &quot;Greetings from: %d\n&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><p>We chose getpid() because it doesn’t require any parameters. Using the C runtime, we simply bl to it. <strong>Calling the system call directly is different in that we must first load x8 with the number that corresponds to getpid() for the AARCH64 architecture</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">/*  Perry Kivolowitz</span><br><span class="line">    Example of file operations.</span><br><span class="line">*/</span><br><span class="line">        .text</span><br><span class="line">        .global main</span><br><span class="line">        .align  2</span><br><span class="line"></span><br><span class="line">/*  This program will</span><br><span class="line">    * open() a file in the current directory,</span><br><span class="line">    * write() some text to it,</span><br><span class="line">    * seek back to the beginning of the file,</span><br><span class="line">    * read() each line, printing it</span><br><span class="line">    * close() the file</span><br><span class="line">*/</span><br><span class="line">// 使用 .req 给寄存器取别名，便于阅读。例如，fd 其实就是 w28，代表文件描述符。</span><br><span class="line">retval  .req    w27</span><br><span class="line">fd .reqw28</span><br><span class="line"></span><br><span class="line">main:   stp     x29, x30, [sp, -16]!</span><br><span class="line">        stp     x27, x28, [sp, -16]!</span><br><span class="line">        bl      open_file</span><br><span class="line"></span><br><span class="line">        // w0 will contain either the file descriptor of the new</span><br><span class="line">        // file or -1 for a failure. Note that the value in w0</span><br><span class="line">        // has also been copied to &quot;fd&quot; - a register alias.</span><br><span class="line">        cmp w0, wzr</span><br><span class="line">        bge 1f</span><br><span class="line"></span><br><span class="line">        // If we get here, the open has failed. Use perror() to</span><br><span class="line">        // print a meaningful error and branch to exit. The return</span><br><span class="line">        // code of the program will be set to non-zero inside fail.</span><br><span class="line">        ldr     x0, =fname</span><br><span class="line">        bl      fail</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">1:// When we get here, the file is open. Write some data to it.</span><br><span class="line">        // If write_file returns non-zero, it signifies an error. If</span><br><span class="line">        // so, branch to the file closing code since the file is open</span><br><span class="line">        // after printing an error message.</span><br><span class="line">        blwrite_data</span><br><span class="line">        cbz    w0, 10f</span><br><span class="line"></span><br><span class="line">        // If we get here, there was an error in write_data. Print</span><br><span class="line">        // a reasonable error message then branch to the clean usleep</span><br><span class="line">        // code.</span><br><span class="line">        ldr     x0, =wf     // load legend</span><br><span class="line">        bl      fail        // print error</span><br><span class="line">        b       50f         // branch to clean up.</span><br><span class="line"></span><br><span class="line">        // Seek back to position zero preparing to read the file back.</span><br><span class="line">        // The return value in x0 (off_t) is the return value of</span><br><span class="line">        // lseek().</span><br><span class="line">10:     bl      seek_zero</span><br><span class="line">        cbz     x0, 20f</span><br><span class="line"></span><br><span class="line">        // If we get here, the seek failed. Cause a reasonable</span><br><span class="line">        // message to be printed then branch to the clean up code.</span><br><span class="line">        ldr     x0, =sf</span><br><span class="line">        bl      fail</span><br><span class="line">        b       50f</span><br><span class="line"></span><br><span class="line">20:     // When we get here, we have to read from the file and print</span><br><span class="line">        // the results. To ignore the complexity of memory allocation</span><br><span class="line">        // and buffer overrun potential, we&#x27;ll read one character at a</span><br><span class="line">        // time looking the end-of-file.</span><br><span class="line"></span><br><span class="line">        // ssize_t read(int fildes, void *buf, size_t nbyte);</span><br><span class="line">        mov     w0, fd</span><br><span class="line">        ldr     x1, =buffer</span><br><span class="line">        mov     x2, 1</span><br><span class="line">        bl      read</span><br><span class="line">        // Check the return value - should be 1.</span><br><span class="line">        cbz     x0,50f      // zero means EOF - that&#x27;s OK.</span><br><span class="line">        // If x0 is negative, that IS a problem.</span><br><span class="line">        cmp     x0, xzr</span><br><span class="line">        bge     25f</span><br><span class="line">        // The return value is negative - this is an error.</span><br><span class="line">        ldr     x0, =rf</span><br><span class="line">        bl      fail</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">25:     // Write the character sitting in buffer to the console.</span><br><span class="line">        mov     w0, 1</span><br><span class="line">        ldr     x1, =buffer</span><br><span class="line">        mov     x2, 1</span><br><span class="line">        bl      write</span><br><span class="line">        // We will ignore the return value for the sake of brevity.</span><br><span class="line">        // There are plenty of examples of handling a potential error</span><br><span class="line">        // elsewhere in this code.</span><br><span class="line">        // --</span><br><span class="line">        b       20b</span><br><span class="line"></span><br><span class="line">        // When we get here, we are done. Close the file.</span><br><span class="line">50:movw0, fd</span><br><span class="line">        bl close</span><br><span class="line">        mov retval, wzr</span><br><span class="line"></span><br><span class="line">99:     ldp     x27, x28, [sp], 16</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        mov     w0, retval</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*open_file()</span><br><span class="line">    This function attempts to open a file for both reading and</span><br><span class="line">    writing. Return values will be checked to ensure the file is</span><br><span class="line">    opened. If successful, the fd is returned (and is squirreled</span><br><span class="line">    away in register &quot;fd&quot;). If unsuccessful, the -1 returned by</span><br><span class="line">    open() is passed back to the caller.</span><br><span class="line"></span><br><span class="line">    Explanation of the magic numbers:</span><br><span class="line"></span><br><span class="line">    int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">    octal 102 for flags is O_RDRW | O_CREAT</span><br><span class="line">    octal 600 for mode is rw------- i.e. read and write for</span><br><span class="line">        the owner but no permissions for anyone else.</span><br><span class="line"></span><br><span class="line">There is a version of open() that takes two parameters. However,</span><br><span class="line">if O_CREAT is specified, the three parameter version is required.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">        .equ    O_FLAGS, 0102</span><br><span class="line">        .equ    O_MODE, 0600</span><br><span class="line"></span><br><span class="line">open_file:</span><br><span class="line">        stp      x29, x30, [sp, -16]!</span><br><span class="line">        ldr      x0, =fname</span><br><span class="line">        mov      w1, O_FLAGS</span><br><span class="line">        mov      w2, O_MODE</span><br><span class="line">        bl       open</span><br><span class="line">        mov      fd, w0</span><br><span class="line">        ldp      x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*  This function uses perror() to print a meaningful error</span><br><span class="line">    message in the event of a failure. The string value</span><br><span class="line">    passed to perror() arrives to us as a pointer in x0.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        bl perror</span><br><span class="line">        movretval, 1</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*  ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">This function will write a string to the file descriptor contained</span><br><span class="line">in &quot;fd&quot; (a register alias).</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">write_data:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        str     x20, [sp, -16]!</span><br><span class="line">        mov     w0, fd              // file descriptor</span><br><span class="line">        ldr     x1, =txt            // address to print from</span><br><span class="line">        ldr     x2, =txt_s          // load pointer to size</span><br><span class="line">        ldr     x2, [x2]            // dereference the pointer</span><br><span class="line">        mov     w20, w2             // need this value for error check.</span><br><span class="line">        bl      write</span><br><span class="line">        cmp     x0, x20             // Did we write the expected amount?</span><br><span class="line">        bne     90f</span><br><span class="line">        // successful write - return 0</span><br><span class="line">        mov     x0, xzr</span><br><span class="line">        b       99f</span><br><span class="line">90:     // failure - ensure we return non-zero!</span><br><span class="line">        mov     x0, 1</span><br><span class="line">99:     ldr     x20, [sp], 16</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*  off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">*/</span><br><span class="line">seek_zero:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        mov     w0, fd          // file descriptor</span><br><span class="line">        mov     x1, xzr         // beginning of file</span><br><span class="line">        mov     w2, wzr         // SEEK_SET - absolute offset</span><br><span class="line">        bl      lseek</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">prog:.asciz&quot;file_ops&quot;</span><br><span class="line">wf:     .asciz  &quot;write failed&quot;</span><br><span class="line">rf:     .asciz  &quot;read failed&quot;</span><br><span class="line">sf:     .asciz  &quot;lseek failed&quot;</span><br><span class="line">fname:.asciz&quot;test.txt&quot;</span><br><span class="line">txt:.asciz&quot;some data\n&quot;</span><br><span class="line">txt_s:.wordtxt_s - txt - 1// strlen(txt)，txt：“some data”的总长度</span><br><span class="line">buffer: .word   0</span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><h2 id="floating-point"><a href="#floating-point" class="headerlink" title="floating point"></a>floating point</h2><h3 id="what-are-floating-points-numbers"><a href="#what-are-floating-points-numbers" class="headerlink" title="what are floating points numbers?"></a>what are floating points numbers?</h3><p>reference<br><div class="tag link"><a class="link-card" title="CSAPP DataLab" href="https://even629.com/posts/42856/"><div class="left"><img src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">CSAPP DataLab</p><p class="url">https://even629.com/posts/42856/</p></div></a></div></p><p><strong>IEEE 754</strong></p><h3 id="register-1"><a href="#register-1" class="headerlink" title="register"></a>register</h3><p>There are four highest level ideas relating to floating point operations on AARCH64.</p><ul><li>There is another complete register set for floating point values.</li><li>There are alternative instructions just for floating point values.</li><li>There are exotic instructions that operate on sets of floating point values (SIMD).</li><li>There are instructions to go back and forth to and from the integer registers.</li></ul><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/simdlanes.jpg" alt="regs"></p><p>上图展示了 <strong>ARM64 架构中 SIMD（Single Instruction, Multiple Data）寄存器 V0 的不同视图与访问方式</strong>，包括<strong>不同位宽的排列方式（Arrangement Specifiers）与 Lane（通道）索引</strong>。</p><p><strong>图解说明</strong></p><p>这个图以 <strong>V0 寄存器为例</strong>，展示了 <strong>如何用不同的排列方式访问其内容</strong>：</p><div class="table-container"><table><thead><tr><th>层级</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>最底层</td><td><code>V0</code></td><td>整个 128-bit 的 V0 寄存器</td></tr><tr><td>向上</td><td><code>V0.2D</code>, <code>V0.4S</code>, <code>V0.8H</code>, <code>V0.16B</code></td><td>以不同大小的数据视图访问 V0：<br/>- D = 64-bit（2 × 64bit）<br/>- S = 32-bit（4 × 32bit）<br/>- H = 16-bit（8 × 16bit）<br/>- B = 8-bit（16 × 8bit）</td></tr><tr><td>再上</td><td><code>V0.2D[0]</code>, <code>V0.4S[0]</code> 等</td><td>每个 lane 的索引，比如：<br/>- <code>V0.4S[2]</code> 表示第 3 个 32-bit 单元<br/>- <code>V0.16B[15]</code> 表示第 16 个 8-bit 字节</td></tr><tr><td>最上层</td><td><code>B0</code>, <code>H0</code>, <code>S0</code>, <code>D0</code></td><td>是对 <code>V0</code> 的 alias，按位宽访问（只访问最低位的数据）</td></tr></tbody></table></div><h3 id="truncation-towards-zero"><a href="#truncation-towards-zero" class="headerlink" title="truncation towards zero"></a>truncation towards zero</h3><p>truncate(截断)</p><p>In C and C++, truncation is what we get from:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">integer_variable = <span class="type">int</span>(floating_variable);  <span class="comment">// C++</span></span><br><span class="line">integer_variable = (<span class="type">int</span>) floating_variable; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><blockquote><p>The instruction is <strong>fcvtz</strong> - convert towards zero. Then, the choice as to whether to produce a signed or unsigned result is defined by the final letterL u or s.</p></blockquote><div class="table-container"><table><thead><tr><th>Mnemonic</th><th>Meaning</th></tr></thead><tbody><tr><td>fcvtzu</td><td>Truncate (always towards 0) producing an unsigned int</td></tr><tr><td>fcvtzs</td><td>Truncate (always towards 0) producing a signed int</td></tr></tbody></table></div><ul><li>fcvtzu: <strong>F</strong>loat <strong>C</strong>onvert to <strong>U</strong>nsigned integer, with truncation toward zero</li><li>fcvtzs: <strong>F</strong>loat <strong>C</strong>onvert to <strong>S</strong>igned integer, with truncation toward zero</li></ul><p>this instruction which completely discards the fractional value is said by the ARM documentation as doing rounding not truncating.</p><p>The the choice of source register defined whether you are converting a double or single precision floating point value.</p><div class="table-container"><table><thead><tr><th>Source Register</th><th>Converts a</th></tr></thead><tbody><tr><td>dX</td><td><code>double</code> to an integer</td></tr><tr><td>sX</td><td><code>float</code> to an integer</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Destination Register</th><th>Converts a</th></tr></thead><tbody><tr><td>xX</td><td>64 bit integer</td></tr><tr><td>wX</td><td>32 bit or less integer</td></tr></tbody></table></div><p>Examples where <code>d</code> is a <code>double</code> and <code>f</code> is a <code>float</code>:</p><div class="table-container"><table><thead><tr><th>C++</th><th>Instruction</th></tr></thead><tbody><tr><td><code>int32_t(d)</code></td><td><code>fcvtzs    w0, d0</code></td></tr><tr><td><code>uint32_t(d)</code></td><td><code>fcvtzu    w0, d0</code></td></tr><tr><td><code>int64_t(d)</code></td><td><code>fcvtzs    x0, d0</code></td></tr><tr><td><code>uint64_t(d)</code></td><td><code>fcvtzu    x0, d0</code></td></tr></tbody></table></div><h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">    .section .text</span><br><span class="line">    .global main</span><br><span class="line">    .type main, @function // 表示 告诉汇编器和链接器：main 是一个函数符号（symbol）</span><br><span class="line">    //.type &lt;symbol&gt;, @&lt;type&gt; 是 GAS（GNU Assembler）的一条伪指令，用于给符号指定类型。</span><br><span class="line">    // &lt;symbol&gt;：符号名，比如 main</span><br><span class="line">    // @&lt;type&gt;：符号类型，这里是 @function，表示这是一个函数，而不是变量或标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    stp     x29, x30, [sp, -16]!     // 保存 frame pointer 和 link register</span><br><span class="line">    mov     x29, sp</span><br><span class="line"></span><br><span class="line">    // 保存浮点寄存器</span><br><span class="line">    stp     d20, d21, [sp, -16]!</span><br><span class="line">    stp     d22, d23, [sp, -16]!</span><br><span class="line"></span><br><span class="line">    // 加载提示信息</span><br><span class="line">    ldr     x0, =leg</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // 加载 vless 数据到 d20-d23</span><br><span class="line">    ldr     x0, =vless</span><br><span class="line">    ldr     d20, [x0]            // dless = 5.49</span><br><span class="line">    ldr     d21, [x0, #8]        // dmore = 5.51</span><br><span class="line">    ldr     d22, [x0, #16]       // ndless = -5.49</span><br><span class="line">    ldr     d23, [x0, #24]       // ndmore = -5.51</span><br><span class="line"></span><br><span class="line">    // fcvtps: 向上取整（+∞）</span><br><span class="line">    fcvtps  x1, d20</span><br><span class="line">    fcvtps  x2, d21</span><br><span class="line">    ldr     x0, =fmt1</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtps  x1, d22</span><br><span class="line">    fcvtps  x2, d23</span><br><span class="line">    ldr     x0, =fmt1</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtns: 四舍五入 (tie to even)</span><br><span class="line">    fcvtns  x1, d20</span><br><span class="line">    fcvtns  x2, d21</span><br><span class="line">    ldr     x0, =fmt2</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtns  x1, d22</span><br><span class="line">    fcvtns  x2, d23</span><br><span class="line">    ldr     x0, =fmt2</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtzs: 向 0 取整</span><br><span class="line">    fcvtzs  x1, d20</span><br><span class="line">    fcvtzs  x2, d21</span><br><span class="line">    ldr     x0, =fmt4</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtzs  x1, d22</span><br><span class="line">    fcvtzs  x2, d23</span><br><span class="line">    ldr     x0, =fmt4</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtas: 四舍五入 (tie away from zero)</span><br><span class="line">    fcvtas  x1, d20</span><br><span class="line">    fcvtas  x2, d21</span><br><span class="line">    ldr     x0, =fmt3</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtas  x1, d22</span><br><span class="line">    fcvtas  x2, d23</span><br><span class="line">    ldr     x0, =fmt3</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // 恢复浮点寄存器和返回地址</span><br><span class="line">    ldp     d22, d23, [sp], #16</span><br><span class="line">    ldp     d20, d21, [sp], #16</span><br><span class="line">    ldp     x29, x30, [sp], #16</span><br><span class="line">    mov     w0, wzr</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .section .rodata</span><br><span class="line">vless:</span><br><span class="line">    .double 5.49</span><br><span class="line">    .double 5.51</span><br><span class="line">    .double -5.49</span><br><span class="line">    .double -5.51</span><br><span class="line"></span><br><span class="line">fmt1:</span><br><span class="line">    .asciz &quot;fcvtps less: %ld more: %ld\n&quot;</span><br><span class="line">fmt2:</span><br><span class="line">    .asciz &quot;fcvtns less: %ld more: %ld\n&quot;</span><br><span class="line">fmt3:</span><br><span class="line">    .asciz &quot;fcvtas less: %ld more: %ld\n&quot;</span><br><span class="line">fmt4:</span><br><span class="line">    .asciz &quot;fcvtzs less: %ld more: %ld\n&quot;</span><br><span class="line">leg:</span><br><span class="line">    .asciz &quot;less values are +/- 5.49. more values are +/- 5.51.\n&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Notice all the values were truncated to the whole number that is closer to zero.</p><h3 id="Truncation-Away-From-Zero"><a href="#Truncation-Away-From-Zero" class="headerlink" title="Truncation Away From Zero"></a>Truncation Away From Zero</h3><p>Truncation away from zero is not as easy. In fact, it cannot be performed with a single instruction.</p><p>In C (and C++):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iv = (<span class="type">int</span>(fv) == fv) ? <span class="type">int</span>(fv) : <span class="type">int</span>(fv) + ((fv &lt; <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>If the fv is already equal to a whole number, the integer value will be that whole number. Other wise the iv is the whole number further away from zero.</p><p>In C++, a more sophisticated version would require <cmath> and could look like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyTruncate</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((x &lt; <span class="number">0</span>) ? <span class="built_in">floor</span>(x) : <span class="built_in">ceil</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>floor() always truncates downward (towards more negative).<br>ceil() always truncates upwards (towards more positive).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RoundAwayFromZero:</span><br><span class="line">        fcmp    d0, 0</span><br><span class="line">        ble     1f</span><br><span class="line">        // Value is positive, truncate towards positive infinity (ceil)</span><br><span class="line">        frintp  d0, d0</span><br><span class="line">        b       2f</span><br><span class="line">1:      // Value is negative, truncate towards negative infinity (floor)</span><br><span class="line">        frintm  d0, d0</span><br><span class="line">2:      fcvtzs  x0, d0</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><ul><li><p>frintp（<strong>R</strong>ound toward +∞）</p></li><li><p>frintm（<strong>R</strong>ound toward -∞）</p></li><li><p>frintz（<strong>R</strong>ound toward 0）</p></li><li><p>frinta（<strong>R</strong>ound to nearest, tie away from 0）</p></li><li><p>frintn（<strong>R</strong>ound to nearest, tie to even）</p></li></ul><h3 id="rounding-conversion"><a href="#rounding-conversion" class="headerlink" title="rounding conversion"></a>rounding conversion</h3><p>rounding(四舍五入)<br>An instruction which does what we normally think of as rounding is frinta. This is the conversion “to nearest with ties going away.” So, 5.5 goes to 6 as one would expect from “rounding.”</p><h3 id="converting-an-integer-to-a-float-point-value"><a href="#converting-an-integer-to-a-float-point-value" class="headerlink" title="converting an integer to a float point value"></a>converting an integer to a float point value</h3><p>In C / C++:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double_var = <span class="built_in">double</span>(integer_var); <span class="comment">// C++</span></span><br><span class="line">double_var = (<span class="type">double</span>)integer_var; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p>Is handled by two instructions:</p><ul><li><strong>scvtf</strong> converts a signed integer to a floating point value</li><li><strong>ucvtf</strong> converts an unsigned integer to a floating point value<br>The name of the destination register controls which kind of floating point value is made. For example, specifying dX makes a double etc.</li></ul><p>The name of the destination register controls which kind of floating point value is made. For example, specifying dX makes a double etc.</p><h3 id="floating-point-literals"><a href="#floating-point-literals" class="headerlink" title="floating point literals"></a>floating point literals</h3><p>Recall that all AARCH64 instructions are 4 bytes long. Recall also that this means that there are constraints on what can be specified as a literal since the literal must be encoded into the 4 byte instruction. If the literal is too large, an assembler error will result.</p><p>Given that floating point values are always at least 4 bytes long themselves, using floating point literals is extremely constrained. For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmov    d0, 1     // 1</span><br><span class="line">fmov    d0, 1.1   // 2</span><br></pre></td></tr></table></figure><p>Line 1 will pass muster but Line 2 will cause an error.</p><p>To load a float, you could translate the value to binary and do as the following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        .global main</span><br><span class="line">        .align    2</span><br><span class="line"></span><br><span class="line">main:   str        x30, [sp, -16]!</span><br><span class="line">        ldr        s0, =0x3fc00000</span><br><span class="line">        fcvt       d0, s0</span><br><span class="line">        ldr        x0, =fmt</span><br><span class="line">        bl         printf</span><br><span class="line">        ldr        x30, [sp], 16</span><br><span class="line">        mov        w0, wzr</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">fmt:    .asciz    &quot;%f\n&quot;</span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><blockquote><p>printf() only knows how to print double precision values. When you specify a float, it will convert it to a double before emitting it.</p></blockquote><p>Translating floats and doubles by hand isn’t a common practice for humans, though compilers are happy to do so.</p><p>Instead for us humans, the assembler directives .float and .double are used more frequently to specify float and double values putting them into RAM.<br>a example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        .global main</span><br><span class="line">        .text</span><br><span class="line">        .align  2</span><br><span class="line"></span><br><span class="line">counter .req    x20</span><br><span class="line">dptr    .req    x21</span><br><span class="line">fptr    .req    x22</span><br><span class="line">        .equ    max, 4</span><br><span class="line"></span><br><span class="line">main:   stp     counter, x30, [sp, -16]!</span><br><span class="line">        stp     dptr, fptr, [sp, -16]!</span><br><span class="line">        ldr     dptr, =d</span><br><span class="line">        ldr     fptr, =f</span><br><span class="line">        mov     counter, xzr</span><br><span class="line"></span><br><span class="line">1:      cmp     counter, max</span><br><span class="line">        beq     2f</span><br><span class="line"></span><br><span class="line">        ldr     d0, [dptr, counter, lsl 3]</span><br><span class="line">        ldr     s1, [fptr, counter, lsl 2]</span><br><span class="line">        fcvt    d1, s1</span><br><span class="line">        ldr     x0, =fmt</span><br><span class="line">        add     counter, counter, 1</span><br><span class="line">        mov     x1, counter</span><br><span class="line">        bl      printf</span><br><span class="line">        b       1b</span><br><span class="line"></span><br><span class="line">2:      ldp     dptr, fptr, [sp], 16</span><br><span class="line">        ldp     counter, x30, [sp], 16</span><br><span class="line">        mov     w0, wzr</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">fmt:    .asciz  &quot;%d %f %f\n&quot;</span><br><span class="line">d:      .double 1.111111, 2.222222, 3.333333, 4.444444</span><br><span class="line">f:      .float  1.111111, 2.222222, 3.333333, 4.444444</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>指令</th><th>全称/缩写</th><th>作用</th><th>常见用法示例</th></tr></thead><tbody><tr><td><code>.req</code></td><td><strong>register require</strong>（非官方缩写）</td><td>给<strong>寄存器起别名</strong></td><td><code>foo .req x0</code> 表示以后写 <code>foo</code> 就等于 <code>x0</code></td></tr><tr><td><code>.equ</code></td><td><strong>equate</strong></td><td>定义一个<strong>常量符号</strong></td><td><code>BUF_SIZE .equ 64</code> 表示 <code>BUF_SIZE = 64</code></td></tr></tbody></table></div><p>On Linux, just as w/x0 through w/x7 are scratch registers and used to pass parameters, s/d0 and s/d7 are as well beginning with the 0 register.</p><p>即：</p><p>📥 整数参数传递：<br>x0 ~ x7（或 32 位的 w0 ~ w7）用于传递前 8 个整数类参数（int、pointer、long 等）。</p><p>超过 8 个就通过栈传递。</p><p>📥 浮点参数传递：<br>d0 ~ d7（64 位 double 类型）或 s0 ~ s7（32 位 float 类型）用于传递前 8 个浮点参数。</p><p>超过 8 个浮点参数也是通过栈传递。</p><h4 id="Fitting-32-bits-into-a-32-bit-bag"><a href="#Fitting-32-bits-into-a-32-bit-bag" class="headerlink" title="Fitting 32 bits into a 32 bit bag"></a>Fitting 32 bits into a 32 bit bag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr s0, =0x3fc00000  // 伪指令！我们以为它直接把 0x3fc00000 加载进 s0</span><br></pre></td></tr></table></figure><p>编译器不能直接把任意 32 位值硬编码进指令中（因为一条 ARM 指令本身就只有 32 位）。</p><p>所以它实际上是：</p><ol><li>将字面量值 0x3fc00000 写到内存的某个地方（通常靠近当前函数底部）。</li><li>生成一条 ldr 指令，用 PC-relative load 的方式从这个地址加载该值。<br>这块被称为一个 literal pool，它是一些常量的集合。</li></ol><p>We expected line 6 to read:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr        s0, =0x3fc00000</span><br></pre></td></tr></table></figure><p>Instead we find:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b+ 0x784 &lt;main+4&gt;          ldr     s0, 0x7a0 &lt;main+32&gt;</span><br></pre></td></tr></table></figure><p>Scan downward to find 0x7a0:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7a0 &lt;main+32&gt;         .inst   0x3fc00000 ; undefined</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>伪指令</th><th>实际效果</th><th>GDB 中看到的实际汇编</th></tr></thead><tbody><tr><td><code>ldr s0, =0x3fc00000</code></td><td>把常量加载进 <code>s0</code> 寄存器</td><td><code>ldr s0, #literal_addr</code><br><code>literal_addr: .inst 0x3fc00000</code></td></tr><tr><td><code>ldr x0, =fmt</code></td><td>加载字符串指针地址</td><td><code>ldr x0, #literal_addr</code><br><code>literal_addr: .inst 地址值</code></td></tr><tr><td><code>.inst 0x3fc00000</code></td><td>手动插入一个 32 位数据（不一定是有效指令）</td><td>存放常量（不是执行）</td></tr></tbody></table></div><p>.inst 的含义<br>全称：.inst = insert instruction<br>用途：直接插入一条 ARM 指令的机器码（通常是 32 位十六进制值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.inst 0xd65f03c0   // 实际是 ret 指令</span><br></pre></td></tr></table></figure><p>这个例子中，.inst 后的机器码 0xd65f03c0 是 ret 指令的 32 位编码。也就是说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.inst 0xd65f03c0</span><br></pre></td></tr></table></figure><p>在上面的例子中，可以用.inst 定义一个地址，从该地址中加载</p><p>为什么不用 mov reg, #imm ？</p><ul><li>mov 有立即数编码限制，不能加载任意 32 位值。</li><li>超过范围时，必须用 ldr 从内存加载。</li></ul><h3 id="fmov"><a href="#fmov" class="headerlink" title="fmov"></a>fmov</h3><blockquote><p>The fmov instruction is used to move floating point values in and out of floating point registers and to some degree, moving data between integer and floating point registers.</p></blockquote><p><strong>loading floating point numbers as immediate values</strong></p><p>Just as we saw with integer registers, some values can be used as immediate values and some cannot. It comes down to how many bits are necessary to encode the value. Too many bits… not enough room to fit in a 4 byte instruction plus the opcode.</p><p>For example, this works:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    x0, 65535</span><br></pre></td></tr></table></figure><p>but this does not:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    x0, 65537</span><br></pre></td></tr></table></figure><p>The constraints placed on immediate values for fmov are much tighter because floating point numbers are far more complex than integers.</p><p>fmov d0, #imm 能否工作，取决于该浮点数是否能在 8 位编码空间内被精确表示：</p><div class="table-container"><table><thead><tr><th>结构</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>符号位</td><td>1 bit</td><td>表示正或负</td></tr><tr><td>指数部分</td><td>3 bits</td><td>控制大小（乘以 2 的幂）</td></tr><tr><td>尾数部分</td><td>4 bits</td><td>仅能由 1/2、1/4、1/8、1/16 组合构成</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmov d0, 1.0        // ✅ OK：整数 1 是 2⁰，指数可编码</span><br><span class="line">fmov d0, 1.5        // ✅ OK：1 + 0.5 = 2⁰ + 2⁻¹，指数/尾数都能编码</span><br><span class="line">fmov d0, 1.75       // ✅ OK：1 + 0.5 + 0.25 = 2⁰ + 2⁻¹ + 2⁻²</span><br><span class="line">fmov d0, 1.875      // ✅ OK：+ 2⁻³</span><br><span class="line">fmov d0, 1.9375     // ✅ OK：+ 2⁻⁴</span><br><span class="line">fmov d0, 1.96875    // ❌ 不行：需要 2⁻⁵，尾数超出 4 位</span><br></pre></td></tr></table></figure><p>大浮点不能用 fmov，改用 ldr。</p><p>fmov 是“位复制器”，不是“精度转换器”。你要改数值精度，就必须用 fcvt 系列。</p><h3 id="half-precision"><a href="#half-precision" class="headerlink" title="half precision"></a>half precision</h3><blockquote><p>Support for half precision (16 bit) floating point values does exist but there is no complete agreement on how different compilers support them. Indeed, there are not one but two competing half precision formats out there. These are the IEEE and GOOGLE types. Further still, many open source developers have created their own implementations with potentially clashing naming conventions.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__fp16 <span class="title function_">Foo</span><span class="params">(__fp16 g, __fp16 f)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> g + f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compiles to:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fcvt    s1, h1</span><br><span class="line">fcvt    s0, h0</span><br><span class="line">fadd    s0, s0, s1</span><br><span class="line">fcvt    h0, s0</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>Notice each half precision value is converted to single precision. So, from C and C++ working with half precision values can be inefficient.</p><p>On the other hand, if you are willing to use intrinsics and one of the SIMD instruction sets offered by ARM, then knock yourself out. Be aware that doing so ties your code to the ARM processor in ways which you might regret later.</p><h3 id="bit-manipulation-1"><a href="#bit-manipulation-1" class="headerlink" title="bit manipulation"></a>bit manipulation</h3><p>Bit fields are a feature of the C and C++ language which completely hide what is often called “bit bashing”.</p><blockquote><p>the ordering of bits in a bit field is not guaranteed to be the same on different platforms and even between different compilers on the same platform.</p></blockquote><p>位域是一种用来在结构体内 精确控制成员所占二进制位数 的语法，通常用于硬件寄存器、协议头等空间敏感的场景。<br>语法格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    类型 成员名 : 位宽;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>example:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>a 用 1 位，能表示 0 或 1</li><li>b 用 2 位，能表示 0 ~ 3</li><li>c 用 5 位，能表示 0 ~ 31<br>三个成员总共占 1 + 2 + 5 = 8 位，即 1 字节</li></ul><ol><li>虽然每个成员是个位宽，但整体大小通常向整型对齐（这里是 1 字节，因为 8 位正好一字节）。</li><li>不同编译器对位域对齐和填充细节可能略有差异。</li><li>访问时可以像普通成员一样：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BF</span> <span class="title">bf</span>;</span></span><br><span class="line">bf.a = <span class="number">1</span>;</span><br><span class="line">bf.b = <span class="number">3</span>;</span><br><span class="line">bf.c = <span class="number">31</span>;</span><br></pre></td></tr></table></figure><p>编译器会自动对位域进行掩码和移位处理。</p><p>Consider a data structure for which there will be potentially millions of instances in RAM. Or, perhaps billions of instances on disc. Suppose you need 8 boolean members in every instance. The C++ standard does not define the size of a bool instead leaving it to be implementation dependent. Some implementations equate bool to int, four bytes in length. Some implement bool with a char, or 1 byte in length.</p><p>Let’s assume the smallest case and equate a bool with char. Our struct, for which there may be millions or billions of instances requires 8 bool so therefore 8 bytes. Times millions or billions.</p><p>Bit fields can come to your aid here by using a single bit per boolean value. In the best case, 8 bytes collapse to 1 byte. In a worse case, 8 x 4 = 32 bytes collapsed into 1.</p><p>假设使用最小单位，即每个 bool 是 1 字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> b0;</span><br><span class="line">    <span class="type">bool</span> b1;</span><br><span class="line">    <span class="type">bool</span> b2;</span><br><span class="line">    <span class="type">bool</span> b3;</span><br><span class="line">    <span class="type">bool</span> b4;</span><br><span class="line">    <span class="type">bool</span> b5;</span><br><span class="line">    <span class="type">bool</span> b6;</span><br><span class="line">    <span class="type">bool</span> b7;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体大小为 8 字节（1 字节 × 8 个 bool）。<br>如果有百万个实例，占用的内存就是 8MB，如果有十亿个实例，则是 8GB。<br>对于 4 字节的 bool 实现，则大小直接变成 32 字节，每亿实例就是 3.2GB。</p><p>解决方案：使用位域压缩布尔值<br>用位域，将 8 个布尔值定义为 1 位大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b0 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b3 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b4 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b5 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b6 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b7 : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>8 个 1-bit 成员 合起来正好占 1 字节。</p><p>这样 8 字节压缩成 1 字节，节省了大量空间。</p><p>In Computer Science there is an eternal tension between space and time. The following is a law:</p><p>If you want something to go faster, it will cost more memory.</p><p>If you want to save memory, what you’re doing will take more time.</p><p>This law shows up here… recall the example of where we wanted to save memory by collapsing 8 bool into 1 byte? To save that memory we will slow down because accessing the right bits takes a couple of instructions where overwriting a bool implemented as an int takes just one instruction.</p><p>As for the assembly language that bit field will produce, it depends upon optimization level. Unoptimized, the code produced will be much longer and cumbersome than the “sophisticated” assembly language.</p><h3 id="endian"><a href="#endian" class="headerlink" title="endian"></a>endian</h3><p>the ARM swing both ways: the litte-endian and the big-endian. But:</p><p>The standard toolchain emits little endian code. It is a big task to install the big-endian version of the toolchain.</p><p>Here is a quote from Wikipedia:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARM, C-Sky, <span class="keyword">and </span>RISC-V have no relevant <span class="keyword">big-endian </span>deployments, <span class="keyword">and </span>can <span class="keyword">be </span>considered little-endian in practice.</span><br></pre></td></tr></table></figure><p>The common Intel processors are also little-endian.</p><h2 id="assembly-macros"><a href="#assembly-macros" class="headerlink" title="assembly macros"></a>assembly macros</h2><p>An early innovation in assemblers was the introduction of a macro capability. Given what could be considered a certain amount of tedium in coding in asm, macros provide a simple form of meta programming where a series of statements can be encapsulated by a single macro. Think of a macro as an early form of C++ templated function (kinda but not really).</p><p>Here’s an example of an assembly language macro:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.macro LLD_ADDR xreg, label</span><br><span class="line">        adrp    \xreg, \label@PAGE</span><br><span class="line">        add     \xreg, \xreg, \label@PAGEOFF</span><br><span class="line">.endm</span><br><span class="line">```asm</span><br><span class="line">Here&#x27;s how it might be used:</span><br><span class="line">```asm</span><br><span class="line">        LLD_ADDR x0, fmt</span><br></pre></td></tr></table></figure><p>This gets expanded to:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> fmt<span class="title">@PAGE</span></span><br><span class="line"><span class="keyword">add</span>     <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> fmt<span class="title">@PAGEOFF</span></span><br></pre></td></tr></table></figure><p>gcc on Linux does not run assembly language files through the C pre-processor if the asm file ends in .s but WILL if the file ends in .S</p><h3 id="Genaral-Use"><a href="#Genaral-Use" class="headerlink" title="Genaral Use"></a>Genaral Use</h3><h4 id="AASCIZ"><a href="#AASCIZ" class="headerlink" title="AASCIZ"></a>AASCIZ</h4><p>AASCIZ label, string</p><p>This macro invokes .asciz with the string set to string and the label set to label. In addition, this macro ensures that the string begins on a 4-byte-aligned boundary.</p><h4 id="PUSH-P-PUSH-R-POP-P-and-POP-R"><a href="#PUSH-P-PUSH-R-POP-P-and-POP-R" class="headerlink" title="PUSH_P, PUSH_R, POP_P and POP_R"></a>PUSH_P, PUSH_R, POP_P and POP_R</h4><p>These macros save some repetitive typing. For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_P  x29, x30</span><br></pre></td></tr></table></figure><p>resolves to:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stp     x29, x30, [sp, -16]!</span><br></pre></td></tr></table></figure><h4 id="START-PROC-and-END-PROC"><a href="#START-PROC-and-END-PROC" class="headerlink" title="START_PROC and END_PROC"></a>START_PROC and END_PROC</h4><p>Place START_PROC after the label introducing a function.</p><p>Place END_PROC after the last ret of the function.</p><p>These resolve to: .cfi_startproc and .cfi_endproc respectively.</p><h4 id="MIN-and-MAX"><a href="#MIN-and-MAX" class="headerlink" title="MIN and MAX"></a>MIN and MAX</h4><p>Handy more readable macros for determining minima and maxima. Note that the macro performs a cmp which subtracts src_b from src_a (discarding the results) in order to set the flags to be interpreted by the following csel.</p><p>Signature:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIN     src_a, src_b, dest</span><br></pre></td></tr></table></figure><p>The smaller of src_a and src_b is put into dest.</p><p>Signature:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX     src_a, src_b, dest</span><br></pre></td></tr></table></figure><p>The larger of src_a and src_b is put into dest.</p><h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p>MOD macro used above is defined as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.macro  MOD         src_a, src_b, dest, scratch</span><br><span class="line">        sdiv        \scratch, \src_a, \src_b</span><br><span class="line">        msub        \dest, \scratch, \src_b, \src_a</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure><h4 id="GLABEL"><a href="#GLABEL" class="headerlink" title="GLABEL"></a>GLABEL</h4><p>Mark a label as global, Makes a label available externally.</p><p>Signature:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLABEL label</span><br></pre></td></tr></table></figure><p>An underscore is prepended.</p><h4 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h4><p>Calling CRT(C runtime) functions<br>If you create your own function without an underscore, just call it as usual.<br>If you need to call a function such as those found in the C runtime library, use this macro in this way:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRT     strlen</span><br></pre></td></tr></table></figure><h4 id="MAIN"><a href="#MAIN" class="headerlink" title="MAIN"></a>MAIN</h4><p>Declaring main()<br>Put MAIN on a line by itself. Notice there is no colon.</p><h4 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h4><p>The externally defined errno is accessed via a CRT function which isn’t seen when coding in C and C++. The function is named differently on Mac versus Linux. To get the address of errno use:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRNO_ADDR</span><br></pre></td></tr></table></figure><p>This macro makes the correct CRT call and leaves the address of errno in x0.</p><h3 id="Loads-and-Stores"><a href="#Loads-and-Stores" class="headerlink" title="Loads and Stores"></a>Loads and Stores</h3><h4 id="GLD-PTR"><a href="#GLD-PTR" class="headerlink" title="GLD_PTR"></a>GLD_PTR</h4><p>Loads the address of a label and then dereferences it where, on Apple the label is in the global space and on Linux is a relatively close label.</p><p>Signature:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLD_PTR     xreg, label</span><br></pre></td></tr></table></figure><p>When this macro finishes, the specified x register contains what 64 bit value lives at the specified label.</p><h4 id="GLD-ADDR"><a href="#GLD-ADDR" class="headerlink" title="GLD_ADDR"></a>GLD_ADDR</h4><p>Loads the address of the label into the specified x register. No dereferencing takes place. On Apple machines, the label will be found in the global space.</p><p>Signature:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLD_ADDR    xreg, label</span><br></pre></td></tr></table></figure><p>When this macro completes, the address of the label is in the x register.</p><h4 id="LLD-ADDR"><a href="#LLD-ADDR" class="headerlink" title="LLD_ADDR"></a>LLD_ADDR</h4><p>Similar to GLD_ADDR this macro loads the address of a “local” label.</p><p>Signature:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_ADDR xreg, label</span><br></pre></td></tr></table></figure><p>When this macro completes, the address of the label is in the x register.</p><h4 id="LLD-DBL"><a href="#LLD-DBL" class="headerlink" title="LLD_DBL"></a>LLD_DBL</h4><p>Signature:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_DBL xreg, dreg, label</span><br></pre></td></tr></table></figure><p>When this macro completes, a double that lives at the specified local label will sit in the specified double register.</p><h4 id="LLD-FLT"><a href="#LLD-FLT" class="headerlink" title="LLD_FLT"></a>LLD_FLT</h4><p>Signature:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_FLT xreg, sreg, label</span><br></pre></td></tr></table></figure><p>When this macro completes, a float that lives at the specified local label will sit in the specified single precision register.</p><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><h3 id="Undoing-Stack-Pointer-Changes"><a href="#Undoing-Stack-Pointer-Changes" class="headerlink" title="Undoing Stack Pointer Changes"></a>Undoing Stack Pointer Changes</h3><p>A small tip concerning undoing changes to the stack pointer. You might think that changes to the stack made by str or stp and their cousins must be undone with ldr or ldp and their cousins.</p><p>This depends.</p><p>If you need to get back the original contents of a register pushed onto the stack, then an ldr or ldp is appropriate. However, if you don’t need to get the original contents of a register back, then it is faster to undo a change to the stack using addition.</p><p>Take for example the use of printf(). On Apple Silicon systems, you must send arguments to printf() by pushing them onto the stack. However, when printf() completes, you have no need for the values that you pushed. As shown above, simply add the right (multiple of 16) to the stack pointer. This is faster as the addition makes no reference to RAM (or caches) as the ldr would.</p><h3 id="other-stuff"><a href="#other-stuff" class="headerlink" title="other stuff"></a>other stuff</h3><h4 id="let-the-assembler-itself-calculate-the-length-for-you"><a href="#let-the-assembler-itself-calculate-the-length-for-you" class="headerlink" title="let the assembler itself calculate the length for you"></a>let the assembler itself calculate the length for you</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">        .global        main</span><br><span class="line">        .align         2</span><br><span class="line">        .text</span><br><span class="line"></span><br><span class="line">main:   str            x30, [sp, -16]!</span><br><span class="line">        mov            w0, 1             // stdout</span><br><span class="line">        ldr            x1, =s            // pointer to string</span><br><span class="line">        ldr            x2, =ssize        // pointer to computed length</span><br><span class="line">        ldr            w2, [x2]          // actual length of string</span><br><span class="line">        bl             write</span><br><span class="line"></span><br><span class="line">        ldr            x0, =fmt</span><br><span class="line">        ldr            x1, =s</span><br><span class="line">        ldr            x2, =ssize</span><br><span class="line">        ldr            w2, [x2]</span><br><span class="line">        bl             printf</span><br><span class="line"></span><br><span class="line">        ldr            x30, [sp], 16</span><br><span class="line">        mov            w0, wzr</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line"></span><br><span class="line">s:      .asciz         &quot;Hello, World!\n&quot;</span><br><span class="line">ssize:  .word          ssize - s - 1        // accounts for null at end</span><br><span class="line">fmt:    .asciz         &quot;str: %slen: %d\n&quot;   // accounts for newline</span><br><span class="line"></span><br><span class="line">        .end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="atomic-operations"><a href="#atomic-operations" class="headerlink" title="atomic operations"></a>atomic operations</h2><h3 id="Load-Linked-Store-Condition"><a href="#Load-Linked-Store-Condition" class="headerlink" title="Load Linked, Store Condition"></a>Load Linked, Store Condition</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        .p2align    2</span><br><span class="line"></span><br><span class="line">#if defined(__APPLE__)</span><br><span class="line">        .global     _LoadLinkedStoreConditional</span><br><span class="line">_LoadLinkedStoreConditional:</span><br><span class="line">#else</span><br><span class="line">        .global     LoadLinkedStoreConditional</span><br><span class="line">LoadLinkedStoreConditional:</span><br><span class="line">#endif</span><br><span class="line">1:      ldaxr       w1, [x0]</span><br><span class="line">        add         w1, w1, 1</span><br><span class="line">        stlxr       w2, w1, [x0]</span><br><span class="line">        cbnz        w2, 1b</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>LL/SC 是一种乐观并发控制机制。它大致逻辑是：</p><ul><li><p>Load-Linked（LDAXR）：加载一个地址的值，并“观察”该地址是否被改动。<br>你可以修改这个值（如加 1）。</p></li><li><p>Store-Conditional（STLXR）：尝试写回这个新值，如果在这之间地址内容没有被别人改过，则写入成功；否则失败。<br>成功与否会通过 STLXR 的返回值告诉你（0 表示成功，非 0 表示失败）。</p></li></ul><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/llsc.png" alt="llsc"></p><p>Implementations of operations on atomic variables were improved in the second version of ARMv8, called ARMv8.1. The load linked and store conditional instructions are still available but several new instructions were added which perform certain operations such as addition, subtraction and various bitwise operations in a single atomic instruction.</p><p>For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    mov       w1, 1</span><br><span class="line">    ldaddal   w1, w0, [x0]</span><br><span class="line">``</span><br><span class="line">does the same work of atomically adding one to the value in memory pointed to by x0.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### spin-lock</span><br><span class="line"></span><br><span class="line">Here is the source code to the spin-lock for ARM V8.</span><br><span class="line"></span><br><span class="line">Lock</span><br><span class="line"></span><br><span class="line">```asm</span><br><span class="line">Lock:</span><br><span class="line">        START_PROC</span><br><span class="line">        mov         w3, 1           // 准备存储的值：1 表示“加锁”</span><br><span class="line">1:      ldaxr       w1, [x0]        // 原子加载并标记 exclusive 访问</span><br><span class="line">        cbnz        w1, 1b          // 如果锁不为 0（被别人持有），继续自旋</span><br><span class="line">        stlxr       w2, w3, [x0]    // 尝试原子写入，成功则 w2=0</span><br><span class="line">        cbnz        w2, 1b          // 如果失败（有竞争），继续自旋</span><br><span class="line">        ret</span><br><span class="line">        END_PROC</span><br></pre></td></tr></table></figure><p>stlxr: 如果 exclusive tag 还有效（没人抢走锁），那么将 w3 的值写入 *x0，并将结果放入 w2（0 表示成功）</p><ol><li>ldaxr dereferencing the lock itself (once again an int32_t) and marks the location of the lock as being hopefully, exclusive.</li><li>Having gotten the value of the lock, its value is inspected and if found to be non-zero, we branch back to attempting to get it again - this is the spin.</li><li>If the contents of the lock is 0, its value in w1 is changed to non-zero. Note, this could be made a bit better if a value of 1 was stored in another w register and simply used directly on line 10.</li><li><code>stlxr w2, w3, [x0]</code> conditionally stores the changed value back to the location of the lock. If the stlxr returns 0, we got the lock. If not, we start over - somebody else got in there ahead of us. Perhaps this happened because we were descheduled. Perhaps we lost the lock to another thread running on a different core.</li></ol><p>unlock</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unlock:</span><br><span class="line">        START_PROC</span><br><span class="line">        str         wzr, [x0]       // 写 0 表示释放锁</span><br><span class="line">        dmb         ish             // 内存屏障，跨核同步</span><br><span class="line">        ret</span><br><span class="line">        END_PROC</span><br></pre></td></tr></table></figure><ol><li><p>All it does is set to value of the lock to zero. The correct operation of the lock requires that no bad actor simply stomps on the lock by calling Unlock without first owning the lock. Just say no to lock stompers.</p></li><li><p><code>dmb ish</code> sets up a data memory barrier across each processor - it makes sure threads running on different cores see the update correctly. This code seemed to work without this line but intuition suggests it could be important. In Lock() the stlxr instruction has an implied data memory barrier.</p></li></ol><p>总结（伪代码角度）<br>🔒 Lock(x0):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    w1 = *x0;      <span class="comment">// atomic exclusive load</span></span><br><span class="line">    <span class="keyword">if</span> (w1 != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    result = atomic_store_exclusive(x0, <span class="number">1</span>);  <span class="comment">// try to set lock</span></span><br><span class="line">&#125; <span class="keyword">while</span> (result != <span class="number">0</span>);  <span class="comment">// someone else beat us</span></span><br></pre></td></tr></table></figure><p>🔓 Unlock(x0):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*x0 = <span class="number">0</span>;       <span class="comment">// unlock</span></span><br><span class="line">dmb(ISH);      <span class="comment">// ensure all cores see the update</span></span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/pkivolowitz/asm_book">asm_book</a></div>]]></content>
      
      
      <categories>
          
          <category> arm64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SR-IOV原理与实现</title>
      <link href="/posts/42860/"/>
      <url>/posts/42860/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-05-22</p></div></div><div class='timeline-item-content'><ol><li>init</li></ol></div></div></div><hr><h1 id="I-O-虚拟化（IOV）"><a href="#I-O-虚拟化（IOV）" class="headerlink" title="I/O 虚拟化（IOV）"></a>I/O 虚拟化（IOV）</h1><p><strong>I/O 虚拟化（IOV）</strong> 是指多个虚拟机之间共享单一的 I/O 资源。实现 IOV 的方法包括：</p><ul><li><strong>纯软件实现</strong>的共享方式，</li><li><strong>硬件支持</strong>的共享方式，</li><li>以及 <strong>软硬结合的混合方式</strong>。</li></ul><h2 id="基于纯软件实现的共享"><a href="#基于纯软件实现的共享" class="headerlink" title="基于纯软件实现的共享"></a>基于纯软件实现的共享</h2><ol><li><strong>device emulation（完全虚拟化）</strong>：<br> 设备仿真模式会模仿那些被广泛支持的真实硬件设备（例如 Intel 的 1Gb 网卡），从而使虚拟机中的操作系统可以继续使用它原本就支持的驱动程序。虚拟机管理程序（VMM，Virtual Machine Monitor）会模拟这个 I/O 设备，以确保兼容性，并在实际 I/O 操作前处理这些操作，然后再把它们转发给实际的物理设备（这个物理设备可能和模拟的设备不一样）。<br> ⚠️ 问题：这样一来，I/O 操作就必须经过两层 I/O 栈——一层在虚拟机内部，另一层在虚拟机管理程序中，这会增加开销，降低性能。</li><li><strong>the split-driver model（半虚拟化）</strong>：<br> 这种方法和设备仿真类似，但它<strong>不再模拟一个传统设备</strong>。而是采用一种<strong>前后端驱动配合的方式</strong>：<ul><li>前端驱动运行在虚拟机的客户操作系统中；</li><li>后端驱动运行在虚拟机管理程序中。<br> 两者配合工作，专门为资源共享进行了优化。相比设备仿真，这种方法的优势在于：<strong>不需要模拟整个设备</strong>，从而性能更好、开销更小。后端驱动会直接与实际物理设备进行通信。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>device emulation</td><td>兼容性好，可使用现有驱动</td><td>性能较差，要经过两层 I/O 栈</td></tr><tr><td>the split-driver model</td><td>性能更好，优化了共享</td><td>需要专门为前后端编写驱动</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522224910146.png" alt="image-20250522224910146"></p><p><strong>基于软件的共享的缺点</strong></p><p>无论是<strong>设备仿真</strong>还是<strong>分离驱动（即半虚拟化驱动）</strong>，它们通常只能提供物理硬件功能的一部分，因此可能<strong>无法利用物理设备提供的高级功能</strong>。</p><p>此外，虚拟机管理程序（VMM）在实现一个虚拟的软件交换机（用于将数据包在多个虚拟机之间转发）时，可能会消耗<strong>大量的 CPU 资源</strong>。这种 CPU 开销会（而且通常确实会）<strong>降低 I/O 设备的最大吞吐量</strong>。</p><p>举个例子：如果只使用设备仿真方式，10Gbps 的以太网控制器<strong>最大只能达到 4.5 到 6.5Gbps 的吞吐量</strong>（这个范围依赖于具体测试服务器的架构）。<br>其中一个主要原因是：<strong>每个数据包都必须通过软件交换机</strong>，而这就需要使用 CPU 来处理这些数据包，造成性能瓶颈，无法达到线速（Line Rate）或接近线速的传输能力。</p><p>基于软件的 I/O 虚拟化方式虽然兼容性好，但也存在一些明显的<strong>性能瓶颈和功能限制</strong>，这些缺陷在对性能要求较高的场景（如高频交易、数据中心、网络功能虚拟化等）中尤其明显：</p><div class="table-container"><table><thead><tr><th>缺点</th><th>说明</th></tr></thead><tbody><tr><td>功能不完整</td><td>无法访问设备的全部高级特性，如硬件加速、QoS、SR-IOV等。</td></tr><tr><td>高 CPU 开销</td><td>每个 I/O 操作都需要 VMM 介入处理，特别是在网络场景下，包处理要通过软件交换机，会消耗大量 CPU。</td></tr><tr><td>吞吐量受限</td><td>理论 10Gbps 的网卡实际只有 4.5~6.5Gbps 的吞吐，远低于线速。</td></tr></tbody></table></div><h2 id="直接分配（Direct-Assignment）"><a href="#直接分配（Direct-Assignment）" class="headerlink" title="直接分配（Direct Assignment）"></a>直接分配（Direct Assignment）</h2><p>也称<strong>设备直通</strong></p><p>基于软件的共享方式在每次 I/O 操作中都增加了额外开销，因为在客户机驱动和 I/O 硬件之间存在一个<strong>仿真层</strong>。这种中间层的存在还带来了另一个影响：<strong>无法使用物理设备提供的硬件加速功能</strong>。<br> 为了解决这些问题，可以将物理硬件<strong>直接暴露给客户操作系统（Guest OS）</strong>，并让它运行<strong>原生设备驱动</strong>，从而减少中间层带来的性能损失。</p><p>硬件厂商（如Intel）为此引入了一些增强功能，用于<strong>支持内存地址转换</strong>并<strong>确保内存保护</strong>，使得设备能够<strong>直接进行主机内存的 DMA 操作</strong>。这些增强功能可以<strong>绕过虚拟机管理程序（VMM）的 I/O 仿真层</strong>，从而<strong>提升虚拟机的 I/O 吞吐性能</strong>。</p><p>Intel® VT-x 技术的一个特性是：如果由 VMM 进行配置，虚拟机可以<strong>直接访问物理地址</strong>。这样，虚拟机中的设备驱动就可以<strong>直接写入 I/O 设备的寄存器</strong>（例如配置 DMA 描述符等）。</p><p>而 Intel® VT-d 技术则提供了类似的能力，使 I/O 设备可以<strong>直接写入虚拟机的内存空间</strong>，例如进行 DMA 操作。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522230514903.png" alt="image-20250522230514903"></p><p>实现直接分配的机制<strong>在不同厂商之间有所差异</strong>，但其基本思路相同：虚拟机管理程序利用并配置诸如 Intel® VT-x 和 VT-d 这类技术，在数据收发过程中完成地址转换，确保数据可以安全、高效地在虚拟机与 I/O 设备之间传输。</p><p>✅ 优势：</p><ul><li><strong>绕过中间的仿真层</strong>，减少 CPU 开销；</li><li><strong>支持原生驱动</strong>，可以启用设备的全部功能（包括硬件加速）；</li><li><strong>大幅提升性能</strong>，尤其是吞吐量和延迟方面的改进明显；</li><li><strong>适合高性能场景</strong>，如网络功能虚拟化（NFV）、GPU 加速计算等。</li></ul><p>⚠️ 问题：</p><p>直接分配的一个主要问题是其<strong>可扩展性有限</strong>：一个物理设备<strong>只能分配给一个虚拟机</strong>。</p><blockquote><p>例如，一个双端口的网卡（NIC）只能同时提供给两个虚拟机使用（每个虚拟机占用一个端口）。然而，系统中可插入的 I/O 设备数量存在<strong>根本性的限制</strong>。</p></blockquote><p>设想一下不久将来的一个相对强大的服务器：<br> 它可能拥有 4 个物理 CPU，每个 CPU 有 12 个核心，总共有 48 个核心。按照“一核一虚拟机”的经验规则，这台服务器可能运行 <strong>48 个虚拟机</strong>。如果你希望为每个虚拟机都使用 Direct Assignment 的方式分配设备，就<strong>需要 48 个物理端口</strong>。</p><h1 id="单根-I-O-虚拟化（SR-IOV）"><a href="#单根-I-O-虚拟化（SR-IOV）" class="headerlink" title="单根 I/O 虚拟化（SR-IOV）"></a>单根 I/O 虚拟化（SR-IOV）</h1><blockquote><p>以上架构问题根源在于硬件底层原生不支持共享，需要一种新型的<strong>原生可共享设备</strong>（<strong>Navitely Shared Devices</strong>），这些设要能为每个虚拟机复制必要的资源，使得<strong>虚拟机可以直接连接到 I/O 设备</strong>，并且<strong>无需 VMM 参与</strong>即可完成主要的数据传输。</p></blockquote><p><strong>原生可共享设备</strong>通常会为每个虚拟接口提供<strong>独立的内存空间、工作队列、中断和命令处理机制</strong>，而在主机接口之后共享一些<strong>公共资源</strong>。这些共享资源仍然需要管理，通常会将一组管理寄存器暴露给 VMM 中的<strong>可信分区（Trusted Partition）</strong>，为每个虚拟机提供独立的工作队列和命令处理能力，这类设备能够<strong>同时接收多个来源的指令</strong>，并在发送给二级互连（如 Ethernet 或 SAS 链路）之前将其整合，而不再需要虚拟化软件将多个 I/O 请求串行化处理。</p><p>这种原生可共享设备可以通过多种方式实现，既有标准化的，也有专有的。由于大多数这类设备是通过 PCI 接口访问的，PCI-SIG（PCI Special Interest Group）决定制定一个标准机制来支持这一功能。</p><p>这个标准就是：<strong>PCI-SIG 单根 I/O 虚拟化和共享规范（SR-IOV，Single Root I/O Virtualization）</strong></p><p>SR-IOV 定义了一个标准机制，使设备能实现原生共享。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522231842281.png" alt="image-20250522231842281"></p><h2 id="PCI-SIG-SR-IOV-规范"><a href="#PCI-SIG-SR-IOV-规范" class="headerlink" title="PCI-SIG SR-IOV 规范"></a>PCI-SIG SR-IOV 规范</h2><p>PCI-SIG SR-IOV规范的目标可以总结为一句话：<strong>规范化一种绕过虚拟机管理程序（VMM）参与数据传输的方式</strong>，通过为每台虚拟机提供<strong>独立的内存空间、中断通道和 DMA 通道</strong>，以实现高效的 I/O 虚拟化。</p><p>SR-IOV 的体系结构设计允许一个设备支持多个<strong>虚拟功能（VF, Virtual Functions）</strong>，并在此过程中重点关注每个额外功能的硬件成本最小化。</p><p>SR-IOV 引入了两种新的 PCIe 功能类型：</p><ul><li><p><strong>物理功能（PF, Physical Functions）</strong>：<br> 完整的 PCIe 功能，包含 <strong>SR-IOV 扩展能力（Extended Capability）</strong>。该能力用于配置和管理 SR-IOV 的相关功能。</p></li><li><p><strong>虚拟功能（VF, Virtual Functions）</strong>：<br> 轻量级 PCIe 功能，包含完成数据传输所需的资源，但其<strong>配置资源经过精简设计</strong>，以降低硬件开销。</p></li></ul><p><strong>SR-IOV</strong> 提供了一种机制，使得一个单一的物理功能（例如一个以太网端口）<strong>可以表现为多个独立的“物理设备”</strong>。</p><p>一个支持 SR-IOV 的设备可以被配置（通常由 VMM 完成），使其在 <strong>PCI 配置空间</strong> 中<strong>呈现为多个功能（Function）</strong>，每个功能都拥有独立的 <strong>配置空间</strong>，包括自己的 <strong>基地址寄存器（BARs）</strong>。SR-IOV 设备可以配置为支持<strong>多个独立的虚拟功能（VF）</strong>，每个 VF 都有独立的 PCI 配置空间。VMM 会将这些 VF 分配给不同的虚拟机。</p><p>虚拟机管理程序（VMM）会将一个或多个虚拟功能（VF）分配给某个虚拟机，这个过程涉及将 VF 的真实配置空间<strong>映射为该 VM 所能看到的 PCI 配置空间</strong>。同时，诸如 Intel® VT-x 和 VT-d 之类的<strong>内存地址转换技术</strong>提供了<strong>硬件加速机制</strong>，可以使 DMA 数据直接在 VM 和设备之间传输，从而<strong>绕过 VMM 中的软件交换开销</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522233027661.png" alt="image-20250522233027661"></p><h2 id="生态系统依赖"><a href="#生态系统依赖" class="headerlink" title="生态系统依赖"></a>生态系统依赖</h2><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><ul><li>BIOS 在系统启动时负责分配 <strong>内存映射I/O（MMIO）空间</strong> 和 <strong>PCI Express总线号（Bus Numbers）</strong> 给主机桥（host bridges）。</li><li>许多系统中 PCI 资源分配缺乏标准化，软件依赖 BIOS 配置设备，确保有足够的内存空间和总线范围，支持主机桥下面的所有 I/O 设备。</li><li>需要增强 BIOS 的枚举代码，使其能识别 <strong>SR-IOV设备</strong>，并分配足够的 MMIO 空间给所有虚拟功能（Virtual Functions，VFs）。</li><li>具体如何解析 PCI 配置空间并计算 VF 所需最大 MMIO 空间，详见 PCI-SIG SR-IOV 规范。</li></ul><h3 id="虚拟机监控器（VMM）"><a href="#虚拟机监控器（VMM）" class="headerlink" title="虚拟机监控器（VMM）"></a>虚拟机监控器（VMM）</h3><ul><li>SR-IOV 定义了两种函数类型：<ul><li><strong>PF</strong>：完整的 PCIe 功能，包含 SR-IOV 扩展能力，用于管理和配置虚拟功能。</li><li><strong>VFs</strong>：轻量级的 PCIe 功能，包含仅用于数据传输的最小配置资源。</li></ul></li><li>SR-IOV 引入了一个新的软件实体：<strong>单根 PCI 配置管理器（Single Root PCI Configuration Manager, SR-PCIM 或 PCIM）</strong>。<ul><li>PCIM 负责管理和配置 VFs，处理所有对配置空间的访问请求。</li><li>它基于物理函数的信息，向虚拟机中的客户操作系统呈现完整的 PCI 配置模型。</li><li>PCIM 是一个概念模型，具体实现由各 VMM 厂商负责集成。</li></ul></li><li>Linux 内核自 2.6.30 版本（2009 年 6 月）开始支持 SR-IOV，多个发行版均已集成。</li></ul><h4 id="虚拟功能（VF）创建"><a href="#虚拟功能（VF）创建" class="headerlink" title="虚拟功能（VF）创建"></a>虚拟功能（VF）创建</h4><ul><li>在设备上电后，VFs 默认不存在，也无法访问其配置空间。</li><li>VFs 必须通过物理函数上的 SR-IOV 功能配置和启用后才能访问。</li><li>物理函数的 PCI 配置空间内有 SR-IOV 能力结构，其中包含一个 <strong>系统页大小字段（System Page Size）</strong>，由 VMM 设定为平台支持的大小。</li><li>所有 VF 的内存空间被连续映射在由 VF 基址寄存器（VF Base Address Register）指定的内存范围内。</li><li>为确保内存空间隔离，VF 的内存资源必须对齐到系统提供的页保护边界。</li><li>ARI（替代路由 ID 解释）能力标志会影响最大 VF 数量的分布，VMM 应启用根端口和交换机上的 ARI，并在 SR-IOV 能力中设置 ARI 能力层级位。BIOS 可能已预先启用 ARI。</li></ul><h4 id="VF-发现"><a href="#VF-发现" class="headerlink" title="VF 发现"></a>VF 发现</h4><ul><li>设置 VF 启用字段后，VFs 被创建并响应配置事务。</li><li>旧有的枚举软件不会自动发现这些 VF。</li><li>SR-IOV 引入一种新机制：通过物理函数中的 <strong>First VF Offset</strong> 和 <strong>VF Stride</strong> 字段形成链表，软件可定位与该物理函数关联的所有 VF。</li><li>SR-IOV 设备可能要求软件分配多个 PCI 总线号以支持超过 256 个功能。</li></ul><h4 id="VF-驱动与物理函数驱动通信支持"><a href="#VF-驱动与物理函数驱动通信支持" class="headerlink" title="VF 驱动与物理函数驱动通信支持"></a>VF 驱动与物理函数驱动通信支持</h4><ul><li>VMM 可以支持创建共享内存页，促进虚拟机中的 VF 驱动与主驱动（Master Driver）之间的通信（详细内容在第 6 节）。</li></ul><h4 id="VF-分配给虚拟机"><a href="#VF-分配给虚拟机" class="headerlink" title="VF 分配给虚拟机"></a>VF 分配给虚拟机</h4><ul><li>VFs 创建配置后，可被分配给虚拟机，实现虚拟机与硬件设备的直接 I/O 交互。</li><li>SR-IOV 设计假定设备上的所有 VF 是相同的，PCI 配置中均呈现相同的功能。</li><li>但通过主驱动介入分配，硬件可以根据系统管理员需求，提供不同的功能特性或性能等级（例如，为某些 VF 提供 2Gbps 的以太网性能保证）。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>BIOS 需要支持 SR-IOV 设备的识别和资源分配，尤其是 MMIO 和总线号管理。</li><li>VMM 引入 PCIM 模型管理 VFs，负责配置访问透明化和虚拟化资源管理。</li><li>VF 需要显式创建和启用，且支持大规模虚拟化场景（成百上千 VF）。</li><li>SR-IOV 支持高性能、低延迟的 I/O 直通，同时具备灵活的资源分配和管理能力。</li></ul><h2 id="主驱动程序（MD-Master-Driver）"><a href="#主驱动程序（MD-Master-Driver）" class="headerlink" title="主驱动程序（MD, Master Driver）"></a>主驱动程序（MD, Master Driver）</h2><p>主驱动（Master Driver，简称 MD；也称为物理功能驱动 PFD 或 PF Driver）是一个专门的驱动程序，用于管理 SR-IOV 设备的全局功能，并负责配置共享资源。MD 是特定于虚拟机监控器（VMM）的，运行在比一般虚拟机驱动更高权限的环境中。它包含了传统驱动的全部功能，以便 VMM 访问 I/O 资源；同时它还能执行影响整个设备的操作。</p><p>MD 必须在一个持续存在的环境中运行，在任何虚拟机驱动加载之前加载，并在所有虚拟机驱动卸载之后才能卸载。所有会影响整个设备的操作只能被 MD 接收和处理。</p><p>为了实现这种控制能力，虚拟机中的 VF 驱动需要与 MD 通信。比如，以太网设备的链路状态变化或最大传输单元（MTU）改变，就需要这种通信机制。VF 驱动通过通信通道询问链路状态时，MD 可以返回任意状态。当物理设备的 MTU 发生改变时，MD 可通知所有 VF 驱动，以便网络栈作出相应调整。</p><h3 id="VF-Drivers"><a href="#VF-Drivers" class="headerlink" title="VF Drivers"></a>VF Drivers</h3><p>VF 是“轻量级”的 PCIe 功能，只包含执行数据传输所必需的资源，它并不是一个完整的 PCIe 设备，仅提供数据进出机制。</p><p>VF 驱动运行于虚拟机中，应为半虚拟化驱动（即意识到它在虚拟化环境中），只能执行其允许的操作。通常，VF 具备发送/接收数据和执行自身复位的能力。该复位操作仅影响该 VF，而不会影响整个物理设备。超出其权限范围的操作需通过与 MD 通信实现。</p><p>VF 驱动是一个专门化驱动，它“知道”自身只能执行特定的功能，如配置 DMA 描述符、设置 MAC 地址、VLAN 标签等。每个 VF 都有在 I/O 设备中分配的独立资源。以太网 VF 通常具备独立的发送/接收队列，绑定到对应的 BAR（基地址寄存器）及描述符。</p><h3 id="VF-驱动与主驱动的通信"><a href="#VF-驱动与主驱动的通信" class="headerlink" title="VF 驱动与主驱动的通信"></a>VF 驱动与主驱动的通信</h3><p>设备共享的关键在于 VF 驱动能够与 MD 通信，请求那些影响全局的操作。这个通信通道需要传递消息并能生成中断。</p><p>SR-IOV 并未定义这一通信机制，因此需由主驱动、物理功能驱动和 VMM 设计者共同构建。最简单的方式是使用 VF 专属的设备内邮箱（mailbox）和门铃（doorbell）机制（Intel SR-IOV 网络控制器支持该方式）。目前，各家 VMM 厂商正在实现各自的通信机制，尚未形成统一标准。</p><h3 id="workflow-示例"><a href="#workflow-示例" class="headerlink" title="workflow 示例"></a>workflow 示例</h3><p>以下是一个接收以太网数据包并通过 VF 转发到虚拟机的典型流程：</p><ol><li>数据包到达 Intel® 网卡。</li><li>包被送入由主驱动配置的二层分类器（Layer 2 sorter）。</li><li>分类后，数据包进入目标 VF 的接收队列。</li><li>启动 DMA 操作，其目标地址由 VF 驱动配置的描述符决定。</li><li>DMA 到达芯片组。VMM 配置的 Intel® VT-d 将虚拟地址映射为主机物理地址，完成 DMA。</li><li>NIC 发出中断，VMM 捕获。</li><li>VMM 发出虚拟中断通知 VM 数据到达</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522234850850.png" alt="image-20250522234850850"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><p>平台必须支持地址转换（如 Intel® VT-d），才能使设备将数据 DMA 直接写入 VM 的内存。</p></li><li><p>BIOS 和 VMM 需能解析 PCI 配置空间，尤其是 SR-IOV 的 VF 定位机制。</p></li><li><p>VMM、PF 驱动、VF 驱动三者必须配合，为 VM 提供完整的 PCI 空间映射和 VF 操作能力。</p></li></ul><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h3><h4 id="PCI（Perpheral-Component-Interconnect）"><a href="#PCI（Perpheral-Component-Interconnect）" class="headerlink" title="PCI（Perpheral Component Interconnect）"></a>PCI（Perpheral Component Interconnect）</h4><p>PCI曾经是个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽。目前该总线已经逐渐被PCI Express总线所取代。PCI总线是由ISA(Industy Standard Architecture)总线发展而来的，是一种同步的独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPU的供应商和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传送。</p><p><strong>注：</strong>ISA并行总线有8位和16位两种模式，时钟频率为8MHz，工作频率为33MHz/66MHz。</p><p>PCI总线是一种树型结构，并且独立于CPU总线，可以和CPU总线并行操作。PCI总线上可以挂接PCI设备和PCI桥，PCI总线上只允许有一个PCI主设备（同一时刻），其他的均为PCI 从设备，而且读写操作只能在主从设备之间进行，从设备之间的数据交换需要通过主设备中转。</p><p><strong>注：</strong>这并不意味着所有的读写操作都需要通过北桥中转，因为PCI总线上的主设备和从设备属性是可以变化的。比如Ethernet和SCSI需要传输数据，可以通过一种叫做Peer-to-Peer的方式来完成，此时Ethernet或者SCSI则作为主机，其它的设备则为从机。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655222482740534418391.png" alt=""></p><p>一个典型的33MHz的PCI总线系统如上图所示，处理器通过<strong>FSB</strong>（<strong>Front Side Bus</strong>，前端总线，是早期计算机体系结构中，<strong>处理器（CPU）与北桥芯片之间通信的主要总线</strong>，用于连接 CPU 和内存控制器、显卡、PCI 总线等系统核心组件）与北桥相连接，北桥上挂载着图形加速器（显卡）、SDRAM（内存）和PCI总线。PCI总线上挂载着南桥、以太网、SCSI总线（一种老式的小型机总线）和若干个PCI插槽。CD和硬盘则通过IDE连接至南桥，音频设备以及打印机、鼠标和键盘等也连接至南桥，此外南桥还提供若干的USB接口。</p><p>PCI总线是一种共享总线，所以需要特定的<strong>仲裁器</strong>（<strong>Arbiter</strong>）来决定当前时刻的总线的控制权。一般该仲裁器位于北桥中，而仲裁器（主机）则通过一对引脚，<strong>REQ#</strong>（<strong>request</strong>） 和<strong>GNT#</strong> （<strong>grant</strong>）来与各个从机连接。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655215521250613180895.png" alt="image.png"></p><p>需要注意的是，并不是所有的设备都有能力成为仲裁器（Arbiter）或者initiator 。</p><p>最初的PCI总线的时钟频率为33MHz，但是随着版本的更新，时钟频率也逐渐的提高。但是由于PCI采用的是一种<strong>Reflected-Wave Signaling</strong>信号模型，导致了时钟频率越高，总线的最大负载越少。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655345775545777449405.png" alt="1000019445-6365655345775545777449405"></p><h3 id="Alternative-Routing-ID"><a href="#Alternative-Routing-ID" class="headerlink" title="Alternative Routing-ID"></a>Alternative Routing-ID</h3><h3 id="Address-Translation-Services（ATS）"><a href="#Address-Translation-Services（ATS）" class="headerlink" title="Address Translation Services（ATS）"></a>Address Translation Services（ATS）</h3><h4 id="Intel®-Virtualization-Technology-for-Directed-I-O-Intel®-VT-d"><a href="#Intel®-Virtualization-Technology-for-Directed-I-O-Intel®-VT-d" class="headerlink" title="Intel® Virtualization Technology for Directed I/O (Intel® VT-d)"></a>Intel® Virtualization Technology for Directed I/O (Intel® VT-d)</h4><h3 id="Access-Control-Services-ACS"><a href="#Access-Control-Services-ACS" class="headerlink" title="Access Control Services (ACS)"></a>Access Control Services (ACS)</h3>]]></content>
      
      
      <categories>
          
          <category> virtualization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RustDesk远程桌面自建服务器</title>
      <link href="/posts/42858/"/>
      <url>/posts/42858/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-14</p></div></div><div class='timeline-item-content'><p>  init</p></div></div></div><hr><p>ToDesk使用了几天后因为一直没关机，在当月中旬用完了所有额度，不让继续免费使用了，直接卸载告别切换到rustdesk，使用Self-host，免费而且帧率，分辨率都比ToDesk免费版高多了，下面是搭建的记录。</p><h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><p>我是使用两台windows(win10)和一台Ubuntu(配置如下图)，通过Ubuntu作为ID/中继服务器，让一台Windows连接到另一台Windows，Ubuntu需要安装Docker，两台windows需要安装rustdesk并进行一些配置。<br><div class="tip warning faa-horizontal animated"><p>注意：我的三台机器是在同一局域网下的。</p></div></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/pc_environment.png" alt="硬件环境"></p><h2 id="安装-Docker-和-docker-compose-plugin"><a href="#安装-Docker-和-docker-compose-plugin" class="headerlink" title="安装 Docker 和 docker-compose-plugin"></a>安装 Docker 和 docker-compose-plugin</h2><p>参考：<br>   <div class="tag link"><a class="link-card" title="Docker在Ubuntu安装" href="https://docs.docker.com/engine/install/ubuntu/"><div class="left"><img src="https://docs.docker.com/favicons/docs@2x.ico"/></div><div class="right"><p class="text">Docker在Ubuntu安装</p><p class="url">https://docs.docker.com/engine/install/ubuntu/</p></div></a></div><br>安装完成后，可以把当前用户加入到docker用户组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加docker用户组，一般已存在，不需要执行</span></span><br><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="comment"># 添加当前用户到docker用户组</span></span><br><span class="line"><span class="built_in">sudo</span> gpasswd -a <span class="variable">$USER</span> docker</span><br><span class="line"><span class="comment"># 更新用户组</span></span><br><span class="line">newgrp docker</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure></p><h2 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="headerlink" title="docker-compose.yaml"></a>docker-compose.yaml</h2><p>参考官方文档：<br>   <div class="tag link"><a class="link-card" title="RustDesk自建服务器" href="https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/docker/"><div class="left"><img src="https://rustdesk.com/docs/images/favicon.png"/></div><div class="right"><p class="text">RustDesk自建服务器</p><p class="url">https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/docker/</p></div></a></div></p><p>如果开启了ufw，需要打开这些端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw status</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 21114:21119/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 8000/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 21116/udp</span><br></pre></td></tr></table></figure><br>选一个目录用来存放ID/中继服务器数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/rustdesk</span><br><span class="line"><span class="built_in">cd</span> ~/rustdesk</span><br><span class="line"><span class="built_in">touch</span> docker-compose.yaml</span><br></pre></td></tr></table></figure><br>下面是docker-compose.yaml文件，是上面的rustdesk官方文档的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hbbs:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">hbbr:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><br>然后启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 进入~/rustdesk/data文件夹中</span></span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line"><span class="comment"># 查看key</span></span><br><span class="line"><span class="built_in">cat</span> id_*.pub</span><br></pre></td></tr></table></figure></p><h2 id="rustdesk安装配置"><a href="#rustdesk安装配置" class="headerlink" title="rustdesk安装配置"></a>rustdesk安装配置</h2><p>安装访问以下链接：<br><div class="tag link"><a class="link-card" title="RustDesk安装" href="https://github.com/rustdesk/rustdesk/releases"><div class="left"><img src="https://github.githubassets.com/favicons/favicon.png"/></div><div class="right"><p class="text">RustDesk安装</p><p class="url">https://github.com/rustdesk/rustdesk/releases</p></div></a></div><br>安装好后，打开网络设置，将ID/中继服务器的IP也就是跑Docker的那个服务器IP地址填写到ID服务器和中继服务器中，被控端可以不填写中继服务器，控制端建议填写，然后控制端填写key（上面data文件下的.pub文件的内容）。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250314214834213.png" alt="windows rustdesk网络配置"></p><p>最后输入被控端的ID和密码连接即可。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Data Lab</title>
      <link href="/posts/42856/"/>
      <url>/posts/42856/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-07</p></div></div><div class='timeline-item-content'><p>写到howManyBits</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-07</p></div></div><div class='timeline-item-content'><p>写完了，再一次感觉这个实验不错</p></div></div></div><hr><p>最近担任计算机系统助教要验收这个CSAPP的实验，这个实验本科的时候就做过，但过了这么久基本忘完了，遂重新做一遍记录于此。</p><h1 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h1><p>我是在win10 WSL2环境下做的：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250304165220672.png" alt="实验环境"></p><p>具体如何搭建环境参考下面这个链接，有脚本一键搭建运行环境，非常方便：<br><div class="tag link"><a class="link-card" title="CSAPP环境搭建" href="https://zhuanlan.zhihu.com/p/505497911"><div class="left"><img src="https://static.zhihu.com/heifetz/favicon.ico"/></div><div class="right"><p class="text">CSAPP环境搭建</p><p class="url">https://zhuanlan.zhihu.com/p/505497911</p></div></a></div></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在bits.c中完成函数实现，但对代码有一定的限制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测代码是否符合要求的规范</span></span><br><span class="line">./dlc bits.c</span><br><span class="line"><span class="comment"># 查看分数</span></span><br><span class="line">make clean </span><br><span class="line">make </span><br><span class="line">./btest</span><br></pre></td></tr></table></figure></p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要求只用~(按位取反)和&amp;(按位与)实现异或，可以使用离散数学中的等值演算，异或即“相同为0，不同为1”：</p><script type="math/tex; mode=display">x \oplus y = \lnot (\lnot x \land \lnot y) \land \lnot ( x \land y)</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ( ~(~x &amp; ~y)) &amp; (~(x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>返回最小的二进制补码整数，关于原码，反码，补码定义如下：</p><div class="table-container"><table><thead><tr><th>表示方法</th><th>定义</th></tr></thead><tbody><tr><td>原码</td><td>最高位为符号位（0 表示正数，1 表示负数），其余位表示数值的绝对值</td></tr><tr><td>反码</td><td>正数的反码与原码相同；负数的反码是符号位不变，其余位按位取反</td></tr><tr><td>补码</td><td>正数的补码与原码相同；负数的补码是其反码加 1</td></tr></tbody></table></div><p>补码的编码具有不对称性，除了最小的负数其他负数都其正数与之对应，在 64 位系统中，整数的补码表示范围是：</p><ul><li>最小负数：0x8000000000000000（即 -2^63）。</li><li>最大正数：0x7FFFFFFFFFFFFFFF（即 2^63 - 1）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果x是二进制补码最大值则返回1,否则返回0。</li><li>最大值是0x7FFFFFFF，它的特点是最高位为0其余为1，那么0x7FFFFFFF+0x1后变为0x800000000，最高位为1其余为0，其特点正好相反。</li><li>这里需要用到异或的特性，如x^target，x取反后与target异或，由于异或是不同为1相同为0，则只有当x与target完全相同时，x^target才会为0x0，那么加上!操作符就能得到!(x^target)即x与target相同时为1,不同时为0。<br>对于0x7FFFFFFF，它加1后为0x80000000，由于特点正好相反，取反后有变为0x7FFFFFFF,故可以利用异或判断是否相同即：!(~(x+1)^x) 。</li><li>继续思考，是不是只有0x7FFFFFFF才满足这样的特性：+1后相当于按位取反？显然0xFFFFFFFF也满足这个特性，这是因为溢出时最高位被丢弃变为0x0。所以我们还需要构造一个表达式与!(~(x+1)^x) 相与记为expression1，即!(~(x+1)^x) &amp; expression1。当x为0x7FFFFFFF时expression1为1，当x为0xFFFFFFFF时为0。</li><li>排除的方法必定需要利用0x7FFFFFFF有而0xFFFFFFFF没有的特点0，即这两个数的区别，而最简单的区别就是0x7FFFFFFF+0x1后变为0x8FFFFFFF是个非零数，而0xFFFFFFFF+0x1后变为0。故!(x+1)在x为0x7FFFFFFF时为0，在x为0xFFFFFFFF时为1，!(x+1)与需要的正好相反，再加上一个!运算即可，即：<p class='p center logo small'>!( ~(x + 1) ^ x) & !!(x + 1)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !( ~(x + <span class="number">1</span>) ^ x) &amp; !!(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果所有奇数位的比特位是1返回1，否则返回0，即一个数只要其1,3,5,7…位为1（其余位不用管）返回1，否则返回0。</li><li>我们可以去除所有的偶数位的影响，看奇数位，比如让x与0xAAAAAAAA相与，则所有的偶数位都为0，再看其是否和0xAAAAAAAA相同（利用isTmax中阐述的通过按位与判断两个数是否相同）。也可以让x与0x55555555相或，则所有的偶数位为1，再看其是否和0xFFFFFFFF相同。即：<p class='p center logo small'>!((x|0x55555555)^0xFFFFFFFF)</p><p class='p center logo small'>!((x&0xAAAAAAAA)^(0xAAAAAAAA))</p></li><li>但是由于实验要求的限制条件，不只直接写0xAAAAAAAA这种，只能写0xAA，通过位运算得到0xAAAAAAAA</li></ul><div class="tip warning faa-horizontal animated"><p>注意：根据C规范移位运算优先级低于加减</p></div><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250307163658185.png" alt="https://en.cppreference.com/w/c/language/operator_precedence"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// return !((x|0x55555555)^0xFFFFFFFF);</span></span><br><span class="line">  <span class="comment">// return !((x&amp;0xAAAAAAAA)^(0xAAAAAAAA));</span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>;<span class="comment">//0x00AA</span></span><br><span class="line">  <span class="type">int</span> b = a | <span class="number">0xAA</span>;<span class="comment">//0xAAAA</span></span><br><span class="line">  <span class="type">int</span> c = b&lt;&lt;<span class="number">16</span> | b;<span class="comment">//0xAAAAAAAA</span></span><br><span class="line">  <span class="keyword">return</span> !((x&amp;c)^c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>返回x的负数</li><li>我们知道：<p class='p center logo small'>x+(-x)=0</p><p class='p center logo small'>x+(~x)=-1</p></li><li>两式子相减得到：<p class='p center logo small'>-x=~x+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2>题目：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>检测x是否属于ascii的数字，简单来说是判断x是否在0x30和0x39之间。</li><li>在汇编中判断大小是通过减法置标志位来完成的，因此我们可以通过让0x30和0x39分别减去x再取符号位，看是否满足：0x30-x应该小于0符号位为1，0x39-x&gt;0符号位为0，但是若是x落在边界时,如x==0x30，0x30-x为0符号位为0也是满足要求的，因此我们可以把&lt;=变为&lt;：<p class='p center logo small'>0x30<= x <= 0x39</p>上式等价于：<p class='p center logo small'>0x2F< x <= 0x39</p>那么右边x<0x39是否需要等价转换?0x39-x应该大于或等于0，符号位为0，0x39-x<0符号位为1，经分析边界条件是囊括的所以不需要等价转换（转换后会把边界条件排出）。让0x2F-x符号位为1，0x39-x符号位为0，必须同时满足这两个条件，首先先看0x2F< x，相减后如何提取符号位？可以通过算数右移，移动31位符号位占满整个32位，即若0x2F-x<0，则(0x2F+(~x+1))>&gt;31为0xFFFFFFFF，若0x2F-x&gt;=0,(0x2F+(~x+1))&gt;&gt;31为0;<p class='p center logo small'>(0x2F+(~x+1))>>31</p>再看x &lt;= 0x39，同样的方法，若0x39-x<0，则(0x39+(~x+1))>&gt;31为0xFFFFFFFF，若0x39-x&gt;=0,(0x39+(~x+1))&gt;&gt;31为0;我们取个反就可以满足<p class='p center logo small'>~((0x39+(~x+1))>>31)</p>需要同时满足上述两个条件，故<p class='p center logo small'>(0x2F + (~x + 1)) >> 31 & ~((0x39 + (~x + 1)) >> 31)</p>由于最后返回1或0，我们取最低位即可：<p class='p center logo small'>(0x2F + (~x + 1)) >> 31 & ~((0x39 + (~x + 1)) >> 31) & 0x1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low = (<span class="number">0x2F</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;  <span class="comment">// 0x2F - x &lt; 0 =&gt; x &gt; 0x2F (即 x &gt;= 0x30)</span></span><br><span class="line">  <span class="type">int</span> high = ~((<span class="number">0x39</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>);  <span class="comment">// 0x39 - x &gt;= 0 =&gt; x &lt;= 0x39</span></span><br><span class="line">  <span class="keyword">return</span> low &amp; high &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>conditional的表达式和 x ? y : z 相同</li><li>要实现这种根据x的值判断返回y还是返回z，仅仅使用位运算非常难，因为虽然我们很容易判断x是否为0，但我们很难将x与yz同时关联起来，所以我们把希望留给加法运算，假设返回这样的式子：<p class='p center logo small'>a+y+z</p>当x!=0时，让a=-z=~z+1；当x==0时，让a=-y=~y+1就可以满足要求，但是这个要求同样难以满足，因为a既与y有关又与z有关，而a又由x是否为0来决定，因此我们考虑将a拆分：<p class='p center logo small'>b+c+y+z</p>当x为非0时，让b=0，c=-z=~z+1；当x为0时，让b=-y=~y+1，c=0。这样可以让b只与y有关，c只与z有关。<br>首先我们要判断x是否为0，这个不难，使用!运算即可，当x为非零则为0，当x为0则为1，我们首先关注b，!x==0时，b要为0，!x!=0时，b要为~z+1，显然与运算可以满足：<p class='p center logo small'>b = !x&(~y+1)</p>但是当!x!=0时，!x==1，而它与~z+1按位与只会留下最低位不一定是~z+1，因此我们需要让x!=0时得到0xFFFFFFFF，x==0时得到0，因此我们定义a：<p class='p center logo small'>a = ~(!x)+1</p>当x为0时,!x==1,~(!x)==0xFFFFFFFE,a==0xFFFFFFFF；当x为非零时，!x==0，~(!x)==0xFFFFFFFF，a==0，因此b的表达式应为<p class='p center logo small'>b = a&(~y+1)</p>再关注c，c的情况刚好与b相反，那么只需要给a再加一个~即可<p class='p center logo small'>c = ~a&(~z+1)</p>这里不用担心加法溢出问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = ~(!x)+<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = a&amp;(~y+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> c = ~a&amp;(~z+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> b+y+c+z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果x&lt;=y那么返回 1，否则返回0</li><li>比大小利用减法，让y-x如果y-x&gt;=0即符号位为0则返回1，如果y-x&lt;0即符号位为1则返回0，y-x=y+~x+1，然后右移31位后取符号位,我们需要一个取反操作以满足符号位为0返回1，符号位为1则返回0:<p class='p center logo small'>~((y+(~x+1))>>31) & 0x1</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~((y+(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>) &amp;<span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>实现!运算符，即对于!x，当x为0时返回1，当x为非0时返回0</li><li>0和非零最直观的区别就在与0的每一位都是0，而非零至少有一位为1，但因为我们无法利用循环移位操作来判断，故只能另辟蹊径</li><li>0的和非零的另一个不同特点在于0的负数还是0，即~0+1=0，而非零数的负数不是0，我们可以利用这点，看x的负数是否与它自己相同，前面我们用到过一个技巧通过异或来判断两数是否相同：这个表达式在x等于0时返回0，x等于非零时返回非零，但是这样等于没做<p class='p center logo small'>(~x+1)^x</p>我们可以利用另一点，非零数的负数和原来这个数的符号位肯定相反，一个必是1，一个必是0，而0的负数的符号位和0的符号位都是0，因此我们只需要将两者相与就能得到：非零时该表达式符号位为1，为0时该表达式符号位0<p class='p center logo small'>(~x+1)|x</p>接下来就是提取符号位了，顺便取个反，因为我们要求为0时返回1，为1时返回0，这个技巧我们在上面的题目用到过：即将其向右算数移位31位并取反，然后与0x1相与取最低位：<p class='p center logo small'>~(((~x+1)|x)>>31) & 0x1</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> ~(((~x+<span class="number">1</span>)|x)&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>返回以二进制补码的形式表示x需要几个比特数，其实就是看这个数的最高位1在第几位，然后加上1位符号位，这个问题有点难度，主要是有点难想到，下面是别人的实现方法。</li><li>这里用到二分法：<br>先考虑正数和0</li></ul><ol><li>高 16 位：检查高 16 位是否有 1，如果有，则至少需要 16 位。</li><li>高 8 位：在剩下的 16 位中，检查高 8 位是否有 1。</li><li>高 4 位：在剩下的 8 位中，检查高 4 位是否有 1。</li><li>高 2 位：在剩下的 4 位中，检查高 2 位是否有 1。</li><li>高 1 位：在剩下的 2 位中，检查高 1 位是否有 1。</li><li>最低位：最后剩下的 1 位。<br>最终，将所有部分的位数相加，并加 1（符号位）。</li></ol><ul><li>对负数的处理：<br>flag 是 x &gt;&gt; 31，即符号位。如果 x 是负数，flag 为 1；否则为 0。</li></ul><ol><li>如果 x 是负数（flag == 1），则 x 被取反：x = ~x。</li><li>如果 x 是非负数（flag == 0），则 x 保持不变。<br>负数的补码表示中，符号位和数值部分是混合在一起的。如果直接计算负数的有效位数，符号位会导致结果错误。例如：<br>-1 的补码是 11111111 11111111 11111111 11111111，如果直接计算位数，会得到 32 位，但实际上我们只关心其有效位数。<br>通过取反操作，负数的补码表示会被转换为正数，其二进制表示中的有效位数与原来的负数相同。例如：</li></ol><ul><li>-1 的补码是 11111111 11111111 11111111 11111111，取反后为 00000000 00000000 00000000 00000000，有效位数为 1。</li><li>-2 的补码是 11111111 11111111 11111111 11111110，取反后为 00000000 00000000 00000000 00000001，有效位数为 2。</li></ul><div class="tag link"><a class="link-card" title="howManyBits" href="https://zhuanlan.zhihu.com/p/559005736"><div class="left"><img src="https://static.zhihu.com/heifetz/favicon.ico"/></div><div class="right"><p class="text">howManyBits</p><p class="url">https://zhuanlan.zhihu.com/p/559005736</p></div></a></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> flag = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  x = (flag &amp; ~x) | (~flag &amp; x);  <span class="comment">// x符号位为0不变 ,x符号位为1按位取反</span></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>; </span><br><span class="line">  x &gt;&gt;= b16;  </span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x &gt;&gt;= b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x &gt;&gt;= b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x &gt;&gt;= b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x &gt;&gt;= b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b0 + b1 + b2 + b4 + b8 + b16 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>将一个单精度浮点数（float）乘以 2，并返回结果的二进制表示。函数的输入和输出都是 unsigned int 类型，但它们实际上表示的是单精度浮点数的二进制位模式，当输入是NaN时返回这个输入即可，另外，终于可以用if while了😭😭😭</p></li><li><p>先回顾下<strong>IEEE 754</strong>浮点数的知识：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-53-54.png" alt="IEEE 754的表示形式"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-54-47.png" alt="单精度float 双精度double"></p><p>对于IEEE 754表示的浮点数，一共有三种类别<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-12.png" alt="类别1：规格化数"></p><p>非规格化数用于表示接近零的极小数值，防止浮点下溢（Underflow），保证浮点运算的连续性。<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-34.png" alt="类别2：非规格化数"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-43.png" alt="类别3：特殊值"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_16-38-57.png" alt="IEEE 754 表示范围"></p><p>首先我们先提取符号位sign，尾数frac，阶码exp：<br><p class='p center logo small'>sign=uf>>31&0x1</p><br><p class='p center logo small'>frac=uf&0x7FFFFF</p><br><p class='p center logo small'>exp = (uf&0x7f800000)>>23</p></p><p>根据阶码判断这个浮点数是规格化数，非规格化数还是特殊情况中的哪一种<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123; </span><br><span class="line">  <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> sign=uf&gt;&gt;<span class="number">31</span>&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac=uf&amp;<span class="number">0x7FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span>)&#123;<span class="comment">//非规格化数，阶码为0，直接让frac乘以2即可</span></span><br><span class="line">    frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">0xFF</span>)&#123;<span class="comment">//特殊情况，非数</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">exp</span>++;<span class="comment">//乘2,相当于E+1,相当于</span></span><br><span class="line">    <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>用int表示输入的IEEE 754浮点数，如果超过表示范围则返回0x80000000u。</li><li>如果是非规格化数，直接返回0，如果是特殊情况直接返回0x80000000u</li><li>如果是规格化数，我们需要先判断是否超出int表示范围，int一共32位，一位表示符号位，最大表示2^31，最小表示-(2^31+1)，因此阶码E不能超过30（当E为31时左移E位会覆盖符号位）；当阶码E小于0时，说明是个小于1的数，直接返回0；又：</li><li>sign <strong>1位</strong></li><li>exp <strong>8位</strong></li><li>frac <strong>23位</strong></li></ul><script type="math/tex; mode=display">V = (-1)^{sign} \times 2^{exp - 127} \times (1 + frac)</script><p>我们可以可以看成<strong>1frac</strong>（第24位为1，第1~23位构成frac）而此时相当于由<strong>1.frac</strong>（整数部分位1，小数部分为frac）左移了23位，此时阶码为E，即要乘以E个2，也就是左移E位，所以，当E小于23时，应该右移（23-E）位以截断frac后面的(23-E)位；当E大于23时，由于此时相当于已经左移了23位，所以只需再左移(E-23)位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> sign = uf &gt;&gt; <span class="number">31</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac = uf &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>) &#123;  <span class="comment">// 特殊情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000u</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;  <span class="comment">// 非规格化数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                   <span class="comment">// 规格化数</span></span><br><span class="line">    <span class="type">int</span> E = <span class="built_in">exp</span> - <span class="number">127</span>;  <span class="comment">// 阶码，注意不要设置为unsigned</span></span><br><span class="line">    <span class="keyword">if</span> (E &gt;= <span class="number">31</span>) &#123;           <span class="comment">// 超范围</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000u</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(E&lt;<span class="number">0</span>)&#123;<span class="comment">//如果E&lt;0说明是个比1小的数，返回0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    frac = frac | (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);  <span class="comment">// 填上frac的1</span></span><br><span class="line">    <span class="keyword">if</span> (E &lt; <span class="number">23</span>) &#123;</span><br><span class="line">      frac = frac &gt;&gt; (<span class="number">23</span> - E);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      frac = frac &lt;&lt; (E - <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;<span class="comment">//根据符号位返回正负</span></span><br><span class="line">      <span class="keyword">return</span> frac;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -frac;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>计算2.0^x，并返回IEEE 754下的unsigned表示，如果结果太小，小到非规格化数都不能表示则返回0，如果结果太大返回+INF，很明显这题主要考察IEEE 754的表示范围。</li></ul><p>对于<strong>float单精度</strong></p><ul><li>符号位sign：1位</li><li>阶码exp: 8位</li><li>尾数frac：23位</li></ul><p><strong>表示范围</strong></p><ul><li><p>规格化数：阶码exp既不全为0，也不全为1，</p><script type="math/tex; mode=display">V = (-1)^S \times 2^E \times M = (-1)^{sign} \times 2^{exp - bias} \times (1 + frac)</script><p>exp范围为1~254,E=Exp-Bias=Exp-127，E的范围为-126&gt;=E&gt;=127;而对于frac，最小值为0，最大值为1-2^(-23),因此，不考虑S的情况下</p><script type="math/tex; mode=display">V_{max} =  (-1)^S \times 2^{127} \times (2-2^{-23}) = (-1)^S \times 2^{127} \times (2-2^{-23})</script><script type="math/tex; mode=display">V_{min} = (-1)^S \times 2^{-126} \times (1+0) = (-1)^S \times 2^{-126}</script></li><li><p>非规格化数：阶码全为0</p><script type="math/tex; mode=display">V = (-1)^S \times 2^E \times M = (-1)^{sign} \times 2^{1-Bias} \times (0 + frac)</script><p>阶码exp全为0,E=1-Bias=1-127=-126，因此：</p><script type="math/tex; mode=display">V = (-1)^{sign} \times 2^{- 126} \times (0 + frac)</script><p>对于frac来说，最小值为0，但能表示的最小非零是2^(-23),0~2^(-23)无法表示,最大值为1-2^(-23)，因此，当frac取0时，值为0，但要计算表示的最小非零时要令frac=2^(-23)，在不考虑S的情况下</p><script type="math/tex; mode=display">V_{max} =  (-1)^S \times 2^{-126} \times (0+1-2^{-23}) = (-1)^S \times 2^{-126} \times (1-2^{-23})</script><script type="math/tex; mode=display">V_{min} = (-1)^S \times 2^{-126} \times (0+2^{-23}) = (-1)^S \times 2^{-149}</script><ul><li>特殊值</li></ul></li></ul><ol><li>+infinity：exp所有位全为1，frac为0，S为0</li><li>-infinity：exp所有位全为1，frac为0，S为1</li><li>NaN：exp所有位全为1，frac不为0</li></ol><p>因此，经上述分析:</p><ul><li>当x&gt;127时返回+NaN</li><li>当-126&lt;=x&lt;=127时为规格化数</li><li>当 -149 &lt;= x &lt; -126时为非规格化数</li><li>当 x &lt; -149时，太小了无法表示返回0<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">127</span>) &#123;  <span class="comment">// 返回+infinity,S=0,exp=0xFF,frac=0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-126</span> &lt;= x &amp;&amp; x &lt;= <span class="number">127</span>) &#123;  <span class="comment">// 规格化数,exp=E+Bias=E+127</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-149</span> &lt;= x &amp;&amp; x &lt; <span class="number">-126</span>) &#123;  <span class="comment">// 非规格化数,exp=0,E=1-Bias=-126,2^(-126)*frac</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">23</span>-(-x<span class="number">-126</span>));<span class="comment">//E已经有了2^(-126),当frac为0x1时表示2^(-23),假设输入x为-127,则frac要为2^(-1),即1向左移动22位</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//x&lt; -149,太小了返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDK2获取Protocol总结</title>
      <link href="/posts/42855/"/>
      <url>/posts/42855/</url>
      
        <content type="html"><![CDATA[<p>——————<br><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-02-25</p></div></div><div class='timeline-item-content'><ol><li>添加了 OpenProtocol,HandleProtocol,LocateProtocol,OpenProtocolInfomation,CloseProtocol</li></ol></div></div></div><br>——————</p><p>UefiSpec.h 中定义了 Protocol 相关的接口:<br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_HANDLE_PROTOCOL HandleProtocol;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_REGISTER_PROTOCOL_NOTIFY RegisterProtocolNotify;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_HANDLE LocateHandle;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_DEVICE_PATH LocateDevicePath;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_OPEN_PROTOCOL OpenProtocol;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_CLOSE_PROTOCOL CloseProtocol;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_OPEN_PROTOCOL_INFORMATION OpenProtocolInformation;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_PROTOCOLS_PER_HANDLE ProtocolsPerHandle;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_HANDLE_BUFFER LocateHandleBuffer;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_LOCATE_PROTOCOL LocateProtocol;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_INSTALL_PROTOCOL_INTERFACE InstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;</p>            </div></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// EFI Boot Services Table.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// The table header for the EFI Boot Services Table.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  EFI_TABLE_HEADER                              Hdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Task Priority Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_RAISE_TPL                                 RaiseTPL;</span><br><span class="line">  EFI_RESTORE_TPL                               RestoreTPL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Memory Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_ALLOCATE_PAGES                            AllocatePages;</span><br><span class="line">  EFI_FREE_PAGES                                FreePages;</span><br><span class="line">  EFI_GET_MEMORY_MAP                            GetMemoryMap;</span><br><span class="line">  EFI_ALLOCATE_POOL                             AllocatePool;</span><br><span class="line">  EFI_FREE_POOL                                 FreePool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Event &amp; Timer Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CREATE_EVENT                              CreateEvent;</span><br><span class="line">  EFI_SET_TIMER                                 SetTimer;</span><br><span class="line">  EFI_WAIT_FOR_EVENT                            WaitForEvent;</span><br><span class="line">  EFI_SIGNAL_EVENT                              SignalEvent;</span><br><span class="line">  EFI_CLOSE_EVENT                               CloseEvent;</span><br><span class="line">  EFI_CHECK_EVENT                               CheckEvent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Protocol Handler Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_INSTALL_PROTOCOL_INTERFACE                InstallProtocolInterface;</span><br><span class="line">  EFI_REINSTALL_PROTOCOL_INTERFACE              ReinstallProtocolInterface;</span><br><span class="line">  EFI_UNINSTALL_PROTOCOL_INTERFACE              UninstallProtocolInterface;</span><br><span class="line">  EFI_HANDLE_PROTOCOL                           HandleProtocol;</span><br><span class="line">  VOID                                          *Reserved;</span><br><span class="line">  EFI_REGISTER_PROTOCOL_NOTIFY                  RegisterProtocolNotify;</span><br><span class="line">  EFI_LOCATE_HANDLE                             LocateHandle;</span><br><span class="line">  EFI_LOCATE_DEVICE_PATH                        LocateDevicePath;</span><br><span class="line">  EFI_INSTALL_CONFIGURATION_TABLE               InstallConfigurationTable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Image Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_IMAGE_LOAD                                LoadImage;</span><br><span class="line">  EFI_IMAGE_START                               StartImage;</span><br><span class="line">  EFI_EXIT                                      Exit;</span><br><span class="line">  EFI_IMAGE_UNLOAD                              UnloadImage;</span><br><span class="line">  EFI_EXIT_BOOT_SERVICES                        ExitBootServices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Miscellaneous Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_GET_NEXT_MONOTONIC_COUNT                  GetNextMonotonicCount;</span><br><span class="line">  EFI_STALL                                     Stall;</span><br><span class="line">  EFI_SET_WATCHDOG_TIMER                        SetWatchdogTimer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// DriverSupport Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CONNECT_CONTROLLER                        ConnectController;</span><br><span class="line">  EFI_DISCONNECT_CONTROLLER                     DisconnectController;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Open and Close Protocol Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_OPEN_PROTOCOL                             OpenProtocol;</span><br><span class="line">  EFI_CLOSE_PROTOCOL                            CloseProtocol;</span><br><span class="line">  EFI_OPEN_PROTOCOL_INFORMATION                 OpenProtocolInformation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Library Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_PROTOCOLS_PER_HANDLE                      ProtocolsPerHandle;</span><br><span class="line">  EFI_LOCATE_HANDLE_BUFFER                      LocateHandleBuffer;</span><br><span class="line">  EFI_LOCATE_PROTOCOL                           LocateProtocol;</span><br><span class="line">  EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES      InstallMultipleProtocolInterfaces;</span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES    UninstallMultipleProtocolInterfaces;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 32-bit CRC Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CALCULATE_CRC32                           CalculateCrc32;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Miscellaneous Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_COPY_MEM                                  CopyMem;</span><br><span class="line">  EFI_SET_MEM                                   SetMem;</span><br><span class="line">  EFI_CREATE_EVENT_EX                           CreateEventEx;</span><br><span class="line">&#125; EFI_BOOT_SERVICES;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="OpenProtocol"><a href="#OpenProtocol" class="headerlink" title="OpenProtocol"></a>OpenProtocol</h1><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250207181806644.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250207182821554.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144030827.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144054460.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144113071.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144141665.png" alt="OpenProtocol"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MdePkg/Include/Uefi/UefiSpec.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL   0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_GET_PROTOCOL         0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_TEST_PROTOCOL        0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER  0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_DRIVER            0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_EXCLUSIVE            0x00000020</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Queries a handle to determine if it supports a specified protocol. If the protocol is supported by the</span></span><br><span class="line"><span class="comment">  handle, it opens the protocol on behalf of the calling agent.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle for the protocol interface that is being opened.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol</span></span><br><span class="line"><span class="comment">                                Interface is returned.</span></span><br><span class="line"><span class="comment">  @param[in]   AgentHandle      The handle of the agent that is opening the protocol interface</span></span><br><span class="line"><span class="comment">                                specified by Protocol and Interface.</span></span><br><span class="line"><span class="comment">  @param[in]   ControllerHandle If the agent that is opening a protocol is a driver that follows the</span></span><br><span class="line"><span class="comment">                                UEFI Driver Model, then this parameter is the controller handle</span></span><br><span class="line"><span class="comment">                                that requires the protocol interface. If the agent does not follow</span></span><br><span class="line"><span class="comment">                                the UEFI Driver Model, then this parameter is optional and may</span></span><br><span class="line"><span class="comment">                                be NULL.</span></span><br><span class="line"><span class="comment">  @param[in]   Attributes       The open mode of the protocol</span></span><br><span class="line"><span class="comment">  interface specified by Handle</span></span><br><span class="line"><span class="comment">                                and Protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           An item was added to the open list for the protocol interface, and the</span></span><br><span class="line"><span class="comment">                                protocol interface was returned in Interface.</span></span><br><span class="line"><span class="comment">  @retval EFI_UNSUPPORTED       Handle does not support Protocol.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.</span></span><br><span class="line"><span class="comment">  @retval EFI_ACCESS_DENIED     Required attributes can&#x27;t be supported in current environment.</span></span><br><span class="line"><span class="comment">  @retval EFI_ALREADY_STARTED   Item on the open list already has requierd attributes whose agent</span></span><br><span class="line"><span class="comment">                                handle is the same as AgentHandle.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_OPEN_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                  *Protocol,</span></span><br><span class="line"><span class="params">  OUT VOID                      **Interface  OPTIONAL,</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                AgentHandle,</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                ControllerHandle,</span></span><br><span class="line"><span class="params">  IN  UINT32                    Attributes</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Guid/FileInfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/BaseMemoryLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/CacheMaintenanceLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/MemoryAllocationLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SimpleFileSystem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">ReadFileByName</span><span class="params">(IN CHAR16 *FileName, OUT UINT8 **FileData, OUT UINTN *FileSize)</span> &#123;</span><br><span class="line">  EFI_FILE_INFO *FileInfo;</span><br><span class="line">  UINTN FileInfoSize;</span><br><span class="line">  EFI_FILE_PROTOCOL *FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *SimpleFileSystem;</span><br><span class="line">  EFI_FILE_PROTOCOL *Root;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  UINTN HandleCount = <span class="number">0</span>;</span><br><span class="line">  UINTN HandleIndex = <span class="number">0</span>;</span><br><span class="line">  EFI_HANDLE *HandleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// find all handles of SimpleFileSystemProtocol</span></span><br><span class="line">  Status =</span><br><span class="line">      gBS-&gt;LocateHandleBuffer(ByProtocol, &amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line">                              <span class="literal">NULL</span>, &amp;HandleCount, &amp;HandleBuffer);</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR(Status) || HandleCount == <span class="number">0</span>) &#123;</span><br><span class="line">    Print(<span class="string">L&quot;Locate SimpleFileSystemProtocolHandle Buffer error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (HandleIndex = <span class="number">0</span>; HandleIndex &lt; HandleCount; HandleIndex++) &#123;</span><br><span class="line">    Status = gBS-&gt;OpenProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                               &amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line">                               (VOID **)&amp;SimpleFileSystem, gImageHandle, <span class="literal">NULL</span>,</span><br><span class="line">                               EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open SimpleFileSystemProtocol error,at HandleIndex %d&quot;</span>,</span><br><span class="line">            HandleIndex);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Status = SimpleFileSystem-&gt;OpenVolume(SimpleFileSystem, &amp;Root);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open Root Volume error at HandleIndex%d&quot;</span>, HandleIndex);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.打开文件，获取文件句柄FileHandle</span></span><br><span class="line">    Status = Root-&gt;Open(Root, &amp;FileHandle, FileName, EFI_FILE_MODE_READ, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((FileHandle == <span class="literal">NULL</span>) || (EFI_ERROR(Status))) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open file %s failed at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else find the target handle</span></span><br><span class="line">    Print(<span class="string">L&quot;FileHandle: 0x%p at HandleIndex%d\n&quot;</span>, FileHandle, HandleIndex);</span><br><span class="line">    <span class="comment">// 2.分配文件信息大小</span></span><br><span class="line">    FileInfoSize = <span class="keyword">sizeof</span>(EFI_FILE_INFO) + <span class="number">1024</span>;</span><br><span class="line">    FileInfo = AllocateZeroPool(FileInfoSize);</span><br><span class="line">    <span class="keyword">if</span> (FileInfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;can not allocate %d size for FineInfo at HandleIndex%d\n&quot;</span>,</span><br><span class="line">            FileInfoSize, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.打开文件信息</span></span><br><span class="line">    Status = FileHandle-&gt;GetInfo(FileHandle, &amp;gEfiFileInfoGuid, &amp;FileInfoSize,</span><br><span class="line">                                 FileInfo);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Get FileInfo failed at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Print(<span class="string">L&quot;FileInfo: 0x%p\n&quot;</span>, FileInfo);</span><br><span class="line">    <span class="comment">// 4.预先分配文件大小</span></span><br><span class="line">    *FileSize = (UINTN)FileInfo-&gt;FileSize + <span class="keyword">sizeof</span>(CHAR16);</span><br><span class="line">    *FileData = AllocateZeroPool(*FileSize);</span><br><span class="line">    <span class="keyword">if</span> (*FileData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;locate file data size %d failed at HandleIndex%d\n&quot;</span>, *FileSize,</span><br><span class="line">            HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Print(<span class="string">L&quot;size of %s is %d\n&quot;</span>, FileName, *FileSize);</span><br><span class="line">      Print(<span class="string">L&quot;FileData: 0x%p\n&quot;</span>, *FileData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.读取文件</span></span><br><span class="line">    Status = FileHandle-&gt;Read(FileHandle, FileSize, (VOID *)*FileData);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;open %s file failed at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">// gBS-&gt;FreePool((VOID *)FileData);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Print(<span class="string">L&quot;open %s file success at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    FileHandle-&gt;Close(FileHandle);</span><br><span class="line">    Print(<span class="string">L&quot;FileHandle is freed normally at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">    Print(<span class="string">L&quot;FileInfo is freed normally at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    Root-&gt;Close(Root);</span><br><span class="line">    gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                       &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">    Print(<span class="string">L&quot;Operation Success at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HandleBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    gBS-&gt;FreePool(HandleBuffer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HandleProtocol"><a href="#HandleProtocol" class="headerlink" title="HandleProtocol"></a>HandleProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250201214538747.png" alt="HandleProtocol的原型"></p><p>相比于 OpenProtocol，不需要指定参数 AgentHandle,ControllerHandle 和 Attributes</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Queries a handle to determine if it supports a specified protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle being queried.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol</span></span><br><span class="line"><span class="comment">                                Interface is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The interface information for the specified protocol was returned.</span></span><br><span class="line"><span class="comment">  @retval EFI_UNSUPPORTED       The device does not support the specified protocol.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Protocol is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Interface is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_HANDLE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE               Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                 *Protocol,</span></span><br><span class="line"><span class="params">  OUT VOID                     **Interface</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/DevicePathLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/LoadedImage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS EFIAPI <span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="params">                           IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  EFI_LOADED_IMAGE_PROTOCOL *LoadedImage;</span><br><span class="line">  Status = gBS-&gt;HandleProtocol(ImageHandle, &amp;gEfiLoadedImageProtocolGuid,</span><br><span class="line">                               (VOID **)&amp;LoadedImage);</span><br><span class="line">  <span class="keyword">if</span> (Status == EFI_SUCCESS) &#123;</span><br><span class="line">    EFI_DEVICE_PATH_PROTOCOL *DevicePath;</span><br><span class="line">    Status =</span><br><span class="line">        gBS-&gt;HandleProtocol(ImageHandle, &amp;gEfiLoadedImageDevicePathProtocolGuid,</span><br><span class="line">                            (VOID **)&amp;DevicePath);</span><br><span class="line">    <span class="keyword">if</span>(Status == EFI_SUCCESS)&#123;</span><br><span class="line">      Print(<span class="string">L&quot;Image device: %s\n&quot;</span>,ConvertDevicePathToText(DevicePath,FALSE,TRUE));</span><br><span class="line">      Print(<span class="string">L&quot;Image file: %s\n&quot;</span>, ConvertDevicePathToText(LoadedImage-&gt;FilePath,FALSE,TRUE));</span><br><span class="line">      Print(<span class="string">L&quot;Image Base: %X\n&quot;</span>,LoadedImage-&gt;ImageBase);</span><br><span class="line">      Print(<span class="string">L&quot;Image Size: %X\n&quot;</span>,LoadedImage-&gt;ImageSize);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      Print(<span class="string">L&quot;Can&#x27;t get EFI_LOADED_IMAGE_PROTOCOL, Status=%r\n&quot;</span>,Status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Print(<span class="string">L&quot;Can&#x27;t get EFI_DEVICE_PATH_PROTOCOL, Status=%r\n&quot;</span>,Status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="ProtocolsPerHandle"><a href="#ProtocolsPerHandle" class="headerlink" title="ProtocolsPerHandle"></a>ProtocolsPerHandle</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250202231208653.png" alt="ProtocolsPerHandle"></p><p>通过 Protocol GUID 检索安装在设备句柄上的接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Retrieves the list of protocol interface GUIDs that are installed on a handle in a buffer allocated</span></span><br><span class="line"><span class="comment">  from pool.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle              The handle from which to retrieve the list of protocol interface</span></span><br><span class="line"><span class="comment">                                   GUIDs.</span></span><br><span class="line"><span class="comment">  @param[out]  ProtocolBuffer      A pointer to the list of protocol interface GUID pointers that are</span></span><br><span class="line"><span class="comment">                                   installed on Handle.</span></span><br><span class="line"><span class="comment">  @param[out]  ProtocolBufferCount A pointer to the number of GUID pointers present in</span></span><br><span class="line"><span class="comment">                                   ProtocolBuffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The list of protocol interface GUIDs installed on Handle was returned in</span></span><br><span class="line"><span class="comment">                                ProtocolBuffer. The number of protocol interface GUIDs was</span></span><br><span class="line"><span class="comment">                                returned in ProtocolBufferCount.</span></span><br><span class="line"><span class="comment">  @retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the results.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is not a valid EFI_HANDLE.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER ProtocolBuffer is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER ProtocolBufferCount is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_PROTOCOLS_PER_HANDLE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE      Handle,</span></span><br><span class="line"><span class="params">  OUT EFI_GUID        ***ProtocolBuffer,</span></span><br><span class="line"><span class="params">  OUT UINTN           *ProtocolBufferCount</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/MemoryAllocationLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  Print(<span class="string">L&quot;_______________\n&quot;</span>);</span><br><span class="line">  EFI_GUID **ProtocolGuidArray;</span><br><span class="line">  UINTN ArrayCount;</span><br><span class="line">  EFI_STATUS Status = gBS-&gt;ProtocolsPerHandle(ImageHandle,&amp;ProtocolGuidArray,&amp;ArrayCount);</span><br><span class="line">  <span class="keyword">if</span>(Status==EFI_SUCCESS)&#123;</span><br><span class="line">    <span class="keyword">for</span>(UINTN i =<span class="number">0</span>;i&lt;ArrayCount;i++)&#123;</span><br><span class="line">      Print(<span class="string">L&quot;%g\n&quot;</span>,ProtocolGuidArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    FreePool(ProtocolGuidArray);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Print(<span class="string">L&quot;ProtocolsPerHandle error: %r\n&quot;</span>,Status);<span class="comment">//%r打印EFI_STATUS错误码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LocateProtocol"><a href="#LocateProtocol" class="headerlink" title="LocateProtocol"></a>LocateProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225140716252.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225141031426.png" alt="LocateProtocol"></p><p>与 HandleProtocol 和 OpenProtocol 不同，LocateProtocol 不关心 Protocol 在哪个设备上，它会在系统中顺序寻找句柄列表，返回找到的第一个 Protocol 实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Returns the first protocol instance that matches the given protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]  Protocol          Provides the protocol to search for.</span></span><br><span class="line"><span class="comment">  @param[in]  Registration      Optional registration key returned from</span></span><br><span class="line"><span class="comment">                                RegisterProtocolNotify().</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        On return, a pointer to the first interface that matches Protocol and</span></span><br><span class="line"><span class="comment">                                Registration.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           A protocol instance matching Protocol was found and returned in</span></span><br><span class="line"><span class="comment">                                Interface.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         No protocol instances were found that match Protocol and</span></span><br><span class="line"><span class="comment">                                Registration.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Interface is NULL.</span></span><br><span class="line"><span class="comment">                                Protocol is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_LOCATE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_GUID  *Protocol,</span></span><br><span class="line"><span class="params">  IN  VOID      *Registration  OPTIONAL,</span></span><br><span class="line"><span class="params">  OUT VOID      **Interface</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">LoadFileByName</span><span class="params">(</span></span><br><span class="line"><span class="params">IN CHAR16 *FileName,</span></span><br><span class="line"><span class="params">OUT UINT8 **FileData,</span></span><br><span class="line"><span class="params">OUT UINTN *FileSize)</span></span><br><span class="line">&#123;</span><br><span class="line">EFI_STATUS Status;</span><br><span class="line">EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *SimpleFileSystem;</span><br><span class="line">EFI_FILE_PROTOCOL *Root;</span><br><span class="line">EFI_FILE_PROTOCOL *FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">EFI_FILE_INFO *FileInfo;</span><br><span class="line">UINTN FileInfoSize;</span><br><span class="line">UINTN TempBufferSize;</span><br><span class="line">VOID *TempBuffer;</span><br><span class="line"></span><br><span class="line">Status = gBS-&gt;LocateProtocol(&amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line"> <span class="literal">NULL</span>, (VOID **)&amp;SimpleFileSystem);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Open the root directory</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = SimpleFileSystem-&gt;OpenVolume(SimpleFileSystem, &amp;Root);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Open the file</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = Root-&gt;Open(Root, &amp;FileHandle, FileName,</span><br><span class="line">EFI_FILE_MODE_READ, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ((FileHandle == <span class="literal">NULL</span>) || (EFI_ERROR(Status)))</span><br><span class="line">&#123;</span><br><span class="line">Print(<span class="string">L&quot;Open file %s failed !!\n&quot;</span>, FileName);</span><br><span class="line">Root-&gt;Close(Root);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get the file information</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">FileInfoSize = <span class="keyword">sizeof</span>(EFI_FILE_INFO) + <span class="number">1024</span>;</span><br><span class="line">FileInfo = AllocateZeroPool(FileInfoSize);</span><br><span class="line"><span class="keyword">if</span> (FileInfo == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status = FileHandle-&gt;GetInfo(FileHandle, &amp;gEfiFileInfoGuid,</span><br><span class="line"> &amp;FileInfoSize,</span><br><span class="line"> FileInfo);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate buffer for the file data. The last CHAR16 is for L&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">TempBufferSize = (UINTN)FileInfo-&gt;FileSize + <span class="keyword">sizeof</span>(CHAR16);</span><br><span class="line">TempBuffer = AllocateZeroPool(TempBufferSize);</span><br><span class="line"><span class="keyword">if</span> (TempBuffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Read the file data to the buffer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = FileHandle-&gt;Read(FileHandle, &amp;TempBufferSize, TempBuffer);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(TempBuffer);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line"></span><br><span class="line">*FileSize = TempBufferSize;</span><br><span class="line">*FileData = TempBuffer;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="OpenProtocolInformation"><a href="#OpenProtocolInformation" class="headerlink" title="OpenProtocolInformation"></a>OpenProtocolInformation</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225141817128.png" alt="OpenProtocolInformation"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// EFI Oprn Protocol Information Entry</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_HANDLE    AgentHandle;</span><br><span class="line">  EFI_HANDLE    ControllerHandle;</span><br><span class="line">  UINT32        Attributes;</span><br><span class="line">  UINT32        OpenCount;</span><br><span class="line">&#125; EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Retrieves the list of agents that currently have a protocol interface opened.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle for the protocol interface that is being queried.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  EntryBuffer      A pointer to a buffer of open protocol information in the form of</span></span><br><span class="line"><span class="comment">                                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY structures.</span></span><br><span class="line"><span class="comment">  @param[out]  EntryCount       A pointer to the number of entries in EntryBuffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The open protocol information was returned in EntryBuffer, and the</span></span><br><span class="line"><span class="comment">                                number of entries was returned EntryCount.</span></span><br><span class="line"><span class="comment">  @retval EFI_OUT_OF_RESOURCES  There are not enough resources available to allocate EntryBuffer.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         Handle does not support the protocol specified by Protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                          Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                            *Protocol,</span></span><br><span class="line"><span class="params">  OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,</span></span><br><span class="line"><span class="params">  OUT UINTN                               *EntryCount</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="CloseProtocol"><a href="#CloseProtocol" class="headerlink" title="CloseProtocol"></a>CloseProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225142227191.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225142316837.png" alt="CloseProtocol"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Closes a protocol on a handle that was opened using OpenProtocol().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]  Handle            The handle for the protocol interface that was previously opened</span></span><br><span class="line"><span class="comment">                                with OpenProtocol(), and is now being closed.</span></span><br><span class="line"><span class="comment">  @param[in]  Protocol          The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[in]  AgentHandle       The handle of the agent that is closing the protocol interface.</span></span><br><span class="line"><span class="comment">  @param[in]  ControllerHandle  If the agent that opened a protocol is a driver that follows the</span></span><br><span class="line"><span class="comment">                                UEFI Driver Model, then this parameter is the controller handle</span></span><br><span class="line"><span class="comment">                                that required the protocol interface.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The protocol instance was closed.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER 1) Handle is NULL.</span></span><br><span class="line"><span class="comment">                                2) AgentHandle is NULL.</span></span><br><span class="line"><span class="comment">                                3) ControllerHandle is not NULL and ControllerHandle is not a valid EFI_HANDLE.</span></span><br><span class="line"><span class="comment">                                4) Protocol is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         1) Handle does not support the protocol specified by Protocol.</span></span><br><span class="line"><span class="comment">                                2) The protocol interface specified by Handle and Protocol is not</span></span><br><span class="line"><span class="comment">                                   currently open by AgentHandle and ControllerHandle.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_CLOSE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               Handle,</span></span><br><span class="line"><span class="params">  IN EFI_GUID                 *Protocol,</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               AgentHandle,</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               ControllerHandle</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UEFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UEFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil安装</title>
      <link href="/posts/28522/"/>
      <url>/posts/28522/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-01-31</p></div></div><div class='timeline-item-content'><p>init</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-08-07</p></div></div><div class='timeline-item-content'><p>add tip warning</p></div></div></div><hr><div class="tip warning faa-horizontal animated"><p>最新的用下面的方法已经不行了，v6 版本的 ARMCC 可以正常使用，但 v5 版本提示没有 license</p></div><h1 id="C51-安装"><a href="#C51-安装" class="headerlink" title="C51 安装"></a>C51 安装</h1><p>1.首先进入官网点击下载 C51</p><div class="tag link"><a class="link-card" title="Keil下载" href="https://www.keil.com/download/product/"><div class="left"><img src="https://www.keil.com/images/icons/c51_dld.png"/></div><div class="right"><p class="text">Keil下载</p><p class="url">https://www.keil.com/download/product/</p></div></a></div><p>这里会要求填一个表单，简单填一下就好，然后点击下载的 exe 安装包进行安装</p><p>2.进入安装后一路确认，在选择安装位置这里我选择安装到 D 盘而不是默认的 C 盘。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131193502978.png" alt="C51安装位置"></p><p>3.最后点击 Finish 安装成功</p><h1 id="MDK-安装"><a href="#MDK-安装" class="headerlink" title="MDK 安装"></a>MDK 安装</h1><p>Keil 的 MDK 和 C51 这两个软件可以共存，安装步骤类似。</p><p>1.首先还是访问官网下载 MDK 的安装包<br><div class="tag link"><a class="link-card" title="Keil下载" href="https://www.keil.com/download/product/"><div class="left"><img src="https://www.keil.com/images/icons/mdk_dld_v2.png"/></div><div class="right"><p class="text">Keil下载</p><p class="url">https://www.keil.com/download/product/</p></div></a></div></p><p>2.进入安装后，安装位置这样填，根据 C51 的安装位置更改<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131194740287.png" alt="MDK安装位置"></p><p>3.最后点击 Finish 安装成功</p><div class="tip warning faa-horizontal animated"><p>注意：C51 和 MDK 的安装顺序不要反了</p></div><h1 id="v5-编译器"><a href="#v5-编译器" class="headerlink" title="v5 编译器"></a>v5 编译器</h1><p>首先下载 v5 编译器，因为现在官方好像不提供直接下载的渠道了，所以只能下载之前版本的 Keil 提取出 v5 版本的编译器，这里有已经提取出来的编译器可以直接下载</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">夸克网盘</button><button type="button" class="tab">百度网盘</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="tag link"><a class="link-card" title="v5编译器下载" href="https://pan.quark.cn/s/cd646c8d5b2b"><div class="left"><img src="https://image.quark.cn/s/uae/g/3o/broccoli/resource/202404/d94d93e0-03a2-11ef-be4c-79ebae2e18ac.vnd.microsoft.icon"/></div><div class="right"><p class="text">v5编译器下载</p><p class="url">https://pan.quark.cn/s/cd646c8d5b2b</p></div></a></div></div><div class="tab-item-content"><div class="tag link"><a class="link-card" title="v5编译器下载" href="https://pan.baidu.com/s/1zkUcPyKC5Z-Qda9jJb1Sjw?pwd=1234"><div class="left"><img src="https://nd-static.bdstatic.com/m-static/v20-main/favicon-main.ico"/></div><div class="right"><p class="text">v5编译器下载</p><p class="url">https://pan.baidu.com/s/1zkUcPyKC5Z-Qda9jJb1Sjw?pwd=1234</p></div></a></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>下载后解压到 D:\Keil_v5\ARM 目录下</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131200906926.png" alt="编译器解压目录"></p><p>打开 Keil，随便新建一个工程，然后点击这个按钮<strong>File Extensions, Books and Environment…</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201214187.png" alt="File Extensions, Books and Environment..."></p><p>然后点击<strong>Folder/Extensions</strong>，点击<strong>Use ARM Compiler</strong>旁边的这个按钮</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201435417.png" alt="Use ARM Compiler"></p><p>点击下面的<strong>Add another ARM Compiler Version to List</strong>, 选择刚才解压的 ARMCC 路径</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201751844.png" alt="Add another ARM Compiler Version to List"></p><p>保存后至此成功</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://zhuanlan.zhihu.com/p/561047339">MDK5.37不预安装Compiler Version5解决办法</a></div>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Emacs配置</title>
      <link href="/posts/28521/"/>
      <url>/posts/28521/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-01-12</p></div></div><div class='timeline-item-content'><p>init</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-17</p></div></div><div class='timeline-item-content'><p>add clang-format</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>使用 Windows Terminal + WSL2</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo//202508021037505.png" alt="WSL2 Arch Linux"></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h2><p>Windows Terminal 中打开设置，选择打开 JSON 文件，在 schemes 中添加配色方案</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;schemes&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#0D1117&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;black&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#484F58&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;blue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#58A6FF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightBlack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#6E7681&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightBlue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#79C0FF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightCyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#56D4DD&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightGreen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#56D364&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightPurple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#D2A8FF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightRed&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFA198&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightWhite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FFFFFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;brightYellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E3B341&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cursorColor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#2F81F7&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cyan&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#39C5CF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;foreground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E6EDF3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;green&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#3FB950&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GitHub-Dark-Default&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;purple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#BC8CFF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;red&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#FF7B72&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;selectionBackground&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#E6EDF3&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;white&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#B1BAC4&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;yellow&quot;</span><span class="punctuation">:</span> <span class="string">&quot;#D29922&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 archlinux 的配置中选择 外观 选项卡<ul><li>配色方案选择 GitHub-Dark-Default</li><li>字体选择 FiraCode Nerd Font</li><li>背景不透明度 86%，选择启用亚克力材料</li></ul></li><li>在 archlinux 的配置中选择 高级 选项卡<ul><li>铃声通知样式取消勾选声音，选择闪烁窗口和闪烁任务栏</li></ul></li><li>安装 win32yank.exe 放入 C:\Winodws\System32 里</li></ul><h2 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h2><p>archlinux 需要下载一些软件包</p><p>下载 yay 参考</p><div class="tag link"><a class="link-card" title="archlinux安装yay" href="https://wiki.archlinuxcn.org/wiki/Yay"><div class="left"><img src="https://wiki.archlinuxcn.org/wzh/images/logo.svg"/></div><div class="right"><p class="text">archlinux安装yay</p><p class="url">https://wiki.archlinuxcn.org/wiki/Yay</p></div></a></div><p>注意下载后最好对 pacman 和 yay 进行换源，否则速度巨慢</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/locale.gen</span><br><span class="line"><span class="comment"># 找到#en_US.UTF-8 UTF-8解除注释</span></span><br><span class="line"><span class="built_in">sudo</span> locale-gen</span><br><span class="line"><span class="built_in">sudo</span> pacman -Sy emacs-nox</span><br><span class="line"><span class="built_in">sudo</span> pacman -Sy clang rust-analyzer nvm ripgrep bear pandoc-bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /usr/share/nvm/init-nvm.sh</span><br><span class="line">nvm list-remote</span><br><span class="line">nvm install v20.19.4</span><br><span class="line">nvm use v20.19.4</span><br><span class="line"><span class="comment"># npm最好也换源后再执行npm install</span></span><br><span class="line">npm i -g pyright bash-language-server</span><br><span class="line"></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"><span class="built_in">rm</span> ~/.cargo/bin/rust-analyzer</span><br><span class="line"><span class="built_in">ln</span> -s /usr/bin/rust-analyzer ~/.cargo/bin/rust-analyzer</span><br><span class="line"></span><br><span class="line">cargo install --git https://github.com/bergercookie/asm-lsp asm-lsp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建配置文件，也可以用默认配置</span></span><br><span class="line">asm-lsp gen-config</span><br><span class="line"><span class="comment"># 将FiraCode Nerd Font的ttf文件拷贝到 ~/.local/share/fonts/</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/sebastiencs/icons-in-terminal.git</span><br><span class="line">./install.sh</span><br><span class="line"><span class="comment"># then Follow the instructions to edit ~/.config/fontconfig/conf.d/30-icons.conf</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> pacman -S exa</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias ll=&quot;ls -alF&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias ls=&quot;exa --icons&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Emacs-配置"><a href="#Emacs-配置" class="headerlink" title="Emacs 配置"></a>Emacs 配置</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;不显示menu-bar</span></span><br><span class="line">(<span class="name">menu-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line"><span class="comment">;;显示行号</span></span><br><span class="line">(<span class="name">global-display-line-numbers-mode</span> <span class="literal">t</span>)</span><br><span class="line"><span class="comment">;;在ModeLine显示列号</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;prog-mode-hook &#x27;column-number-mode)</span><br><span class="line"><span class="comment">;;代码的折叠</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;prog-mode-hook &#x27;hs-minor-mode)</span><br><span class="line"><span class="comment">;; 自动重载更改的文件</span></span><br><span class="line">(<span class="name">global-auto-revert-mode</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;;开启可视化换行，自动折行</span></span><br><span class="line">(<span class="name">global-visual-line-mode</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;; 括号匹配</span></span><br><span class="line">(<span class="name">electric-pair-mode</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">;; 自动缩进</span></span><br><span class="line">(<span class="name">electric-indent-mode</span> <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 中文显示</span></span><br><span class="line">(<span class="name">set-language-environment</span> <span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">(<span class="name">set-buffer-file-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-terminal-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-keyboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-selection-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-default-coding-systems</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-clipboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">modify-coding-system-alist</span> &#x27;process <span class="string">&quot;*&quot;</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">prefer-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">setq-default</span> pathname-coding-system &#x27;utf-8)</span><br><span class="line">(<span class="name">setq</span> default-process-coding-system &#x27;(utf-8 . utf-8)</span><br><span class="line">      locale-coding-system &#x27;utf-8</span><br><span class="line">      file-name-coding-system &#x27;utf-8</span><br><span class="line">      default-buffer-file-coding-system &#x27;utf-8</span><br><span class="line">      slime-net-coding-system &#x27;utf-8-unix</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">(<span class="name">setenv</span> <span class="string">&quot;LC_CTYPE&quot;</span> <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">(<span class="name">setenv</span> <span class="string">&quot;LC_ALL&quot;</span> <span class="string">&quot;en_US.UTF-8&quot;</span>)</span><br><span class="line">(<span class="name">setenv</span> <span class="string">&quot;LANG&quot;</span> <span class="string">&quot;en_US.UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> find-file-encoding &#x27;auto)</span><br><span class="line">(<span class="name">setq-default</span> coding-system-for-read &#x27;utf-8)</span><br><span class="line">(<span class="name">setq-default</span> coding-system-for-write &#x27;utf-8)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 基本设置</span></span><br><span class="line"></span><br><span class="line">(<span class="name">setq-default</span> window-combination-resize <span class="literal">t</span>                      <span class="comment">;; 新窗口平均其他左右窗口</span></span><br><span class="line">              x-stretch-cursor <span class="literal">t</span>                               <span class="comment">;; 将光标拉伸到字形宽度</span></span><br><span class="line">              indent-tabs-mode <span class="literal">nil</span>                             <span class="comment">;; 不使用 TAB 字符，使用空格</span></span><br><span class="line">              tab-width <span class="number">8</span>                                      <span class="comment">;; tab 宽度设为 2 空格</span></span><br><span class="line">              )</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my/kill-unwanted-buffers ()</span><br><span class="line">  <span class="string">&quot;在 Emacs 启动时关闭一些不想要的 buffer.&quot;</span></span><br><span class="line">  (<span class="name">mapc</span> (<span class="name">lambda</span> (<span class="name">buf</span>)</span><br><span class="line">          (<span class="name">when</span> (<span class="name">get-buffer</span> buf)</span><br><span class="line">            (<span class="name">kill-buffer</span> buf)))</span><br><span class="line">        &#x27;( <span class="string">&quot;*scratch*&quot;</span> )))</span><br><span class="line">(<span class="name">add-hook</span> &#x27;emacs-startup-hook #&#x27;my/kill-unwanted-buffers)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> ring-bell-function &#x27;ignore</span><br><span class="line">      initial-scratch-message <span class="literal">nil</span></span><br><span class="line">      inhibit-startup-message <span class="literal">t</span></span><br><span class="line">      auto-save-file-name-transforms &#x27;((<span class="string">&quot;.*&quot;</span> <span class="string">&quot;~/.emacs.d/data/backup/&quot;</span> <span class="literal">t</span>)) <span class="comment">;; Write auto-save files to a separate directory</span></span><br><span class="line">      backup-directory-alist &#x27;((<span class="string">&quot;.&quot;</span> . <span class="string">&quot;~/.emacs.d/data/backup/&quot;</span>))          <span class="comment">;; Write backup files to a separate directory</span></span><br><span class="line">      create-lockfiles <span class="literal">nil</span>                                                 <span class="comment">;; Disable lockfiles</span></span><br><span class="line">      scroll-conservatively <span class="number">10000</span> <span class="comment">;;防止页面滚动时跳动</span></span><br><span class="line">      scroll-step <span class="number">1</span>               <span class="comment">;; 当光标移动到边缘时，窗口每次只滚动一行</span></span><br><span class="line">      undo-limit <span class="number">80000000</span>         <span class="comment">;; 提升撤销限制</span></span><br><span class="line">      display-time-default-load-average <span class="literal">nil</span> <span class="comment">;; 不显示系统负载</span></span><br><span class="line">      use-short-answers <span class="literal">t</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 时间显示设置</span></span><br><span class="line"><span class="comment">;; (setq display-time-24hr-format t   ;; 时间使用24小时制</span></span><br><span class="line"><span class="comment">;;       display-time-day-and-date t   ;; 时间显示包括日期和具体时间</span></span><br><span class="line"><span class="comment">;;       display-time-interval 10   ;; 时间的变化频率</span></span><br><span class="line"><span class="comment">;;       display-time-format &quot;%Y-%m-%d %A %H:%M&quot;) ;; 显示完整日期</span></span><br><span class="line"><span class="comment">;; ;; 启用时间显示设置,在minibuffer上面的那个杠上</span></span><br><span class="line"><span class="comment">;; (display-time-mode 1)</span></span><br><span class="line"><span class="comment">;; ;; 立即强制刷新一次时间</span></span><br><span class="line"><span class="comment">;; (display-time-update)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 使用 Fira Code Nerd Font 字体</span></span><br><span class="line">(<span class="name">set-face-attribute</span> &#x27;default <span class="literal">nil</span></span><br><span class="line">                    <span class="symbol">:font</span> <span class="string">&quot;FiraCode Nerd Font&quot;</span></span><br><span class="line">                    <span class="symbol">:height</span> <span class="number">120</span>)  <span class="comment">;; 120=12pt，可根据需求调整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; wsl与windos共享剪切版</span></span><br><span class="line">(<span class="name">defun</span> my/clipboard-to-windows (<span class="name">text</span> <span class="symbol">&amp;optional</span> push)</span><br><span class="line">  (<span class="name">let</span> ((<span class="name">process-connection-type</span> <span class="literal">nil</span>))</span><br><span class="line">    (<span class="name">with-temp-buffer</span></span><br><span class="line">      (<span class="name">insert</span> text)</span><br><span class="line">      (<span class="name">call-process-region</span> (<span class="name">point-min</span>) (<span class="name">point-max</span>) <span class="string">&quot;win32yank.exe&quot;</span> <span class="literal">nil</span> <span class="literal">nil</span> <span class="literal">nil</span> <span class="string">&quot;-i&quot;</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my/clipboard-from-windows ()</span><br><span class="line">  (<span class="name">string-trim-right</span></span><br><span class="line">   (<span class="name">with-output-to-string</span></span><br><span class="line">     (<span class="name">call-process</span> <span class="string">&quot;win32yank.exe&quot;</span> <span class="literal">nil</span> standard-output <span class="literal">nil</span> <span class="string">&quot;-o&quot;</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> interprogram-cut-function &#x27;my/clipboard-to-windows)</span><br><span class="line">(<span class="name">setq</span> interprogram-paste-function &#x27;my/clipboard-from-windows)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;设置镜像源</span></span><br><span class="line"><span class="comment">;; (setq package-archives</span></span><br><span class="line"><span class="comment">;;      &#x27;((&quot;melpa&quot; . &quot;https://melpa.org/packages/&quot;)</span></span><br><span class="line"><span class="comment">;;        (&quot;gnu&quot;   . &quot;https://elpa.gnu.org/packages/&quot;)))</span></span><br><span class="line">(<span class="name">setq</span> package-archives &#x27;((<span class="string">&quot;gnu&quot;</span>    . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;</span>)</span><br><span class="line">                         (<span class="string">&quot;nongnu&quot;</span> . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/nongnu/&quot;</span>)</span><br><span class="line">                         (<span class="string">&quot;melpa&quot;</span>  . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> package</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">unless</span> (<span class="name">bound-and-true-p</span> package--initialized)</span><br><span class="line">    (<span class="name">package-initialize</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> use-package-always-ensure <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;doom主题</span></span><br><span class="line">(<span class="name">use-package</span> doom-themes</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> doom-themes-enable-bold <span class="literal">t</span>    <span class="comment">; if nil, bold is universally disabled</span></span><br><span class="line">        doom-themes-enable-italic <span class="literal">t</span>) <span class="comment">; if nil, italics is universally disable</span></span><br><span class="line">  <span class="comment">;; 加载主题（例如 doom-one）</span></span><br><span class="line">  (<span class="name">load-theme</span> &#x27;doom-tomorrow-night <span class="literal">t</span>)</span><br><span class="line">  <span class="comment">;; 启用可选配置</span></span><br><span class="line">  <span class="comment">;; 高亮当前行</span></span><br><span class="line">  (<span class="name">doom-themes-visual-bell-config</span>)</span><br><span class="line">  <span class="comment">;; 改善 Org-mode 颜色</span></span><br><span class="line">  (<span class="name">doom-themes-org-config</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;在执行操作（如撤销、替换、复制）时提供视觉反馈。</span></span><br><span class="line">(<span class="name">use-package</span> volatile-highlights</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">volatile-highlights-mode</span> <span class="literal">t</span>))  <span class="comment">;; 启用 volatile-highlights</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; tab栏显示buffer</span></span><br><span class="line">(<span class="name">use-package</span> centaur-tabs</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:demand</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">defun</span> centaur-tabs-hide-tab (<span class="name">x</span>)</span><br><span class="line">    <span class="string">&quot;隐藏特殊 buffer，保留 GUD/GDB/VTERM buffer.&quot;</span></span><br><span class="line">    (<span class="name">let</span> ((<span class="name">name</span> (<span class="name">format</span> <span class="string">&quot;%s&quot;</span> x)))</span><br><span class="line">      (<span class="name">cond</span></span><br><span class="line">       <span class="comment">;; 保留所有 GDB/GUD 相关 buffer</span></span><br><span class="line">       ((<span class="name">string-match-p</span></span><br><span class="line">         <span class="string">&quot;^\\*\\(gud\\|gdb\\)&quot;</span> name)</span><br><span class="line">        <span class="literal">nil</span>)</span><br><span class="line">       <span class="comment">;; 隐藏 *Messages*、*Async-native-compile-log*、*EGLOT* 等内部 buffer</span></span><br><span class="line">       ((<span class="name">string-prefix-p</span> <span class="string">&quot;*&quot;</span> name) <span class="literal">t</span>)</span><br><span class="line">       <span class="comment">;; Magit buffer</span></span><br><span class="line">       ((<span class="name">and</span> (<span class="name">string-prefix-p</span> <span class="string">&quot;magit&quot;</span> name)</span><br><span class="line">             (<span class="name">not</span> (<span class="name">file-name-extension</span> name))) <span class="literal">t</span>)</span><br><span class="line">       <span class="comment">;;非文件不显示</span></span><br><span class="line">       ((<span class="name">not</span> (<span class="name">buffer-file-name</span> x)) <span class="literal">t</span>)</span><br><span class="line">       <span class="comment">;; 其他 buffer 显示</span></span><br><span class="line">       (<span class="name">t</span> <span class="literal">nil</span>))))</span><br><span class="line">  (<span class="name">setq</span> centaur-tabs-style <span class="string">&quot;bar&quot;</span></span><br><span class="line">        centaur-tabs-set-bar &#x27;over</span><br><span class="line">        centaur-tabs-enable-key-bindings <span class="literal">nil</span></span><br><span class="line">        centaur-tabs-set-icons <span class="literal">t</span></span><br><span class="line">        centaur-tabs-icon-type &#x27;nerd-icons</span><br><span class="line">        centaur-tabs-set-close-button <span class="literal">nil</span></span><br><span class="line">        centaur-tabs-show-new-tab-button <span class="literal">nil</span></span><br><span class="line">        centaur-tabs-cycle-scope &#x27;tabs)</span><br><span class="line">  (<span class="name">centaur-tabs-mode</span> <span class="literal">t</span>)</span><br><span class="line">  <span class="symbol">:bind</span></span><br><span class="line">  (<span class="string">&quot;C-&lt;left&gt;&quot;</span> . centaur-tabs-backward)</span><br><span class="line">  (<span class="string">&quot;C-&lt;right&gt;&quot;</span> . centaur-tabs-forward)</span><br><span class="line">  )</span><br><span class="line"><span class="comment">;;启用插件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; a light that follows your cursor</span></span><br><span class="line">(<span class="name">use-package</span> beacon</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">beacon-mode</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; modeline主题</span></span><br><span class="line">(<span class="name">use-package</span> doom-modeline</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:after</span> nyan-mode</span><br><span class="line">  <span class="symbol">:custom</span></span><br><span class="line">  (<span class="name">doom-modeline-buffer-file-name-style</span> &#x27;truncate-all)</span><br><span class="line">  <span class="symbol">:init</span> (<span class="name">doom-modeline-mode</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;显示进度条</span></span><br><span class="line">(<span class="name">use-package</span> nyan-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">nyan-mode</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;文件导航栏</span></span><br><span class="line">(<span class="name">use-package</span> neotree</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;&lt;f8&gt;&quot;</span> . neotree-toggle))</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> neo-theme &#x27;nerd-icons)</span><br><span class="line">  (<span class="name">setq</span> neo-smart-open <span class="literal">t</span>)       <span class="comment">;;  打开时自动跳到当前文件路径</span></span><br><span class="line">  (<span class="name">setq</span> neo-show-hidden-files <span class="literal">t</span>)<span class="comment">;;  显示隐藏文件</span></span><br><span class="line">  )</span><br><span class="line"><span class="comment">;; neotree buffer 中强制截断长行</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;neo-after-create-hook</span><br><span class="line">          (<span class="name">lambda</span> (<span class="name">_</span>)</span><br><span class="line">            <span class="comment">;; 不换行，禁用 visual-line（你全局开了的话）</span></span><br><span class="line">            (<span class="name">visual-line-mode</span> <span class="number">-1</span>)</span><br><span class="line">            (<span class="name">setq-local</span> truncate-lines <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">;; 用 “…” 代替右侧的 $ 截断标记</span></span><br><span class="line">            (<span class="name">let</span> ((<span class="name">tbl</span> (<span class="name">or</span> buffer-display-table (<span class="name">make-display-table</span>))))</span><br><span class="line">              (<span class="name">set-display-table-slot</span> tbl &#x27;truncation (<span class="name">make-glyph-code</span> ?…))</span><br><span class="line">              (<span class="name">setq-local</span> buffer-display-table tbl))))</span><br><span class="line"><span class="comment">;; 允许 neotree 窗口宽度可调整</span></span><br><span class="line">(<span class="name">with-eval-after-load</span> &#x27;neotree</span><br><span class="line">  (<span class="name">setq</span> neo-window-fixed-size <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> nerd-icons</span><br><span class="line">  <span class="symbol">:custom</span></span><br><span class="line">  <span class="comment">;; The Nerd Font you want to use in GUI</span></span><br><span class="line">  <span class="comment">;; &quot;Symbols Nerd Font Mono&quot; is the default and is recommended</span></span><br><span class="line">  <span class="comment">;; but you can use any other Nerd Font if you want</span></span><br><span class="line">  (<span class="name">nerd-icons-font-family</span> <span class="string">&quot;FiraCode Nerd Font&quot;</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; use-package with package.el:</span></span><br><span class="line">(<span class="name">use-package</span> dashboard</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">dashboard-setup-startup-hook</span>)</span><br><span class="line">  <span class="comment">;; recentf mode 必须开启</span></span><br><span class="line">  (<span class="name">recentf-mode</span> <span class="number">1</span>)</span><br><span class="line">  (<span class="name">setq</span> dashboard-navigation-cycle <span class="literal">t</span></span><br><span class="line">        dashboard-show-shortcuts <span class="literal">nil</span></span><br><span class="line">        dashboard-set-footer     <span class="literal">nil</span></span><br><span class="line">        dashboard-center-content <span class="literal">t</span><span class="comment">;; Content is not centered by default. To center, set</span></span><br><span class="line">        dashboard-vertically-center-content <span class="literal">t</span><span class="comment">;; vertically center content</span></span><br><span class="line">        dashboard-items &#x27;((recents   . <span class="number">3</span>)   ;; 显示的 widget: 最近文件、书签、项目、agenda</span><br><span class="line">                          (projects  . <span class="number">3</span>)</span><br><span class="line">                          (agenda    . <span class="number">50</span>))</span><br><span class="line">        dashboard-week-agenda <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">;; dashboard-match-agenda-entry &quot;&quot;</span></span><br><span class="line">        dashboard-projects-backend &#x27;projectile <span class="comment">;; 设置项目列表使用 Projectile</span></span><br><span class="line">        dashboard-display-icons-p <span class="literal">t</span>        <span class="comment">;; 开启显示图标</span></span><br><span class="line">        dashboard-icon-type &#x27;nerd-icons    <span class="comment">;; 使用 nerd-icons</span></span><br><span class="line">        dashboard-set-file-icons <span class="literal">t</span>         <span class="comment">;; 文件图标</span></span><br><span class="line">        dashboard-set-heading-icons <span class="literal">nil</span>)<span class="comment">;; 标题图标不显示</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> org-agenda-files &#x27;(<span class="string">&quot;~/org/todo.org&quot;</span></span><br><span class="line">                         ))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; enhancement for amx</span></span><br><span class="line">(<span class="name">use-package</span> amx</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span> (<span class="name">amx-mode</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; ;; 保存最近打开的buffers到disk</span></span><br><span class="line"><span class="comment">;; (use-package perspective</span></span><br><span class="line"><span class="comment">;;   :custom</span></span><br><span class="line"><span class="comment">;;   (persp-mode-prefix-key (kbd &quot;C-c M-p&quot;))  ; pick your own prefix key here</span></span><br><span class="line"><span class="comment">;;   (persp-state-default-file &quot;~/.emacs.d/persp-state.el&quot;) ;; 默认保存位置</span></span><br><span class="line"><span class="comment">;;   :init</span></span><br><span class="line"><span class="comment">;;   (persp-mode))</span></span><br><span class="line"><span class="comment">;; ;; 退出 Emacs 时自动保存 session</span></span><br><span class="line"><span class="comment">;; (add-hook &#x27;kill-emacs-hook #&#x27;persp-state-save)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 终端模拟器</span></span><br><span class="line">(<span class="name">use-package</span> vterm</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;预览要跳转的行</span></span><br><span class="line">(<span class="name">use-package</span> goto-line-preview <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;M-g g&quot;</span> . goto-line-preview)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;代码整行上移下移</span></span><br><span class="line">(<span class="name">use-package</span> move-dup</span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-M-p&quot;</span>   . move-dup-move-lines-up)</span><br><span class="line">         <span class="comment">;;    (&quot;C-M-p&quot; . move-dup-duplicate-up)</span></span><br><span class="line">         (<span class="string">&quot;C-M-n&quot;</span>   . move-dup-move-lines-down)</span><br><span class="line">         <span class="comment">;;    (&quot;C-M-n&quot; . move-dup-duplicate-down)</span></span><br><span class="line">         ))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> exec-path-from-shell</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">when</span> (<span class="name">memq</span> window-system &#x27;(mac ns x))</span><br><span class="line">    (<span class="name">exec-path-from-shell-initialize</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 保证在编程模式下缩进是主要行为</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;prog-mode-hook</span><br><span class="line">          (<span class="name">lambda</span> ()</span><br><span class="line">            (<span class="name">setq-local</span> indent-line-function #&#x27;indent-relative)))</span><br><span class="line"><span class="comment">;; Git工具</span></span><br><span class="line">(<span class="name">use-package</span> magit</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:defer</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-x g&quot;</span> . magit-log-all))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> markdown-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:mode</span> (<span class="string">&quot;\\.md\\&#x27;&quot;</span> . markdown-mode)</span><br><span class="line">  <span class="symbol">:init</span> (<span class="name">setq</span> markdown-command <span class="string">&quot;pandoc&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 语法解析</span></span><br><span class="line">(<span class="name">use-package</span> tree-sitter</span><br><span class="line">  <span class="symbol">:when</span> (<span class="name">and</span> (<span class="name">fboundp</span> &#x27;treesit-available-p)</span><br><span class="line">             (<span class="name">treesit-available-p</span>))</span><br><span class="line">  <span class="symbol">:config</span> (<span class="name">setq</span> treesit-font-lock-level <span class="number">4</span>)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> treesit-language-source-alist</span><br><span class="line">        &#x27;((bash       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-bash&quot;</span>))</span><br><span class="line">          (c          . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-c&quot;</span>))</span><br><span class="line">          (cpp        . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-cpp&quot;</span>))</span><br><span class="line">          (python     . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-python&quot;</span>))</span><br><span class="line">          (rust       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-rust&quot;</span>))</span><br><span class="line">          (toml       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-toml&quot;</span>))</span><br><span class="line">          (elisp      . (<span class="string">&quot;https://github.com/Wilfred/tree-sitter-elisp&quot;</span>))</span><br><span class="line">          (cmake      . (<span class="string">&quot;https://github.com/uyha/tree-sitter-cmake&quot;</span>))</span><br><span class="line">          (dockerfile . (<span class="string">&quot;https://github.com/camdencheek/tree-sitter-dockerfile&quot;</span>))</span><br><span class="line">          (make       . (<span class="string">&quot;https://github.com/alemuller/tree-sitter-make&quot;</span>))</span><br><span class="line">          (yaml       . (<span class="string">&quot;https://github.com/ikatyang/tree-sitter-yaml&quot;</span>))</span><br><span class="line">          (json       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-json&quot;</span>))</span><br><span class="line">          (java       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-java.git&quot;</span>))</span><br><span class="line">          ;;(markdown   . (<span class="string">&quot;https://github.com/MDeiml/tree-sitter-markdown&quot;</span> <span class="literal">nil</span> <span class="string">&quot;tree-sitter-markdown/src&quot;</span>))</span><br><span class="line">          ))</span><br><span class="line"></span><br><span class="line">  <span class="comment">;;没有内置&lt;languate&gt;-mode的需要添加</span></span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\.y[a]?ml\\&#x27;&quot;</span> . yaml-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\(?:Dockerfile\\(?:\\..*\\)?\\|\\.[Dd]ockerfile\\)\\&#x27;&quot;</span> . dockerfile-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\.rs\\&#x27;&quot;</span> . rust-ts-mode))</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 安装 tree-sitter 语法解析器（仅 Emacs 29+）</span></span><br><span class="line">(<span class="name">dolist</span> (<span class="name">lang</span> &#x27;(bash c cpp python rust toml elisp cmake dockerfile make yaml json java))</span><br><span class="line">  (<span class="name">unless</span> (<span class="name">treesit-language-available-p</span> lang)</span><br><span class="line">    (<span class="name">treesit-install-language-grammar</span> lang)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 优先使用 Tree-sitter mode</span></span><br><span class="line">(<span class="name">setq</span> major-mode-remap-alist</span><br><span class="line">      &#x27;((bash-mode        . bash-ts-mode)</span><br><span class="line">        (c-mode           . c-ts-mode)</span><br><span class="line">        (c++-mode         . c++-ts-mode)</span><br><span class="line">        (python-mode      . python-ts-mode)</span><br><span class="line">        (rust-mode        . rust-ts-mode)</span><br><span class="line">        (conf-toml-mode   . toml-ts-mode)</span><br><span class="line">        (elisp-mode       . elisp-ts-mode)</span><br><span class="line">        (cmake-mode       . cmake-ts-mode)</span><br><span class="line">        (dockerfile-mode  . dockerfile-ts-mode)</span><br><span class="line">        (json-mode        . json-ts-mode)</span><br><span class="line">        (java-mode        . java-ts-mode)</span><br><span class="line">        (yaml-mode        . yaml-ts-mode)</span><br><span class="line">        (makefile-mode    . makefile-ts-mode)</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; lsp语言服务器配置</span></span><br><span class="line">(<span class="name">require</span> &#x27;eglot)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> eglot-server-programs</span><br><span class="line">      &#x27;(((c++-mode c-mode c++-ts-mode c-ts-mode)     . (<span class="string">&quot;clangd&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;-j=4&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--background-index&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--clang-tidy&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--completion-style=detailed&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--header-insertion=iwyu&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--all-scopes-completion&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;--include-ineligible-results&quot;</span></span><br><span class="line">                                                        ))</span><br><span class="line">        ((rust-mode rust-ts-mode)                    . (<span class="string">&quot;rust-analyzer&quot;</span> :initializationOptions (:check (:command <span class="string">&quot;clippy&quot;</span>))))</span><br><span class="line">        ((asm-mode nasm-mode)                        . (<span class="string">&quot;asm-lsp&quot;</span>))</span><br><span class="line">        ((python-mode python-ts-mode)                . (<span class="string">&quot;pyright-langserver&quot;</span> <span class="string">&quot;--stdio&quot;</span>))</span><br><span class="line">        ;;((java-mode java-ts-mode)                    . (<span class="string">&quot;jdtls&quot;</span>))</span><br><span class="line">        ((bash-mode bash-ts-mode sh-mode sh-ts-mode) . (<span class="string">&quot;bash-language-server&quot;</span> <span class="string">&quot;start&quot;</span>))</span><br><span class="line">        ;;((markdown-mode)                             . (<span class="string">&quot;marksman&quot;</span>))</span><br><span class="line">        ;;((latex-mode LaTeX-mode)                     . (<span class="string">&quot;texlab&quot;</span>))</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> c-default-style <span class="string">&quot;stroustrup&quot;</span></span><br><span class="line">      c-basic-offset <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;关闭lsp自动格式化</span></span><br><span class="line">(<span class="name">setq</span> eglot-ignored-server-capabilities &#x27;(<span class="symbol">:documentFormattingProvider</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;自动打开eglot</span></span><br><span class="line">(<span class="name">dolist</span> (<span class="name">hook</span> &#x27;(c-mode-hook c-ts-mode-hook</span><br><span class="line">                            c++-mode-hook c++-ts-mode-hook</span><br><span class="line">                            rust-mode-hook rust-ts-mode-hook</span><br><span class="line">                            asm-mode-hook nasm-mode-hook</span><br><span class="line">                            python-mode-hook python-ts-mode-hook</span><br><span class="line">                            ;;                  java-mode-hook java-ts-mode-hook</span><br><span class="line">                            ;;                  markdown-mode-hook</span><br><span class="line">                            bash-mode-hook bash-ts-mode-hook</span><br><span class="line">                            sh-mode-hook sh-ts-mode-hook</span><br><span class="line">                            ;;                  latex-mode-hook LaTeX-mode-hook</span><br><span class="line">                            ))</span><br><span class="line">  (<span class="name">add-hook</span> hook &#x27;eglot-ensure))</span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-n&quot;</span>) #&#x27;flymake-goto-next-error)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-p&quot;</span>) #&#x27;flymake-goto-prev-error)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; eglot快捷键</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-,&quot;</span>) &#x27;xref-find-definitions)  <span class="comment">;; 跳转到定义</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-.&quot;</span>) &#x27;xref-pop-marker-stack)  <span class="comment">;; 跳回</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-?&quot;</span>) &#x27;xref-find-references)   <span class="comment">;; 查找引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 显示诊断信息（自动 hover 显示错误、警告等）</span></span><br><span class="line">(<span class="name">setq</span> eldoc-idle-delay <span class="number">0.1</span>)  <span class="comment">;; 光标停留 0.1 秒后显示提示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; comment</span></span><br><span class="line">(<span class="name">defun</span> my-cpp-line-comments ()</span><br><span class="line">  <span class="string">&quot;Use // comments instead of /* */ in C/C++.&quot;</span></span><br><span class="line">  (<span class="name">setq-local</span> comment-start <span class="string">&quot;// &quot;</span></span><br><span class="line">              comment-end <span class="string">&quot;&quot;</span></span><br><span class="line">              comment-start-skip <span class="string">&quot;//+\\s-*&quot;</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">dolist</span> (<span class="name">hook</span> &#x27;(c-mode-hook c++-mode-hook c-ts-mode-hook c++-ts-mode-hook</span><br><span class="line">                            rust-mode-hook rust-ts-mode-hook python-mode-hook python-ts-mode-hook java-mode-hook java-ts-mode-hook))</span><br><span class="line">  (<span class="name">add-hook</span> hook #&#x27;my-cpp-line-comments))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 自动补全</span></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> company</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:defer</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">after-init</span> . global-company-mode)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  <span class="comment">;; 光标停留 0 秒立即弹出补全</span></span><br><span class="line">  (<span class="name">setq</span> company-idle-delay <span class="number">0</span>)</span><br><span class="line">  <span class="comment">;; 后端</span></span><br><span class="line">  (<span class="name">setq</span> company-backends &#x27;((company-capf)))</span><br><span class="line">  <span class="comment">;; 最少 1 个字符触发补全，0 表示空白处也可以触发</span></span><br><span class="line">  (<span class="name">setq</span> company-minimum-prefix-length <span class="number">2</span>)</span><br><span class="line">  <span class="comment">;; 补全候选最多显示 20 个</span></span><br><span class="line">  (<span class="name">setq</span> company-tooltip-limit <span class="number">20</span>)</span><br><span class="line">  (<span class="name">setq</span> company-show-numbers <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">setq</span> company-dabbrev-downcase <span class="literal">nil</span>)</span><br><span class="line">  <span class="comment">;; 2023-01-13 From a Reddit post on mixed case issue.</span></span><br><span class="line">  (<span class="name">setq</span> company-dabbrev-ignore-case <span class="literal">nil</span>)</span><br><span class="line">  (<span class="name">setq</span> company-dabbrev-code-ignore-case <span class="literal">nil</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; GDB配置</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;gud-mode-hook (<span class="name">lambda</span> () (<span class="name">company-mode</span> <span class="number">-1</span>))) <span class="comment">;; gud模式下禁用 company</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; Force gdb-mi to not dedicate any windows</span></span><br><span class="line">(<span class="name">advice-add</span> &#x27;gdb-display-buffer</span><br><span class="line">    <span class="symbol">:around</span> (<span class="name">lambda</span> (<span class="name">orig-fun</span> <span class="symbol">&amp;rest</span> r)</span><br><span class="line">      (<span class="name">let</span> ((<span class="name">window</span> (<span class="name">apply</span> orig-fun r)))</span><br><span class="line">(<span class="name">set-window-dedicated-p</span> window <span class="literal">nil</span>)</span><br><span class="line">window)))</span><br><span class="line"></span><br><span class="line">(<span class="name">advice-add</span> &#x27;gdb-set-window-buffer</span><br><span class="line">    <span class="symbol">:around</span> (<span class="name">lambda</span> (<span class="name">orig-fun</span> name <span class="symbol">&amp;optional</span> ignore-dedicated window)</span><br><span class="line">      (<span class="name">funcall</span> orig-fun name ignore-dedicated window)</span><br><span class="line">      (<span class="name">set-window-dedicated-p</span> window <span class="literal">nil</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> my-gdb ()</span><br><span class="line">  <span class="string">&quot;启动GDB时禁用默认~/.gdbinit，仅加载指定配置&quot;</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">let*</span> ((<span class="name">extra-args</span> (<span class="name">read-string</span> <span class="string">&quot;gdb arguments: &quot;</span>))</span><br><span class="line">         (<span class="name">fixed-args</span> <span class="string">&quot;-n -ex \&quot;set debuginfod enabled on\&quot; -ex \&quot;set confirm off\&quot; -ex \&quot;set print pretty on\&quot;&quot;</span>)</span><br><span class="line">         (<span class="name">full-command</span> (<span class="name">if</span> (<span class="name">string-empty-p</span> extra-args)</span><br><span class="line">                           (<span class="name">format</span> <span class="string">&quot;gdb -i=mi %s&quot;</span> fixed-args)</span><br><span class="line">                         (<span class="name">format</span> <span class="string">&quot;gdb -i=mi %s %s&quot;</span> fixed-args extra-args))))</span><br><span class="line">    (<span class="name">message</span> <span class="string">&quot;execute: %s ?&quot;</span> full-command)</span><br><span class="line">    (<span class="name">gdb</span> full-command)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 不使用独立的io buffer</span></span><br><span class="line">(<span class="name">setq</span> gdb-use-separate-io-buffer <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">;; 启动时显示main函数</span></span><br><span class="line">(<span class="name">setq</span> gdb-show-main <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">;; 禁用多窗口布局</span></span><br><span class="line">(<span class="name">setq</span> gdb-many-windows <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 打开GDB后关闭不必要的缓冲区，使用前缀匹配EGLOT相关缓冲区</span></span><br><span class="line">(<span class="name">defun</span> my/kill-gdb-unwanted-buffers ()</span><br><span class="line">  <span class="string">&quot;打开 GDB 后关闭不必要 buffer，包括所有以*EGLOT开头的缓冲区。&quot;</span></span><br><span class="line">  <span class="comment">;; 首先关闭明确指定的缓冲区</span></span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">buf</span> &#x27;(<span class="string">&quot;*Async-native-compile-log*&quot;</span>))</span><br><span class="line">    (<span class="name">when</span> (<span class="name">buffer-live-p</span> (<span class="name">get-buffer</span> buf))</span><br><span class="line">      (<span class="name">kill-buffer</span> (<span class="name">get-buffer</span> buf))))</span><br><span class="line"></span><br><span class="line">  <span class="comment">;; 然后处理以*EGLOT开头的所有缓冲区（前缀匹配）</span></span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">buf</span> (<span class="name">buffer-list</span>))</span><br><span class="line">    (<span class="name">let</span> ((<span class="name">buf-name</span> (<span class="name">buffer-name</span> buf)))</span><br><span class="line">      (<span class="name">when</span> (<span class="name">and</span> buf-name (<span class="name">string-prefix-p</span> <span class="string">&quot;*EGLOT &quot;</span> buf-name))</span><br><span class="line">        (<span class="name">when</span> (<span class="name">buffer-live-p</span> buf)</span><br><span class="line">          (<span class="name">kill-buffer</span> buf))))))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> &#x27;gdb-mode-hook #&#x27;my/kill-gdb-unwanted-buffers)</span><br><span class="line"><span class="comment">;; 模糊匹配算法</span></span><br><span class="line">(<span class="name">use-package</span> flx</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> company-fuzzy</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:after</span> company</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">company-mode</span> . company-fuzzy-mode)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> company-fuzzy-sorting-backend &#x27;flx         <span class="comment">;; 选择模糊匹配算法</span></span><br><span class="line">        company-fuzzy-reset-selection <span class="literal">t</span>           <span class="comment">;; 选中候选时重置到第一个</span></span><br><span class="line">        company-fuzzy-prefix-on-top <span class="literal">nil</span>           <span class="comment">;; 是否把 prefix 值置顶</span></span><br><span class="line">        company-fuzzy-trigger-symbols &#x27;(<span class="string">&quot;.&quot;</span> <span class="string">&quot;-&gt;&quot;</span>)  <span class="comment">;; 触发符号</span></span><br><span class="line">        company-fuzzy-show-annotation <span class="literal">t</span>           <span class="comment">;; 显示注释</span></span><br><span class="line">        company-fuzzy-passthrough-backends &#x27;(company-capf)) <span class="comment">;; 排除部分 backend</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  <span class="comment">;; 全局启用</span></span><br><span class="line">  (<span class="name">global-company-fuzzy-mode</span> <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> imenu-list</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> imenu-list-focus-after-activation <span class="literal">t</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 格式化</span></span><br><span class="line">(<span class="name">use-package</span> format-all</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:commands</span> format-all-mode</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . format-all-mode)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  <span class="comment">;; 不在保存时自动格式化</span></span><br><span class="line">  (<span class="name">remove-hook</span> &#x27;before-save-hook &#x27;format-all-buffer <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">setq-default</span> format-all-formatters</span><br><span class="line">                &#x27;((<span class="string">&quot;C&quot;</span> (clang-format))</span><br><span class="line">                  (<span class="string">&quot;C++&quot;</span>     (clang-format))</span><br><span class="line">                  (<span class="string">&quot;Rust&quot;</span> (rustfmt))</span><br><span class="line">                  )))</span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-x f&quot;</span>) &#x27;format-all-buffer)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 代码模板</span></span><br><span class="line"><span class="comment">;; YASnippet 配置</span></span><br><span class="line">(<span class="name">use-package</span> yasnippet</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . yas-minor-mode)  <span class="comment">;; 只在编程模式启用</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  <span class="comment">;; 启动时加载所有 snippet</span></span><br><span class="line">  (<span class="name">yas-reload-all</span>)</span><br><span class="line">  <span class="comment">;; 设置 snippet 目录</span></span><br><span class="line">  (<span class="name">setq</span> yas-snippet-dirs</span><br><span class="line">        &#x27;(<span class="string">&quot;~/.emacs.d/snippets&quot;</span>        ;; 个人片段</span><br><span class="line">          <span class="string">&quot;~/.emacs.d/elpa/yasnippet-snippets-*/snippets&quot;</span>))) <span class="comment">;; 社区合集</span></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> yasnippet-snippets</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:after</span> yasnippet)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; which-key 显示键绑定提示</span></span><br><span class="line">(<span class="name">use-package</span> which-key</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">which-key-mode</span>))</span><br><span class="line"><span class="comment">;; 窗格切换</span></span><br><span class="line">(<span class="name">use-package</span> ace-window</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;M-o&quot;</span> . ace-window)))</span><br><span class="line"><span class="comment">;; 窗格移动</span></span><br><span class="line">(<span class="name">use-package</span> buffer-move</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-c &lt;up&gt;&quot;</span>    . buf-move-up)</span><br><span class="line">         (<span class="string">&quot;C-c &lt;down&gt;&quot;</span>  . buf-move-down)</span><br><span class="line">         (<span class="string">&quot;C-c &lt;left&gt;&quot;</span>  . buf-move-left)</span><br><span class="line">         (<span class="string">&quot;C-c &lt;right&gt;&quot;</span> . buf-move-right)))</span><br><span class="line"><span class="comment">;; 智能按键C-a C-c k</span></span><br><span class="line">(<span class="name">use-package</span> crux</span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-a&quot;</span> . &#x27;crux-move-beginning-of-line)</span><br><span class="line">         (<span class="string">&quot;C-c k&quot;</span> . &#x27;crux-smart-kill-line)))</span><br><span class="line"><span class="comment">;; 项目识别,通过创建.projectile文件识别为一个项目</span></span><br><span class="line">(<span class="name">use-package</span> projectile</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">projectile-mode</span> <span class="number">+1</span>)</span><br><span class="line">  <span class="symbol">:bind-keymap</span></span><br><span class="line">  (<span class="string">&quot;C-c p&quot;</span> . projectile-command-map)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> projectile-project-search-path &#x27;(<span class="string">&quot;~/repository&quot;</span>))</span><br><span class="line">  (<span class="name">setq</span> projectile-completion-system &#x27;auto) <span class="comment">;; 或 ivy / helm / default</span></span><br><span class="line">  (<span class="name">use-package</span> rg</span><br><span class="line">    <span class="symbol">:ensure</span> <span class="literal">t</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 快捷键定义必须放在后面否则容易被其他插件覆盖</span></span><br><span class="line"><span class="comment">;;enhancement for help</span></span><br><span class="line">(<span class="name">use-package</span> helpful</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span></span><br><span class="line">  ((<span class="string">&quot;C-h f&quot;</span> . helpful-callable)    <span class="comment">;; 替换 describe-function</span></span><br><span class="line">   (<span class="string">&quot;C-h v&quot;</span> . helpful-variable)    <span class="comment">;; 替换 describe-variable</span></span><br><span class="line">   (<span class="string">&quot;C-h k&quot;</span> . helpful-key)         <span class="comment">;; 替换 describe-key</span></span><br><span class="line">   (<span class="string">&quot;C-h x&quot;</span> . helpful-command)     <span class="comment">;; 替换 describe-command</span></span><br><span class="line">   (<span class="string">&quot;C-c C-d&quot;</span> . helpful-at-point)  <span class="comment">;; 光标下符号</span></span><br><span class="line">   (<span class="string">&quot;C-h F&quot;</span> . helpful-function)))  <span class="comment">;; 查看函数，不含宏</span></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> kill-other-buffers ()</span><br><span class="line">  <span class="string">&quot;Kill all buffers except the current one.&quot;</span></span><br><span class="line">  (<span class="name">interactive</span>)</span><br><span class="line">  (<span class="name">mapc</span> (<span class="name">lambda</span> (<span class="name">buf</span>)</span><br><span class="line">          (<span class="name">unless</span> (<span class="name">eq</span> buf (<span class="name">current-buffer</span>))</span><br><span class="line">            (<span class="name">kill-buffer</span> buf)))</span><br><span class="line">        (<span class="name">buffer-list</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 快捷键绑定：使用调整窗口大小</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-&lt;up&gt;&quot;</span>)    &#x27;enlarge-window)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-&lt;down&gt;&quot;</span>)  &#x27;shrink-window)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-&lt;left&gt;&quot;</span>)  &#x27;shrink-window-horizontally)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;M-&lt;right&gt;&quot;</span>) &#x27;enlarge-window-horizontally)</span><br><span class="line"><span class="comment">;; 关闭其他buffers</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c k&quot;</span>) #&#x27;kill-other-buffers)</span><br><span class="line"><span class="comment">;;撤销</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-/&quot;</span>) &#x27;undo-only)</span><br><span class="line"><span class="comment">;;撤销刚才的撤销</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-?&quot;</span>) &#x27;undo-redo)</span><br><span class="line"><span class="comment">;;全局搜索</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c C-s&quot;</span>) &#x27;projectile-ripgrep)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c i&quot;</span>) #&#x27;imenu-list-minor-mode)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c C-t&quot;</span>) #&#x27;vterm-other-window)</span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-c C-g&quot;</span>) #&#x27;my-gdb)</span><br><span class="line"></span><br><span class="line">(<span class="name">custom-set-variables</span></span><br><span class="line"> <span class="comment">;; custom-set-variables was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won&#x27;t work right.</span></span><br><span class="line"> &#x27;(package-selected-packages nil))</span><br><span class="line">(<span class="name">custom-set-faces</span></span><br><span class="line"> <span class="comment">;; custom-set-faces was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won&#x27;t work right.</span></span><br><span class="line"> )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="clang-format-配置"><a href="#clang-format-配置" class="headerlink" title=".clang-format 配置"></a>.clang-format 配置</h2><p>直接用的 Linux Kernel 的配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># clang-format configuration file. Intended for clang-format &gt;= 11.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For more information, see:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   Documentation/dev-tools/clang-format.rst</span></span><br><span class="line"><span class="comment">#   https://clang.llvm.org/docs/ClangFormat.html</span></span><br><span class="line"><span class="comment">#   https://clang.llvm.org/docs/ClangFormatStyleOptions.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-4</span></span><br><span class="line"><span class="attr">AlignAfterOpenBracket:</span> <span class="string">Align</span></span><br><span class="line"><span class="attr">AlignConsecutiveAssignments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlignConsecutiveDeclarations:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlignEscapedNewlines:</span> <span class="string">Left</span></span><br><span class="line"><span class="attr">AlignOperands:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">AlignTrailingComments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AllowAllParametersOfDeclarationOnNextLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AllowShortBlocksOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AllowShortFunctionsOnASingleLine:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">AllowShortIfStatementsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AllowShortLoopsOnASingleLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterDefinitionReturnType:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">AlwaysBreakAfterReturnType:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">AlwaysBreakTemplateDeclarations:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BinPackArguments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BinPackParameters:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BraceWrapping:</span></span><br><span class="line">  <span class="attr">AfterClass:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterControlStatement:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterEnum:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterFunction:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">AfterNamespace:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">AfterObjCDeclaration:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterStruct:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterUnion:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">AfterExternBlock:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">BeforeCatch:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">BeforeElse:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">IndentBraces:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">SplitEmptyFunction:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">SplitEmptyRecord:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">SplitEmptyNamespace:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">BreakBeforeBinaryOperators:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">BreakBeforeBraces:</span> <span class="string">Custom</span></span><br><span class="line"><span class="attr">BreakBeforeInheritanceComma:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakBeforeTernaryOperators:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakConstructorInitializersBeforeComma:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakConstructorInitializers:</span> <span class="string">BeforeComma</span></span><br><span class="line"><span class="attr">BreakAfterJavaFieldAnnotations:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">BreakStringLiterals:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ColumnLimit:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">CommentPragmas:</span> <span class="string">&quot;^ IWYU pragma:&quot;</span></span><br><span class="line"><span class="attr">CompactNamespaces:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ConstructorInitializerAllOnOneLineOrOnePerLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ConstructorInitializerIndentWidth:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">ContinuationIndentWidth:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">Cpp11BracedListStyle:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">DerivePointerAlignment:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">DisableFormat:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">ExperimentalAutoDetectBinPacking:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">FixNamespaceComments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">IncludeBlocks:</span> <span class="string">Preserve</span></span><br><span class="line"><span class="attr">IncludeCategories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Regex:</span> <span class="string">&quot;.*&quot;</span></span><br><span class="line">    <span class="attr">Priority:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">IncludeIsMainRegex:</span> <span class="string">&quot;(Test)?$&quot;</span></span><br><span class="line"><span class="attr">IndentCaseLabels:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">IndentGotoLabels:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">IndentPPDirectives:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">IndentWrappedFunctionNames:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">JavaScriptQuotes:</span> <span class="string">Leave</span></span><br><span class="line"><span class="attr">JavaScriptWrapImports:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">KeepEmptyLinesAtTheStartOfBlocks:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">MacroBlockBegin:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">MacroBlockEnd:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">MaxEmptyLinesToKeep:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">NamespaceIndentation:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">ObjCBinPackProtocolList:</span> <span class="string">Auto</span></span><br><span class="line"><span class="attr">ObjCBlockIndentWidth:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">ObjCSpaceAfterProperty:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">ObjCSpaceBeforeProtocolList:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Taken from git&#x27;s rules</span></span><br><span class="line"><span class="attr">PenaltyBreakAssignment:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">PenaltyBreakBeforeFirstCallParameter:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">PenaltyBreakComment:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">PenaltyBreakFirstLessLess:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">PenaltyBreakString:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">PenaltyExcessCharacter:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">PenaltyReturnTypeOnItsOwnLine:</span> <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Right</span></span><br><span class="line"><span class="attr">ReflowComments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SortIncludes:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SortUsingDeclarations:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpaceAfterCStyleCast:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpaceAfterTemplateKeyword:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeAssignmentOperators:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeCtorInitializerColon:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeInheritanceColon:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceBeforeParens:</span> <span class="string">ControlStatementsExceptForEachMacros</span></span><br><span class="line"><span class="attr">SpaceBeforeRangeBasedForLoopColon:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">SpaceInEmptyParentheses:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesBeforeTrailingComments:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">SpacesInAngles:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesInContainerLiterals:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesInCStyleCastParentheses:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesInParentheses:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SpacesInSquareBrackets:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Standard:</span> <span class="string">Cpp03</span></span><br><span class="line"><span class="attr">TabWidth:</span> <span class="number">8</span></span><br><span class="line"><span class="attr">UseTab:</span> <span class="string">Always</span></span><br></pre></td></tr></table></figure><h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo//202508032237463.png" alt="preview"></p><h1 id="快捷键配置总览"><a href="#快捷键配置总览" class="headerlink" title="快捷键配置总览"></a>快捷键配置总览</h1><div class="table-container"><table><thead><tr><th>快捷键</th><th>功能描述</th><th>来源配置</th></tr></thead><tbody><tr><td><strong>C-/</strong></td><td>撤销（undo-only）</td><td>手动绑定</td></tr><tr><td><strong>C-?</strong></td><td>重做（undo-redo）</td><td>手动绑定</td></tr><tr><td><strong>M-</strong></td><td>增大当前窗口高度</td><td>手动绑定</td></tr><tr><td><strong>M-</strong></td><td>减小当前窗口高度</td><td>手动绑定</td></tr><tr><td><strong>M-</strong></td><td>减小当前窗口宽度</td><td>手动绑定</td></tr><tr><td><strong>M-</strong></td><td>增大当前窗口宽度</td><td>手动绑定</td></tr><tr><td><strong>C-</strong></td><td>切换到前一个 Tab（Centaur Tabs）</td><td><code>centaur-tabs</code></td></tr><tr><td><strong>C-</strong></td><td>切换到下一个 Tab</td><td><code>centaur-tabs</code></td></tr><tr><td><strong>M-g g</strong></td><td>预览跳转到指定行（goto-line-preview）</td><td><code>goto-line-preview</code></td></tr><tr><td><strong>M-C-p</strong></td><td>将当前行上移</td><td><code>move-dup</code></td></tr><tr><td><strong>M-C-n</strong></td><td>将当前行下移</td><td><code>move-dup</code></td></tr><tr><td><strong>M-p</strong></td><td>下一个错误</td><td><code>flymake</code></td></tr><tr><td><strong>M-n</strong></td><td>上一个错误</td><td><code>flymake</code></td></tr><tr><td><strong>f8</strong></td><td>打开/关闭文件树侧边栏（neotree）</td><td><code>neotree</code></td></tr><tr><td><strong>C-x g</strong></td><td>查看当前 Git 仓库的所有提交</td><td><code>magit</code></td></tr><tr><td><strong>C-x f</strong></td><td>格式化当前 buffer（clang-format / rustfmt）</td><td><code>format-all</code></td></tr><tr><td><strong>M-,</strong></td><td>跳转到定义（xref-find-definitions，需 LSP 支持）</td><td>手动绑定</td></tr><tr><td><strong>M-.</strong></td><td>跳回上一个位置（xref-pop-marker-stack）</td><td>手动绑定</td></tr><tr><td><strong>M-?</strong></td><td>查找引用（xref-find-references，需 LSP 支持）</td><td>手动绑定</td></tr><tr><td><strong>M-o</strong></td><td>在多个窗口间切换焦点</td><td><code>ace-window</code></td></tr><tr><td><strong>C-c</strong></td><td>当前 buffer 上移到另一个窗口</td><td><code>buffer-move</code></td></tr><tr><td><strong>C-c</strong></td><td>当前 buffer 下移到另一个窗口</td><td><code>buffer-move</code></td></tr><tr><td><strong>C-c</strong></td><td>当前 buffer 左移到另一个窗口</td><td><code>buffer-move</code></td></tr><tr><td><strong>C-c</strong></td><td>当前 buffer 右移到另一个窗口</td><td><code>buffer-move</code></td></tr><tr><td><strong>C-a</strong></td><td>智能移动光标到行首（再次按可回到代码开始处）</td><td><code>crux</code></td></tr><tr><td><strong>C-c k</strong></td><td>智能删除一行（不会破坏缩进）</td><td><code>crux</code></td></tr><tr><td><strong>C-c p</strong></td><td>Projectile 项目命令前缀</td><td><code>projectile</code></td></tr><tr><td><strong>C-x SPC</strong></td><td>矩形选择模式，可以选择某些列</td><td>内置</td></tr></tbody></table></div><p><strong> M-X projectile-ripgrep</strong></p><ul><li>neotree<ul><li><strong>M-x neotree-create-node</strong> 创建文件，也可以用<strong>C-c n</strong></li><li><strong>M-x neotree-delete-node</strong> 删除文件</li><li><strong>M-x neotree-rename-node</strong> 重命名文件</li></ul></li><li><strong>M-x persp-state-load</strong> 打开上次打开的 buffer</li><li><strong>M-x recenter</strong> 把当前行放在窗口中间</li><li><strong>M-x eglot-code-actions</strong>对于 lsp 提示 fix available 的可以让 lsp 修改</li><li><strong>C-c C-s</strong> 项目里全局查找</li><li><strong>C-c i</strong> 展示 imenu</li></ul><h1 id="编程设置"><a href="#编程设置" class="headerlink" title="编程设置"></a>编程设置</h1><p>有 makefile 的 project</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">bear -- make</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emacs </tag>
            
            <tag> GNU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下基于edk2的UEFI开发环境搭建</title>
      <link href="/posts/42853/"/>
      <url>/posts/42853/</url>
      
        <content type="html"><![CDATA[<p>——————<br><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-01-10</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><br>——————</p><h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><p>这是我的硬件环境及操作系统</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/pc_environment.png" alt="硬件环境"></p><h2 id="下载-edk2-源码"><a href="#下载-edk2-源码" class="headerlink" title="下载 edk2 源码"></a>下载 edk2 源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装需要的软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install git</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/UEFI</span><br><span class="line"><span class="built_in">cd</span> UEFI</span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://github.com/tianocore/edk2.git&quot;</span></span><br><span class="line"><span class="built_in">cd</span> edk2</span><br><span class="line"><span class="comment"># 使用这个分支</span></span><br><span class="line">git checkout origin/stable/202408</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">git branch</span><br><span class="line"><span class="comment"># 查看子模块是否都已正确初始化，如果子模块未下载完毕，编译时会有一些问题</span></span><br><span class="line">git submodule status</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="comment"># 下载edk2-libc的代码，这个主要是为了在UEFI开发中使用c标准库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tianocore/edk2-libc.git</span><br><span class="line"><span class="comment"># 创建code文件夹用于存放我们自己的代码</span></span><br><span class="line"><span class="built_in">mkdir</span> -p code</span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载一些基本软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install python3 python3-distutils uuid-dev build-essential bison flex nasm acpica-tools gcc</span><br><span class="line"><span class="comment"># 安装arm的编译器, 这里主要是为了编译aarch64的</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/UEFI/toolchain</span><br><span class="line"><span class="built_in">cd</span> ~/UEFI/toolchain</span><br><span class="line">wget https://developer.arm.com/-/media/Files/downloads/gnu-a/8.2-2019.01/gcc-arm-8.2-2019.01-x86_64-aarch64-elf.tar.xz</span><br><span class="line">tar -xf gcc-arm-8.2-2019.01-x86_64-aarch64-elf.tar.xz</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p>下面来通过一个例子 HelloWorld 来实现实现编译 UEFI 代码到目标平台为 x64 或 aarch64, 并支持在 Emulator 和 qemu 中运行, 最后用 gdb 调试程序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> HelloWorld.dsc</span><br><span class="line"><span class="built_in">touch</span> HelloWorld.inf</span><br><span class="line"><span class="built_in">touch</span> HelloWorld.c</span><br><span class="line"><span class="comment"># 这个命令行工具可以生成uuid, 后面的dsc和inf中的uuid都是这样生成的</span></span><br><span class="line">uuidgen</span><br></pre></td></tr></table></figure><p><strong>HelloWorld.dsc</strong></p><p>DSC 文件是包描述文件，其中<strong>Defines</strong>中的所有字段都是强制性的。</p><p>对于 LibraryClasses 中的路径可以通过以下命令查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> edk2</span><br><span class="line"><span class="comment"># 以UefiApplicationEntryPoint为例</span></span><br><span class="line">grep UefiApplicationEntryPoint -r ./ --include=*.inf | grep LIBRARY_CLASS</span><br><span class="line"><span class="comment"># 通过GUID查找</span></span><br><span class="line">grep -i 752F3136 -r ./ --exclude-dir=Build</span><br></pre></td></tr></table></figure><p>LibraryClasses 的格式是</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibraryClassName|Path/To/LibInstanceName.inf</span><br></pre></td></tr></table></figure><p>对于 DSC 文件的完整解释，参考以下链接：<br><div class="tag link"><a class="link-card" title="INF-Specification" href="https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/"><div class="left"><img src="https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/gitbook/images/favicon.ico"/></div><div class="right"><p class="text">INF-Specification</p><p class="url">https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/</p></div></a></div></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Defines]</span></span><br><span class="line">  <span class="attr">DSC_SPECIFICATION</span>         = <span class="number">0</span>x0001001A</span><br><span class="line">  <span class="attr">PLATFORM_GUID</span>             = c08977d4-<span class="number">6</span>e87-<span class="number">42</span>f6-bf5c-<span class="number">4</span>d41cfe7ba53</span><br><span class="line">  <span class="attr">PLATFORM_VERSION</span>          = <span class="number">0.01</span></span><br><span class="line">  <span class="attr">PLATFORM_NAME</span>             = HelloWorld</span><br><span class="line">  <span class="attr">SKUID_IDENTIFIER</span>          = DEFAULT</span><br><span class="line">  <span class="attr">SUPPORTED_ARCHITECTURES</span>   = AARCH64|X64</span><br><span class="line">  <span class="attr">BUILD_TARGETS</span>             = DEBUG|RELEASE|NOOPT</span><br><span class="line">  <span class="attr">OUTPUT_DIRECTORY</span>          = $(PKG_OUTPUT_DIR)</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses]</span></span><br><span class="line">  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf</span><br><span class="line">  BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf</span><br><span class="line">  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf</span><br><span class="line">  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf</span><br><span class="line">  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf</span><br><span class="line">  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf</span><br><span class="line">  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf</span><br><span class="line">  ShellCEntryLib|ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf</span><br><span class="line">  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf</span><br><span class="line">  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf</span><br><span class="line">  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf</span><br><span class="line"></span><br><span class="line">  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf</span><br><span class="line">  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses.ARM,LibraryClasses.AARCH64]</span></span><br><span class="line">  NULL|ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf</span><br><span class="line">  NULL|MdePkg/Library/BaseStackCheckLib/BaseStackCheckLib.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses.X64]</span></span><br><span class="line">  RegisterFilterLib|MdePkg/Library/RegisterFilterLibNull/RegisterFilterLibNull.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[Components]</span></span><br><span class="line">  HelloWorld.inf</span><br></pre></td></tr></table></figure><p><strong>HelloWorld.inf</strong></p><p>INF 文件是 edk2 app 的配置文件，其中</p><ul><li>[Defines] 该节定义了一些模块的基本信息<ul><li>BASE_NAME app 的名称</li><li>FILE_GUID 可以通过命令 uuidgen 生成，UEFI 通过 GUID 来区分不同的模块</li><li>MODULE_TYPE 这里填 UEFI_APPLICATION</li><li>ENTRY_POINT c 代码中的主函数的名称</li></ul></li><li>[Sources] 模块的源代码，一般是.c,.h 文件</li><li>[Packages] 需要使用到的包</li><li>[LibraryClasses] 需要使用到的库</li></ul><p>对于 INF 文件的完整解释，参考以下链接：<br><div class="tag link"><a class="link-card" title="INF-Specification" href="https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/"><div class="left"><img src="https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/gitbook/images/favicon.ico"/></div><div class="right"><p class="text">INF-Specification</p><p class="url">https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/</p></div></a></div></p><p>下面是定义的一个简单的模块</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Variables defined to be used during the build process</span></span><br><span class="line"><span class="section">[Defines]</span></span><br><span class="line">  <span class="attr">INF_VERSION</span>       = <span class="number">1.25</span></span><br><span class="line">  <span class="attr">BASE_NAME</span>         = HelloWorld</span><br><span class="line">  <span class="attr">FILE_GUID</span>         = <span class="number">5455334</span>b-dbd9-<span class="number">4</span>f95-b6ed-<span class="number">5</span>ae261a6a0c1</span><br><span class="line">  <span class="attr">MODULE_TYPE</span>       = UEFI_APPLICATION</span><br><span class="line">  <span class="attr">VERSION_STRING</span>    = <span class="number">1.0</span></span><br><span class="line">  <span class="attr">ENTRY_POINT</span>       = UefiMain</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source code</span></span><br><span class="line"><span class="section">[Sources]</span></span><br><span class="line">  HelloWorld.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required packages</span></span><br><span class="line"><span class="section">[Packages]</span></span><br><span class="line">  MdePkg/MdePkg.dec            <span class="comment"># Contains Uefi and UefiLib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Required Libraries</span></span><br><span class="line"><span class="section">[LibraryClasses]</span></span><br><span class="line">  UefiApplicationEntryPoint    <span class="comment"># Uefi application entry point</span></span><br><span class="line">  UefiLib                      <span class="comment"># UefiLib</span></span><br><span class="line">  UefiBootServicesTableLib</span><br></pre></td></tr></table></figure><p><strong>HelloWorld.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  Print(<span class="string">L&quot;Hello World!!!\n&quot;</span>);</span><br><span class="line">  SystemTable-&gt;BootServices-&gt;Stall(<span class="number">10000000</span>);</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h2><p>首先我们需要创建一个脚本，用于设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> env.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x env.sh</span><br></pre></td></tr></table></figure><p><strong>env.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 项目名称,也是源代码的源文件目录</span></span><br><span class="line"><span class="built_in">export</span> PROJ_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># dsc文件名</span></span><br><span class="line"><span class="built_in">export</span> DSC_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># inf文件名</span></span><br><span class="line"><span class="built_in">export</span> INF_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># 也是编译生成的*.efi的名字，在inf的BASE_NAME中定义</span></span><br><span class="line"><span class="built_in">export</span> INF_BASE_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># UEFI 工作目录</span></span><br><span class="line"><span class="built_in">export</span> UEFI_WORKSPACE=<span class="string">&quot;<span class="variable">$HOME</span>/UEFI&quot;</span></span><br><span class="line"><span class="comment"># EDK II 路径</span></span><br><span class="line"><span class="built_in">export</span> EDK_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/edk2&quot;</span></span><br><span class="line"><span class="comment"># EDK II libc路径</span></span><br><span class="line"><span class="built_in">export</span> EDK_LIBC_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/edk2-libc&quot;</span></span><br><span class="line"><span class="comment"># 应用代码路径</span></span><br><span class="line"><span class="built_in">export</span> APP_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/code/<span class="variable">$PROJ_NAME</span>&quot;</span></span><br><span class="line"><span class="comment"># 构建输出目录</span></span><br><span class="line"><span class="built_in">export</span> PKG_OUTPUT_DIR=<span class="string">&quot;<span class="variable">$APP_PATH</span>/Build&quot;</span></span><br><span class="line"><span class="comment"># 模拟器路径</span></span><br><span class="line"><span class="built_in">export</span> EMULATOR_PATH=<span class="string">&quot;<span class="variable">$EDK_PATH</span>/Build/EmulatorX64/DEBUG_GCC5/X64&quot;</span></span><br><span class="line"><span class="comment"># 包路径设置，支持多个路径，用冒号分隔</span></span><br><span class="line"><span class="built_in">export</span> PACKAGES_PATH=<span class="string">&quot;<span class="variable">$EDK_PATH</span>:<span class="variable">$EDK_LIBC_PATH</span>:<span class="variable">$APP_PATH</span>&quot;</span></span><br><span class="line"><span class="comment"># 指定 Python 解释器</span></span><br><span class="line"><span class="built_in">export</span> PYTHON_COMMAND=<span class="string">&quot;/usr/bin/python3&quot;</span></span><br><span class="line"><span class="comment"># 确认设置完成</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Environment variables for <span class="variable">$PROJ_NAME</span> project are configured.&quot;</span></span><br></pre></td></tr></table></figure><p>接下写一个脚本实现编译我们的代码到 x64 目标平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> build-x64.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x build-x64.sh</span><br></pre></td></tr></table></figure><p><strong>build-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"></span><br><span class="line"><span class="comment"># Building BaseTools</span></span><br><span class="line">make -C <span class="variable">$EDK_PATH</span>/BaseTools</span><br><span class="line"><span class="comment"># 这里设置-b参数为DEBUG，需要部署时用RELEASE</span></span><br><span class="line"><span class="comment"># -p --platform=</span></span><br><span class="line"><span class="comment"># -m --module=</span></span><br><span class="line"><span class="comment"># -a --arch=</span></span><br><span class="line"><span class="comment"># -b --buildtarget=</span></span><br><span class="line"><span class="comment"># -t --taggname=</span></span><br><span class="line">build -p <span class="variable">$APP_PATH</span>/<span class="variable">$DSC_NAME</span>.dsc -m <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>.inf -a X64 -t GCC5 -b DEBUG -D PKG_OUTPUT_DIR=<span class="variable">$PKG_OUTPUT_DIR</span></span><br></pre></td></tr></table></figure><p>编译到 aarch64 平台同理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> build-aarch64.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x build-aarch64.sh</span><br></pre></td></tr></table></figure><p><strong>build-aarch64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5_AARCH64_PREFIX=<span class="variable">$UEFI_WORKSPACE</span>/toolchain/gcc-arm-8.2-2019.01-x86_64-aarch64-elf/bin/aarch64-elf-</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"></span><br><span class="line"><span class="comment"># Building BaseTools</span></span><br><span class="line">make -C <span class="variable">$EDK_PATH</span>/BaseTools</span><br><span class="line"></span><br><span class="line">build -p <span class="variable">$APP_PATH</span>/<span class="variable">$DSC_NAME</span>.dsc -m <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>.inf -a AARCH64 -t GCC5 -b DEBUG -D PKG_OUTPUT_DIR=<span class="variable">$PKG_OUTPUT_DIR</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="Emulator-运行"><a href="#Emulator-运行" class="headerlink" title="Emulator 运行"></a>Emulator 运行</h3><p>最后我们写一个脚本在 edk2 自带的模拟器上运行一下, 注意<strong>这里需要你有 gui 环境</strong>, 如果是只有命令行则跳过这一步, 看下面一节用 qemu 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> run.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x run.sh</span><br></pre></td></tr></table></figure><p><strong>run.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="comment"># Emulator编译,编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -p <span class="variable">$EDK_PATH</span>/EmulatorPkg/EmulatorPkg.dsc -t GCC5 -a X64</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p <span class="variable">$EMULATOR_PATH</span>/UEFI_Disk</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.efi <span class="variable">$EMULATOR_PATH</span>/UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EMULATOR_PATH</span></span><br><span class="line">./Host</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="qemu-运行"><a href="#qemu-运行" class="headerlink" title="qemu 运行"></a>qemu 运行</h3><p>首先编译并安装 qemu,这里我选择 8.1.5 的版本, 如果你的没有达到预期的效果可以考虑使用这个版本的 qemu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/qemu-project/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout stable-8.1</span><br><span class="line"><span class="built_in">sudo</span> apt install python3-venv python3-pip python3-setuptools python3-sphinx ninja-build pkg-config libglib2.0-dev libpixman-1-dev</span><br><span class="line"><span class="comment"># x86_64</span></span><br><span class="line">./configure --target-list=x86_64-softmmu</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="comment"># aarch64</span></span><br><span class="line">./configure --target-list=aarch64-softmmu</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure><p>接下来写脚本用 qemu 运行, 这里一些参数是为下一节用 gdb 调试程序用的, 但如果你只是想用 qemu 运行一下也不影响</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> debug.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x debug.sh</span><br></pre></td></tr></table></figure><p><strong>debug-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="comment"># 编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -a X64 -p OvmfPkg/OvmfPkgX64.dsc -t GCC5 -b DEBUG <span class="comment">#-D SOURCE_DEBUG_ENABLE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$APP_PATH</span></span><br><span class="line"><span class="built_in">mkdir</span> -p _ovmf_dbg</span><br><span class="line"><span class="built_in">cd</span> _ovmf_dbg</span><br><span class="line"><span class="built_in">rm</span> -f debug.log</span><br><span class="line"><span class="comment"># 与ubuntu22.04软件源默认的qemu不兼容，需要升级qemu版本到v8.1.5</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$EDK_PATH</span>/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd ./</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p UEFI_Disk</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.efi ./UEFI_Disk/</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.debug ./UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 启用 GDB 调试，默认监听在 127.0.0.1:1234</span></span><br><span class="line"><span class="comment"># -bios OVMF.fd，指定 OVMF 固件文件，这是一个支持 UEFI 的 QEMU 固件。</span></span><br><span class="line"><span class="comment"># -debugcon file:debug.log 将调试输出重定向到 debug.log 文件。</span></span><br><span class="line"><span class="comment"># -global isa-debugcon.iobase=0x402 配置调试控制台的 I/O 基地址。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-s \</span><br><span class="line">-bios OVMF.fd \</span><br><span class="line">-drive format=raw,file=fat:rw:UEFI_Disk/ \</span><br><span class="line">-net none \</span><br><span class="line">-debugcon file:debug.log \</span><br><span class="line">-global isa-debugcon.iobase=0x402 \</span><br><span class="line">-nographic</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个脚本首先会编译 OVMF(Open Virtual Machine Firmware)，OVMF 是一个基于 EDKII 的固件，可以在 qemu x86-64 虚拟机下运行。这使得调试和实验 UEFI 固件变得更加容易；无论是用于测试操作系统启动，还是使用（内置的）EFI shell。</p><p>OVMF 固件（用于 QEMU 的 UEFI 实现）被分为两个文件：</p><ul><li>OVMF_CODE.fd：包含实际的 UEFI 固件。</li><li>OVMF_VARS.fd：作为一个“模板”用于模拟持久化的 NVRAM 存储。<br>所有虚拟机实例可以共享来自 ovmf 包的系统范围内的只读 OVMF_CODE.fd 文件，但每个实例都需要一个私有的、可写的 OVMF_VARS.fd 副本。<br>在 qemu 中，可以分别指定 OVMF_CODE.fd 和 OVMF_VARS.fd，也可以采用简化的写法：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别指定</span></span><br><span class="line">qemu-system-x86_64 -drive <span class="keyword">if</span>=pflash,format=raw,<span class="built_in">readonly</span>,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF_CODE.fd \</span><br><span class="line">                     -drive <span class="keyword">if</span>=pflash,format=raw,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF_VARS.fd \</span><br><span class="line">                     -nographic \</span><br><span class="line">                     -net none</span><br><span class="line"><span class="comment"># 简化写法</span></span><br><span class="line">qemu-system-x86_64 -drive <span class="keyword">if</span>=pflash,format=raw,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd \</span><br><span class="line">                     -nographic \</span><br><span class="line">                     -net none</span><br></pre></td></tr></table></figure><p>运行 debug-x64.sh, 不出意外会出现如下界面, 即 UEFI 的 Shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">Press ESC <span class="keyword">in</span> 2 seconds to skip startup.nsh or any other key to <span class="built_in">continue</span>.</span><br><span class="line">Shell&gt;</span><br></pre></td></tr></table></figure><p>在这个 shell 中输入 fs0:(注意这有一个英文冒号), 然后输入 HelloWorld.efi 运行我们的程序,预期输出”Hello World!!!”</p><div class="tip warning faa-horizontal animated"><p>在 Shell 如果按 BackSpace 没有反应，可以按 Ctrl+H 代替</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">Press ESC <span class="keyword">in</span> 2 seconds to skip startup.nsh or any other key to <span class="built_in">continue</span>.</span><br><span class="line">Shell&gt; fs0:</span><br><span class="line">FS0:\&gt; <span class="built_in">ls</span></span><br><span class="line">Directory of: FS0:\</span><br><span class="line">01/08/2025  22:23                  82  gdb_commands.txt</span><br><span class="line">01/10/2025  20:22             184,544  HelloWorld.debug</span><br><span class="line">01/10/2025  20:22               5,760  HelloWorld.efi</span><br><span class="line">01/10/2025  12:22               1,391  NvVars</span><br><span class="line">          4 File(s)     191,777 bytes</span><br><span class="line">          0 Dir(s)</span><br><span class="line">FS0:\&gt; HelloWorld.efi</span><br><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure><p>退出 qemu 按<strong>CTRL+A - X</strong></p><p>下面是 aarch64 版本的<br><strong>debug-aarch64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5_AARCH64_PREFIX=<span class="variable">$UEFI_WORKSPACE</span>/toolchain/gcc-arm-8.2-2019.01-x86_64-aarch64-elf/bin/aarch64-elf-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -a AARCH64 -p ArmVirtPkg/ArmVirtQemu.dsc -t GCC5 -b RELEASE</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span></span><br><span class="line"><span class="built_in">mkdir</span> -p _armvirt_dbg</span><br><span class="line"><span class="built_in">cd</span> _armvirt_dbg</span><br><span class="line"><span class="built_in">rm</span> -f debug.log</span><br><span class="line"><span class="comment"># 与ubuntu22.04软件源默认的qemu不兼容，需要升级qemu版本到v8.1.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$EDK_PATH</span>/Build/ArmVirtQemu-AARCH64/RELEASE_GCC5/FV/QEMU_EFI.fd ./</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p UEFI_Disk</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>/Build/DEBUG_GCC5/AARCH64/<span class="variable">$INF_BASE_NAME</span>.efi ./UEFI_Disk/</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>/Build/DEBUG_GCC5/AARCH64/<span class="variable">$INF_BASE_NAME</span>.debug ./UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="comment">#qemu命令</span></span><br><span class="line">qemu-system-aarch64 \</span><br><span class="line">-machine virt,kernel_irqchip=on,gic-version=3 \</span><br><span class="line">-cpu cortex-a57 -m 1G  \</span><br><span class="line">-drive format=raw,file=fat:rw:UEFI_Disk/ \</span><br><span class="line">-bios QEMU_EFI.fd \</span><br><span class="line">-net none \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>gdb 调试 UEFI 程序稍稍有点麻烦, 但可以用脚本自动化一些操作, 总体流程如下:</p><ol><li>运行 debug.sh, 然后进入 UEFI Shell 中运行一下代码(和上一小节用 qemu 运行一样的操作, 这里主要是为了在_ovmf_dbg/debug.log 中拿到 driver 启动的地址)</li><li>开另一个 terminal, 运行下面的脚本 addr.sh</li><li>在_ovmf_dbg/UEFI_Disk 目录下运行 gdb -x gdb_commands.txt</li><li>在 gdb 里面打断点, 比如 break UefiMain</li><li>添加 gdb 调试 target remote localhost:1234</li><li>运行,输入 c 跳到第一个断点位置</li><li>在 UEFI Shell 中运行你的代码</li></ol><p><strong>addr-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> _ovmf_dbg</span><br><span class="line"></span><br><span class="line">logfile=<span class="string">&quot;debug.log&quot;</span></span><br><span class="line"></span><br><span class="line">line=$(grep -oP <span class="string">&quot;Loading driver at 0x[0-9a-fA-F]+ EntryPoint=0x[0-9a-fA-F]+ <span class="variable">$INF_BASE_NAME</span>\.efi&quot;</span> <span class="string">&quot;<span class="variable">$logfile</span>&quot;</span> | <span class="built_in">tail</span> -n 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式提取两个地址</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$line</span> =~ Loading\ driver\ at\ (0x[0-9a-fA-F]+)\ EntryPoint=(0x[0-9a-fA-F]+)\ <span class="variable">$INF_BASE_NAME</span>\.efi ]]; <span class="keyword">then</span></span><br><span class="line">    address0=<span class="string">&quot;<span class="variable">$&#123;BASH_REMATCH[1]&#125;</span>&quot;</span></span><br><span class="line">    address1=<span class="string">&quot;<span class="variable">$&#123;BASH_REMATCH[2]&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Loading driver at <span class="variable">$address0</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;EntryPoint=<span class="variable">$address1</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: No matching line found, maybe you need to run <span class="variable">$INF_BASE_NAME</span> in qemu first&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> UEFI_Disk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 objdump 获取文件头信息并提取 .text 和 .data 的 File off</span></span><br><span class="line">text_offset=$(objdump -h <span class="string">&quot;<span class="variable">$INF_BASE_NAME</span>.efi&quot;</span> | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  /\.text/ &#123;print $6&#125;  # 提取 .text 的 File off</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data_offset=$(objdump -h <span class="string">&quot;<span class="variable">$INF_BASE_NAME</span>.efi&quot;</span> | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  /\.data/ &#123;print $6&#125;  # 提取 .data 的 File off</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出提取的结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;.text file off: <span class="variable">$text_offset</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;.data file off: <span class="variable">$data_offset</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算</span></span><br><span class="line">text_addr=$((<span class="number">0</span>x<span class="variable">$&#123;address0#0x&#125;</span> + <span class="number">0</span>x<span class="variable">$&#123;text_offset&#125;</span>))</span><br><span class="line">data_addr=$((<span class="number">0</span>x<span class="variable">$&#123;address0#0x&#125;</span> + <span class="number">0</span>x<span class="variable">$&#123;data_offset&#125;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果时使用16进制格式</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;text_addr: 0x%X   data_addr: 0x%X\n&quot;</span> <span class="variable">$text_addr</span> <span class="variable">$data_addr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf gdb_commands.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 gdb_commands.txt 文件并写入内容</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOL &gt; gdb_commands.txt</span></span><br><span class="line"><span class="string">file $&#123;INF_BASE_NAME&#125;.efi</span></span><br><span class="line"><span class="string">add-symbol-file $&#123;INF_BASE_NAME&#125;.debug 0x$(printf &quot;%X&quot; $text_addr) -s .data 0x$(printf &quot;%X&quot; $data_addr)</span></span><br><span class="line"><span class="string">EOL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出文件内容确认</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;gdb_commands.txt has been created with the following content:&quot;</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">cat</span> gdb_commands.txt</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run the following command to debug&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cd _ovmf_dgb/UEFI_Disk&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;gdb -x gdb_commands.txt&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;break UefiMain&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;target remote localhost:1234&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="HelloStd"><a href="#HelloStd" class="headerlink" title="HelloStd"></a>HelloStd</h1><p>另一个例子, 使用 edk-libc 实现在 UEFI 中调用标准 c 库程序</p><p>可以复制 HelloWorld.dsc，在此基础上修改 guid,然后记得修改[<strong>Components</strong>]为 HelloWorld.inf, 最后在 dsc 的[<strong>LibraryClasses</strong>]最后添加一行下面的代码</p><p><strong>HelloStd.dsc</strong></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!include StdLib/StdLib.inc</span><br></pre></td></tr></table></figure><p>接下来是 HelloStd.inf, 首先[<strong>Defines</strong>]中的 ENTRY_POINT 要改为 ShellCEntryLib, [<strong>Packages</strong>]中添加 StdLib/StdLib.dec 和 ShellPkg/ShellPkg.dec 这两个包, [<strong>LibraryClasses</strong>]中要去掉 UefiApplicationEntryPoint, 添加 LibC 和 LibStdio 这两个库, 下面是 HelloStd.inf 的声明</p><p><strong>HelloStd.inf</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Variables defined to be used during the build process</span></span><br><span class="line">[Defines]</span><br><span class="line">  INF_VERSION       = 1.25</span><br><span class="line">  BASE_NAME         = HelloStd</span><br><span class="line">  FILE_GUID         = d0956d2b-c033-45af-8ef2-76c9d30518ec</span><br><span class="line">  MODULE_TYPE       = UEFI_APPLICATION</span><br><span class="line">  VERSION_STRING    = 1.0</span><br><span class="line">  ENTRY_POINT       = ShellCEntryLib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source code</span></span><br><span class="line">[Sources]</span><br><span class="line">  HelloStd.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required packages</span></span><br><span class="line">[Packages]</span><br><span class="line">  MdePkg/MdePkg.dec            <span class="comment"># Contains Uefi and UefiLib</span></span><br><span class="line">  StdLib/StdLib.dec</span><br><span class="line">  ShellPkg/ShellPkg.dec</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required Libraries</span></span><br><span class="line">[LibraryClasses]</span><br><span class="line">  <span class="comment"># UefiApplicationEntryPoint    # Uefi application entry point</span></span><br><span class="line">  UefiLib                      <span class="comment"># UefiLib</span></span><br><span class="line">  LibC</span><br><span class="line">  LibStdio</span><br></pre></td></tr></table></figure><p>接着我们就可以在 UEFI 中调用标准库程序了</p><p><strong>HelloStd.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/ShellCEntryLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiRuntimeServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(IN <span class="type">int</span> Argc, IN <span class="type">char</span> **Argv)</span> &#123;</span><br><span class="line">  EFI_TIME curTime;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;HelloStd!!!\n&quot;</span>);</span><br><span class="line">  gBS-&gt;Stall(<span class="number">2000</span>);</span><br><span class="line">  gRT-&gt;GetTime(&amp;curTime, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Current Time: %d-%d-%d %02d:%02d:%02d\n&quot;</span>, curTime.Year, curTime.Month,</span><br><span class="line">         curTime.Day, curTime.Hour, curTime.Minute, curTime.Second);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着更改下 env.sh 中的 PROJ_NAME, DSC_NAME, INF_NAME, INF_BASE_NAME 即可编译，运行调试等在 HelloWorld 中描述的操作</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/Kostr/UEFI-Lessons">UEFI-Lessons</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/luobing/uefi-practical-programming">UEFI编程实践 罗冰</a></div>]]></content>
      
      
      <categories>
          
          <category> UEFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UEFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emacs</title>
      <link href="/posts/28520/"/>
      <url>/posts/28520/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-01-09</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h2 id="常用选中指令"><a href="#常用选中指令" class="headerlink" title="常用选中指令"></a>常用选中指令</h2><div class="table-container"><table><thead><tr><th>指令</th><th>名字</th><th>效果</th></tr></thead><tbody><tr><td>M - h</td><td>mark-paragraph</td><td>选中段落</td></tr><tr><td>C - x + C - p</td><td>mark-page</td><td>选中整个页面</td></tr><tr><td>C - x h</td><td>mark-whole-buffer</td><td>选中整个编辑窗口内容</td></tr><tr><td>M - y</td><td>yank-pop</td><td>在C - y 之后使用，粘贴剪贴板内以前的项目</td></tr></tbody></table></div><h1 id="emacs配置文件在windows上的位置"><a href="#emacs配置文件在windows上的位置" class="headerlink" title="emacs配置文件在windows上的位置"></a>emacs配置文件在windows上的位置</h1><p>On Windows, the .emacs file may be called _emacs for backward compatibility with DOS and FAT filesystems where filenames could not start with a dot. Some users prefer to continue using such a name, because Explorer cannot create a file with a name starting with a dot, even though the filesystem and most other programs can handle it. In Emacs 22 and later, the init file may also be called.emacs.d/init.el. Many of the other files that are created by lisp packages are now stored in the.emacs.ddirectory too, so this keeps all your Emacs related files in one place.</p><p>All the files mentioned above should go in your HOME directory. The HOME directory is determined by following the steps below:</p><ol><li>If the environment variableHOME is set, use the directory it indicates.</li><li>If the registry entry HKCU\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates.</li><li>If the registry entry HKLM\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates. Not recommended, as it results in users sharing the same HOME directory.</li><li>If C:.emacs exists, then use C:/. This is for backward compatibility, as previous versions defaulted to C:/ if HOME was not set.</li><li>Use the user’s AppData directory, usually a directory called Application Data under the user’s profile directory, the location of which varies according to Windows version and whether the computer is part of a domain.</li></ol><p>也就是说，Emacs的配置文件有三种格式：.emacs文件、_emacs文件或者.emacs.d目录下的init.el（22或者更高版本）文件，但是，不管哪种格式，必须放对正确的目录Emacs才能找到，这个正确的目录就是HOME目录。</p><p>熟悉Linux的朋友一般都知道home目录，简单的用~表示，或者用全路径表示为/home/<xxx>，其中xxx表示用户名字，所以，在Linux下将.emacs和.emacs.d放到这个目录下就行了，但windows没有home目录的概念，所以，Emacs就按如下方式来查找配置文件：</p><ol><li>如果设置了HOME环境变量，那么就用它的值作为home目录~</li><li>如果存在注册表键值HKCU\SOFTWARE\GNU\Emacs\HOME，就用它的值作为home目录~</li><li>如果存在注册表键值HKLM\SOFTWARE\GNU\Emacs\HOME，就用它的值作为home目录~（和2的区别是，2只是针对当前用户的注册表路径，3则是针对所有用户）</li><li>如果存在C:.emacs，就用C:\作为home目录~</li><li>如果以上都不存在的话，就使用<system root>\Users<user name>\AppData\Roaming作为home目录~（对于XP和较早windows用户，需要到Documents and Settings目录下去找）</li></ol><p><strong>从以上策略来看，1是比较好的做法，所以优先级也最高，应该是属于建议的方式，于是，新建一个HOME环境变量，将它的值设为想要放置Emacs配置文件的地方既可。</strong></p><p><strong>之前我是按以上方法设置的HOME目录，不过现在我后悔了，因为我发现不光是Emacs会使用HOME这个环境变量，会使用这个变量的至少还有以下程序或者插件：</strong></p><ol><li><strong>VIM，VIM会把_viminfo文件放在这个目录；</strong></li><li><strong>VIM的neocomplcache插件，它会放置一个.neocon目录进去；</strong></li><li><strong>firefox的pentadactyl插件，它会放一个pentadactyl目录进去。</strong></li></ol><p><strong>所以，个人建议：</strong></p><ol><li><strong>如果你希望有一个公共的目录存放这些配置，就像Linux下的~目录一样，那么设置HOME这个环境变量最适合不过；</strong></li><li><strong>如果你希望这个目录只存放Emacs的配置，那么，还是不要用HOME环境变量了，去注册表里面添加一个HOME键值吧。（至少我个人比较偏向于这个方式）</strong></li></ol><p>即：</p><p>在</p><p>HKEY_LOCAL_MACHINE\SOFTWARE下新建GNU项，在GNU项下新建Emacs项，然后Emacs新建一个字符串值，键为HOME,值为要存放的路径</p><h1 id="emacs-turials"><a href="#emacs-turials" class="headerlink" title="emacs turials"></a>emacs turials</h1><p>C：Ctrl</p><p>M: Alt</p><h2 id="退出Emacs"><a href="#退出Emacs" class="headerlink" title="退出Emacs"></a>退出Emacs</h2><p><strong>C-x C-c</strong></p><h2 id="退出一个正在运行中的命令"><a href="#退出一个正在运行中的命令" class="headerlink" title="退出一个正在运行中的命令"></a>退出一个正在运行中的命令</h2><p><strong>C-g</strong></p><h2 id="移动到下一屏"><a href="#移动到下一屏" class="headerlink" title="移动到下一屏"></a>移动到下一屏</h2><p><strong>C-v</strong></p><h2 id="移动到上一屏"><a href="#移动到上一屏" class="headerlink" title="移动到上一屏"></a>移动到上一屏</h2><p><strong>M-v</strong></p><h2 id="重绘屏幕，将光标所在的行置于屏幕的中央"><a href="#重绘屏幕，将光标所在的行置于屏幕的中央" class="headerlink" title="重绘屏幕，将光标所在的行置于屏幕的中央"></a>重绘屏幕，将光标所在的行置于屏幕的中央</h2><p><strong>C-l（这里是CTRL-L）</strong></p><h2 id="基本光标控制"><a href="#基本光标控制" class="headerlink" title="基本光标控制"></a>基本光标控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                   上一行 C-p</span><br><span class="line">                      :</span><br><span class="line">                      :</span><br><span class="line">向左移 C-b .... 目前光标位置 .... 向右移 C-f</span><br><span class="line">                      :</span><br><span class="line">                      :</span><br><span class="line">                 下一行 C-n</span><br></pre></td></tr></table></figure><p>每行文字都以一个“换行符”结束，“换行符”把行与行区分开来。（通常情况下，一个文件的最后一行会有一个换行符，但是 Emacs 不强制要求这一点。）</p><h3 id="上一行"><a href="#上一行" class="headerlink" title="上一行"></a>上一行</h3><p><strong>C-p</strong></p><p>previous</p><h3 id="下一行"><a href="#下一行" class="headerlink" title="下一行"></a>下一行</h3><p><strong>C-n</strong></p><p>next</p><h3 id="向左移一个字符"><a href="#向左移一个字符" class="headerlink" title="向左移一个字符"></a>向左移一个字符</h3><p><strong>C-b</strong></p><p>backward</p><h3 id="向右移一个字符"><a href="#向右移一个字符" class="headerlink" title="向右移一个字符"></a>向右移一个字符</h3><p><strong>C-f</strong></p><p>forward</p><h3 id="光标向前移动一个词"><a href="#光标向前移动一个词" class="headerlink" title="光标向前移动一个词"></a>光标向前移动一个词</h3><p>这里词对于英文来说是一个英文单词，对于中文来说是移动到下一个标点符号</p><p><strong>M-f</strong></p><h3 id="光标向后移动一个词"><a href="#光标向后移动一个词" class="headerlink" title="光标向后移动一个词"></a>光标向后移动一个词</h3><p><strong>M-b</strong></p><h3 id="将光标移动到行头"><a href="#将光标移动到行头" class="headerlink" title="将光标移动到行头"></a>将光标移动到行头</h3><p><strong>C-a</strong></p><p>ahead</p><h3 id="将光标移动到行尾"><a href="#将光标移动到行尾" class="headerlink" title="将光标移动到行尾"></a>将光标移动到行尾</h3><p><strong>C-e</strong></p><p>end</p><h3 id="将光标移动到一句的头部"><a href="#将光标移动到一句的头部" class="headerlink" title="将光标移动到一句的头部"></a>将光标移动到一句的头部</h3><p><strong>M-a</strong></p><h3 id="将光标移动到一句的尾部"><a href="#将光标移动到一句的尾部" class="headerlink" title="将光标移动到一句的尾部"></a>将光标移动到一句的尾部</h3><p><strong>M-e</strong></p><h3 id="将光标移动到所有文字的最开头"><a href="#将光标移动到所有文字的最开头" class="headerlink" title="将光标移动到所有文字的最开头"></a>将光标移动到所有文字的最开头</h3><p><strong>M-&lt;</strong>(实际上是alt+shift+,)</p><h3 id="将光标移动到所有文字的最末尾"><a href="#将光标移动到所有文字的最末尾" class="headerlink" title="将光标移动到所有文字的最末尾"></a>将光标移动到所有文字的最末尾</h3><p><strong>M-&gt;</strong>(实际上是alt+shift+.)</p><h3 id="光标选中多个文字"><a href="#光标选中多个文字" class="headerlink" title="光标选中多个文字"></a>光标选中多个文字</h3><p><strong>C-shift-r C-shift-f</strong></p><h2 id="移动行块"><a href="#移动行块" class="headerlink" title="移动行块"></a>移动行块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(use-package drag-stuff</span><br><span class="line">             :bind ((&quot;&lt;M-up&gt;&quot; . drag-stuff-up)</span><br><span class="line">                    (&quot;&lt;M-down&gt;&quot; . drag-stuff-down)))</span><br></pre></td></tr></table></figure><p><strong>M-向上箭头</strong></p><h2 id="互换顺序"><a href="#互换顺序" class="headerlink" title="互换顺序"></a>互换顺序</h2><h3 id="光标前后两个字符互换"><a href="#光标前后两个字符互换" class="headerlink" title="光标前后两个字符互换"></a>光标前后两个字符互换</h3><p><strong>C-t</strong></p><h3 id="光标前后两个单词互换"><a href="#光标前后两个单词互换" class="headerlink" title="光标前后两个单词互换"></a>光标前后两个单词互换</h3><p><strong>M-t</strong></p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><strong>M-w</strong></p><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p><strong>C-w</strong></p><h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><p><strong>C-y</strong></p><p>yank</p><h2 id="参数控制"><a href="#参数控制" class="headerlink" title="参数控制"></a>参数控制</h2><p>大部分的Emacs命令接受数字参数，并且对于多数命令而言，这些数字参数的作用是<strong>指定命令的重复次数</strong></p><p><strong>先输入C-u ，然后输入数字作为参数，最后再输入命令</strong></p><p>如： C-u 8 C-f 会向前移动8个字符</p><p>某些Emacs命令接收数字参数当作他用</p><p>比如： C-v 和 M-v</p><p>当给定一一个参数时，他们将滚动指定的行数而不是屏数</p><p>即C-u 8 C-v会将光标向下移动8行</p><h2 id="窗格"><a href="#窗格" class="headerlink" title="窗格"></a>窗格</h2><h3 id="关闭多余的窗格"><a href="#关闭多余的窗格" class="headerlink" title="关闭多余的窗格"></a>关闭多余的窗格</h3><p><strong>C-x 1</strong></p><p>只保留一个窗格，也就是关掉其它所有的窗格，将保留的窗格扩大到整个屏幕，同时关掉所有其它窗格</p><p>有一系列命令是以CONTROL-x开始的，这些命令许多都跟窗格，文件，缓冲区等等相关</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="插入多个相同字符"><a href="#插入多个相同字符" class="headerlink" title="插入多个相同字符"></a>插入多个相同字符</h3><p><strong>C-u 8</strong> <strong>*</strong></p><p>这将会插入<strong><strong>*</strong></strong></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除光标后的一个字符"><a href="#删除光标后的一个字符" class="headerlink" title="删除光标后的一个字符"></a>删除光标后的一个字符</h3><p><strong>C-d</strong></p><p>delete</p><p>相当于键盘的delete键</p><h3 id="删除光标后的一个词"><a href="#删除光标后的一个词" class="headerlink" title="删除光标后的一个词"></a>删除光标后的一个词</h3><p><strong>M-d</strong></p><h3 id="删除光标到行尾之间的字符"><a href="#删除光标到行尾之间的字符" class="headerlink" title="删除光标到行尾之间的字符"></a>删除光标到行尾之间的字符</h3><p><strong>C-k</strong></p><p>kill</p><h3 id="删除光标到句尾之间的字符"><a href="#删除光标到句尾之间的字符" class="headerlink" title="删除光标到句尾之间的字符"></a>删除光标到句尾之间的字符</h3><p><strong>M-k</strong></p><p>注意,“移除（kill）”和“删除（delete）”的不同在于被移除的东西可以被重新插入（在任何位置），而被删除的就不能使用相同的方法重新插入了（不过可以通过撤销一个删除命令来做到，后文会提到）。【实际上，移除掉的东西虽然看起来“消失”了，但实际上被 Emacs 记录了下来，因此还可以找回来；而删除掉的东西虽然也可能还在内存里，但是已经被 Emacs“抛弃”了，所以就找不回来了。】重新插入被移除的文字称为“召回（yank）”。一般而言，那些可能消除很多文字的命令会把消除掉的文字记录下来（它们被设定成了“可召回”），而那些只消除一个字符或者只消除空白的命令就不会记录被消除的内容（自然你也就无法召回了）。</p><p>注意，单独的 C-k 会把一行的内容移除，而第二个 C-k 则会移除换行符，并使其后所有的行都向上移动。C-k 处理数字参数的方式很特别，它会把参数指定的那么多行连同其后的换行符一起移除，而不仅仅是重复 C-k 而已。比如 C-u 2C-k 会把两行以及它们的换行符移除；而如果只是输入 C-k 两次显然不是这个结果。</p><h2 id="召回（粘贴）"><a href="#召回（粘贴）" class="headerlink" title="召回（粘贴）"></a>召回（粘贴）</h2><p>重新插入被移除的文字恢复的动作称为“召回（yanking）”。（就好像把别人从你身边移走的东西又猛力地拉回来。）你可以在你删除文字的地方召回，也可以在别的地方召回，还可以多次召回同样的文字以得到它的多个拷贝。很多其它的编辑器把移除和召回叫做“剪切”和“粘贴” </p><h3 id="召回最近一次移除的内容"><a href="#召回最近一次移除的内容" class="headerlink" title="召回最近一次移除的内容"></a>召回最近一次移除的内容</h3><p><strong>C-y</strong></p><p>yanking</p><h3 id="召回前几次移除的内容"><a href="#召回前几次移除的内容" class="headerlink" title="召回前几次移除的内容"></a>召回前几次移除的内容</h3><p><strong>M-y</strong></p><p>需要先C-y之后再M-y</p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p><strong>C-/</strong></p><p>或者 <strong>C-_</strong> 或者 <strong>C-x u</strong></p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>Emacs 可以向前或向后搜索字符串（“字符串”指的是一组连续的字符）。</p><p>搜索命令是一个<strong>移动光标的命令</strong>：搜索成功后，光标会停留在搜索目标出现的地方</p><h3 id="向前搜索"><a href="#向前搜索" class="headerlink" title="向前搜索"></a>向前搜索</h3><p><strong>C-s</strong></p><p>在一次渐进式搜索中，Emacs 会尝试跳到搜索目标出现的位置。要跳到下一个命中位置，就再按一次 C-s。如果找不到目标，Emacs 会发出“哔”的一声，告诉你搜索失败。在整个过程中，都可以用 C-g 来终止搜索。【你会发现 C-g 会让光标回到搜索开始的位置，而 <Return> 则让光标留在搜索结果上，这是很有用的功能】</p><h3 id="向后搜索"><a href="#向后搜索" class="headerlink" title="向后搜索"></a>向后搜索</h3><p><strong>C-r</strong></p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><strong>M-%</strong></p><p>替换时按下y确认替换，n跳过本处的替换，！全部替换</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="寻找一个文件"><a href="#寻找一个文件" class="headerlink" title="寻找一个文件"></a>寻找一个文件</h3><p><strong>C-x C-f</strong></p><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><p><strong>C-x C-s</strong></p><p>这条命令把 Emacs 中的文字存储到文件中。第一次存盘的时候 Emacs 会将原文件重命名以备份。重命名的规则通常是在原文件名之后添加一个“~”字符。可以关闭这个特性。</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>Emacs 把每个编辑中的文件都放在一个称为“缓冲区（buffer）”的地方。每寻找到一个文件，Emacs 就在其内部开辟一个缓冲区。用下面的命令可以列出当前所有的缓冲区：</p><p>   C-x C-b  列出缓冲区</p><p>输入 C-x 1 离开缓冲区列表</p><p>不管存在多少缓冲区，任何时候都只能有一个“当前”缓冲区，也就是你正在编辑的这个。如果你想编辑其它的缓冲区，就必须“切换”过去。上面讲过，用C-x C-f 是一种办法。不过还有一个更简单的办法，那就是用 C-x b。用这条命令，你必须输入缓冲区的名称。</p><p>大多数情况下，缓冲区与跟其对应的文件是同名的（不包括目录名），不过这也不是绝对的。用 C-x C-b 得到的缓冲区列表总是显示缓冲区名。</p><p>缓冲区未必有对应文件。显示缓冲区列表的缓冲区（叫做“<em>Buffer List</em>”）就是这样。这个 TUTORIAL.cn 缓冲区起初没有对应的文件，但是现在有了，因为在前一节你输入了 C-x C-s ， 将它保存成了一个文件。</p><p>“<em>Messages</em>”缓冲区也没有对应文件，这个缓冲区里存放的都是在 Emacs 底部出现的消息。</p><p>如果你对某个文件做了些修改，然后切换到另一个文件，这个动作并不会帮你把前一个文件存盘。对第一个文件的修改仍然仅存在于 Emacs 中，也就是在它对应的缓冲区里。并且，对第二个文件的修改也不会影响到第一个件。这很有用，但也意味着你需要一个简便的办法来保存第一个文件的缓冲区。先切换回那个缓冲区，再用 C-x C-s 存盘，太麻烦了。你需要一个更简便的方法，而 Emacs 已经为你准备好了：</p><p>   C-x s  保存多个缓冲区</p><p>C-x s 会找出所有已被修改但尚未存盘的缓冲区，然后向你逐个询问：是否需要存盘？</p><h2 id="命令集扩展"><a href="#命令集扩展" class="headerlink" title="命令集扩展"></a>命令集扩展</h2><p>Emacs 的命令就像天上的星星，数也数不清。把它们都对应到 CONTROL 和 META组合键上显然是不可能的。Emacs 用扩展（eXtend）命令来解决这个问题，扩展命令有两种风格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C-x     字符扩展。  C-x 之后输入另一个字符或者组合键。</span><br><span class="line">    M-x     命令名扩展。M-x 之后输入一个命令名</span><br></pre></td></tr></table></figure><h3 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h3><p><strong>M-x sort-lines</strong></p><h3 id="统计字数"><a href="#统计字数" class="headerlink" title="统计字数"></a>统计字数</h3><p>整个buffer统计</p><p><strong>M-x count-words-region</strong></p><p>选中区域统计</p><p><strong>M-x count-words</strong></p><h2 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h2><p>如果你已经修改了一个文件，但是还没来得及存盘你的计算机就罢工了，那么你所做的修改就很可能会丢失。为了避免这样的不幸发生，Emacs 会定期将正在编辑的文件写入一个“自动保存”文件中。自动保存文件的文件名的头尾各有一个“#”字符，比如你正在编辑的文件叫“hello.c”，那么它的自动保存文件就叫“#hello.c#”。这个文件会在常存盘之后被 Emacs 删除。</p><p>所以，假如不幸真的发生了，你大可以从容地打开原来的文件（注意不是自动保存文件）然后输入 M-x recover file <Return> 来恢复你的自动保存文件。在提示确认的时候，输入 yes<Return>。</p><h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>位于回显区正上方的一行被称为“状态栏”。状态栏上会显示一些信息，比如：</p><p>-:**- TUTORIAL.cn 63% L749 (Fundamental)</p><ul><li>状态栏显示了 Emacs 的状态和你正在编辑的文字的一些信息。</li><li>你应该知道文件名的意思吧？就是你找到的那个文件嘛。</li><li>-NN%— 显示的是光标在全文中的位置。如果位于文件的开头，那么就显示 —Top— 而不是 —00%—；如果位于文件的末尾，就显示 —Bot—。如果文件很小，一屏就足以显示全部内容，那么状态栏会显示 —All—。</li><li>“L” 和其后的数字给出了光标所在行的行号。</li><li>最开头的星号（*）表示你已经对文字做过改动。刚刚打开的文件肯定没有被改动过，所以状态栏上显示的不是星号而是短线（-）。</li><li>状态栏上小括号里的内容告诉你当前正在使用的编辑模式。缺省的模式是Fundamental，就是你现在正在使用的这个。它是一种“主模式”。</li></ul><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>主模式都是可以用 M-x 启动的扩展命令，M-x fundamental-mode 就可以切换到 Fundamental模式。</p><p>M-x text-mode <Return>。切换到文本模式</p><p>用 C-h m 可以查看当前主模式的文档，输入 C-x 1 关掉文档窗格</p><ul><li>主模式之所以称之为“主（major）”模式，是因为同时还有“辅模式”（minormode）存在。辅模式并不能替代主模式，而是提供一些辅助的功能。每个辅模式都可以独立地开启和关闭，跟其它辅模式无关，跟主模式也无关。所以你可以不使用辅模式，也可以只使用一个或同时使用多个辅模式。</li><li>有一个叫做自动折行（Auto Fill）的辅模式很有用，特别是在编辑自然语言文本的时候。启用自动折行后，Emacs 会在你打字超出一行边界时自动替你换行。</li><li>用 M-x auto-fill-mode <Return> 启动自动折行模式。再用一次这条命令，自动折行模式会被关闭。也就是说，如果自动折行模式没有被开启，这个命令会开启它；如果已经开启了，这个命令会关闭它。所以我们说，这个命令可以用来开关（toggle）”模式。</li><li>行边界通常被设定为 70 个字符【这里指英文字符】，你可以用 C-x f 命令配合数字参数来重新设定它。</li><li>如果你在段落的中间做了一些修改，那么自动折行模式不会替你把整个段落重新折行，你需要用 M-q 手动折行。注意，光标必须位于你需要折行的那一段里</li></ul><h2 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h2><p>Buffer切换</p><p>C-x b</p><p>杀死当前Buffer</p><p>C-x k</p><p>批量管理Buffer</p><p>C-x C-b ;; 进入Buffer列表</p><ul><li>d ;; 标记删除</li><li>u ;; 取消当前行标记</li><li>U ;; 取消全部标记</li><li>x ;; 执行操作</li><li>? ;; 查看按键帮助</li></ul><h2 id="多窗格（分屏）"><a href="#多窗格（分屏）" class="headerlink" title="多窗格（分屏）"></a>多窗格（分屏）</h2><h3 id="将屏幕划分为两个窗格"><a href="#将屏幕划分为两个窗格" class="headerlink" title="将屏幕划分为两个窗格"></a>将屏幕划分为两个窗格</h3><p><strong>C-x 0</strong></p><p>关闭当前分屏</p><p><strong>C-x 1</strong></p><p>只保留当前分屏</p><p><strong>C-x 2</strong></p><p>上下分屏</p><p><strong>C-x 3</strong></p><p>左右分屏</p><h3 id="分屏宽度调整"><a href="#分屏宽度调整" class="headerlink" title="分屏宽度调整"></a>分屏宽度调整</h3><p>增加高度 C-x ^</p><p>增加/减少宽度 C-x {C-x }</p><h3 id="将光标移动到其它窗格"><a href="#将光标移动到其它窗格" class="headerlink" title="将光标移动到其它窗格"></a>将光标移动到其它窗格</h3><p><strong>C-x o</strong></p><p>o指的是other</p><p>当你在一个窗格中编辑，但用另一个窗格作为参考的时候，C-M-v 是很有用的命令。无需离开被选中的窗格，你就可以用 C-M-v 命令滚动另外一个窗格中的文字。【比如翻译和校对就很适合用这种方式进行。】</p><p>（在上方窗格里）输入 C-x 1 关掉下方窗格</p><p>当分屏很多的时候效率非常低。通过ace-window可快速进行窗口间的跳转。类似的插件较多，但该款为最佳方案。</p><p><strong>M-o</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(use-package ace-window </span><br><span class="line">             :bind ((&quot;M-o&quot; . &#x27;ace-window)))</span><br></pre></td></tr></table></figure><p><img src="./emacs.assets/1673110725303-6cb4c6aa-b022-46d2-827b-1b7befb54e8b.png" alt="img"></p><h3 id="在新窗格里打开文件"><a href="#在新窗格里打开文件" class="headerlink" title="在新窗格里打开文件"></a>在新窗格里打开文件</h3><p><strong>C-x 4 C-f</strong></p><h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><h3 id="新建一个窗口"><a href="#新建一个窗口" class="headerlink" title="新建一个窗口"></a>新建一个窗口</h3><p><strong>M-x make-frame</strong></p><h3 id="关闭选中窗口"><a href="#关闭选中窗口" class="headerlink" title="关闭选中窗口"></a>关闭选中窗口</h3><p><strong>M-x delete-frame</strong></p><h2 id="获得更多帮助"><a href="#获得更多帮助" class="headerlink" title="获得更多帮助"></a>获得更多帮助</h2><p>Emacs 提供了一些命令来查看 Emacs 的命令文档，这些命令都以 CONTROL-h 开头，这个字符也因此被称为“帮助（Help）字符”</p><p>最基本的帮助功能是 C-h c。输入 C-h c 之后再输入一个组合键，Emacs 会给出这个命令的简要说明。</p><p>输入 C-h c C-p。</p><p>显示的消息应该会是这样：</p><p>​    C-p runs the command previous-line</p><p>这条消息显示了 C-p 命令对应的函数名。命令的功能由函数完成，所以函数名本身也可以被看成是最简单的文档――至少对于你已经学过的命令来说，它们的函数名足以解释它们的功能了。</p><p>想得到更多的信息，请把 C-h c 换成 C-h k 试试看。</p><p>输入 C-h k C-p。</p><p>上面的命令会新打开一个 Emacs 窗格以显示函数的名称及其文档。你读完之后可以用 C-x 1 关掉这个帮助窗格。当然你并不需要立即这样做，你完全可以先在编辑窗格里做点别的事情，然后再关掉帮助窗格。</p><p>C-h f 解释一个函数。需要输入函数名。</p><p>输入 C-h f previous-line <Return>。Emacs 会给出它所知道的所有有关“实现 C-p 命令功能的函数”的信息</p><p>C-h v 用来显示 Emacs 变量的文档。Emacs 变量可以被用来“定制 Emacs 的行为”。同样，你需要输入变量的名称。</p><p>C-h a 相关命令搜索（Command Apropos）。 输入一个关键词然后 Emacs 会列出所有命令名中包含此关键词 的命令。这些命令全都可以用 M-x 来启动。对于某些命令来说， 相关命令搜索还会列出一两个组合键。</p><p>输入 C-h a file <Return>。</p><p>Emacs 会在另一个窗格里显示一个 M-x 命令列表，这个列表包含了所有名称中含有“file”的命令。你可以看到像“C-x C-f”这样的组合键显示在“find-file”这样的命令名的旁边。</p><p>C-h i 阅读手册（也就是通常讲的 Info）。 这个命令会打开一个称为“<em>info</em>”的特殊缓冲区，在那里， 你可以阅读安装在系统里的软件包使用手册。要读 Emacs 的使 用手册，按 m emacs <Return> 就可以了。如果你之前从没用 过 Info 系统，那么请按“?”，Emacs 会带你进入 Info 的使 用指南。在看完本快速指南之后，Emacs Info 会成为你的主要 参考文档。</p>]]></content>
      
      
      <categories>
          
          <category> emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emacs </tag>
            
            <tag> GNU </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
