<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSAPP BombLab</title>
      <link href="/posts/42881/"/>
      <url>/posts/42881/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>win11 WSL2：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/CCECAA6776058E5E7B3BD5CD47C415D9.png" alt="硬件环境"></p><p>环境搭建<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/SJTU-IPADS/OS-Course-Lab.git</span><br><span class="line"><span class="built_in">cd</span> OS-Course-Lab/Lab0</span><br></pre></td></tr></table></figure></p><p>terminal1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-aarch64-static -g 1234 ./bomb</span><br></pre></td></tr></table></figure><p>terminal2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch -ex <span class="string">&quot;set architecture aarch64&quot;</span> -ex <span class="string">&quot;target remote localhost:1234&quot;</span> -ex <span class="string">&quot;file bomb&quot;</span></span><br></pre></td></tr></table></figure><h1 id="main"><a href="#main" class="headerlink" title="main"></a>main</h1><p>main函数是有C代码的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;phases.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span>* input;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Type in your defuse password!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_0(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_1(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_2(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_3(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_4(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  input = read_line();</span><br><span class="line">  phase_5(input);</span><br><span class="line">  phase_defused();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Congrats! You have defused all phases!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到read_line的返回值作为参数传递给phase_x</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225404452.png" alt="image-20250629225404452"></p><p>可以看到，main函数每次调用read_line读取输入，随后调用phase_x函数，随后调用phase_defused打印信息</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225341441.png" alt="image-20250629225341441"></p><p>函数开头（栈帧设置）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400b10: a9bf7bfd    stp x29, x30, [sp, #-16]!    // 保存帧指针和返回地址到栈上，sp -= 16</span><br><span class="line">400b14: 910003fd    mov x29, sp                  // 设置新的帧指针 x29 = sp</span><br></pre></td></tr></table></figure><p>获取 fgets 的目标缓冲区（x0），准备调用 <code>_IO_fgets</code>：</p><p>该函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>可以看到第一个参数是char*（x0），第二个参数为int（w1），第三个参数为一个结构体指针（x2）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">400b18: f00004e0    adrp x0, 49f000</span><br><span class="line">400b1c: f946d000    ldr x0, [x0, #3488]          </span><br><span class="line">400b20: f9400002    ldr x2, [x0]                 // FILE *stream</span><br><span class="line"></span><br><span class="line">400b24: 52800a21    mov w1, #0x51                // w1 = 81，最多读取 81 字节</span><br><span class="line"></span><br><span class="line">400b28: d0000500    adrp x0, 4a2000</span><br><span class="line">400b2c: 9104e000    add x0, x0, #0x138           // x0 = 0x4a2000 + 0x138，x0 是目标 buffer 指针</span><br><span class="line"></span><br><span class="line">400b30: 94004a78    bl  413510 &lt;_IO_fgets&gt;       // 调用 _IO_fgets(buffer, 81, stream)</span><br></pre></td></tr></table></figure><blockquote><p>到这里，函数已经从输入中读取了一行字符串到 <code>0x4a2138</code> 地址。</p></blockquote><p>处理 fgets 结果：遍历字符串查找换行符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">400b34: d2800000    mov x0, #0                   // x0 = 0，作为字符串偏移索引</span><br><span class="line"></span><br><span class="line">// 再次构造 x2 = buffer 基址</span><br><span class="line">400b38: d0000502    adrp x2, 4a2000</span><br><span class="line">400b3c: 9104e042    add x2, x2, #0x138           // x2 = buffer</span><br><span class="line"></span><br><span class="line">400b40: 38626801    ldrb w1, [x0, x2]            // w1 = buffer[x0]</span><br><span class="line">400b44: 34000141    cbz w1, 400b6c               // 如果 w1 == 0，字符串结束，跳到 return</span><br><span class="line">400b48: 7100283f    cmp w1, #0xa                 // 检查是否是换行符 &#x27;\n&#x27;</span><br><span class="line">400b4c: 540000a0    b.eq 400b60                  // 是换行符，跳转到去掉换行符</span><br><span class="line">400b50: 91000400    add x0, x0, #1               // x0++，继续检查下一个字符</span><br><span class="line">400b54: f101401f    cmp x0, #0x50                // 最多检查 0x50 字节（最多 80 字节）</span><br><span class="line">400b58: 54ffff41    b.ne 400b40                  // 没到头就继续循环</span><br></pre></td></tr></table></figure><p>如果没有在前 80 字节找到 ‘\n’，调用 <code>explode</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400b5c: 97ffffe6    bl 400af4 &lt;explode&gt;          // 没有 &#x27;\n&#x27;，爆炸</span><br></pre></td></tr></table></figure><p>如果找到了换行符 <code>\n</code>，把它替换为 <code>\0</code>（字符串结束）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">400b60: d0000501    adrp x1, 4a2000</span><br><span class="line">400b64: 9104e021    add x1, x1, #0x138           // x1 = buffer</span><br><span class="line">400b68: 3820c83f    strb wzr, [x1, w0, sxtw]     // buffer[x0] = 0（wzr是0寄存器）</span><br></pre></td></tr></table></figure><p>返回前恢复现场：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">400b6c: d0000500    adrp x0, 4a2000</span><br><span class="line">400b70: 9104e000    add x0, x0, #0x138           // x0 = buffer，作为返回值</span><br><span class="line"></span><br><span class="line">400b74: a8c17bfd    ldp x29, x30, [sp], #16      // 恢复帧指针和返回地址，sp += 16</span><br><span class="line">400b78: d65f03c0    ret                          // 返回</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629225645707.png" alt="image-20250629225645707"></p><p>可以看到phase_defused函数读取一个全局变量值，然后减一</p><p>随后加载一个全局地址0x464000+0x7c0 = 0x4647c0作为参数调用printf打印</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630125413000.png" alt="image-20250630125413000"></p><p>而w1存的是最开始减一的全局变量的值，地址是0x4a0000+ 80 = 0x4a0000 + 0x50 = 0x4a0050。</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630125539188.png" alt="image-20250630125539188"></p><h1 id="phase-0"><a href="#phase-0" class="headerlink" title="phase_0"></a>phase_0</h1><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624203514602.png" alt="image-20250624203514602"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stpx29, x30, [sp, #-16]!</span><br></pre></td></tr></table></figure><ul><li>作用：将 x29（frame pointer，帧指针）和 x30（link register，返回地址）压入栈中。这一步保存了调用者的帧指针和返回地址，便于后续恢复。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movx29, sp</span><br></pre></td></tr></table></figure><ul><li>作用：将当前的栈指针 sp 赋值给帧指针 x29，即建立当前函数的新栈帧。</li></ul><p>从现在开始，x29 就指向这个函数调用的栈底，方便以后访问局部变量或传递参数。</p><p>随后，函数先是调用read_int函数读取一个int值，将返回值存入w0，然后对比0x4a0000 + 0x54(84) = 0x4a0054的值看是否相等。可通过gdb examine命令查看内存这个位置的值：</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624204122130.png" alt="image-20250624204122130"></p><p>可以看到是2022</p><p>随后是cmp指令对比输入的值(存储在x0)和2022(存储在x1)，如果不相等则跳到调用explode函数的那行，所以必须要相等。即输入值必须是2022</p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>phase_1和phase_0差不多</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624205525968.png" alt="image-20250624205525968"></p><p>可以看到函数把0x4a0000+0x58(88) = 0x4a0058地址的值装入x1，然后调用strcmp，其参数应该是x0，x1，而x0是我们输入的值，也就是说让我们输入的字符串和这个0x4a0058地址的字符串进行比较，看返回值w0是否为0，不为0就跳转到调用explode的那一行</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250624205829889.png" alt="image-20250624205829889"></p><p>里需要注意的是0x4a0058地址存放的不是字符串，而是字符串的地址，所以要先读出这个地址，然后读字符串地址的字符串</p><p>答案为：”Fault Tolerance: Reliable Systems from Unreliable Components.”</p><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629223737226.png" alt="image-20250629223737226"></p><p>第一行开辟了64字节的栈空间，共可存放64/8=8 个64位值，第一行将x29放在sp，将x30放在sp+8</p><p>随后保存sp到x29寄存器</p><p>随后将x19, x20寄存器的值放在sp+16, sp+24的位置，即</p><ul><li>sp        —-&gt; x29</li><li>sp+8   —-&gt; x30</li><li>sp+16 —-&gt; x19</li><li>sp+24 —-&gt; x20</li></ul><p>随后x1 = sp+ 0x20 = sp+32，作为read_8_numbers的第二个参数，随后调用read_8_numbers这个函数</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250629224840291.png" alt="image-20250629224840291"></p><p>可以看到，该函数首先开辟0x20即32字节的栈空间sp= sp-32，随后将x29存入sp+16，x30存入sp+24</p><p>随后设置栈帧指针x29为sp+0x10即sp+16</p><p>随后将x1放入x2，x1是read_8_numbers的第二个参数</p><p>随后，x1 = x1+0x1c = x1+ 28</p><p>将x1存入sp+8</p><p>x1 = x2 + 0x18 =x1 + 24</p><p>将x1存入sp</p><p>随后</p><ul><li><p>x7 = x2+ 0x14</p></li><li><p>x6 = x2 + 0x10</p></li><li>x5 = x2+0xc</li><li>x4 = x2+ 0x8</li><li>x3 = x2+0x4</li></ul><p>x1是地址0x464000+0x858的值，是一个指针，这里可以明显看出来是一个数组起始地址，可以看到是格式化字符串，作为__isoc99_scanf的第二个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数是x0，即从read_line返回后一直未变</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630140224444.png" alt="image-20250630140224444"></p><p>函数调用结束后比较返回值和0x7的大小，如果小于等于就爆炸，因此必须要输入8个数字。</p><p>函数返回后恢复原来的栈结构</p><ul><li>sp        —-&gt; x29</li><li>sp+8   —-&gt; x30</li><li>sp+16 —-&gt; x19</li><li>sp+24 —-&gt; x20</li><li>sp+32 —-&gt; array的首地址，共8个数字，也是第一个数字的地址array[0]</li><li>sp+36 —-&gt; array[1]</li><li>sp+40 —-&gt; array[2]</li><li>sp+44 —-&gt; array[3]</li><li>sp+48 —-&gt; array[4]</li><li>sp+52 —-&gt; array[5]</li><li>sp+56 —-&gt; array[6]</li><li>sp+60 —-&gt; array[7]</li></ul><p>刚好占满phase_2最初开辟的64字节</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630142117435.png" alt="image-20250630142117435"></p><p>然后是对输入的8个数字的判断了，这里很容易看出第一个数字和第二个数字都必须为1</p><p>随后是一个循环</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250630142644664.png" alt="image-20250630142644664"></p><p>x19 = sp+0x20 = sp+32 即array[0]</p><p>x20 = sp+0x38 = sp+56 即终止条件即(56-32)/4=6，即到第六个就停止</p><p>首先b 0x4007d0跳过一次x19的自增与和x20的比较</p><p>如果x19 == x20 则跳到phase_2+108结束</p><p>否则，首先将x19作为地址加载到w0（array[i]），将它下一个加载到w1（array[i+1]）</p><p>令w0 = array[i]+array[i+1] +4</p><p>w1 = array[i+2]</p><p>比较w0 是否等于w1,如果相等则跳到phase_2+60，将i++</p><p>如果不相等则爆炸</p><p>第一个数和第二个数必须为1</p><p>那么第三个数字为1+1+4=6</p><p>第四个数字为1+6+4=11</p><p>第五个数字为6+11+4=21</p><p>第六个数字为11+21+4=36</p><p>第七个数字为21+36+4=61</p><p>第八个数字为61+36+4=101</p><p>故答案为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">6</span> <span class="number">11</span> <span class="number">21</span> <span class="number">36</span> <span class="number">61</span> <span class="number">101</span></span><br></pre></td></tr></table></figure><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB</title>
      <link href="/posts/42870/"/>
      <url>/posts/42870/</url>
      
        <content type="html"><![CDATA[<hr><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-06-24</p></div></div><div class='timeline-item-content'><p>init</p></div></div></div><hr><h1 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h1><h2 id="编译阶段：加入调试信息"><a href="#编译阶段：加入调试信息" class="headerlink" title="编译阶段：加入调试信息"></a>编译阶段：加入调试信息</h2><p>为了让 GDB 能看到函数名、变量名、源码行号，<strong>编译时必须加上 <code>-g</code> 参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -g hello.c -o hello        <span class="comment"># 对 C 程序</span></span><br><span class="line">g++ -g hello.cpp -o hello      <span class="comment"># 对 C++ 程序</span></span><br></pre></td></tr></table></figure><p>否则 GDB 只能看到汇编和内存地址，无法进行源码级调试。</p><hr><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><h3 id="调试一个程序"><a href="#调试一个程序" class="headerlink" title="调试一个程序"></a><strong>调试一个程序</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program</span><br></pre></td></tr></table></figure><h4 id="设置程序运行参数"><a href="#设置程序运行参数" class="headerlink" title="设置程序运行参数"></a><strong>设置程序运行参数</strong></h4><ul><li><p><strong>设置运行参数（如命令行参数）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> args 10 20 30</span><br></pre></td></tr></table></figure></li><li><p><strong>查看当前设置的参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show args</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="设置运行环境变量"><a href="#设置运行环境变量" class="headerlink" title="设置运行环境变量"></a><strong>设置运行环境变量</strong></h4><ul><li><p><strong>设置程序运行路径（用于找可执行文件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path /your/bin/dir</span><br></pre></td></tr></table></figure></li><li><p><strong>查看运行路径设置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show paths</span><br></pre></td></tr></table></figure></li><li><p><strong>设置环境变量</strong>（例如传给 <code>main()</code> 程序用的环境）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> environment USER=yourname</span><br></pre></td></tr></table></figure></li><li><p><strong>查看环境变量</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show environment</span><br><span class="line">show environment USER</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="设置工作目录"><a href="#设置工作目录" class="headerlink" title="设置工作目录"></a><strong>设置工作目录</strong></h4><p>设置工作目录指的是程序运行时的当前目录</p><ul><li><p><strong>切换当前目录</strong>（等同于 shell 的 <code>cd</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/dir</span><br></pre></td></tr></table></figure></li><li><p><strong>查看当前目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="控制程序的输入输出"><a href="#控制程序的输入输出" class="headerlink" title="控制程序的输入输出"></a><strong>控制程序的输入输出</strong></h4><ul><li><p><strong>查看程序绑定的终端信息</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info terminal</span><br></pre></td></tr></table></figure></li><li><p><strong>重定向输出（如保存输出到文件）</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run &gt; output.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>指定程序输入输出使用的终端设备</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tty</span> /dev/pts/1</span><br></pre></td></tr></table></figure></li></ul><h3 id="调试-core-dump-文件"><a href="#调试-core-dump-文件" class="headerlink" title="调试 core dump 文件"></a><strong>调试 core dump 文件</strong></h3><p>core dump是程序崩溃后的转储</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program core</span><br></pre></td></tr></table></figure><h4 id="打开core文件生成功能"><a href="#打开core文件生成功能" class="headerlink" title="打开core文件生成功能"></a>打开core文件生成功能</h4><p>Linux <strong>默认没有打开core文件生成功能</strong>，也就是发生段错误时不会<code>core dumped</code>。可以通过以下命令打开<code>core</code>文件的生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不限制产生 core 的大小</span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p><code>unlimited</code> 意思是系统<strong>不限制core文件的大小</strong>，只要有足够的磁盘空间，会转存程序所占用的全部内存，如果需要限制系统产生 <code>core</code>的大小，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core 最大限制大小为 409600 字节</span></span><br><span class="line"><span class="built_in">ulimit</span> -c 409600</span><br></pre></td></tr></table></figure><h4 id="关闭core文件生成功能"><a href="#关闭core文件生成功能" class="headerlink" title="关闭core文件生成功能"></a>关闭core文件生成功能</h4><p>把核心转储功能关闭，只需要将限制大小设为<code>0</code> 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c 0</span><br></pre></td></tr></table></figure><p><strong>注意，如果只是输入命令“<code>ulimit -c unlimited</code>”，这只会在当前终端有效，退出终端或者打开一个新的终端时是无效的</strong>。</p><p>例子：</p><p>编写一个简单的C程序，人为制造一个<code>Segmentation fault</code>错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给一个NULL指令赋值，会产生 Segmentation fault 错误</span></span><br><span class="line">  *p = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中定义了一个空指针变量P，然后给空指针P赋值，运行程序就会<strong>产生一个段错误</strong>。</p><p>开启了<strong>核心转储</strong>后，就会产生一个<code>core</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译 hello.c 生成 hello 程序</span></span><br><span class="line">gcc -o hello hello.c -g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行该程序</span></span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p>运行后，我们可以看到 <code>Segmentation fault (core dumped)</code> 提示信息，表示已经在当前目录下产生了一个<code>core</code>文件：</p><h3 id="调试正在运行的程序"><a href="#调试正在运行的程序" class="headerlink" title="调试正在运行的程序"></a><strong>调试正在运行的程序</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program &lt;PID&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>直接指定 PID 启动 GDB</strong>（需要有可执行程序路径）：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./program &lt;PID&gt;</span><br></pre></td></tr></table></figure><ol><li><strong>在 GDB 内 attach 到某个 PID</strong>：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach &lt;PID&gt;</span><br><span class="line">(gdb) detach   # 取消 attach</span><br></pre></td></tr></table></figure><hr><h2 id="常用启动参数"><a href="#常用启动参数" class="headerlink" title="常用启动参数"></a>常用启动参数</h2><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-s</code> 或 <code>-symbols &lt;file&gt;</code></td><td>指定符号表文件</td></tr><tr><td><code>-se &lt;file&gt;</code></td><td>指定符号表文件，并关联到可执行文件</td></tr><tr><td><code>-c</code> 或 <code>-core &lt;file&gt;</code></td><td>指定 core dump 文件用于调试</td></tr><tr><td><code>-d</code> 或 <code>-directory &lt;dir&gt;</code></td><td>添加源码搜索路径（默认用 <code>$PATH</code>）</td></tr></tbody></table></div><p>退出输入quit(q)即可</p><h2 id="gdb中运行Shell"><a href="#gdb中运行Shell" class="headerlink" title="gdb中运行Shell"></a>gdb中运行Shell</h2><p>在 GDB 中可以直接运行操作系统的命令，方法是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell &lt;命令字符串&gt;</span><br></pre></td></tr></table></figure><p>example</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell <span class="built_in">ls</span> -l</span><br><span class="line">(gdb) shell <span class="built_in">cat</span> input.txt</span><br></pre></td></tr></table></figure><p>这会在 GDB 内部启动你系统的 shell（由环境变量 <code>SHELL</code> 决定），然后执行你写的命令。</p><p>GDB 也内置了一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) make &lt;参数&gt;</span><br></pre></td></tr></table></figure><p>它本质上等价于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) shell make &lt;参数&gt;</span><br></pre></td></tr></table></figure><p>也就是说，它会调用系统的 <code>make</code> 工具来重新编译程序，非常方便调试时快速修改代码后重新 build。</p><h1 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h1><h2 id="断点-breakpoint"><a href="#断点-breakpoint" class="headerlink" title="断点 (breakpoint)"></a>断点 (breakpoint)</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><h4 id="按函数名设置断点"><a href="#按函数名设置断点" class="headerlink" title="按函数名设置断点"></a>按函数名设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> <span class="keyword">function</span></span><br></pre></td></tr></table></figure><ul><li>在指定函数的<strong>入口</strong>处停下。</li><li>对于 C++ 可以写成：<ul><li><code>break ClassName::Function</code></li><li><code>break function(type1, type2)</code>（如果重载）</li></ul></li></ul><h4 id="按行号设置断点"><a href="#按行号设置断点" class="headerlink" title="按行号设置断点"></a>按行号设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> 42</span><br></pre></td></tr></table></figure><ul><li>在当前源文件的第 <strong>42 行</strong> 设断点。</li></ul><h4 id="相对当前行设置断点"><a href="#相对当前行设置断点" class="headerlink" title="相对当前行设置断点"></a>相对当前行设置断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> +5     // 当前行之后5行</span><br><span class="line"><span class="built_in">break</span> -3     // 当前行之前3行</span><br></pre></td></tr></table></figure><h4 id="指定文件-行号"><a href="#指定文件-行号" class="headerlink" title="指定文件 + 行号"></a>指定文件 + 行号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> filename.c:42</span><br></pre></td></tr></table></figure><ul><li>在 <code>filename.c</code> 的第 42 行设置断点。</li></ul><h4 id="指定文件-函数名"><a href="#指定文件-函数名" class="headerlink" title="指定文件 + 函数名"></a>指定文件 + 函数名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> filename.c:func</span><br></pre></td></tr></table></figure><ul><li>在 <code>filename.c</code> 中 <code>func</code> 函数的入口处设置断点。</li></ul><h4 id="按地址设置断点"><a href="#按地址设置断点" class="headerlink" title="按地址设置断点"></a>按地址设置断点</h4><p>常用于汇编调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> *0x4007d0</span><br></pre></td></tr></table></figure><ul><li>在程序内存地址 <code>0x4007d0</code> 处设置断点。</li></ul><h4 id="设置条件断点"><a href="#设置条件断点" class="headerlink" title="设置条件断点"></a>设置条件断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> func <span class="keyword">if</span> i == 100</span><br></pre></td></tr></table></figure><ul><li>当变量 <code>i == 100</code> 且执行到 <code>func</code> 函数时才停下。</li></ul><h4 id="设置下一条语句的断点（无参数）"><a href="#设置下一条语句的断点（无参数）" class="headerlink" title="设置下一条语句的断点（无参数）"></a>设置下一条语句的断点（无参数）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span></span><br></pre></td></tr></table></figure><ul><li>在“下一条将要执行”的语句处设断点。</li></ul><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><h4 id="查看所有断点"><a href="#查看所有断点" class="headerlink" title="查看所有断点"></a>查看所有断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info breakpoints</span><br></pre></td></tr></table></figure><h4 id="查看指定编号的断点"><a href="#查看指定编号的断点" class="headerlink" title="查看指定编号的断点"></a>查看指定编号的断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info <span class="built_in">break</span> 3</span><br></pre></td></tr></table></figure><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><h4 id="删除某一个断点"><a href="#删除某一个断点" class="headerlink" title="删除某一个断点"></a>删除某一个断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &lt;编号&gt;</span><br></pre></td></tr></table></figure><ul><li>例如：<code>delete 1</code> 表示删除编号为 1 的断点。</li></ul><h4 id="删除多个断点"><a href="#删除多个断点" class="headerlink" title="删除多个断点"></a>删除多个断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete 1 2 3</span><br></pre></td></tr></table></figure><ul><li>同时删除断点 1、2 和 3。</li></ul><h4 id="删除所有断点"><a href="#删除所有断点" class="headerlink" title="删除所有断点"></a>删除所有断点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete</span><br></pre></td></tr></table></figure><ul><li><strong>不加参数</strong>表示删除所有断点。GDB 会提示你确认（输入 <code>y</code>）。</li></ul><h2 id="观察点-watchpoint"><a href="#观察点-watchpoint" class="headerlink" title="观察点 (watchpoint)"></a>观察点 (watchpoint)</h2><h3 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h3><h4 id="watch-lt-expr-gt"><a href="#watch-lt-expr-gt" class="headerlink" title="watch &lt;expr&gt;"></a><code>watch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 的 <strong>值被改变</strong> 时，程序会暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch x</span><br></pre></td></tr></table></figure><p>当变量 <code>x</code> 的值发生变化时暂停。</p></li></ul><h4 id="rwatch-lt-expr-gt"><a href="#rwatch-lt-expr-gt" class="headerlink" title="rwatch &lt;expr&gt;"></a><code>rwatch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 被<strong>读取</strong>时，程序暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwatch y</span><br></pre></td></tr></table></figure><p>当变量 <code>y</code> 被读取时暂停程序。</p></li></ul><h4 id="awatch-lt-expr-gt"><a href="#awatch-lt-expr-gt" class="headerlink" title="awatch &lt;expr&gt;"></a><code>awatch &lt;expr&gt;</code></h4><ul><li><p><strong>用途</strong>：当表达式或变量 <code>expr</code> 被<strong>读取或写入</strong>时，程序暂停。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awatch z</span><br></pre></td></tr></table></figure><p>当变量 <code>z</code> 被读取或写入时都暂停。</p></li></ul><h3 id="查看当前观察点"><a href="#查看当前观察点" class="headerlink" title="查看当前观察点"></a>查看当前观察点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info watchpoints</span><br></pre></td></tr></table></figure><ul><li>显示所有设置的观察点（类似 <code>info breakpoints</code>）。</li></ul><h3 id="删除观察点"><a href="#删除观察点" class="headerlink" title="删除观察点"></a>删除观察点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &lt;编号&gt;</span><br></pre></td></tr></table></figure><ul><li>与删除断点的方式一样。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>观察点依赖于 <strong>目标架构是否支持硬件观察点</strong>（大多数支持）。</li><li>不支持的情况下，GDB 可能无法设置 <code>watch</code>、<code>rwatch</code> 等。</li><li>观察点数量受限，一般比断点少（通常是 4 个）。</li></ul><h2 id="捕捉点-catchpoint"><a href="#捕捉点-catchpoint" class="headerlink" title="捕捉点 (catchpoint)"></a>捕捉点 (catchpoint)</h2><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch &lt;event&gt;</span><br></pre></td></tr></table></figure><p>也可以使用一次性的捕捉点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcatch &lt;event&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="常见-catchpoint-类型"><a href="#常见-catchpoint-类型" class="headerlink" title="常见 catchpoint 类型"></a>常见 catchpoint 类型</h3><div class="table-container"><table><thead><tr><th>事件类型</th><th>描述说明</th></tr></thead><tbody><tr><td><code>throw</code></td><td>捕捉 C++ 程序抛出异常的位置。</td></tr><tr><td><code>catch</code></td><td>捕捉 C++ 程序捕获异常的位置。</td></tr><tr><td><code>exec</code></td><td>捕捉程序调用 <code>exec()</code> 系统调用（替换进程映像）。</td></tr><tr><td><code>fork</code></td><td>捕捉程序调用 <code>fork()</code> 系统调用（创建子进程）。</td></tr><tr><td><code>vfork</code></td><td>捕捉 <code>vfork()</code> 调用（特殊类型的 <code>fork()</code>）。</td></tr><tr><td><code>load</code></td><td>捕捉动态链接库的加载事件。</td></tr><tr><td><code>unload</code></td><td>捕捉动态链接库的卸载事件。</td></tr></tbody></table></div><p> 示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch throw</span><br></pre></td></tr></table></figure><blockquote><p>在 C++ 抛出异常时中断程序。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch fork</span><br></pre></td></tr></table></figure><blockquote><p>在程序调用 <code>fork()</code> 时中断。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcatch <span class="built_in">exec</span></span><br></pre></td></tr></table></figure><blockquote><p>设置一次性的捕捉点，在程序调用 <code>exec()</code> 系统调用时暂停，之后自动移除。</p></blockquote><h2 id="程序停止点清除"><a href="#程序停止点清除" class="headerlink" title="程序停止点清除"></a>程序停止点清除</h2><h3 id="清除停止点（clear）"><a href="#清除停止点（clear）" class="headerlink" title="清除停止点（clear）"></a>清除停止点（clear）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clear                    <span class="comment"># 清除当前位置所有停止点</span></span><br><span class="line">clear &lt;<span class="keyword">function</span>&gt;         <span class="comment"># 清除函数上的所有停止点</span></span><br><span class="line">clear &lt;filename:<span class="keyword">function</span>&gt;# 指定源文件和函数</span><br><span class="line">clear &lt;linenum&gt;          <span class="comment"># 清除当前文件某行的断点</span></span><br><span class="line">clear &lt;filename:linenum&gt; <span class="comment"># 指定文件+行号清除</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：<code>clear</code> 是基于“<strong>位置</strong>”清除，而非编号。</p></blockquote><h3 id="删除断点（delete）"><a href="#删除断点（delete）" class="headerlink" title="删除断点（delete）"></a>删除断点（delete）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete                   <span class="comment"># 删除所有断点</span></span><br><span class="line">delete &lt;bnum&gt;            <span class="comment"># 删除指定编号的断点</span></span><br><span class="line">delete &lt;range&gt;           <span class="comment"># 如 delete 3-5，删除编号 3 到 5 的断点</span></span><br><span class="line">d                        <span class="comment"># delete 的简写</span></span><br></pre></td></tr></table></figure><h3 id="禁用-启用断点（disable-enable）"><a href="#禁用-启用断点（disable-enable）" class="headerlink" title="禁用/启用断点（disable / enable）"></a>禁用/启用断点（disable / enable）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span>                  <span class="comment"># 禁用所有断点</span></span><br><span class="line"><span class="built_in">disable</span> &lt;bnum&gt; [range]   <span class="comment"># 禁用特定断点</span></span><br><span class="line">dis                      <span class="comment"># disable 的简写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">enable</span>                   <span class="comment"># 启用所有断点</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt;            <span class="comment"># 启用某个断点</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt; once       <span class="comment"># 执行一次后自动 disable</span></span><br><span class="line"><span class="built_in">enable</span> &lt;bnum&gt; delete     <span class="comment"># 执行一次后自动删除</span></span><br></pre></td></tr></table></figure><blockquote><p>推荐使用 <code>disable/enable</code> 管理调试状态，灵活又不丢失断点信息。</p></blockquote><hr><h3 id="设置-修改-条件（condition）"><a href="#设置-修改-条件（condition）" class="headerlink" title="设置 / 修改 条件（condition）"></a>设置 / 修改 条件（condition）</h3><h4 id="设置条件断点（设置时）"><a href="#设置条件断点（设置时）" class="headerlink" title="设置条件断点（设置时）"></a>设置条件断点（设置时）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> foo <span class="keyword">if</span> x &gt; 5</span><br><span class="line">watch var <span class="keyword">if</span> var == 0</span><br></pre></td></tr></table></figure><h4 id="修改断点条件（维护时）"><a href="#修改断点条件（维护时）" class="headerlink" title="修改断点条件（维护时）"></a>修改断点条件（维护时）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">condition &lt;bnum&gt; x &gt; 100     <span class="comment"># 修改断点编号为 bnum 的条件</span></span><br><span class="line">condition &lt;bnum&gt;            <span class="comment"># 清除断点条件</span></span><br></pre></td></tr></table></figure><hr><h3 id="忽略断点次数（ignore）"><a href="#忽略断点次数（ignore）" class="headerlink" title="忽略断点次数（ignore）"></a>忽略断点次数（ignore）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignore &lt;bnum&gt; &lt;count&gt;   <span class="comment"># 忽略断点号 bnum 的触发 count 次</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ignore 2 3</span><br></pre></td></tr></table></figure><blockquote><p>忽略断点 2 的前三次命中，第 4 次才真正中断。</p></blockquote><h4 id="为断点添加命令序列"><a href="#为断点添加命令序列" class="headerlink" title="为断点添加命令序列"></a>为断点添加命令序列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commands &lt;bnum&gt;</span><br><span class="line">...gdb命令序列...</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">break</span> foo <span class="keyword">if</span> x &gt; 0</span><br><span class="line">commands</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;x is %d\n&quot;</span>, x</span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>作用：x &gt; 0 时断点命中，打印后自动继续，不用手动按 <code>c</code>。</p></blockquote><h4 id="清除已有命令"><a href="#清除已有命令" class="headerlink" title="清除已有命令"></a>清除已有命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands &lt;bnum&gt;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>example</p><ul><li><p>调试循环或大函数中的问题时，建议使用：<br> <code>break &lt;line&gt; if i == 9999</code><br> 或<br> <code>ignore &lt;bnum&gt; 9998</code></p></li><li><p>在你定位 bug 后，不要删断点，直接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> &lt;bnum&gt;  <span class="comment"># 保留断点以后复用</span></span><br></pre></td></tr></table></figure></li><li><p>想测试多个变量变化时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch a</span><br><span class="line">watch b</span><br></pre></td></tr></table></figure></li><li><p>想搞自动化调试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">silent</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;Reached here\n&quot;</span></span><br><span class="line"><span class="built_in">continue</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></li></ul><h2 id="调试程序执行"><a href="#调试程序执行" class="headerlink" title="调试程序执行"></a>调试程序执行</h2><h3 id="恢复程序运行（继续执行）"><a href="#恢复程序运行（继续执行）" class="headerlink" title="恢复程序运行（继续执行）"></a>恢复程序运行（继续执行）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>continue</code> / <code>c</code> / <code>fg</code></td><td>从当前断点处继续运行</td></tr><tr><td><code>continue &lt;ignore-count&gt;</code></td><td>忽略接下来的 <code>&lt;count&gt;</code> 次断点命中</td></tr><tr><td><code>run</code> / <code>r</code></td><td>重新启动程序（从头开始）</td></tr></tbody></table></div><blockquote><p>适用于程序刚停下，想跳过一些断点或继续往下执行。</p></blockquote><h3 id="单步调试（源代码级）"><a href="#单步调试（源代码级）" class="headerlink" title="单步调试（源代码级）"></a>单步调试（源代码级）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>step</code> / <code>s</code></td><td>单步执行，会进入函数（Step Into）</td></tr><tr><td><code>next</code> / <code>n</code></td><td>单步执行，不进入函数（Step Over）</td></tr><tr><td><code>step &lt;count&gt;</code> / <code>next &lt;count&gt;</code></td><td>连续执行 <code>&lt;count&gt;</code> 步</td></tr></tbody></table></div><blockquote><p>用于逐行查看程序逻辑，<code>step</code> 会进函数内部，<code>next</code> 则略过。</p></blockquote><h3 id="退出当前函数（函数级跳出）"><a href="#退出当前函数（函数级跳出）" class="headerlink" title="退出当前函数（函数级跳出）"></a>退出当前函数（函数级跳出）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>finish</code></td><td>继续运行到当前函数返回，并打印返回值和返回地址</td></tr></tbody></table></div><blockquote><p>非常实用，适合跟踪完某个函数后退出它。</p></blockquote><h3 id="跳出循环体-块（until）"><a href="#跳出循环体-块（until）" class="headerlink" title="跳出循环体 / 块（until）"></a>跳出循环体 / 块（until）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>until &lt;location&gt;</code> / <code>u</code></td><td>执行直到某个位置或当前块结束（适合退出循环）</td></tr></tbody></table></div><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> 42            <span class="comment"># 运行到当前文件的第 42 行</span></span><br><span class="line"><span class="keyword">until</span> main.c:100    <span class="comment"># 运行到 main.c 第 100 行</span></span><br></pre></td></tr></table></figure><blockquote><p>用于快速跳出 for/while 循环等结构块。</p></blockquote><h3 id="汇编级单步（指令级调试）"><a href="#汇编级单步（指令级调试）" class="headerlink" title="汇编级单步（指令级调试）"></a>汇编级单步（指令级调试）</h3><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>stepi</code> / <code>si</code></td><td>单步执行一条机器指令（Step Into）</td></tr><tr><td><code>nexti</code> / <code>ni</code></td><td>单步执行一条机器指令（Step Over）</td></tr></tbody></table></div><blockquote><p>用于底层跟踪，比如跟踪系统调用、libc 内部逻辑或 boot code。</p></blockquote><p>汇编查看建议：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display/i <span class="variable">$pc</span>     <span class="comment"># 实时显示当前执行指令</span></span><br></pre></td></tr></table></figure><h3 id="设置-step-mode-模式"><a href="#设置-step-mode-模式" class="headerlink" title="设置 step-mode 模式"></a>设置 step-mode 模式</h3><p>主要用于控制是否进入无符号函数</p><div class="table-container"><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>set step-mode on</code></td><td>即使没有 debug 符号也停住（默认 off）</td></tr><tr><td><code>set step-mode off</code></td><td>遇到无符号函数就跳过（默认）</td></tr></tbody></table></div><blockquote><p>对调试汇编或只含部分符号的库文件时很有用。</p></blockquote><h1 id="查看运行时数据"><a href="#查看运行时数据" class="headerlink" title="查看运行时数据"></a>查看运行时数据</h1><p>程序暂停时，使用print命令（简写p）或者用同义命令inspect查看当前程序的运行数据，格式为：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="symbol">&lt;expr&gt;</span></span><br><span class="line"><span class="keyword">print</span>/<span class="symbol">&lt;f&gt;</span> <span class="symbol">&lt;expr&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li><expr>为要调试的程序语言的表达式</li><li><f>是format的意思，比如按16进制输出就是/x</li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一般来说，GDB 会根据变量的类型输出变量的值。但你也可以自定义 GDB 的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整<br>型变量的中的位的情况。要做到这样，你可以使用 GDB 的数据显示格式： </p><ul><li>x  按十六进制格式显示变量。       (hex)</li><li>d  按十进制格式显示变量。        (decimal)</li><li>u  按十六进制格式显示无符号整型。 (unsinged hex)</li><li>o  按八进制格式显示变量。        (octal)</li><li>t  按二进制格式显示变量。        (two)</li><li>a  按十六进制格式显示变量。      (address)</li><li>c  按字符格式显示变量。         (char)</li><li>f  按浮点数格式显示变量。       (float)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p i </span><br><span class="line"><span class="variable">$21</span> = 101   </span><br><span class="line">(gdb) p/a i </span><br><span class="line"><span class="variable">$22</span> = 0x65 </span><br><span class="line">(gdb) p/c i </span><br><span class="line"><span class="variable">$23</span> = 101 <span class="string">&#x27;e&#x27;</span> </span><br><span class="line">(gdb) p/f i </span><br><span class="line"><span class="variable">$24</span> = 1.41531145e-43 (gdb) p/x i </span><br><span class="line"><span class="variable">$25</span> = 0x65 </span><br><span class="line">(gdb) p/t i </span><br><span class="line"><span class="variable">$26</span> = 1100101 </span><br></pre></td></tr></table></figure><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式可以是当前程序运行中的const常量，变量，函数等内容，但不能是程序中定义的宏</p><h3 id="程序变量"><a href="#程序变量" class="headerlink" title="程序变量"></a>程序变量</h3><p>在 GDB 中，你可以随时查看以下三种变量的值： </p><ol><li>全局变量（所有文件可见的） </li><li>静态全局变量（当前文件可见的） </li><li>局部变量（当前 Scope 可见的）</li></ol><p>用 print 显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用“::”操作符：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>::<span class="keyword">variable</span> </span><br><span class="line">function::<span class="keyword">variable</span> </span><br></pre></td></tr></table></figure><br>example<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb) p <span class="string">&#x27;f2.c&#x27;</span>::x </span><br></pre></td></tr></table></figure><br><div class="tip warning faa-horizontal animated"><p>注意：如果你的程序编译时开启了优化选项，那么在用 GDB调试被优化过的程序时，可能会发生某些变量不能访问，或是取值错误码的情况。这个是很正常的，因为优化程序会删改你的程序，整理你程序的语句顺序，剔除一些无意义的变量等，所以在 GDB 调试这种程序时，运行时的指令和你所编写指令就有不一样，也就会出现你所想象不到的结果。对付这种情况时，需要在编译程序时关闭编译优化。一般来说，几乎所有的编译器都支持编译优化的开关，例如，GNU 的 C/C++编译器 GCC，你可以使用“-gstabs”选项来解决这个问题。</p></div></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="built_in">array</span> = (<span class="type">int</span> *) <span class="built_in">malloc</span> (len * <span class="keyword">sizeof</span> (<span class="type">int</span>)); </span><br></pre></td></tr></table></figure><p>在 GDB 调试过程中，你可以以如下命令显示出这个动态数组的取值：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> *array<span class="keyword">@len</span> </span><br></pre></td></tr></table></figure><br> @的左边是数组的首地址的值，也就是变量 array 所指向的内容，右边则是数据的长度，其保存在变量 len 中，其输出结果，大约是下面这个样子的：<br> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p <span class="number">*a</span>rray@len </span><br><span class="line"><span class="variable">$1</span> = &#123;2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40&#125; 如果是静态数组的话，可以直接用 <span class="built_in">print</span> 数组名，就可以显示数组中所有数据的内容了。 </span><br></pre></td></tr></table></figure></p><p>如果是静态数组的话，可以直接用 print 数组名，就可以显示数组中所有数据的内容了。</p><h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><p>使用 examine 命令（简写是 x）来查看内存地址中的值。x 命令的语法如下所示：<br><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/<span class="attribute">&lt;n/f/u&gt;</span> <span class="attribute">&lt;addr&gt;</span>  </span><br></pre></td></tr></table></figure></p><ul><li><p>n：显示的个数，即从内存地址 <addr> 开始，显示几个单位（默认为 1）。</p></li><li><p>f：显示格式，比如：</p><ul><li>x 十六进制</li><li>d 十进制</li><li>t 二进制</li><li>c 字符</li><li>f 浮点数</li><li>s 字符串</li><li>i 指令</li></ul></li><li><p>u：读取单位的大小，决定每次读取多少字节：</p><ul><li>b = 1 字节（byte）</li><li>h = 2 字节（half word）</li><li>w = 4 字节（word，默认）</li><li>g = 8 字节（giant/quad word）</li></ul></li></ul><h2 id="查看寄存器"><a href="#查看寄存器" class="headerlink" title="查看寄存器"></a>查看寄存器</h2><p>要查看寄存器的值，很简单，可以使用info registers (i r)<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看寄存器的情况。（除了浮点寄存器） </span></span><br><span class="line"><span class="built_in">info</span> all-registers </span><br><span class="line"><span class="comment"># 查看所有寄存器的情况。（包括浮点寄存器） </span></span><br><span class="line"><span class="built_in">info</span> registers &lt;regname <span class="built_in">..</span>.&gt; </span><br></pre></td></tr></table></figure><br>也可以使用 print 命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">p</span> <span class="variable">$eip</span>。</span><br></pre></td></tr></table></figure></p><p>查看所指定的寄存器的情况。<br>寄存器中放置了程序运行时的数据，比如程序当前运行的指令地址（ip），程序的当前堆栈地址（sp）等等。你同样可以使用 print 命令来访问寄存器的情况，只需要在寄存器名字前加一个$符号就可以了。如：p $eip。</p><h2 id="自动显示"><a href="#自动显示" class="headerlink" title="自动显示"></a>自动显示</h2><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的 GDB 命令是 display。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">display</span> <span class="symbol">&lt;expr&gt;</span>  </span><br><span class="line"><span class="keyword">display</span>/<span class="symbol">&lt;fmt&gt;</span> <span class="symbol">&lt;expr&gt;</span>  </span><br><span class="line"><span class="keyword">display</span>/<span class="symbol">&lt;fmt&gt;</span> <span class="symbol">&lt;addr&gt;</span> </span><br></pre></td></tr></table></figure></p><ul><li>expr 是一个表达式</li><li>fmt 表示显示的格式</li><li>addr 表示内存地址<br>当你用display 设定好了一个或多个表达式后，只要你的程序被停下来，GDB 会自动显示你所设置的这些表达式的值。 </li></ul><p>格式 i 和 s 同样被 display 支持，一个非常有用的命令是： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display/i <span class="variable">$pc</span> </span><br></pre></td></tr></table></figure><p>$pc 是 GDB 的环境变量，表示着指令的地址，/i 则表示输出格式为机器指令码，也就是汇编。于是当程序停下后，就会出现源代码和机器指令码相对应的情形</p><h3 id="删除自动显示"><a href="#删除自动显示" class="headerlink" title="删除自动显示"></a>删除自动显示</h3><p>要删除自动显示可以用下面的命令<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undisplay &lt;dnums...&gt; </span><br><span class="line"><span class="keyword">delete</span> display &lt;dnums...&gt; </span><br></pre></td></tr></table></figure></p><ul><li>dnums 意为所设置好了的自动显式的编号。<br>如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5） </li></ul><h3 id="隐藏自动显示"><a href="#隐藏自动显示" class="headerlink" title="隐藏自动显示"></a>隐藏自动显示</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> display &lt;dnums<span class="built_in">..</span>.&gt; </span><br><span class="line"><span class="built_in">enable</span> display &lt;dnums<span class="built_in">..</span>.&gt; </span><br></pre></td></tr></table></figure><p>disable 和 enalbe 不删除自动显示的设置，而只是让其失效和恢复。 </p><h3 id="查看设置的自动显示的信息"><a href="#查看设置的自动显示的信息" class="headerlink" title="查看设置的自动显示的信息"></a>查看设置的自动显示的信息</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">info</span> display </span><br></pre></td></tr></table></figure><p>查看 display 设置的自动显示的信息。GDB 会打出一张表格，向你报告当然调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否 enable。 </p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小Linux系统编译与运行</title>
      <link href="/posts/42869/"/>
      <url>/posts/42869/</url>
      
        <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>win11 WSL2：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/CCECAA6776058E5E7B3BD5CD47C415D9.png" alt="环境"></p><h1 id="busybox编译"><a href="#busybox编译" class="headerlink" title="busybox编译"></a>busybox编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.busybox.net/downloads/busybox-1.37.0.tar.bz2</span><br><span class="line">bzip2 -d busybox-1.37.0.tar.bz2</span><br><span class="line">tar xvf busybox-1.37.0.tar</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> busybox-1.37.0</span><br></pre></td></tr></table></figure><h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>这个版本直接编译aarch64有点问题，需要打一个补丁：</p>   <div class="tag link"><a class="link-card" title="libbb/sha: add missing sha-NI guard" href="https://lists.busybox.net/pipermail/busybox/2024-September/090899.html"><div class="left"><img src="https://www.busybox.net/favicon.ico"/></div><div class="right"><p class="text">libbb/sha: add missing sha-NI guard</p><p class="url">https://lists.busybox.net/pipermail/busybox/2024-September/090899.html</p></div></a></div><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- clean</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"><span class="comment"># Settings</span></span><br><span class="line"><span class="comment"># --- Build Option</span></span><br><span class="line"><span class="comment">#   [*] Build static binary (no shared libs)</span></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- install</span><br></pre></td></tr></table></figure><h2 id="创建inittab-rcS和fstab文件"><a href="#创建inittab-rcS和fstab文件" class="headerlink" title="创建inittab,rcS和fstab文件"></a>创建inittab,rcS和fstab文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> _install</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p dev etc home lib mnt proc root sys tmp var</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> etc/inittab</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d/</span><br><span class="line"><span class="built_in">touch</span> etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span> etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 755 etc/inittab</span><br><span class="line"><span class="built_in">chmod</span> 755 etc/init.d/rcS</span><br></pre></td></tr></table></figure><p>inittab语法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;id&gt;<span class="symbol">:&lt;runlevels&gt;</span><span class="symbol">:&lt;action&gt;</span><span class="symbol">:&lt;process&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>id : /dev/id</li><li>runlevels : 忽略</li><li>action : 何时执行，有以下选项 sysinit, respawn, askfirst, wait, once,restart, ctrlaltdel, and shutdown</li><li>process : 应用程序或脚本</li></ul><p>etc/inittab 写入以下内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br></pre></td></tr></table></figure></p><p>etc/init.d/rcS写入如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/bin/mount -a </span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="keyword">if</span> [ -e /proc/sys/kernel/hotplug ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure><br>etc/fstab写入如下内容:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#device mount-point type option dump fsck</span></span><br><span class="line">proc  /proc proc  defaults 0 0</span><br><span class="line">tmpfs /tmp tmpfs defaults 0 0</span><br><span class="line">none  /tmp  ramfs defaults 0 0</span><br><span class="line">sysfs /sys  sysfs defaults 0 0</span><br><span class="line">mdev  /dev  ramfs defaults 0 0</span><br></pre></td></tr></table></figure></p><h2 id="添加设备文件"><a href="#添加设备文件" class="headerlink" title="添加设备文件"></a>添加设备文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dev</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> console c 5 1</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> null c 1 3</span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> busybox-1.37.0/_install</span><br><span class="line">find . | cpio -o -H newc | gzip -c &gt; ../initramfs.cpio.gz</span><br><span class="line"><span class="built_in">cp</span> ../initramfs.cpio.gz ~/tftp</span><br></pre></td></tr></table></figure><h1 id="Linux-内核编译"><a href="#Linux-内核编译" class="headerlink" title="Linux 内核编译"></a>Linux 内核编译</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install gcc-aarch64-linux-gnu</span><br><span class="line"><span class="built_in">sudo</span> apt install libssl-dev</span><br><span class="line"></span><br><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.238.tar.xz</span><br><span class="line">tar xvf linux-5.10.238.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.10.238</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- clean</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"></span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image -j$(<span class="built_in">nproc</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm64/boot/Image ~/tftp</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="qemu运行"><a href="#qemu运行" class="headerlink" title="qemu运行"></a>qemu运行</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">  -cpu cortex-a57 \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -machine <span class="built_in">type</span>=virt \</span><br><span class="line">  -nographic \</span><br><span class="line">  -smp 2 \</span><br><span class="line">  -kernel ~/tftp/Image  \</span><br><span class="line">  -initrd ~/tftp/initramfs.cpio.gz   \</span><br><span class="line">  -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">  -device virtio-scsi-device</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line">zhaohang@ZhaoHang:~/kernel/my_arm64_programming$ qemu-system-aarch64 \</span><br><span class="line">  -cpu cortex-a57 \</span><br><span class="line">  -m 512M \</span><br><span class="line">  -machine <span class="built_in">type</span>=virt \</span><br><span class="line">  -nographic \</span><br><span class="line">  -smp 2 \</span><br><span class="line">  -kernel ~/tftp/Image  \</span><br><span class="line">  -initrd ~/tftp/initramfs.cpio.gz   \</span><br><span class="line">  -append <span class="string">&quot;rdinit=/linuxrc console=ttyAMA0&quot;</span> \</span><br><span class="line">  -device virtio-scsi-device</span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd070]</span><br><span class="line">[    0.000000] Linux version 5.10.238 (zhaohang@ZhaoHang) (aarch64-linux-gnu-gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils <span class="keyword">for</span> Ubuntu) 2.38) <span class="comment">#2 SMP PREEMPT Mon Jun 23 13:01:18 CST 2025</span></span><br><span class="line">[    0.000000] random: crng init <span class="keyword">done</span></span><br><span class="line">[    0.000000] Machine model: linux,dummy-virt</span><br><span class="line">[    0.000000] efi: UEFI not found.</span><br><span class="line">[    0.000000] NUMA: No NUMA configuration found</span><br><span class="line">[    0.000000] NUMA: Faking a node at [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] NUMA: NODE_DATA [mem 0x5fef4b00-0x5fef6fff]</span><br><span class="line">[    0.000000] Zone ranges:</span><br><span class="line">[    0.000000]   DMA      [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000]   DMA32    empty</span><br><span class="line">[    0.000000]   Normal   empty</span><br><span class="line">[    0.000000] Movable zone start <span class="keyword">for</span> each node</span><br><span class="line">[    0.000000] Early memory node ranges</span><br><span class="line">[    0.000000]   node   0: [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] Initmem setup node 0 [mem 0x0000000040000000-0x000000005fffffff]</span><br><span class="line">[    0.000000] cma: Reserved 32 MiB at 0x000000005c000000</span><br><span class="line">[    0.000000] psci: probing <span class="keyword">for</span> conduit method from DT.</span><br><span class="line">[    0.000000] psci: PSCIv1.1 detected <span class="keyword">in</span> firmware.</span><br><span class="line">[    0.000000] psci: Using standard PSCI v0.2 <span class="keyword">function</span> IDs</span><br><span class="line">[    0.000000] psci: Trusted OS migration not required</span><br><span class="line">[    0.000000] psci: SMC Calling Convention v1.0</span><br><span class="line">[    0.000000] percpu: Embedded 23 pages/cpu s56664 r8192 d29352 u94208</span><br><span class="line">[    0.000000] Detected PIPT I-cache on CPU0</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 832075</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 834220</span><br><span class="line">[    0.000000] CPU features: detected: EL2 vector hardening</span><br><span class="line">[    0.000000] CPU features: kernel page table isolation forced ON by KASLR</span><br><span class="line">[    0.000000] CPU features: detected: Kernel page table isolation (KPTI)</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-v2</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-v4</span><br><span class="line">[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or 1530923</span><br><span class="line">[    0.000000] CPU features: detected: Spectre-BHB</span><br><span class="line">[    0.000000] CPU features: detected: ARM erratum 1742098</span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 129024</span><br><span class="line">[    0.000000] Policy zone: DMA</span><br><span class="line">[    0.000000] Kernel <span class="built_in">command</span> line: rdinit=/linuxrc console=ttyAMA0</span><br><span class="line">[    0.000000] Dentry cache <span class="built_in">hash</span> table entries: 65536 (order: 7, 524288 bytes, linear)</span><br><span class="line">[    0.000000] Inode-cache <span class="built_in">hash</span> table entries: 32768 (order: 6, 262144 bytes, linear)</span><br><span class="line">[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span><br><span class="line">[    0.000000] Memory: 439372K/524288K available (14464K kernel code, 2810K rwdata, 7632K rodata, 5952K init, 512K bss, 52148K reserved, 32768K cma-reserved)</span><br><span class="line">[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=2, Nodes=1</span><br><span class="line">[    0.000000] rcu: Preemptible hierarchical RCU implementation.</span><br><span class="line">[    0.000000] rcu:     RCU event tracing is enabled.</span><br><span class="line">[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=256 to nr_cpu_ids=2.</span><br><span class="line">[    0.000000]  Trampoline variant of Tasks RCU enabled.</span><br><span class="line">[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.</span><br><span class="line">[    0.000000] rcu: Adjusting geometry <span class="keyword">for</span> rcu_fanout_leaf=16, nr_cpu_ids=2</span><br><span class="line">[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0</span><br><span class="line">[    0.000000] GICv2m: range[mem 0x08020000-0x08020fff], SPI[80:143]</span><br><span class="line">[    0.000000] arch_timer: cp15 timer(s) running at 62.50MHz (virt).</span><br><span class="line">[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x1cd42e208c, max_idle_ns: 881590405314 ns</span><br><span class="line">[    0.000135] sched_clock: 56 bits at 62MHz, resolution 16ns, wraps every 4398046511096ns</span><br><span class="line">[    0.005145] Console: colour dummy device 80x25</span><br><span class="line">[    0.006576] Calibrating delay loop (skipped), value calculated using timer frequency.. 125.00 BogoMIPS (lpj=250000)</span><br><span class="line">[    0.006668] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.007333] LSM: Security Framework initializing</span><br><span class="line">[    0.008050] Mount-cache <span class="built_in">hash</span> table entries: 1024 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.008075] Mountpoint-cache <span class="built_in">hash</span> table entries: 1024 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.025711] /cpus/cpu-map: empty cluster</span><br><span class="line">[    0.030337] rcu: Hierarchical SRCU implementation.</span><br><span class="line">[    0.032757] EFI services will not be available.</span><br><span class="line">[    0.033350] smp: Bringing up secondary CPUs ...</span><br><span class="line">[    0.036124] Detected PIPT I-cache on CPU1</span><br><span class="line">[    0.036589] CPU1: Booted secondary processor 0x0000000001 [0x411fd070]</span><br><span class="line">[    0.038611] smp: Brought up 1 node, 2 CPUs</span><br><span class="line">[    0.038641] SMP: Total of 2 processors activated.</span><br><span class="line">[    0.038684] CPU features: detected: 32-bit EL0 Support</span><br><span class="line">[    0.038732] CPU features: detected: CRC32 instructions</span><br><span class="line">[    0.038761] CPU features: detected: 32-bit EL1 Support</span><br><span class="line">[    0.087011] CPU: All CPU(s) started at EL1</span><br><span class="line">[    0.087320] alternatives: patching kernel code</span><br><span class="line">[    0.100786] devtmpfs: initialized</span><br><span class="line">[    0.106839] KASLR enabled</span><br><span class="line">[    0.107566] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns</span><br><span class="line">[    0.107783] futex <span class="built_in">hash</span> table entries: 512 (order: 3, 32768 bytes, linear)</span><br><span class="line">[    0.110482] pinctrl core: initialized pinctrl subsystem</span><br><span class="line">[    0.117149] DMI not present or invalid.</span><br><span class="line">[    0.123022] NET: Registered protocol family 16</span><br><span class="line">[    0.130687] DMA: preallocated 128 KiB GFP_KERNEL pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.130888] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.131032] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA32 pool <span class="keyword">for</span> atomic allocations</span><br><span class="line">[    0.131170] audit: initializing netlink subsys (disabled)</span><br><span class="line">[    0.132726] audit: <span class="built_in">type</span>=2000 audit(0.124:1): state=initialized audit_enabled=0 res=1</span><br><span class="line">[    0.135229] thermal_sys: Registered thermal governor <span class="string">&#x27;step_wise&#x27;</span></span><br><span class="line">[    0.135284] thermal_sys: Registered thermal governor <span class="string">&#x27;power_allocator&#x27;</span></span><br><span class="line">[    0.135718] cpuidle: using governor menu</span><br><span class="line">[    0.136329] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.</span><br><span class="line">[    0.136815] ASID allocator initialised with 32768 entries</span><br><span class="line">[    0.139125] Serial: AMBA PL011 UART driver</span><br><span class="line">[    0.165966] 9000000.pl011: ttyAMA0 at MMIO 0x9000000 (irq = 47, base_baud = 0) is a PL011 rev1</span><br><span class="line">[    0.256055] printk: console [ttyAMA0] enabled</span><br><span class="line">[    0.275753] HugeTLB registered 1.00 GiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.276425] HugeTLB registered 32.0 MiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.278075] HugeTLB registered 2.00 MiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.279114] HugeTLB registered 64.0 KiB page size, pre-allocated 0 pages</span><br><span class="line">[    0.287377] cryptd: max_cpu_qlen <span class="built_in">set</span> to 1000</span><br><span class="line">[    0.295509] ACPI: Interpreter disabled.</span><br><span class="line">[    0.298412] iommu: Default domain <span class="built_in">type</span>: Translated</span><br><span class="line">[    0.299715] vgaarb: loaded</span><br><span class="line">[    0.300806] SCSI subsystem initialized</span><br><span class="line">[    0.302702] usbcore: registered new interface driver usbfs</span><br><span class="line">[    0.303416] usbcore: registered new interface driver hub</span><br><span class="line">[    0.303948] usbcore: registered new device driver usb</span><br><span class="line">[    0.305361] pps_core: LinuxPPS API ver. 1 registered</span><br><span class="line">[    0.305774] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;</span><br><span class="line">[    0.306671] PTP clock support registered</span><br><span class="line">[    0.307422] EDAC MC: Ver: 3.0.0</span><br><span class="line">[    0.311302] FPGA manager framework</span><br><span class="line">[    0.312553] Advanced Linux Sound Architecture Driver Initialized.</span><br><span class="line">[    0.320481] clocksource: Switched to clocksource arch_sys_counter</span><br><span class="line">[    0.321721] VFS: Disk quotas dquot_6.6.0</span><br><span class="line">[    0.322248] VFS: Dquot-cache <span class="built_in">hash</span> table entries: 512 (order 0, 4096 bytes)</span><br><span class="line">[    0.325830] pnp: PnP ACPI: disabled</span><br><span class="line">[    0.352101] NET: Registered protocol family 2</span><br><span class="line">[    0.353501] IP idents <span class="built_in">hash</span> table entries: 8192 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.357091] tcp_listen_portaddr_hash <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes, linear)</span><br><span class="line">[    0.357844] TCP established <span class="built_in">hash</span> table entries: 4096 (order: 3, 32768 bytes, linear)</span><br><span class="line">[    0.358536] TCP <span class="built_in">bind</span> <span class="built_in">hash</span> table entries: 4096 (order: 4, 65536 bytes, linear)</span><br><span class="line">[    0.359240] TCP: Hash tables configured (established 4096 <span class="built_in">bind</span> 4096)</span><br><span class="line">[    0.360804] UDP <span class="built_in">hash</span> table entries: 256 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.361461] UDP-Lite <span class="built_in">hash</span> table entries: 256 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.362658] NET: Registered protocol family 1</span><br><span class="line">[    0.366482] RPC: Registered named UNIX socket transport module.</span><br><span class="line">[    0.366894] RPC: Registered udp transport module.</span><br><span class="line">[    0.367151] RPC: Registered tcp transport module.</span><br><span class="line">[    0.367596] RPC: Registered tcp NFSv4.1 backchannel transport module.</span><br><span class="line">[    0.368532] PCI: CLS 0 bytes, default 64</span><br><span class="line">[    0.371336] Unpacking initramfs...</span><br><span class="line">[    0.423234] Freeing initrd memory: 1156K</span><br><span class="line">[    0.425734] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available</span><br><span class="line">[    0.426386] kvm [1]: HYP mode not available</span><br><span class="line">[    0.438866] Initialise system trusted keyrings</span><br><span class="line">[    0.441323] workingset: timestamp_bits=42 max_order=17 bucket_order=0</span><br><span class="line">[    0.449648] squashfs: version 4.0 (2009/01/31) Phillip Lougher</span><br><span class="line">[    0.451781] NFS: Registering the id_resolver key <span class="built_in">type</span></span><br><span class="line">[    0.452635] Key <span class="built_in">type</span> id_resolver registered</span><br><span class="line">[    0.452872] Key <span class="built_in">type</span> id_legacy registered</span><br><span class="line">[    0.453347] nfs4filelayout_init: NFSv4 File Layout Driver Registering...</span><br><span class="line">[    0.453801] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...</span><br><span class="line">[    0.454953] 9p: Installing v9fs 9p2000 file system support</span><br><span class="line">[    0.485329] Key <span class="built_in">type</span> asymmetric registered</span><br><span class="line">[    0.486010] Asymmetric key parser <span class="string">&#x27;x509&#x27;</span> registered</span><br><span class="line">[    0.486459] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 245)</span><br><span class="line">[    0.486881] io scheduler mq-deadline registered</span><br><span class="line">[    0.487275] io scheduler kyber registered</span><br><span class="line">[    0.498447] pl061_gpio 9030000.pl061: PL061 GPIO chip registered</span><br><span class="line">[    0.501854] pci-host-generic 4010000000.pcie: host bridge /pcie@10000000 ranges:</span><br><span class="line">[    0.502917] pci-host-generic 4010000000.pcie:       IO 0x003eff0000..0x003effffff -&gt; 0x0000000000</span><br><span class="line">[    0.503846] pci-host-generic 4010000000.pcie:      MEM 0x0010000000..0x003efeffff -&gt; 0x0010000000</span><br><span class="line">[    0.504662] pci-host-generic 4010000000.pcie:      MEM 0x8000000000..0xffffffffff -&gt; 0x8000000000</span><br><span class="line">[    0.505854] pci-host-generic 4010000000.pcie: ECAM at [mem 0x4010000000-0x401fffffff] <span class="keyword">for</span> [bus 00-ff]</span><br><span class="line">[    0.507028] pci-host-generic 4010000000.pcie: PCI host bridge to bus 0000:00</span><br><span class="line">[    0.507648] pci_bus 0000:00: root bus resource [bus 00-ff]</span><br><span class="line">[    0.508176] pci_bus 0000:00: root bus resource [io  0x0000-0xffff]</span><br><span class="line">[    0.509569] pci_bus 0000:00: root bus resource [mem 0x10000000-0x3efeffff]</span><br><span class="line">[    0.511529] pci_bus 0000:00: root bus resource [mem 0x8000000000-0xffffffffff]</span><br><span class="line">[    0.513307] pci 0000:00:00.0: [1b36:0008] <span class="built_in">type</span> 00 class 0x060000</span><br><span class="line">[    0.515919] pci 0000:00:01.0: [1af4:1000] <span class="built_in">type</span> 00 class 0x020000</span><br><span class="line">[    0.517340] pci 0000:00:01.0: reg 0x10: [io  0x0000-0x001f]</span><br><span class="line">[    0.517754] pci 0000:00:01.0: reg 0x14: [mem 0x00000000-0x00000fff]</span><br><span class="line">[    0.518388] pci 0000:00:01.0: reg 0x20: [mem 0x00000000-0x00003fff 64bit pref]</span><br><span class="line">[    0.518923] pci 0000:00:01.0: reg 0x30: [mem 0x00000000-0x0003ffff pref]</span><br><span class="line">[    0.521212] pci 0000:00:01.0: BAR 6: assigned [mem 0x10000000-0x1003ffff pref]</span><br><span class="line">[    0.522137] pci 0000:00:01.0: BAR 4: assigned [mem 0x8000000000-0x8000003fff 64bit pref]</span><br><span class="line">[    0.523076] pci 0000:00:01.0: BAR 1: assigned [mem 0x10040000-0x10040fff]</span><br><span class="line">[    0.523801] pci 0000:00:01.0: BAR 0: assigned [io  0x1000-0x101f]</span><br><span class="line">[    0.528448] EINJ: ACPI disabled.</span><br><span class="line">[    0.542283] virtio-pci 0000:00:01.0: enabling device (0000 -&gt; 0003)</span><br><span class="line">[    0.554485] Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled</span><br><span class="line">[    0.558302] SuperH (H)SCI(F) driver initialized</span><br><span class="line">[    0.559486] msm_serial: driver initialized</span><br><span class="line">[    0.561993] cacheinfo: Unable to detect cache hierarchy <span class="keyword">for</span> CPU 0</span><br><span class="line">[    0.575536] loop: module loaded</span><br><span class="line">[    0.577188] megasas: 07.714.04.00-rc1</span><br><span class="line">[    0.581247] physmap-flash 0.flash: physmap platform flash device: [mem 0x00000000-0x03ffffff]</span><br><span class="line">[    0.583156] 0.flash: Found 2 x16 devices at 0x0 <span class="keyword">in</span> 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000</span><br><span class="line">[    0.584568] Intel/Sharp Extended Query Table at 0x0031</span><br><span class="line">[    0.585746] Using buffer write method</span><br><span class="line">[    0.586466] physmap-flash 0.flash: physmap platform flash device: [mem 0x04000000-0x07ffffff]</span><br><span class="line">[    0.587833] 0.flash: Found 2 x16 devices at 0x0 <span class="keyword">in</span> 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000</span><br><span class="line">[    0.589950] Intel/Sharp Extended Query Table at 0x0031</span><br><span class="line">[    0.590679] Using buffer write method</span><br><span class="line">[    0.591154] Concatenating MTD devices:</span><br><span class="line">[    0.591566] (0): <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.591870] (1): <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.592172] into device <span class="string">&quot;0.flash&quot;</span></span><br><span class="line">[    0.639324] tun: Universal TUN/TAP device driver, 1.6</span><br><span class="line">[    0.648697] thunder_xcv, ver 1.0</span><br><span class="line">[    0.649091] thunder_bgx, ver 1.0</span><br><span class="line">[    0.649532] nicpf, ver 1.0</span><br><span class="line">[    0.651118] hclge is initializing</span><br><span class="line">[    0.651699] hns3: Hisilicon Ethernet Network Driver <span class="keyword">for</span> Hip08 Family - version</span><br><span class="line">[    0.652969] hns3: Copyright (c) 2017 Huawei Corporation.</span><br><span class="line">[    0.654822] e1000: Intel(R) PRO/1000 Network Driver</span><br><span class="line">[    0.655566] e1000: Copyright (c) 1999-2006 Intel Corporation.</span><br><span class="line">[    0.656421] e1000e: Intel(R) PRO/1000 Network Driver</span><br><span class="line">[    0.657100] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.</span><br><span class="line">[    0.657828] igb: Intel(R) Gigabit Ethernet Network Driver</span><br><span class="line">[    0.658543] igb: Copyright (c) 2007-2014 Intel Corporation.</span><br><span class="line">[    0.659076] igbvf: Intel(R) Gigabit Virtual Function Network Driver</span><br><span class="line">[    0.659905] igbvf: Copyright (c) 2009 - 2012 Intel Corporation.</span><br><span class="line">[    0.661636] sky2: driver version 1.30</span><br><span class="line">[    0.663482] VFIO - User Level meta-driver version: 0.3</span><br><span class="line">[    0.666363] ehci_hcd: USB 2.0 <span class="string">&#x27;Enhanced&#x27;</span> Host Controller (EHCI) Driver</span><br><span class="line">[    0.666801] ehci-pci: EHCI PCI platform driver</span><br><span class="line">[    0.667200] ehci-platform: EHCI generic platform driver</span><br><span class="line">[    0.667555] ehci-orion: EHCI orion driver</span><br><span class="line">[    0.668162] ehci-exynos: EHCI Exynos driver</span><br><span class="line">[    0.669422] ohci_hcd: USB 1.1 <span class="string">&#x27;Open&#x27;</span> Host Controller (OHCI) Driver</span><br><span class="line">[    0.670008] ohci-pci: OHCI PCI platform driver</span><br><span class="line">[    0.670583] ohci-platform: OHCI generic platform driver</span><br><span class="line">[    0.671027] ohci-exynos: OHCI Exynos driver</span><br><span class="line">[    0.672066] usbcore: registered new interface driver usb-storage</span><br><span class="line">[    0.678548] rtc-pl031 9010000.pl031: registered as rtc0</span><br><span class="line">[    0.679438] rtc-pl031 9010000.pl031: setting system clock to 2025-06-23T05:12:11 UTC (1750655531)</span><br><span class="line">[    0.680812] i2c /dev entries driver</span><br><span class="line">[    0.687138] sdhci: Secure Digital Host Controller Interface driver</span><br><span class="line">[    0.687486] sdhci: Copyright(c) Pierre Ossman</span><br><span class="line">[    0.688175] Synopsys Designware Multimedia Card Interface Driver</span><br><span class="line">[    0.689770] sdhci-pltfm: SDHCI platform and OF driver helper</span><br><span class="line">[    0.691932] ledtrig-cpu: registered to indicate activity on CPUs</span><br><span class="line">[    0.694429] usbcore: registered new interface driver usbhid</span><br><span class="line">[    0.694654] usbhid: USB HID core driver</span><br><span class="line">[    0.700987] NET: Registered protocol family 17</span><br><span class="line">[    0.702090] 9pnet: Installing 9P2000 support</span><br><span class="line">[    0.702525] Key <span class="built_in">type</span> dns_resolver registered</span><br><span class="line">[    0.703492] registered taskstats version 1</span><br><span class="line">[    0.703776] Loading compiled-in X.509 certificates</span><br><span class="line">[    0.710892] input: gpio-keys as /devices/platform/gpio-keys/input/input0</span><br><span class="line">[    0.714806] clk: Disabling unused clocks</span><br><span class="line">[    0.715339] ALSA device list:</span><br><span class="line">[    0.715654]   No soundcards found.</span><br><span class="line">[    0.718941] uart-pl011 9000000.pl011: no DMA platform data</span><br><span class="line">[    0.752373] Freeing unused kernel memory: 5952K</span><br><span class="line">[    0.753454] Run /linuxrc as init process</span><br><span class="line"></span><br><span class="line">Please press Enter to activate this console.</span><br><span class="line">~ <span class="comment">#</span></span><br><span class="line">~ <span class="comment"># ls</span></span><br><span class="line">bin      etc      lib      mnt      root     sys      usr</span><br><span class="line">dev      home     linuxrc  proc     sbin     tmp      var</span><br></pre></td></tr></table></figure><br>ctrl-a x退出qemu</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AArch64 ASM</title>
      <link href="/posts/42868/"/>
      <url>/posts/42868/</url>
      
        <content type="html"><![CDATA[<h1 id="preknowledge"><a href="#preknowledge" class="headerlink" title="preknowledge"></a>preknowledge</h1><p>1 <strong>byte</strong> has 8 <strong>bits</strong></p><ul><li><strong>char</strong> has 1 <strong>byte</strong></li><li><strong>short</strong> has 2 <strong>byte</strong></li><li><strong>int</strong> has 4 <strong>byte</strong></li></ul><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/v2-b9e8babf753b1691039458592667121a_1440w.jpg" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">gcc -S hello.i -o hello.s</span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><ul><li><p><strong>All</strong> AARCH64 instructions are 4 bytes in width.</p></li><li><p><strong>All</strong> AARCH64 pointers are 8 bytes in width†.</p><blockquote><p>While this is technically true, typically only the lower 39, 42 or 48 bits of addresses in Linux systems are used - i.e. the virtual address space of an ARM Linux process is smaller than 64 bits. The upper bits are set to zero when considering the address as an 8-byte value.</p></blockquote></li></ul><h1 id="register"><a href="#register" class="headerlink" title="register"></a>register</h1><h2 id="register-access-speed"><a href="#register-access-speed" class="headerlink" title="register access speed"></a>register access speed</h2><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/latency.png" alt="Latency"></p><blockquote><p>This says that if we liken accessing a register (which can be done at <em>least</em> once per CPU Clock Cycle) to one second, accessing RAM would be like a 3.5 to 5.5 minute wait.</p></blockquote><h2 id="register-type"><a href="#register-type" class="headerlink" title="register type"></a>register type</h2><ul><li>rn means register “of some type” number n.</li></ul><p>The kind of register is specified by a letter. Which register within a given type is specified by a number. There are some exceptions to this. Here is an introductory summary:</p><div class="table-container"><table><thead><tr><th>Letter</th><th>Type</th></tr></thead><tbody><tr><td>x</td><td>64 bit integer or pointer</td></tr><tr><td>w</td><td>32 bit <em>or smaller</em> integer</td></tr><tr><td>d</td><td>64 bit floats (doubles)</td></tr><tr><td>s</td><td>32 bit floats</td></tr></tbody></table></div><p>Some register types have been left out.</p><p>（Chapter 9.1）（Cortex-A Series Programmer’s Guide for ARMv8-A）</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511155518113.png" alt="image-20250511155518113"></p><ul><li>x29是栈帧指针（FP）</li><li>x30是链接寄存器（LR，即返回地址）</li></ul><p>The registers used for floating point types (and vector operations) are coincident:</p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210301586.png" alt="image-20250511210301586"></p><ul><li><code>q</code> registers are a massive 16 bytes wide - quad words.(vn的别名，主要用于<strong>SIMD/Neon</strong> 指令中)</li><li><code>v</code> registers are also 16 bytes wide and are synonyms for the <code>q</code> registers.</li><li><code>d</code> registers for <code>doubles</code> which are 8 bytes wide - <strong>double precision</strong>. 2 per <code>v</code>.</li><li><code>s</code> registers for <code>floats</code> which are 4 bytes wide - <strong>single precisio</strong>n. 4 per <code>v</code>.</li><li><code>h</code> registers for <code>half precisions floats</code> which are 2 bytes wide. 8 per <code>v</code>.</li><li><code>b</code> registers for byte operations. 16 per <code>v</code>.</li></ul><h2 id="register-and-C-type"><a href="#register-and-C-type" class="headerlink" title="register and C type"></a>register and C type</h2><h3 id="Integers"><a href="#Integers" class="headerlink" title="Integers"></a>Integers</h3><div class="table-container"><table><thead><tr><th>This declares an integer</th><th>This IS an integer</th></tr></thead><tbody><tr><td>char</td><td>wn</td></tr><tr><td>short</td><td>wn</td></tr><tr><td>int</td><td>wn</td></tr><tr><td>long</td><td>xn</td></tr></tbody></table></div><h3 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h3><div class="table-container"><table><thead><tr><th>This declares a pointer</th><th>This IS a pointer</th></tr></thead><tbody><tr><td><em>type</em> *</td><td>xn</td></tr></tbody></table></div><p>All pointers are stored in x registers. X registers are 64 bits long but many operating systems do not support 64 bit address spaces because keeping track of that big of an address space itself would use a lot of space. Instead <strong>OS’s typically have 48 to 52 bit address spaces</strong>. </p><h3 id="Floating-Point"><a href="#Floating-Point" class="headerlink" title="Floating Point"></a>Floating Point</h3><div class="table-container"><table><thead><tr><th>This declares a float</th><th>This IS a float</th></tr></thead><tbody><tr><td><code>float</code></td><td><code>sn</code></td></tr><tr><td><code>double</code></td><td><code>dn</code></td></tr><tr><td><code>__fp16</code> (half)</td><td><code>hn</code></td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210512600.png" alt="image-20250511210512600"></p><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/image-20250511210539205.png" alt="image-20250511210539205"></p><p>vn是真正的物理寄存器名，<strong>推荐使用</strong>, 支持最多类型的访问（浮点 + SIMD）</p><p>qn是vn的别名，主要用于<strong>SIMD/Neon</strong> 指令中(<em>Single Instruction - Multiple Data</em>)</p><h1 id="instructions"><a href="#instructions" class="headerlink" title="instructions"></a>instructions</h1><h2 id="preknowledge-1"><a href="#preknowledge-1" class="headerlink" title="preknowledge"></a>preknowledge</h2><p><strong>EVERY</strong> AARCH64 instruction is 4 bytes wide. Everything the CPU needs to know about what the instruction is and what variation it might be plus what data it will use will be found in those 4 bytes.</p><ul><li>Most (but not all) AARCH64 instructions have three <em>operands</em>. These are read in the following way:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op     ra, rb, rc</span><br></pre></td></tr></table></figure><p>means:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ra</span> <span class="operator">=</span> rb op rc</span><br></pre></td></tr></table></figure><p>examples:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sub</span>    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">1</span> <span class="comment">; means x0 = x0 - x1</span></span><br><span class="line">mov    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">1</span>     <span class="comment">; means x0 = x1</span></span><br></pre></td></tr></table></figure><ul><li><strong>[ ]</strong></li></ul><p>the <code>[</code> and <code>]</code> serve the same purpose of the asterisk in C and C++ indicating “dereference.” It means <strong>use what’s inside the brackets as an address for going out to memory</strong>.</p><p>when a  <strong>!</strong> is at the end of <strong>[]</strong> , for example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stp     x21, x30, [sp, -16]!  </span><br><span class="line"></span><br><span class="line">stp     x29, x30, [sp, -16]!    </span><br></pre></td></tr></table></figure><blockquote><p>Lastly, the exclamation point means that the stack pointer should be changed (i.e. the -16 applied to it) <em>before</em> the value of the stack pointer is used as the address in memory to which the registers will be copied. Again, this is a <strong>predecrement</strong>.</p></blockquote><p>it means:</p><ol><li><code>sp = sp - 16</code>（栈指针向下移动 16 字节）</li><li>把 <code>x29</code> 存入 <code>[sp]</code>，把 <code>x30</code> 存入 <code>[sp + 8]</code></li></ol><p>对应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldp     x29, x30, [sp], 16</span><br></pre></td></tr></table></figure><p>it means:</p><ol><li>从 <code>[sp]</code> 读取 8 字节给 <code>x29</code>，从 <code>[sp + 8]</code> 读取 8 字节给 <code>x30</code></li><li><code>sp = sp + 16</code>（释放栈帧空间）</li></ol><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><blockquote><p>x29是栈帧寄存器，但不是必须保存的</p></blockquote><h2 id="memory-access"><a href="#memory-access" class="headerlink" title="memory access"></a>memory access</h2><h3 id="ldr"><a href="#ldr" class="headerlink" title="ldr"></a>ldr</h3><blockquote><p><strong>load register</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr    x0, [sp]   // load 8 bytes from address specified by sp</span><br><span class="line">ldr    w0, [sp]   // load 4 bytes from address specified by sp</span><br><span class="line">ldrh   w0, [sp]   // load 2 bytes from address specified by sp</span><br><span class="line">ldrb   w0, [sp]   // load 1 byte  from address specified by sp</span><br></pre></td></tr></table></figure><p><strong>When misaligned accesses to RAM are made, the processor must slow down and access each byte individually. This is a big performance hit. Properly aligned access is critical to performance.</strong></p><h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><blockquote><p><strong>store register</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str    x0, [sp]   // store 8 bytes to address specified by sp</span><br><span class="line">str    w0, [sp]   // store 4 bytes to address specified by sp</span><br><span class="line">strh   w0, [sp]   // store 2 bytes to address specified by sp</span><br><span class="line">strb   w0, [sp]   // store 1 byte  to address specified by sp</span><br></pre></td></tr></table></figure><blockquote><p>Casting between integer types is in some cases accomplished by <code>anding</code> with <code>255</code> and <code>65535</code> (for <code>char</code> and <code>short</code>) or :</p><p>Whenever a narrower portion of a register is written to, the remainder of the register is zero’d out. That is: <code>ldrb</code> overwrites the least significant byte of an <code>x</code> register and zeros out the upper 7 bytes.</p></blockquote><h3 id="ldp"><a href="#ldp" class="headerlink" title="ldp"></a>ldp</h3><blockquote><p><strong>load pair, same as ldr but load a pair of value</strong></p></blockquote><h3 id="stp"><a href="#stp" class="headerlink" title="stp"></a>stp</h3><blockquote><p><strong>store pair, same as str but load a pair of value</strong></p></blockquote><p><strong>offsets</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) LDR Xt, [Xn|SP&#123;, #pimm&#125;] ; 64-bit general registers</span><br><span class="line">2) LDR Xt, [Xn|SP], #simm ; 64-bit general registers, Post-index</span><br><span class="line">3) LDR Xt, [Xn|SP, #simm]! ; 64-bit general registers, Pre-index</span><br></pre></td></tr></table></figure><ul><li><code>simm</code> can be in the range of -256 to 255 (10 byte signed value).</li><li><code>pimm</code> can be in the range of 0 to 32760 in multiples of 8.</li></ul><h3 id="three-patterns"><a href="#three-patterns" class="headerlink" title="three patterns"></a><strong>three patterns</strong></h3><ol><li>普通偏移模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn, #pimm]</span><br></pre></td></tr></table></figure><blockquote><p>从 <code>Xn + pimm</code> 的地址加载数据到 <code>Xt</code>；<strong>地址寄存器 <code>Xn</code> 不变</strong>；</p><p><code>pimm</code> 是一个 <strong>正的立即数（positive immediate）</strong>，必须是 8 的倍数，最大为 32760。</p></blockquote><ol><li>后变基模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn], #simm</span><br></pre></td></tr></table></figure><blockquote><p>先用 <code>Xn</code> 的原始值作为地址加载数据到 <code>Xt</code>，然后再用 <code>simm</code> 更新 <code>Xn</code>；<strong>地址寄存器 <code>Xn</code> 改变</strong>；</p></blockquote><ol><li>前变基模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR Xt, [Xn, #simm]!</span><br></pre></td></tr></table></figure><blockquote><p>先用 <code>Xn + simm</code> 作为地址加载数据到 <code>Xt</code>，并将更新后的地址写回 <code>Xn</code>；<strong>地址寄存器 <code>Xn</code> 改变</strong>；</p></blockquote><h3 id="pseudo-instruction"><a href="#pseudo-instruction" class="headerlink" title="pseudo instruction"></a>pseudo instruction</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr     x1, =label</span><br></pre></td></tr></table></figure><ul><li><p>the assembler puts the address of the label into a special region of memory called a “<strong>literal pool</strong>.” What matters is <strong>this region of memory is placed immediately after (therefore nearby) your code</strong>.</p></li><li><p>Then, the assembler computes the difference between the address of the current instruction (the <code>ldr</code> itself) and the address of the data in the literal pool made from the labeled data.</p></li><li><p>The assembler generates a different <code>ldr</code> instruction which uses the difference (or offset) of the data relative to the program counter (<code>pc</code>). The <code>pc</code> is non-other the address of the current instruction.</p></li><li><p>Because the literal pool for your code is located nearby your code, the offset from the current instruction to the data in the pool is a relatively <strong>small</strong> number. Small enough, to fit inside a four byte <code>ldr</code> instruction.</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr    x1, [pc, offset to data in literal pool]</span><br></pre></td></tr></table></figure><blockquote><p><em>A downside of this approach is that the literal pool, from which the address is loaded, resides in RAM. This means each of these <code>ldr</code> pseudo instructions incurs a memory reference.</em></p></blockquote><h3 id="literal-pool"><a href="#literal-pool" class="headerlink" title="literal pool"></a>literal pool</h3><p>compare</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr x1, =q</span><br><span class="line">ldr x1, q</span><br></pre></td></tr></table></figure><p>aarch64 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .global     main       // expose main to linker                                        </span><br><span class="line">        .text                  // begin to write code                 </span><br><span class="line">        .align      2          // the code should certainly begin on an even address                    </span><br><span class="line">                                                                       </span><br><span class="line">main:   str         x30, [sp, -16]!                                     </span><br><span class="line">                                                                       </span><br><span class="line">        ldr         x0, =fmt          </span><br><span class="line">        ldr         x1, =q                     </span><br><span class="line">        ldr         x2, [x1]                 </span><br><span class="line">        bl          printf               </span><br><span class="line">                                                                       </span><br><span class="line">        ldr         x0, =fmt                   </span><br><span class="line">        ldr         x1, q                    </span><br><span class="line">        ldr         x2, [x1]                   </span><br><span class="line">        bl          printf            </span><br><span class="line">                                    </span><br><span class="line">        ldr         x30, [sp], 16           </span><br><span class="line">        mov         w0, wzr                                             </span><br><span class="line">        ret                                                             </span><br><span class="line">                                                                       </span><br><span class="line">        .data                                                           </span><br><span class="line">q:      .quad       0x1122334455667788                                 </span><br><span class="line">fmt:    .asciz      &quot;address: %p value: %lx\n&quot;                         </span><br><span class="line">                                                                       </span><br><span class="line">        .end                                                           </span><br><span class="line">                                                                       </span><br></pre></td></tr></table></figure><p>disasembling the binary machine code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000000007a0 &lt;main&gt;:</span><br><span class="line"> 7a0:   f81f0ffe   str  x30, [sp, #-16]!</span><br><span class="line"> 7a4:   58000160   ldr  x0, 7d0 &lt;main+0x30&gt;</span><br><span class="line"> 7a8:   58000181   ldr  x1, 7d8 &lt;main+0x38&gt;</span><br><span class="line"> 7ac:   f9400022   ldr  x2, [x1]</span><br><span class="line"> 7b0:   97ffffb4   bl   680 &lt;printf@plt&gt;</span><br><span class="line"> 7b4:   580000e0   ldr  x0, 7d0 &lt;main+0x30&gt;</span><br><span class="line"> 7b8:   580842c1   ldr  x1, 11010 &lt;q&gt;</span><br><span class="line"> 7bc:   f9400022   ldr  x2, [x1]</span><br><span class="line"> 7c0:   97ffffb0   bl   680 &lt;printf@plt&gt;</span><br><span class="line"> 7c4:   f84107fe   ldr  x30, [sp], #16</span><br><span class="line"> 7c8:   2a1f03e0   mov  w0, wzr</span><br><span class="line"> 7cc:   d65f03c0   ret</span><br></pre></td></tr></table></figure><p>and</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000000000011010 &lt;q&gt;:</span><br><span class="line">   11010:   55667788</span><br><span class="line">   11014:   11223344</span><br></pre></td></tr></table></figure><ul><li><p>It says <code>000000000011010 &lt;q&gt;:</code>. This means that what comes next is the data corresponding to what is labeled <code>q</code> in our source code. Notice the relocatable address of <code>11010</code>. We will explain “relocatable address” below.</p></li><li><p>Now, look at the disassembled code on the line beginning with <code>7b8</code>. It reads <code>ldr x1, 11010</code>. So the disassembled executable is saying “go to address 11010 and fetch its contents” which are our <code>1122334455667788</code>.</p></li></ul><div class="table-container"><table><thead><tr><th>Instruction</th><th>Meaning</th></tr></thead><tbody><tr><td>ldr r, =label</td><td>Load the address of the label into r</td></tr><tr><td>ldr r, label</td><td>Load the value found at the label into r</td></tr></tbody></table></div><h3 id="relocation-of-address-when-executing"><a href="#relocation-of-address-when-executing" class="headerlink" title="relocation of address when executing"></a>relocation of address when executing</h3><blockquote><p>None of the addresses we have seen so far are the final addresses that will be used once the program is actually running. <strong>All addresses will be <em>relocated</em></strong>.</p></blockquote><p>One reason for this is a guard against malware. A technique called <strong>Address Space Layout Randomization (ASLR)</strong> prevents malware writers from being able to know ahead where to modify your executable in order to accomplish their nefarious purposes.</p><p><strong>64 bit ARM Linux kernels allocate 39, 42 or 48 bits for the size of a process’s virtual address space</strong>. Notice 42 and 48 bit values require 6 bytes to hold them. A virtual address space is all of the addresses a process can generate / use. Further, all addresses used by processes are virtual addresses.</p><p>using this can avoid literal pool</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp    x0, s</span><br><span class="line">add     x0, x0, :lo12:s</span><br></pre></td></tr></table></figure><h3 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h3><h4 id="loading-storing-various-sizes-of-integers"><a href="#loading-storing-various-sizes-of-integers" class="headerlink" title="loading (storing) various sizes of integers"></a>loading (storing) various sizes of integers</h4><div class="table-container"><table><thead><tr><th>Instruction</th><th style="text-align:left">Meaning</th></tr></thead><tbody><tr><td><code>ldr x0, [x1]</code></td><td style="text-align:left">Fetches a 64 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr><tr><td><code>ldr w0, [x1]</code></td><td style="text-align:left">Fetches a 32 bit value from the address specified by <code>x1</code> and places it in <code>w0</code></td></tr><tr><td><code>ldrh w0, [x1]</code></td><td style="text-align:left">Fetches a 16 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr><tr><td><code>ldrb w0, [x1]</code></td><td style="text-align:left">Fetches an 8 bit value from the address specified by <code>x1</code> and places it in <code>x0</code></td></tr></tbody></table></div><ul><li>Pointers and longs use <code>x</code> registers.</li><li>All other integer sizes use <code>w</code> registers where the instruction itself specifies the size.</li></ul><h4 id="array-indexing"><a href="#array-indexing" class="headerlink" title="array indexing"></a>array indexing</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Sum</span><span class="params">(<span class="type">long</span> * values, <span class="type">long</span> length)</span>   </span><br><span class="line">&#123;                                          </span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;                          </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; length; i++)            </span><br><span class="line">    &#123;                                           </span><br><span class="line">        sum += values[i];                         </span><br><span class="line">    &#125;                                                   </span><br><span class="line">    <span class="keyword">return</span> sum;                                            </span><br><span class="line">&#125;                                                                                                     </span><br></pre></td></tr></table></figure><p>Notice we’re using the index variable <code>i</code> for nothing more than traipsing through the array. This is fantastically inefficient (in this case).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Sum</span><span class="params">(<span class="type">long</span> * values, <span class="type">long</span> length)</span>         </span><br><span class="line">&#123;                                     </span><br><span class="line">    <span class="type">long</span> sum = <span class="number">0</span>;                           </span><br><span class="line">    <span class="type">long</span> * end = values + length;                   </span><br><span class="line">    <span class="keyword">while</span> (values &lt; end)                     </span><br><span class="line">    &#123;                                              </span><br><span class="line">        sum += *(values++);                            </span><br><span class="line">    &#125;                                                </span><br><span class="line">    <span class="keyword">return</span> sum;                                           </span><br><span class="line">&#125;                                                            </span><br></pre></td></tr></table></figure><p>Notice we don’t use an index variable any longer. Instead, we use the pointer itself for both the dereferencing <em>and</em> to tell us when to stop the loop.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    .global Sum                                           </span><br><span class="line">    .text                                                </span><br><span class="line">    .align  4                                           </span><br><span class="line"></span><br><span class="line">//  x0 is the pointer to data                         </span><br><span class="line">//  x1 is the length and is reused as `end`           </span><br><span class="line">//  x2 is the sum                                  </span><br><span class="line">//  x3 is the current dereferenced value                    </span><br><span class="line"></span><br><span class="line">Sum:                                                     </span><br><span class="line">    mov     x2, xzr              // x2 = 0                     </span><br><span class="line">    add     x1, x0, x1, lsl 3    //  x1 = x0+x1*8              </span><br><span class="line">    b       2f                                   </span><br><span class="line"></span><br><span class="line">1:  ldr     x3, [x0], 8                          </span><br><span class="line">    add     x2, x2, x3                             </span><br><span class="line">2:  cmp     x0, x1                               </span><br><span class="line">    blt     1b                                        </span><br><span class="line"></span><br><span class="line">    mov     x0, x2                                  </span><br><span class="line">    ret                                             </span><br><span class="line"></span><br><span class="line">    .end</span><br></pre></td></tr></table></figure><h4 id="faster-memory-copy"><a href="#faster-memory-copy" class="headerlink" title="faster memory copy"></a>faster memory copy</h4><p>Suppose you needed to <strong>copy 16 bytes of memory</strong> from one place to another. You might do it like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SillyCopy16</span><span class="params">(<span class="type">uint8_t</span> * dest, <span class="type">uint8_t</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        *(dest++) = *(src++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is especially silly as why would you go through 16 loops when you could have simply:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SillyCopy16</span><span class="params">(<span class="type">uint64_t</span> * dest, <span class="type">uint64_t</span> * src)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(dest++) = *(src++); <span class="comment">// 3</span></span><br><span class="line">    *dest = *src;         <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:              // 1</span><br><span class="line">    ldr    x2, [x0], 8    // 2</span><br><span class="line">    str    x2, [x1], 8    // 3</span><br><span class="line">    ldr    x2, [x0]       // 4</span><br><span class="line">    str    x2, [x1]       // 5</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>using ldp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:</span><br><span class="line">    ldp    x2, x3, [x0]</span><br><span class="line">    stp    x2, x3, [x1]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>using q register</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SillyCopy16:</span><br><span class="line">    ldr    q2, [x0]</span><br><span class="line">    str    q2, [x1]</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h4 id="indexing-through-an-array-of-struct"><a href="#indexing-through-an-array-of-struct" class="headerlink" title="indexing through an array of struct"></a>indexing through an array of struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>                                       </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>                                       </span></span><br><span class="line"><span class="class">&#123;</span>                                                   </span><br><span class="line">    <span class="type">char</span> * fname;                                </span><br><span class="line">    <span class="type">char</span> * lname;                                      </span><br><span class="line">    <span class="type">int</span> age;                                        </span><br><span class="line">&#125;;                                                         </span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">rand</span><span class="params">()</span>;                                          </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> Person * <span class="title function_">FindOldestPerson</span><span class="params">(<span class="keyword">struct</span> Person *, <span class="type">int</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Person * <span class="title function_">OriginalFindOldestPerson</span><span class="params">(<span class="keyword">struct</span> Person * people, <span class="type">int</span> length)</span></span><br><span class="line">&#123;                                                     </span><br><span class="line">    <span class="type">int</span> oldest_age = <span class="number">0</span>;                        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">oldest_ptr</span> =</span> <span class="literal">NULL</span>;               </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (people)                                        </span><br><span class="line">    &#123;                                                     </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">end_ptr</span> =</span> people + length;       </span><br><span class="line">        <span class="keyword">while</span> (people &lt; end_ptr)                           </span><br><span class="line">        &#123;                                                   </span><br><span class="line">            <span class="keyword">if</span> (people-&gt;age &gt; oldest_age)             </span><br><span class="line">            &#123;                                      </span><br><span class="line">                oldest_age = people-&gt;age;            </span><br><span class="line">                oldest_ptr = people;                   </span><br><span class="line">            &#125;                               </span><br><span class="line">            people++;                          </span><br><span class="line">        &#125;                                         </span><br><span class="line">    &#125;                                             </span><br><span class="line">    <span class="keyword">return</span> oldest_ptr;                             </span><br><span class="line">&#125;                                                  </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH  20                                </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                                            </span><br><span class="line">&#123;                                                   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">array</span>[<span class="title">LENGTH</span>];</span>                          </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)                     </span><br><span class="line">    &#123;                                               </span><br><span class="line">        <span class="built_in">array</span>[i].age = rand() % <span class="number">5000</span>;                   </span><br><span class="line">    &#125;                                                       </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> * <span class="title">oldest</span> =</span> FindOldestPerson(<span class="built_in">array</span>, LENGTH);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LENGTH; i++)                  </span><br><span class="line">    &#123;                                                   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">array</span>[i].age);               </span><br><span class="line">        <span class="keyword">if</span> (oldest == &amp;<span class="built_in">array</span>[i])                </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);                           </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                                 </span><br><span class="line">    &#125;                                                  </span><br><span class="line">&#125;                                                           </span><br></pre></td></tr></table></figure><p><code>Line 11</code> tells us that somewhere else, there is a function called <code>FindOldestPerson</code>. That function must have a <code>.global</code> specifying the same name so that the linker can reconcile the reference to <code>FindOldestPerson</code>.</p><p><code>gcc</code> with <code>-O2</code> or <code>-O3</code> optimization rendered <code>OriginalFindOldestPerson()</code> into 18 lines of assembly language.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">        .global FindOldestPerson                                        // 1 </span><br><span class="line">        .text                                                           // 2 </span><br><span class="line">        .align  2                                                       // 3 </span><br><span class="line">                                                                        // 4 </span><br><span class="line">//  x0  has struct Person * people                                      // 5 </span><br><span class="line">//      will be used for oldest_ptr as this is the return value         // 6 </span><br><span class="line">//  w1  has int length                                                  // 7 </span><br><span class="line">//  w2  used for oldest_age                                             // 8 </span><br><span class="line">//  x3  used for Person *                                               // 9 </span><br><span class="line">//  x4  used for end_ptr                                                // 10 </span><br><span class="line">//  w5  used for scratch                                                // 11 </span><br><span class="line">                                                                        // 12 </span><br><span class="line">FindOldestPerson:                                                       // 13 </span><br><span class="line">        cbz     x0, 99f             // short circuit                    // 14 </span><br><span class="line">        mov     w2, wzr             // initial oldest age is 0          // 15 </span><br><span class="line">        mov     x3, x0              // initialize loop pointer          // 16 </span><br><span class="line">        mov     x0, xzr             // initialize return value          // 17 </span><br><span class="line">        mov     w5, 24              // struct is 24 bytes wide          // 18 </span><br><span class="line">        smaddl  x4, w1, w5, x3      // initialize end_ptr               // 19 </span><br><span class="line">        b       10f                 // enter loop                       // 20 </span><br><span class="line">                                                                        // 21 </span><br><span class="line">1:      ldr     w5, [x3, p.age]     // fetch loop ptr -&gt; age            // 22 </span><br><span class="line">        cmp     w2, w5              // compare to oldest_age            // 23 </span><br><span class="line">        csel    w2, w2, w5, gt      // update based on cmp              // 24 </span><br><span class="line">        csel    x0, x0, x3, gt      // update based on cmp              // 25 </span><br><span class="line">        add     x3, x3, 24          // increment loop ptr               // 26 </span><br><span class="line">10:     cmp     x3, x4              // has loop ptr reached end_ptr?    // 27 </span><br><span class="line">        blt     1b                  // no, not yet                      // 28 </span><br><span class="line">                                                                        // 29 </span><br><span class="line">99:     ret                                                             // 30 </span><br><span class="line">                                                                        // 31 </span><br><span class="line">        .data                                                           // 32 </span><br><span class="line">        .struct 0                                                       // 33 </span><br><span class="line">p.fn:   .skip   8                                                       // 34 </span><br><span class="line">p.ln:   .skip   8                                                       // 35 </span><br><span class="line">p.age:  .skip   4                                                       // 36 </span><br><span class="line">p.pad:  .skip   4                                                       // 37 </span><br><span class="line">                                                                        // 38 </span><br><span class="line">        .end                                                            // 39 </span><br></pre></td></tr></table></figure><h2 id="control-flow"><a href="#control-flow" class="headerlink" title="control flow"></a>control flow</h2><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><blockquote><p><strong>compare</strong></p></blockquote><p>discards the result of the subtraction but keeps a record of whether or not the result was less than, equal to or greater than zero. It sets the condition bits</p><h3 id="br"><a href="#br" class="headerlink" title="br"></a>br</h3><blockquote><p>Branch to Register</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br &lt;register&gt;</span><br></pre></td></tr></table></figure><p>无条件跳转，类似于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> *(ptr)</span><br></pre></td></tr></table></figure><h3 id="ble"><a href="#ble" class="headerlink" title="ble"></a>ble</h3><blockquote><p><strong>Branch less or equal</strong></p></blockquote><h3 id="bl"><a href="#bl" class="headerlink" title="bl"></a>bl</h3><blockquote><p><strong>Branch with Link</strong></p></blockquote><p>跳转到一个函数（子程序）地址，并且保存返回地址到 <code>x30</code> 寄存器中（也叫 <code>lr</code>，Link Register）</p><h3 id="cbz"><a href="#cbz" class="headerlink" title="cbz"></a>cbz</h3><blockquote><p>Compare and Branch if Zero</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cbz &lt;register&gt;, &lt;label&gt;</span><br></pre></td></tr></table></figure><p>如果 <code>&lt;register&gt;</code> 中的值为 0，就跳转到 <code>&lt;label&gt;</code>。</p><p>否则继续执行下一条指令。</p><h3 id="csel"><a href="#csel" class="headerlink" title="csel"></a>csel</h3><blockquote><p>Conditional Select</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csel &lt;dest&gt;, &lt;src1&gt;, &lt;src2&gt;, &lt;condition&gt;</span><br></pre></td></tr></table></figure><p>如果满足 <code>&lt;condition&gt;</code>，则将 <code>&lt;src1&gt;</code> 的值赋给 <code>&lt;dest&gt;</code>；</p><p>否则将 <code>&lt;src2&gt;</code> 的值赋给 <code>&lt;dest&gt;</code>。</p><p>examples:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp w2, w5</span><br><span class="line">csel w2, w2, w5, gt    // 如果 w2 &gt; w5，则 w2 保持不变；否则更新为 w5</span><br></pre></td></tr></table></figure><p>这是<strong>无分支的条件赋值</strong>，比 <code>if-else</code> 更高效。</p><p>this is equal to </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w2 = (w2 &gt; w5) ? w2 : w5;</span><br></pre></td></tr></table></figure><h3 id="calculate"><a href="#calculate" class="headerlink" title="calculate"></a>calculate</h3><h2 id="shift-Opertations"><a href="#shift-Opertations" class="headerlink" title="shift Opertations"></a>shift Opertations</h2><h3 id="lsl"><a href="#lsl" class="headerlink" title="lsl"></a>lsl</h3><blockquote><p>Logical Shift Left</p></blockquote><p>The LSL instruction performs multiplication by a power of 2.</p><h3 id="lsr"><a href="#lsr" class="headerlink" title="lsr"></a>lsr</h3><blockquote><p>Logical Shift Right</p></blockquote><p>The LSR instruction performs division by a power of 2.</p><h3 id="asr"><a href="#asr" class="headerlink" title="asr"></a>asr</h3><blockquote><p>Arithmetic Shift Right</p></blockquote><p>The ASR instruction performs division by a power of 2, preserving the sign bit.</p><h3 id="ror"><a href="#ror" class="headerlink" title="ror"></a>ror</h3><blockquote><p>rotate right</p></blockquote><p>The ROR instruction performs a bitwise rotation, wrapping the bits rotated from the LSB into the MSB.<br>即：<code>ROR</code> 指令执行<strong>按位右旋转</strong>操作：<strong>从最低有效位（LSB）被旋转出来的位，会重新被放入到最高有效位（MSB）的位置中。</strong></p><h2 id="bit-manipulation"><a href="#bit-manipulation" class="headerlink" title="bit manipulation"></a>bit manipulation</h2><h3 id="mvn"><a href="#mvn" class="headerlink" title="mvn"></a>mvn</h3><p>mvn (Move Not) 作用是 将操作数按位取反（bitwise NOT）后，放入目标寄存器。</p><h3 id="orr"><a href="#orr" class="headerlink" title="orr"></a>orr</h3><p>orr (bitwise inclusive OR) 对两个操作数执行<strong>按位或（bitwise OR）</strong>运算，然后将结果写入目标寄存器</p><h3 id="bfi"><a href="#bfi" class="headerlink" title="bfi"></a>bfi</h3><p>bfi (Bit Field Insert) 即“位字段插入”。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfi &lt;Xd&gt;, &lt;Xn&gt;, #&lt;lsb&gt;, #&lt;width&gt;</span><br></pre></td></tr></table></figure></p><p><Xd>：目标寄存器（结果写到这里）</p><p><Xn>：源寄存器（从这里取低位的值）</p><p><lsb>：目标寄存器中开始插入的起始位（least significant bit 起始位）</p><p><width>：要插入多少位（宽度）</p><p>假设：</p><p>Xd = 0b1111 0000<br>Xn = 0b1011 (只用低4位)<br>lsb=1<br>width=3</p><p>执行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfi Xd, Xn, #1, #3</span><br></pre></td></tr></table></figure><br>结果：<br>将 Xn 的低3位 011 插入 Xd 的位1~3上，替换原值<br>结果是 Xd = 1111 0110 </p><h3 id="ubfm"><a href="#ubfm" class="headerlink" title="ubfm"></a>ubfm</h3><p>ubfm = Unsigned BitField Move</p><p>基本格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfm &lt;dst&gt;, &lt;src&gt;, #lsb, #msb</span><br></pre></td></tr></table></figure></p><p><dst>：目标寄存器</p><p><src>：源寄存器<br>lsb：起始位（low bit index）<br>msb：结束位（high bit index）<br>这条指令从 src 中 提取一个无符号位字段（即一段连续的比特位），把它放到 dst 的低位（bit 0 开始），其他位清零或忽略<br>也就是说：</p><ol><li>从 src 的第 lsb 位开始，取到 msb 位</li><li>将这段 bit 字段提取出来</li><li>右对齐放到 dst 的低位（bit 0）<br>其他位全部清零<br>实例：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfm    w1, w2, #8, #15</span><br></pre></td></tr></table></figure><ol><li>从 w2 中提取 bit 8 到 bit 15（共 8 位）</li><li>把它放到 w1 的 bit 0~7</li></ol><h3 id="ubfiz"><a href="#ubfiz" class="headerlink" title="ubfiz"></a>ubfiz</h3><p>ubfiz (Unsigned Bit Field Insert Zeroed) 将一个无符号数的低位字段插入到另一个寄存器的指定位置，但目标寄存器在插入之前会被清零。<br>它其实是 ubfm（Unsigned Bit Field Move）的一个特化形式，和 UBFM 的语义类似。</p><p>指令格式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfiz  &lt;dst&gt;, &lt;src&gt;, #lsb, #width</span><br></pre></td></tr></table></figure><br>简单来讲就是：ubfiz = 把 src 的低 width 位 插入到 dst 的 bit lsb 开始的位置，其余位置全部清零。</p><p>其中：</p><p><src>：来源寄存器（如 w1）</p><p><dst>：目标寄存器（如 w2），最终结果放在这里<br>lsb：目标中插入位置的起始 bit 位（从0开始）<br>width：要插入的位数（从 <src> 的最低位开始数）</p><p>目标寄存器其他位都会被清零。</p><p>举例说明：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubfiz   w1, w1, #3, #5</span><br></pre></td></tr></table></figure><br>含义如下：</p><ol><li>从 w1 的 最低 5 位（bit 0 到 bit 4）提取出来</li><li>插入到目标（w1）寄存器的 bit 3 到 bit 7</li><li>w1 的其他所有位（02 和 831）清零</li></ol><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="adr"><a href="#adr" class="headerlink" title="adr"></a>adr</h3><blockquote><p>Address</p></blockquote><h3 id="adrp"><a href="#adrp" class="headerlink" title="adrp"></a>adrp</h3><blockquote><p>Address of page</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line"></span><br><span class="line">adrp x0, fmt</span><br><span class="line">add  x0, x0, :lo12:fmt    // 汇编器会自动提取 fmt 的低12位作为立即数,计算页偏移</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：把符号 <code>fmt</code> 所在的 <strong>4KB 对齐页的页地址</strong>加载到 <code>x0</code> 中。</li><li><code>adrp</code> = <em>Address of Page</em>。</li><li>它会忽略符号地址的低 12 位，只保留高位。</li><li>举例：如果 <code>fmt</code> 地址是 <code>0x400123</code>，那么 <code>adrp x0, fmt</code> 会将 <code>0x400000</code> 加载到 <code>x0</code>。</li><li><code>adrp x0, fmt</code> 会将 <code>fmt</code> 地址向下取整到最近的 <strong>4KB 边界</strong>（即清除低12位）</li></ul><blockquote><p>为什么不直接用 <code>ldr x0, =fmt</code>？</p></blockquote><ul><li>在 ARM64 下，使用 <code>ldr x0, =fmt</code> 可能隐式引入 <strong>文字常量池（literal pool）</strong>，不利于可重定位代码，尤其是在动态链接或 PIE (Position Independent Executable) 环境下。</li><li><code>adrp</code> + <code>add</code> 是 <strong>推荐的可重定位代码写法（relocatable and PIC-compliant）</strong>。</li><li>Linux 下的动态链接器（ld.so）支持这种模式更好。</li></ul><div class="table-container"><table><thead><tr><th>指令</th><th>含义</th><th>支持的偏移范围</th><th>常用于</th></tr></thead><tbody><tr><td><code>adr</code></td><td>获取<strong>当前指令附近</strong>的地址</td><td>±1MB</td><td>局部跳转、临时变量等</td></tr><tr><td><code>adrp</code></td><td>获取<strong>4KB 页对齐的高地址部分</strong></td><td>±4GB（页对齐偏移）</td><td>获取全局变量地址、字符串、常量表地址等</td></tr></tbody></table></div><h3 id="smaddl"><a href="#smaddl" class="headerlink" title="smaddl"></a>smaddl</h3><blockquote><p>Signed Multiply Add Long</p><p>两个 <strong>32位整数（有符号）</strong> 相乘后，加上一个 <strong>64位整数</strong>，结果保存在一个 <strong>64位寄存器</strong>中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smaddl &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;Xa&gt;</span><br></pre></td></tr></table></figure><p>执行如下操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xd = (<span class="type">int64_t</span>)(<span class="type">int32_t</span>)Wn * (<span class="type">int64_t</span>)(<span class="type">int32_t</span>)Wm + Xa;</span><br></pre></td></tr></table></figure></p><h1 id="programming"><a href="#programming" class="headerlink" title="programming"></a>programming</h1><h2 id="if-statement"><a href="#if-statement" class="headerlink" title="if statement"></a>if statement</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)                                                              </span><br><span class="line">&#123;                                                                       </span><br><span class="line">    <span class="comment">// CODE BLOCK                                                       </span></span><br><span class="line">&#125;                                                                       </span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0                                       </span><br><span class="line">    // Assume value of b is in x1                                       </span><br><span class="line">    cmp     x0, x1                                                      </span><br><span class="line">    ble     1f                                                          </span><br><span class="line">    // CODE BLOCK                                                       </span><br><span class="line">1:                                                                     </span><br></pre></td></tr></table></figure><p>If <code>a &gt; b</code> then <code>x0 - x1</code> will be <em>greater than zero</em>.</p><p>If <code>a == b</code> then <code>x0 - x1</code> will be <em>equal to zero</em>.</p><p>If <code>a &lt; b</code> then <code>x0 - x1</code> will be <em>less than zero</em>.</p><p><strong>ble</strong> means <strong>branch (a jump or goto) if the previous computation shows <code>less than or equal to</code> zero</strong></p><h4 id="a-rule-of-thumb"><a href="#a-rule-of-thumb" class="headerlink" title="a rule of thumb"></a>a rule of thumb</h4><ul><li><p><strong>In the higher level language, you want to <em>enter</em> the following code block if the condition is true. </strong></p></li><li><p><strong>In assembly language, you want to <em>avoid</em> the following code block if the condition is false.</strong></p></li></ul><h4 id="temporary-label"><a href="#temporary-label" class="headerlink" title="temporary label"></a>temporary label</h4><p>The target of the branch instruction is given as <code>1f</code>. This is an example of a <strong><em>temporary label</em></strong>.</p><p><strong>There are a lot of braces used in C and C++. Since labels frequently function as equivalents to <code>&#123;</code> and <code>&#125;</code>, there can be a lot of labels used in assembly language. But label is only a position label, it is not a scope </strong></p><p>A temporary label is a label made using just a number. Such labels can appear over and over again (i.e. they can be reused). They are made unique by virtue of their placement relative to where they are being used. </p><ul><li><code>1f</code> looks <code>f</code>orward in the code for the next label <code>1</code>. </li><li><code>1b</code> looks in the <code>b</code>ackward direction for the most recent label <code>1</code>.</li></ul><h3 id="if-else"><a href="#if-else" class="headerlink" title="if / else"></a>if / else</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b)                                                          </span><br><span class="line">&#123;                                                                   </span><br><span class="line">    <span class="comment">// CODE BLOCK IF TRUE                                           </span></span><br><span class="line">&#125;                                                          </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;                                                                   </span><br><span class="line">    <span class="comment">// CODE BLOCK IF FALSE                                         </span></span><br><span class="line">&#125;                                                                   </span><br></pre></td></tr></table></figure><p><strong>There are two branches built into this code!</strong></p><p>in aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0                                       </span><br><span class="line">    // Assume value of b is in x1                                       </span><br><span class="line">    cmp     x0, x1                                                      </span><br><span class="line">    ble     1f                                                          </span><br><span class="line">    // CODE BLOCK IF TRUE                                               </span><br><span class="line">    b       2f                                                         </span><br><span class="line">1:                                                                      </span><br><span class="line">    // CODE BLOCK IF FALSE                                             </span><br><span class="line">2:                                                                     </span><br></pre></td></tr></table></figure><h4 id="a-complete-example"><a href="#a-complete-example" class="headerlink" title="a complete example"></a>a complete example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    .global main                                                       </span><br><span class="line">    .text                                                               </span><br><span class="line">                                                                       </span><br><span class="line">main:                                                                   </span><br><span class="line">    stp     x29, x30, [sp, -16]!                                       </span><br><span class="line">    mov     x1, 10                                                     </span><br><span class="line">    mov     x0, 5                                                       </span><br><span class="line">    cmp     x0, x1                                                     </span><br><span class="line">    ble     1f                                                         </span><br><span class="line">    ldr     x0, =T                     //Pseudo Instruction 伪指令</span><br><span class="line">    bl      puts                                                       </span><br><span class="line">    b       2f                                                         </span><br><span class="line"></span><br><span class="line">1:  ldr     x0, =F                                                     </span><br><span class="line">    bl      puts                                                       </span><br><span class="line">                                                                       </span><br><span class="line">2:  ldp     x29, x30, [sp], 16                                         </span><br><span class="line">    mov     x0, xzr                                                     </span><br><span class="line">    ret                                                                 </span><br><span class="line">                                                                    </span><br><span class="line">    .data                                                               </span><br><span class="line">F:  .asciz  &quot;FALSE&quot;                                                     </span><br><span class="line">T:  .asciz  &quot;TRUE&quot;                                                     </span><br><span class="line">    .end                                                               </span><br></pre></td></tr></table></figure><p><code>Line 11</code> is one way of loading the address represented by a label. In this case, the label <code>T</code> corresponds to the address to the first letter of the C string “TRUE”. <code>Line 15</code> loads the address of the C string containing “FALSE”.</p><p>The occurrences of <code>.asciz</code> on <code>line 23</code> and <code>line 24</code> are invocations of an <em>assembler directive</em> the creates a C string. Recall that <strong>C strings are NULL terminated</strong>. The NULL termination is indicated by the <code>z</code> which ends <code>.asciz</code>.</p><p>There is a similar directive <code>.ascii</code> that <em>does not NULL terminate</em> the string.</p><h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><h3 id="while-loop"><a href="#while-loop" class="headerlink" title="while loop"></a>while loop</h3><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/while.jpeg" alt="while loop"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (a &gt;= b) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    // Assume value of a is in x0                                       </span><br><span class="line">    // Assume value of b is in x1                                       </span><br><span class="line">                                                                        </span><br><span class="line"> 1: cmp     x0, x1                                                     </span><br><span class="line">    blt     2f                                                          </span><br><span class="line">    // CODE BLOCK                                                       </span><br><span class="line">    b       1b                                                          </span><br><span class="line"></span><br><span class="line">2:                                                                     </span><br></pre></td></tr></table></figure><h3 id="for-loop"><a href="#for-loop" class="headerlink" title="for loop"></a>for loop</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span> up; decision; post step)                                   </span><br><span class="line">&#123;                                                                    </span><br><span class="line">    <span class="comment">// CODE BLOCK                                                   </span></span><br><span class="line">&#125;                                                                   </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/for.jpeg" alt="for"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)                                     </span><br><span class="line">&#123;                                                                  </span><br><span class="line">    <span class="comment">// CODE BLOCK                                                    </span></span><br><span class="line">&#125;                                                                   </span><br></pre></td></tr></table></figure><p>aarch64 (the flow chart on the left)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Assume i is implemented using x0                                                                                        </span></span><br><span class="line">    mov     x0, xzr                                                     </span><br><span class="line">                                                                      </span><br><span class="line"><span class="number">1</span>:  cmp     x0, <span class="number">10</span>                                                     </span><br><span class="line">    bge     <span class="number">2f</span>                                                         </span><br><span class="line">                                                                       </span><br><span class="line">    <span class="comment">// CODE BLOCK                                                       </span></span><br><span class="line">                                                                       </span><br><span class="line">    add     x0, x0, <span class="number">1</span>                                                   </span><br><span class="line">    b       <span class="number">1b</span>                                                         </span><br><span class="line">                                                                       </span><br><span class="line"><span class="number">2</span>:                                                                     </span><br></pre></td></tr></table></figure><p>aarch64 (the flow chart on the right)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0                                 </span><br><span class="line">                                                                       </span><br><span class="line">    mov     x0, xzr                                                     </span><br><span class="line">    b       2f</span><br><span class="line">                                                                       </span><br><span class="line">1:                                                                     </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK                                                       </span><br><span class="line">                                                                       </span><br><span class="line">    add     x0, x0, 1                                                   </span><br><span class="line">2:  cmp     x0, 10                                                     </span><br><span class="line">    blt     1b                                                         </span><br></pre></td></tr></table></figure><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;A&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;B&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>in aarch64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0                                 </span><br><span class="line">                                                                       </span><br><span class="line">    mov x0, xzr                                                         </span><br><span class="line"></span><br><span class="line">1:  cmp x0, 10                                                         </span><br><span class="line">    bge 3f                                                                                                                      </span><br><span class="line">    // CODE BLOCK &quot;A&quot;.                                                              </span><br><span class="line">    // if (i == 5)                                                     </span><br><span class="line">    //      continue                                                   </span><br><span class="line">    </span><br><span class="line">    cmp x0, 5                                                           </span><br><span class="line">    beq 2f                                                                                                                      </span><br><span class="line">    // CODE BLOCK &quot;B&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">2:  add x0, x0, 1                                                       </span><br><span class="line">    b   1b                                                             </span><br><span class="line"></span><br><span class="line">3:                                                                     </span><br></pre></td></tr></table></figure><p>another one</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0                                 </span><br><span class="line">                                                                       </span><br><span class="line">    mov x0, xzr                                                         </span><br><span class="line">    b   3f                                                             </span><br><span class="line">                                                                       </span><br><span class="line">1:                                                                     </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK &quot;A&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">    // if (i == 5)                                                     </span><br><span class="line">    //      continue                                                   </span><br><span class="line">                                                                       </span><br><span class="line">    cmp x0, 5                                                           </span><br><span class="line">    beq 2f                                                             </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK &quot;B&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">2:  add x0, x0, 1                                                       </span><br><span class="line">3:  cmp x0, 10                                                         </span><br><span class="line">    blt 1b                                                             </span><br></pre></td></tr></table></figure><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>The implementation of <code>break</code> is very similar to that of <code>continue</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;A&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// CODE BLOCK &quot;B&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aarch64:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    // Assume i is implemented using x0                                 </span><br><span class="line">                                                                       </span><br><span class="line">    mov x0, xzr                                                         </span><br><span class="line">    b   3f                                                             </span><br><span class="line"> </span><br><span class="line">1:                                                                     </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK &quot;A&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">    // if (i == 5)                                                     </span><br><span class="line">    //      break;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">    cmp x0, 5                                                           </span><br><span class="line">    beq 4f                                                             </span><br><span class="line">                                                                       </span><br><span class="line">    // CODE BLOCK &quot;B&quot;                                                   </span><br><span class="line">                                                                       </span><br><span class="line">2:  add x0, x0, 1                                                       </span><br><span class="line">3:  cmp x0, 10                                                         </span><br><span class="line">    blt 1b                                                             </span><br><span class="line">                                                                       </span><br><span class="line">4:                                                                     </span><br></pre></td></tr></table></figure><h2 id="structs"><a href="#structs" class="headerlink" title="structs"></a>structs</h2><h3 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h3><p><em>Data members exhibit <strong>natural alignment</strong>.</em></p><p>That is:</p><ul><li>a <code>long</code> will be found at addresses which are a multiple of 8.</li><li>an <code>int</code> will be found at addresses which are a multiple of 4.</li><li>a <code>short</code> will be found at addresses which are even.</li><li>a <code>char</code> can be found anywhere.</li></ul><h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>布局：</p><div class="table-container"><table><thead><tr><th>Offset</th><th>Width</th><th>Member</th></tr></thead><tbody><tr><td>0</td><td>8byte</td><td>a</td></tr><tr><td>8</td><td>2byte</td><td>b</td></tr><tr><td>10</td><td>2</td><td>— gap —</td></tr><tr><td>12</td><td>4byte</td><td>c</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> a;</span><br><span class="line">    <span class="type">short</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaaaaaaaaaaaaaa</span>, <span class="number">0xbbbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>A hex dump will show:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa aaaa aaaa aaaa bbbb 0000 cccc cccc</span><br></pre></td></tr></table></figure><p>Notice the gap filled in which zeros. Note, if this were a local variable, the zeros might be garbage.</p><p>change the order:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaa</span>, <span class="number">0xbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>A hex dump will show:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaa 00bb cccc cccc</span><br></pre></td></tr></table></figure><p>Notice there is only one byte of gap before the <code>int c</code> starts.</p><p><em>why are the zeros to the left of the b’s?</em></p><p>This ARM processor is running as a <em>little endian</em> machine.</p><h3 id="defining-structs"><a href="#defining-structs" class="headerlink" title="defining structs"></a>defining structs</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="type">short</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> <span class="title">Bar</span> =</span> &#123; <span class="number">0xaaaa</span>, <span class="number">0xbb</span>, <span class="number">0xcccccccc</span> &#125;;</span><br></pre></td></tr></table></figure><p>Here is one way of defining and accessing the struct:</p><p><strong>硬编码字段偏移量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">bar:</span><br><span class="line">    .short 0xaaaa        // a: short 2 byte</span><br><span class="line">    .byte  0xbb          // b: char  1 byte</span><br><span class="line">    .byte  0x00          // padding</span><br><span class="line">    .word  0xcccccccc    // c: int   4 byte</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line">    .global main</span><br><span class="line">    .align 2</span><br><span class="line">main:</span><br><span class="line">    stp x29, x30, [sp, -16]!    // 保存栈帧</span><br><span class="line">    mov x29, sp</span><br><span class="line"></span><br><span class="line">    adrp x0, fmt</span><br><span class="line">    add  x0, x0, :lo12:fmt      // printf 格式字符串地址</span><br><span class="line"></span><br><span class="line">    adrp x1, bar</span><br><span class="line">    add  x1, x1, :lo12:bar      // bar 的地址</span><br><span class="line"></span><br><span class="line">    ldrh w2, [x1, 0]            // short a</span><br><span class="line">    ldrb w3, [x1, 2]            // char b</span><br><span class="line">    ldr  w4, [x1, 4]            // int  c</span><br><span class="line"></span><br><span class="line">    bl printf                   // 调用 printf(&amp;bar, a, b, c)</span><br><span class="line">    </span><br><span class="line">    // 显式退出系统调用</span><br><span class="line">    mov     x8, #93       // syscall number for exit</span><br><span class="line">    mov     x0, xzr       // exit code 0</span><br><span class="line">    svc     0             // make syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>:lo12:fmt</code> 会被汇编器替换成 <code>fmt</code> 地址的低 12 位。</p><p><code>adrp x0, fmt</code> 会将 <code>fmt</code> 地址向下取整到最近的 <strong>4KB 边界</strong>（即清除低12位），然后加载这个“页基址”到 <code>x0</code>。</p><p>例如：<br> 如果 <code>fmt = 0x12345678</code>，那么：</p><ul><li><code>adrp x0, fmt</code> 会得到 <code>0x12345000</code>（低 12 位清零）</li></ul><p>another way to define a structs is </p><p><strong>使用 <code>.equ</code> 伪指令定义符号常量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    .global main                // main 函数声明</span><br><span class="line">    .text</span><br><span class="line">    .p2align 2</span><br><span class="line"></span><br><span class="line">    .equ foo_a, 0               // like #define foo_a 0</span><br><span class="line">    .equ foo_b, 2               // like #define foo_b 2</span><br><span class="line">    .equ foo_c, 4               // like #define foo_c 4</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    stp     x29, x30, [sp, -16]!  // 保存 x29, x30 到栈上</span><br><span class="line">    mov     x29, sp               // 设置新的帧指针</span><br><span class="line"></span><br><span class="line">    // 加载 fmt 和 bar 的地址</span><br><span class="line">    ldr     x0, =fmt              // fmt 字符串的地址</span><br><span class="line">    ldr     x1, =bar              // bar 的地址</span><br><span class="line">    ldrh    w2, [x1, foo_a]       // 加载 bar.a 到 w2</span><br><span class="line">    ldrb    w3, [x1, foo_b]       // 加载 bar.b 到 w3</span><br><span class="line">    ldr     w4, [x1, foo_c]       // 加载 bar.c 到 w4</span><br><span class="line"></span><br><span class="line">    // 调用 printf，传递参数</span><br><span class="line">    mov     x0, x0               // 第一个参数：fmt 地址</span><br><span class="line">    mov     x1, w2               // 第二个参数：a 的值</span><br><span class="line">    mov     x2, w3               // 第三个参数：b 的值</span><br><span class="line">    mov     x3, w4               // 第四个参数：c 的值</span><br><span class="line">    bl      printf               // 调用 printf</span><br><span class="line"></span><br><span class="line">    // 恢复栈和寄存器</span><br><span class="line">    ldp     x29, x30, [sp], #16  // 恢复 x29 和 x30</span><br><span class="line">    ret                          // 返回</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">fmt:    </span><br><span class="line">.asciz      &quot;%p a: 0x%lx b: %x c: %x\n&quot;   // printf 格式字符串</span><br><span class="line">bar:    </span><br><span class="line">.short      0xaaaa                        // a</span><br><span class="line">    .byte       0xbb                          // b</span><br><span class="line">    .byte       0                               // padding</span><br><span class="line">    .word       0xcccccccc                    // c</span><br><span class="line"></span><br><span class="line">    .end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>the third way:(<strong>Linux only</strong>)</p><p> <strong>使用 <code>.struct</code> 和字段标签自动推导偏移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">    .section .rodata</span><br><span class="line">fmt:</span><br><span class="line">    .asciz &quot;%p a: 0x%lx b: %x c: %x\n&quot;</span><br><span class="line"></span><br><span class="line">    // 用 .struct 模拟 struct Foo 的字段偏移</span><br><span class="line">    .set  Foo, 0</span><br><span class="line">    .struct 0</span><br><span class="line">Foo_a:  .struct Foo_a + 2      // short a: 2字节</span><br><span class="line">Foo_b:  .struct Foo_b + 1      // char b: 1字节</span><br><span class="line">        .struct Foo_b + 1      // padding: 1字节</span><br><span class="line">Foo_c:  .struct Foo_b + 2      // int c: 从 offset 4 开始</span><br><span class="line">    // 现在 Foo_c 是偏移量 4</span><br><span class="line"></span><br><span class="line">    .data</span><br><span class="line">bar:</span><br><span class="line">    .short 0xaaaa              // a: short 2 byte</span><br><span class="line">    .byte  0xbb                // b: char  1 byte</span><br><span class="line">    .byte  0x00                // padding</span><br><span class="line">    .word  0xcccccccc          // c: int   4 byte</span><br><span class="line"></span><br><span class="line">    .text</span><br><span class="line">    .global main</span><br><span class="line">    .align 2</span><br><span class="line">main:</span><br><span class="line">    stp x29, x30, [sp, -16]!   // 保存栈帧</span><br><span class="line">    mov x29, sp</span><br><span class="line"></span><br><span class="line">    adrp x0, fmt</span><br><span class="line">    add  x0, x0, :lo12:fmt     // printf 格式字符串地址</span><br><span class="line"></span><br><span class="line">    adrp x1, bar</span><br><span class="line">    add  x1, x1, :lo12:bar     // bar 的地址</span><br><span class="line"></span><br><span class="line">    ldrh w2, [x1, Foo_a]       // 加载 bar.a（short）</span><br><span class="line">    ldrb w3, [x1, Foo_b]       // 加载 bar.b（char）</span><br><span class="line">    ldr  w4, [x1, Foo_c]       // 加载 bar.c（int）</span><br><span class="line"></span><br><span class="line">    bl printf                  // printf(bar, a, b, c)</span><br><span class="line"></span><br><span class="line">    // 显式退出</span><br><span class="line">    mov     x8, #93            // syscall number for exit</span><br><span class="line">    mov     x0, xzr            // exit code 0</span><br><span class="line">    svc     0                  // syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="using-structs"><a href="#using-structs" class="headerlink" title="using structs"></a>using structs</h4><p>To summarize using <code>structs</code>:</p><ul><li>All <code>structs</code> have a base address</li><li><strong>The base address corresponds to the beginning of the first data member</strong></li><li>All subsequent data members are offsets relative to the first</li><li>In order to use a <code>struct</code> correctly, you must have first calculated the offsets of each data member</li><li>Sometimes there will be padding between data members due to the need to align all data members on natural boundaries.</li></ul><h4 id="this-pointer-in-c"><a href="#this-pointer-in-c" class="headerlink" title="this pointer in c++"></a>this pointer in c++</h4><ul><li><strong>Every non-static method call employs a hidden first parameter. That’s it. That’s the slight of hand. The hidden argument is the this pointer.</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestClass tc;</span><br><span class="line">tc.<span class="built_in">SetString</span>(test_string);</span><br></pre></td></tr></table></figure><p>看起来我们只传入了一个参数 test_string。但实际上编译器传入了两个参数：</p><ol><li><p>第一个是 this 指针：也就是 tc 的地址，传给寄存器 x0</p></li><li><p>第二个是 test_string，传给寄存器 x1</p></li></ol><p>在汇编里看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adrp x1, _test_string</span><br><span class="line">adrp x0, _tc         // 把 tc 对象地址放到 x0 —— 也就是 this 指针</span><br><span class="line">bl __ZN9TestClass9SetStringEPc</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><blockquote><p>The meaning and function of <code>const</code> only <code>partially</code> translates to assembly language.</p></blockquote><ul><li><code>const</code> local variables and <code>const</code> parameters are just like any other data to assembly language. </li><li><p>The constant nature of <code>const</code> local variables and parameters is implemented solely in the compiler.</p></li><li><p><strong><code>const</code> globals are made constant by the hardware</strong>. Attempting to modify a variable protected in this manner will be like poking a dragon. Best not to poke dragons.</p></li></ul><h2 id="switch-and-jump-table"><a href="#switch-and-jump-table" class="headerlink" title="switch and jump table"></a>switch and jump table</h2><blockquote><p>When the C++ optimizer is enabled, it will look at your cases and choose between three different constructs for implementing your <code>switch</code>.</p><p>And, it can use any combination of the following! Compiler writers are smart!</p></blockquote><ol><li>It may emit a long string of <code>if / else</code> constructs.</li><li>It may find the right <code>case</code> using a <em>binary search</em>.</li><li>Finally, it might use a <strong>jump table</strong>.</li></ol><p>Suppose our cases are largely consecutive. Given that all branch instructions are the same length in bytes, we can do math on the switch variable to somehow derive the address of the case we want.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>                                              </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>                                                 </span></span><br><span class="line">                                                                   </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>                                                        </span><br><span class="line">&#123;                                                                   </span><br><span class="line">    <span class="type">int</span> r;                                                         </span><br><span class="line">                                                                    </span><br><span class="line">    srand(time(<span class="number">0</span>));                                                </span><br><span class="line">    r = rand() &amp; <span class="number">7</span>;                                                 </span><br><span class="line">    <span class="keyword">switch</span> (r)                                                      </span><br><span class="line">    &#123;                                                              </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:                                                    </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;0 returned&quot;</span>);                                    </span><br><span class="line">            <span class="keyword">break</span>;                                                 </span><br><span class="line">                                                                 </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:                                                  </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1 returned&quot;</span>);                                   </span><br><span class="line">            <span class="keyword">break</span>;                                                  </span><br><span class="line">                                                                    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:                                                     </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;2 returned&quot;</span>);                                     </span><br><span class="line">            <span class="keyword">break</span>;                                                 </span><br><span class="line">                                                                    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:                                                   </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;3 returned&quot;</span>);                                  </span><br><span class="line">            <span class="keyword">break</span>;                                                </span><br><span class="line">                                                                   </span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:                                                    </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;4 returned&quot;</span>);                                     </span><br><span class="line">            <span class="keyword">break</span>;                                                 </span><br><span class="line">                                                                   </span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:                                                     </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;5 returned&quot;</span>);                                  </span><br><span class="line">            <span class="keyword">break</span>;                                             </span><br><span class="line">                                                                    </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:                                                    </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;6 returned&quot;</span>);                                    </span><br><span class="line">            <span class="keyword">break</span>;                                                  </span><br><span class="line">                                                                  </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:                                                     </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;7 returned&quot;</span>);                                     </span><br><span class="line">            <span class="keyword">break</span>;                                                  </span><br><span class="line">    &#125;                                                               </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                     </span><br><span class="line">&#125;                                                                  </span><br></pre></td></tr></table></figure><p>Notice that the <code>case</code> values are all, in this case, consecutive.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jt:     b       0f</span><br><span class="line">        b       1f</span><br><span class="line">        b       2f</span><br><span class="line">        b       3f</span><br><span class="line">        b       4f</span><br><span class="line">        b       5f</span><br><span class="line">        b       6f</span><br><span class="line">        b       7f</span><br></pre></td></tr></table></figure><p><code>f</code> means forward, <code>b</code> means backward</p><p>At address <code>jt</code> there are a sequence of branch statements… jumps if you will. Being in a sequence, this is an example of a jump table. We’ll compute the index into this <em>array of instructions</em> and then branch to it.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsl     x0, x0, 2     </span><br><span class="line">ldr     x1, =jt          </span><br><span class="line">add     x1, x1, x0        </span><br><span class="line">br      x1                    </span><br></pre></td></tr></table></figure><ul><li><p>Line 2 loads the base address of the “instruction array” starting at address <code>jt</code>.</p><p>complete example</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        .align  4</span><br><span class="line">        .global main</span><br><span class="line"></span><br><span class="line">main:   str     x30, [sp, -16]!</span><br><span class="line">        mov     x0, xzr             // set up call to time(nullptr)</span><br><span class="line">        bl      time                // call time setting up srand</span><br><span class="line">        bl      srand               // call srand setting up rand</span><br><span class="line">        bl      rand                // get a random number</span><br><span class="line">        and     x0, x0, 7           // ensure its range is 0 to 7</span><br><span class="line">                                    // note use of x register is on purpose</span><br><span class="line">        lsl     x0, x0, 2           // multiply by 4</span><br><span class="line">        ldr     x1, =jt             // load base address of jump table</span><br><span class="line">        add     x1, x1, x0          // add offset to base address</span><br><span class="line">        br      x1</span><br><span class="line"></span><br><span class="line">// If, as in this case, all the &quot;cases&quot; have the same number of </span><br><span class="line">// instructions then this intermediate jump table can be omitted saving</span><br><span class="line">// some space and a tiny amount of time. To omit the intermediate jump</span><br><span class="line">// table, you&#x27;d multiply by 12 above and not 4. Twelve because each </span><br><span class="line">// &quot;case&quot; has 3 instructions (3 x 4 == 12).</span><br><span class="line"></span><br><span class="line">// Question for you: If you did omit the jump table, relative to what</span><br><span class="line">// would you jump (since &quot;jt&quot; would be gone).</span><br><span class="line"></span><br><span class="line">jt:     b       0f</span><br><span class="line">        b       1f</span><br><span class="line">        b       2f</span><br><span class="line">        b       3f</span><br><span class="line">        b       4f</span><br><span class="line">        b       5f</span><br><span class="line">        b       6f</span><br><span class="line">        b       7f</span><br><span class="line"></span><br><span class="line">0:      ldr     x0, =ZR</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">1:      ldr     x0, =ON</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">2:      ldr     x0, =TW</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">3:      ldr     x0, =TH</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">4:      ldr     x0, =FR</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">5:      ldr     x0, =FV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">6:      ldr     x0, =SX</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">7:      ldr     x0, =SV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">99:     mov     w0, wzr</span><br><span class="line">        ldr     x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">        .section    .rodata</span><br><span class="line"></span><br><span class="line">ZR:     .asciz      &quot;0 returned&quot;</span><br><span class="line">ON:     .asciz      &quot;1 returned&quot;</span><br><span class="line">TW:     .asciz      &quot;2 returned&quot;</span><br><span class="line">TH:     .asciz      &quot;3 returned&quot;</span><br><span class="line">FR:     .asciz      &quot;4 returned&quot;</span><br><span class="line">FV:     .asciz      &quot;5 returned&quot;</span><br><span class="line">SX:     .asciz      &quot;6 returned&quot;</span><br><span class="line">SV:     .asciz      &quot;7 returned&quot;</span><br><span class="line"></span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><h3 id="implement-falling-through"><a href="#implement-falling-through" class="headerlink" title="implement falling through"></a>implement falling through</h3><p>If there is no break falling the code for a case, control will simply fall through to the next case</p><p>Here is a snippet from the program linked just above</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:      ldr     x0, =ZR  </span><br><span class="line">        bl      puts   </span><br><span class="line">        b       99f </span><br><span class="line">                  </span><br><span class="line">1:      ldr     x0, =ON </span><br><span class="line">        bl      puts    </span><br><span class="line">        b       99f     </span><br></pre></td></tr></table></figure><h3 id="implementing-gaps"><a href="#implementing-gaps" class="headerlink" title="implementing gaps"></a>implementing gaps</h3><p>The example above present shows 8 consecutive cases. What if there was no code for case 4? In other words,  what if case 4 didn’t exit?</p><p>Here is the result:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2:      ldr     x0, =TW</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">3:      ldr     x0, =TH</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">4:      b       99f</span><br><span class="line"></span><br><span class="line">5:      ldr     x0, =FV</span><br><span class="line">        bl      puts</span><br><span class="line">        b       99f</span><br></pre></td></tr></table></figure><h3 id="other-strategies-for-implementing-switch"><a href="#other-strategies-for-implementing-switch" class="headerlink" title="other strategies for implementing switch"></a>other strategies for implementing switch</h3><p>As indicated above, an optimizer has at least three tools available to it to implement complex <code>switch</code> statements. And, it can combine these tools.</p><ol><li>For example, suppose your cases boil down to two ranges of fairly consecutive values. For example, you have cases 0 to 9 and also cases 50 to 59. You can implement this as <strong>two jump tables with an <code>if / else</code> to select</strong> which one you use.</li></ol><p>假设你的 <code>switch</code> 语句中，<code>case</code> 值主要集中在<strong>两个小的连续范围内</strong>，例如：一组是 <code>case 0</code> 到 <code>case 9</code>,另一组是 <code>case 50</code> 到 <code>case 59</code>,那么可以用 <strong>两个跳转表</strong> 来处理这两个范围，再用一个 <code>if / else</code> 来决定使用哪一个跳转表。</p><ol><li>Suppose you have a large <code>switch</code> statement with widely ranging <code>case</code> values. In this case, you can implement a binary search to narrow down to a small range in which another technique becomes viable to narrow down to a single <code>case</code>.</li></ol><p>假设你有一个包含很多 <code>case</code> 分支的 <code>switch</code> 语句，而且这些 <code>case</code> 值之间的<strong>数值范围差异很大</strong>,比如 case 10, case 1000, case 50000…，那么可以<strong>先用二分查找法缩小查找范围</strong>，把目标值限制在一个<strong>较小的范围内</strong>，然后在这个范围内再用其他技术（比如跳转表、线性比较等）来确定最终对应哪个 <code>case</code> 分支。</p><ol><li>You might have need to implement <strong>hierarchical jump tables（分层跳转表）</strong>, for example.</li></ol><p>“分层跳转表”是一种优化结构，适用于以下情况：</p><ul><li><code>case</code> 值非常<strong>稀疏</strong>、<strong>范围极广</strong>（例如 <code>case 0, case 1000, case 2000...</code>)</li><li>但它们在<strong>局部范围内是稠密的</strong>（比如 <code>1000~1009</code>, <code>2000~2009</code>）</li></ul><p>你可以：</p><ol><li><strong>先用一个“一级跳转表”根据高位或区段跳转</strong>到一个子跳转表（子范围）。</li><li><strong>再在子跳转表中做具体跳转</strong>。<br> 这就构成了一个“分层结构”——像树一样的跳转过程。</li></ol><h3 id="strategies-for-implementing-if-else"><a href="#strategies-for-implementing-if-else" class="headerlink" title="strategies for implementing if-else"></a>strategies for implementing if-else</h3><p>If you do choose to implement a long chain of <code>if / else</code> statements, consider how frequently a given case might be chosen. <strong>Put the most common cases at the top of the <code>if / else</code> sequence</strong>.</p><p><strong>This is known as making the common case fast.</strong></p><p>Making the common case fast is one of the Great Ideas in Computer Science. One, you would do well to remember no matter what language you’re working with.</p><h2 id="fucntions"><a href="#fucntions" class="headerlink" title="fucntions"></a>fucntions</h2><h3 id="bottom-line-concept"><a href="#bottom-line-concept" class="headerlink" title="bottom line concept"></a>bottom line concept</h3><p>The <code>bl</code> instruction is stands for Branch with Link. The Link concept is what enables a function (or method) to return to the instruction after the call.</p><p>Branch-with-link computes the address of the instruction following it.</p><blockquote><p>It places this address into register <code>x30</code> and then branches to the label provided. It makes one link of a trail of breadcrumbs to follow to get back following a <code>ret</code>.</p></blockquote><p><strong>This is why it is absolutely essential to backup <code>x30</code> inside your functions if they call other functions themselves.</strong></p><h4 id="a-example"><a href="#a-example" class="headerlink" title="a example"></a>a example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">        .text                                      </span><br><span class="line">        .global main                       </span><br><span class="line">        .align  2                           </span><br><span class="line">                                 </span><br><span class="line">main:   ldr     x0, =hw                </span><br><span class="line">        bl      puts             </span><br><span class="line">        ret</span><br><span class="line">                      </span><br><span class="line">        .data                        </span><br><span class="line">hw:     .asciz  &quot;Hello World!&quot;               </span><br><span class="line">                                                 </span><br><span class="line">        .end  </span><br></pre></td></tr></table></figure><p><strong>The program hung and had to be killed with ^C.</strong> </p><p>Somebody called <code>main()</code> - it’s a function and someone called it with a <code>bl</code> instruction. At the moment <code>main()</code> entered, the address to which it needed to return was sitting in <code>x30</code>.</p><p>Then, <code>main()</code> called a function - in this case <code>puts()</code> but which function is called doesn’t matter - it called a function. In doing so, it overwrote the address to which <code>main()</code> needed to return with the address of line 7 in the code. That is where <code>puts()</code> needs to return.</p><p>So, when line 7 executes it puts the contents of <code>x30</code> into the program counter and branches to it.</p><p>Here is a fixed version of the code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        .text                                   </span><br><span class="line">        .global main                           </span><br><span class="line">        .align  2                         </span><br><span class="line">                                          </span><br><span class="line">main:   str     x30, [sp, -16]!            </span><br><span class="line">        ldr     x0, =hw                     </span><br><span class="line">        bl      puts                 </span><br><span class="line">        ldr     x30, [sp], 16         </span><br><span class="line">        ret                             </span><br><span class="line">                        </span><br><span class="line">        .data                       </span><br><span class="line">hw:     .asciz  &quot;Hello World!&quot;                   </span><br><span class="line">                                             </span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><p>In the AARCH64 Linux style calling convention, values are returned in <code>x0</code> and sometimes also returned in other scratch registers though this is uncommon.(Note that <code>x0</code> could also be <code>w0</code> or the first floating point register if the function is returning a <code>float</code> or <code>double</code>.)</p><p>If your functions call <em>any</em> other functions, <code>x30</code> must be backed up on the stack and then restored into <code>x30</code> before returning.</p><p>A function with more than one return value is not supported by C or C++ but they can be written in assembly language where the rules are yours to break.</p><h3 id="inline-functions"><a href="#inline-functions" class="headerlink" title="inline functions"></a>inline functions</h3><p>Functions that are declared as <em>inline</em> don’t actually make function calls. Instead, the code from the function is type checked and inserted directly where the “call” is made after adjusting for parameter names.</p><h3 id="passing-parameters-to-functions"><a href="#passing-parameters-to-functions" class="headerlink" title="passing parameters to functions"></a>passing parameters to functions</h3><p><strong>How parameters are passed to functions can be different from OS to OS.</strong> This chapter is written to the standard implemented for Linux. </p><p>For the purposes of the present discussion, we assume all parameters are <code>long int</code> and are therefore stored in <code>x</code> registers.</p><ul><li><p><strong>Up to 8 parameters can be passed directly via scratch registers.</strong>（These are <code>x0</code> through <code>x7</code>） Each parameter can be up to the size of an address, long or double (8 bytes).</p><ul><li><p><strong><em>Scratch</em> means the value of the register can be changed at will without any need to backup or restore their values across function calls.</strong></p></li><li><p><strong>This means that you cannot count on the contents of the scratch registers maintaining their value if your function makes any function calls.</strong></p></li></ul></li></ul><h4 id="a-example-1"><a href="#a-example-1" class="headerlink" title="a example"></a>a example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> p1, <span class="type">long</span> p2)</span>              </span><br><span class="line">&#123;                                              </span><br><span class="line">    <span class="keyword">return</span> p1 + p2;                           </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure><p>is implemented as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func:   add x0, x0, x1  </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>If you are the author of both the caller and the callee and both are in assembly language, you can play loosey goosey with how you return values. Specifically, you can return more than one value. <strong>But</strong> if you do so, you give up the possibility of calling these functions from C or C++.</p><h3 id="const-1"><a href="#const-1" class="headerlink" title="const"></a>const</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">long</span> p1, <span class="type">const</span> <span class="type">long</span> p2)</span>              </span><br><span class="line">&#123;                                  </span><br><span class="line">    <span class="keyword">return</span> p1 + p2;</span><br><span class="line">&#125;                                                 </span><br></pre></td></tr></table></figure><p>how would the assembly language change?</p><p>Answer: no change at all!</p><p><code>const</code> is an instruction to the compiler ordering it to prohibit changing the values of <code>p1</code> and <code>p2</code>. We’re smart humans and realize that our assembly language makes no attempt to change <code>p1</code> and <code>p2</code> so no changes are warranted.</p><h3 id="passing-pointers"><a href="#passing-pointers" class="headerlink" title="passing pointers"></a>passing pointers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">long</span> * p1, <span class="type">long</span> * p2)</span>               </span><br><span class="line">&#123;                                                </span><br><span class="line">    *p1 = *p1 + *p2;                           </span><br><span class="line">&#125;                                         </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func:   ldr x2, [x0]                     </span><br><span class="line">        ldr x3, [x1]                            </span><br><span class="line">        add x2, x2, x3                       </span><br><span class="line">        str x2, [x0]                            </span><br><span class="line">        ret                                   </span><br></pre></td></tr></table></figure><p>The value of <code>x0</code> on return is, in the general sense, undefined because this is a <code>void</code> function.</p><h3 id="passing-reference"><a href="#passing-reference" class="headerlink" title="passing reference"></a>passing reference</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">func</span><span class="params">(<span class="type">long</span> &amp; p1, <span class="type">long</span> &amp; p2)</span>                     </span></span><br><span class="line"><span class="function"></span>&#123;                                              </span><br><span class="line">    <span class="keyword">return</span> p1 + p2;                               </span><br><span class="line">&#125;                                      </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func:   ldr x0, [x0]                     </span><br><span class="line">        ldr x1, [x1]                </span><br><span class="line">        add x0, x0, x1      </span><br><span class="line">        ret                </span><br></pre></td></tr></table></figure><p>Passing by reference is also an instruction to the compiler to treat pointers a little differently - the differences don’t show up here so there the only change to our pointer passing version is how we return the answer.</p><h3 id="more-than-eight-parameters"><a href="#more-than-eight-parameters" class="headerlink" title="more than eight parameters"></a>more than eight parameters</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SillyFunction</span><span class="params">(<span class="type">long</span> p1, <span class="type">long</span> p2, <span class="type">long</span> p3, <span class="type">long</span> p4, </span></span><br><span class="line"><span class="params">                   <span class="type">long</span> p5, <span class="type">long</span> p6, <span class="type">long</span> p7, <span class="type">long</span> p8, </span></span><br><span class="line"><span class="params">                   <span class="type">long</span> p9)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This example hurts: %ld %ld\n&quot;</span>, p8, p9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SillyFunction(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">        .text                                                            </span><br><span class="line">        .global    main                                                </span><br><span class="line">                                                                        </span><br><span class="line">/*  Demonstration of using  more than 8 arguments to  a function.  This  </span><br><span class="line">    demo is LINUX only as APPLE will put all arguments beyond the first  </span><br><span class="line">    one on the stack anyway.                                             </span><br><span class="line">                                                                         </span><br><span class="line">    On LINUX, all parameters to a function beyond  the  eight go on the </span><br><span class="line">    stack.  The first 8 go in registers  x0  through  x7 as normal (for </span><br><span class="line">    LINUX).                                                              </span><br><span class="line">*/                                                                    </span><br><span class="line">                                                                       </span><br><span class="line">SillyFunction:                                                        </span><br><span class="line">        stp        x29, x30, [sp, -16]!    // Changes sp.               </span><br><span class="line">        mov        x29, sp                 // set new sp                    </span><br><span class="line">        ldr        x0, =fmt                                 </span><br><span class="line">        mov        x1, x7                  // 第八个参数</span><br><span class="line">        ldr        x2, [sp, 16]            // This does not alter the sp，第九个参数</span><br><span class="line">        bl         printf                                                </span><br><span class="line">        ldp        x29, x30, [sp], 16      // Undoes change to sp.     </span><br><span class="line">        ret                                                          </span><br><span class="line">                                                                          </span><br><span class="line">main:                                                                   </span><br><span class="line">        stp        x29, x30, [sp, -16]!    // sp down total of 16.      </span><br><span class="line">        mov        x29, sp                                                </span><br><span class="line">        mov        x0, 9                                                </span><br><span class="line">        str        x0, [sp, -16]!          // sp down total of 32.     </span><br><span class="line">        mov        x0, 1                                                </span><br><span class="line">        mov        x1, 2                                                  </span><br><span class="line">        mov        x2, 3                                            </span><br><span class="line">        mov        x3, 4                                               </span><br><span class="line">        mov        x4, 5                                              </span><br><span class="line">        mov        x5, 6                                                  </span><br><span class="line">        mov        x6, 7                                                   </span><br><span class="line">        mov        x7, 8                                                   </span><br><span class="line">        bl         SillyFunction                                           </span><br><span class="line">        add        sp, sp, 16           // undoes change of sp by 16 due   </span><br><span class="line">                                        // to function call.              </span><br><span class="line">        ldp        x29, x30, [sp], 16   // undoes change to sp of 16.    </span><br><span class="line">        ret                                                             </span><br><span class="line">                                                                        </span><br><span class="line">        .data                                                            </span><br><span class="line">fmt:    .asciz    &quot;This example hurts my brain: %ld %ld\n&quot;           </span><br><span class="line">                                                                       </span><br><span class="line">        .end                                                         </span><br></pre></td></tr></table></figure><p>After executing <code>Line 24</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    former contents of frame pointer</span><br><span class="line">sp + 8    return address for main</span><br></pre></td></tr></table></figure><p>After executing <code>Line 27</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    9</span><br><span class="line">sp + 8    garbage</span><br><span class="line">sp + 16   former contents of frame pointer</span><br><span class="line">sp + 24   return address for main</span><br></pre></td></tr></table></figure><p>After executing <code>Line 14</code>, the stack will have:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sp + 0    return address for SillyFunction</span><br><span class="line">sp + 8    garbage</span><br><span class="line">sp + 16   9</span><br><span class="line">sp + 24   garbage</span><br><span class="line">sp + 32   former contents of frame pointer</span><br><span class="line">sp + 40   return address for main</span><br></pre></td></tr></table></figure><p>This means that <code>Line 18</code> fetches <code>p9</code> from memory and puts its value into x2 (where it becomes the third argument to <code>printf()</code>).</p><blockquote><p>在 AArch64 中，栈空间常常是 <strong>以 16 字节为单位对齐</strong>分配的，但你可能 <strong>只写了其中的一部分数据</strong>，剩下的就没有被初始化，于是我们称它为 <strong>“garbage”（未定义的内容）</strong>。</p></blockquote><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><p><strong>The stack pointer in ARM V8 can only be manipulated in multiples of 16.</strong></p><h3 id="examples-of-calling-some-common-C-runtime-functions"><a href="#examples-of-calling-some-common-C-runtime-functions" class="headerlink" title="examples of calling some common C runtime functions"></a>examples of calling some common C runtime functions</h3><p>There are, by the way, two broad types of functions within the C runtime. </p><ul><li><p>Some are implemented largely in the C runtime itself. </p></li><li><p>Others that exist in the C runtime act as wrappers for functions implemented within the OS itself. These are called “system calls”.</p></li></ul><p>For the purposes of calling functions in the C runtime, there is no practical difference between these two types. Note however, there are ways of calling system calls directly using the <code>svc</code> instruction.</p><p>“C runtime”（<strong>C 运行时</strong>）指的是一组在程序运行时提供支持的函数、变量和基础机制，<strong>主要用于支持 C 语言标准库和程序的初始化/终止</strong>。这套系统通常被称为 <strong>C runtime library（C 运行时库）</strong>，在不同平台中常见的实现有：</p><ul><li>GNU/Linux 下的 <strong>glibc</strong></li><li>Windows 下的 <strong>MSVCRT</strong></li><li>macOS 下的 <strong>libSystem.dylib（包含 libc）</strong></li></ul><p>C runtime 做了哪些事？</p><ol><li><strong>程序初始化</strong><ul><li>在 <code>main()</code> 执行之前，C runtime 会设置好堆栈、初始化全局变量、调用构造函数等。</li><li>典型入口点是 <code>_start</code> → <code>__libc_start_main()</code> → <code>main()</code>。</li></ul></li><li><strong>提供标准库函数</strong><ul><li>如 <code>printf()</code>, <code>malloc()</code>, <code>exit()</code>, <code>fopen()</code> 等，这些函数由 C runtime 实现或封装。</li></ul></li><li><strong>管理资源</strong><ul><li>比如内存分配、文件句柄、线程等的生命周期管理。</li></ul></li><li><strong>提供系统调用封装</strong><ul><li>比如你调用 <code>write()</code>，它其实是调用了一个 <strong>C runtime 提供的 wrapper</strong>，最终通过 <code>syscall</code> 或 <code>svc</code> 指令访问内核。</li></ul></li></ol><h3 id="system-calls"><a href="#system-calls" class="headerlink" title="system calls"></a>system calls</h3><p>Many C runtime functions are just wrappers for system calls. For example if you call open() from the C runtime, the function will perform a few bookkeeping operations and then make the actual system call.</p><h4 id="What-IS-a-system-call"><a href="#What-IS-a-system-call" class="headerlink" title="What IS a system call?"></a>What IS a system call?</h4><p>The short answer is a system call is a sort-of function call that is serviced by the operating system itself, within its own private region of memory and with access to internal features and data structures.</p><p>Our programs run in “userland”. The technical name for userland on the ARM64 processor is EL0 (Exception Level 0).</p><p>We can operate within the kernel’s space only through carefully controlled mechanisms - such as system calls. The technical name for where the kernel (or system) generally operates is called EL1.</p><p>There are two higher Exception Levels (EL2 and EL3) which are beyond the scope of this book.</p><h4 id="Mechanism-of-making-a-system-call"><a href="#Mechanism-of-making-a-system-call" class="headerlink" title="Mechanism of making a system call"></a>Mechanism of making a system call</h4><p>First, like any function call, parameters need to be set up. The first parameter goes in the first register, etc.</p><p>Second, a number associated with the specific system call we wish to make is loaded in a specific register (w8).</p><p>Finally, a special instruction svc causes a trap which elevates us out of userland into kernel space. Said differently, svc causes a transition from EL0 to EL1. There, various checks are done and the actual code for the system call is run.</p><p>A description of returning from a system call is beyond the scope of this book. Hint: just as there’s a special instruction that escalates from EL0 to EL1, there is a special instruction that does the reverse.</p><h4 id="the-number-associated-with-a-particular-system-call"><a href="#the-number-associated-with-a-particular-system-call" class="headerlink" title="the number associated with a particular system call"></a>the number associated with a particular system call</h4><p>reference:</p>   <div class="tag link"><a class="link-card" title="syscalls" href="https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html"><div class="left"><img src="/img/avatar.jpg"/></div><div class="right"><p class="text">syscalls</p><p class="url">https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html</p></div></a></div><h4 id="example-getpid"><a href="#example-getpid" class="headerlink" title="example getpid()"></a>example getpid()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>                                                </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>                                               </span></span><br><span class="line">                                                                  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;                                                      </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Greetings from: %d\n&quot;</span>, getpid());                     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                     </span><br><span class="line">&#125;                                                                 </span><br></pre></td></tr></table></figure><p>Written in assembly language using C runtime<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        .global main                                              </span><br><span class="line">        .text                                                     </span><br><span class="line">        .align  2                                                 </span><br><span class="line">                                                                  </span><br><span class="line">main:   stp     x29, x30, [sp, -16]!                              </span><br><span class="line">        bl      getpid                                            </span><br><span class="line">        mov     w1, w0                                            </span><br><span class="line">        ldr     x0, =fmt                                          </span><br><span class="line">        bl      printf                                            </span><br><span class="line">        ldp     x29, x30, [sp], 16                                </span><br><span class="line">        mov     w0, wzr                                           </span><br><span class="line">        ret                                                       </span><br><span class="line">                                                                  </span><br><span class="line">        .data                                                     </span><br><span class="line">fmt:    .asciz  &quot;Greetings from: %d\n&quot;                            </span><br><span class="line">                                                                  </span><br><span class="line">        .end                                                      </span><br></pre></td></tr></table></figure><br>And finally: calling the system call directly<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        .global main                                              </span><br><span class="line">        .text                                                     </span><br><span class="line">        .align  2                                                 </span><br><span class="line">                                                                  </span><br><span class="line">main:   stp     x29, x30, [sp, -16]!                              </span><br><span class="line">        mov     x8, 172                 // getpid on ARM64        </span><br><span class="line">        svc     0                       // trap to EL1            </span><br><span class="line">        mov     w1, w0                                            </span><br><span class="line">        ldr     x0, =fmt                                          </span><br><span class="line">        bl      printf                                            </span><br><span class="line">        ldp     x29, x30, [sp], 16                                </span><br><span class="line">        mov     w0, wzr                                           </span><br><span class="line">        ret                                                       </span><br><span class="line">                                                                  </span><br><span class="line">        .data                                                     </span><br><span class="line">fmt:    .asciz  &quot;Greetings from: %d\n&quot;                            </span><br><span class="line">                                                                  </span><br><span class="line">        .end                                                      </span><br></pre></td></tr></table></figure><br>We chose getpid() because it doesn’t require any parameters. Using the C runtime, we simply bl to it. <strong>Calling the system call directly is different in that we must first load x8 with the number that corresponds to getpid() for the AARCH64 architecture</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">/*  Perry Kivolowitz</span><br><span class="line">    Example of file operations.</span><br><span class="line">*/</span><br><span class="line">        .text</span><br><span class="line">        .global main</span><br><span class="line">        .align  2</span><br><span class="line"></span><br><span class="line">/*  This program will</span><br><span class="line">    * open() a file in the current directory,</span><br><span class="line">    * write() some text to it, </span><br><span class="line">    * seek back to the beginning of the file,</span><br><span class="line">    * read() each line, printing it</span><br><span class="line">    * close() the file</span><br><span class="line">*/</span><br><span class="line">// 使用 .req 给寄存器取别名，便于阅读。例如，fd 其实就是 w28，代表文件描述符。</span><br><span class="line">retval  .req    w27</span><br><span class="line">fd .reqw28</span><br><span class="line"></span><br><span class="line">main:   stp     x29, x30, [sp, -16]!</span><br><span class="line">        stp     x27, x28, [sp, -16]!</span><br><span class="line">        bl      open_file</span><br><span class="line"></span><br><span class="line">        // w0 will contain either the file descriptor of the new</span><br><span class="line">        // file or -1 for a failure. Note that the value in w0</span><br><span class="line">        // has also been copied to &quot;fd&quot; - a register alias.</span><br><span class="line">        cmp w0, wzr</span><br><span class="line">        bge 1f</span><br><span class="line"></span><br><span class="line">        // If we get here, the open has failed. Use perror() to</span><br><span class="line">        // print a meaningful error and branch to exit. The return</span><br><span class="line">        // code of the program will be set to non-zero inside fail.</span><br><span class="line">        ldr     x0, =fname</span><br><span class="line">        bl      fail</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">1:// When we get here, the file is open. Write some data to it.</span><br><span class="line">        // If write_file returns non-zero, it signifies an error. If</span><br><span class="line">        // so, branch to the file closing code since the file is open</span><br><span class="line">        // after printing an error message.</span><br><span class="line">        blwrite_data</span><br><span class="line">        cbz    w0, 10f</span><br><span class="line"></span><br><span class="line">        // If we get here, there was an error in write_data. Print</span><br><span class="line">        // a reasonable error message then branch to the clean usleep</span><br><span class="line">        // code.</span><br><span class="line">        ldr     x0, =wf     // load legend</span><br><span class="line">        bl      fail        // print error</span><br><span class="line">        b       50f         // branch to clean up.</span><br><span class="line"></span><br><span class="line">        // Seek back to position zero preparing to read the file back.</span><br><span class="line">        // The return value in x0 (off_t) is the return value of</span><br><span class="line">        // lseek(). </span><br><span class="line">10:     bl      seek_zero</span><br><span class="line">        cbz     x0, 20f</span><br><span class="line"></span><br><span class="line">        // If we get here, the seek failed. Cause a reasonable</span><br><span class="line">        // message to be printed then branch to the clean up code.</span><br><span class="line">        ldr     x0, =sf</span><br><span class="line">        bl      fail</span><br><span class="line">        b       50f</span><br><span class="line"></span><br><span class="line">20:     // When we get here, we have to read from the file and print</span><br><span class="line">        // the results. To ignore the complexity of memory allocation</span><br><span class="line">        // and buffer overrun potential, we&#x27;ll read one character at a </span><br><span class="line">        // time looking the end-of-file.</span><br><span class="line"></span><br><span class="line">        // ssize_t read(int fildes, void *buf, size_t nbyte);</span><br><span class="line">        mov     w0, fd</span><br><span class="line">        ldr     x1, =buffer</span><br><span class="line">        mov     x2, 1</span><br><span class="line">        bl      read</span><br><span class="line">        // Check the return value - should be 1.</span><br><span class="line">        cbz     x0,50f      // zero means EOF - that&#x27;s OK.</span><br><span class="line">        // If x0 is negative, that IS a problem.</span><br><span class="line">        cmp     x0, xzr</span><br><span class="line">        bge     25f</span><br><span class="line">        // The return value is negative - this is an error.</span><br><span class="line">        ldr     x0, =rf</span><br><span class="line">        bl      fail</span><br><span class="line">        b       99f</span><br><span class="line"></span><br><span class="line">25:     // Write the character sitting in buffer to the console.</span><br><span class="line">        mov     w0, 1</span><br><span class="line">        ldr     x1, =buffer</span><br><span class="line">        mov     x2, 1</span><br><span class="line">        bl      write</span><br><span class="line">        // We will ignore the return value for the sake of brevity.</span><br><span class="line">        // There are plenty of examples of handling a potential error</span><br><span class="line">        // elsewhere in this code.</span><br><span class="line">        // --</span><br><span class="line">        b       20b</span><br><span class="line"></span><br><span class="line">        // When we get here, we are done. Close the file.</span><br><span class="line">50:movw0, fd</span><br><span class="line">        bl close</span><br><span class="line">        mov retval, wzr</span><br><span class="line"></span><br><span class="line">99:     ldp     x27, x28, [sp], 16</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        mov     w0, retval</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*open_file()</span><br><span class="line">    This function attempts to open a file for both reading and</span><br><span class="line">    writing. Return values will be checked to ensure the file is</span><br><span class="line">    opened. If successful, the fd is returned (and is squirreled</span><br><span class="line">    away in register &quot;fd&quot;). If unsuccessful, the -1 returned by</span><br><span class="line">    open() is passed back to the caller.</span><br><span class="line"></span><br><span class="line">    Explanation of the magic numbers:</span><br><span class="line"></span><br><span class="line">    int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">    octal 102 for flags is O_RDRW | O_CREAT</span><br><span class="line">    octal 600 for mode is rw------- i.e. read and write for</span><br><span class="line">        the owner but no permissions for anyone else.</span><br><span class="line"></span><br><span class="line">There is a version of open() that takes two parameters. However,</span><br><span class="line">if O_CREAT is specified, the three parameter version is required.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">        .equ    O_FLAGS, 0102</span><br><span class="line">        .equ    O_MODE, 0600</span><br><span class="line"></span><br><span class="line">open_file:</span><br><span class="line">        stp      x29, x30, [sp, -16]!</span><br><span class="line">        ldr      x0, =fname</span><br><span class="line">        mov      w1, O_FLAGS</span><br><span class="line">        mov      w2, O_MODE</span><br><span class="line">        bl       open</span><br><span class="line">        mov      fd, w0</span><br><span class="line">        ldp      x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*  This function uses perror() to print a meaningful error</span><br><span class="line">    message in the event of a failure. The string value</span><br><span class="line">    passed to perror() arrives to us as a pointer in x0.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        bl perror</span><br><span class="line">        movretval, 1</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*  ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">This function will write a string to the file descriptor contained</span><br><span class="line">in &quot;fd&quot; (a register alias).</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">write_data:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        str     x20, [sp, -16]!</span><br><span class="line">        mov     w0, fd              // file descriptor</span><br><span class="line">        ldr     x1, =txt            // address to print from</span><br><span class="line">        ldr     x2, =txt_s          // load pointer to size</span><br><span class="line">        ldr     x2, [x2]            // dereference the pointer</span><br><span class="line">        mov     w20, w2             // need this value for error check.</span><br><span class="line">        bl      write</span><br><span class="line">        cmp     x0, x20             // Did we write the expected amount?</span><br><span class="line">        bne     90f</span><br><span class="line">        // successful write - return 0</span><br><span class="line">        mov     x0, xzr</span><br><span class="line">        b       99f</span><br><span class="line">90:     // failure - ensure we return non-zero!</span><br><span class="line">        mov     x0, 1</span><br><span class="line">99:     ldr     x20, [sp], 16</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">/*  off_t lseek(int fd, off_t offset, int whence);</span><br><span class="line">*/</span><br><span class="line">seek_zero:</span><br><span class="line">        stp     x29, x30, [sp, -16]!</span><br><span class="line">        mov     w0, fd          // file descriptor</span><br><span class="line">        mov     x1, xzr         // beginning of file</span><br><span class="line">        mov     w2, wzr         // SEEK_SET - absolute offset</span><br><span class="line">        bl      lseek</span><br><span class="line">        ldp     x29, x30, [sp], 16</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        .data</span><br><span class="line">prog:.asciz&quot;file_ops&quot;</span><br><span class="line">wf:     .asciz  &quot;write failed&quot;</span><br><span class="line">rf:     .asciz  &quot;read failed&quot;</span><br><span class="line">sf:     .asciz  &quot;lseek failed&quot;</span><br><span class="line">fname:.asciz&quot;test.txt&quot;</span><br><span class="line">txt:.asciz&quot;some data\n&quot;</span><br><span class="line">txt_s:.wordtxt_s - txt - 1// strlen(txt)，txt：“some data”的总长度</span><br><span class="line">buffer: .word   0</span><br><span class="line">        .end</span><br></pre></td></tr></table></figure><h2 id="floating-point"><a href="#floating-point" class="headerlink" title="floating point"></a>floating point</h2><h3 id="what-are-floating-points-numbers"><a href="#what-are-floating-points-numbers" class="headerlink" title="what are floating points numbers?"></a>what are floating points numbers?</h3><p>reference<br>   <div class="tag link"><a class="link-card" title="CSAPP DataLab" href="https://even629.com/posts/42856/"><div class="left"><img src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">CSAPP DataLab</p><p class="url">https://even629.com/posts/42856/</p></div></a></div></p><p><strong>IEEE 754</strong></p><h3 id="register-1"><a href="#register-1" class="headerlink" title="register"></a>register</h3><p>There are four highest level ideas relating to floating point operations on AARCH64.</p><ul><li>There is another complete register set for floating point values.</li><li>There are alternative instructions just for floating point values.</li><li>There are exotic instructions that operate on sets of floating point values (SIMD).</li><li>There are instructions to go back and forth to and from the integer registers.</li></ul><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/simdlanes.jpg" alt="regs"></p><p>上图展示了 <strong>ARM64 架构中 SIMD（Single Instruction, Multiple Data）寄存器 V0 的不同视图与访问方式</strong>，包括<strong>不同位宽的排列方式（Arrangement Specifiers）与 Lane（通道）索引</strong>。</p><p> <strong>图解说明</strong></p><p>这个图以 <strong>V0 寄存器为例</strong>，展示了 <strong>如何用不同的排列方式访问其内容</strong>：</p><div class="table-container"><table><thead><tr><th>层级</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>最底层</td><td><code>V0</code></td><td>整个 128-bit 的 V0 寄存器</td></tr><tr><td>向上</td><td><code>V0.2D</code>, <code>V0.4S</code>, <code>V0.8H</code>, <code>V0.16B</code></td><td>以不同大小的数据视图访问 V0：<br/>- D = 64-bit（2 × 64bit）<br/>- S = 32-bit（4 × 32bit）<br/>- H = 16-bit（8 × 16bit）<br/>- B = 8-bit（16 × 8bit）</td></tr><tr><td>再上</td><td><code>V0.2D[0]</code>, <code>V0.4S[0]</code> 等</td><td>每个 lane 的索引，比如：<br/>- <code>V0.4S[2]</code> 表示第 3 个 32-bit 单元<br/>- <code>V0.16B[15]</code> 表示第 16 个 8-bit 字节</td></tr><tr><td>最上层</td><td><code>B0</code>, <code>H0</code>, <code>S0</code>, <code>D0</code></td><td>是对 <code>V0</code> 的 alias，按位宽访问（只访问最低位的数据）</td></tr></tbody></table></div><h3 id="truncation-towards-zero"><a href="#truncation-towards-zero" class="headerlink" title="truncation towards zero"></a>truncation towards zero</h3><p>truncate(截断)</p><p>In C and C++, truncation is what we get from:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">integer_variable = <span class="type">int</span>(floating_variable);  <span class="comment">// C++</span></span><br><span class="line">integer_variable = (<span class="type">int</span>) floating_variable; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><blockquote><p>The instruction is <strong>fcvtz</strong> - convert towards zero. Then, the choice as to whether to produce a signed or unsigned result is defined by the final letterL u or s.</p></blockquote><div class="table-container"><table><thead><tr><th>Mnemonic</th><th>Meaning</th></tr></thead><tbody><tr><td>fcvtzu</td><td>Truncate (always towards 0) producing an unsigned int</td></tr><tr><td>fcvtzs</td><td>Truncate (always towards 0) producing a signed int</td></tr></tbody></table></div><ul><li>fcvtzu: <strong>F</strong>loat <strong>C</strong>onvert to <strong>U</strong>nsigned integer, with truncation toward zero</li><li>fcvtzs: <strong>F</strong>loat <strong>C</strong>onvert to <strong>S</strong>igned integer, with truncation toward zero</li></ul><p>this instruction which completely discards the fractional value is said by the ARM documentation as doing rounding not truncating.</p><p>The the choice of source register defined whether you are converting a double or single precision floating point value.</p><div class="table-container"><table><thead><tr><th>Source Register</th><th>Converts a</th></tr></thead><tbody><tr><td>dX</td><td><code>double</code> to an integer</td></tr><tr><td>sX</td><td><code>float</code> to an integer</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Destination Register</th><th>Converts a</th></tr></thead><tbody><tr><td>xX</td><td>64 bit integer</td></tr><tr><td>wX</td><td>32 bit or less integer</td></tr></tbody></table></div><p>Examples where <code>d</code> is a <code>double</code> and <code>f</code> is a <code>float</code>:</p><div class="table-container"><table><thead><tr><th>C++</th><th>Instruction</th></tr></thead><tbody><tr><td><code>int32_t(d)</code></td><td><code>fcvtzs    w0, d0</code></td></tr><tr><td><code>uint32_t(d)</code></td><td><code>fcvtzu    w0, d0</code></td></tr><tr><td><code>int64_t(d)</code></td><td><code>fcvtzs    x0, d0</code></td></tr><tr><td><code>uint64_t(d)</code></td><td><code>fcvtzu    x0, d0</code></td></tr></tbody></table></div><h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">    .section .text</span><br><span class="line">    .global main</span><br><span class="line">    .type main, @function // 表示 告诉汇编器和链接器：main 是一个函数符号（symbol）</span><br><span class="line">    //.type &lt;symbol&gt;, @&lt;type&gt; 是 GAS（GNU Assembler）的一条伪指令，用于给符号指定类型。</span><br><span class="line">    // &lt;symbol&gt;：符号名，比如 main</span><br><span class="line">    // @&lt;type&gt;：符号类型，这里是 @function，表示这是一个函数，而不是变量或标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    stp     x29, x30, [sp, -16]!     // 保存 frame pointer 和 link register</span><br><span class="line">    mov     x29, sp</span><br><span class="line"></span><br><span class="line">    // 保存浮点寄存器</span><br><span class="line">    stp     d20, d21, [sp, -16]!</span><br><span class="line">    stp     d22, d23, [sp, -16]!</span><br><span class="line"></span><br><span class="line">    // 加载提示信息</span><br><span class="line">    ldr     x0, =leg</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // 加载 vless 数据到 d20-d23</span><br><span class="line">    ldr     x0, =vless</span><br><span class="line">    ldr     d20, [x0]            // dless = 5.49</span><br><span class="line">    ldr     d21, [x0, #8]        // dmore = 5.51</span><br><span class="line">    ldr     d22, [x0, #16]       // ndless = -5.49</span><br><span class="line">    ldr     d23, [x0, #24]       // ndmore = -5.51</span><br><span class="line"></span><br><span class="line">    // fcvtps: 向上取整（+∞）</span><br><span class="line">    fcvtps  x1, d20</span><br><span class="line">    fcvtps  x2, d21</span><br><span class="line">    ldr     x0, =fmt1</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtps  x1, d22</span><br><span class="line">    fcvtps  x2, d23</span><br><span class="line">    ldr     x0, =fmt1</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtns: 四舍五入 (tie to even)</span><br><span class="line">    fcvtns  x1, d20</span><br><span class="line">    fcvtns  x2, d21</span><br><span class="line">    ldr     x0, =fmt2</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtns  x1, d22</span><br><span class="line">    fcvtns  x2, d23</span><br><span class="line">    ldr     x0, =fmt2</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtzs: 向 0 取整</span><br><span class="line">    fcvtzs  x1, d20</span><br><span class="line">    fcvtzs  x2, d21</span><br><span class="line">    ldr     x0, =fmt4</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtzs  x1, d22</span><br><span class="line">    fcvtzs  x2, d23</span><br><span class="line">    ldr     x0, =fmt4</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // fcvtas: 四舍五入 (tie away from zero)</span><br><span class="line">    fcvtas  x1, d20</span><br><span class="line">    fcvtas  x2, d21</span><br><span class="line">    ldr     x0, =fmt3</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    fcvtas  x1, d22</span><br><span class="line">    fcvtas  x2, d23</span><br><span class="line">    ldr     x0, =fmt3</span><br><span class="line">    bl      printf</span><br><span class="line"></span><br><span class="line">    // 恢复浮点寄存器和返回地址</span><br><span class="line">    ldp     d22, d23, [sp], #16</span><br><span class="line">    ldp     d20, d21, [sp], #16</span><br><span class="line">    ldp     x29, x30, [sp], #16</span><br><span class="line">    mov     w0, wzr</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">    .section .rodata</span><br><span class="line">vless:</span><br><span class="line">    .double 5.49</span><br><span class="line">    .double 5.51</span><br><span class="line">    .double -5.49</span><br><span class="line">    .double -5.51</span><br><span class="line"></span><br><span class="line">fmt1:</span><br><span class="line">    .asciz &quot;fcvtps less: %ld more: %ld\n&quot;</span><br><span class="line">fmt2:</span><br><span class="line">    .asciz &quot;fcvtns less: %ld more: %ld\n&quot;</span><br><span class="line">fmt3:</span><br><span class="line">    .asciz &quot;fcvtas less: %ld more: %ld\n&quot;</span><br><span class="line">fmt4:</span><br><span class="line">    .asciz &quot;fcvtzs less: %ld more: %ld\n&quot;</span><br><span class="line">leg:</span><br><span class="line">    .asciz &quot;less values are +/- 5.49. more values are +/- 5.51.\n&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Notice all the values were truncated to the whole number that is closer to zero.</p><h3 id="Truncation-Away-From-Zero"><a href="#Truncation-Away-From-Zero" class="headerlink" title="Truncation Away From Zero"></a>Truncation Away From Zero</h3><p>Truncation away from zero is not as easy. In fact, it cannot be performed with a single instruction.</p><p>In C (and C++):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iv = (<span class="type">int</span>(fv) == fv) ? <span class="type">int</span>(fv) : <span class="type">int</span>(fv) + ((fv &lt; <span class="number">0</span>) ? <span class="number">-1</span> : <span class="number">1</span>);</span><br></pre></td></tr></table></figure><br>If the fv is already equal to a whole number, the integer value will be that whole number. Other wise the iv is the whole number further away from zero.</p><p>In C++, a more sophisticated version would require <cmath> and could look like:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MyTruncate</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((x &lt; <span class="number">0</span>) ? <span class="built_in">floor</span>(x) : <span class="built_in">ceil</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>floor() always truncates downward (towards more negative).<br>ceil() always truncates upwards (towards more positive).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RoundAwayFromZero:</span><br><span class="line">        fcmp    d0, 0</span><br><span class="line">        ble     1f</span><br><span class="line">        // Value is positive, truncate towards positive infinity (ceil)</span><br><span class="line">        frintp  d0, d0</span><br><span class="line">        b       2f</span><br><span class="line">1:      // Value is negative, truncate towards negative infinity (floor)</span><br><span class="line">        frintm  d0, d0</span><br><span class="line">2:      fcvtzs  x0, d0</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><ul><li><p>frintp（<strong>R</strong>ound toward +∞）</p></li><li><p>frintm（<strong>R</strong>ound toward -∞）</p></li><li><p>frintz（<strong>R</strong>ound toward 0）</p></li><li><p>frinta（<strong>R</strong>ound to nearest, tie away from 0）</p></li><li><p>frintn（<strong>R</strong>ound to nearest, tie to even）</p></li></ul><h3 id="rounding-conversion"><a href="#rounding-conversion" class="headerlink" title="rounding conversion"></a>rounding conversion</h3><p>rounding(四舍五入)<br>An instruction which does what we normally think of as rounding is frinta. This is the conversion “to nearest with ties going away.” So, 5.5 goes to 6 as one would expect from “rounding.”</p><h3 id="converting-an-integer-to-a-float-point-value"><a href="#converting-an-integer-to-a-float-point-value" class="headerlink" title="converting an integer to a float point value"></a>converting an integer to a float point value</h3><p>In C / C++:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double_var = <span class="built_in">double</span>(integer_var); <span class="comment">// C++</span></span><br><span class="line">double_var = (<span class="type">double</span>)integer_var; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><br>Is handled by two instructions:</p><ul><li><strong>scvtf</strong> converts a signed integer to a floating point value</li><li><strong>ucvtf</strong> converts an unsigned integer to a floating point value<br>The name of the destination register controls which kind of floating point value is made. For example, specifying dX makes a double etc.</li></ul><p>The name of the destination register controls which kind of floating point value is made. For example, specifying dX makes a double etc.</p><h3 id="floating-point-literals"><a href="#floating-point-literals" class="headerlink" title="floating point literals"></a>floating point literals</h3><p>Recall that all AARCH64 instructions are 4 bytes long. Recall also that this means that there are constraints on what can be specified as a literal since the literal must be encoded into the 4 byte instruction. If the literal is too large, an assembler error will result.</p><p>Given that floating point values are always at least 4 bytes long themselves, using floating point literals is extremely constrained. For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmov    d0, 1     // 1</span><br><span class="line">fmov    d0, 1.1   // 2</span><br></pre></td></tr></table></figure><p>Line 1 will pass muster but Line 2 will cause an error.</p><p>To load a float, you could translate the value to binary and do as the following:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        .text                                                   </span><br><span class="line">        .global main                                            </span><br><span class="line">        .align    2                                             </span><br><span class="line">                                                                </span><br><span class="line">main:   str        x30, [sp, -16]!                              </span><br><span class="line">        ldr        s0, =0x3fc00000                              </span><br><span class="line">        fcvt       d0, s0                                       </span><br><span class="line">        ldr        x0, =fmt                                     </span><br><span class="line">        bl         printf                                       </span><br><span class="line">        ldr        x30, [sp], 16                                </span><br><span class="line">        mov        w0, wzr                                      </span><br><span class="line">        ret                                                     </span><br><span class="line">                                                                </span><br><span class="line">        .data                                                   </span><br><span class="line">fmt:    .asciz    &quot;%f\n&quot;                                        </span><br><span class="line">        .end                                                    </span><br></pre></td></tr></table></figure></p><blockquote><p>printf() only knows how to print double precision values. When you specify a float, it will convert it to a double before emitting it.</p></blockquote><p>Translating floats and doubles by hand isn’t a common practice for humans, though compilers are happy to do so.</p><p>Instead for us humans, the assembler directives .float and .double are used more frequently to specify float and double values putting them into RAM.<br>a example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        .global main                                            </span><br><span class="line">        .text                                                   </span><br><span class="line">        .align  2                                               </span><br><span class="line">                                                                </span><br><span class="line">counter .req    x20                                             </span><br><span class="line">dptr    .req    x21                                             </span><br><span class="line">fptr    .req    x22                                             </span><br><span class="line">        .equ    max, 4                                              </span><br><span class="line">                                                                    </span><br><span class="line">main:   stp     counter, x30, [sp, -16]!                            </span><br><span class="line">        stp     dptr, fptr, [sp, -16]!                              </span><br><span class="line">        ldr     dptr, =d                                            </span><br><span class="line">        ldr     fptr, =f                                            </span><br><span class="line">        mov     counter, xzr                                        </span><br><span class="line">                                                                    </span><br><span class="line">1:      cmp     counter, max                                        </span><br><span class="line">        beq     2f                                                  </span><br><span class="line">                                                                    </span><br><span class="line">        ldr     d0, [dptr, counter, lsl 3]                          </span><br><span class="line">        ldr     s1, [fptr, counter, lsl 2]                          </span><br><span class="line">        fcvt    d1, s1                                              </span><br><span class="line">        ldr     x0, =fmt                                            </span><br><span class="line">        add     counter, counter, 1                                 </span><br><span class="line">        mov     x1, counter                                         </span><br><span class="line">        bl      printf                                              </span><br><span class="line">        b       1b                                                  </span><br><span class="line">                                                                    </span><br><span class="line">2:      ldp     dptr, fptr, [sp], 16                                </span><br><span class="line">        ldp     counter, x30, [sp], 16                              </span><br><span class="line">        mov     w0, wzr                                             </span><br><span class="line">        ret                                                         </span><br><span class="line">                                                                    </span><br><span class="line">        .data                                                       </span><br><span class="line">fmt:    .asciz  &quot;%d %f %f\n&quot;                                       </span><br><span class="line">d:      .double 1.111111, 2.222222, 3.333333, 4.444444              </span><br><span class="line">f:      .float  1.111111, 2.222222, 3.333333, 4.444444             </span><br><span class="line">                                                                    </span><br><span class="line">        .end                                                        </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>指令</th><th>全称/缩写</th><th>作用</th><th>常见用法示例</th></tr></thead><tbody><tr><td><code>.req</code></td><td><strong>register require</strong>（非官方缩写）</td><td>给<strong>寄存器起别名</strong></td><td><code>foo .req x0</code> 表示以后写 <code>foo</code> 就等于 <code>x0</code></td></tr><tr><td><code>.equ</code></td><td><strong>equate</strong></td><td>定义一个<strong>常量符号</strong></td><td><code>BUF_SIZE .equ 64</code> 表示 <code>BUF_SIZE = 64</code></td></tr></tbody></table></div><p>On Linux, just as w/x0 through w/x7 are scratch registers and used to pass parameters, s/d0 and s/d7 are as well beginning with the 0 register.</p><p>即：</p><p>📥 整数参数传递：<br>x0 ~ x7（或 32 位的 w0 ~ w7）用于传递前 8 个整数类参数（int、pointer、long 等）。</p><p>超过 8 个就通过栈传递。</p><p>📥 浮点参数传递：<br>d0 ~ d7（64 位 double 类型）或 s0 ~ s7（32 位 float 类型）用于传递前 8 个浮点参数。</p><p>超过 8 个浮点参数也是通过栈传递。</p><h4 id="Fitting-32-bits-into-a-32-bit-bag"><a href="#Fitting-32-bits-into-a-32-bit-bag" class="headerlink" title="Fitting 32 bits into a 32 bit bag"></a>Fitting 32 bits into a 32 bit bag</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr s0, =0x3fc00000  // 伪指令！我们以为它直接把 0x3fc00000 加载进 s0</span><br></pre></td></tr></table></figure><p>编译器不能直接把任意 32 位值硬编码进指令中（因为一条 ARM 指令本身就只有 32 位）。</p><p>所以它实际上是：</p><ol><li>将字面量值 0x3fc00000 写到内存的某个地方（通常靠近当前函数底部）。</li><li>生成一条 ldr 指令，用 PC-relative load 的方式从这个地址加载该值。<br>这块被称为一个 literal pool，它是一些常量的集合。</li></ol><p>We expected line 6 to read:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr        s0, =0x3fc00000</span><br></pre></td></tr></table></figure><br>Instead we find:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b+ 0x784 &lt;main+4&gt;          ldr     s0, 0x7a0 &lt;main+32&gt;</span><br></pre></td></tr></table></figure><br>Scan downward to find 0x7a0:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7a0 &lt;main+32&gt;         .inst   0x3fc00000 ; undefined  </span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th>伪指令</th><th>实际效果</th><th>GDB中看到的实际汇编</th></tr></thead><tbody><tr><td><code>ldr s0, =0x3fc00000</code></td><td>把常量加载进 <code>s0</code> 寄存器</td><td><code>ldr s0, #literal_addr</code><br><code>literal_addr: .inst 0x3fc00000</code></td></tr><tr><td><code>ldr x0, =fmt</code></td><td>加载字符串指针地址</td><td><code>ldr x0, #literal_addr</code><br><code>literal_addr: .inst 地址值</code></td></tr><tr><td><code>.inst 0x3fc00000</code></td><td>手动插入一个 32 位数据（不一定是有效指令）</td><td>存放常量（不是执行）</td></tr></tbody></table></div><p>.inst 的含义<br>全称：.inst = insert instruction<br>用途：直接插入一条 ARM 指令的机器码（通常是 32 位十六进制值）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.inst 0xd65f03c0   // 实际是 ret 指令</span><br></pre></td></tr></table></figure><p>这个例子中，.inst 后的机器码 0xd65f03c0 是 ret 指令的 32 位编码。也就是说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br></pre></td></tr></table></figure><p>等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.inst 0xd65f03c0</span><br></pre></td></tr></table></figure><br>在上面的例子中，可以用.inst定义一个地址，从该地址中加载</p><p>为什么不用 mov reg, #imm ？</p><ul><li>mov 有立即数编码限制，不能加载任意 32 位值。</li><li>超过范围时，必须用 ldr 从内存加载。<h3 id="fmov"><a href="#fmov" class="headerlink" title="fmov"></a>fmov</h3><blockquote><p>The fmov instruction is used to move floating point values in and out of floating point registers and to some degree, moving data between integer and floating point registers.</p></blockquote></li></ul><p><strong>loading floating point numbers as immediate values</strong></p><p>Just as we saw with integer registers, some values can be used as immediate values and some cannot. It comes down to how many bits are necessary to encode the value. Too many bits… not enough room to fit in a 4 byte instruction plus the opcode.</p><p>For example, this works:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    x0, 65535</span><br></pre></td></tr></table></figure><br>but this does not:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov    x0, 65537</span><br></pre></td></tr></table></figure></p><p>The constraints placed on immediate values for fmov are much tighter because floating point numbers are far more complex than integers.</p><p>fmov d0, #imm 能否工作，取决于该浮点数是否能在8位编码空间内被精确表示：</p><div class="table-container"><table><thead><tr><th>结构</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>符号位</td><td>1 bit</td><td>表示正或负</td></tr><tr><td>指数部分</td><td>3 bits</td><td>控制大小（乘以 2 的幂）</td></tr><tr><td>尾数部分</td><td>4 bits</td><td>仅能由 1/2、1/4、1/8、1/16 组合构成</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmov d0, 1.0        // ✅ OK：整数 1 是 2⁰，指数可编码</span><br><span class="line">fmov d0, 1.5        // ✅ OK：1 + 0.5 = 2⁰ + 2⁻¹，指数/尾数都能编码</span><br><span class="line">fmov d0, 1.75       // ✅ OK：1 + 0.5 + 0.25 = 2⁰ + 2⁻¹ + 2⁻²</span><br><span class="line">fmov d0, 1.875      // ✅ OK：+ 2⁻³</span><br><span class="line">fmov d0, 1.9375     // ✅ OK：+ 2⁻⁴</span><br><span class="line">fmov d0, 1.96875    // ❌ 不行：需要 2⁻⁵，尾数超出 4 位</span><br></pre></td></tr></table></figure><p>大浮点不能用 fmov，改用 ldr。</p><p>fmov 是“位复制器”，不是“精度转换器”。你要改数值精度，就必须用 fcvt 系列。</p><h3 id="half-precision"><a href="#half-precision" class="headerlink" title="half precision"></a>half precision</h3><blockquote><p>Support for half precision (16 bit) floating point values does exist but there is no complete agreement on how different compilers support them. Indeed, there are not one but two competing half precision formats out there. These are the IEEE and GOOGLE types. Further still, many open source developers have created their own implementations with potentially clashing naming conventions.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__fp16 <span class="title function_">Foo</span><span class="params">(__fp16 g, __fp16 f)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> g + f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compiles to:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fcvt    s1, h1</span><br><span class="line">fcvt    s0, h0</span><br><span class="line">fadd    s0, s0, s1</span><br><span class="line">fcvt    h0, s0</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>Notice each half precision value is converted to single precision. So, from C and C++ working with half precision values can be inefficient.</p><p>On the other hand, if you are willing to use intrinsics and one of the SIMD instruction sets offered by ARM, then knock yourself out. Be aware that doing so ties your code to the ARM processor in ways which you might regret later.</p><h3 id="bit-manipulation-1"><a href="#bit-manipulation-1" class="headerlink" title="bit manipulation"></a>bit manipulation</h3><p>Bit fields are a feature of the C and C++ language which completely hide what is often called “bit bashing”.</p><blockquote><p>the ordering of bits in a bit field is not guaranteed to be the same on different platforms and even between different compilers on the same platform.</p></blockquote><p>位域是一种用来在结构体内 精确控制成员所占二进制位数 的语法，通常用于硬件寄存器、协议头等空间敏感的场景。<br>语法格式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    类型 成员名 : 位宽;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>example:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b : <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li>a 用 1 位，能表示 0 或 1</li><li>b 用 2 位，能表示 0 ~ 3</li><li>c 用 5 位，能表示 0 ~ 31<br>三个成员总共占 1 + 2 + 5 = 8 位，即 1 字节</li></ul><ol><li>虽然每个成员是个位宽，但整体大小通常向整型对齐（这里是 1 字节，因为 8 位正好一字节）。</li><li>不同编译器对位域对齐和填充细节可能略有差异。</li><li>访问时可以像普通成员一样：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BF</span> <span class="title">bf</span>;</span></span><br><span class="line">bf.a = <span class="number">1</span>;</span><br><span class="line">bf.b = <span class="number">3</span>;</span><br><span class="line">bf.c = <span class="number">31</span>;</span><br></pre></td></tr></table></figure><p>编译器会自动对位域进行掩码和移位处理。</p><p>Consider a data structure for which there will be potentially millions of instances in RAM. Or, perhaps billions of instances on disc. Suppose you need 8 boolean members in every instance. The C++ standard does not define the size of a bool instead leaving it to be implementation dependent. Some implementations equate bool to int, four bytes in length. Some implement bool with a char, or 1 byte in length.</p><p>Let’s assume the smallest case and equate a bool with char. Our struct, for which there may be millions or billions of instances requires 8 bool so therefore 8 bytes. Times millions or billions.</p><p>Bit fields can come to your aid here by using a single bit per boolean value. In the best case, 8 bytes collapse to 1 byte. In a worse case, 8 x 4 = 32 bytes collapsed into 1.</p><p>假设使用最小单位，即每个 bool 是 1 字节：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> b0;</span><br><span class="line">    <span class="type">bool</span> b1;</span><br><span class="line">    <span class="type">bool</span> b2;</span><br><span class="line">    <span class="type">bool</span> b3;</span><br><span class="line">    <span class="type">bool</span> b4;</span><br><span class="line">    <span class="type">bool</span> b5;</span><br><span class="line">    <span class="type">bool</span> b6;</span><br><span class="line">    <span class="type">bool</span> b7;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体大小为 8 字节（1 字节 × 8 个 bool）。<br>如果有百万个实例，占用的内存就是 8MB，如果有十亿个实例，则是 8GB。<br>对于 4 字节的 bool 实现，则大小直接变成 32 字节，每亿实例就是 3.2GB。</p><p>解决方案：使用位域压缩布尔值<br>用位域，将 8 个布尔值定义为 1 位大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b0 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b1 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b2 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b3 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b4 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b5 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b6 : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> b7 : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>8 个 1-bit 成员 合起来正好占 1 字节。</p><p>这样 8 字节压缩成 1 字节，节省了大量空间。</p><p>In Computer Science there is an eternal tension between space and time. The following is a law:</p><p>If you want something to go faster, it will cost more memory.</p><p>If you want to save memory, what you’re doing will take more time.</p><p>This law shows up here… recall the example of where we wanted to save memory by collapsing 8 bool into 1 byte? To save that memory we will slow down because accessing the right bits takes a couple of instructions where overwriting a bool implemented as an int takes just one instruction.</p><p>As for the assembly language that bit field will produce, it depends upon optimization level. Unoptimized, the code produced will be much longer and cumbersome than the “sophisticated” assembly language.</p><h3 id="endian"><a href="#endian" class="headerlink" title="endian"></a>endian</h3><p>the ARM swing both ways: the litte-endian and the big-endian. But:</p><p>The standard toolchain emits little endian code. It is a big task to install the big-endian version of the toolchain.</p><p>Here is a quote from Wikipedia:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARM, C-Sky, <span class="keyword">and </span>RISC-V have no relevant <span class="keyword">big-endian </span>deployments, <span class="keyword">and </span>can <span class="keyword">be </span>considered little-endian in practice.</span><br></pre></td></tr></table></figure><br>The common Intel processors are also little-endian.</p><h2 id="assembly-macros"><a href="#assembly-macros" class="headerlink" title="assembly macros"></a>assembly macros</h2><p>An early innovation in assemblers was the introduction of a macro capability. Given what could be considered a certain amount of tedium in coding in asm, macros provide a simple form of meta programming where a series of statements can be encapsulated by a single macro. Think of a macro as an early form of C++ templated function (kinda but not really).</p><p>Here’s an example of an assembly language macro:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.macro LLD_ADDR xreg, label </span><br><span class="line">        adrp    \xreg, \label@PAGE</span><br><span class="line">        add     \xreg, \xreg, \label@PAGEOFF</span><br><span class="line">.endm</span><br><span class="line">```asm</span><br><span class="line">Here&#x27;s how it might be used:</span><br><span class="line">```asm</span><br><span class="line">        LLD_ADDR x0, fmt</span><br></pre></td></tr></table></figure><br>This gets expanded to:<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adrp    <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> fmt<span class="title">@PAGE</span></span><br><span class="line"><span class="keyword">add</span>     <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> <span class="keyword">x</span><span class="number">0</span><span class="punctuation">,</span> fmt<span class="title">@PAGEOFF</span></span><br></pre></td></tr></table></figure></p><p>gcc on Linux does not run assembly language files through the C pre-processor if the asm file ends in .s but WILL if the file ends in .S</p><h3 id="Genaral-Use"><a href="#Genaral-Use" class="headerlink" title="Genaral Use"></a>Genaral Use</h3><h4 id="AASCIZ"><a href="#AASCIZ" class="headerlink" title="AASCIZ"></a>AASCIZ</h4><p>AASCIZ    label, string</p><p>This macro invokes .asciz with the string set to string and the label set to label. In addition, this macro ensures that the string begins on a 4-byte-aligned boundary.</p><h4 id="PUSH-P-PUSH-R-POP-P-and-POP-R"><a href="#PUSH-P-PUSH-R-POP-P-and-POP-R" class="headerlink" title="PUSH_P, PUSH_R, POP_P and POP_R"></a>PUSH_P, PUSH_R, POP_P and POP_R</h4><p>These macros save some repetitive typing. For example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUSH_P  x29, x30</span><br></pre></td></tr></table></figure><br>resolves to:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stp     x29, x30, [sp, -16]!</span><br></pre></td></tr></table></figure></p><h4 id="START-PROC-and-END-PROC"><a href="#START-PROC-and-END-PROC" class="headerlink" title="START_PROC and END_PROC"></a>START_PROC and END_PROC</h4><p>Place START_PROC after the label introducing a function.</p><p>Place END_PROC after the last ret of the function.</p><p>These resolve to: .cfi_startproc and .cfi_endproc respectively.</p><h4 id="MIN-and-MAX"><a href="#MIN-and-MAX" class="headerlink" title="MIN and MAX"></a>MIN and MAX</h4><p>Handy more readable macros for determining minima and maxima. Note that the macro performs a cmp which subtracts src_b from src_a (discarding the results) in order to set the flags to be interpreted by the following csel.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIN     src_a, src_b, dest</span><br></pre></td></tr></table></figure><br>The smaller of src_a and src_b is put into dest.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX     src_a, src_b, dest</span><br></pre></td></tr></table></figure><br>The larger of src_a and src_b is put into dest.</p><h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p>MOD macro used above is defined as:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.macro  MOD         src_a, src_b, dest, scratch</span><br><span class="line">        sdiv        \scratch, \src_a, \src_b</span><br><span class="line">        msub        \dest, \scratch, \src_b, \src_a</span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></p><h4 id="GLABEL"><a href="#GLABEL" class="headerlink" title="GLABEL"></a>GLABEL</h4><p>Mark a label as global, Makes a label available externally.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLABEL label</span><br></pre></td></tr></table></figure><br>An underscore is prepended.</p><h4 id="CRT"><a href="#CRT" class="headerlink" title="CRT"></a>CRT</h4><p>Calling CRT(C runtime) functions<br>If you create your own function without an underscore, just call it as usual.<br>If you need to call a function such as those found in the C runtime library, use this macro in this way:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRT     strlen</span><br></pre></td></tr></table></figure><h4 id="MAIN"><a href="#MAIN" class="headerlink" title="MAIN"></a>MAIN</h4><p>Declaring main()<br>Put MAIN on a line by itself. Notice there is no colon.</p><h4 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h4><p>The externally defined errno is accessed via a CRT function which isn’t seen when coding in C and C++. The function is named differently on Mac versus Linux. To get the address of errno use:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERRNO_ADDR</span><br></pre></td></tr></table></figure><br>This macro makes the correct CRT call and leaves the address of errno in x0.</p><h3 id="Loads-and-Stores"><a href="#Loads-and-Stores" class="headerlink" title="Loads and Stores"></a>Loads and Stores</h3><h4 id="GLD-PTR"><a href="#GLD-PTR" class="headerlink" title="GLD_PTR"></a>GLD_PTR</h4><p>Loads the address of a label and then dereferences it where, on Apple the label is in the global space and on Linux is a relatively close label.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLD_PTR     xreg, label</span><br></pre></td></tr></table></figure><br>When this macro finishes, the specified x register contains what 64 bit value lives at the specified label.</p><h4 id="GLD-ADDR"><a href="#GLD-ADDR" class="headerlink" title="GLD_ADDR"></a>GLD_ADDR</h4><p>Loads the address of the label into the specified x register. No dereferencing takes place. On Apple machines, the label will be found in the global space.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLD_ADDR    xreg, label</span><br></pre></td></tr></table></figure><br>When this macro completes, the address of the label is in the x register.</p><h4 id="LLD-ADDR"><a href="#LLD-ADDR" class="headerlink" title="LLD_ADDR"></a>LLD_ADDR</h4><p>Similar to GLD_ADDR this macro loads the address of a “local” label.</p><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_ADDR xreg, label</span><br></pre></td></tr></table></figure><br>When this macro completes, the address of the label is in the x register.</p><h4 id="LLD-DBL"><a href="#LLD-DBL" class="headerlink" title="LLD_DBL"></a>LLD_DBL</h4><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_DBL xreg, dreg, label</span><br></pre></td></tr></table></figure><br>When this macro completes, a double that lives at the specified local label will sit in the specified double register.</p><h4 id="LLD-FLT"><a href="#LLD-FLT" class="headerlink" title="LLD_FLT"></a>LLD_FLT</h4><p>Signature:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLD_FLT xreg, sreg, label</span><br></pre></td></tr></table></figure><br>When this macro completes, a float that lives at the specified local label will sit in the specified single precision register.</p><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><h3 id="Undoing-Stack-Pointer-Changes"><a href="#Undoing-Stack-Pointer-Changes" class="headerlink" title="Undoing Stack Pointer Changes"></a>Undoing Stack Pointer Changes</h3><p>A small tip concerning undoing changes to the stack pointer. You might think that changes to the stack made by str or stp and their cousins must be undone with ldr or ldp and their cousins.</p><p>This depends.</p><p>If you need to get back the original contents of a register pushed onto the stack, then an ldr or ldp is appropriate. However, if you don’t need to get the original contents of a register back, then it is faster to undo a change to the stack using addition.</p><p>Take for example the use of printf(). On Apple Silicon systems, you must send arguments to printf() by pushing them onto the stack. However, when printf() completes, you have no need for the values that you pushed. As shown above, simply add the right (multiple of 16) to the stack pointer. This is faster as the addition makes no reference to RAM (or caches) as the ldr would.</p><h3 id="other-stuff"><a href="#other-stuff" class="headerlink" title="other stuff"></a>other stuff</h3><h4 id="let-the-assembler-itself-calculate-the-length-for-you"><a href="#let-the-assembler-itself-calculate-the-length-for-you" class="headerlink" title="let the assembler itself calculate the length for you"></a>let the assembler itself calculate the length for you</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">        .global        main                                             </span><br><span class="line">        .align         2                                                </span><br><span class="line">        .text                                                           </span><br><span class="line">                                                                        </span><br><span class="line">main:   str            x30, [sp, -16]!                                  </span><br><span class="line">        mov            w0, 1             // stdout                      </span><br><span class="line">        ldr            x1, =s            // pointer to string           </span><br><span class="line">        ldr            x2, =ssize        // pointer to computed length  </span><br><span class="line">        ldr            w2, [x2]          // actual length of string     </span><br><span class="line">        bl             write                                            </span><br><span class="line">                                                                        </span><br><span class="line">        ldr            x0, =fmt                                         </span><br><span class="line">        ldr            x1, =s                                           </span><br><span class="line">        ldr            x2, =ssize                                       </span><br><span class="line">        ldr            w2, [x2]                                         </span><br><span class="line">        bl             printf                                           </span><br><span class="line">                                                                        </span><br><span class="line">        ldr            x30, [sp], 16                                    </span><br><span class="line">        mov            w0, wzr                                          </span><br><span class="line">        ret                                                             </span><br><span class="line">                                                                        </span><br><span class="line">        .data                                                           </span><br><span class="line">                                                                        </span><br><span class="line">s:      .asciz         &quot;Hello, World!\n&quot;                                </span><br><span class="line">ssize:  .word          ssize - s - 1        // accounts for null at end </span><br><span class="line">fmt:    .asciz         &quot;str: %slen: %d\n&quot;   // accounts for newline     </span><br><span class="line">                                                                        </span><br><span class="line">        .end                                                            </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="atomic-operations"><a href="#atomic-operations" class="headerlink" title="atomic operations"></a>atomic operations</h2><h3 id="Load-Linked-Store-Condition"><a href="#Load-Linked-Store-Condition" class="headerlink" title="Load Linked, Store Condition"></a>Load Linked, Store Condition</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        .text                                                 </span><br><span class="line">        .p2align    2                                         </span><br><span class="line">                                                              </span><br><span class="line">#if defined(__APPLE__)                                        </span><br><span class="line">        .global     _LoadLinkedStoreConditional               </span><br><span class="line">_LoadLinkedStoreConditional:                                  </span><br><span class="line">#else                                                         </span><br><span class="line">        .global     LoadLinkedStoreConditional                </span><br><span class="line">LoadLinkedStoreConditional:                                   </span><br><span class="line">#endif                                                        </span><br><span class="line">1:      ldaxr       w1, [x0]                                  </span><br><span class="line">        add         w1, w1, 1                                 </span><br><span class="line">        stlxr       w2, w1, [x0]                              </span><br><span class="line">        cbnz        w2, 1b                                    </span><br><span class="line">        ret                                                   </span><br></pre></td></tr></table></figure><p>LL/SC 是一种乐观并发控制机制。它大致逻辑是：</p><ul><li><p>Load-Linked（LDAXR）：加载一个地址的值，并“观察”该地址是否被改动。<br>你可以修改这个值（如加1）。</p></li><li><p>Store-Conditional（STLXR）：尝试写回这个新值，如果在这之间地址内容没有被别人改过，则写入成功；否则失败。<br>成功与否会通过 STLXR 的返回值告诉你（0 表示成功，非 0 表示失败）。</p></li></ul><p><img src="https://raw.githubusercontent.com/even629/myPicGo/main/llsc.png" alt="llsc"></p><p>Implementations of operations on atomic variables were improved in the second version of ARMv8, called ARMv8.1. The load linked and store conditional instructions are still available but several new instructions were added which perform certain operations such as addition, subtraction and various bitwise operations in a single atomic instruction.</p><p>For example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    mov       w1, 1</span><br><span class="line">    ldaddal   w1, w0, [x0]</span><br><span class="line">``</span><br><span class="line">does the same work of atomically adding one to the value in memory pointed to by x0.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### spin-lock</span><br><span class="line"></span><br><span class="line">Here is the source code to the spin-lock for ARM V8.</span><br><span class="line"></span><br><span class="line">Lock</span><br><span class="line"></span><br><span class="line">```asm</span><br><span class="line">Lock:                                                              </span><br><span class="line">        START_PROC                                                 </span><br><span class="line">        mov         w3, 1           // 准备存储的值：1 表示“加锁”  </span><br><span class="line">1:      ldaxr       w1, [x0]        // 原子加载并标记 exclusive 访问                      </span><br><span class="line">        cbnz        w1, 1b          // 如果锁不为 0（被别人持有），继续自旋           </span><br><span class="line">        stlxr       w2, w3, [x0]    // 尝试原子写入，成功则 w2=0                  </span><br><span class="line">        cbnz        w2, 1b          // 如果失败（有竞争），继续自旋</span><br><span class="line">        ret                                                        </span><br><span class="line">        END_PROC                                                   </span><br></pre></td></tr></table></figure><br>stlxr: 如果 exclusive tag 还有效（没人抢走锁），那么将 w3 的值写入 *x0，并将结果放入 w2（0 表示成功）</p><ol><li>ldaxr dereferencing the lock itself (once again an int32_t) and marks the location of the lock as being hopefully, exclusive.</li><li>Having gotten the value of the lock, its value is inspected and if found to be non-zero, we branch back to attempting to get it again - this is the spin.</li><li>If the contents of the lock is 0, its value in w1 is changed to non-zero. Note, this could be made a bit better if a value of 1 was stored in another w register and simply used directly on line 10.</li><li><code>stlxr w2, w3, [x0]</code> conditionally stores the changed value back to the location of the lock. If the stlxr returns 0, we got the lock. If not, we start over - somebody else got in there ahead of us. Perhaps this happened because we were descheduled. Perhaps we lost the lock to another thread running on a different core.</li></ol><p>unlock<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unlock:                                                           </span><br><span class="line">        START_PROC                                                </span><br><span class="line">        str         wzr, [x0]       // 写 0 表示释放锁                            </span><br><span class="line">        dmb         ish             // 内存屏障，跨核同步                    </span><br><span class="line">        ret                                              </span><br><span class="line">        END_PROC                       </span><br></pre></td></tr></table></figure></p><ol><li><p>All it does is set to value of the lock to zero. The correct operation of the lock requires that no bad actor simply stomps on the lock by calling Unlock without first owning the lock. Just say no to lock stompers.</p></li><li><p><code>dmb ish</code> sets up a data memory barrier across each processor - it makes sure threads running on different cores see the update correctly. This code seemed to work without this line but intuition suggests it could be important. In Lock() the stlxr instruction has an implied data memory barrier.</p></li></ol><p>总结（伪代码角度）<br>🔒 Lock(x0):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    w1 = *x0;      <span class="comment">// atomic exclusive load</span></span><br><span class="line">    <span class="keyword">if</span> (w1 != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    result = atomic_store_exclusive(x0, <span class="number">1</span>);  <span class="comment">// try to set lock</span></span><br><span class="line">&#125; <span class="keyword">while</span> (result != <span class="number">0</span>);  <span class="comment">// someone else beat us</span></span><br></pre></td></tr></table></figure><br>🔓 Unlock(x0):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*x0 = <span class="number">0</span>;       <span class="comment">// unlock</span></span><br><span class="line">dmb(ISH);      <span class="comment">// ensure all cores see the update</span></span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/pkivolowitz/asm_book">asm_book</a></div>]]></content>
      
      
      <categories>
          
          <category> arm64 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SR-IOV原理与实现</title>
      <link href="/posts/42860/"/>
      <url>/posts/42860/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-05-22</p></div></div><div class='timeline-item-content'><ol><li>init</li></ol></div></div></div><hr><h1 id="I-O-虚拟化（IOV）"><a href="#I-O-虚拟化（IOV）" class="headerlink" title="I/O 虚拟化（IOV）"></a>I/O 虚拟化（IOV）</h1><p><strong>I/O 虚拟化（IOV）</strong> 是指多个虚拟机之间共享单一的 I/O 资源。实现 IOV 的方法包括：</p><ul><li><strong>纯软件实现</strong>的共享方式，</li><li><strong>硬件支持</strong>的共享方式，</li><li>以及 <strong>软硬结合的混合方式</strong>。</li></ul><h2 id="基于纯软件实现的共享"><a href="#基于纯软件实现的共享" class="headerlink" title="基于纯软件实现的共享"></a>基于纯软件实现的共享</h2><ol><li><strong>device emulation（完全虚拟化）</strong>：<br> 设备仿真模式会模仿那些被广泛支持的真实硬件设备（例如 Intel 的 1Gb 网卡），从而使虚拟机中的操作系统可以继续使用它原本就支持的驱动程序。虚拟机管理程序（VMM，Virtual Machine Monitor）会模拟这个 I/O 设备，以确保兼容性，并在实际 I/O 操作前处理这些操作，然后再把它们转发给实际的物理设备（这个物理设备可能和模拟的设备不一样）。<br> ⚠️ 问题：这样一来，I/O 操作就必须经过两层 I/O 栈——一层在虚拟机内部，另一层在虚拟机管理程序中，这会增加开销，降低性能。</li><li><strong>the split-driver model（半虚拟化）</strong>：<br> 这种方法和设备仿真类似，但它<strong>不再模拟一个传统设备</strong>。而是采用一种<strong>前后端驱动配合的方式</strong>：<ul><li>前端驱动运行在虚拟机的客户操作系统中；</li><li>后端驱动运行在虚拟机管理程序中。<br> 两者配合工作，专门为资源共享进行了优化。相比设备仿真，这种方法的优势在于：<strong>不需要模拟整个设备</strong>，从而性能更好、开销更小。后端驱动会直接与实际物理设备进行通信。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>device emulation</td><td>兼容性好，可使用现有驱动</td><td>性能较差，要经过两层 I/O 栈</td></tr><tr><td>the split-driver model</td><td>性能更好，优化了共享</td><td>需要专门为前后端编写驱动</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522224910146.png" alt="image-20250522224910146"></p><p><strong>基于软件的共享的缺点</strong></p><p>无论是<strong>设备仿真</strong>还是<strong>分离驱动（即半虚拟化驱动）</strong>，它们通常只能提供物理硬件功能的一部分，因此可能<strong>无法利用物理设备提供的高级功能</strong>。</p><p>此外，虚拟机管理程序（VMM）在实现一个虚拟的软件交换机（用于将数据包在多个虚拟机之间转发）时，可能会消耗<strong>大量的 CPU 资源</strong>。这种 CPU 开销会（而且通常确实会）<strong>降低 I/O 设备的最大吞吐量</strong>。</p><p>举个例子：如果只使用设备仿真方式，10Gbps 的以太网控制器<strong>最大只能达到 4.5 到 6.5Gbps 的吞吐量</strong>（这个范围依赖于具体测试服务器的架构）。<br>其中一个主要原因是：<strong>每个数据包都必须通过软件交换机</strong>，而这就需要使用 CPU 来处理这些数据包，造成性能瓶颈，无法达到线速（Line Rate）或接近线速的传输能力。</p><p>基于软件的 I/O 虚拟化方式虽然兼容性好，但也存在一些明显的<strong>性能瓶颈和功能限制</strong>，这些缺陷在对性能要求较高的场景（如高频交易、数据中心、网络功能虚拟化等）中尤其明显：</p><div class="table-container"><table><thead><tr><th>缺点</th><th>说明</th></tr></thead><tbody><tr><td>功能不完整</td><td>无法访问设备的全部高级特性，如硬件加速、QoS、SR-IOV等。</td></tr><tr><td>高 CPU 开销</td><td>每个 I/O 操作都需要 VMM 介入处理，特别是在网络场景下，包处理要通过软件交换机，会消耗大量 CPU。</td></tr><tr><td>吞吐量受限</td><td>理论 10Gbps 的网卡实际只有 4.5~6.5Gbps 的吞吐，远低于线速。</td></tr></tbody></table></div><h2 id="直接分配（Direct-Assignment）"><a href="#直接分配（Direct-Assignment）" class="headerlink" title="直接分配（Direct Assignment）"></a>直接分配（Direct Assignment）</h2><p>也称<strong>设备直通</strong></p><p>基于软件的共享方式在每次 I/O 操作中都增加了额外开销，因为在客户机驱动和 I/O 硬件之间存在一个<strong>仿真层</strong>。这种中间层的存在还带来了另一个影响：<strong>无法使用物理设备提供的硬件加速功能</strong>。<br> 为了解决这些问题，可以将物理硬件<strong>直接暴露给客户操作系统（Guest OS）</strong>，并让它运行<strong>原生设备驱动</strong>，从而减少中间层带来的性能损失。</p><p>硬件厂商（如Intel）为此引入了一些增强功能，用于<strong>支持内存地址转换</strong>并<strong>确保内存保护</strong>，使得设备能够<strong>直接进行主机内存的 DMA 操作</strong>。这些增强功能可以<strong>绕过虚拟机管理程序（VMM）的 I/O 仿真层</strong>，从而<strong>提升虚拟机的 I/O 吞吐性能</strong>。</p><p>Intel® VT-x 技术的一个特性是：如果由 VMM 进行配置，虚拟机可以<strong>直接访问物理地址</strong>。这样，虚拟机中的设备驱动就可以<strong>直接写入 I/O 设备的寄存器</strong>（例如配置 DMA 描述符等）。</p><p>而 Intel® VT-d 技术则提供了类似的能力，使 I/O 设备可以<strong>直接写入虚拟机的内存空间</strong>，例如进行 DMA 操作。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522230514903.png" alt="image-20250522230514903"></p><p>实现直接分配的机制<strong>在不同厂商之间有所差异</strong>，但其基本思路相同：虚拟机管理程序利用并配置诸如 Intel® VT-x 和 VT-d 这类技术，在数据收发过程中完成地址转换，确保数据可以安全、高效地在虚拟机与 I/O 设备之间传输。</p><p>✅ 优势：</p><ul><li><strong>绕过中间的仿真层</strong>，减少 CPU 开销；</li><li><strong>支持原生驱动</strong>，可以启用设备的全部功能（包括硬件加速）；</li><li><strong>大幅提升性能</strong>，尤其是吞吐量和延迟方面的改进明显；</li><li><strong>适合高性能场景</strong>，如网络功能虚拟化（NFV）、GPU 加速计算等。</li></ul><p>⚠️ 问题：</p><p>直接分配的一个主要问题是其<strong>可扩展性有限</strong>：一个物理设备<strong>只能分配给一个虚拟机</strong>。</p><blockquote><p>例如，一个双端口的网卡（NIC）只能同时提供给两个虚拟机使用（每个虚拟机占用一个端口）。然而，系统中可插入的 I/O 设备数量存在<strong>根本性的限制</strong>。</p></blockquote><p>设想一下不久将来的一个相对强大的服务器：<br> 它可能拥有 4 个物理 CPU，每个 CPU 有 12 个核心，总共有 48 个核心。按照“一核一虚拟机”的经验规则，这台服务器可能运行 <strong>48 个虚拟机</strong>。如果你希望为每个虚拟机都使用 Direct Assignment 的方式分配设备，就<strong>需要 48 个物理端口</strong>。</p><h1 id="单根-I-O-虚拟化（SR-IOV）"><a href="#单根-I-O-虚拟化（SR-IOV）" class="headerlink" title="单根 I/O 虚拟化（SR-IOV）"></a>单根 I/O 虚拟化（SR-IOV）</h1><blockquote><p>以上架构问题根源在于硬件底层原生不支持共享，需要一种新型的<strong>原生可共享设备</strong>（<strong>Navitely Shared Devices</strong>），这些设要能为每个虚拟机复制必要的资源，使得<strong>虚拟机可以直接连接到 I/O 设备</strong>，并且<strong>无需 VMM 参与</strong>即可完成主要的数据传输。</p></blockquote><p><strong>原生可共享设备</strong>通常会为每个虚拟接口提供<strong>独立的内存空间、工作队列、中断和命令处理机制</strong>，而在主机接口之后共享一些<strong>公共资源</strong>。这些共享资源仍然需要管理，通常会将一组管理寄存器暴露给 VMM 中的<strong>可信分区（Trusted Partition）</strong>，为每个虚拟机提供独立的工作队列和命令处理能力，这类设备能够<strong>同时接收多个来源的指令</strong>，并在发送给二级互连（如 Ethernet 或 SAS 链路）之前将其整合，而不再需要虚拟化软件将多个 I/O 请求串行化处理。</p><p>这种原生可共享设备可以通过多种方式实现，既有标准化的，也有专有的。由于大多数这类设备是通过 PCI 接口访问的，PCI-SIG（PCI Special Interest Group）决定制定一个标准机制来支持这一功能。</p><p>这个标准就是：<strong>PCI-SIG 单根 I/O 虚拟化和共享规范（SR-IOV，Single Root I/O Virtualization）</strong></p><p>SR-IOV 定义了一个标准机制，使设备能实现原生共享。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522231842281.png" alt="image-20250522231842281"></p><h2 id="PCI-SIG-SR-IOV-规范"><a href="#PCI-SIG-SR-IOV-规范" class="headerlink" title="PCI-SIG SR-IOV 规范"></a>PCI-SIG SR-IOV 规范</h2><p>PCI-SIG SR-IOV规范的目标可以总结为一句话：<strong>规范化一种绕过虚拟机管理程序（VMM）参与数据传输的方式</strong>，通过为每台虚拟机提供<strong>独立的内存空间、中断通道和 DMA 通道</strong>，以实现高效的 I/O 虚拟化。</p><p>SR-IOV 的体系结构设计允许一个设备支持多个<strong>虚拟功能（VF, Virtual Functions）</strong>，并在此过程中重点关注每个额外功能的硬件成本最小化。</p><p>SR-IOV 引入了两种新的 PCIe 功能类型：</p><ul><li><p><strong>物理功能（PF, Physical Functions）</strong>：<br> 完整的 PCIe 功能，包含 <strong>SR-IOV 扩展能力（Extended Capability）</strong>。该能力用于配置和管理 SR-IOV 的相关功能。</p></li><li><p><strong>虚拟功能（VF, Virtual Functions）</strong>：<br> 轻量级 PCIe 功能，包含完成数据传输所需的资源，但其<strong>配置资源经过精简设计</strong>，以降低硬件开销。</p></li></ul><p><strong>SR-IOV</strong> 提供了一种机制，使得一个单一的物理功能（例如一个以太网端口）<strong>可以表现为多个独立的“物理设备”</strong>。</p><p>一个支持 SR-IOV 的设备可以被配置（通常由 VMM 完成），使其在 <strong>PCI 配置空间</strong> 中<strong>呈现为多个功能（Function）</strong>，每个功能都拥有独立的 <strong>配置空间</strong>，包括自己的 <strong>基地址寄存器（BARs）</strong>。SR-IOV 设备可以配置为支持<strong>多个独立的虚拟功能（VF）</strong>，每个 VF 都有独立的 PCI 配置空间。VMM 会将这些 VF 分配给不同的虚拟机。</p><p>虚拟机管理程序（VMM）会将一个或多个虚拟功能（VF）分配给某个虚拟机，这个过程涉及将 VF 的真实配置空间<strong>映射为该 VM 所能看到的 PCI 配置空间</strong>。同时，诸如 Intel® VT-x 和 VT-d 之类的<strong>内存地址转换技术</strong>提供了<strong>硬件加速机制</strong>，可以使 DMA 数据直接在 VM 和设备之间传输，从而<strong>绕过 VMM 中的软件交换开销</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522233027661.png" alt="image-20250522233027661"></p><h2 id="生态系统依赖"><a href="#生态系统依赖" class="headerlink" title="生态系统依赖"></a>生态系统依赖</h2><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><ul><li>BIOS 在系统启动时负责分配 <strong>内存映射I/O（MMIO）空间</strong> 和 <strong>PCI Express总线号（Bus Numbers）</strong> 给主机桥（host bridges）。</li><li>许多系统中 PCI 资源分配缺乏标准化，软件依赖 BIOS 配置设备，确保有足够的内存空间和总线范围，支持主机桥下面的所有 I/O 设备。</li><li>需要增强 BIOS 的枚举代码，使其能识别 <strong>SR-IOV设备</strong>，并分配足够的 MMIO 空间给所有虚拟功能（Virtual Functions，VFs）。</li><li>具体如何解析 PCI 配置空间并计算 VF 所需最大 MMIO 空间，详见 PCI-SIG SR-IOV 规范。</li></ul><h3 id="虚拟机监控器（VMM）"><a href="#虚拟机监控器（VMM）" class="headerlink" title="虚拟机监控器（VMM）"></a>虚拟机监控器（VMM）</h3><ul><li>SR-IOV 定义了两种函数类型：<ul><li><strong>PF</strong>：完整的 PCIe 功能，包含 SR-IOV 扩展能力，用于管理和配置虚拟功能。</li><li><strong>VFs</strong>：轻量级的 PCIe 功能，包含仅用于数据传输的最小配置资源。</li></ul></li><li>SR-IOV 引入了一个新的软件实体：<strong>单根 PCI 配置管理器（Single Root PCI Configuration Manager, SR-PCIM 或 PCIM）</strong>。<ul><li>PCIM 负责管理和配置 VFs，处理所有对配置空间的访问请求。</li><li>它基于物理函数的信息，向虚拟机中的客户操作系统呈现完整的 PCI 配置模型。</li><li>PCIM 是一个概念模型，具体实现由各 VMM 厂商负责集成。</li></ul></li><li>Linux 内核自 2.6.30 版本（2009 年 6 月）开始支持 SR-IOV，多个发行版均已集成。</li></ul><h4 id="虚拟功能（VF）创建"><a href="#虚拟功能（VF）创建" class="headerlink" title="虚拟功能（VF）创建"></a>虚拟功能（VF）创建</h4><ul><li>在设备上电后，VFs 默认不存在，也无法访问其配置空间。</li><li>VFs 必须通过物理函数上的 SR-IOV 功能配置和启用后才能访问。</li><li>物理函数的 PCI 配置空间内有 SR-IOV 能力结构，其中包含一个 <strong>系统页大小字段（System Page Size）</strong>，由 VMM 设定为平台支持的大小。</li><li>所有 VF 的内存空间被连续映射在由 VF 基址寄存器（VF Base Address Register）指定的内存范围内。</li><li>为确保内存空间隔离，VF 的内存资源必须对齐到系统提供的页保护边界。</li><li>ARI（替代路由 ID 解释）能力标志会影响最大 VF 数量的分布，VMM 应启用根端口和交换机上的 ARI，并在 SR-IOV 能力中设置 ARI 能力层级位。BIOS 可能已预先启用 ARI。</li></ul><h4 id="VF-发现"><a href="#VF-发现" class="headerlink" title="VF 发现"></a>VF 发现</h4><ul><li>设置 VF 启用字段后，VFs 被创建并响应配置事务。</li><li>旧有的枚举软件不会自动发现这些 VF。</li><li>SR-IOV 引入一种新机制：通过物理函数中的 <strong>First VF Offset</strong> 和 <strong>VF Stride</strong> 字段形成链表，软件可定位与该物理函数关联的所有 VF。</li><li>SR-IOV 设备可能要求软件分配多个 PCI 总线号以支持超过 256 个功能。</li></ul><h4 id="VF-驱动与物理函数驱动通信支持"><a href="#VF-驱动与物理函数驱动通信支持" class="headerlink" title="VF 驱动与物理函数驱动通信支持"></a>VF 驱动与物理函数驱动通信支持</h4><ul><li>VMM 可以支持创建共享内存页，促进虚拟机中的 VF 驱动与主驱动（Master Driver）之间的通信（详细内容在第 6 节）。</li></ul><h4 id="VF-分配给虚拟机"><a href="#VF-分配给虚拟机" class="headerlink" title="VF 分配给虚拟机"></a>VF 分配给虚拟机</h4><ul><li>VFs 创建配置后，可被分配给虚拟机，实现虚拟机与硬件设备的直接 I/O 交互。</li><li>SR-IOV 设计假定设备上的所有 VF 是相同的，PCI 配置中均呈现相同的功能。</li><li>但通过主驱动介入分配，硬件可以根据系统管理员需求，提供不同的功能特性或性能等级（例如，为某些 VF 提供 2Gbps 的以太网性能保证）。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>BIOS 需要支持 SR-IOV 设备的识别和资源分配，尤其是 MMIO 和总线号管理。</li><li>VMM 引入 PCIM 模型管理 VFs，负责配置访问透明化和虚拟化资源管理。</li><li>VF 需要显式创建和启用，且支持大规模虚拟化场景（成百上千 VF）。</li><li>SR-IOV 支持高性能、低延迟的 I/O 直通，同时具备灵活的资源分配和管理能力。</li></ul><h2 id="主驱动程序（MD-Master-Driver）"><a href="#主驱动程序（MD-Master-Driver）" class="headerlink" title="主驱动程序（MD, Master Driver）"></a>主驱动程序（MD, Master Driver）</h2><p>主驱动（Master Driver，简称 MD；也称为物理功能驱动 PFD 或 PF Driver）是一个专门的驱动程序，用于管理 SR-IOV 设备的全局功能，并负责配置共享资源。MD 是特定于虚拟机监控器（VMM）的，运行在比一般虚拟机驱动更高权限的环境中。它包含了传统驱动的全部功能，以便 VMM 访问 I/O 资源；同时它还能执行影响整个设备的操作。</p><p>MD 必须在一个持续存在的环境中运行，在任何虚拟机驱动加载之前加载，并在所有虚拟机驱动卸载之后才能卸载。所有会影响整个设备的操作只能被 MD 接收和处理。</p><p>为了实现这种控制能力，虚拟机中的 VF 驱动需要与 MD 通信。比如，以太网设备的链路状态变化或最大传输单元（MTU）改变，就需要这种通信机制。VF 驱动通过通信通道询问链路状态时，MD 可以返回任意状态。当物理设备的 MTU 发生改变时，MD 可通知所有 VF 驱动，以便网络栈作出相应调整。</p><h3 id="VF-Drivers"><a href="#VF-Drivers" class="headerlink" title="VF Drivers"></a>VF Drivers</h3><p>VF 是“轻量级”的 PCIe 功能，只包含执行数据传输所必需的资源，它并不是一个完整的 PCIe 设备，仅提供数据进出机制。</p><p>VF 驱动运行于虚拟机中，应为半虚拟化驱动（即意识到它在虚拟化环境中），只能执行其允许的操作。通常，VF 具备发送/接收数据和执行自身复位的能力。该复位操作仅影响该 VF，而不会影响整个物理设备。超出其权限范围的操作需通过与 MD 通信实现。</p><p>VF 驱动是一个专门化驱动，它“知道”自身只能执行特定的功能，如配置 DMA 描述符、设置 MAC 地址、VLAN 标签等。每个 VF 都有在 I/O 设备中分配的独立资源。以太网 VF 通常具备独立的发送/接收队列，绑定到对应的 BAR（基地址寄存器）及描述符。</p><h3 id="VF-驱动与主驱动的通信"><a href="#VF-驱动与主驱动的通信" class="headerlink" title="VF 驱动与主驱动的通信"></a>VF 驱动与主驱动的通信</h3><p>设备共享的关键在于 VF 驱动能够与 MD 通信，请求那些影响全局的操作。这个通信通道需要传递消息并能生成中断。</p><p>SR-IOV 并未定义这一通信机制，因此需由主驱动、物理功能驱动和 VMM 设计者共同构建。最简单的方式是使用 VF 专属的设备内邮箱（mailbox）和门铃（doorbell）机制（Intel SR-IOV 网络控制器支持该方式）。目前，各家 VMM 厂商正在实现各自的通信机制，尚未形成统一标准。</p><h3 id="workflow-示例"><a href="#workflow-示例" class="headerlink" title="workflow 示例"></a>workflow 示例</h3><p>以下是一个接收以太网数据包并通过 VF 转发到虚拟机的典型流程：</p><ol><li>数据包到达 Intel® 网卡。</li><li>包被送入由主驱动配置的二层分类器（Layer 2 sorter）。</li><li>分类后，数据包进入目标 VF 的接收队列。</li><li>启动 DMA 操作，其目标地址由 VF 驱动配置的描述符决定。</li><li>DMA 到达芯片组。VMM 配置的 Intel® VT-d 将虚拟地址映射为主机物理地址，完成 DMA。</li><li>NIC 发出中断，VMM 捕获。</li><li>VMM 发出虚拟中断通知 VM 数据到达</li></ol><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250522234850850.png" alt="image-20250522234850850"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><p>平台必须支持地址转换（如 Intel® VT-d），才能使设备将数据 DMA 直接写入 VM 的内存。</p></li><li><p>BIOS 和 VMM 需能解析 PCI 配置空间，尤其是 SR-IOV 的 VF 定位机制。</p></li><li><p>VMM、PF 驱动、VF 驱动三者必须配合，为 VM 提供完整的 PCI 空间映射和 VF 操作能力。</p></li></ul><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><h3 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h3><h4 id="PCI（Perpheral-Component-Interconnect）"><a href="#PCI（Perpheral-Component-Interconnect）" class="headerlink" title="PCI（Perpheral Component Interconnect）"></a>PCI（Perpheral Component Interconnect）</h4><p>PCI曾经是个人电脑中使用最为广泛的接口，几乎所有的主板产品上都带有这种插槽。目前该总线已经逐渐被PCI Express总线所取代。PCI总线是由ISA(Industy Standard Architecture)总线发展而来的，是一种同步的独立于处理器的32位或64位局部总线。从结构上看，PCI是在CPU的供应商和原来的系统总线之间插入的一级总线，具体由一个桥接电路实现对这一层的管理，并实现上下之间的接口以协调数据的传送。</p><p><strong>注：</strong>ISA并行总线有8位和16位两种模式，时钟频率为8MHz，工作频率为33MHz/66MHz。</p><p>PCI总线是一种树型结构，并且独立于CPU总线，可以和CPU总线并行操作。PCI总线上可以挂接PCI设备和PCI桥，PCI总线上只允许有一个PCI主设备（同一时刻），其他的均为PCI 从设备，而且读写操作只能在主从设备之间进行，从设备之间的数据交换需要通过主设备中转。</p><p><strong>注：</strong>这并不意味着所有的读写操作都需要通过北桥中转，因为PCI总线上的主设备和从设备属性是可以变化的。比如Ethernet和SCSI需要传输数据，可以通过一种叫做Peer-to-Peer的方式来完成，此时Ethernet或者SCSI则作为主机，其它的设备则为从机。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655222482740534418391.png" alt=""></p><p>一个典型的33MHz的PCI总线系统如上图所示，处理器通过<strong>FSB</strong>（<strong>Front Side Bus</strong>，前端总线，是早期计算机体系结构中，<strong>处理器（CPU）与北桥芯片之间通信的主要总线</strong>，用于连接 CPU 和内存控制器、显卡、PCI 总线等系统核心组件）与北桥相连接，北桥上挂载着图形加速器（显卡）、SDRAM（内存）和PCI总线。PCI总线上挂载着南桥、以太网、SCSI总线（一种老式的小型机总线）和若干个PCI插槽。CD和硬盘则通过IDE连接至南桥，音频设备以及打印机、鼠标和键盘等也连接至南桥，此外南桥还提供若干的USB接口。</p><p>PCI总线是一种共享总线，所以需要特定的<strong>仲裁器</strong>（<strong>Arbiter</strong>）来决定当前时刻的总线的控制权。一般该仲裁器位于北桥中，而仲裁器（主机）则通过一对引脚，<strong>REQ#</strong>（<strong>request</strong>） 和<strong>GNT#</strong> （<strong>grant</strong>）来与各个从机连接。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655215521250613180895.png" alt="image.png"></p><p>需要注意的是，并不是所有的设备都有能力成为仲裁器（Arbiter）或者initiator 。</p><p>最初的PCI总线的时钟频率为33MHz，但是随着版本的更新，时钟频率也逐渐的提高。但是由于PCI采用的是一种<strong>Reflected-Wave Signaling</strong>信号模型，导致了时钟频率越高，总线的最大负载越少。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/1000019445-6365655345775545777449405.png" alt="1000019445-6365655345775545777449405"></p><h3 id="Alternative-Routing-ID"><a href="#Alternative-Routing-ID" class="headerlink" title="Alternative Routing-ID"></a>Alternative Routing-ID</h3><h3 id="Address-Translation-Services（ATS）"><a href="#Address-Translation-Services（ATS）" class="headerlink" title="Address Translation Services（ATS）"></a>Address Translation Services（ATS）</h3><h4 id="Intel®-Virtualization-Technology-for-Directed-I-O-Intel®-VT-d"><a href="#Intel®-Virtualization-Technology-for-Directed-I-O-Intel®-VT-d" class="headerlink" title="Intel® Virtualization Technology for Directed I/O (Intel® VT-d)"></a>Intel® Virtualization Technology for Directed I/O (Intel® VT-d)</h4><h3 id="Access-Control-Services-ACS"><a href="#Access-Control-Services-ACS" class="headerlink" title="Access Control Services (ACS)"></a>Access Control Services (ACS)</h3>]]></content>
      
      
      <categories>
          
          <category> virtualization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RustDesk远程桌面自建服务器</title>
      <link href="/posts/42858/"/>
      <url>/posts/42858/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-14</p></div></div><div class='timeline-item-content'><ol><li>init</li></ol></div></div></div><hr><p>ToDesk使用了几天后因为一直没关机，在当月中旬用完了所有额度，不让继续免费使用了，直接卸载告别切换到rustdesk，使用Self-host，免费而且帧率，分辨率都比ToDesk免费版高多了，下面是搭建的记录。</p><h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><p>我是使用两台windows(win10)和一台Ubuntu(配置如下图)，通过Ubuntu作为ID/中继服务器，让一台Windows连接到另一台Windows，Ubuntu需要安装Docker，两台windows需要安装rustdesk并进行一些配置。<br><div class="tip warning faa-horizontal animated"><p>注意：我的三台机器是在同一局域网下的。</p></div></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/pc_environment.png" alt="硬件环境"></p><h2 id="安装-Docker-和-docker-compose-plugin"><a href="#安装-Docker-和-docker-compose-plugin" class="headerlink" title="安装 Docker 和 docker-compose-plugin"></a>安装 Docker 和 docker-compose-plugin</h2><p>参考：<br>   <div class="tag link"><a class="link-card" title="Docker在Ubuntu安装" href="https://docs.docker.com/engine/install/ubuntu/"><div class="left"><img src="https://docs.docker.com/favicons/docs@2x.ico"/></div><div class="right"><p class="text">Docker在Ubuntu安装</p><p class="url">https://docs.docker.com/engine/install/ubuntu/</p></div></a></div><br>安装完成后，可以把当前用户加入到docker用户组<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加docker用户组，一般已存在，不需要执行</span></span><br><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="comment"># 添加当前用户到docker用户组</span></span><br><span class="line"><span class="built_in">sudo</span> gpasswd -a <span class="variable">$USER</span> docker</span><br><span class="line"><span class="comment"># 更新用户组</span></span><br><span class="line">newgrp docker</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure></p><h2 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="headerlink" title="docker-compose.yaml"></a>docker-compose.yaml</h2><p>参考官方文档：<br>   <div class="tag link"><a class="link-card" title="RustDesk自建服务器" href="https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/docker/"><div class="left"><img src="https://rustdesk.com/docs/images/favicon.png"/></div><div class="right"><p class="text">RustDesk自建服务器</p><p class="url">https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/docker/</p></div></a></div></p><p>如果开启了ufw，需要打开这些端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw status</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 21114:21119/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 8000/tcp</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 21116/udp</span><br></pre></td></tr></table></figure><br>选一个目录用来存放ID/中继服务器数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/rustdesk</span><br><span class="line"><span class="built_in">cd</span> ~/rustdesk</span><br><span class="line"><span class="built_in">touch</span> docker-compose.yaml</span><br></pre></td></tr></table></figure><br>下面是docker-compose.yaml文件，是上面的rustdesk官方文档的：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hbbs:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">hbbr:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:latest</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><br>然后启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 进入~/rustdesk/data文件夹中</span></span><br><span class="line"><span class="built_in">cd</span> data</span><br><span class="line"><span class="comment"># 查看key</span></span><br><span class="line"><span class="built_in">cat</span> id_*.pub</span><br></pre></td></tr></table></figure></p><h2 id="rustdesk安装配置"><a href="#rustdesk安装配置" class="headerlink" title="rustdesk安装配置"></a>rustdesk安装配置</h2><p>安装访问以下链接：<br><div class="tag link"><a class="link-card" title="RustDesk安装" href="https://github.com/rustdesk/rustdesk/releases"><div class="left"><img src="https://github.githubassets.com/favicons/favicon.png"/></div><div class="right"><p class="text">RustDesk安装</p><p class="url">https://github.com/rustdesk/rustdesk/releases</p></div></a></div><br>安装好后，打开网络设置，将ID/中继服务器的IP也就是跑Docker的那个服务器IP地址填写到ID服务器和中继服务器中，被控端可以不填写中继服务器，控制端建议填写，然后控制端填写key（上面data文件下的.pub文件的内容）。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250314214834213.png" alt="windows rustdesk网络配置"></p><p>最后输入被控端的ID和密码连接即可。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP Data Lab</title>
      <link href="/posts/42856/"/>
      <url>/posts/42856/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-07</p></div></div><div class='timeline-item-content'><p>写到howManyBits</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-03-07</p></div></div><div class='timeline-item-content'><p>写完了，再一次感觉这个实验不错</p></div></div></div><hr><p>最近担任计算机系统助教要验收这个CSAPP的实验，这个实验本科的时候就做过，但过了这么久基本忘完了，遂重新做一遍记录于此。</p><h1 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h1><p>我是在win10 WSL2环境下做的：</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250304165220672.png" alt="实验环境"></p><p>具体如何搭建环境参考下面这个链接，有脚本一键搭建运行环境，非常方便：<br><div class="tag link"><a class="link-card" title="CSAPP环境搭建" href="https://zhuanlan.zhihu.com/p/505497911"><div class="left"><img src="https://static.zhihu.com/heifetz/favicon.ico"/></div><div class="right"><p class="text">CSAPP环境搭建</p><p class="url">https://zhuanlan.zhihu.com/p/505497911</p></div></a></div></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在bits.c中完成函数实现，但对代码有一定的限制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检测代码是否符合要求的规范</span></span><br><span class="line">./dlc bits.c</span><br><span class="line"><span class="comment"># 查看分数</span></span><br><span class="line">make clean </span><br><span class="line">make </span><br><span class="line">./btest</span><br></pre></td></tr></table></figure></p><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要求只用~(按位取反)和&amp;(按位与)实现异或，可以使用离散数学中的等值演算，异或即“相同为0，不同为1”：</p><script type="math/tex; mode=display">x \oplus y = \lnot (\lnot x \land \lnot y) \land \lnot ( x \land y)</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ( ~(~x &amp; ~y)) &amp; (~(x &amp; y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>返回最小的二进制补码整数，关于原码，反码，补码定义如下：</p><div class="table-container"><table><thead><tr><th>表示方法</th><th>定义</th></tr></thead><tbody><tr><td>原码</td><td>最高位为符号位（0 表示正数，1 表示负数），其余位表示数值的绝对值</td></tr><tr><td>反码</td><td>正数的反码与原码相同；负数的反码是符号位不变，其余位按位取反</td></tr><tr><td>补码</td><td>正数的补码与原码相同；负数的补码是其反码加 1</td></tr></tbody></table></div><p>补码的编码具有不对称性，除了最小的负数其他负数都其正数与之对应，在 64 位系统中，整数的补码表示范围是：</p><ul><li>最小负数：0x8000000000000000（即 -2^63）。</li><li>最大正数：0x7FFFFFFFFFFFFFFF（即 2^63 - 1）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果x是二进制补码最大值则返回1,否则返回0。</li><li>最大值是0x7FFFFFFF，它的特点是最高位为0其余为1，那么0x7FFFFFFF+0x1后变为0x800000000，最高位为1其余为0，其特点正好相反。</li><li>这里需要用到异或的特性，如x^target，x取反后与target异或，由于异或是不同为1相同为0，则只有当x与target完全相同时，x^target才会为0x0，那么加上!操作符就能得到!(x^target)即x与target相同时为1,不同时为0。<br>对于0x7FFFFFFF，它加1后为0x80000000，由于特点正好相反，取反后有变为0x7FFFFFFF,故可以利用异或判断是否相同即：!(~(x+1)^x) 。</li><li>继续思考，是不是只有0x7FFFFFFF才满足这样的特性：+1后相当于按位取反？显然0xFFFFFFFF也满足这个特性，这是因为溢出时最高位被丢弃变为0x0。所以我们还需要构造一个表达式与!(~(x+1)^x) 相与记为expression1，即!(~(x+1)^x) &amp; expression1。当x为0x7FFFFFFF时expression1为1，当x为0xFFFFFFFF时为0。</li><li>排除的方法必定需要利用0x7FFFFFFF有而0xFFFFFFFF没有的特点0，即这两个数的区别，而最简单的区别就是0x7FFFFFFF+0x1后变为0x8FFFFFFF是个非零数，而0xFFFFFFFF+0x1后变为0。故!(x+1)在x为0x7FFFFFFF时为0，在x为0xFFFFFFFF时为1，!(x+1)与需要的正好相反，再加上一个!运算即可，即：<p class='p center logo small'>!( ~(x + 1) ^ x) & !!(x + 1)</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !( ~(x + <span class="number">1</span>) ^ x) &amp; !!(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果所有奇数位的比特位是1返回1，否则返回0，即一个数只要其1,3,5,7…位为1（其余位不用管）返回1，否则返回0。</li><li>我们可以去除所有的偶数位的影响，看奇数位，比如让x与0xAAAAAAAA相与，则所有的偶数位都为0，再看其是否和0xAAAAAAAA相同（利用isTmax中阐述的通过按位与判断两个数是否相同）。也可以让x与0x55555555相或，则所有的偶数位为1，再看其是否和0xFFFFFFFF相同。即：<p class='p center logo small'>!((x|0x55555555)^0xFFFFFFFF)</p><p class='p center logo small'>!((x&0xAAAAAAAA)^(0xAAAAAAAA))</p></li><li>但是由于实验要求的限制条件，不只直接写0xAAAAAAAA这种，只能写0xAA，通过位运算得到0xAAAAAAAA</li></ul><div class="tip warning faa-horizontal animated"><p>注意：根据C规范移位运算优先级低于加减</p></div><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250307163658185.png" alt="https://en.cppreference.com/w/c/language/operator_precedence"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// return !((x|0x55555555)^0xFFFFFFFF);</span></span><br><span class="line">  <span class="comment">// return !((x&amp;0xAAAAAAAA)^(0xAAAAAAAA));</span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">0xAA</span>&lt;&lt;<span class="number">8</span>;<span class="comment">//0x00AA</span></span><br><span class="line">  <span class="type">int</span> b = a | <span class="number">0xAA</span>;<span class="comment">//0xAAAA</span></span><br><span class="line">  <span class="type">int</span> c = b&lt;&lt;<span class="number">16</span> | b;<span class="comment">//0xAAAAAAAA</span></span><br><span class="line">  <span class="keyword">return</span> !((x&amp;c)^c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>返回x的负数</li><li>我们知道：<p class='p center logo small'>x+(-x)=0</p><p class='p center logo small'>x+(~x)=-1</p></li><li>两式子相减得到：<p class='p center logo small'>-x=~x+1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2>题目：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>检测x是否属于ascii的数字，简单来说是判断x是否在0x30和0x39之间。</li><li>在汇编中判断大小是通过减法置标志位来完成的，因此我们可以通过让0x30和0x39分别减去x再取符号位，看是否满足：0x30-x应该小于0符号位为1，0x39-x&gt;0符号位为0，但是若是x落在边界时,如x==0x30，0x30-x为0符号位为0也是满足要求的，因此我们可以把&lt;=变为&lt;：<p class='p center logo small'>0x30<= x <= 0x39</p>上式等价于：<p class='p center logo small'>0x2F< x <= 0x39</p>那么右边x<0x39是否需要等价转换?0x39-x应该大于或等于0，符号位为0，0x39-x<0符号位为1，经分析边界条件是囊括的所以不需要等价转换（转换后会把边界条件排出）。让0x2F-x符号位为1，0x39-x符号位为0，必须同时满足这两个条件，首先先看0x2F< x，相减后如何提取符号位？可以通过算数右移，移动31位符号位占满整个32位，即若0x2F-x<0，则(0x2F+(~x+1))>&gt;31为0xFFFFFFFF，若0x2F-x&gt;=0,(0x2F+(~x+1))&gt;&gt;31为0;<p class='p center logo small'>(0x2F+(~x+1))>>31</p>再看x &lt;= 0x39，同样的方法，若0x39-x<0，则(0x39+(~x+1))>&gt;31为0xFFFFFFFF，若0x39-x&gt;=0,(0x39+(~x+1))&gt;&gt;31为0;我们取个反就可以满足<p class='p center logo small'>~((0x39+(~x+1))>>31)</p>需要同时满足上述两个条件，故<p class='p center logo small'>(0x2F + (~x + 1)) >> 31 & ~((0x39 + (~x + 1)) >> 31)</p>由于最后返回1或0，我们取最低位即可：<p class='p center logo small'>(0x2F + (~x + 1)) >> 31 & ~((0x39 + (~x + 1)) >> 31) & 0x1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> low = (<span class="number">0x2F</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>;  <span class="comment">// 0x2F - x &lt; 0 =&gt; x &gt; 0x2F (即 x &gt;= 0x30)</span></span><br><span class="line">  <span class="type">int</span> high = ~((<span class="number">0x39</span> + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>);  <span class="comment">// 0x39 - x &gt;= 0 =&gt; x &lt;= 0x39</span></span><br><span class="line">  <span class="keyword">return</span> low &amp; high &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>conditional的表达式和 x ? y : z 相同</li><li>要实现这种根据x的值判断返回y还是返回z，仅仅使用位运算非常难，因为虽然我们很容易判断x是否为0，但我们很难将x与yz同时关联起来，所以我们把希望留给加法运算，假设返回这样的式子：<p class='p center logo small'>a+y+z</p>当x!=0时，让a=-z=~z+1；当x==0时，让a=-y=~y+1就可以满足要求，但是这个要求同样难以满足，因为a既与y有关又与z有关，而a又由x是否为0来决定，因此我们考虑将a拆分：<p class='p center logo small'>b+c+y+z</p>当x为非0时，让b=0，c=-z=~z+1；当x为0时，让b=-y=~y+1，c=0。这样可以让b只与y有关，c只与z有关。<br>首先我们要判断x是否为0，这个不难，使用!运算即可，当x为非零则为0，当x为0则为1，我们首先关注b，!x==0时，b要为0，!x!=0时，b要为~z+1，显然与运算可以满足：<p class='p center logo small'>b = !x&(~y+1)</p>但是当!x!=0时，!x==1，而它与~z+1按位与只会留下最低位不一定是~z+1，因此我们需要让x!=0时得到0xFFFFFFFF，x==0时得到0，因此我们定义a：<p class='p center logo small'>a = ~(!x)+1</p>当x为0时,!x==1,~(!x)==0xFFFFFFFE,a==0xFFFFFFFF；当x为非零时，!x==0，~(!x)==0xFFFFFFFF，a==0，因此b的表达式应为<p class='p center logo small'>b = a&(~y+1)</p>再关注c，c的情况刚好与b相反，那么只需要给a再加一个~即可<p class='p center logo small'>c = ~a&(~z+1)</p>这里不用担心加法溢出问题</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = ~(!x)+<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = a&amp;(~y+<span class="number">1</span>);</span><br><span class="line">  <span class="type">int</span> c = ~a&amp;(~z+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> b+y+c+z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>如果x&lt;=y那么返回 1，否则返回0</li><li>比大小利用减法，让y-x如果y-x&gt;=0即符号位为0则返回1，如果y-x&lt;0即符号位为1则返回0，y-x=y+~x+1，然后右移31位后取符号位,我们需要一个取反操作以满足符号位为0返回1，符号位为1则返回0:<p class='p center logo small'>~((y+(~x+1))>>31) & 0x1</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ~((y+(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>) &amp;<span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>实现!运算符，即对于!x，当x为0时返回1，当x为非0时返回0</li><li>0和非零最直观的区别就在与0的每一位都是0，而非零至少有一位为1，但因为我们无法利用循环移位操作来判断，故只能另辟蹊径</li><li>0的和非零的另一个不同特点在于0的负数还是0，即~0+1=0，而非零数的负数不是0，我们可以利用这点，看x的负数是否与它自己相同，前面我们用到过一个技巧通过异或来判断两数是否相同：这个表达式在x等于0时返回0，x等于非零时返回非零，但是这样等于没做<p class='p center logo small'>(~x+1)^x</p>我们可以利用另一点，非零数的负数和原来这个数的符号位肯定相反，一个必是1，一个必是0，而0的负数的符号位和0的符号位都是0，因此我们只需要将两者相与就能得到：非零时该表达式符号位为1，为0时该表达式符号位0<p class='p center logo small'>(~x+1)|x</p>接下来就是提取符号位了，顺便取个反，因为我们要求为0时返回1，为1时返回0，这个技巧我们在上面的题目用到过：即将其向右算数移位31位并取反，然后与0x1相与取最低位：<p class='p center logo small'>~(((~x+1)|x)>>31) & 0x1</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123; </span><br><span class="line">   <span class="keyword">return</span> ~(((~x+<span class="number">1</span>)|x)&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>返回以二进制补码的形式表示x需要几个比特数，其实就是看这个数的最高位1在第几位，然后加上1位符号位，这个问题有点难度，主要是有点难想到，下面是别人的实现方法。</li><li>这里用到二分法：<br>先考虑正数和0</li></ul><ol><li>高 16 位：检查高 16 位是否有 1，如果有，则至少需要 16 位。</li><li>高 8 位：在剩下的 16 位中，检查高 8 位是否有 1。</li><li>高 4 位：在剩下的 8 位中，检查高 4 位是否有 1。</li><li>高 2 位：在剩下的 4 位中，检查高 2 位是否有 1。</li><li>高 1 位：在剩下的 2 位中，检查高 1 位是否有 1。</li><li>最低位：最后剩下的 1 位。<br>最终，将所有部分的位数相加，并加 1（符号位）。</li></ol><ul><li>对负数的处理：<br>flag 是 x &gt;&gt; 31，即符号位。如果 x 是负数，flag 为 1；否则为 0。</li></ul><ol><li>如果 x 是负数（flag == 1），则 x 被取反：x = ~x。</li><li>如果 x 是非负数（flag == 0），则 x 保持不变。<br>负数的补码表示中，符号位和数值部分是混合在一起的。如果直接计算负数的有效位数，符号位会导致结果错误。例如：<br>-1 的补码是 11111111 11111111 11111111 11111111，如果直接计算位数，会得到 32 位，但实际上我们只关心其有效位数。<br>通过取反操作，负数的补码表示会被转换为正数，其二进制表示中的有效位数与原来的负数相同。例如：</li></ol><ul><li>-1 的补码是 11111111 11111111 11111111 11111111，取反后为 00000000 00000000 00000000 00000000，有效位数为 1。</li><li>-2 的补码是 11111111 11111111 11111111 11111110，取反后为 00000000 00000000 00000000 00000001，有效位数为 2。</li></ul><div class="tag link"><a class="link-card" title="howManyBits" href="https://zhuanlan.zhihu.com/p/559005736"><div class="left"><img src="https://static.zhihu.com/heifetz/favicon.ico"/></div><div class="right"><p class="text">howManyBits</p><p class="url">https://zhuanlan.zhihu.com/p/559005736</p></div></a></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="type">int</span> b16, b8, b4, b2, b1, b0;</span><br><span class="line">  <span class="type">int</span> flag = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  x = (flag &amp; ~x) | (~flag &amp; x);  <span class="comment">// x符号位为0不变 ,x符号位为1按位取反</span></span><br><span class="line">  b16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>; </span><br><span class="line">  x &gt;&gt;= b16;  </span><br><span class="line">  b8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">  x &gt;&gt;= b8;</span><br><span class="line">  b4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">  x &gt;&gt;= b4;</span><br><span class="line">  b2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  x &gt;&gt;= b2;</span><br><span class="line">  b1 = !!(x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  x &gt;&gt;= b1;</span><br><span class="line">  b0 = x;</span><br><span class="line">  <span class="keyword">return</span> b0 + b1 + b2 + b4 + b8 + b16 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>将一个单精度浮点数（float）乘以 2，并返回结果的二进制表示。函数的输入和输出都是 unsigned int 类型，但它们实际上表示的是单精度浮点数的二进制位模式，当输入是NaN时返回这个输入即可，另外，终于可以用if while了😭😭😭</p></li><li><p>先回顾下<strong>IEEE 754</strong>浮点数的知识：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-53-54.png" alt="IEEE 754的表示形式"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-54-47.png" alt="单精度float 双精度double"></p><p>对于IEEE 754表示的浮点数，一共有三种类别<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-12.png" alt="类别1：规格化数"></p><p>非规格化数用于表示接近零的极小数值，防止浮点下溢（Underflow），保证浮点运算的连续性。<br><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-34.png" alt="类别2：非规格化数"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_15-55-43.png" alt="类别3：特殊值"></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/Snipaste_2025-03-11_16-38-57.png" alt="IEEE 754 表示范围"></p><p>首先我们先提取符号位sign，尾数frac，阶码exp：<br><p class='p center logo small'>sign=uf>>31&0x1</p><br><p class='p center logo small'>frac=uf&0x7FFFFF</p><br><p class='p center logo small'>exp = (uf&0x7f800000)>>23</p></p><p>根据阶码判断这个浮点数是规格化数，非规格化数还是特殊情况中的哪一种<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123; </span><br><span class="line">  <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> sign=uf&gt;&gt;<span class="number">31</span>&amp;<span class="number">0x1</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac=uf&amp;<span class="number">0x7FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">0</span>)&#123;<span class="comment">//非规格化数，阶码为0，直接让frac乘以2即可</span></span><br><span class="line">    frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">0xFF</span>)&#123;<span class="comment">//特殊情况，非数</span></span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">exp</span>++;<span class="comment">//乘2,相当于E+1,相当于</span></span><br><span class="line">    <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>用int表示输入的IEEE 754浮点数，如果超过表示范围则返回0x80000000u。</li><li>如果是非规格化数，直接返回0，如果是特殊情况直接返回0x80000000u</li><li>如果是规格化数，我们需要先判断是否超出int表示范围，int一共32位，一位表示符号位，最大表示2^31，最小表示-(2^31+1)，因此阶码E不能超过30（当E为31时左移E位会覆盖符号位）；当阶码E小于0时，说明是个小于1的数，直接返回0；又：</li><li>sign <strong>1位</strong></li><li>exp <strong>8位</strong></li><li>frac <strong>23位</strong></li></ul><script type="math/tex; mode=display">V = (-1)^{sign} \times 2^{exp - 127} \times (1 + frac)</script><p>我们可以可以看成<strong>1frac</strong>（第24位为1，第1~23位构成frac）而此时相当于由<strong>1.frac</strong>（整数部分位1，小数部分为frac）左移了23位，此时阶码为E，即要乘以E个2，也就是左移E位，所以，当E小于23时，应该右移（23-E）位以截断frac后面的(23-E)位；当E大于23时，由于此时相当于已经左移了23位，所以只需再左移(E-23)位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="built_in">exp</span> = (uf &amp; <span class="number">0x7f800000</span>) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">unsigned</span> sign = uf &gt;&gt; <span class="number">31</span> &amp; <span class="number">0x1</span>;</span><br><span class="line">  <span class="type">unsigned</span> frac = uf &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xFF</span>) &#123;  <span class="comment">// 特殊情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000u</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) &#123;  <span class="comment">// 非规格化数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                   <span class="comment">// 规格化数</span></span><br><span class="line">    <span class="type">int</span> E = <span class="built_in">exp</span> - <span class="number">127</span>;  <span class="comment">// 阶码，注意不要设置为unsigned</span></span><br><span class="line">    <span class="keyword">if</span> (E &gt;= <span class="number">31</span>) &#123;           <span class="comment">// 超范围</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x80000000u</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(E&lt;<span class="number">0</span>)&#123;<span class="comment">//如果E&lt;0说明是个比1小的数，返回0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    frac = frac | (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);  <span class="comment">// 填上frac的1</span></span><br><span class="line">    <span class="keyword">if</span> (E &lt; <span class="number">23</span>) &#123;</span><br><span class="line">      frac = frac &gt;&gt; (<span class="number">23</span> - E);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      frac = frac &lt;&lt; (E - <span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">0</span>) &#123;<span class="comment">//根据符号位返回正负</span></span><br><span class="line">      <span class="keyword">return</span> frac;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -frac;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h2><p>题目：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>计算2.0^x，并返回IEEE 754下的unsigned表示，如果结果太小，小到非规格化数都不能表示则返回0，如果结果太大返回+INF，很明显这题主要考察IEEE 754的表示范围。</li></ul><p>对于<strong>float单精度</strong></p><ul><li>符号位sign：1位</li><li>阶码exp: 8位</li><li>尾数frac：23位</li></ul><p><strong>表示范围</strong></p><ul><li><p>规格化数：阶码exp既不全为0，也不全为1，</p><script type="math/tex; mode=display">V = (-1)^S \times 2^E \times M = (-1)^{sign} \times 2^{exp - bias} \times (1 + frac)</script><p>exp范围为1~254,E=Exp-Bias=Exp-127，E的范围为-126&gt;=E&gt;=127;而对于frac，最小值为0，最大值为1-2^(-23),因此，不考虑S的情况下</p><script type="math/tex; mode=display">V_{max} =  (-1)^S \times 2^{127} \times (2-2^{-23}) = (-1)^S \times 2^{127} \times (2-2^{-23})</script><script type="math/tex; mode=display">V_{min} = (-1)^S \times 2^{-126} \times (1+0) = (-1)^S \times 2^{-126}</script></li><li><p>非规格化数：阶码全为0</p><script type="math/tex; mode=display">V = (-1)^S \times 2^E \times M = (-1)^{sign} \times 2^{1-Bias} \times (0 + frac)</script><p>阶码exp全为0,E=1-Bias=1-127=-126，因此：</p><script type="math/tex; mode=display">V = (-1)^{sign} \times 2^{- 126} \times (0 + frac)</script><p>对于frac来说，最小值为0，但能表示的最小非零是2^(-23),0~2^(-23)无法表示,最大值为1-2^(-23)，因此，当frac取0时，值为0，但要计算表示的最小非零时要令frac=2^(-23)，在不考虑S的情况下</p><script type="math/tex; mode=display">V_{max} =  (-1)^S \times 2^{-126} \times (0+1-2^{-23}) = (-1)^S \times 2^{-126} \times (1-2^{-23})</script><script type="math/tex; mode=display">V_{min} = (-1)^S \times 2^{-126} \times (0+2^{-23}) = (-1)^S \times 2^{-149}</script><ul><li>特殊值</li></ul></li></ul><ol><li>+infinity：exp所有位全为1，frac为0，S为0</li><li>-infinity：exp所有位全为1，frac为0，S为1</li><li>NaN：exp所有位全为1，frac不为0</li></ol><p>因此，经上述分析:</p><ul><li>当x&gt;127时返回+NaN</li><li>当-126&lt;=x&lt;=127时为规格化数</li><li>当 -149 &lt;= x &lt; -126时为非规格化数</li><li>当 x &lt; -149时，太小了无法表示返回0<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">127</span>) &#123;  <span class="comment">// 返回+infinity,S=0,exp=0xFF,frac=0;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-126</span> &lt;= x &amp;&amp; x &lt;= <span class="number">127</span>) &#123;  <span class="comment">// 规格化数,exp=E+Bias=E+127</span></span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-149</span> &lt;= x &amp;&amp; x &lt; <span class="number">-126</span>) &#123;  <span class="comment">// 非规格化数,exp=0,E=1-Bias=-126,2^(-126)*frac</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(<span class="number">23</span>-(-x<span class="number">-126</span>));<span class="comment">//E已经有了2^(-126),当frac为0x1时表示2^(-23),假设输入x为-127,则frac要为2^(-1),即1向左移动22位</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//x&lt; -149,太小了返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSAPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDK2获取Protocol总结</title>
      <link href="/posts/42855/"/>
      <url>/posts/42855/</url>
      
        <content type="html"><![CDATA[<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-02-25</p></div></div><div class='timeline-item-content'><ol><li>添加了OpenProtocol,HandleProtocol,LocateProtocol,OpenProtocolInfomation,CloseProtocol</li></ol></div></div></div><hr><p>UefiSpec.h 中定义了Protocol相关的接口:<br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_HANDLE_PROTOCOL HandleProtocol;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_REGISTER_PROTOCOL_NOTIFY RegisterProtocolNotify;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_HANDLE LocateHandle;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_DEVICE_PATH LocateDevicePath;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_OPEN_PROTOCOL OpenProtocol;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_CLOSE_PROTOCOL CloseProtocol;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_OPEN_PROTOCOL_INFORMATION OpenProtocolInformation;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_PROTOCOLS_PER_HANDLE ProtocolsPerHandle;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_LOCATE_HANDLE_BUFFER LocateHandleBuffer;</p>            </div><br><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>EFI_LOCATE_PROTOCOL LocateProtocol;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_INSTALL_PROTOCOL_INTERFACE InstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces;</p>            </div><br><div class='checkbox cyan'><input type="checkbox" />            <p>EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;</p>            </div></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// EFI Boot Services Table.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// The table header for the EFI Boot Services Table.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  EFI_TABLE_HEADER                              Hdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Task Priority Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_RAISE_TPL                                 RaiseTPL;</span><br><span class="line">  EFI_RESTORE_TPL                               RestoreTPL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Memory Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_ALLOCATE_PAGES                            AllocatePages;</span><br><span class="line">  EFI_FREE_PAGES                                FreePages;</span><br><span class="line">  EFI_GET_MEMORY_MAP                            GetMemoryMap;</span><br><span class="line">  EFI_ALLOCATE_POOL                             AllocatePool;</span><br><span class="line">  EFI_FREE_POOL                                 FreePool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Event &amp; Timer Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CREATE_EVENT                              CreateEvent;</span><br><span class="line">  EFI_SET_TIMER                                 SetTimer;</span><br><span class="line">  EFI_WAIT_FOR_EVENT                            WaitForEvent;</span><br><span class="line">  EFI_SIGNAL_EVENT                              SignalEvent;</span><br><span class="line">  EFI_CLOSE_EVENT                               CloseEvent;</span><br><span class="line">  EFI_CHECK_EVENT                               CheckEvent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Protocol Handler Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_INSTALL_PROTOCOL_INTERFACE                InstallProtocolInterface;</span><br><span class="line">  EFI_REINSTALL_PROTOCOL_INTERFACE              ReinstallProtocolInterface;</span><br><span class="line">  EFI_UNINSTALL_PROTOCOL_INTERFACE              UninstallProtocolInterface;</span><br><span class="line">  EFI_HANDLE_PROTOCOL                           HandleProtocol;</span><br><span class="line">  VOID                                          *Reserved;</span><br><span class="line">  EFI_REGISTER_PROTOCOL_NOTIFY                  RegisterProtocolNotify;</span><br><span class="line">  EFI_LOCATE_HANDLE                             LocateHandle;</span><br><span class="line">  EFI_LOCATE_DEVICE_PATH                        LocateDevicePath;</span><br><span class="line">  EFI_INSTALL_CONFIGURATION_TABLE               InstallConfigurationTable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Image Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_IMAGE_LOAD                                LoadImage;</span><br><span class="line">  EFI_IMAGE_START                               StartImage;</span><br><span class="line">  EFI_EXIT                                      Exit;</span><br><span class="line">  EFI_IMAGE_UNLOAD                              UnloadImage;</span><br><span class="line">  EFI_EXIT_BOOT_SERVICES                        ExitBootServices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Miscellaneous Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_GET_NEXT_MONOTONIC_COUNT                  GetNextMonotonicCount;</span><br><span class="line">  EFI_STALL                                     Stall;</span><br><span class="line">  EFI_SET_WATCHDOG_TIMER                        SetWatchdogTimer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// DriverSupport Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CONNECT_CONTROLLER                        ConnectController;</span><br><span class="line">  EFI_DISCONNECT_CONTROLLER                     DisconnectController;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Open and Close Protocol Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_OPEN_PROTOCOL                             OpenProtocol;</span><br><span class="line">  EFI_CLOSE_PROTOCOL                            CloseProtocol;</span><br><span class="line">  EFI_OPEN_PROTOCOL_INFORMATION                 OpenProtocolInformation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Library Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_PROTOCOLS_PER_HANDLE                      ProtocolsPerHandle;</span><br><span class="line">  EFI_LOCATE_HANDLE_BUFFER                      LocateHandleBuffer;</span><br><span class="line">  EFI_LOCATE_PROTOCOL                           LocateProtocol;</span><br><span class="line">  EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES      InstallMultipleProtocolInterfaces;</span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES    UninstallMultipleProtocolInterfaces;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 32-bit CRC Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_CALCULATE_CRC32                           CalculateCrc32;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Miscellaneous Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_COPY_MEM                                  CopyMem;</span><br><span class="line">  EFI_SET_MEM                                   SetMem;</span><br><span class="line">  EFI_CREATE_EVENT_EX                           CreateEventEx;</span><br><span class="line">&#125; EFI_BOOT_SERVICES;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="OpenProtocol"><a href="#OpenProtocol" class="headerlink" title="OpenProtocol"></a>OpenProtocol</h1><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250207181806644.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250207182821554.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144030827.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144054460.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144113071.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225144141665.png" alt="OpenProtocol"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MdePkg/Include/Uefi/UefiSpec.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL   0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_GET_PROTOCOL         0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_TEST_PROTOCOL        0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_CHILD_CONTROLLER  0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_BY_DRIVER            0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_OPEN_PROTOCOL_EXCLUSIVE            0x00000020</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Queries a handle to determine if it supports a specified protocol. If the protocol is supported by the</span></span><br><span class="line"><span class="comment">  handle, it opens the protocol on behalf of the calling agent.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle for the protocol interface that is being opened.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol</span></span><br><span class="line"><span class="comment">                                Interface is returned.</span></span><br><span class="line"><span class="comment">  @param[in]   AgentHandle      The handle of the agent that is opening the protocol interface</span></span><br><span class="line"><span class="comment">                                specified by Protocol and Interface.</span></span><br><span class="line"><span class="comment">  @param[in]   ControllerHandle If the agent that is opening a protocol is a driver that follows the</span></span><br><span class="line"><span class="comment">                                UEFI Driver Model, then this parameter is the controller handle</span></span><br><span class="line"><span class="comment">                                that requires the protocol interface. If the agent does not follow</span></span><br><span class="line"><span class="comment">                                the UEFI Driver Model, then this parameter is optional and may</span></span><br><span class="line"><span class="comment">                                be NULL.</span></span><br><span class="line"><span class="comment">  @param[in]   Attributes       The open mode of the protocol </span></span><br><span class="line"><span class="comment">  interface specified by Handle</span></span><br><span class="line"><span class="comment">                                and Protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           An item was added to the open list for the protocol interface, and the</span></span><br><span class="line"><span class="comment">                                protocol interface was returned in Interface.</span></span><br><span class="line"><span class="comment">  @retval EFI_UNSUPPORTED       Handle does not support Protocol.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.</span></span><br><span class="line"><span class="comment">  @retval EFI_ACCESS_DENIED     Required attributes can&#x27;t be supported in current environment.</span></span><br><span class="line"><span class="comment">  @retval EFI_ALREADY_STARTED   Item on the open list already has requierd attributes whose agent</span></span><br><span class="line"><span class="comment">                                handle is the same as AgentHandle.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_OPEN_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                  *Protocol,</span></span><br><span class="line"><span class="params">  OUT VOID                      **Interface  OPTIONAL,</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                AgentHandle,</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                ControllerHandle,</span></span><br><span class="line"><span class="params">  IN  UINT32                    Attributes</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>示例:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Guid/FileInfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/BaseMemoryLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/CacheMaintenanceLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/MemoryAllocationLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/SimpleFileSystem.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">ReadFileByName</span><span class="params">(IN CHAR16 *FileName, OUT UINT8 **FileData, OUT UINTN *FileSize)</span> &#123;</span><br><span class="line">  EFI_FILE_INFO *FileInfo;</span><br><span class="line">  UINTN FileInfoSize;</span><br><span class="line">  EFI_FILE_PROTOCOL *FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">  EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *SimpleFileSystem;</span><br><span class="line">  EFI_FILE_PROTOCOL *Root;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  UINTN HandleCount = <span class="number">0</span>;</span><br><span class="line">  UINTN HandleIndex = <span class="number">0</span>;</span><br><span class="line">  EFI_HANDLE *HandleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// find all handles of SimpleFileSystemProtocol</span></span><br><span class="line">  Status =</span><br><span class="line">      gBS-&gt;LocateHandleBuffer(ByProtocol, &amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line">                              <span class="literal">NULL</span>, &amp;HandleCount, &amp;HandleBuffer);</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR(Status) || HandleCount == <span class="number">0</span>) &#123;</span><br><span class="line">    Print(<span class="string">L&quot;Locate SimpleFileSystemProtocolHandle Buffer error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (HandleIndex = <span class="number">0</span>; HandleIndex &lt; HandleCount; HandleIndex++) &#123;</span><br><span class="line">    Status = gBS-&gt;OpenProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                               &amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line">                               (VOID **)&amp;SimpleFileSystem, gImageHandle, <span class="literal">NULL</span>,</span><br><span class="line">                               EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open SimpleFileSystemProtocol error,at HandleIndex %d&quot;</span>,</span><br><span class="line">            HandleIndex);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Status = SimpleFileSystem-&gt;OpenVolume(SimpleFileSystem, &amp;Root);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open Root Volume error at HandleIndex%d&quot;</span>, HandleIndex);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.打开文件，获取文件句柄FileHandle</span></span><br><span class="line">    Status = Root-&gt;Open(Root, &amp;FileHandle, FileName, EFI_FILE_MODE_READ, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((FileHandle == <span class="literal">NULL</span>) || (EFI_ERROR(Status))) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Open file %s failed at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// else find the target handle</span></span><br><span class="line">    Print(<span class="string">L&quot;FileHandle: 0x%p at HandleIndex%d\n&quot;</span>, FileHandle, HandleIndex);</span><br><span class="line">    <span class="comment">// 2.分配文件信息大小</span></span><br><span class="line">    FileInfoSize = <span class="keyword">sizeof</span>(EFI_FILE_INFO) + <span class="number">1024</span>;</span><br><span class="line">    FileInfo = AllocateZeroPool(FileInfoSize);</span><br><span class="line">    <span class="keyword">if</span> (FileInfo == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;can not allocate %d size for FineInfo at HandleIndex%d\n&quot;</span>,</span><br><span class="line">            FileInfoSize, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.打开文件信息</span></span><br><span class="line">    Status = FileHandle-&gt;GetInfo(FileHandle, &amp;gEfiFileInfoGuid, &amp;FileInfoSize,</span><br><span class="line">                                 FileInfo);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;Get FileInfo failed at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Print(<span class="string">L&quot;FileInfo: 0x%p\n&quot;</span>, FileInfo);</span><br><span class="line">    <span class="comment">// 4.预先分配文件大小</span></span><br><span class="line">    *FileSize = (UINTN)FileInfo-&gt;FileSize + <span class="keyword">sizeof</span>(CHAR16);</span><br><span class="line">    *FileData = AllocateZeroPool(*FileSize);</span><br><span class="line">    <span class="keyword">if</span> (*FileData == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;locate file data size %d failed at HandleIndex%d\n&quot;</span>, *FileSize,</span><br><span class="line">            HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Print(<span class="string">L&quot;size of %s is %d\n&quot;</span>, FileName, *FileSize);</span><br><span class="line">      Print(<span class="string">L&quot;FileData: 0x%p\n&quot;</span>, *FileData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.读取文件</span></span><br><span class="line">    Status = FileHandle-&gt;Read(FileHandle, FileSize, (VOID *)*FileData);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR(Status)) &#123;</span><br><span class="line">      Print(<span class="string">L&quot;open %s file failed at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">      FileHandle-&gt;Close(FileHandle);</span><br><span class="line">      gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">      Root-&gt;Close(Root);</span><br><span class="line">      gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                         &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">// gBS-&gt;FreePool((VOID *)FileData);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Print(<span class="string">L&quot;open %s file success at HandleIndex%d\n&quot;</span>, FileName, HandleIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    FileHandle-&gt;Close(FileHandle);</span><br><span class="line">    Print(<span class="string">L&quot;FileHandle is freed normally at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    gBS-&gt;FreePool(FileInfo);  <span class="comment">// 释放FileInfo</span></span><br><span class="line">    Print(<span class="string">L&quot;FileInfo is freed normally at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    Root-&gt;Close(Root);</span><br><span class="line">    gBS-&gt;CloseProtocol(HandleBuffer[HandleIndex],</span><br><span class="line">                       &amp;gEfiSimpleFileSystemProtocolGuid, gImageHandle, <span class="literal">NULL</span>);</span><br><span class="line">    Print(<span class="string">L&quot;Operation Success at HandleIndex%d\n&quot;</span>, HandleIndex);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HandleBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    gBS-&gt;FreePool(HandleBuffer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="HandleProtocol"><a href="#HandleProtocol" class="headerlink" title="HandleProtocol"></a>HandleProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250201214538747.png" alt="HandleProtocol的原型"></p><p>相比于OpenProtocol，不需要指定参数AgentHandle,ControllerHandle和Attributes</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Queries a handle to determine if it supports a specified protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle being queried.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        Supplies the address where a pointer to the corresponding Protocol</span></span><br><span class="line"><span class="comment">                                Interface is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The interface information for the specified protocol was returned.</span></span><br><span class="line"><span class="comment">  @retval EFI_UNSUPPORTED       The device does not support the specified protocol.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Protocol is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Interface is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_HANDLE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE               Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                 *Protocol,</span></span><br><span class="line"><span class="params">  OUT VOID                     **Interface</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/DevicePathLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Protocol/LoadedImage.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS EFIAPI <span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="params">                           IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  EFI_LOADED_IMAGE_PROTOCOL *LoadedImage;</span><br><span class="line">  Status = gBS-&gt;HandleProtocol(ImageHandle, &amp;gEfiLoadedImageProtocolGuid,</span><br><span class="line">                               (VOID **)&amp;LoadedImage);</span><br><span class="line">  <span class="keyword">if</span> (Status == EFI_SUCCESS) &#123;</span><br><span class="line">    EFI_DEVICE_PATH_PROTOCOL *DevicePath;</span><br><span class="line">    Status =</span><br><span class="line">        gBS-&gt;HandleProtocol(ImageHandle, &amp;gEfiLoadedImageDevicePathProtocolGuid,</span><br><span class="line">                            (VOID **)&amp;DevicePath);</span><br><span class="line">    <span class="keyword">if</span>(Status == EFI_SUCCESS)&#123;</span><br><span class="line">      Print(<span class="string">L&quot;Image device: %s\n&quot;</span>,ConvertDevicePathToText(DevicePath,FALSE,TRUE));</span><br><span class="line">      Print(<span class="string">L&quot;Image file: %s\n&quot;</span>, ConvertDevicePathToText(LoadedImage-&gt;FilePath,FALSE,TRUE));</span><br><span class="line">      Print(<span class="string">L&quot;Image Base: %X\n&quot;</span>,LoadedImage-&gt;ImageBase);</span><br><span class="line">      Print(<span class="string">L&quot;Image Size: %X\n&quot;</span>,LoadedImage-&gt;ImageSize);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      Print(<span class="string">L&quot;Can&#x27;t get EFI_LOADED_IMAGE_PROTOCOL, Status=%r\n&quot;</span>,Status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Print(<span class="string">L&quot;Can&#x27;t get EFI_DEVICE_PATH_PROTOCOL, Status=%r\n&quot;</span>,Status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="ProtocolsPerHandle"><a href="#ProtocolsPerHandle" class="headerlink" title="ProtocolsPerHandle"></a>ProtocolsPerHandle</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250202231208653.png" alt="ProtocolsPerHandle"></p><p>通过Protocol GUID检索安装在设备句柄上的接口<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Retrieves the list of protocol interface GUIDs that are installed on a handle in a buffer allocated</span></span><br><span class="line"><span class="comment">  from pool.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle              The handle from which to retrieve the list of protocol interface</span></span><br><span class="line"><span class="comment">                                   GUIDs.</span></span><br><span class="line"><span class="comment">  @param[out]  ProtocolBuffer      A pointer to the list of protocol interface GUID pointers that are</span></span><br><span class="line"><span class="comment">                                   installed on Handle.</span></span><br><span class="line"><span class="comment">  @param[out]  ProtocolBufferCount A pointer to the number of GUID pointers present in</span></span><br><span class="line"><span class="comment">                                   ProtocolBuffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The list of protocol interface GUIDs installed on Handle was returned in</span></span><br><span class="line"><span class="comment">                                ProtocolBuffer. The number of protocol interface GUIDs was</span></span><br><span class="line"><span class="comment">                                returned in ProtocolBufferCount.</span></span><br><span class="line"><span class="comment">  @retval EFI_OUT_OF_RESOURCES  There is not enough pool memory to store the results.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Handle is not a valid EFI_HANDLE.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER ProtocolBuffer is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER ProtocolBufferCount is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_PROTOCOLS_PER_HANDLE)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE      Handle,</span></span><br><span class="line"><span class="params">  OUT EFI_GUID        ***ProtocolBuffer,</span></span><br><span class="line"><span class="params">  OUT UINTN           *ProtocolBufferCount</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>例子:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/MemoryAllocationLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  Print(<span class="string">L&quot;_______________\n&quot;</span>);</span><br><span class="line">  EFI_GUID **ProtocolGuidArray;</span><br><span class="line">  UINTN ArrayCount;</span><br><span class="line">  EFI_STATUS Status = gBS-&gt;ProtocolsPerHandle(ImageHandle,&amp;ProtocolGuidArray,&amp;ArrayCount);</span><br><span class="line">  <span class="keyword">if</span>(Status==EFI_SUCCESS)&#123;</span><br><span class="line">    <span class="keyword">for</span>(UINTN i =<span class="number">0</span>;i&lt;ArrayCount;i++)&#123;</span><br><span class="line">      Print(<span class="string">L&quot;%g\n&quot;</span>,ProtocolGuidArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    FreePool(ProtocolGuidArray);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Print(<span class="string">L&quot;ProtocolsPerHandle error: %r\n&quot;</span>,Status);<span class="comment">//%r打印EFI_STATUS错误码</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="LocateProtocol"><a href="#LocateProtocol" class="headerlink" title="LocateProtocol"></a>LocateProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225140716252.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225141031426.png" alt="LocateProtocol"></p><p>与HandleProtocol和OpenProtocol不同，LocateProtocol不关心Protocol在哪个设备上，它会在系统中顺序寻找句柄列表，返回找到的第一个Protocol实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Returns the first protocol instance that matches the given protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]  Protocol          Provides the protocol to search for.</span></span><br><span class="line"><span class="comment">  @param[in]  Registration      Optional registration key returned from</span></span><br><span class="line"><span class="comment">                                RegisterProtocolNotify().</span></span><br><span class="line"><span class="comment">  @param[out]  Interface        On return, a pointer to the first interface that matches Protocol and</span></span><br><span class="line"><span class="comment">                                Registration.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           A protocol instance matching Protocol was found and returned in</span></span><br><span class="line"><span class="comment">                                Interface.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         No protocol instances were found that match Protocol and</span></span><br><span class="line"><span class="comment">                                Registration.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER Interface is NULL.</span></span><br><span class="line"><span class="comment">                                Protocol is NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_LOCATE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_GUID  *Protocol,</span></span><br><span class="line"><span class="params">  IN  VOID      *Registration  OPTIONAL,</span></span><br><span class="line"><span class="params">  OUT VOID      **Interface</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line"><span class="title function_">LoadFileByName</span><span class="params">(</span></span><br><span class="line"><span class="params">IN CHAR16 *FileName,</span></span><br><span class="line"><span class="params">OUT UINT8 **FileData,</span></span><br><span class="line"><span class="params">OUT UINTN *FileSize)</span></span><br><span class="line">&#123;</span><br><span class="line">EFI_STATUS Status;</span><br><span class="line">EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *SimpleFileSystem;</span><br><span class="line">EFI_FILE_PROTOCOL *Root;</span><br><span class="line">EFI_FILE_PROTOCOL *FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">EFI_FILE_INFO *FileInfo;</span><br><span class="line">UINTN FileInfoSize;</span><br><span class="line">UINTN TempBufferSize;</span><br><span class="line">VOID *TempBuffer;</span><br><span class="line"></span><br><span class="line">Status = gBS-&gt;LocateProtocol(&amp;gEfiSimpleFileSystemProtocolGuid,</span><br><span class="line"> <span class="literal">NULL</span>, (VOID **)&amp;SimpleFileSystem);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Open the root directory</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = SimpleFileSystem-&gt;OpenVolume(SimpleFileSystem, &amp;Root);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Open the file</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = Root-&gt;Open(Root, &amp;FileHandle, FileName,</span><br><span class="line">EFI_FILE_MODE_READ, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ((FileHandle == <span class="literal">NULL</span>) || (EFI_ERROR(Status)))</span><br><span class="line">&#123;</span><br><span class="line">Print(<span class="string">L&quot;Open file %s failed !!\n&quot;</span>, FileName);</span><br><span class="line">Root-&gt;Close(Root);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Get the file information</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">FileInfoSize = <span class="keyword">sizeof</span>(EFI_FILE_INFO) + <span class="number">1024</span>;</span><br><span class="line">FileInfo = AllocateZeroPool(FileInfoSize);</span><br><span class="line"><span class="keyword">if</span> (FileInfo == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status = FileHandle-&gt;GetInfo(FileHandle, &amp;gEfiFileInfoGuid,</span><br><span class="line"> &amp;FileInfoSize,</span><br><span class="line"> FileInfo);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate buffer for the file data. The last CHAR16 is for L&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">TempBufferSize = (UINTN)FileInfo-&gt;FileSize + <span class="keyword">sizeof</span>(CHAR16);</span><br><span class="line">TempBuffer = AllocateZeroPool(TempBufferSize);</span><br><span class="line"><span class="keyword">if</span> (TempBuffer == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gBS-&gt;FreePool(FileInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Read the file data to the buffer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Status = FileHandle-&gt;Read(FileHandle, &amp;TempBufferSize, TempBuffer);</span><br><span class="line"><span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">&#123;</span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line">gBS-&gt;FreePool(TempBuffer);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FileHandle-&gt;Close(FileHandle);</span><br><span class="line"></span><br><span class="line">*FileSize = TempBufferSize;</span><br><span class="line">*FileData = TempBuffer;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="OpenProtocolInformation"><a href="#OpenProtocolInformation" class="headerlink" title="OpenProtocolInformation"></a>OpenProtocolInformation</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225141817128.png" alt="OpenProtocolInformation"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// EFI Oprn Protocol Information Entry</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_HANDLE    AgentHandle;</span><br><span class="line">  EFI_HANDLE    ControllerHandle;</span><br><span class="line">  UINT32        Attributes;</span><br><span class="line">  UINT32        OpenCount;</span><br><span class="line">&#125; EFI_OPEN_PROTOCOL_INFORMATION_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Retrieves the list of agents that currently have a protocol interface opened.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]   Handle           The handle for the protocol interface that is being queried.</span></span><br><span class="line"><span class="comment">  @param[in]   Protocol         The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[out]  EntryBuffer      A pointer to a buffer of open protocol information in the form of</span></span><br><span class="line"><span class="comment">                                EFI_OPEN_PROTOCOL_INFORMATION_ENTRY structures.</span></span><br><span class="line"><span class="comment">  @param[out]  EntryCount       A pointer to the number of entries in EntryBuffer.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The open protocol information was returned in EntryBuffer, and the</span></span><br><span class="line"><span class="comment">                                number of entries was returned EntryCount.</span></span><br><span class="line"><span class="comment">  @retval EFI_OUT_OF_RESOURCES  There are not enough resources available to allocate EntryBuffer.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         Handle does not support the protocol specified by Protocol.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_OPEN_PROTOCOL_INFORMATION)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_HANDLE                          Handle,</span></span><br><span class="line"><span class="params">  IN  EFI_GUID                            *Protocol,</span></span><br><span class="line"><span class="params">  OUT EFI_OPEN_PROTOCOL_INFORMATION_ENTRY **EntryBuffer,</span></span><br><span class="line"><span class="params">  OUT UINTN                               *EntryCount</span></span><br><span class="line"><span class="params">  )</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例子:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="CloseProtocol"><a href="#CloseProtocol" class="headerlink" title="CloseProtocol"></a>CloseProtocol</h1><p>UEFI_Spec_2.8</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225142227191.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250225142316837.png" alt="CloseProtocol"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Closes a protocol on a handle that was opened using OpenProtocol().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in]  Handle            The handle for the protocol interface that was previously opened</span></span><br><span class="line"><span class="comment">                                with OpenProtocol(), and is now being closed.</span></span><br><span class="line"><span class="comment">  @param[in]  Protocol          The published unique identifier of the protocol.</span></span><br><span class="line"><span class="comment">  @param[in]  AgentHandle       The handle of the agent that is closing the protocol interface.</span></span><br><span class="line"><span class="comment">  @param[in]  ControllerHandle  If the agent that opened a protocol is a driver that follows the</span></span><br><span class="line"><span class="comment">                                UEFI Driver Model, then this parameter is the controller handle</span></span><br><span class="line"><span class="comment">                                that required the protocol interface.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS           The protocol instance was closed.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER 1) Handle is NULL.</span></span><br><span class="line"><span class="comment">                                2) AgentHandle is NULL.</span></span><br><span class="line"><span class="comment">                                3) ControllerHandle is not NULL and ControllerHandle is not a valid EFI_HANDLE.</span></span><br><span class="line"><span class="comment">                                4) Protocol is NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_NOT_FOUND         1) Handle does not support the protocol specified by Protocol.</span></span><br><span class="line"><span class="comment">                                2) The protocol interface specified by Handle and Protocol is not</span></span><br><span class="line"><span class="comment">                                   currently open by AgentHandle and ControllerHandle.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="title function_">EFI_STATUS</span></span><br><span class="line"><span class="params">(EFIAPI *EFI_CLOSE_PROTOCOL)</span><span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               Handle,</span></span><br><span class="line"><span class="params">  IN EFI_GUID                 *Protocol,</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               AgentHandle,</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE               ControllerHandle</span></span><br><span class="line"><span class="params">  )</span>;</span><br></pre></td></tr></table></figure><p>例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UEFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UEFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil安装</title>
      <link href="/posts/28522/"/>
      <url>/posts/28522/</url>
      
        <content type="html"><![CDATA[<h1 id="C51安装"><a href="#C51安装" class="headerlink" title="C51安装"></a>C51安装</h1><p>  1.首先进入官网点击下载C51</p>   <div class="tag link"><a class="link-card" title="Keil下载" href="https://www.keil.com/download/product/"><div class="left"><img src="https://www.keil.com/images/icons/c51_dld.png"/></div><div class="right"><p class="text">Keil下载</p><p class="url">https://www.keil.com/download/product/</p></div></a></div><p>这里会要求填一个表单，简单填一下就好，然后点击下载的exe安装包进行安装</p><p>  2.进入安装后一路确认，在选择安装位置这里我选择安装到D盘而不是默认的C盘。</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131193502978.png" alt="C51安装位置"></p><p>  3.最后点击Finish安装成功</p><h1 id="MDK安装"><a href="#MDK安装" class="headerlink" title="MDK安装"></a>MDK安装</h1><p>Keil的MDK和C51这两个软件可以共存，安装步骤类似。</p><p>  1.首先还是访问官网下载MDK的安装包<br>   <div class="tag link"><a class="link-card" title="Keil下载" href="https://www.keil.com/download/product/"><div class="left"><img src="https://www.keil.com/images/icons/mdk_dld_v2.png"/></div><div class="right"><p class="text">Keil下载</p><p class="url">https://www.keil.com/download/product/</p></div></a></div></p><p>  2.进入安装后，安装位置这样填，根据C51的安装位置更改<br>   <img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131194740287.png" alt="MDK安装位置"></p><p>  3.最后点击Finish安装成功</p><div class="tip warning faa-horizontal animated"><p>注意：C51和MDK的安装顺序不要反了</p></div><h1 id="v5编译器"><a href="#v5编译器" class="headerlink" title="v5编译器"></a>v5编译器</h1><p>首先下载v5编译器，因为现在官方好像不提供直接下载的渠道了，所以只能下载之前版本的Keil提取出v5版本的编译器，这里有已经提取出来的编译器可以直接下载</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">夸克网盘</button><button type="button" class="tab">百度网盘</button></div><div class="tab-contents"><div class="tab-item-content active"><div class="tag link"><a class="link-card" title="v5编译器下载" href="https://pan.quark.cn/s/cd646c8d5b2b"><div class="left"><img src="https://image.quark.cn/s/uae/g/3o/broccoli/resource/202404/d94d93e0-03a2-11ef-be4c-79ebae2e18ac.vnd.microsoft.icon"/></div><div class="right"><p class="text">v5编译器下载</p><p class="url">https://pan.quark.cn/s/cd646c8d5b2b</p></div></a></div></div><div class="tab-item-content"><div class="tag link"><a class="link-card" title="v5编译器下载" href="https://pan.baidu.com/s/1zkUcPyKC5Z-Qda9jJb1Sjw?pwd=1234"><div class="left"><img src="https://nd-static.bdstatic.com/m-static/v20-main/favicon-main.ico"/></div><div class="right"><p class="text">v5编译器下载</p><p class="url">https://pan.baidu.com/s/1zkUcPyKC5Z-Qda9jJb1Sjw?pwd=1234</p></div></a></div></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><p>下载后解压到D:\Keil_v5\ARM目录下</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131200906926.png" alt="编译器解压目录"></p><p>打开Keil，随便新建一个工程，然后点击这个按钮<strong>File Extensions, Books and Environment…</strong></p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201214187.png" alt="File Extensions, Books and Environment..."></p><p>然后点击<strong>Folder/Extensions</strong>，点击<strong>Use ARM Compiler</strong>旁边的这个按钮</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201435417.png" alt="Use ARM Compiler"></p><p>点击下面的<strong>Add another ARM Compiler Version to List</strong>, 选择刚才解压的ARMCC路径</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250131201751844.png" alt="Add another ARM Compiler Version to List"></p><p>保存后至此成功</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://zhuanlan.zhihu.com/p/561047339">MDK5.37不预安装Compiler Version5解决办法</a></div>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedded tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Emacs配置</title>
      <link href="/posts/28521/"/>
      <url>/posts/28521/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:ubuntuhandbook1/emacs</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="comment"># emacs-nox 无gui，命令行</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install emacs-nox</span><br><span class="line"><span class="comment"># emacs</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install emacs</span><br><span class="line"><span class="built_in">sudo</span> apt-get install clang clangd clang-format</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><p>.emacs<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> inhibit-startup-message <span class="literal">t</span>)         <span class="comment">;; 关闭启动消息</span></span><br><span class="line">(<span class="name">setq</span> initial-scratch-message <span class="literal">nil</span>)       <span class="comment">;; 关闭 *scratch* 缓冲区中的欢迎信息</span></span><br><span class="line">(<span class="name">tool-bar-mode</span> <span class="number">-1</span>)                       <span class="comment">;; 关闭工具栏</span></span><br><span class="line">(<span class="name">menu-bar-mode</span> <span class="number">-1</span>)                       <span class="comment">;; 关闭菜单栏</span></span><br><span class="line">(<span class="name">scroll-bar-mode</span> <span class="number">-1</span>)                     <span class="comment">;; 关闭滚动条</span></span><br><span class="line">(<span class="name">setq</span> ring-bell-function &#x27;ignore)        <span class="comment">;; 关闭错误提示音</span></span><br><span class="line">(<span class="name">global-display-line-numbers-mode</span> <span class="literal">t</span>)     <span class="comment">;; 显示行号</span></span><br><span class="line">(<span class="name">defalias</span> &#x27;yes-or-no-p &#x27;y-or-n-p)        <span class="comment">;; 使用 y/n 代替 yes/no</span></span><br><span class="line">(<span class="name">setq</span> make-backup-files <span class="literal">nil</span>)             <span class="comment">;; 禁用备份文件</span></span><br><span class="line"><span class="comment">;;(setq auto-save-default nil)             ;; 禁用自动保存文件</span></span><br><span class="line">(<span class="name">setq</span> create-lockfiles <span class="literal">nil</span>)              <span class="comment">;; 禁用锁定文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; ------------------------</span></span><br><span class="line"><span class="comment">;; 设置编码</span></span><br><span class="line"><span class="comment">;; ------------------------</span></span><br><span class="line"><span class="comment">;; 设定 Emacs 使用 UTF-8 编码</span></span><br><span class="line">(<span class="name">prefer-coding-system</span> &#x27;utf-8)                   <span class="comment">;; 优先使用 UTF-8 编码</span></span><br><span class="line">(<span class="name">setq</span> locale-coding-system &#x27;utf-8)              <span class="comment">;; 设置区域编码为 UTF-8</span></span><br><span class="line">(<span class="name">set-keyboard-coding-system</span> &#x27;utf-8)             <span class="comment">;; 设置键盘编码为 UTF-8</span></span><br><span class="line">(<span class="name">set-selection-coding-system</span> &#x27;utf-8)            <span class="comment">;; 设置选择内容的编码为 UTF-8</span></span><br><span class="line">(<span class="name">set-terminal-coding-system</span> &#x27;utf-8)             <span class="comment">;; 设置终端编码为 UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 默认保存文件时使用 UTF-8 编码</span></span><br><span class="line">(<span class="name">setq-default</span> buffer-file-coding-system &#x27;utf-8)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 自动检测文件编码</span></span><br><span class="line">(<span class="name">setq</span> find-file-encoding &#x27;auto)                  <span class="comment">;; 自动检测文件编码</span></span><br><span class="line">(<span class="name">setq-default</span> coding-system-for-read &#x27;utf-8)     <span class="comment">;; 读取文件时默认使用 UTF-8</span></span><br><span class="line">(<span class="name">setq-default</span> coding-system-for-write &#x27;utf-8)    <span class="comment">;; 写入文件时默认使用 UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 设定编码环境为 UTF-8</span></span><br><span class="line">(<span class="name">set-language-environment</span> <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;;------------------------------</span></span><br><span class="line"><span class="comment">;; 优化部分</span></span><br><span class="line"><span class="comment">;;------------------------------</span></span><br><span class="line"><span class="comment">;; 将基本缩进改为空格</span></span><br><span class="line">(<span class="name">use-package</span> simple</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">nil</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq-default</span> indent-tabs-mode <span class="literal">nil</span>))</span><br><span class="line"><span class="comment">;;优化长行文件</span></span><br><span class="line">(<span class="name">use-package</span> so-long</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">global-so-long-mode</span> <span class="number">+1</span>))</span><br><span class="line"><span class="comment">;; 提高性能</span></span><br><span class="line">(<span class="name">setq</span> process-adaptive-read-buffering <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> blink-matching-paren <span class="literal">nil</span>)<span class="comment">;;键入右括号时不要眨眼</span></span><br><span class="line">(<span class="name">setq</span> vc-handled-backends &#x27;(Git))<span class="comment">;;将 VC 后端更改为仅 Git</span></span><br><span class="line">(<span class="name">setq</span> auto-mode-case-fold <span class="literal">nil</span>)<span class="comment">;;防止文件搜索执行两次</span></span><br><span class="line">(<span class="name">setq-default</span> bidi-display-reordering &#x27;left-to-right)<span class="comment">;;抑制双向排序</span></span><br><span class="line">(<span class="name">setq</span> bidi-inhibit-bpa <span class="literal">t</span>)<span class="comment">;;长线双向扫描</span></span><br><span class="line"><span class="comment">;;删除未聚焦窗口中的光标</span></span><br><span class="line">(<span class="name">setq-default</span> cursor-in-non-selected-windows <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">setq</span> highlight-nonselected-windows <span class="literal">nil</span>)<span class="comment">;;</span></span><br><span class="line">(<span class="name">setq</span> fast-but-imprecise-scrolling <span class="literal">t</span>)<span class="comment">;;快速滚动</span></span><br><span class="line">(<span class="name">setq</span> ffap-machine-p-known &#x27;reject)<span class="comment">;;不要 ping 域</span></span><br><span class="line">(<span class="name">setq</span> idle-update-delay <span class="number">1.0</span>)<span class="comment">;;减少UI更新频率</span></span><br><span class="line">(<span class="name">setq</span> redisplay-skip-fontification-on-input <span class="literal">t</span>)<span class="comment">;;抑制不必要的字体显示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; package </span></span><br><span class="line">(<span class="name">use-package</span> package</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;package-archives &#x27;(<span class="string">&quot;melpa&quot;</span> . <span class="string">&quot;https://melpa.org/packages/&quot;</span>))</span><br><span class="line">  (<span class="name">unless</span> (<span class="name">bound-and-true-p</span> package--initialized)</span><br><span class="line">    (<span class="name">package-initialize</span>)))</span><br><span class="line"><span class="comment">;; 设置 use-package 自动安装缺失包</span></span><br><span class="line">(<span class="name">setq</span> use-package-always-ensure <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; Fix path</span></span><br><span class="line">(<span class="name">use-package</span> exec-path-from-shell</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">when</span> (<span class="name">memq</span> window-system &#x27;(mac ns x))</span><br><span class="line">    (<span class="name">exec-path-from-shell-initialize</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> tree-sitter</span><br><span class="line">  <span class="symbol">:when</span> (<span class="name">and</span> (<span class="name">fboundp</span> &#x27;treesit-available-p)</span><br><span class="line">         (<span class="name">treesit-available-p</span>))</span><br><span class="line">  <span class="symbol">:config</span> (<span class="name">setq</span> treesit-font-lock-level <span class="number">4</span>)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> treesit-language-source-alist</span><br><span class="line">    &#x27;((bash       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-bash&quot;</span>))</span><br><span class="line">      (c          . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-c&quot;</span>))</span><br><span class="line">      (cpp        . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-cpp&quot;</span>))</span><br><span class="line">      (css        . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-css&quot;</span>))</span><br><span class="line">      (cmake      . (<span class="string">&quot;https://github.com/uyha/tree-sitter-cmake&quot;</span>))</span><br><span class="line">      (csharp     . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-c-sharp.git&quot;</span>))</span><br><span class="line">      (dockerfile . (<span class="string">&quot;https://github.com/camdencheek/tree-sitter-dockerfile&quot;</span>))</span><br><span class="line">      (elisp      . (<span class="string">&quot;https://github.com/Wilfred/tree-sitter-elisp&quot;</span>))</span><br><span class="line">      (go         . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-go&quot;</span>))</span><br><span class="line">      (gomod      . (<span class="string">&quot;https://github.com/camdencheek/tree-sitter-go-mod.git&quot;</span>))</span><br><span class="line">      (html       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-html&quot;</span>))</span><br><span class="line">      (java       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-java.git&quot;</span>))</span><br><span class="line">      (javascript . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-javascript&quot;</span>))</span><br><span class="line">      (json       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-json&quot;</span>))</span><br><span class="line">      (lua        . (<span class="string">&quot;https://github.com/Azganoth/tree-sitter-lua&quot;</span>))</span><br><span class="line">      (make       . (<span class="string">&quot;https://github.com/alemuller/tree-sitter-make&quot;</span>))</span><br><span class="line">      (markdown   . (<span class="string">&quot;https://github.com/MDeiml/tree-sitter-markdown&quot;</span> <span class="literal">nil</span> <span class="string">&quot;tree-sitter-markdown/src&quot;</span>))</span><br><span class="line">      (ocaml      . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-ocaml&quot;</span> <span class="literal">nil</span> <span class="string">&quot;ocaml/src&quot;</span>))</span><br><span class="line">      (org        . (<span class="string">&quot;https://github.com/milisims/tree-sitter-org&quot;</span>))</span><br><span class="line">      (python     . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-python&quot;</span>))</span><br><span class="line">      (php        . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-php&quot;</span>))</span><br><span class="line">      (typescript . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-typescript&quot;</span> <span class="literal">nil</span> <span class="string">&quot;typescript/src&quot;</span>))</span><br><span class="line">      (tsx        . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-typescript&quot;</span> <span class="literal">nil</span> <span class="string">&quot;tsx/src&quot;</span>))</span><br><span class="line">      (ruby       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-ruby&quot;</span>))</span><br><span class="line">      (rust       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-rust&quot;</span>))</span><br><span class="line">      (sql        . (<span class="string">&quot;https://github.com/m-novikov/tree-sitter-sql&quot;</span>))</span><br><span class="line">      (vue        . (<span class="string">&quot;https://github.com/merico-dev/tree-sitter-vue&quot;</span>))</span><br><span class="line">      (yaml       . (<span class="string">&quot;https://github.com/ikatyang/tree-sitter-yaml&quot;</span>))</span><br><span class="line">      (toml       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-toml&quot;</span>))</span><br><span class="line">      (zig        . (<span class="string">&quot;https://github.com/GrayJack/tree-sitter-zig&quot;</span>))))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(sh-mode         . bash-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(c-mode          . c-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(c++-mode        . c++-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(c-or-c++-mode   . c-or-c++-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(css-mode        . css-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(js-mode         . js-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(java-mode       . java-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(js-json-mode    . json-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(makefile-mode   . cmake-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(python-mode     . python-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(ruby-mode       . ruby-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;major-mode-remap-alist &#x27;(conf-toml-mode  . toml-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\(?:Dockerfile\\(?:\\..*\\)?\\|\\.[Dd]ockerfile\\)\\&#x27;&quot;</span> . dockerfile-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\.go\\&#x27;&quot;</span> . go-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;/go\\.mod\\&#x27;&quot;</span> . go-mod-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\.rs\\&#x27;&quot;</span> . rust-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\.ts\\&#x27;&quot;</span> . typescript-ts-mode))</span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;auto-mode-alist &#x27;(<span class="string">&quot;\\.y[a]?ml\\&#x27;&quot;</span> . yaml-ts-mode)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> &#x27;eglot)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> eglot-server-programs</span><br><span class="line">      &#x27;(((c++-mode c-mode c++-ts-mode c-ts-mode) . (<span class="string">&quot;clangd&quot;</span>))</span><br><span class="line">        ((rust-ts-mode rust-mode) . (<span class="string">&quot;rust-analyzer&quot;</span></span><br><span class="line">                                     :initializationOptions</span><br><span class="line">                                     (:checkCommand <span class="string">&quot;clippy&quot;</span>)))))</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c-mode-hook &#x27;eglot-ensure)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c++-mode-hook &#x27;eglot-ensure)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c-ts-mode-hook &#x27;eglot-ensure)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c++-ts-mode-hook &#x27;eglot-ensure)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;rust-mode-hook &#x27;eglot-ensure)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;rust-ts-mode-hook &#x27;eglot-ensure)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; ------------------------</span></span><br><span class="line"><span class="comment">;; Company-mode 自动补全配置</span></span><br><span class="line"><span class="comment">;; ------------------------</span></span><br><span class="line">(<span class="name">use-package</span> company <span class="symbol">:ensure</span> <span class="literal">t</span> <span class="symbol">:defer</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">after-init</span> . global-company-mode))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;-------------------------</span></span><br><span class="line"><span class="comment">;; 设置格式化代码</span></span><br><span class="line"><span class="comment">;;-------------------------</span></span><br><span class="line">(<span class="name">use-package</span> format-all</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:commands</span> format-all-mode</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . format-all-mode)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq-default</span> format-all-formatters</span><br><span class="line">                &#x27;((<span class="string">&quot;C&quot;</span>     (clang-format )))))</span><br><span class="line"><span class="comment">;;快捷键绑定</span></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-x f&quot;</span>) &#x27;format-all-buffer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;;---------------------------------</span></span><br><span class="line"><span class="comment">;; UI界面</span></span><br><span class="line"><span class="comment">;;---------------------------------</span></span><br><span class="line"><span class="comment">;; 安装 neotree,文件浏览侧边栏</span></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> neotree</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:bind</span> ([f8] . neotree-toggle)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> neo-theme (<span class="name">if</span> (<span class="name">display-graphic-p</span>) &#x27;icons &#x27;arrow))</span><br><span class="line">  (<span class="name">setq</span> neo-window-fixed-size <span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> all-the-icons</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">unless</span> (<span class="name">member</span> <span class="string">&quot;all-the-icons&quot;</span> (<span class="name">font-family-list</span>))</span><br><span class="line">    (<span class="name">all-the-icons-install-fonts</span> <span class="literal">t</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;;面包屑</span></span><br><span class="line">(<span class="name">use-package</span> breadcrumb</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">breadcrumb-mode</span> <span class="number">+1</span>))</span><br><span class="line"><span class="comment">;;仪表盘</span></span><br><span class="line">(<span class="name">use-package</span> dashboard</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> dashboard-center-content <span class="literal">t</span>)</span><br><span class="line">  (<span class="name">dashboard-setup-startup-hook</span>))</span><br><span class="line"><span class="comment">;; 改进分页符显示</span></span><br><span class="line">(<span class="name">use-package</span> page-break-lines</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">page-break-lines-mode</span> <span class="number">+1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; ------------------------</span></span><br><span class="line"><span class="comment">;; 设置 Fira Code Light 字体</span></span><br><span class="line"><span class="comment">;; ------------------------</span></span><br><span class="line">(<span class="name">defun</span> my-setup-fira-code ()</span><br><span class="line">  <span class="string">&quot;设置 Fira Code 字体和连体字功能，针对 C/C++ 模式。&quot;</span></span><br><span class="line">  (<span class="name">set-face-attribute</span> &#x27;default <span class="literal">nil</span> <span class="symbol">:family</span> <span class="string">&quot;Fira Code&quot;</span> <span class="symbol">:height</span> <span class="number">120</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> &#x27;c-mode-hook &#x27;my-setup-fira-code)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c++-mode-hook &#x27;my-setup-fira-code)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c-ts-mode-hook &#x27;my-setup-fira-code)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c++-ts-mode-hook &#x27;my-setup-fira-code)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> ligature</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">ligature-set-ligatures</span> &#x27;prog-mode &#x27;(<span class="string">&quot;www&quot;</span> <span class="string">&quot;**&quot;</span> <span class="string">&quot;***&quot;</span> <span class="string">&quot;**/&quot;</span> <span class="string">&quot;*&gt;&quot;</span> <span class="string">&quot;*/&quot;</span> <span class="string">&quot;//&quot;</span> <span class="string">&quot;&amp;&amp;&quot;</span> <span class="string">&quot;||&quot;</span> <span class="string">&quot;==&quot;</span> <span class="string">&quot;===&quot;</span> <span class="string">&quot;!=&quot;</span> <span class="string">&quot;!==&quot;</span> <span class="string">&quot;=&gt;&quot;</span> <span class="string">&quot;-&gt;&quot;</span>))</span><br><span class="line">  <span class="comment">;; 只在 C/C++ 模式下启用连体字</span></span><br><span class="line">  (<span class="name">add-hook</span> &#x27;c-mode-hook (<span class="name">lambda</span> () (<span class="name">ligature-set-ligatures</span> &#x27;c-mode &#x27;(<span class="string">&quot;-&gt;&quot;</span> <span class="string">&quot;&amp;&amp;&quot;</span> <span class="string">&quot;||&quot;</span> <span class="string">&quot;==&quot;</span> <span class="string">&quot;!=&quot;</span>))))</span><br><span class="line">  (<span class="name">add-hook</span> &#x27;c++-mode-hook (<span class="name">lambda</span> () (<span class="name">ligature-set-ligatures</span> &#x27;c++-mode &#x27;(<span class="string">&quot;-&gt;&quot;</span> <span class="string">&quot;&amp;&amp;&quot;</span> <span class="string">&quot;||&quot;</span> <span class="string">&quot;==&quot;</span> <span class="string">&quot;!=&quot;</span>))))</span><br><span class="line">  (<span class="name">add-hook</span> &#x27;c-ts-mode-hook (<span class="name">lambda</span> () (<span class="name">ligature-set-ligatures</span> &#x27;c-mode &#x27;(<span class="string">&quot;-&gt;&quot;</span> <span class="string">&quot;&amp;&amp;&quot;</span> <span class="string">&quot;||&quot;</span> <span class="string">&quot;==&quot;</span> <span class="string">&quot;!=&quot;</span>))))</span><br><span class="line">  (<span class="name">add-hook</span> &#x27;c++-ts-mode-hook (<span class="name">lambda</span> () (<span class="name">ligature-set-ligatures</span> &#x27;c++-mode &#x27;(<span class="string">&quot;-&gt;&quot;</span> <span class="string">&quot;&amp;&amp;&quot;</span> <span class="string">&quot;||&quot;</span> <span class="string">&quot;==&quot;</span> <span class="string">&quot;!=&quot;</span>))))</span><br><span class="line">  <span class="comment">;; 全局启用连体字支持，但只在特定模式中生效</span></span><br><span class="line">  (<span class="name">global-ligature-mode</span> <span class="literal">t</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">custom-set-variables</span></span><br><span class="line"> <span class="comment">;; custom-set-variables was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won&#x27;t work right.</span></span><br><span class="line"> &#x27;(package-selected-packages</span><br><span class="line">   &#x27;(page-break-lines dashboard breadcrumb all-the-icons treesit-ispell treesit-auto tree-sitter neotree format-all flycheck exec-path-from-shell company)))</span><br><span class="line">(<span class="name">custom-set-faces</span></span><br><span class="line"> <span class="comment">;; custom-set-faces was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won&#x27;t work right.</span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure></p><h2 id="nox-无GUI"><a href="#nox-无GUI" class="headerlink" title="nox (无GUI)"></a>nox (无GUI)</h2><p>.emacs<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> inhibit-startup-message <span class="literal">t</span>)</span><br><span class="line">(<span class="name">setq</span> initial-scratch-message <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">menu-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line">(<span class="name">setq</span> ring-bell-function &#x27;ignore)</span><br><span class="line">(<span class="name">global-display-line-numbers-mode</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="name">defalias</span> &#x27;yes-or-no-p &#x27;y-or-n-p)</span><br><span class="line">(<span class="name">setq</span> make-backup-files <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">setq</span> create-lockfiles <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">prefer-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">setq</span> locale-coding-system &#x27;utf-8)</span><br><span class="line">(<span class="name">set-keyboard-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-selection-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">set-terminal-coding-system</span> &#x27;utf-8)</span><br><span class="line">(<span class="name">setq-default</span> buffer-file-coding-system &#x27;utf-8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">setq-default</span> indent-tabs-mode <span class="literal">nil</span>)</span><br><span class="line">(<span class="name">setq</span> find-file-encoding &#x27;auto)</span><br><span class="line">(<span class="name">setq-default</span> coding-system-for-read &#x27;utf-8)</span><br><span class="line">(<span class="name">setq-default</span> coding-system-for-write &#x27;utf-8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> package</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">add-to-list</span> &#x27;package-archives &#x27;(<span class="string">&quot;melpa&quot;</span> . <span class="string">&quot;https://melpa.org/packages/&quot;</span>))</span><br><span class="line">  (<span class="name">unless</span> (<span class="name">bound-and-true-p</span> package--initialized)</span><br><span class="line">    (<span class="name">package-initialize</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> use-package-always-ensure <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> exec-path-from-shell</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">when</span> (<span class="name">memq</span> window-system &#x27;(mac ns x))</span><br><span class="line">    (<span class="name">exec-path-from-shell-initialize</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> tree-sitter</span><br><span class="line">  <span class="symbol">:when</span> (<span class="name">and</span> (<span class="name">fboundp</span> &#x27;treesit-available-p)</span><br><span class="line">         (<span class="name">treesit-available-p</span>))</span><br><span class="line">  <span class="symbol">:config</span> (<span class="name">setq</span> treesit-font-lock-level <span class="number">4</span>)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> treesit-language-source-alist</span><br><span class="line">    &#x27;((bash       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-bash&quot;</span>))</span><br><span class="line">      (c          . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-c&quot;</span>))</span><br><span class="line">      (cpp        . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-cpp&quot;</span>))</span><br><span class="line">      (python     . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-python&quot;</span>))</span><br><span class="line">      (rust       . (<span class="string">&quot;https://github.com/tree-sitter/tree-sitter-rust&quot;</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> &#x27;eglot)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> eglot-server-programs</span><br><span class="line">      &#x27;(((c++-mode c-mode) . (<span class="string">&quot;clangd&quot;</span>))</span><br><span class="line">        ((rust-mode) . (<span class="string">&quot;rust-analyzer&quot;</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">add-hook</span> &#x27;c-mode-hook &#x27;eglot-ensure)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;c++-mode-hook &#x27;eglot-ensure)</span><br><span class="line">(<span class="name">add-hook</span> &#x27;rust-mode-hook &#x27;eglot-ensure)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> company <span class="symbol">:ensure</span> <span class="literal">t</span> <span class="symbol">:defer</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">after-init</span> . global-company-mode))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> format-all</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:commands</span> format-all-mode</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . format-all-mode)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq-default</span> format-all-formatters</span><br><span class="line">                &#x27;((<span class="string">&quot;C&quot;</span> (clang-format)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">global-set-key</span> (<span class="name">kbd</span> <span class="string">&quot;C-x f&quot;</span>) &#x27;format-all-buffer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">custom-set-variables</span></span><br><span class="line"> <span class="comment">;; custom-set-variables was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won&#x27;t work right.</span></span><br><span class="line"> &#x27;(package-selected-packages</span><br><span class="line">   &#x27;(page-break-lines dashboard breadcrumb all-the-icons treesit-ispell treesit-auto tree-sitter neotree format-all flycheck exec-path-from-shell company)))</span><br><span class="line">(<span class="name">custom-set-faces</span></span><br><span class="line"> <span class="comment">;; custom-set-faces was added by Custom.</span></span><br><span class="line"> <span class="comment">;; If you edit it by hand, you could mess it up, so be careful.</span></span><br><span class="line"> <span class="comment">;; Your init file should contain only one such instance.</span></span><br><span class="line"> <span class="comment">;; If there is more than one, they won&#x27;t work right.</span></span><br><span class="line"> )</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下基于edk2的UEFI开发环境搭建</title>
      <link href="/posts/42853/"/>
      <url>/posts/42853/</url>
      
        <content type="html"><![CDATA[<h1 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h1><p>这是我的硬件环境及操作系统</p><p><img src="https://cdn.jsdelivr.net/gh/even629/myPicGo/pc_environment.png" alt="硬件环境"></p><h2 id="下载-edk2-源码"><a href="#下载-edk2-源码" class="headerlink" title="下载 edk2 源码"></a>下载 edk2 源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装需要的软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install git</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/UEFI</span><br><span class="line"><span class="built_in">cd</span> UEFI</span><br><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://github.com/tianocore/edk2.git&quot;</span></span><br><span class="line"><span class="built_in">cd</span> edk2</span><br><span class="line"><span class="comment"># 使用这个分支</span></span><br><span class="line">git checkout origin/stable/202408</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">git branch</span><br><span class="line"><span class="comment"># 查看子模块是否都已正确初始化，如果子模块未下载完毕，编译时会有一些问题</span></span><br><span class="line">git submodule status</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="comment"># 下载edk2-libc的代码，这个主要是为了在UEFI开发中使用c标准库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tianocore/edk2-libc.git</span><br><span class="line"><span class="comment"># 创建code文件夹用于存放我们自己的代码</span></span><br><span class="line"><span class="built_in">mkdir</span> -p code</span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载一些基本软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install python3 python3-distutils uuid-dev build-essential bison flex nasm acpica-tools gcc</span><br><span class="line"><span class="comment"># 安装arm的编译器, 这里主要是为了编译aarch64的</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/UEFI/toolchain</span><br><span class="line"><span class="built_in">cd</span> ~/UEFI/toolchain</span><br><span class="line">wget https://developer.arm.com/-/media/Files/downloads/gnu-a/8.2-2019.01/gcc-arm-8.2-2019.01-x86_64-aarch64-elf.tar.xz</span><br><span class="line">tar -xf gcc-arm-8.2-2019.01-x86_64-aarch64-elf.tar.xz</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p>下面来通过一个例子 HelloWorld 来实现实现编译 UEFI 代码到目标平台为 x64 或 aarch64, 并支持在 Emulator 和 qemu 中运行, 最后用 gdb 调试程序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> HelloWorld.dsc</span><br><span class="line"><span class="built_in">touch</span> HelloWorld.inf</span><br><span class="line"><span class="built_in">touch</span> HelloWorld.c</span><br><span class="line"><span class="comment"># 这个命令行工具可以生成uuid, 后面的dsc和inf中的uuid都是这样生成的</span></span><br><span class="line">uuidgen</span><br></pre></td></tr></table></figure><p><strong>HelloWorld.dsc</strong></p><p>DSC文件是包描述文件，其中<strong>Defines</strong>中的所有字段都是强制性的。</p><p>对于LibraryClasses中的路径可以通过以下命令查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> edk2</span><br><span class="line"><span class="comment"># 以UefiApplicationEntryPoint为例</span></span><br><span class="line">grep UefiApplicationEntryPoint -r ./ --include=*.inf | grep LIBRARY_CLASS</span><br><span class="line"><span class="comment"># 通过GUID查找</span></span><br><span class="line">grep -i 752F3136 -r ./ --exclude-dir=Build</span><br></pre></td></tr></table></figure><p>LibraryClasses的格式是<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LibraryClassName|Path/To/LibInstanceName.inf</span><br></pre></td></tr></table></figure></p><p>对于DSC文件的完整解释，参考以下链接：<br>   <div class="tag link"><a class="link-card" title="INF-Specification" href="https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/"><div class="left"><img src="https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/gitbook/images/favicon.ico"/></div><div class="right"><p class="text">INF-Specification</p><p class="url">https://tianocore-docs.github.io/edk2-DscSpecification/release-1.28/</p></div></a></div></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Defines]</span></span><br><span class="line">  <span class="attr">DSC_SPECIFICATION</span>         = <span class="number">0</span>x0001001A</span><br><span class="line">  <span class="attr">PLATFORM_GUID</span>             = c08977d4-<span class="number">6</span>e87-<span class="number">42</span>f6-bf5c-<span class="number">4</span>d41cfe7ba53</span><br><span class="line">  <span class="attr">PLATFORM_VERSION</span>          = <span class="number">0.01</span></span><br><span class="line">  <span class="attr">PLATFORM_NAME</span>             = HelloWorld</span><br><span class="line">  <span class="attr">SKUID_IDENTIFIER</span>          = DEFAULT</span><br><span class="line">  <span class="attr">SUPPORTED_ARCHITECTURES</span>   = AARCH64|X64</span><br><span class="line">  <span class="attr">BUILD_TARGETS</span>             = DEBUG|RELEASE|NOOPT</span><br><span class="line">  <span class="attr">OUTPUT_DIRECTORY</span>          = $(PKG_OUTPUT_DIR)</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses]</span></span><br><span class="line">  BaseLib|MdePkg/Library/BaseLib/BaseLib.inf</span><br><span class="line">  BaseMemoryLib|MdePkg/Library/BaseMemoryLib/BaseMemoryLib.inf</span><br><span class="line">  DevicePathLib|MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf</span><br><span class="line">  MemoryAllocationLib|MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf</span><br><span class="line">  PrintLib|MdePkg/Library/BasePrintLib/BasePrintLib.inf</span><br><span class="line">  UefiLib|MdePkg/Library/UefiLib/UefiLib.inf</span><br><span class="line">  UefiHiiServicesLib|MdeModulePkg/Library/UefiHiiServicesLib/UefiHiiServicesLib.inf</span><br><span class="line">  ShellCEntryLib|ShellPkg/Library/UefiShellCEntryLib/UefiShellCEntryLib.inf</span><br><span class="line">  HiiLib|MdeModulePkg/Library/UefiHiiLib/UefiHiiLib.inf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  UefiApplicationEntryPoint|MdePkg/Library/UefiApplicationEntryPoint/UefiApplicationEntryPoint.inf</span><br><span class="line">  UefiBootServicesTableLib|MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf</span><br><span class="line">  UefiRuntimeServicesTableLib|MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf</span><br><span class="line"></span><br><span class="line">  DebugLib|MdePkg/Library/BaseDebugLibNull/BaseDebugLibNull.inf</span><br><span class="line">  PcdLib|MdePkg/Library/BasePcdLibNull/BasePcdLibNull.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses.ARM,LibraryClasses.AARCH64]</span></span><br><span class="line">  NULL|ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf</span><br><span class="line">  NULL|MdePkg/Library/BaseStackCheckLib/BaseStackCheckLib.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[LibraryClasses.X64]</span></span><br><span class="line">  RegisterFilterLib|MdePkg/Library/RegisterFilterLibNull/RegisterFilterLibNull.inf</span><br><span class="line"></span><br><span class="line"><span class="section">[Components]</span></span><br><span class="line">  HelloWorld.inf</span><br></pre></td></tr></table></figure><p><strong>HelloWorld.inf</strong></p><p>INF文件是edk2 app的配置文件，其中</p><ul><li>[Defines] 该节定义了一些模块的基本信息<ul><li>BASE_NAME app的名称</li><li>FILE_GUID 可以通过命令uuidgen生成，UEFI通过GUID来区分不同的模块</li><li>MODULE_TYPE 这里填UEFI_APPLICATION</li><li>ENTRY_POINT c代码中的主函数的名称</li></ul></li><li>[Sources] 模块的源代码，一般是.c,.h文件</li><li>[Packages] 需要使用到的包</li><li>[LibraryClasses] 需要使用到的库</li></ul><p>对于INF文件的完整解释，参考以下链接：<br>   <div class="tag link"><a class="link-card" title="INF-Specification" href="https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/"><div class="left"><img src="https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/gitbook/images/favicon.ico"/></div><div class="right"><p class="text">INF-Specification</p><p class="url">https://tianocore-docs.github.io/edk2-InfSpecification/release-1.27/</p></div></a></div></p><p>下面是定义的一个简单的模块<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Variables defined to be used during the build process</span></span><br><span class="line"><span class="section">[Defines]</span></span><br><span class="line">  <span class="attr">INF_VERSION</span>       = <span class="number">1.25</span></span><br><span class="line">  <span class="attr">BASE_NAME</span>         = HelloWorld</span><br><span class="line">  <span class="attr">FILE_GUID</span>         = <span class="number">5455334</span>b-dbd9-<span class="number">4</span>f95-b6ed-<span class="number">5</span>ae261a6a0c1</span><br><span class="line">  <span class="attr">MODULE_TYPE</span>       = UEFI_APPLICATION</span><br><span class="line">  <span class="attr">VERSION_STRING</span>    = <span class="number">1.0</span></span><br><span class="line">  <span class="attr">ENTRY_POINT</span>       = UefiMain</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source code</span></span><br><span class="line"><span class="section">[Sources]</span></span><br><span class="line">  HelloWorld.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required packages</span></span><br><span class="line"><span class="section">[Packages]</span></span><br><span class="line">  MdePkg/MdePkg.dec            <span class="comment"># Contains Uefi and UefiLib</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Required Libraries</span></span><br><span class="line"><span class="section">[LibraryClasses]</span></span><br><span class="line">  UefiApplicationEntryPoint    <span class="comment"># Uefi application entry point</span></span><br><span class="line">  UefiLib                      <span class="comment"># UefiLib</span></span><br><span class="line">  UefiBootServicesTableLib</span><br></pre></td></tr></table></figure></p><p><strong>HelloWorld.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">UefiMain</span><span class="params">(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable)</span> &#123;</span><br><span class="line">  Print(<span class="string">L&quot;Hello World!!!\n&quot;</span>);</span><br><span class="line">  SystemTable-&gt;BootServices-&gt;Stall(<span class="number">10000000</span>);</span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译脚本"><a href="#编译脚本" class="headerlink" title="编译脚本"></a>编译脚本</h2><p>首先我们需要创建一个脚本，用于设置环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> env.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x env.sh</span><br></pre></td></tr></table></figure><p><strong>env.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 项目名称,也是源代码的源文件目录</span></span><br><span class="line"><span class="built_in">export</span> PROJ_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># dsc文件名</span></span><br><span class="line"><span class="built_in">export</span> DSC_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># inf文件名</span></span><br><span class="line"><span class="built_in">export</span> INF_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># 也是编译生成的*.efi的名字，在inf的BASE_NAME中定义</span></span><br><span class="line"><span class="built_in">export</span> INF_BASE_NAME=<span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line"><span class="comment"># UEFI 工作目录</span></span><br><span class="line"><span class="built_in">export</span> UEFI_WORKSPACE=<span class="string">&quot;<span class="variable">$HOME</span>/UEFI&quot;</span></span><br><span class="line"><span class="comment"># EDK II 路径</span></span><br><span class="line"><span class="built_in">export</span> EDK_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/edk2&quot;</span></span><br><span class="line"><span class="comment"># EDK II libc路径</span></span><br><span class="line"><span class="built_in">export</span> EDK_LIBC_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/edk2-libc&quot;</span></span><br><span class="line"><span class="comment"># 应用代码路径</span></span><br><span class="line"><span class="built_in">export</span> APP_PATH=<span class="string">&quot;<span class="variable">$UEFI_WORKSPACE</span>/code/<span class="variable">$PROJ_NAME</span>&quot;</span></span><br><span class="line"><span class="comment"># 构建输出目录</span></span><br><span class="line"><span class="built_in">export</span> PKG_OUTPUT_DIR=<span class="string">&quot;<span class="variable">$APP_PATH</span>/Build&quot;</span></span><br><span class="line"><span class="comment"># 模拟器路径</span></span><br><span class="line"><span class="built_in">export</span> EMULATOR_PATH=<span class="string">&quot;<span class="variable">$EDK_PATH</span>/Build/EmulatorX64/DEBUG_GCC5/X64&quot;</span></span><br><span class="line"><span class="comment"># 包路径设置，支持多个路径，用冒号分隔</span></span><br><span class="line"><span class="built_in">export</span> PACKAGES_PATH=<span class="string">&quot;<span class="variable">$EDK_PATH</span>:<span class="variable">$EDK_LIBC_PATH</span>:<span class="variable">$APP_PATH</span>&quot;</span></span><br><span class="line"><span class="comment"># 指定 Python 解释器</span></span><br><span class="line"><span class="built_in">export</span> PYTHON_COMMAND=<span class="string">&quot;/usr/bin/python3&quot;</span></span><br><span class="line"><span class="comment"># 确认设置完成</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Environment variables for <span class="variable">$PROJ_NAME</span> project are configured.&quot;</span></span><br></pre></td></tr></table></figure><p>接下写一个脚本实现编译我们的代码到 x64 目标平台</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> build-x64.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x build-x64.sh</span><br></pre></td></tr></table></figure><p><strong>build-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"></span><br><span class="line"><span class="comment"># Building BaseTools</span></span><br><span class="line">make -C <span class="variable">$EDK_PATH</span>/BaseTools</span><br><span class="line"><span class="comment"># 这里设置-b参数为DEBUG，需要部署时用RELEASE</span></span><br><span class="line"><span class="comment"># -p --platform=</span></span><br><span class="line"><span class="comment"># -m --module=</span></span><br><span class="line"><span class="comment"># -a --arch=</span></span><br><span class="line"><span class="comment"># -b --buildtarget=</span></span><br><span class="line"><span class="comment"># -t --taggname=</span></span><br><span class="line">build -p <span class="variable">$APP_PATH</span>/<span class="variable">$DSC_NAME</span>.dsc -m <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>.inf -a X64 -t GCC5 -b DEBUG -D PKG_OUTPUT_DIR=<span class="variable">$PKG_OUTPUT_DIR</span></span><br></pre></td></tr></table></figure><p>编译到 aarch64 平台同理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> build-aarch64.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x build-aarch64.sh</span><br></pre></td></tr></table></figure><p><strong>build-aarch64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5_AARCH64_PREFIX=<span class="variable">$UEFI_WORKSPACE</span>/toolchain/gcc-arm-8.2-2019.01-x86_64-aarch64-elf/bin/aarch64-elf-</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"></span><br><span class="line"><span class="comment"># Building BaseTools</span></span><br><span class="line">make -C <span class="variable">$EDK_PATH</span>/BaseTools</span><br><span class="line"></span><br><span class="line">build -p <span class="variable">$APP_PATH</span>/<span class="variable">$DSC_NAME</span>.dsc -m <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>.inf -a AARCH64 -t GCC5 -b DEBUG -D PKG_OUTPUT_DIR=<span class="variable">$PKG_OUTPUT_DIR</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="Emulator-运行"><a href="#Emulator-运行" class="headerlink" title="Emulator 运行"></a>Emulator 运行</h3><p>最后我们写一个脚本在 edk2 自带的模拟器上运行一下, 注意<strong>这里需要你有 gui 环境</strong>, 如果是只有命令行则跳过这一步, 看下面一节用 qemu 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> run.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x run.sh</span><br></pre></td></tr></table></figure><p><strong>run.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="comment"># Emulator编译,编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -p <span class="variable">$EDK_PATH</span>/EmulatorPkg/EmulatorPkg.dsc -t GCC5 -a X64</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p <span class="variable">$EMULATOR_PATH</span>/UEFI_Disk</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.efi <span class="variable">$EMULATOR_PATH</span>/UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EMULATOR_PATH</span></span><br><span class="line">./Host</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="qemu-运行"><a href="#qemu-运行" class="headerlink" title="qemu 运行"></a>qemu 运行</h3><p>首先编译并安装 qemu,这里我选择 8.1.5 的版本, 如果你的没有达到预期的效果可以考虑使用这个版本的 qemu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/qemu-project/qemu.git</span><br><span class="line"><span class="built_in">cd</span> qemu</span><br><span class="line">git checkout stable-8.1</span><br><span class="line"><span class="built_in">sudo</span> apt install python3-venv python3-pip python3-setuptools python3-sphinx ninja-build pkg-config libglib2.0-dev libpixman-1-dev</span><br><span class="line"><span class="comment"># x86_64</span></span><br><span class="line">./configure --target-list=x86_64-softmmu</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="comment"># aarch64</span></span><br><span class="line">./configure --target-list=aarch64-softmmu</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure><p>接下来写脚本用 qemu 运行, 这里一些参数是为下一节用 gdb 调试程序用的, 但如果你只是想用 qemu 运行一下也不影响</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> debug.sh</span><br><span class="line"><span class="built_in">chmod</span> a+x debug.sh</span><br></pre></td></tr></table></figure><p><strong>debug-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5=/usr/bin/gcc</span><br><span class="line"><span class="comment"># 编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -a X64 -p OvmfPkg/OvmfPkgX64.dsc -t GCC5 -b DEBUG <span class="comment">#-D SOURCE_DEBUG_ENABLE</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$APP_PATH</span></span><br><span class="line"><span class="built_in">mkdir</span> -p _ovmf_dbg</span><br><span class="line"><span class="built_in">cd</span> _ovmf_dbg</span><br><span class="line"><span class="built_in">rm</span> -f debug.log</span><br><span class="line"><span class="comment"># 与ubuntu22.04软件源默认的qemu不兼容，需要升级qemu版本到v8.1.5</span></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$EDK_PATH</span>/Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd ./</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p UEFI_Disk</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.efi ./UEFI_Disk/</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/Build/DEBUG_GCC5/X64/<span class="variable">$INF_BASE_NAME</span>.debug ./UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 启用 GDB 调试，默认监听在 127.0.0.1:1234</span></span><br><span class="line"><span class="comment"># -bios OVMF.fd，指定 OVMF 固件文件，这是一个支持 UEFI 的 QEMU 固件。</span></span><br><span class="line"><span class="comment"># -debugcon file:debug.log 将调试输出重定向到 debug.log 文件。</span></span><br><span class="line"><span class="comment"># -global isa-debugcon.iobase=0x402 配置调试控制台的 I/O 基地址。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-s \</span><br><span class="line">-bios OVMF.fd \</span><br><span class="line">-drive format=raw,file=fat:rw:UEFI_Disk/ \</span><br><span class="line">-net none \</span><br><span class="line">-debugcon file:debug.log \</span><br><span class="line">-global isa-debugcon.iobase=0x402 \</span><br><span class="line">-nographic</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个脚本首先会编译OVMF(Open Virtual Machine Firmware)，OVMF 是一个基于 EDKII 的固件，可以在 qemu x86-64 虚拟机下运行。这使得调试和实验 UEFI 固件变得更加容易；无论是用于测试操作系统启动，还是使用（内置的）EFI shell。</p><p>OVMF 固件（用于 QEMU 的 UEFI 实现）被分为两个文件：</p><ul><li>OVMF_CODE.fd：包含实际的 UEFI 固件。</li><li>OVMF_VARS.fd：作为一个“模板”用于模拟持久化的 NVRAM 存储。<br>所有虚拟机实例可以共享来自 ovmf 包的系统范围内的只读 OVMF_CODE.fd 文件，但每个实例都需要一个私有的、可写的 OVMF_VARS.fd 副本。<br>在qemu中，可以分别指定OVMF_CODE.fd和OVMF_VARS.fd，也可以采用简化的写法：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别指定</span></span><br><span class="line">qemu-system-x86_64 -drive <span class="keyword">if</span>=pflash,format=raw,<span class="built_in">readonly</span>,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF_CODE.fd \</span><br><span class="line">                     -drive <span class="keyword">if</span>=pflash,format=raw,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF_VARS.fd \</span><br><span class="line">                     -nographic \</span><br><span class="line">                     -net none</span><br><span class="line"><span class="comment"># 简化写法</span></span><br><span class="line">qemu-system-x86_64 -drive <span class="keyword">if</span>=pflash,format=raw,file=Build/OvmfX64/RELEASE_GCC5/FV/OVMF.fd \</span><br><span class="line">                     -nographic \</span><br><span class="line">                     -net none</span><br></pre></td></tr></table></figure></li></ul><p>运行 debug-x64.sh, 不出意外会出现如下界面, 即 UEFI 的 Shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">Press ESC <span class="keyword">in</span> 2 seconds to skip startup.nsh or any other key to <span class="built_in">continue</span>.</span><br><span class="line">Shell&gt;</span><br></pre></td></tr></table></figure><p>在这个 shell 中输入 fs0:(注意这有一个英文冒号), 然后输入 HelloWorld.efi 运行我们的程序,预期输出”Hello World!!!”</p><div class="tip warning faa-horizontal animated"><p>在Shell如果按BackSpace没有反应，可以按Ctrl+H代替</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1,0x1)/Ata(0x0)</span><br><span class="line">Press ESC <span class="keyword">in</span> 2 seconds to skip startup.nsh or any other key to <span class="built_in">continue</span>.</span><br><span class="line">Shell&gt; fs0:</span><br><span class="line">FS0:\&gt; <span class="built_in">ls</span></span><br><span class="line">Directory of: FS0:\</span><br><span class="line">01/08/2025  22:23                  82  gdb_commands.txt</span><br><span class="line">01/10/2025  20:22             184,544  HelloWorld.debug</span><br><span class="line">01/10/2025  20:22               5,760  HelloWorld.efi</span><br><span class="line">01/10/2025  12:22               1,391  NvVars</span><br><span class="line">          4 File(s)     191,777 bytes</span><br><span class="line">          0 Dir(s)</span><br><span class="line">FS0:\&gt; HelloWorld.efi</span><br><span class="line">Hello World!!!</span><br></pre></td></tr></table></figure><p>退出qemu按<strong>CTRL+A - X</strong></p><p>下面是aarch64版本的<br><strong>debug-aarch64.sh</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;Exiting&quot;</span> INT</span><br><span class="line"></span><br><span class="line"><span class="comment"># environment variables</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GCC5_AARCH64_PREFIX=<span class="variable">$UEFI_WORKSPACE</span>/toolchain/gcc-arm-8.2-2019.01-x86_64-aarch64-elf/bin/aarch64-elf-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译过一次就不用再编译了</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$EDK_PATH</span></span><br><span class="line"><span class="built_in">source</span> edksetup.sh</span><br><span class="line">build -a AARCH64 -p ArmVirtPkg/ArmVirtQemu.dsc -t GCC5 -b RELEASE </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span></span><br><span class="line"><span class="built_in">mkdir</span> -p _armvirt_dbg</span><br><span class="line"><span class="built_in">cd</span> _armvirt_dbg</span><br><span class="line"><span class="built_in">rm</span> -f debug.log</span><br><span class="line"><span class="comment"># 与ubuntu22.04软件源默认的qemu不兼容，需要升级qemu版本到v8.1.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$EDK_PATH</span>/Build/ArmVirtQemu-AARCH64/RELEASE_GCC5/FV/QEMU_EFI.fd ./</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p UEFI_Disk</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>/Build/DEBUG_GCC5/AARCH64/<span class="variable">$INF_BASE_NAME</span>.efi ./UEFI_Disk/</span><br><span class="line"><span class="built_in">cp</span> <span class="variable">$APP_PATH</span>/<span class="variable">$INF_NAME</span>/Build/DEBUG_GCC5/AARCH64/<span class="variable">$INF_BASE_NAME</span>.debug ./UEFI_Disk/</span><br><span class="line"></span><br><span class="line"><span class="comment">#qemu命令</span></span><br><span class="line">qemu-system-aarch64 \</span><br><span class="line">-machine virt,kernel_irqchip=on,gic-version=3 \</span><br><span class="line">-cpu cortex-a57 -m 1G  \</span><br><span class="line">-drive format=raw,file=fat:rw:UEFI_Disk/ \</span><br><span class="line">-bios QEMU_EFI.fd \</span><br><span class="line">-net none \</span><br><span class="line">-nographic </span><br></pre></td></tr></table></figure></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>gdb 调试 UEFI 程序稍稍有点麻烦, 但可以用脚本自动化一些操作, 总体流程如下:</p><ol><li>运行 debug.sh, 然后进入 UEFI Shell 中运行一下代码(和上一小节用 qemu 运行一样的操作, 这里主要是为了在_ovmf_dbg/debug.log 中拿到 driver 启动的地址)</li><li>开另一个 terminal, 运行下面的脚本 addr.sh</li><li>在_ovmf_dbg/UEFI_Disk 目录下运行 gdb -x gdb_commands.txt</li><li>在 gdb 里面打断点, 比如 break UefiMain</li><li>添加 gdb 调试 target remote localhost:1234</li><li>运行,输入 c 跳到第一个断点位置</li><li>在 UEFI Shell 中运行你的代码</li></ol><p><strong>addr-x64.sh</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> env.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> _ovmf_dbg</span><br><span class="line"></span><br><span class="line">logfile=<span class="string">&quot;debug.log&quot;</span></span><br><span class="line"></span><br><span class="line">line=$(grep -oP <span class="string">&quot;Loading driver at 0x[0-9a-fA-F]+ EntryPoint=0x[0-9a-fA-F]+ <span class="variable">$INF_BASE_NAME</span>\.efi&quot;</span> <span class="string">&quot;<span class="variable">$logfile</span>&quot;</span> | <span class="built_in">tail</span> -n 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式提取两个地址</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$line</span> =~ Loading\ driver\ at\ (0x[0-9a-fA-F]+)\ EntryPoint=(0x[0-9a-fA-F]+)\ <span class="variable">$INF_BASE_NAME</span>\.efi ]]; <span class="keyword">then</span></span><br><span class="line">    address0=<span class="string">&quot;<span class="variable">$&#123;BASH_REMATCH[1]&#125;</span>&quot;</span></span><br><span class="line">    address1=<span class="string">&quot;<span class="variable">$&#123;BASH_REMATCH[2]&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Loading driver at <span class="variable">$address0</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;EntryPoint=<span class="variable">$address1</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: No matching line found, maybe you need to run <span class="variable">$INF_BASE_NAME</span> in qemu first&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> UEFI_Disk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 objdump 获取文件头信息并提取 .text 和 .data 的 File off</span></span><br><span class="line">text_offset=$(objdump -h <span class="string">&quot;<span class="variable">$INF_BASE_NAME</span>.efi&quot;</span> | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  /\.text/ &#123;print $6&#125;  # 提取 .text 的 File off</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line"></span><br><span class="line">data_offset=$(objdump -h <span class="string">&quot;<span class="variable">$INF_BASE_NAME</span>.efi&quot;</span> | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">  /\.data/ &#123;print $6&#125;  # 提取 .data 的 File off</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出提取的结果</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;.text file off: <span class="variable">$text_offset</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;.data file off: <span class="variable">$data_offset</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算</span></span><br><span class="line">text_addr=$((<span class="number">0</span>x<span class="variable">$&#123;address0#0x&#125;</span> + <span class="number">0</span>x<span class="variable">$&#123;text_offset&#125;</span>))</span><br><span class="line">data_addr=$((<span class="number">0</span>x<span class="variable">$&#123;address0#0x&#125;</span> + <span class="number">0</span>x<span class="variable">$&#123;data_offset&#125;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果时使用16进制格式</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;text_addr: 0x%X   data_addr: 0x%X\n&quot;</span> <span class="variable">$text_addr</span> <span class="variable">$data_addr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf gdb_commands.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 gdb_commands.txt 文件并写入内容</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOL &gt; gdb_commands.txt</span></span><br><span class="line"><span class="string">file $&#123;INF_BASE_NAME&#125;.efi</span></span><br><span class="line"><span class="string">add-symbol-file $&#123;INF_BASE_NAME&#125;.debug 0x$(printf &quot;%X&quot; $text_addr) -s .data 0x$(printf &quot;%X&quot; $data_addr)</span></span><br><span class="line"><span class="string">EOL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出文件内容确认</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;gdb_commands.txt has been created with the following content:&quot;</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">cat</span> gdb_commands.txt</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;run the following command to debug&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;cd _ovmf_dgb/UEFI_Disk&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;gdb -x gdb_commands.txt&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;break UefiMain&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;target remote localhost:1234&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="HelloStd"><a href="#HelloStd" class="headerlink" title="HelloStd"></a>HelloStd</h1><p>另一个例子, 使用 edk-libc 实现在 UEFI 中调用标准 c 库程序</p><p>可以复制 HelloWorld.dsc，在此基础上修改 guid,然后记得修改[<strong>Components</strong>]为 HelloWorld.inf, 最后在 dsc 的[<strong>LibraryClasses</strong>]最后添加一行下面的代码</p><p><strong>HelloStd.dsc</strong></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!include StdLib/StdLib.inc</span><br></pre></td></tr></table></figure><p>接下来是 HelloStd.inf, 首先[<strong>Defines</strong>]中的 ENTRY_POINT 要改为 ShellCEntryLib, [<strong>Packages</strong>]中添加 StdLib/StdLib.dec 和 ShellPkg/ShellPkg.dec 这两个包, [<strong>LibraryClasses</strong>]中要去掉 UefiApplicationEntryPoint, 添加 LibC 和 LibStdio 这两个库, 下面是 HelloStd.inf 的声明</p><p><strong>HelloStd.inf</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Variables defined to be used during the build process</span></span><br><span class="line">[Defines]</span><br><span class="line">  INF_VERSION       = 1.25</span><br><span class="line">  BASE_NAME         = HelloStd</span><br><span class="line">  FILE_GUID         = d0956d2b-c033-45af-8ef2-76c9d30518ec</span><br><span class="line">  MODULE_TYPE       = UEFI_APPLICATION</span><br><span class="line">  VERSION_STRING    = 1.0</span><br><span class="line">  ENTRY_POINT       = ShellCEntryLib</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source code</span></span><br><span class="line">[Sources]</span><br><span class="line">  HelloStd.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required packages</span></span><br><span class="line">[Packages]</span><br><span class="line">  MdePkg/MdePkg.dec            <span class="comment"># Contains Uefi and UefiLib</span></span><br><span class="line">  StdLib/StdLib.dec</span><br><span class="line">  ShellPkg/ShellPkg.dec</span><br><span class="line"></span><br><span class="line"><span class="comment"># Required Libraries</span></span><br><span class="line">[LibraryClasses]</span><br><span class="line">  <span class="comment"># UefiApplicationEntryPoint    # Uefi application entry point</span></span><br><span class="line">  UefiLib                      <span class="comment"># UefiLib</span></span><br><span class="line">  LibC</span><br><span class="line">  LibStdio</span><br></pre></td></tr></table></figure><p>接着我们就可以在 UEFI 中调用标准库程序了</p><p><strong>HelloStd.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/ShellCEntryLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiBootServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Library/UefiRuntimeServicesTableLib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Uefi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(IN <span class="type">int</span> Argc, IN <span class="type">char</span> **Argv)</span> &#123;</span><br><span class="line">  EFI_TIME curTime;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;HelloStd!!!\n&quot;</span>);</span><br><span class="line">  gBS-&gt;Stall(<span class="number">2000</span>);</span><br><span class="line">  gRT-&gt;GetTime(&amp;curTime, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Current Time: %d-%d-%d %02d:%02d:%02d\n&quot;</span>, curTime.Year, curTime.Month,</span><br><span class="line">         curTime.Day, curTime.Hour, curTime.Minute, curTime.Second);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着更改下 env.sh 中的 PROJ_NAME, DSC_NAME, INF_NAME, INF_BASE_NAME 即可编译，运行调试等在 HelloWorld 中描述的操作</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/Kostr/UEFI-Lessons">UEFI-Lessons</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/luobing/uefi-practical-programming">UEFI编程实践 罗冰</a></div>]]></content>
      
      
      <categories>
          
          <category> UEFI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UEFI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emacs</title>
      <link href="/posts/28520/"/>
      <url>/posts/28520/</url>
      
        <content type="html"><![CDATA[<h2 id="常用选中指令"><a href="#常用选中指令" class="headerlink" title="常用选中指令"></a>常用选中指令</h2><div class="table-container"><table><thead><tr><th>指令</th><th>名字</th><th>效果</th></tr></thead><tbody><tr><td>M - h</td><td>mark-paragraph</td><td>选中段落</td></tr><tr><td>C - x + C - p</td><td>mark-page</td><td>选中整个页面</td></tr><tr><td>C - x h</td><td>mark-whole-buffer</td><td>选中整个编辑窗口内容</td></tr><tr><td>M - y</td><td>yank-pop</td><td>在C - y 之后使用，粘贴剪贴板内以前的项目</td></tr></tbody></table></div><h1 id="emacs配置文件在windows上的位置"><a href="#emacs配置文件在windows上的位置" class="headerlink" title="emacs配置文件在windows上的位置"></a>emacs配置文件在windows上的位置</h1><p>On Windows, the .emacs file may be called _emacs for backward compatibility with DOS and FAT filesystems where filenames could not start with a dot. Some users prefer to continue using such a name, because Explorer cannot create a file with a name starting with a dot, even though the filesystem and most other programs can handle it. In Emacs 22 and later, the init file may also be called.emacs.d/init.el. Many of the other files that are created by lisp packages are now stored in the.emacs.ddirectory too, so this keeps all your Emacs related files in one place.</p><p>All the files mentioned above should go in your HOME directory. The HOME directory is determined by following the steps below:</p><ol><li>If the environment variableHOME is set, use the directory it indicates.</li><li>If the registry entry HKCU\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates.</li><li>If the registry entry HKLM\SOFTWARE\GNU\Emacs\HOME is set, use the directory it indicates. Not recommended, as it results in users sharing the same HOME directory.</li><li>If C:.emacs exists, then use C:/. This is for backward compatibility, as previous versions defaulted to C:/ if HOME was not set.</li><li>Use the user’s AppData directory, usually a directory called Application Data under the user’s profile directory, the location of which varies according to Windows version and whether the computer is part of a domain.</li></ol><p>也就是说，Emacs的配置文件有三种格式：.emacs文件、_emacs文件或者.emacs.d目录下的init.el（22或者更高版本）文件，但是，不管哪种格式，必须放对正确的目录Emacs才能找到，这个正确的目录就是HOME目录。</p><p>熟悉Linux的朋友一般都知道home目录，简单的用~表示，或者用全路径表示为/home/<xxx>，其中xxx表示用户名字，所以，在Linux下将.emacs和.emacs.d放到这个目录下就行了，但windows没有home目录的概念，所以，Emacs就按如下方式来查找配置文件：</p><ol><li>如果设置了HOME环境变量，那么就用它的值作为home目录~</li><li>如果存在注册表键值HKCU\SOFTWARE\GNU\Emacs\HOME，就用它的值作为home目录~</li><li>如果存在注册表键值HKLM\SOFTWARE\GNU\Emacs\HOME，就用它的值作为home目录~（和2的区别是，2只是针对当前用户的注册表路径，3则是针对所有用户）</li><li>如果存在C:.emacs，就用C:\作为home目录~</li><li>如果以上都不存在的话，就使用<system root>\Users<user name>\AppData\Roaming作为home目录~（对于XP和较早windows用户，需要到Documents and Settings目录下去找）</li></ol><p><strong>从以上策略来看，1是比较好的做法，所以优先级也最高，应该是属于建议的方式，于是，新建一个HOME环境变量，将它的值设为想要放置Emacs配置文件的地方既可。</strong></p><p><strong>之前我是按以上方法设置的HOME目录，不过现在我后悔了，因为我发现不光是Emacs会使用HOME这个环境变量，会使用这个变量的至少还有以下程序或者插件：</strong></p><ol><li><strong>VIM，VIM会把_viminfo文件放在这个目录；</strong></li><li><strong>VIM的neocomplcache插件，它会放置一个.neocon目录进去；</strong></li><li><strong>firefox的pentadactyl插件，它会放一个pentadactyl目录进去。</strong></li></ol><p><strong>所以，个人建议：</strong></p><ol><li><strong>如果你希望有一个公共的目录存放这些配置，就像Linux下的~目录一样，那么设置HOME这个环境变量最适合不过；</strong></li><li><strong>如果你希望这个目录只存放Emacs的配置，那么，还是不要用HOME环境变量了，去注册表里面添加一个HOME键值吧。（至少我个人比较偏向于这个方式）</strong></li></ol><p>即：</p><p>在</p><p>HKEY_LOCAL_MACHINE\SOFTWARE下新建GNU项，在GNU项下新建Emacs项，然后Emacs新建一个字符串值，键为HOME,值为要存放的路径</p><h1 id="emacs-turials"><a href="#emacs-turials" class="headerlink" title="emacs turials"></a>emacs turials</h1><p>C：Ctrl</p><p>M: Alt</p><h2 id="退出Emacs"><a href="#退出Emacs" class="headerlink" title="退出Emacs"></a>退出Emacs</h2><p><strong>C-x C-c</strong></p><h2 id="退出一个正在运行中的命令"><a href="#退出一个正在运行中的命令" class="headerlink" title="退出一个正在运行中的命令"></a>退出一个正在运行中的命令</h2><p><strong>C-g</strong></p><h2 id="移动到下一屏"><a href="#移动到下一屏" class="headerlink" title="移动到下一屏"></a>移动到下一屏</h2><p><strong>C-v</strong></p><h2 id="移动到上一屏"><a href="#移动到上一屏" class="headerlink" title="移动到上一屏"></a>移动到上一屏</h2><p><strong>M-v</strong></p><h2 id="重绘屏幕，将光标所在的行置于屏幕的中央"><a href="#重绘屏幕，将光标所在的行置于屏幕的中央" class="headerlink" title="重绘屏幕，将光标所在的行置于屏幕的中央"></a>重绘屏幕，将光标所在的行置于屏幕的中央</h2><p><strong>C-l（这里是CTRL-L）</strong></p><h2 id="基本光标控制"><a href="#基本光标控制" class="headerlink" title="基本光标控制"></a>基本光标控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                   上一行 C-p</span><br><span class="line">                      :</span><br><span class="line">                      :</span><br><span class="line">向左移 C-b .... 目前光标位置 .... 向右移 C-f</span><br><span class="line">                      :</span><br><span class="line">                      :</span><br><span class="line">                 下一行 C-n</span><br></pre></td></tr></table></figure><p>每行文字都以一个“换行符”结束，“换行符”把行与行区分开来。（通常情况下，一个文件的最后一行会有一个换行符，但是 Emacs 不强制要求这一点。）</p><h3 id="上一行"><a href="#上一行" class="headerlink" title="上一行"></a>上一行</h3><p><strong>C-p</strong></p><p>previous</p><h3 id="下一行"><a href="#下一行" class="headerlink" title="下一行"></a>下一行</h3><p><strong>C-n</strong></p><p>next</p><h3 id="向左移一个字符"><a href="#向左移一个字符" class="headerlink" title="向左移一个字符"></a>向左移一个字符</h3><p><strong>C-b</strong></p><p>backward</p><h3 id="向右移一个字符"><a href="#向右移一个字符" class="headerlink" title="向右移一个字符"></a>向右移一个字符</h3><p><strong>C-f</strong></p><p>forward</p><h3 id="光标向前移动一个词"><a href="#光标向前移动一个词" class="headerlink" title="光标向前移动一个词"></a>光标向前移动一个词</h3><p>这里词对于英文来说是一个英文单词，对于中文来说是移动到下一个标点符号</p><p><strong>M-f</strong></p><h3 id="光标向后移动一个词"><a href="#光标向后移动一个词" class="headerlink" title="光标向后移动一个词"></a>光标向后移动一个词</h3><p><strong>M-b</strong></p><h3 id="将光标移动到行头"><a href="#将光标移动到行头" class="headerlink" title="将光标移动到行头"></a>将光标移动到行头</h3><p><strong>C-a</strong></p><p>ahead</p><h3 id="将光标移动到行尾"><a href="#将光标移动到行尾" class="headerlink" title="将光标移动到行尾"></a>将光标移动到行尾</h3><p><strong>C-e</strong></p><p>end</p><h3 id="将光标移动到一句的头部"><a href="#将光标移动到一句的头部" class="headerlink" title="将光标移动到一句的头部"></a>将光标移动到一句的头部</h3><p><strong>M-a</strong></p><h3 id="将光标移动到一句的尾部"><a href="#将光标移动到一句的尾部" class="headerlink" title="将光标移动到一句的尾部"></a>将光标移动到一句的尾部</h3><p><strong>M-e</strong></p><h3 id="将光标移动到所有文字的最开头"><a href="#将光标移动到所有文字的最开头" class="headerlink" title="将光标移动到所有文字的最开头"></a>将光标移动到所有文字的最开头</h3><p><strong>M-&lt;</strong>(实际上是alt+shift+,)</p><h3 id="将光标移动到所有文字的最末尾"><a href="#将光标移动到所有文字的最末尾" class="headerlink" title="将光标移动到所有文字的最末尾"></a>将光标移动到所有文字的最末尾</h3><p><strong>M-&gt;</strong>(实际上是alt+shift+.)</p><h3 id="光标选中多个文字"><a href="#光标选中多个文字" class="headerlink" title="光标选中多个文字"></a>光标选中多个文字</h3><p><strong>C-shift-r C-shift-f</strong></p><h2 id="移动行块"><a href="#移动行块" class="headerlink" title="移动行块"></a>移动行块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(use-package drag-stuff</span><br><span class="line">             :bind ((&quot;&lt;M-up&gt;&quot; . drag-stuff-up)</span><br><span class="line">                    (&quot;&lt;M-down&gt;&quot; . drag-stuff-down)))</span><br></pre></td></tr></table></figure><p><strong>M-向上箭头</strong></p><h2 id="互换顺序"><a href="#互换顺序" class="headerlink" title="互换顺序"></a>互换顺序</h2><h3 id="光标前后两个字符互换"><a href="#光标前后两个字符互换" class="headerlink" title="光标前后两个字符互换"></a>光标前后两个字符互换</h3><p><strong>C-t</strong></p><h3 id="光标前后两个单词互换"><a href="#光标前后两个单词互换" class="headerlink" title="光标前后两个单词互换"></a>光标前后两个单词互换</h3><p><strong>M-t</strong></p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><strong>M-w</strong></p><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><p><strong>C-w</strong></p><h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><p><strong>C-y</strong></p><p>yank</p><h2 id="参数控制"><a href="#参数控制" class="headerlink" title="参数控制"></a>参数控制</h2><p>大部分的Emacs命令接受数字参数，并且对于多数命令而言，这些数字参数的作用是<strong>指定命令的重复次数</strong></p><p><strong>先输入C-u ，然后输入数字作为参数，最后再输入命令</strong></p><p>如： C-u 8 C-f 会向前移动8个字符</p><p>某些Emacs命令接收数字参数当作他用</p><p>比如： C-v 和 M-v</p><p>当给定一一个参数时，他们将滚动指定的行数而不是屏数</p><p>即C-u 8 C-v会将光标向下移动8行</p><h2 id="窗格"><a href="#窗格" class="headerlink" title="窗格"></a>窗格</h2><h3 id="关闭多余的窗格"><a href="#关闭多余的窗格" class="headerlink" title="关闭多余的窗格"></a>关闭多余的窗格</h3><p><strong>C-x 1</strong></p><p>只保留一个窗格，也就是关掉其它所有的窗格，将保留的窗格扩大到整个屏幕，同时关掉所有其它窗格</p><p>有一系列命令是以CONTROL-x开始的，这些命令许多都跟窗格，文件，缓冲区等等相关</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="插入多个相同字符"><a href="#插入多个相同字符" class="headerlink" title="插入多个相同字符"></a>插入多个相同字符</h3><p><strong>C-u 8</strong> <strong>*</strong></p><p>这将会插入<strong><strong>*</strong></strong></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除光标后的一个字符"><a href="#删除光标后的一个字符" class="headerlink" title="删除光标后的一个字符"></a>删除光标后的一个字符</h3><p><strong>C-d</strong></p><p>delete</p><p>相当于键盘的delete键</p><h3 id="删除光标后的一个词"><a href="#删除光标后的一个词" class="headerlink" title="删除光标后的一个词"></a>删除光标后的一个词</h3><p><strong>M-d</strong></p><h3 id="删除光标到行尾之间的字符"><a href="#删除光标到行尾之间的字符" class="headerlink" title="删除光标到行尾之间的字符"></a>删除光标到行尾之间的字符</h3><p><strong>C-k</strong></p><p>kill</p><h3 id="删除光标到句尾之间的字符"><a href="#删除光标到句尾之间的字符" class="headerlink" title="删除光标到句尾之间的字符"></a>删除光标到句尾之间的字符</h3><p><strong>M-k</strong></p><p>注意,“移除（kill）”和“删除（delete）”的不同在于被移除的东西可以被重新插入（在任何位置），而被删除的就不能使用相同的方法重新插入了（不过可以通过撤销一个删除命令来做到，后文会提到）。【实际上，移除掉的东西虽然看起来“消失”了，但实际上被 Emacs 记录了下来，因此还可以找回来；而删除掉的东西虽然也可能还在内存里，但是已经被 Emacs“抛弃”了，所以就找不回来了。】重新插入被移除的文字称为“召回（yank）”。一般而言，那些可能消除很多文字的命令会把消除掉的文字记录下来（它们被设定成了“可召回”），而那些只消除一个字符或者只消除空白的命令就不会记录被消除的内容（自然你也就无法召回了）。</p><p>注意，单独的 C-k 会把一行的内容移除，而第二个 C-k 则会移除换行符，并使其后所有的行都向上移动。C-k 处理数字参数的方式很特别，它会把参数指定的那么多行连同其后的换行符一起移除，而不仅仅是重复 C-k 而已。比如 C-u 2C-k 会把两行以及它们的换行符移除；而如果只是输入 C-k 两次显然不是这个结果。</p><h2 id="召回（粘贴）"><a href="#召回（粘贴）" class="headerlink" title="召回（粘贴）"></a>召回（粘贴）</h2><p>重新插入被移除的文字恢复的动作称为“召回（yanking）”。（就好像把别人从你身边移走的东西又猛力地拉回来。）你可以在你删除文字的地方召回，也可以在别的地方召回，还可以多次召回同样的文字以得到它的多个拷贝。很多其它的编辑器把移除和召回叫做“剪切”和“粘贴” </p><h3 id="召回最近一次移除的内容"><a href="#召回最近一次移除的内容" class="headerlink" title="召回最近一次移除的内容"></a>召回最近一次移除的内容</h3><p><strong>C-y</strong></p><p>yanking</p><h3 id="召回前几次移除的内容"><a href="#召回前几次移除的内容" class="headerlink" title="召回前几次移除的内容"></a>召回前几次移除的内容</h3><p><strong>M-y</strong></p><p>需要先C-y之后再M-y</p><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p><strong>C-/</strong></p><p>或者 <strong>C-_</strong> 或者 <strong>C-x u</strong></p><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>Emacs 可以向前或向后搜索字符串（“字符串”指的是一组连续的字符）。</p><p>搜索命令是一个<strong>移动光标的命令</strong>：搜索成功后，光标会停留在搜索目标出现的地方</p><h3 id="向前搜索"><a href="#向前搜索" class="headerlink" title="向前搜索"></a>向前搜索</h3><p><strong>C-s</strong></p><p>在一次渐进式搜索中，Emacs 会尝试跳到搜索目标出现的位置。要跳到下一个命中位置，就再按一次 C-s。如果找不到目标，Emacs 会发出“哔”的一声，告诉你搜索失败。在整个过程中，都可以用 C-g 来终止搜索。【你会发现 C-g 会让光标回到搜索开始的位置，而 <Return> 则让光标留在搜索结果上，这是很有用的功能】</p><h3 id="向后搜索"><a href="#向后搜索" class="headerlink" title="向后搜索"></a>向后搜索</h3><p><strong>C-r</strong></p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><strong>M-%</strong></p><p>替换时按下y确认替换，n跳过本处的替换，！全部替换</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="寻找一个文件"><a href="#寻找一个文件" class="headerlink" title="寻找一个文件"></a>寻找一个文件</h3><p><strong>C-x C-f</strong></p><h3 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h3><p><strong>C-x C-s</strong></p><p>这条命令把 Emacs 中的文字存储到文件中。第一次存盘的时候 Emacs 会将原文件重命名以备份。重命名的规则通常是在原文件名之后添加一个“~”字符。可以关闭这个特性。</p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>Emacs 把每个编辑中的文件都放在一个称为“缓冲区（buffer）”的地方。每寻找到一个文件，Emacs 就在其内部开辟一个缓冲区。用下面的命令可以列出当前所有的缓冲区：</p><p>   C-x C-b  列出缓冲区</p><p>输入 C-x 1 离开缓冲区列表</p><p>不管存在多少缓冲区，任何时候都只能有一个“当前”缓冲区，也就是你正在编辑的这个。如果你想编辑其它的缓冲区，就必须“切换”过去。上面讲过，用C-x C-f 是一种办法。不过还有一个更简单的办法，那就是用 C-x b。用这条命令，你必须输入缓冲区的名称。</p><p>大多数情况下，缓冲区与跟其对应的文件是同名的（不包括目录名），不过这也不是绝对的。用 C-x C-b 得到的缓冲区列表总是显示缓冲区名。</p><p>缓冲区未必有对应文件。显示缓冲区列表的缓冲区（叫做“<em>Buffer List</em>”）就是这样。这个 TUTORIAL.cn 缓冲区起初没有对应的文件，但是现在有了，因为在前一节你输入了 C-x C-s ， 将它保存成了一个文件。</p><p>“<em>Messages</em>”缓冲区也没有对应文件，这个缓冲区里存放的都是在 Emacs 底部出现的消息。</p><p>如果你对某个文件做了些修改，然后切换到另一个文件，这个动作并不会帮你把前一个文件存盘。对第一个文件的修改仍然仅存在于 Emacs 中，也就是在它对应的缓冲区里。并且，对第二个文件的修改也不会影响到第一个件。这很有用，但也意味着你需要一个简便的办法来保存第一个文件的缓冲区。先切换回那个缓冲区，再用 C-x C-s 存盘，太麻烦了。你需要一个更简便的方法，而 Emacs 已经为你准备好了：</p><p>   C-x s  保存多个缓冲区</p><p>C-x s 会找出所有已被修改但尚未存盘的缓冲区，然后向你逐个询问：是否需要存盘？</p><h2 id="命令集扩展"><a href="#命令集扩展" class="headerlink" title="命令集扩展"></a>命令集扩展</h2><p>Emacs 的命令就像天上的星星，数也数不清。把它们都对应到 CONTROL 和 META组合键上显然是不可能的。Emacs 用扩展（eXtend）命令来解决这个问题，扩展命令有两种风格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C-x     字符扩展。  C-x 之后输入另一个字符或者组合键。</span><br><span class="line">    M-x     命令名扩展。M-x 之后输入一个命令名</span><br></pre></td></tr></table></figure><h3 id="行排序"><a href="#行排序" class="headerlink" title="行排序"></a>行排序</h3><p><strong>M-x sort-lines</strong></p><h3 id="统计字数"><a href="#统计字数" class="headerlink" title="统计字数"></a>统计字数</h3><p>整个buffer统计</p><p><strong>M-x count-words-region</strong></p><p>选中区域统计</p><p><strong>M-x count-words</strong></p><h2 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h2><p>如果你已经修改了一个文件，但是还没来得及存盘你的计算机就罢工了，那么你所做的修改就很可能会丢失。为了避免这样的不幸发生，Emacs 会定期将正在编辑的文件写入一个“自动保存”文件中。自动保存文件的文件名的头尾各有一个“#”字符，比如你正在编辑的文件叫“hello.c”，那么它的自动保存文件就叫“#hello.c#”。这个文件会在常存盘之后被 Emacs 删除。</p><p>所以，假如不幸真的发生了，你大可以从容地打开原来的文件（注意不是自动保存文件）然后输入 M-x recover file <Return> 来恢复你的自动保存文件。在提示确认的时候，输入 yes<Return>。</p><h2 id="状态栏"><a href="#状态栏" class="headerlink" title="状态栏"></a>状态栏</h2><p>位于回显区正上方的一行被称为“状态栏”。状态栏上会显示一些信息，比如：</p><p>-:**- TUTORIAL.cn 63% L749 (Fundamental)</p><ul><li>状态栏显示了 Emacs 的状态和你正在编辑的文字的一些信息。</li><li>你应该知道文件名的意思吧？就是你找到的那个文件嘛。</li><li>-NN%— 显示的是光标在全文中的位置。如果位于文件的开头，那么就显示 —Top— 而不是 —00%—；如果位于文件的末尾，就显示 —Bot—。如果文件很小，一屏就足以显示全部内容，那么状态栏会显示 —All—。</li><li>“L” 和其后的数字给出了光标所在行的行号。</li><li>最开头的星号（*）表示你已经对文字做过改动。刚刚打开的文件肯定没有被改动过，所以状态栏上显示的不是星号而是短线（-）。</li><li>状态栏上小括号里的内容告诉你当前正在使用的编辑模式。缺省的模式是Fundamental，就是你现在正在使用的这个。它是一种“主模式”。</li></ul><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>主模式都是可以用 M-x 启动的扩展命令，M-x fundamental-mode 就可以切换到 Fundamental模式。</p><p>M-x text-mode <Return>。切换到文本模式</p><p>用 C-h m 可以查看当前主模式的文档，输入 C-x 1 关掉文档窗格</p><ul><li>主模式之所以称之为“主（major）”模式，是因为同时还有“辅模式”（minormode）存在。辅模式并不能替代主模式，而是提供一些辅助的功能。每个辅模式都可以独立地开启和关闭，跟其它辅模式无关，跟主模式也无关。所以你可以不使用辅模式，也可以只使用一个或同时使用多个辅模式。</li><li>有一个叫做自动折行（Auto Fill）的辅模式很有用，特别是在编辑自然语言文本的时候。启用自动折行后，Emacs 会在你打字超出一行边界时自动替你换行。</li><li>用 M-x auto-fill-mode <Return> 启动自动折行模式。再用一次这条命令，自动折行模式会被关闭。也就是说，如果自动折行模式没有被开启，这个命令会开启它；如果已经开启了，这个命令会关闭它。所以我们说，这个命令可以用来开关（toggle）”模式。</li><li>行边界通常被设定为 70 个字符【这里指英文字符】，你可以用 C-x f 命令配合数字参数来重新设定它。</li><li>如果你在段落的中间做了一些修改，那么自动折行模式不会替你把整个段落重新折行，你需要用 M-q 手动折行。注意，光标必须位于你需要折行的那一段里</li></ul><h2 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h2><p>Buffer切换</p><p>C-x b</p><p>杀死当前Buffer</p><p>C-x k</p><p>批量管理Buffer</p><p>C-x C-b ;; 进入Buffer列表</p><ul><li>d ;; 标记删除</li><li>u ;; 取消当前行标记</li><li>U ;; 取消全部标记</li><li>x ;; 执行操作</li><li>? ;; 查看按键帮助</li></ul><h2 id="多窗格（分屏）"><a href="#多窗格（分屏）" class="headerlink" title="多窗格（分屏）"></a>多窗格（分屏）</h2><h3 id="将屏幕划分为两个窗格"><a href="#将屏幕划分为两个窗格" class="headerlink" title="将屏幕划分为两个窗格"></a>将屏幕划分为两个窗格</h3><p><strong>C-x 0</strong></p><p>关闭当前分屏</p><p><strong>C-x 1</strong></p><p>只保留当前分屏</p><p><strong>C-x 2</strong></p><p>上下分屏</p><p><strong>C-x 3</strong></p><p>左右分屏</p><h3 id="分屏宽度调整"><a href="#分屏宽度调整" class="headerlink" title="分屏宽度调整"></a>分屏宽度调整</h3><p>增加高度 C-x ^</p><p>增加/减少宽度 C-x {C-x }</p><h3 id="将光标移动到其它窗格"><a href="#将光标移动到其它窗格" class="headerlink" title="将光标移动到其它窗格"></a>将光标移动到其它窗格</h3><p><strong>C-x o</strong></p><p>o指的是other</p><p>当你在一个窗格中编辑，但用另一个窗格作为参考的时候，C-M-v 是很有用的命令。无需离开被选中的窗格，你就可以用 C-M-v 命令滚动另外一个窗格中的文字。【比如翻译和校对就很适合用这种方式进行。】</p><p>（在上方窗格里）输入 C-x 1 关掉下方窗格</p><p>当分屏很多的时候效率非常低。通过ace-window可快速进行窗口间的跳转。类似的插件较多，但该款为最佳方案。</p><p><strong>M-o</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(use-package ace-window </span><br><span class="line">             :bind ((&quot;M-o&quot; . &#x27;ace-window)))</span><br></pre></td></tr></table></figure><p><img src="./emacs.assets/1673110725303-6cb4c6aa-b022-46d2-827b-1b7befb54e8b.png" alt="img"></p><h3 id="在新窗格里打开文件"><a href="#在新窗格里打开文件" class="headerlink" title="在新窗格里打开文件"></a>在新窗格里打开文件</h3><p><strong>C-x 4 C-f</strong></p><h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><h3 id="新建一个窗口"><a href="#新建一个窗口" class="headerlink" title="新建一个窗口"></a>新建一个窗口</h3><p><strong>M-x make-frame</strong></p><h3 id="关闭选中窗口"><a href="#关闭选中窗口" class="headerlink" title="关闭选中窗口"></a>关闭选中窗口</h3><p><strong>M-x delete-frame</strong></p><h2 id="获得更多帮助"><a href="#获得更多帮助" class="headerlink" title="获得更多帮助"></a>获得更多帮助</h2><p>Emacs 提供了一些命令来查看 Emacs 的命令文档，这些命令都以 CONTROL-h 开头，这个字符也因此被称为“帮助（Help）字符”</p><p>最基本的帮助功能是 C-h c。输入 C-h c 之后再输入一个组合键，Emacs 会给出这个命令的简要说明。</p><p>输入 C-h c C-p。</p><p>显示的消息应该会是这样：</p><p>​    C-p runs the command previous-line</p><p>这条消息显示了 C-p 命令对应的函数名。命令的功能由函数完成，所以函数名本身也可以被看成是最简单的文档――至少对于你已经学过的命令来说，它们的函数名足以解释它们的功能了。</p><p>想得到更多的信息，请把 C-h c 换成 C-h k 试试看。</p><p>输入 C-h k C-p。</p><p>上面的命令会新打开一个 Emacs 窗格以显示函数的名称及其文档。你读完之后可以用 C-x 1 关掉这个帮助窗格。当然你并不需要立即这样做，你完全可以先在编辑窗格里做点别的事情，然后再关掉帮助窗格。</p><p>C-h f 解释一个函数。需要输入函数名。</p><p>输入 C-h f previous-line <Return>。Emacs 会给出它所知道的所有有关“实现 C-p 命令功能的函数”的信息</p><p>C-h v 用来显示 Emacs 变量的文档。Emacs 变量可以被用来“定制 Emacs 的行为”。同样，你需要输入变量的名称。</p><p>C-h a 相关命令搜索（Command Apropos）。 输入一个关键词然后 Emacs 会列出所有命令名中包含此关键词 的命令。这些命令全都可以用 M-x 来启动。对于某些命令来说， 相关命令搜索还会列出一两个组合键。</p><p>输入 C-h a file <Return>。</p><p>Emacs 会在另一个窗格里显示一个 M-x 命令列表，这个列表包含了所有名称中含有“file”的命令。你可以看到像“C-x C-f”这样的组合键显示在“find-file”这样的命令名的旁边。</p><p>C-h i 阅读手册（也就是通常讲的 Info）。 这个命令会打开一个称为“<em>info</em>”的特殊缓冲区，在那里， 你可以阅读安装在系统里的软件包使用手册。要读 Emacs 的使 用手册，按 m emacs <Return> 就可以了。如果你之前从没用 过 Info 系统，那么请按“?”，Emacs 会带你进入 Info 的使 用指南。在看完本快速指南之后，Emacs Info 会成为你的主要 参考文档。</p>]]></content>
      
      
      <categories>
          
          <category> emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emacs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
