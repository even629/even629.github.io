<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>rust language advanced | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="rust笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="rust language advanced">
<meta property="og:url" content="https://even629.com/posts/42972/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="rust笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/rust_cover.webp">
<meta property="article:published_time" content="2025-10-22T11:04:13.000Z">
<meta property="article:modified_time" content="2025-10-22T11:04:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="programming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/rust_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/42972/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: even629","link":"链接: ","source":"来源: 常想一二，不思八九","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'rust language advanced',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.gif', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/music.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/rust.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/avatar.gif" alt="Logo"><span class="site-name">常想一二，不思八九</span></a><a class="nav-page-title" href="/"><span class="site-name">rust language advanced</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">rust language advanced</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-22T11:04:13.000Z" title="发表于 2025-10-22 19:04:13">2025-10-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-22T11:04:13.000Z" title="更新于 2025-10-22 19:04:13">2025-10-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/programming/">programming</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/42972/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-10-22</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div></div>
<hr>
<h1 id="函数式语言特性-迭代器和闭包"><a href="#函数式语言特性-迭代器和闭包" class="headerlink" title="函数式语言特性:迭代器和闭包"></a>函数式语言特性:迭代器和闭包</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Rust 的 <strong>闭包</strong>（<em>closures</em>）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数</p>
<ul>
<li>匿名函数</li>
<li>保存为变量,作为参数</li>
<li>可以在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算</li>
<li>可从其定义的作用域捕获值</li>
</ul>
<p>文件名: src/main.rs</p>
<p>一个用来代替假定计算的函数，它大约会执行两秒钟</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">simulated_expensive_calculation</span>(intensity: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">    intensity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件名: src/main.rs</p>
<p>程序的业务逻辑，它根据输入并调用 simulated_expensive_calculation 函数来打印出健身计划</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">simulated_expensive_calculation</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件名: src/main.rs</p>
<p>main 函数包含了用于 generate_workout 函数的模拟用户输入和模拟随机数输入</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">simulated_user_specified_value</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">simulated_random_number</span> = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">generate_workout</span>(simulated_user_specified_value, simulated_random_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">       thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">       num</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包定义是 expensive_closure 赋值的 = 之后的部分。闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数；</li>
<li>如果<strong>有多于一个参数，可以使用逗号分隔，比如 |param1, param2|</strong>。</li>
<li>参数之后是存放闭包体的大括号 —— <strong>如果闭包体只有一行则大括号是可以省略的</strong>。大括号之后闭包的结尾，需要用于 let 语句的分号。因为闭包体的最后一行没有分号（正如函数体一样），所以闭包体（num）最后一行的返回值作为调用闭包时的返回值 。</li>
</ul>
<p>注意:</p>
<p>这个 let 语句意味着 expensive_closure 包含一个匿名函数的 <strong>定义</strong>，不是调用匿名函数的 <strong>返回值</strong>。</p>
<p><strong>重构代码</strong></p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, <span class="title function_ invoke__">expensive_closure</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                <span class="title function_ invoke__">expensive_closure</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包的类型推断"><a href="#闭包的类型推断" class="headerlink" title="闭包的类型推断"></a>闭包的类型推断</h3><ul>
<li><strong>闭包不要求标注参数和返回值的类型</strong></li>
<li>闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型</li>
<li>可以手动添加类型</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">expensive_closure</span> = |num: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>与函数的比较</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;<span class="comment">//函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;<span class="comment">//闭包</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;<span class="comment">//闭包</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;<span class="comment">//闭包</span></span><br></pre></td></tr></table></figure>
<p>src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>这个闭包在执行第二行代码时，编译器就能确定该闭包的类型是 String 了，而在执行第三行时就会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   Compiling rust_programming v0.1.0 (/home/zhaohang/repository/rust_programming)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> --&gt; src/main.rs:4:29</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> n = example_closure(5);</span><br><span class="line">  |             --------------- ^ expected `String`, found <span class="built_in">integer</span></span><br><span class="line">  |             |</span><br><span class="line">  |             arguments to this <span class="keyword">function</span> are incorrect</span><br><span class="line">  |</span><br><span class="line">note: expected because the closure was earlier called with an argument of <span class="built_in">type</span> `String`</span><br><span class="line"> --&gt; src/main.rs:3:29</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="built_in">let</span> s = example_closure(String::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">  |             --------------- ^^^^^^^^^^^^^^^^^^^^^ expected because this argument is of <span class="built_in">type</span> `String`</span><br><span class="line">  |             |</span><br><span class="line">  |             <span class="keyword">in</span> this closure call</span><br><span class="line">note: closure parameter defined here</span><br><span class="line"> --&gt; src/main.rs:2:28</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> example_closure = |x| x;</span><br><span class="line">  |                            ^</span><br><span class="line"><span class="built_in">help</span>: try using a conversion method</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> n = example_closure(5.to_string());</span><br><span class="line">  |                              ++++++++++++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br></pre></td></tr></table></figure>
<h3 id="泛型参数闭包"><a href="#泛型参数闭包" class="headerlink" title="泛型参数闭包"></a>泛型参数闭包</h3><p>在上面的代码仍然把慢计算闭包调用了比所需更多的次数。解决这个问题的一个方法是在全部代码中的每一个需要多个慢计算闭包结果的地方，可以将结果保存进变量以供复用，这样就可以使用变量而不是再次调用闭包。但是这样就会有很多重复的保存结果变量的地方。</p>
<p>幸运的是，还有另一个可用的方案。可以<strong>创建一个存放闭包和调用闭包结果的结构体</strong>。该结构体只会在需要结果时执行闭包，并会缓存结果值，这样余下的代码就不必再负责保存结果并可以复用该值。你可能见过这种模式被称 <strong>*memoization*</strong> 或 <strong>*lazy evaluation**</strong>（惰性求值）*。</p>
<h4 id="如何让-struct-持有闭包"><a href="#如何让-struct-持有闭包" class="headerlink" title="如何让 struct 持有闭包"></a>如何让 struct 持有闭包</h4><ul>
<li>struct 的定义需要知道所有字段的类型，即需要指明闭包的类型</li>
<li><strong>每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一样</strong></li>
<li>所以需要使用:泛型和 Trait Bound</li>
</ul>
<p><strong>Fn Trait</strong></p>
<ul>
<li>由标准库提供</li>
<li><strong>所有的闭包都至少实现了以下 trait 之一:</strong><ul>
<li><strong>Fn</strong></li>
<li><strong>FnMut</strong></li>
<li><strong>FnOnce</strong></li>
</ul>
</li>
</ul>
<p>注意：<strong>函数也都实现了这三个</strong> <strong>Fn</strong> <strong>trait</strong>。如果不需要捕获环境中的值，则可以使用实现了 Fn trait 的函数而不是闭包。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    calculation: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(calculation: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            calculation,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.calculation)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体 Cacher 有一个泛型 T 的字段 calculation。</p>
<p>T 的 trait bound 指定了 T 是一个使用 Fn 的闭包。</p>
<p>任何我们希望储存到 Cacher 实例的 calculation 字段的闭包必须有一个 u32 参数（由 Fn 之后的括号的内容指定）并必须返回一个 u32（由 -&gt; 之后的内容）。</p>
<p>字段 value 是 Option<u32> 类型的。在执行闭包之前，value 将是 None。如果使用 Cacher 的代码请求闭包的结果，这时会执行闭包并将结果储存在 value 字段的 Some 成员中。接着<strong>如果代码再次请求闭包的结果，这时不再执行闭包，而是会返回存放在 Some 成员中的结果</strong>。</p>
<p>重构代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_workout</span>(intensity: <span class="type">u32</span>, random_number: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">expensive_result</span> = Cacher::<span class="title function_ invoke__">new</span>(|num| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;calculating slowly...&quot;</span>);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">2</span>));</span><br><span class="line">        num</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intensity &lt; <span class="number">25</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Today, do &#123;&#125; pushups!&quot;</span>, expensive_result.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Next, do &#123;&#125; situps!&quot;</span>, expensive_result.<span class="title function_ invoke__">value</span>(intensity));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> random_number == <span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Take a break today! Remember to stay hydrated!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Today, run for &#123;&#125; minutes!&quot;</span>,</span><br><span class="line">                expensive_result.<span class="title function_ invoke__">value</span>(intensity)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Cacher-实现的限制"><a href="#Cacher-实现的限制" class="headerlink" title="Cacher 实现的限制"></a>Cacher 实现的限制</h4><ol>
<li>第一个问题是 Cacher 实例假设对于 value 方法的任何 arg 参数值总是会返回相同的值。</li>
</ol>
<p><strong>解决方案</strong>：</p>
<p>可以使用 HashMap 代替单个值:</p>
<ul>
<li><p>key: arg 参数</p>
</li>
<li><p>value: 执行闭包的结果</p>
</li>
</ul>
<ol>
<li>第二个问题是只能接收一个 u32 类型的参数和 u32 类型的返回值</li>
</ol>
<p><strong>解决方案:</strong></p>
<p>引入两个或多个泛型参数</p>
<h3 id="闭包会捕获其环境"><a href="#闭包会捕获其环境" class="headerlink" title="闭包会捕获其环境"></a>闭包会捕获其环境</h3><ul>
<li>可以捕获其环境并访问其被定义的作用域的变量,而普通函数则不能</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包<strong>会产生内存开销</strong><br> 闭包在 Rust 中是一个编译器生成的匿名结构体，结构体的字段就是捕获的变量。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器内部类似：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>, <span class="comment">// 捕获的变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Fn</span>() <span class="keyword">for</span> <span class="title class_">Closure</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>捕获变量需要存储空间</strong></p>
<ul>
<li>如果捕获的是<strong>值</strong>，闭包会在自身结构体中存储该值。</li>
<li>如果捕获的是<strong>引用</strong>，闭包结构体中存储的是指针（引用本身也占空间）。</li>
</ul>
<p><strong>开销大小</strong></p>
<ul>
<li><strong>小变量（如 i32, bool）</strong>：几乎没有额外开销，存储在闭包的结构体里即可。</li>
<li><strong>大变量（如 String, Vec, HashMap）</strong>：<ul>
<li>如果 <code>move</code> 捕获，闭包会拷贝或移动整个对象（堆内存可能被绑定到闭包）。</li>
<li>如果只是引用捕获，闭包内部只存指针，但要保证引用生命周期有效。</li>
</ul>
</li>
</ul>
<h4 id="闭包从所在环境捕获值的方式"><a href="#闭包从所在环境捕获值的方式" class="headerlink" title="闭包从所在环境捕获值的方式"></a>闭包从所在环境捕获值的方式</h4><p>与函数获得参数的三种方式一样:</p>
<ul>
<li><p>取得所有权: <strong>FnOnce</strong></p>
<ul>
<li>FnOnce 消费从周围作用域捕获的变量，闭包周围的作用域被称为其 <strong>环境</strong>，<em>environment</em>。为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。</li>
</ul>
</li>
<li><p>可变借用: <strong>FnMut</strong></p>
<ul>
<li>FnMut 获取可变的借用值所以可以改变其环境</li>
</ul>
</li>
<li><p>不可变借用: <strong>Fn</strong></p>
<ul>
<li>Fn 从其环境获取不可变的借用值</li>
</ul>
</li>
</ul>
<p>创建闭包时，通过闭包对环境值的使用，Rust 推断出具体使用哪个 trait：</p>
<ul>
<li><strong>所有的闭包都实现了 FnOnce</strong></li>
<li><strong>没有移动捕获变量的实现了 FnMut</strong></li>
<li><strong>无需可变访问捕获变量的闭包实现了 Fn</strong></li>
</ul>
<p>实际上有一个层级关系，所有实现了 Fn 的都实现了 FnMut，所有实现了 FnMut 的，都实现了 FnOnce</p>
<h4 id="move-关键字"><a href="#move-关键字" class="headerlink" title="move 关键字"></a>move 关键字</h4><p>在参数列表前<strong>使用 move 关键字，可以强制闭包取得它所使用的环境值得所有权</strong></p>
<ul>
<li>当<strong>将闭包传递给新线程以移动数据使其归新线程所有</strong>时，此技术最为有用</li>
</ul>
<p>例子</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = <span class="keyword">move</span> |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x); <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x 被移动进了闭包，因为闭包使用 move 关键字定义。接着闭包获取了 x 的所有权，同时 main 就不再允许在 println! 语句中使用 x 了。去掉 println! 即可修复问题。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>当指定 Fn trait bound 之一时，首先用 Fn,基于闭包体里得情况，如果需要 FnOnce 或 FnMut，编译器会再告诉你 </p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器模式允许你对一个序列的项进行某些处理。<strong>迭代器</strong>（<em>iterator</em>）负责遍历序列中的每一项和决定序列何时结束的逻辑。当使用迭代器时，我们无需重新实现这些逻辑。</p>
<p>在 Rust 中，<strong>迭代器是 惰性的（<em>lazy</em>）</strong>，这意味着在调用方法使用迭代器之前它都不会有效果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br></pre></td></tr></table></figure>
<h3 id="Iterator-trait"><a href="#Iterator-trait" class="headerlink" title="Iterator trait"></a>Iterator trait</h3><ul>
<li>所有迭代器都实现了这个 trait</li>
<li>定义于标准库</li>
</ul>
<p>这个 trait 的定义看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略了方法的默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>type Item 和 Self::Item，他们定义了 trait 的 <strong>关联类型</strong>（<em>associated type</em>）。</p>
<p>这段代码表明实现 Iterator trait 要求同时<strong>定义一个</strong> <strong>Item</strong> <strong>类型</strong>，这个 Item 类型被用作 <strong>next</strong> <strong>方法的返回值类型</strong>。换句话说，Item 类型将是迭代器返回元素的类型。</p>
<p>Iterator trait 仅要求实现一个方法：next</p>
<p>next:</p>
<ul>
<li>每次返回迭代中的一项</li>
<li>返回结果包裹在 Some 里</li>
<li>迭代结束，返回 None</li>
</ul>
<p>可直接在迭代器上调用 next 方法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">iterator_demonstration</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v1_iter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>v1_iter 需要是可变的：在迭代器上调用 next 方法改变了迭代器中用来记录序列位置的状态。换句话说，代码 <strong>消费</strong>（consume）了，或使用了迭代器。每一个 next 调用都会从迭代器中消费一个项。</li>
<li>使用 for 循环时无需使 v1_iter 可变因为 for 循环会获取 v1_iter 的所有权并在后台使 v1_iter 可变。</li>
</ul>
<h4 id="几个迭代方法"><a href="#几个迭代方法" class="headerlink" title="几个迭代方法"></a>几个迭代方法</h4><ul>
<li><strong>iter</strong> 方法：在<strong>不可变引用上创建迭代器</strong>（元素的不可变引用）</li>
<li><strong>into_iter</strong> 方法：创建的<strong>迭代器会获得所有权</strong></li>
<li><strong>iter_mut</strong> 方法: <strong>迭代可变的引用</strong></li>
</ul>
<h3 id="消耗迭代器的方法"><a href="#消耗迭代器的方法" class="headerlink" title="消耗迭代器的方法"></a>消耗迭代器的方法</h3><ul>
<li>在标准库中，Iterator trait 由一些带默认实现的方法</li>
<li>其中有一些方法会调用 next 方法</li>
</ul>
<p>实现 Iterator trait 时必须实现 next 方法的原因之一</p>
<ul>
<li>调用 next 的叫做“<strong>消耗型适配器</strong>”</li>
</ul>
<p>因为调用它们会把迭代器耗尽</p>
<p>一个消费适配器的例子是 sum 方法。这个方法获取迭代器的所有权并反复调用 next 来遍历迭代器，因而会消费迭代器。当其遍历每一个项时，它将每一个项加总到一个总和并在迭代完成时返回总和。</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">iterator_sum</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="产生其它迭代器的方法"><a href="#产生其它迭代器的方法" class="headerlink" title="产生其它迭代器的方法"></a>产生其它迭代器的方法</h3><p>Iterator trait 中定义了另一类方法，被称为 <strong>迭代器适配器</strong>（<em>iterator adaptors</em>），</p>
<ul>
<li>他们允许将当前迭代器变为不同类型的迭代器。</li>
<li>可以链式调用多个迭代器适配器。</li>
<li>不过因为所有的迭代器都是惰性的，必须调用一个消费适配器方法以便获取迭代器适配器调用的结果。</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let v1: Vec&lt;i32&gt; = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    v1.iter().map(|x| x + 1);</span><br></pre></td></tr></table></figure>
<p>该 map 方法使用闭包来调用每个元素以生成新的迭代器。 这里的闭包创建了一个新的迭代器，对其中 vector 中的每个元素都被加 1。</p>
<p>不过这些代码会产生一个警告：</p>
<p>= note: iterators are lazy and do nothing unless consumed</p>
<p><strong>代码实际上并没有做任何事；所指定的闭包从未被调用过</strong>。警告提醒了我们为什么：<strong>迭代器适配器是惰性的</strong>，而这里我们需要消费迭代器。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
<p>第二行代码的下划线实际上是让编译器去推断他的类型</p>
<p>collect 方法是一个<strong>消耗型适配器</strong>，把结果收集到一个集合类型中</p>
<p>因为 map 获取一个闭包，可以指定任何希望在遍历的每个元素上执行的操作。这是一个展示如何使用闭包来自定义行为同时又复用 Iterator trait 提供的迭代行为的绝佳例子。</p>
<h3 id="使用闭包捕获环境"><a href="#使用闭包捕获环境" class="headerlink" title="使用闭包捕获环境"></a>使用闭包捕获环境</h3><p>filter 方法过滤器</p>
<ul>
<li>迭代器的 filter 方法获取一个使用迭代器的每一个项并返回布尔值的闭包。</li>
<li>如果闭包返回 true，其值将会包含在 filter 提供的新迭代器中。</li>
<li>如果闭包返回 false，其值不会包含在结果迭代器中。</li>
</ul>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(PartialEq, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shoe</span> &#123;</span><br><span class="line">    size: <span class="type">u32</span>,</span><br><span class="line">    style: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">shoes_in_size</span>(shoes: <span class="type">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;Shoe&gt; &#123;</span><br><span class="line">    shoes.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">filter</span>(|s| s.size == shoe_size).<span class="title function_ invoke__">collect</span>()</span><br><span class="line">    <span class="comment">//闭包从环境中捕获了 `shoe_size` 变量并使用其值与每一只鞋的大小作比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">filters_by_size</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">shoes</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">10</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">13</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sandal&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            Shoe &#123;</span><br><span class="line">                size: <span class="number">10</span>,</span><br><span class="line">                style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">in_my_size</span> = <span class="title function_ invoke__">shoes_in_size</span>(shoes, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            in_my_size,</span><br><span class="line">            <span class="built_in">vec!</span>[</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: <span class="number">10</span>,</span><br><span class="line">                    style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sneaker&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">                Shoe &#123;</span><br><span class="line">                    size: <span class="number">10</span>,</span><br><span class="line">                    style: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;boot&quot;</span>)</span><br><span class="line">                &#125;,</span><br><span class="line">            ]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>shoes_in_my_size 函数获取一个鞋子 vector 的所有权和一个鞋子大小作为参数。它返回一个只包含指定大小鞋子的 vector。</p>
<p>shoes_in_my_size 函数体中调用了 into_iter 来创建一个获取 vector 所有权的迭代器。接着调用 filter 将这个迭代器适配成一个只含有那些闭包返回 true 的元素的新迭代器。</p>
<p>闭包从环境中捕获了 shoe_size 变量并使用其值与每一只鞋的大小作比较，只保留指定大小的鞋子。最终，调用 collect 将迭代器适配器返回的值收集进一个 vector 并返回。</p>
<h3 id="创建自定义迭代器"><a href="#创建自定义迭代器" class="headerlink" title="创建自定义迭代器"></a>创建自定义迭代器</h3><p>trait Iterator定义中唯一要求提供的方法就是 next 方法。一旦定义了它，就可以使用所有其他由 Iterator trait 提供的拥有默认实现的方法来创建自定义迭代器了！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    count: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span> = <span class="type">u32</span>;</span><br><span class="line">    <span class="comment">//这里将迭代器的关联类型 Item 设置为 u32，意味着迭代器会返回 u32 值集合。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果 count 值小于 6，next 会返回封装在 Some 中的当前值，</span></span><br><span class="line">        <span class="comment">//不过如果 count 大于或等于 6，迭代器会返回 None。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">calling_next_directly</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = Counter::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">3</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">4</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="title function_ invoke__">Some</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="built_in">assert_eq!</span>(counter.<span class="title function_ invoke__">next</span>(), <span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过定义 next 方法实现 Iterator trait，我们现在就可以使用任何标准库定义的拥有默认实现的 Iterator trait 方法了，因为他们都使用了 next 方法的功能。</p>
<p>例如，出于某种原因我们希望获取 Counter 实例产生的值，将这些值与另一个 Counter 实例在<strong>省略了第一个值</strong>之后产生的值配对，<strong>将每一对值相乘</strong>，<strong>只保留那些可以被三整除的结果</strong>，<strong>然后将所有保留的结果相加</strong>，这可以如示例 13-23 中的测试这样做：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line">   <span class="keyword">fn</span> <span class="title function_">using_other_iterator_trait_methods</span>() &#123;</span><br><span class="line">       <span class="keyword">let</span> <span class="variable">sum</span>: <span class="type">u32</span> = Counter::<span class="title function_ invoke__">new</span>()</span><br><span class="line">           .<span class="title function_ invoke__">zip</span>(Counter::<span class="title function_ invoke__">new</span>().<span class="title function_ invoke__">skip</span>(<span class="number">1</span>))</span><br><span class="line">           .<span class="title function_ invoke__">map</span>(|(a, b)| a * b)</span><br><span class="line">           .<span class="title function_ invoke__">filter</span>(|x| x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">           .<span class="title function_ invoke__">sum</span>();</span><br><span class="line">       <span class="built_in">assert_eq!</span>(<span class="number">18</span>, sum);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>示例 13-23：使用自定义的 Counter 迭代器的多种方法，注意Counter本身就是Iterator</p>
<p>注意 zip 只产生四对值；理论上第五对值 (5, None) 从未被产生，因为 zip 在任一输入迭代器返回 None 时也返回 None。</p>
<p>所有这些方法调用都是可能的，因为我们指定了 next 方法如何工作，而标准库则提供了其它调用 next 的方法的默认实现。</p>
<h3 id="改进-I-O-项目"><a href="#改进-I-O-项目" class="headerlink" title="改进 I/O 项目"></a>改进 I/O 项目</h3><h4 id="使用迭代器并去掉-clone"><a href="#使用迭代器并去掉-clone" class="headerlink" title="使用迭代器并去掉 clone"></a>使用迭代器并去掉 clone</h4><p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(args: &amp;[<span class="type">String</span>]) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> args.<span class="title function_ invoke__">len</span>() &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;not enough arguments&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = args[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = args[<span class="number">2</span>].<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接使用-env-args-返回的迭代器"><a href="#直接使用-env-args-返回的迭代器" class="headerlink" title="直接使用 env::args 返回的迭代器"></a>直接使用 env::args 返回的迭代器</h4><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//let args: Vec&lt;String&gt; = env::args().collect();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments: &#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(config: Config) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//读取文件</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">contents</span> = fs::<span class="title function_ invoke__">read_to_string</span>(&amp;config.filename)?;</span><br><span class="line">    <span class="comment">// println!(&quot;With text:\n&#123;&#125;&quot;, contents);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">results</span> = <span class="keyword">if</span> config.case_sensitive &#123;</span><br><span class="line">        <span class="title function_ invoke__">search</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">search_case_insensitive</span>(&amp;config.query, &amp;contents)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">line</span> <span class="keyword">in</span> results &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> query: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> filename: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> case_sensitive: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(<span class="keyword">mut</span> args: std::env::Args) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Config, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// if args.len() &lt; 3 &#123;</span></span><br><span class="line">        <span class="comment">//     return Err(&quot;not enough arguments&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        args.<span class="title function_ invoke__">next</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(arg) =&gt; arg,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Didn&#x27;t get a query string&quot;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">filename</span> = <span class="keyword">match</span> args.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(arg) =&gt; arg,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="string">&quot;Didn&#x27;t get a file name&quot;</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// println!(&quot;Search for &#123;&#125;&quot;, query);</span></span><br><span class="line">        <span class="comment">// println!(&quot;In file &#123;&#125;&quot;, filename);</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">case_sensitive</span> = env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;CASE_INSENSITIVE&quot;</span>).<span class="title function_ invoke__">is_err</span>();</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(Config &#123;</span><br><span class="line">            query,</span><br><span class="line">            filename,</span><br><span class="line">            case_sensitive,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// let mut result = Vec::new();</span></span><br><span class="line">    <span class="comment">// for line in contents.lines() &#123;</span></span><br><span class="line">    <span class="comment">//     if line.contains(query) &#123;</span></span><br><span class="line">    <span class="comment">//         result.push(line);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// result</span></span><br><span class="line"></span><br><span class="line">    contents</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">contains</span>(query))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">search_case_insensitive</span>&lt;<span class="symbol">&#x27;a</span>&gt;(query: &amp;<span class="type">str</span>, contents: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// let mut result = Vec::new();</span></span><br><span class="line">    <span class="comment">// let query = query.to_lowercase();</span></span><br><span class="line">    <span class="comment">// for line in contents.lines() &#123;</span></span><br><span class="line">    <span class="comment">//     if line.to_lowercase().contains(&amp;query) &#123;</span></span><br><span class="line">    <span class="comment">//         result.push(line);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// result</span></span><br><span class="line">    contents</span><br><span class="line">        .<span class="title function_ invoke__">lines</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|line| line.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">contains</span>(query.<span class="title function_ invoke__">to_lowercase</span>().<span class="title function_ invoke__">as_str</span>()))</span><br><span class="line">        .<span class="title function_ invoke__">collect</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_sensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>], <span class="title function_ invoke__">search</span>(query, contents));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">case_insensitive</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">query</span> = <span class="string">&quot;duct&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">contents</span> = <span class="string">&quot;\</span></span><br><span class="line"><span class="string">Rust:</span></span><br><span class="line"><span class="string">safe,fast,productive.</span></span><br><span class="line"><span class="string">Pick three.&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            <span class="built_in">vec!</span>[<span class="string">&quot;safe,fast,productive.&quot;</span>],</span><br><span class="line">            <span class="title function_ invoke__">search_case_insensitive</span>(query, contents)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"><span class="keyword">use</span> std::process;</span><br><span class="line"><span class="keyword">use</span> minigrep::Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,args);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config</span> = Config::<span class="title function_ invoke__">new</span>(env::<span class="title function_ invoke__">args</span>()).<span class="title function_ invoke__">unwrap_or_else</span>(|err| &#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Problem parsing arguments:&#123;&#125;&quot;</span>, err);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = minigrep::<span class="title function_ invoke__">run</span>(config)&#123;</span><br><span class="line">        <span class="built_in">eprintln!</span>(<span class="string">&quot;Application error: &#123;&#125;&quot;</span>,e);</span><br><span class="line">        process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能比较-循环-迭代器"><a href="#性能比较-循环-迭代器" class="headerlink" title="性能比较 循环/迭代器"></a>性能比较 循环/迭代器</h3><p>代器是 Rust 的 <strong>零成本抽象</strong>（<em>zero-cost abstractions</em>）之一，它意味着抽象并不会引入运行时开销，它与Bjarne Stroustrup（C++ 的设计和实现者）在 “Foundations of C++”（2012） 中所定义的 <strong>零开销</strong>（<em>zero-overhead</em>）如出一辙：</p>
<p>In general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</p>
<ul>
<li>Bjarne Stroustrup “Foundations of C++”</li>
</ul>
<p>从整体来说，C++ 的实现遵循了零开销原则：你不需要的，无需为他们买单。更有甚者的是：你需要的时候，也不可能找到其他更好的代码了。</p>
<ul>
<li>本贾尼·斯特劳斯特卢普 “Foundations of C++”</li>
</ul>
<h1 id="Cargo-和-crates-io"><a href="#Cargo-和-crates-io" class="headerlink" title="Cargo 和 crates.io"></a>Cargo 和 crates.io</h1><h2 id="采用发布配置自定义构建"><a href="#采用发布配置自定义构建" class="headerlink" title="采用发布配置自定义构建"></a>采用发布配置自定义构建</h2><p><strong>release profile</strong></p>
<ul>
<li>是预定义的</li>
<li>可自定义</li>
<li>每个 profile 配置独立于其它 profile</li>
</ul>
<p>cargo 主要的两个 profile</p>
<ul>
<li><strong>dev profile</strong>: 适用于开发 cargo build</li>
<li><strong>release profile</strong>: 适用于发布 cargo build —release</li>
</ul>
<h3 id="自定义-profile"><a href="#自定义-profile" class="headerlink" title="自定义 profile"></a>自定义 profile</h3><p>在 Cargo.toml 中添加[profile.xxxx]区域，在里面覆盖某人配置的子集</p>
<p>文件名: Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[profile.dev]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[profile.release]</span></span><br><span class="line"><span class="attr">opt-level</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>opt-level 设置控制 Rust 会对代码进行何种程度的优化。这个配置的值从 0 到 3。越高的优化级别需要更多的时间编译，所以如果你在进行开发并经常编译，可能会希望在牺牲一些代码性能的情况下编译得快一些。这就是为什么 dev 的 opt-level 默认为 0。</p>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ul>
<li>生成 HTML 文档</li>
<li>显示公共 Api 的文档注释: 如何使用 API</li>
<li>使用///</li>
<li>支持 Markdown</li>
<li>放置在说明条目前</li>
</ul>
<h3 id="生成文档"><a href="#生成文档" class="headerlink" title="生成文档"></a>生成文档</h3><p>运行 rustdoc 工具</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc</span><br></pre></td></tr></table></figure>
<p>把生成的文档放到 target/doc 下</p>
<h3 id="生成文档并浏览"><a href="#生成文档并浏览" class="headerlink" title="生成文档并浏览"></a>生成文档并浏览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo doc --open</span><br></pre></td></tr></table></figure>
<h3 id="常用章节"><a href="#常用章节" class="headerlink" title="常用章节"></a>常用章节</h3><p>#Examples</p>
<p>其它常用章节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Panics: 函数可能发生panic的场景</span><br><span class="line">Errors: 如果函数返回Result,描述可能的错误种类，以及可导致错误的条件</span><br><span class="line">Safety: 如果函数处于unsafe调用，就应该解释函数unsafe的原因，以及调用者确保的使用前提</span><br></pre></td></tr></table></figure>
<h3 id="文档注释作为测试"><a href="#文档注释作为测试" class="headerlink" title="文档注释作为测试"></a>文档注释作为测试</h3><p>运行 cargo test： 把文档注释中的示例代码作为测试来运行</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let arg = 5;</span></span><br><span class="line"><span class="comment">/// let answer = my_crate::add_one(arg);</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// assert_eq!(6, answer);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_one</span>(x: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试 cargo test 运行像示例中 add_one 函数的文档；应该在测试结果中看到像这样的部分：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Doc-tests my_crate</span><br><span class="line"></span><br><span class="line">running 1 <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> src/lib.rs - add_one (line 5) ... ok</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished <span class="keyword">in</span> 0.27s</span><br></pre></td></tr></table></figure>
<p>现在尝试改变函数或例子来使例子中的 assert_eq! 产生 panic。再次运行 cargo test，我们将会看到文档测试捕获到了例子与代码不再同步！</p>
<h3 id="为包含注释的项添加文档注释"><a href="#为包含注释的项添加文档注释" class="headerlink" title="为包含注释的项添加文档注释"></a>为包含注释的项添加文档注释</h3><ul>
<li>符号: //!</li>
<li>这类注释通常描述 crate 和模块</li>
</ul>
<p>crate root (按惯例 src/lib.rs)</p>
<p>一个模块内，将 crate 或模块作为一个整体进行记录</p>
<p>例子：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # My Crate</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! `my_crate` is a collection of utilities to make performing certain</span></span><br><span class="line"><span class="comment">//! calculations more convenient.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Adds one to the number given.</span></span><br><span class="line"><span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-pub-use-导出方便使用的公共-API"><a href="#使用-pub-use-导出方便使用的公共-API" class="headerlink" title="使用 pub use 导出方便使用的公共 API"></a>使用 pub use 导出方便使用的公共 API</h2><p>你开发时候使用的文件架构可能并不方便用户。你的结构可能是一个包含多个层级的分层结构，不过这对于用户来说并不方便。这是因为想要使用被定义在很深层级中的类型的人可能很难发现这些类型的存在。他们也可能会厌烦要使用 use my_crate::some_module::another_module::UsefulType; 而不是 use my_crate::UsefulType; 来使用类型。</p>
<p><strong>使用</strong> <strong>pub use</strong> <strong>重导出（re-export）项来使公有结构不同于私有结构</strong></p>
<p>src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">/// The primary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">PrimaryColor</span> &#123;</span><br><span class="line">        Red,</span><br><span class="line">        Yellow,</span><br><span class="line">        Blue,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// The secondary colors according to the RYB color model.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">SecondaryColor</span> &#123;</span><br><span class="line">        Orange,</span><br><span class="line">        Green,</span><br><span class="line">        Purple,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="keyword">use</span> crate::kinds::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Combines two primary colors in equal amounts to create</span></span><br><span class="line">    <span class="comment">/// a secondary color.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">mix</span>(c1: PrimaryColor, c2: PrimaryColor) <span class="punctuation">-&gt;</span> SecondaryColor &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        SecondaryColor::Green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">use</span> art::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">red</span> = PrimaryColor::Red;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">yellow</span> = PrimaryColor::Yellow;</span><br><span class="line">    <span class="title function_ invoke__">mix</span>(red, yellow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了从公有 API 中去掉 crate 的内部组织，我们可以采用示例 中的 art crate 并增加 pub use 语句来重导出项到顶层结构，如示例 14-5 所示：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! # Art</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! A library for modeling artistic concepts.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::PrimaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::kinds::SecondaryColor;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::utils::mix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> kinds &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> utils &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> art::mix;</span><br><span class="line"><span class="keyword">use</span> art::PrimaryColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发布-Crate"><a href="#发布-Crate" class="headerlink" title="发布 Crate"></a>发布 Crate</h2><p>有了唯一的名称、版本号、由 cargo new 新建项目时增加的作者信息、描述和所选择的 license，已经准备好发布的项目的 <em>Cargo.toml</em> 文件可能看起来像这样：</p>
<p>文件名: Cargo.toml</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;guessing_game&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">&quot;A fun game where you guess what number the computer has chosen.&quot;</span></span><br><span class="line"><span class="attr">license</span> = <span class="string">&quot;MIT OR Apache-2.0&quot;</span></span><br><span class="line"><span class="attr">author</span> = <span class="string">&quot;even629&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>
<p>Cargo 的文档 描述了其他可以指定的元信息，他们可以帮助你的 crate 更容易被发现和使用！</p>
<p>发布：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo publish</span><br></pre></td></tr></table></figure>
<p><strong>crate 一旦发布，就是永久性的:该版本无法覆盖，代码无法删除</strong></p>
<ul>
<li>目的：依赖于该版本的项目可继续正常工作</li>
</ul>
<h2 id="发布已存在-crate-的新版本"><a href="#发布已存在-crate-的新版本" class="headerlink" title="发布已存在 crate 的新版本"></a>发布已存在 crate 的新版本</h2><p>修改 version 重新发布</p>
<h2 id="使用-cargo-yank-从-Crates-io-撤回版本"><a href="#使用-cargo-yank-从-Crates-io-撤回版本" class="headerlink" title="使用 cargo yank 从 Crates.io 撤回版本"></a>使用 cargo yank 从 Crates.io 撤回版本</h2><ul>
<li>不可以删除 crate 之前的版本</li>
</ul>
<p>撤回某个版本会阻止新项目开始依赖此版本，不过所有现存此依赖的项目仍然能够下载和依赖这个版本。从本质上说，撤回意味着所有带有 <em>Cargo.lock</em> 的项目的依赖不会被破坏，同时任何新生成的 <em>Cargo.lock</em> 将不能使用被撤回的版本。</p>
<p>为了撤回一个 crate，运行 cargo yank 并指定希望撤回的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo yank --vers 1.0.1</span><br></pre></td></tr></table></figure>
<p>也可以撤销撤回操作，并允许项目可以再次开始依赖某个版本，通过在命令上增加 —undo：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo yank --vers 1.0.1 --undo</span><br></pre></td></tr></table></figure>
<p>撤回 <strong>并没有</strong> 删除任何代码。举例来说，撤回功能并不意在删除不小心上传的秘密信息。如果出现了这种情况，请立即重新设置这些秘密信息。</p>
<h2 id="Cargo-工作空间（Workspaces）"><a href="#Cargo-工作空间（Workspaces）" class="headerlink" title="Cargo 工作空间（Workspaces）"></a>Cargo 工作空间（Workspaces）</h2><ul>
<li>cargo 工作空间： 帮助管理多个相互关联且需要协同开发的 crate</li>
<li>cargo 工作空间是一套共享同一个 Cargo.lock 和输出文件夹的包</li>
</ul>
<h3 id="创建工作空间"><a href="#创建工作空间" class="headerlink" title="创建工作空间"></a>创建工作空间</h3><div class="tag link"><a class="link-card" title="Cargo工作空间" target="_blank" rel="noopener external nofollow noreferrer" href="https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html#cargo-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4"><div class="left"><img src="https://kaisery.github.io/trpl-zh-cn/favicon.svg"/></div><div class="right"><p class="text">Cargo工作空间</p><p class="url">https://kaisery.github.io/trpl-zh-cn/ch14-03-cargo-workspaces.html#cargo-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4</p></div></a></div>
<p>为了在顶层 <em>add</em> 目录运行二进制 crate，可以通过 -p 参数和包名称来运行 cargo run 指定工作空间中我们希望使用的包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run -p adder</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.0s</span><br><span class="line">     Running `target/debug/adder`</span><br><span class="line">Hello, world! 10 plus one is 11!</span><br></pre></td></tr></table></figure>
<p>这会运行 <em>adder/src/main.rs</em> 中的代码，其依赖 add_one crate</p>
<h2 id="从-CRATES-IO-安装二进制-crate"><a href="#从-CRATES-IO-安装二进制-crate" class="headerlink" title="从 CRATES.IO 安装二进制 crate"></a>从 CRATES.IO 安装二进制 crate</h2><ul>
<li>命令: cargo install</li>
<li>来源 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://crates.io">https://crates.io</a></li>
<li>限制: 只能安装具有二进制目标 (binary target) 的 crate</li>
</ul>
<p>二进制目标 binary target:是一个可运行的程序</p>
<ul>
<li>拥有 src/main.rs 或其它被指定为二进制文件的 crate 生成</li>
</ul>
<p>通常: READEME 里面有关于 crate 的描述:</p>
<ul>
<li>拥有 library target</li>
<li>拥有 library target</li>
<li>两者兼备</li>
</ul>
<h3 id="cargo-install"><a href="#cargo-install" class="headerlink" title="cargo install"></a>cargo install</h3><p>cargo install 安装的二进制存放在根目录的 bin 文件夹</p>
<h2 id="使用自定义命令扩展-cargo"><a href="#使用自定义命令扩展-cargo" class="headerlink" title="使用自定义命令扩展 cargo"></a>使用自定义命令扩展 cargo</h2><ul>
<li>cargo 被设计成可以使用子命令来扩展</li>
<li>例：如果$PATH 中的某个二进制是 cargo-something，你可以像子命令一样运行:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo something</span><br></pre></td></tr></table></figure>
<ul>
<li>类似这样的自定义命令可以通过该命令列出: cargo —list</li>
<li>优点: 可以使用 cargo install 来安装扩展，像内置工具一样来运行</li>
</ul>
<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul>
<li><strong>指针</strong> （<em>pointer</em>）是一个包含内存地址的变量的通用概念。</li>
</ul>
<p>这个地址引用，或 “指向”（points at）一些其他数据。</p>
<ul>
<li>Rust 中最常见的指针是 <strong>引用</strong>（<em>reference</em>）。</li>
</ul>
<p>引用以 &amp; 符号为标志并借用了他们所指向的值。除了引用数据没有任何其他特殊功能。它们也<strong>没有任何额外开销</strong>，所以应用得最多。</p>
<ul>
<li><strong>智能指针</strong>（<em>smart pointers</em>）是一类数据结构，他们的表现类似指针，但是也拥有额外的元数据和功能。</li>
</ul>
<h2 id="引用和智能指针的其它不同"><a href="#引用和智能指针的其它不同" class="headerlink" title="引用和智能指针的其它不同"></a>引用和智能指针的其它不同</h2><ul>
<li><strong>引用：只借用数据</strong></li>
<li><strong>智能指针：很多时候都拥有它所指向的数据</strong></li>
</ul>
<p><strong>智能指针的例子：</strong></p>
<ul>
<li>String 和 Vec<T></li>
<li>都拥有一片内存区域，且允许用户对其操作</li>
<li>还拥有元数据（例如容量等）</li>
<li>提供额外的功能或保障（String 保障其数据是合法的 UTF-8 编码）</li>
</ul>
<p><strong>智能指针的实现</strong></p>
<ul>
<li><p><strong>智能指针通常使用 struct 实现，</strong>并且实现了：Deref 和 Drop 这两个 trait</p>
<ul>
<li><p><strong>Deref trait 允许智能指针 struct 的实例像引用一样使用</strong></p>
</li>
<li><p><strong>Drop trait 允许你自定义当智能指针实例走出作用域时的代码</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="使用-Box指向堆上的数据"><a href="#使用-Box指向堆上的数据" class="headerlink" title="使用 Box指向堆上的数据"></a>使用 Box<T>指向堆上的数据</h2><ul>
<li><p>Box<T>是最简单的智能指针：</p>
<ul>
<li>允许你在 heap 上存储数据（而不是 stack）</li>
<li>stack 上是指向 heap 数据的指针</li>
<li>没有性能开销</li>
<li>没有其它额外功能</li>
</ul>
</li>
<li><p>Box<T>实现了 Deref trait 和 Drop trait</p>
</li>
</ul>
<p>多用于如下场景：</p>
<ul>
<li>当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候</li>
<li>当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候</li>
<li>当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b = &#123;&#125;&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Box-赋能递归类型"><a href="#使用-Box-赋能递归类型" class="headerlink" title="使用 Box 赋能递归类型"></a>使用 Box 赋能递归类型</h2><ul>
<li>在编译时,Rust 需要知道一个类型所占的空间大小</li>
<li>而递归类型的大小无法在编译时确定</li>
<li>但 Box 类型的大小确定</li>
<li>在递归类型中使用 Box 就可以解决上述问题</li>
<li>函数式语言的 Cons List</li>
</ul>
<h3 id="Cons-List"><a href="#Cons-List" class="headerlink" title="Cons List"></a>Cons List</h3><p><em>cons list</em> 是一个来源于 Lisp 编程语言及其方言的数据结构。在 Lisp 中，cons 函数（“construct function” 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。</p>
<p>cons 函数的概念涉及到更常见的函数式编程术语；“将 <em>x</em> 与 <em>y</em> 连接” 通常意味着构建一个新的容器而将 <em>x</em> 的元素放在新容器的开头，其后则是容器 <em>y</em> 的元素。</p>
<p>cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 Nil 的值且没有下一项。cons list 通过递归调用 cons 函数产生。代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。</p>
<p>代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。注意这不同于 “null” 或 “nil” 的概念，他们代表无效或缺失的值。</p>
<p>Cons List 并不是 Rust 的常用集合</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons,Nil&#125;;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">1</span>, <span class="title function_ invoke__">Cons</span>(<span class="number">2</span>, <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>,List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行报错</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiling my_box v0.<span class="number">1.0</span> (C:\Users\cauchy\Desktop\rust\my_box)</span><br><span class="line">error[E0072]: recursive <span class="keyword">type</span> `List` has infinite size</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src\main.rs:<span class="number">6</span>:<span class="number">1</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">6</span> | <span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">  | ^^^^^^^^^</span><br><span class="line"><span class="number">7</span> |     <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>,List),</span><br><span class="line">  |              ---- recursive without indirection</span><br><span class="line">  |</span><br><span class="line">help: insert some <span class="title function_ invoke__">indirection</span> (e.g., a `<span class="type">Box</span>`, `Rc`, or `&amp;`) to <span class="keyword">break</span> the cycle</span><br><span class="line">  |</span><br><span class="line"><span class="number">7</span> |     <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>,<span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">  |              ++++    +</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0072`.</span><br><span class="line">error: could not compile `my_box` due to previous error</span><br></pre></td></tr></table></figure>
<h3 id="计算非递归类型的大小"><a href="#计算非递归类型的大小" class="headerlink" title="计算非递归类型的大小"></a>计算非递归类型的大小</h3><p>Message 枚举：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Rust 需要知道要为 Message 值分配多少空间时，它可以检查每一个成员并发现</p>
<ul>
<li>Message::Quit 并不需要任何空间，</li>
<li>Message::Move 需要足够储存两个 i32 值的空间，依此类推。</li>
<li>因为 enum 实际上只会使用其中的一个成员，所以 Message 值所需的空间等于储存其最大成员的空间大小。</li>
</ul>
<p>与此相对当 Rust 编译器检查像上例的 List 这样的递归类型时会发生什么呢。编译器尝试计算出储存一个 List 枚举需要多少内存，并开始检查 Cons 成员，那么 Cons 需要的空间等于 i32 的大小加上 List 的大小。为了计算 List 需要多少内存，它检查其成员，从 Cons 成员开始。Cons 成员储存了一个 i32 值和一个 List 值，这样的计算将无限进行下去</p>
<h3 id="使用-Box给递归类型一个已知的大小"><a href="#使用-Box给递归类型一个已知的大小" class="headerlink" title="使用 Box给递归类型一个已知的大小"></a>使用 Box<T>给递归类型一个已知的大小</h3><ul>
<li>因为 Box<T> 是一个指针，我们总是知道它需要多少空间</li>
</ul>
<p><strong>指针的大小并不会根据其指向的数据量而改变。</strong></p>
<ul>
<li>Box<T></li>
</ul>
<ol>
<li>只提供了”间接”存储和 heap 内存分配的功能</li>
<li>没有其它额外功能</li>
<li>没有性能开销</li>
<li>适用于需要间接存储的场景，例如 Cons List</li>
<li>实现了 Deref trait 和 Drop trait</li>
</ol>
<h2 id="Dref-Trait"><a href="#Dref-Trait" class="headerlink" title="Dref Trait"></a>Dref Trait</h2><ul>
<li>实现 Deref Trait 使我们可以<strong>自定义解引用运算符*的行为</strong></li>
<li>通过实现 Deref，智能指针可<strong>像引用一样来处理</strong></li>
</ul>
<h2 id="解引用运算符"><a href="#解引用运算符" class="headerlink" title="解引用运算符"></a>解引用运算符</h2><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="把-Box当作引用"><a href="#把-Box当作引用" class="headerlink" title="把 Box当作引用"></a>把 Box<T>当作引用</h2><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义自己的智能指针"><a href="#定义自己的智能指针" class="headerlink" title="定义自己的智能指针"></a>定义自己的智能指针</h2><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的编译错误是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling deref-example v0.1.0 (file:///projects/deref-example)</span><br><span class="line">error[E0614]: <span class="built_in">type</span> `MyBox&lt;&#123;<span class="built_in">integer</span>&#125;&gt;` cannot be dereferenced</span><br><span class="line">  --&gt; src/main.rs:14:19</span><br><span class="line">   |</span><br><span class="line">14 |     assert_eq!(5, *y);</span><br><span class="line">   |                   ^^</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0614`.</span><br><span class="line">error: could not compile `deref-example` due to previous error</span><br></pre></td></tr></table></figure>
<p>MyBox<T> 类型不能解引用，因为我们尚未在该类型实现这个功能。为了启用 * 运算符的解引用功能，需要实现 Deref trait。</p>
<h2 id="通过实现-Deref-trait-将某类型像引用一样处理"><a href="#通过实现-Deref-trait-将某类型像引用一样处理" class="headerlink" title="通过实现 Deref trait 将某类型像引用一样处理"></a>通过实现 Deref trait 将某类型像引用一样处理</h2><ul>
<li><p>标准库中的 Deref trait 要求我们实现一个 deref 方法：</p>
<ul>
<li><p>该方法借用 self</p>
</li>
<li><p>返回一个指向内部数据的引用</p>
</li>
</ul>
</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在示例代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入 *y 时，Rust 事实上在底层运行了如下代码：</p>
<p>*(y.deref())</p>
<h2 id="函数和方法的隐式解引用转化（Deref-Coercion）"><a href="#函数和方法的隐式解引用转化（Deref-Coercion）" class="headerlink" title="函数和方法的隐式解引用转化（Deref Coercion）"></a>函数和方法的隐式解引用转化（Deref Coercion）</h2><ul>
<li>Deref Coercion 是为<strong>函数和方法</strong>提供的一种便捷特性</li>
<li>假设 T 实现了 Deref trait: Deref Coercion 可以把 T 的引用转化为 T 经过 Deref 操作后生成的引用</li>
<li>当把某类型的引用传递给函数或方法时，但它的类型于定义的参数类型不匹配:</li>
</ul>
<ol>
<li>Deref Coercion 就会自动发生</li>
<li>编译器会对 deref 进行一系列调用，来把它转为所需的参数类型</li>
<li>它在编译时完成，没有额外性能开销</li>
</ol>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="comment">//&amp;m &amp;MyBox&lt;String&gt;</span></span><br><span class="line">    <span class="comment">//deref &amp;String</span></span><br><span class="line">    <span class="comment">//&amp;String &amp;str</span></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这里使用 &amp;m 调用 hello 函数，其为 MyBox<String> 值的引用</li>
<li>因为示例 中在 MyBox<T> 上实现了 Deref trait，Rust 可以通过 deref 调用将 &amp;MyBox<String> 变为 &amp;String。</li>
<li>标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。Rust 再次调用 deref 将 &amp;String 变为 &amp;str，这就符合 hello 函数的定义了。</li>
</ol>
<p>如果 Rust 没有实现 Deref 强制转换，为了使用 &amp;MyBox<String> 类型的值调用 hello，则不得不编写以下的代码</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">hello</span>(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解引用与可变性"><a href="#解引用与可变性" class="headerlink" title="解引用与可变性"></a>解引用与可变性</h2><ul>
<li>可使用 DerefMut trait 重载可变引用的*运算符</li>
<li>在类型和 trait 在下列三种情况发生时，Rust 会执行 deref coercion:</li>
</ul>
<ol>
<li>当 T: Deref<Target=U>，允许&amp;T 转换为&amp;U</li>
<li>当 T: DerefMut<Target=U>，允许&amp;mut T 转换为&amp;mut U</li>
<li>当 T: Deref<Target=U>，允许&amp;mut T 转换为&amp;U</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>情况</th>
<th>条件</th>
<th>转换</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>T: Deref&lt;Target=U&gt;</code></td>
<td><code>&amp;T</code> 自动变 <code>&amp;U</code></td>
</tr>
<tr>
<td>2</td>
<td><code>T: DerefMut&lt;Target=U&gt;</code></td>
<td><code>&amp;mut T</code> 自动变 <code>&amp;mut U</code></td>
</tr>
<tr>
<td>3</td>
<td><code>T: Deref&lt;Target=U&gt;</code></td>
<td><code>&amp;mut T</code> 可变引用<strong>降级</strong>为不可变引用 <code>&amp;U</code></td>
</tr>
</tbody>
</table>
</div>
<p>举例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;name&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">greet</span>(&amp;s);  </span><br><span class="line"><span class="comment">// 正常情况下 &amp;String 不能传给 &amp;str，</span></span><br><span class="line"><span class="comment">// 但因为 String 实现了 Deref&lt;Target=str&gt;，所以自动变成了 &amp;str</span></span><br></pre></td></tr></table></figure>
<h2 id="Drop-Trait"><a href="#Drop-Trait" class="headerlink" title="Drop Trait"></a>Drop Trait</h2><ul>
<li><p>实现 Drop Trait 可以让我们自定义<strong>当值将要离开作用域时发生的动作</strong></p>
<ol>
<li><p>例如：文件，网络资源释放等</p>
</li>
<li><p>任何类型都可以实现 Drop trait</p>
</li>
</ol>
</li>
<li><p>Drop Trait 只要求你实现 drop 方法</p>
<ol>
<li>参数： 对 self 的可变引用</li>
</ol>
</li>
<li><p>Drop trait 在预导入模块里</p>
</li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">CustomSmartPointer</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Dropping CustomSmartPointer with data `&#123;&#125;`!&quot;</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;my stuff&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;other stuff&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointers created.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行这个程序，会出现如下输出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling drop-example v0.<span class="number">1.0</span> (file:<span class="comment">///projects/drop-example)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.60</span>s</span><br><span class="line">     Running `target/debug/drop-example`</span><br><span class="line">CustomSmartPointers created.</span><br><span class="line">Dropping CustomSmartPointer with data `other stuff`!</span><br><span class="line">Dropping CustomSmartPointer with data `my stuff`!</span><br></pre></td></tr></table></figure>
<h2 id="使用-std-mem-drop-来提前-drop-值"><a href="#使用-std-mem-drop-来提前-drop-值" class="headerlink" title="使用 std::mem::drop 来提前 drop 值"></a>使用 std::mem::drop 来提前 drop 值</h2><ul>
<li>很难直接禁用自动的 drop 功能，也没必要<ol>
<li>Drop trait 的目的就是进行自动的释放处理逻辑</li>
</ol>
</li>
</ul>
<ul>
<li><strong>Rust 不允许手动调用 Drop trait 的 drop 方法</strong></li>
<li>但<strong>可以调用标准库的 std::mem::drop 函数(prelude)，来提前 drop 值</strong></li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;some data&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer created.&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;CustomSmartPointer dropped before the end of main.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码会打印出如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling drop-example v0.<span class="number">1.0</span> (file:<span class="comment">///projects/drop-example)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.73</span>s</span><br><span class="line">     Running `target/debug/drop-example`</span><br><span class="line">CustomSmartPointer created.</span><br><span class="line">Dropping CustomSmartPointer with data `some data`!</span><br><span class="line">CustomSmartPointer dropped before the end of main.</span><br></pre></td></tr></table></figure>
<p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 drop 只会在值不再被使用时被调用一次。</p>
<h2 id="Rc引用计数智能指针"><a href="#Rc引用计数智能指针" class="headerlink" title="Rc引用计数智能指针"></a>Rc<T>引用计数智能指针</h2><ul>
<li>有时一个值会有多个所有者</li>
<li><p>为了支持多重所有权: Rt<T></p>
<ol>
<li><p>reference counting(引用计数)</p>
</li>
<li><p>追踪到值得引用</p>
</li>
<li>0 个引用:该值可以被清理掉</li>
</ol>
</li>
<li><p>需要在 heap 上分配数据，这些数据<strong>被程序的多个部分读取（只读）</strong>，但在<strong>编译时无法确定哪个部分最后使用完这些数据</strong></p>
</li>
<li>注意 <strong>Rc<T> 只能用于单线程场景</strong>；</li>
</ul>
<p>我们希望创建两个共享第三个列表所有权的列表，其概念将会看起来如图所示：</p>
<p>文件名: src/main.rs</p>
<p>不能用两个 Box<T> 的列表尝试共享第三个列表的所有权</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, <span class="type">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: use of moved value: `a`</span><br><span class="line">  --&gt; src/main.rs:11:30</span><br><span class="line">   |</span><br><span class="line"> 9 |     <span class="built_in">let</span> a = Cons(5, Box::new(Cons(10, Box::new(Nil))));</span><br><span class="line">   |         - move occurs because `a` has <span class="built_in">type</span> `List`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">10 |     <span class="built_in">let</span> b = Cons(3, Box::new(a));</span><br><span class="line">   |                              - value moved here</span><br><span class="line">11 |     <span class="built_in">let</span> c = Cons(4, Box::new(a));</span><br><span class="line">   |                              ^ value used here after move</span><br></pre></td></tr></table></figure>
<p>我们修改 List 的定义为使用 Rc<T> 代替 Box<T>，如列表 所示。现在每一个 Cons 变量都包含一个值和一个指向 List 的 Rc<T>。当创建 b 时，不同于获取 a 的所有权，这里会克隆 a 所包含的 Rc<List>，这会将引用计数从 1 增加到 2 并允许 a 和 b 共享 Rc<List> 中数据的所有权。创建 c 时也会克隆 a，这会将引用计数从 2 增加为 3。每次调用 Rc::clone，Rc<List> 中数据的引用计数都会增加，直到有零个引用之前其数据都不会被清理。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据结构关系：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="selector-tag">a</span> (Rc)</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">      <span class="built_in">Cons</span>(<span class="number">5</span>)</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">      <span class="built_in">Cons</span>(<span class="number">10</span>)</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">        Nil</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">b</span> ---&gt; <span class="built_in">Cons</span>(<span class="number">3</span>) ───┐</span><br><span class="line">                   │</span><br><span class="line">                   ▼</span><br><span class="line">                  <span class="selector-tag">a</span> (共享)</span><br><span class="line"></span><br><span class="line">c ---&gt; <span class="built_in">Cons</span>(<span class="number">4</span>) ───┘</span><br></pre></td></tr></table></figure>
<p>也可以调用 a.clone() 而不是 Rc::clone(&amp;a)，不过在这里 Rust 的习惯是使用 Rc::clone。</p>
<ul>
<li>Rc::clone 的实现并不像大部分类型的 clone 实现那样对所有数据进行深拷贝。</li>
<li><strong>Rc::clone 只会增加引用计数，这并不会花费多少时间。深拷贝可能会花费很长时间</strong>。</li>
</ul>
<h2 id="克隆-Rc会增加引用计数"><a href="#克隆-Rc会增加引用计数" class="headerlink" title="克隆 Rc会增加引用计数"></a>克隆 Rc<T>会增加引用计数</h2><p>文件名: src/main.rs</p>
<p>Rc::strong_count 获得引用计数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, Rc::<span class="title function_ invoke__">new</span>(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">3</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(<span class="number">4</span>, Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码会打印出：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.<span class="number">1.0</span> (file:<span class="comment">///projects/cons-list)</span></span><br><span class="line">    Finished dev [unoptimized + debuginfo] <span class="title function_ invoke__">target</span>(s) <span class="keyword">in</span> <span class="number">0.45</span>s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">count after creating a = <span class="number">1</span></span><br><span class="line">count after creating b = <span class="number">2</span></span><br><span class="line">count after creating c = <span class="number">3</span></span><br><span class="line">count after c goes out of scope = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们能够看到 a 中 Rc<List> 的初始引用计数为 1，接着每次调用 clone，计数会增加 1。当 c 离开作用域时，计数减 1。不必像调用 Rc::clone 增加引用计数那样调用一个函数来减少计数；Drop trait 的实现当 Rc<T> 值离开作用域时自动减少引用计数。</p>
<p>从这个例子我们所不能看到的是，在 main 的结尾当 b 然后是 a 离开作用域时，此处计数会是 0，同时 Rc<List> 被完全清理。使用 Rc<T> 允许一个值有多个所有者，引用计数则确保只要任何所有者依然存在其值也保持有效。</p>
<ul>
<li>Rc<T>通过<strong>不可变引用</strong>， Rc<T> 允许在程序的多个部分之间只读地共享数据。</li>
<li>如果 Rc<T> 也允许多个可变引用，则会违反第四章讨论的借用规则之一：相同位置的多个可变借用可能造成数据竞争和不一致。</li>
</ul>
<h2 id="RefCell和内部可变性"><a href="#RefCell和内部可变性" class="headerlink" title="RefCell和内部可变性"></a>RefCell<T>和内部可变性</h2><h3 id="内部可变性（interior-mutability"><a href="#内部可变性（interior-mutability" class="headerlink" title="内部可变性（interior mutability)"></a>内部可变性（interior mutability)</h3><ul>
<li>interior mutability 是 Rust 的设计模式之一</li>
<li>它允许你在支持有不可变引用的前提下对数据进行修改</li>
</ul>
<p>数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则</p>
<ul>
<li>与 Rc<T>不同，RefCell<T>类型代表了其持有数据的唯一所有权</li>
</ul>
<p>回忆借用规则：</p>
<ol>
<li>在任何给定的时间里，你要么只能拥有一个可变引用，要么只能拥有任意数量的不可变引用</li>
<li>引用总是有效的</li>
</ol>
<h3 id="RefCell与-Box的区别"><a href="#RefCell与-Box的区别" class="headerlink" title="RefCell与 Box的区别"></a>RefCell<T>与 Box<T>的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Box<T></th>
<th>RefCell<T></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>编译阶段</strong>强制代码遵守借用规则</td>
<td>只会在<strong>运行时</strong>检查借用规则</td>
</tr>
<tr>
<td>否则出现错误</td>
<td>否则触发 panic</td>
</tr>
</tbody>
</table>
</div>
<h3 id="借用规则在不同阶段进行检查的比较"><a href="#借用规则在不同阶段进行检查的比较" class="headerlink" title="借用规则在不同阶段进行检查的比较"></a>借用规则在不同阶段进行检查的比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>编译阶段</strong></th>
<th><strong>运行时</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>尽早暴露问题</td>
<td>问题暴露延后，甚至到生产环境</td>
</tr>
<tr>
<td>没有任何运行时开销</td>
<td>因借用计数产生些许性能损失</td>
</tr>
<tr>
<td>对大多数场景是最佳选择</td>
<td>实现某些特定的内存安全场景(不可变环境中修改自身数据)</td>
</tr>
<tr>
<td>是 Rust 的默认行为</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>与 Rc<T>类似，只能用于<strong>单线程</strong>场景</li>
</ul>
<h3 id="选择-Box，Rc，RefCell的依据"><a href="#选择-Box，Rc，RefCell的依据" class="headerlink" title="选择 Box，Rc，RefCell的依据"></a>选择 Box<T>，Rc<T>，RefCell<T>的依据</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Box<T></th>
<th>Rc<T></th>
<th>RefCell<T></th>
</tr>
</thead>
<tbody>
<tr>
<td>同一数据的所有者</td>
<td>一个</td>
<td>多个</td>
<td>一个</td>
</tr>
<tr>
<td>可变性,借用检查</td>
<td>可变，不可变借用(编译时检查)</td>
<td>不可变借用(编译时检查)</td>
<td>可变，不可变借用（运行时检查）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="内部可变性：可变的借用一个不可变的值"><a href="#内部可变性：可变的借用一个不可变的值" class="headerlink" title="内部可变性：可变的借用一个不可变的值"></a>内部可变性：可变的借用一个不可变的值</h3><p>借用规则的一个推论是当有一个不可变值时，不能可变地借用它。例如，如下代码不能编译：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果尝试编译，会得到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling borrowing v0.1.0 (file:///projects/borrowing)</span><br><span class="line">error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable</span><br><span class="line"> --&gt; src/main.rs:3:13</span><br></pre></td></tr></table></figure>
<p>如下是一个我们想要测试的场景：</p>
<p>我们在编写一个记录某个值与最大值的差距的库，并根据当前值与最大值的差距来发送消息。例如，这个库可以用于记录用户所允许的 API 调用数量限额。</p>
<p>该库只提供记录与最大值的差距，以及何种情况发送什么消息的功能。使用此库的程序则期望提供实际发送消息的机制：程序可以选择记录一条消息、发送 email、发送短信等等。库本身无需知道这些细节；只需实现其提供的 Messenger trait 即可。示例 15-20 展示了库代码：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Messenger</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="type">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">LimitTracker</span>&lt;<span class="symbol">&#x27;a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">&#x27;a</span> T,</span><br><span class="line">    value: <span class="type">usize</span>,</span><br><span class="line">    max: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, T&gt; LimitTracker&lt;<span class="symbol">&#x27;a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(messenger: &amp;T, max: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">percentage_of_max</span> = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.<span class="title function_ invoke__">send</span>(<span class="string">&quot;Error: You are over your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .<span class="title function_ invoke__">send</span>(<span class="string">&quot;Urgent warning: You&#x27;ve used up over 90% of your quota!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .<span class="title function_ invoke__">send</span>(<span class="string">&quot;Warning: You&#x27;ve used up over 75% of your quota!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        sent_messages: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: <span class="built_in">vec!</span>[],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">mock_messenger</span> = MockMessenger::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">limit_tracker</span> = LimitTracker::<span class="title function_ invoke__">new</span>(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.<span class="title function_ invoke__">set_value</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码中一个重要部分是拥有一个方法 send 的 Messenger trait，其获取一个 self 的<strong>不可变引用</strong>和文本信息。这个 trait 是 mock 对象所需要实现的接口库，这样 mock 就能像一个真正的对象那样使用了。另一个重要的部分是我们需要测试 LimitTracker 的 set_value 方法的行为。可以改变传递的 value 参数的值，不过 set_value 并没有返回任何可供断言的值。也就是说，如果使用某个实现了 Messenger trait 的值和特定的 max 创建 LimitTracker，当传递不同 value 值时，消息发送者应被告知发送合适的消息。</p>
<p>我们所需的 mock 对象是，调用 send 并不实际发送 email 或消息，而是只记录信息被通知要发送了。可以新建一个 mock 对象实例，用其创建 LimitTracker，调用 LimitTracker 的 set_value 方法，然后检查 mock 对象是否有我们期望的消息。示例 15-21 展示了一个如此尝试的 mock 对象实现，不过借用检查器并不允许：</p>
<p>然而，这个测试是有问题的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo <span class="built_in">test</span></span><br><span class="line">   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)</span><br><span class="line">error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</span><br><span class="line">  --&gt; src/lib.rs:58:13</span><br><span class="line">   |</span><br><span class="line">2  |     fn send(&amp;self, msg: &amp;str);</span><br><span class="line">   |             ----- <span class="built_in">help</span>: consider changing that to be a mutable reference: `&amp;mut self`</span><br><span class="line">...</span><br><span class="line">58 |             self.sent_messages.push(String::from(message));</span><br><span class="line">   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0596`.</span><br><span class="line">error: could not compile `limit-tracker` due to previous error</span><br><span class="line">warning: build failed, waiting <span class="keyword">for</span> other <span class="built_in">jobs</span> to finish...</span><br><span class="line">error: build failed</span><br></pre></td></tr></table></figure>
<p>不能修改 MockMessenger 来记录消息，因为 <strong>send 方法获取了 self 的不可变引用</strong>。我们也不能参考错误文本的建议使用 &amp;mut self 替代，因为这样 send 的签名就不符合 Messenger trait 定义中的签名了（可以试着这么改，看看会出现什么错误信息）。</p>
<p>这正是内部可变性的用武之地！我们将通过 RefCell 来储存 sent_messages，然后 send 将能够修改 sent_messages 并储存消息。</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Messenger</span> <span class="keyword">for</span> <span class="title class_">MockMessenger</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.<span class="title function_ invoke__">borrow_mut</span>().<span class="title function_ invoke__">push</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">it_sends_an_over_75_percent_warning_message</span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">len</span>(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-RefCell在运行时记录借用信息"><a href="#使用-RefCell在运行时记录借用信息" class="headerlink" title="使用 RefCell在运行时记录借用信息"></a>使用 RefCell<T>在运行时记录借用信息</h3><ul>
<li><p>两个方法（安全接口）</p>
<ol>
<li><p>borrow 方法：返回智能指针 Ref<T>，它实现了 Deref</p>
</li>
<li><p>borrow_mut 方法：返回 RefMut<T>，它实现了 Deref</p>
</li>
</ol>
</li>
<li><p>RefCell<T>会记录当前存在多少个活跃的 Ref<T>和 RefMut<T>智能指针</p>
<ol>
<li><p>每次调用 borrow：不可变借用计数+1</p>
</li>
<li><p>任何一个 Ref<T>的值离开作用域被释放时：不可变借用计数-1</p>
</li>
<li><p>每次调用 borrow_mut: 可变借用计数+1</p>
</li>
<li><p>任何一个 RefMut<T>的值利开作用域被释放时：可变借用计数-1</p>
</li>
</ol>
</li>
<li><p>Rust 以此计数来维护借用检查规则：任何一个给定时间里，只允许拥有多个不可变借用或一个可变借用</p>
</li>
</ul>
<h3 id="结合-Rc-和-RefCell-来拥有多个可变数据所有者"><a href="#结合-Rc-和-RefCell-来拥有多个可变数据所有者" class="headerlink" title="结合 Rc 和 RefCell 来拥有多个可变数据所有者"></a>结合 Rc 和 RefCell 来拥有多个可变数据所有者</h3><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(Rc&lt;RefCell&lt;<span class="type">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">value</span> = Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;value), Rc::<span class="title function_ invoke__">new</span>(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">3</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="title function_ invoke__">Cons</span>(Rc::<span class="title function_ invoke__">new</span>(RefCell::<span class="title function_ invoke__">new</span>(<span class="number">4</span>)), Rc::<span class="title function_ invoke__">clone</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.<span class="title function_ invoke__">borrow_mut</span>() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a after = &#123;:?&#125;&quot;</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b after = &#123;:?&#125;&quot;</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;c after = &#123;:?&#125;&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们打印出 a、b 和 c 时，可以看到他们都拥有修改后的值 15 而不是 5：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.63s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">a after = Cons(RefCell &#123; value: 15 &#125;, Nil)</span><br><span class="line">b after = Cons(RefCell &#123; value: 3 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br><span class="line">c after = Cons(RefCell &#123; value: 4 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span><br></pre></td></tr></table></figure>
<h2 id="其它可实现内部可变性的类型"><a href="#其它可实现内部可变性的类型" class="headerlink" title="其它可实现内部可变性的类型"></a>其它可实现内部可变性的类型</h2><ul>
<li>Cell<T>：通过复制来访问数据</li>
<li>Mutex<T>：用于实现跨线程的情形下的内部可变性模式</li>
</ul>
<h2 id="循环引用导致内存泄漏"><a href="#循环引用导致内存泄漏" class="headerlink" title="循环引用导致内存泄漏"></a>循环引用导致内存泄漏</h2><p>Rust 的内存安全性保证使其难以意外地制造永远也不会被清理的内存（被称为 <strong>内存泄漏</strong>（<em>memory leak</em>）），但并不是不可能。与在编译时拒绝数据竞争不同， Rust 并不保证完全地避免内存泄漏，这意味着内存泄漏在 Rust 被认为是内存安全的。这一点可以通过 Rc<T> 和 RefCell<T> 看出：创建引用循环的可能性是存在的。这会造成内存泄漏，因为每一项的引用计数永远也到不了 0，其值也永远不会被丢弃。</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 是一个链表，每个节点是 Cons(value, next) 或 Nil</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Cons</span>(<span class="type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">tail</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(_, item) =&gt; <span class="title function_ invoke__">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">5</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">new</span>(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a initial rc count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a next item = &#123;:?&#125;&quot;</span>, a.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">Cons</span>(<span class="number">10</span>, RefCell::<span class="title function_ invoke__">new</span>(Rc::<span class="title function_ invoke__">clone</span>(&amp;a))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after b creation = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b initial rc count = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b next item = &#123;:?&#125;&quot;</span>, b.<span class="title function_ invoke__">tail</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(link) = a.<span class="title function_ invoke__">tail</span>() &#123;</span><br><span class="line">        *link.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">clone</span>(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a rc count after changing a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uncomment the next line to see that we have a cycle;</span></span><br><span class="line">    <span class="comment">// it will overflow the stack</span></span><br><span class="line">    <span class="comment">// println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果保持最后的 println! 行注释并运行代码，会得到如下输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling cons-list v0.1.0 (file:///projects/cons-list)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.53s</span><br><span class="line">     Running `target/debug/cons-list`</span><br><span class="line">a initial rc count = 1</span><br><span class="line">a next item = Some(RefCell &#123; value: Nil &#125;)</span><br><span class="line">a rc count after b creation = 2</span><br><span class="line">b initial rc count = 1</span><br><span class="line">b next item = Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)</span><br><span class="line">b rc count after changing a = 2</span><br><span class="line">a rc count after changing a = 2</span><br></pre></td></tr></table></figure>
<p>如果取消最后 println! 的注释并运行程序，Rust 会尝试打印出 a 指向 b 指向 a 这样的循环直到栈溢出。这是因为：</p>
<p>在 Rust 中，<code>#[derive(Debug)]</code> 对枚举（比如链表）会生成一个递归打印逻辑：注意：<code>next</code> 也会调用 <code>Debug</code> → 又去打印它的 <code>next</code> → 递归调用，而且这个递归调用没有终止条件，因此最后会导致栈溢出</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Cons</span>(v, next) =&gt; &#123;</span><br><span class="line">                <span class="built_in">write!</span>(f, <span class="string">&quot;Cons(&#123;:?&#125;, &#123;:?&#125;)&quot;</span>, v, next)</span><br><span class="line">            &#125;</span><br><span class="line">            Nil =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Nil&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>防止内存泄漏的解决办法</strong></p>
<ul>
<li>依靠开发者来保证，不能依靠 Rust</li>
<li><p>重新组织数据结构：一些引用来表达所有权，一些引用不表达所有权</p>
<ol>
<li><p>循环引用中的一部分具有所有权关系，另一部分不涉及所有权关系</p>
</li>
<li><p>而只有所有权关系才影响值的清理</p>
</li>
</ol>
</li>
</ul>
<h3 id="避免引用循环：将-Rc-变为-Weak"><a href="#避免引用循环：将-Rc-变为-Weak" class="headerlink" title="避免引用循环：将 Rc 变为 Weak"></a>避免引用循环：将 Rc<T> 变为 Weak<T></h3><ul>
<li>Rc::clone 为 Rc<T>实例的 strong_count 加 1，Rc<T>的实例只有在 strong_count 为 0 时才会被清理</li>
<li><p><strong>Rc<T>实例通过调用 Rc::downgrade 方法可以创建值的 Weak Reference（弱引用）</strong></p>
<ol>
<li><p>返回类型是 Weak<T>（智能指针）</p>
</li>
<li><p>调用 Rc::downgrade 会为 weak_count 加 1</p>
</li>
</ol>
</li>
<li><p>Rc<T>使用 weak_count 来追踪存在多少 Weak<T></p>
</li>
<li><strong>weak_count 不为 0 并不影响 Rc<T>实例的清理</strong></li>
</ul>
<h3 id="Strong-VS-Weak"><a href="#Strong-VS-Weak" class="headerlink" title="Strong VS Weak"></a>Strong VS Weak</h3><ul>
<li>Strong Reference 是关于如何分享 Rc<T>实例的所有权</li>
<li>Weak Reference 并不表达上述意思</li>
<li>使用 Weak Reference 并不会创建循环引用：</li>
</ul>
<p><strong>当 Strong Reference 数量为 0 的时候，Weak Reference 会自动断开</strong></p>
<ul>
<li>在使用 Weak<T>前，需保证它指向的值仍然存在：</li>
</ul>
<p><strong>在 Weak<T>实例上调用 upgrade 方法，返回 Option<Rc<T>&gt;</strong></p>
<h4 id="创建树形数据结构：带有子节点的-Node"><a href="#创建树形数据结构：带有子节点的-Node" class="headerlink" title="创建树形数据结构：带有子节点的 Node"></a>创建树形数据结构：带有子节点的 Node</h4><p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里克隆了 leaf 中的 Rc<Node> 并储存在了 branch 中，这意味着 leaf 中的 Node 现在有两个所有者：leaf 和 branch。可以通过 branch.children 从 branch 中获得 leaf，不过无法从 leaf 到 branch。leaf 没有到 branch 的引用且并不知道他们相互关联。我们希望 leaf 知道 branch 是其父节点。稍后我们会这么做</p>
<h4 id="增加从子到父的引用"><a href="#增加从子到父的引用" class="headerlink" title="增加从子到父的引用"></a>增加从子到父的引用</h4><p>为了使子节点知道其父节点，需要在 Node 结构体定义中增加一个 parent 字段。问题是 parent 的类型应该是什么。我们知道其不能包含 Rc<T>，因为这样 leaf.parent 将会指向 branch 而 branch.children 会包含 leaf 的指针，这会形成引用循环，会造成其 strong_count 永远也不会为 0。</p>
<p>现在换一种方式思考这个关系:</p>
<ul>
<li><strong>父节点应该拥有其子节点</strong></li>
<li><strong>如果父节点被丢弃了，其子节点也应该被丢弃</strong></li>
<li>然而<strong>子节点不应该拥有其父节点</strong></li>
<li><strong>如果丢弃子节点，其父节点应该依然存在</strong>。</li>
</ul>
<p>这正是弱引用的例子！</p>
<p>所以 parent 使用 Weak<T> 类型而不是 Rc<T>，具体来说是 RefCell<Weak<Node>&gt;。现在 Node 结构体定义看起来像这样：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    value: <span class="type">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 leaf 节点类似于示例 15-27 中如何创建 leaf 节点的，除了 parent 字段有所不同：leaf 开始时没有父节点，所以我们新建了一个空的 Weak 引用实例。</p>
<p>此时，当尝试使用 upgrade 方法获取 leaf 的父节点引用时，会得到一个 None 值。如第一个 println! 输出所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leaf parent = None</span><br></pre></td></tr></table></figure>
<p>当创建 branch 节点时，其也会新建一个 Weak<Node> 引用，因为 branch 并没有父节点。leaf 仍然作为 branch 的一个子节点。一旦在 branch 中有了 Node 实例，就可以修改 leaf 使其拥有指向父节点的 Weak<Node> 引用。这里使用了 leaf 中 parent 字段里的 RefCell<Weak<Node>&gt; 的 borrow_mut 方法，接着使用了 Rc::downgrade 函数来从 branch 中的 Rc<Node> 值创建了一个指向 branch 的 Weak<Node> 引用。</p>
<p>当再次打印出 leaf 的父节点时，这一次将会得到存放了 branch 的 Some 值：现在 leaf 可以访问其父节点了！当打印出 leaf 时，我们也避免了如示例 15-26 中最终会导致栈溢出的循环：Weak<Node> 引用被打印为 (Weak)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;,</span><br><span class="line">children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;,</span><br><span class="line">children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span><br></pre></td></tr></table></figure>
<p>没有无限的输出表明这段代码并没有造成引用循环。这一点也可以从观察 Rc::strong_count 和 Rc::weak_count 调用的结果看出。</p>
<p><strong>可视化 strong_count 和 weak_count 的改变</strong>让我们通过创建了一个新的内部作用域并将 branch 的创建放入其中，来观察 Rc<Node> 实例的 strong_count 和 weak_count 值的变化。这会展示当 branch 创建和离开作用域被丢弃时会发生什么。这些修改如示例所示：</p>
<p>示例 ：在内部作用域创建 branch 并检查其强弱引用计数</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">leaf</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">        children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// leaf strong = 1, weak = 0</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">branch</span> = Rc::<span class="title function_ invoke__">new</span>(Node &#123;</span><br><span class="line">            value: <span class="number">5</span>,</span><br><span class="line">            parent: RefCell::<span class="title function_ invoke__">new</span>(Weak::<span class="title function_ invoke__">new</span>()),</span><br><span class="line">            children: RefCell::<span class="title function_ invoke__">new</span>(<span class="built_in">vec!</span>[Rc::<span class="title function_ invoke__">clone</span>(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.<span class="title function_ invoke__">borrow_mut</span>() = Rc::<span class="title function_ invoke__">downgrade</span>(&amp;branch);</span><br><span class="line"><span class="comment">// branch strong = 1, weak = 1</span></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;branch),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;branch),</span><br><span class="line">        );</span><br><span class="line"><span class="comment">// leaf strong = 2, weak = 0</span></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">            Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">            Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// leaf parent = None</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="title function_ invoke__">borrow</span>().<span class="title function_ invoke__">upgrade</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// leaf strong = 1, weak = 0</span></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,</span><br><span class="line">        Rc::<span class="title function_ invoke__">strong_count</span>(&amp;leaf),</span><br><span class="line">        Rc::<span class="title function_ invoke__">weak_count</span>(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦创建了 leaf，其 Rc<Node> 的强引用计数为 1，弱引用计数为 0。在内部作用域中创建了 branch 并与 leaf 相关联，此时 branch 中 Rc<Node> 的强引用计数为 1，弱引用计数为 1（因为 leaf.parent 通过 Weak<Node> 指向 branch）。这里 leaf 的强引用计数为 2，因为现在 branch 的 branch.children 中储存了 leaf 的 Rc<Node> 的拷贝，不过弱引用计数仍然为 0。</p>
<p>当内部作用域结束时，branch 离开作用域，Rc<Node> 的强引用计数减少为 0，所以其 Node 被丢弃。来自 leaf.parent 的弱引用计数 1 与 Node 是否被丢弃无关，所以并没有产生任何内存泄漏！</p>
<p>如果在内部作用域结束后尝试访问 leaf 的父节点，会再次得到 None。在程序的结尾，leaf 中 Rc<Node> 的强引用计数为 1，弱引用计数为 0，因为现在 leaf 又是 Rc<Node> 唯一的引用了。</p>
<p>所有这些管理计数和值的逻辑都内建于 Rc<T> 和 Weak<T> 以及它们的 Drop trait 实现中。通过在 Node 定义中指定从子节点到父节点的关系为一个 Weak<T>引用，就能够拥有父节点和子节点之间的双向引用而不会造成引用循环和内存泄漏。</p>
<h1 id="无畏并发"><a href="#无畏并发" class="headerlink" title="无畏并发"></a>无畏并发</h1><ul>
<li><strong>并发编程</strong>（<em>Concurrent programming</em>），代表程序的不同部分相互独立的执行，</li>
<li><strong>并行编程</strong>（<em>parallel programming</em>）代表程序不同部分于同时执行</li>
</ul>
<h2 id="使用线程同时运行代码"><a href="#使用线程同时运行代码" class="headerlink" title="使用线程同时运行代码"></a>使用线程同时运行代码</h2><p>在大部分现代操作系统中，已执行程序的代码在一个 <strong>进程</strong>（<em>process</em>）中运行，操作系统则负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分。运行这些独立部分的功能被称为 <strong>线程</strong>（<em>threads</em>）。</p>
<p>将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：</p>
<ul>
<li>竞态条件（Race conditions），多个线程以不一致的顺序访问数据或资源</li>
<li>死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行</li>
<li>只会发生在特定情况且难以稳定重现和修复的 bug</li>
</ul>
<p>编程语言有一些不同的方法来实现线程。</p>
<ul>
<li>很多操作系统提供了创建新线程的 API。这种由编程语言调用操作系统 API 创建线程的模型有时被称为 <em>1:1</em>，一个 OS 线程对应一个语言线程。<strong>Rust 标准库只提供了 1:1 线程实现</strong>；需要较小的运行时（即Rust 不需要额外的线程调度器或复杂机制，只需要跟踪线程句柄（handle），创建和销毁线程时调用 OS API，没有额外的用户态调度）。</li>
<li>有一些 crate 实现了其他有着不同取舍的线程模型，即语言自己实现的线程（绿色线程）：M:N 模型。需要较大的运行时</li>
</ul>
<h2 id="通过-spawn-创建新线程"><a href="#通过-spawn-创建新线程" class="headerlink" title="通过 spawn 创建新线程"></a>通过 spawn 创建新线程</h2><p>为了创建一个新线程，需要调用 <strong>thread::spawn</strong> 函数并传递一个闭包，并在其中包含希望在新线程运行的代码</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当主线程结束时，新线程也会结束，而不管其是否执行完毕。</p>
<h2 id="通过-join-Handle-来等待所有线程的完成"><a href="#通过-join-Handle-来等待所有线程的完成" class="headerlink" title="通过 join Handle 来等待所有线程的完成"></a>通过 join Handle 来等待所有线程的完成</h2><ul>
<li>thread::spawn 的返回值类型是 JoinHandle。</li>
<li><strong>JoinHandle 是一个拥有所有权的值</strong></li>
<li><strong>当对其调用 join 方法时，会阻止当前运行线程的执行，直到 handle 所表示的这些线程的终结。</strong></li>
</ul>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用 handle 的 join 会阻塞当前线程直到 handle 所代表的线程结束。<strong>阻塞</strong>（<em>Blocking</em>） 线程意味着阻止该线程执行工作或退出。因为我们将 join 调用放在了主线程的 for 循环之后，</p>
<h2 id="使用-move-闭包"><a href="#使用-move-闭包" class="headerlink" title="使用 move 闭包"></a>使用 move 闭包</h2><ul>
<li>move 闭包通常和 thread::spawn 函数一起使用，它允许你使用其他线程的数据</li>
<li>创建线程时，把值得所有权从一个线程转移到另一个线程</li>
</ul>
<p>示例: 尝试在另一个线程使用主线程创建的 vector</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闭包使用了 v，所以闭包会捕获 v 并使其成为闭包环境的一部分。因为 thread::spawn 在一个新线程中运行这个闭包，所以可以在新线程中访问 v。然而当编译这个例子时，会得到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling threads v0.1.0 (file:///projects/threads)</span><br><span class="line">error[E0373]: closure may outlive the current <span class="keyword">function</span>, but it borrows `v`, <span class="built_in">which</span> is owned by the current <span class="keyword">function</span></span><br><span class="line"> --&gt; src/main.rs:6:32</span><br><span class="line">  |</span><br><span class="line">6 |     <span class="built_in">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">  |                                ^^ may outlive borrowed value `v`</span><br><span class="line">7 |         println!(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">  |                                           - `v` is borrowed here</span><br><span class="line">  |</span><br><span class="line">note: <span class="keyword">function</span> requires argument <span class="built_in">type</span> to outlive `<span class="string">&#x27;static`</span></span><br><span class="line"><span class="string"> --&gt; src/main.rs:6:18</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">6 |       let handle = thread::spawn(|| &#123;</span></span><br><span class="line"><span class="string">  |  __________________^</span></span><br><span class="line"><span class="string">7 | |         println!(&quot;Here&#x27;</span>s a vector: &#123;:?&#125;<span class="string">&quot;, v);</span></span><br><span class="line"><span class="string">8 | |     &#125;);</span></span><br><span class="line"><span class="string">  | |______^</span></span><br><span class="line"><span class="string">help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword</span></span><br><span class="line"><span class="string">  |</span></span><br><span class="line"><span class="string">6 |     let handle = thread::spawn(move || &#123;</span></span><br><span class="line"><span class="string">  |                                ++++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0373`.</span></span><br><span class="line"><span class="string">error: could not compile `threads` due to previous error</span></span><br></pre></td></tr></table></figure>
<p>Rust 会 <strong>推断</strong> 如何捕获 v，因为 <strong>println! 只需要 v 的引用，闭包尝试借用 v</strong>。然而这有一个问题：<strong>Rust 不知道这个新建线程会执行多久，所以无法知晓 v 的引用是否一直有效</strong>。</p>
<p>示例 16-4 展示了一个 v 的引用很有可能不再有效的场景：</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">drop</span>(v); <span class="comment">// oh no!</span></span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在闭包之前增加 move 关键字，我们强制闭包获取其使用的值的所有权，而不是任由 Rust 推断它应该借用值。下面展示对代码的修改，可以按照我们的预期编译并运行：</p>
<p>示例: 使用 move 关键字强制获取它使用的值的所有权</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用消息传递来跨线程传递数据"><a href="#使用消息传递来跨线程传递数据" class="headerlink" title="使用消息传递来跨线程传递数据"></a>使用消息传递来跨线程传递数据</h2><p>一个日益流行的确保安全并发的方式是 <strong>消息传递</strong>（<em>message passing</em>），这里线程或 actor 通过发送包含数据的消息来相互沟通。这个思想来源于 [Go 编程语言文档中]的口号：“不要通过共享内存来通讯；而是通过通讯来共享内存。”（“Do not communicate by sharing memory; instead, share memory by communicating.”）</p>
<ul>
<li>线程（或 Actor）通过彼此发送消息（数据）来进行通信</li>
<li>Rust: Channel(标准库提供)</li>
</ul>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul>
<li>Channel 包含：<strong>发送端</strong>，<strong>接收端</strong></li>
<li>调用发送端的方法，发送数据</li>
<li>接收端会检查和接收到达的数据</li>
<li><strong>如果发送端，接收端中任意一端被丢弃了，那么 Channel 就被“关闭”了</strong></li>
</ul>
<h3 id="创建-Channel"><a href="#创建-Channel" class="headerlink" title="创建 Channel"></a>创建 Channel</h3><ul>
<li>使用<strong>mpsc::channel</strong> 函数来创建 Channel</li>
</ul>
<ol>
<li>mpsc 表示 <strong>multiple producer,single consumer</strong>(多个生产者，一个消费者)</li>
<li>返回一个 tuple(元组):里面元素分别是发送端，接收端</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">channel</span>&lt;T&gt;() <span class="punctuation">-&gt;</span> (Sender&lt;T&gt;, Receiver&lt;T&gt;)</span><br></pre></td></tr></table></figure>
<p>让我们将发送端移动到一个新建线程中并发送一个字符串，这样新建线程就可以和主线程通讯了</p>
<p>示例: 将 tx 移动到一个新建的线程中并发送 “hi”</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 阻塞主进程执行直到从信道中接受一个值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里再次使用 thread::spawn 来创建一个新线程并使用 move 将 tx 移动到闭包中这样新建线程就拥有 tx 了。新建线程需要拥有信道的发送端以便能向信道发送消息。</p>
<p>信道的发送端有一个 send 方法用来获取需要放入信道的值。send 方法返回一个 Result<T, E> 类型，所以<strong>如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误</strong>。在这个例子中，出错的时候调用 unwrap 产生 panic。不过对于一个真实程序，需要合理地处理它</p>
<p><strong>接收端的 recv 方法</strong></p>
<ul>
<li>信道的接收端有两个有用的方法：recv 和 try_recv。</li>
<li>这里，我们使用了 recv，它是 <em>receive</em> 的缩写。这个方法会<strong>阻塞主线程执行直到从信道中接收一个值</strong>。一旦发送了一个值，recv 会在一个 Result<T, E> 中返回它。当信道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了。</li>
<li><strong>try_recv 不会阻塞</strong>，相反它立刻返回一个 Result<T, E>：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息。如果线程在等待消息过程中还有其他工作时使用 try_recv 很有用：可以编写一个循环来频繁调用 try_recv，在有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。</li>
</ul>
<h3 id="信道与所有权转移"><a href="#信道与所有权转移" class="headerlink" title="信道与所有权转移"></a>信道与所有权转移</h3><p>现在让我们做一个试验来看看信道与所有权如何一同协作以避免产生问题：我们将尝试在新建线程中的信道中发送完 val 值 <strong>之后</strong> 再使用它。尝试编译下面的示例的代码并看看为何这是不允许的：</p>
<p>示例: 在我们已经发送到信道中后，尝试使用 val 引用</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;val is &#123;&#125;&quot;</span>, val);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里尝试在通过 tx.send 发送 val 到信道中之后将其打印出来。允许这么做是一个坏主意：</p>
<p><strong>一旦将值发送到另一个线程后，那个线程可能会在我们再次使用它之前就将其修改或者丢弃。其他线程对值可能的修改会由于不一致或不存在的数据而导致错误或意外的结果</strong>。</p>
<p>然而，尝试编译示例 16-9 的代码时，Rust 会给出一个错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling message-passing v0.1.0 (file:///projects/message-passing)</span><br><span class="line">error[E0382]: borrow of moved value: `val`</span><br><span class="line">  --&gt; src/main.rs:10:31</span><br><span class="line">   |</span><br><span class="line">8  |         <span class="built_in">let</span> val = String::from(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">   |             --- move occurs because `val` has <span class="built_in">type</span> `String`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">9  |         tx.send(val).unwrap();</span><br><span class="line">   |                 --- value moved here</span><br><span class="line">10 |         println!(<span class="string">&quot;val is &#123;&#125;&quot;</span>, val);</span><br><span class="line">   |                               ^^^ value borrowed here after move</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `message-passing` due to previous error</span><br></pre></td></tr></table></figure>
<p>我们的并发错误会造成一个编译时错误。send 函数获取其参数的所有权并移动这个值归接收者所有。这可以防止在发送后再次意外地使用这个值；所有权系统检查一切是否合乎规则。</p>
<h3 id="发送多个值并观察接收者的等待"><a href="#发送多个值并观察接收者的等待" class="headerlink" title="发送多个值并观察接收者的等待"></a>发送多个值并观察接收者的等待</h3><p>示例: 发送多个消息，并在每次发送后暂停一段时间</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一次，在新建线程中有一个字符串 vector 希望发送到主线程。我们遍历他们，单独的发送每一个字符串并通过一个 Duration 值调用 thread::sleep 函数来暂停一秒。</p>
<p>在主线程中，不再显式调用 recv 函数：而是将 rx 当作一个迭代器。对于每一个接收到的值，我们将其打印出来。当信道被关闭时，迭代器也将结束。</p>
<p>当运行示例 16-10 中的代码时，将看到如下输出，每一行都会暂停一秒：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br><span class="line">Got: from</span><br><span class="line">Got: the</span><br><span class="line">Got: thread</span><br></pre></td></tr></table></figure>
<p>因为主线程中的 for 循环里并没有任何暂停或等待的代码，所以可以说主线程是在等待从新建线程中接收值。</p>
<h3 id="通过克隆发送者来创建多个生产者"><a href="#通过克隆发送者来创建多个生产者" class="headerlink" title="通过克隆发送者来创建多个生产者"></a>通过克隆发送者来创建多个生产者</h3><p>示例: 从多个生产者发送多个消息</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx1.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;more&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;messages&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;for&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;you&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br></pre></td></tr></table></figure>
<p>这一次，在创建新线程之前，我们对信道的发送端调用了 clone 方法。这会给我们一个<strong>可以传递给第一个新建线程的发送端句柄</strong>。我们会将原始的信道发送端传递给第二个新建线程。这样就会有两个线程，每个线程将向信道的接收端发送不同的消息。</p>
<p>如果运行这些代码，你 <strong>可能</strong> 会看到这样的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Got: hi</span><br><span class="line">Got: more</span><br><span class="line">Got: from</span><br><span class="line">Got: messages</span><br><span class="line">Got: <span class="keyword">for</span></span><br><span class="line">Got: the</span><br><span class="line">Got: thread</span><br><span class="line">Got: you</span><br></pre></td></tr></table></figure>
<p>虽然你可能会看到这些值以不同的顺序出现；这依赖于你的系统。这也就是并发既有趣又困难的原因。如果通过 thread::sleep 做实验，在不同的线程中提供不同的值，就会发现他们的运行更加不确定，且每次都会产生不同的输出。</p>
<h2 id="共享状态并发"><a href="#共享状态并发" class="headerlink" title="共享状态并发"></a>共享状态并发</h2><ul>
<li>在某种程度上，任何编程语言中的信道都类似于单所有权，因为一旦将一个值传送到信道中，将无法再使用这个值。</li>
<li>共享内存类似于多所有权：多个线程可以同时访问相同的内存位置</li>
</ul>
<h3 id="互斥器一次只允许一个线程访问数据"><a href="#互斥器一次只允许一个线程访问数据" class="headerlink" title="互斥器一次只允许一个线程访问数据"></a>互斥器一次只允许一个线程访问数据</h3><p><strong>互斥器</strong>（<em>mutex</em>）是 <em>mutual exclusion</em> 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 <strong>锁</strong>（<em>lock</em>）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 <strong>保护</strong>（<em>guarding</em>）其数据。</p>
<p>互斥器以难以使用著称，因为你不得不记住：</p>
<ol>
<li><strong>在使用数据之前尝试获取锁。</strong></li>
<li><strong>处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁</strong>。</li>
</ol>
<p>在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。</p>
<h3 id="Mutex-的-API"><a href="#Mutex-的-API" class="headerlink" title="Mutex 的 API"></a>Mutex 的 API</h3><p>作为展示如何使用互斥器的例子，让我们从在单线程上下文使用互斥器开始，如示例所示：</p>
<p>示例: 出于简单的考虑，在一个单线程上下文中探索 Mutex<T> 的 API</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像很多类型一样，我们使用关联函数 new 来创建一个 Mutex<T>。使用 lock 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。</p>
<p>一旦获取了锁，就可以将返回值（在这里是 num）<strong>视为一个其内部数据的可变引用</strong>了。类型系统确保了我们在使用 m 中的值之前获取锁：Mutex<i32> 并不是一个 i32，所以 <strong>必须</strong> 获取锁才能使用这个 i32 值。我们是不会忘记这么做的，因为反之类型系统不允许访问内部的 i32 值。</p>
<p>Mutex<T> 是一个智能指针。更准确的说，<strong>lock 调用 返回 一个叫做 MutexGuard 的智能指针</strong>。<strong>这个智能指针实现了 Deref 来指向其内部数据；其也提供了一个 Drop 实现当 MutexGuard 离开作用域时自动释放锁</strong>，这正发生于示例 16-12 内部作用域的结尾。为此，我们不会忘记释放锁并阻塞互斥器为其它线程所用的风险，因为<strong>锁的释放是自动发生的</strong>。</p>
<h3 id="在线程间共享-Mutex"><a href="#在线程间共享-Mutex" class="headerlink" title="在线程间共享 Mutex"></a>在线程间共享 Mutex</h3><p>现在让我们尝试使用 Mutex<T> 在多个线程间共享值。我们将启动十个线程，并在各个线程中对同一个计数器值加一，这样计数器将从 0 变为 10。示例中的例子会出现编译错误，而我们将通过这些错误来学习如何使用 Mutex<T>，以及 Rust 又是如何帮助我们正确使用的。</p>
<p>示例: 程序启动了 10 个线程，每个线程都通过 Mutex<T> 来增加计数器的值</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个 counter 变量来存放内含 i32 的 Mutex<T>，类似示例 16-12 那样。接下来遍历 range 创建了 10 个线程。使用了 thread::spawn 并对所有线程使用了相同的闭包：他们每一个都将调用 lock 方法来获取 Mutex<T> 上的锁，接着将互斥器中的值加一。当一个线程结束执行，num 会离开闭包作用域并释放锁，这样另一个线程就可以获取它了。</p>
<p>在主线程中，我们收集了所有的 join 句柄，调用它们的 join 方法来确保所有线程都会结束。这时，主线程会获取锁并打印出程序的结果。</p>
<p>编译失败：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.<span class="number">1.0</span> (file:<span class="comment">///projects/shared-state)</span></span><br><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `counter`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">9</span>:<span class="number">36</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">5</span>  |     <span class="keyword">let</span> <span class="variable">counter</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">   |         ------- <span class="keyword">move</span> occurs because `counter` has <span class="keyword">type</span> `Mutex&lt;<span class="type">i32</span>&gt;`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">...</span><br><span class="line"><span class="number">9</span>  |         <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">   |                                    ^^^^^^^ value moved into closure here, <span class="keyword">in</span> previous iteration of <span class="keyword">loop</span></span><br><span class="line"><span class="number">10</span> |             <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">   |                           ------- <span class="keyword">use</span> occurs due to <span class="keyword">use</span> <span class="keyword">in</span> closure</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">error: could not compile `shared-state` due to previous error</span><br></pre></td></tr></table></figure>
<p>错误信息表明 counter 值在上一次循环中被移动了。所以 Rust 告诉我们<strong>不能将</strong> <strong>counter</strong> <strong>锁的所有权移动到多个线程中</strong>。</p>
<h3 id="多线程和多所有权"><a href="#多线程和多所有权" class="headerlink" title="多线程和多所有权"></a>多线程和多所有权</h3><p>通过使用智能指针 Rc<T> 来创建引用计数的值，可以拥有多所有者。</p>
<p>示例: 尝试使用 Rc<T> 来允许多个线程拥有 Mutex<T></p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再一次编译并…出现了不同的错误！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling shared-state v0.1.0 (file:///projects/shared-state)</span><br><span class="line">error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">   --&gt; src/main.rs:11:22</span><br><span class="line">    |</span><br><span class="line">11  |           <span class="built_in">let</span> handle = thread::spawn(move || &#123;</span><br><span class="line">    |  ______________________^^^^^^^^^^^^^_-</span><br><span class="line">    | |                      |</span><br><span class="line">    | |                      `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</span><br><span class="line">12  | |             <span class="built_in">let</span> mut num = counter.lock().unwrap();</span><br><span class="line">13  | |</span><br><span class="line">14  | |             *num += 1;</span><br><span class="line">15  | |         &#125;);</span><br><span class="line">    | |_________- within this `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">    |</span><br><span class="line">    = <span class="built_in">help</span>: within `[closure@src/main.rs:11:36: 15:10]`, the trait `Send` is not implemented <span class="keyword">for</span> `Rc&lt;Mutex&lt;i32&gt;&gt;`</span><br><span class="line">    = note: required because it appears within the <span class="built_in">type</span> `[closure@src/main.rs:11:36: 15:10]`</span><br><span class="line">note: required by a bound <span class="keyword">in</span> `spawn`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0277`.</span><br><span class="line">error: could not compile `shared-state` due to previous error</span><br></pre></td></tr></table></figure>
<p>第一行错误表明 Rc<Mutex<i32>&gt;<code>cannot be sent between threads safely</code>。编译器也告诉了我们原因 <code>the trait</code>Send<code>is not implemented for</code>Rc<Mutex<i32>&gt;。下一部分会讲到 Send：这是确保所使用的类型可以用于并发环境的 trait 之一。</p>
<p>不幸的是，<strong>Rc<T></strong> <strong>并不能安全的在线程间共享</strong>。当 Rc<T> 管理引用计数时，它必须在每一个 clone 调用时增加计数，并在每一个克隆被丢弃时减少计数。<strong>Rc<T></strong> <strong>并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断</strong>。在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。我们所需要的是一个完全类似 Rc<T>，又以一种线程安全的方式改变引用计数的类型。</p>
<h3 id="原子引用计数-Arc"><a href="#原子引用计数-Arc" class="headerlink" title="原子引用计数 Arc"></a>原子引用计数 Arc<T></h3><p>Arc<T><strong>正是</strong> 这么一个类似 Rc<T> 并可以安全的用于并发环境的类型。字母 “a” 代表 <strong>原子性</strong>（<em>atomic</em>），所以这是一个 <strong>原子引用计数</strong>（<em>atomically reference counted</em>）类型.</p>
<p>为什么不是所有的原始类型都是原子性的？为什么不是所有标准库中的类型都默认使用 Arc<T> 实现？</p>
<p>原因在于<strong>线程安全带有性能惩罚</strong>，我们希望只在必要时才为此买单。如果只是在单线程中对值进行操作，原子性提供的保证并无必要，代码可以因此运行的更快。</p>
<p>示例: 使用 Arc<T> 包装一个 Mutex<T> 能够实现在多线程之间共享所有权</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会打印出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Result</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="RefCell-Rc-与-Mutex-Arc-的相似性"><a href="#RefCell-Rc-与-Mutex-Arc-的相似性" class="headerlink" title="RefCell/Rc 与 Mutex/Arc 的相似性"></a>RefCell/Rc 与 Mutex/Arc 的相似性</h3><ul>
<li>因为 counter 是不可变的，不过可以获取其内部值的可变引用；这意味着 Mutex<T> 提供了内部可变性，就像 Cell 系列类型那样。正如使用 RefCell<T> 可以改变 Rc<T> 中的内容那样，同样的可以使用 Mutex<T> 来改变 Arc<T> 中的内容。</li>
<li>Rust 不能避免使用 Mutex<T> 的全部逻辑错误。回忆一下使用 Rc<T> 就有造成引用循环的风险，这时两个 Rc<T> 值相互引用，造成内存泄漏。同理，Mutex<T> 也有造成 <strong>死锁</strong>（<em>deadlock</em>） 的风险。这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。</li>
</ul>
<h2 id="使用-Sync-和-Send-trait-的可扩展并发"><a href="#使用-Sync-和-Send-trait-的可扩展并发" class="headerlink" title="使用 Sync 和 Send trait 的可扩展并发"></a>使用 Sync 和 Send trait 的可扩展并发</h2><p>Rust 的并发模型中一个有趣的方面是：语言本身对并发知之 <strong>甚少</strong>。我们之前讨论的几乎所有内容，都属于标准库，而不是语言本身的内容。由于不需要语言提供并发相关的基础设施，并发方案不受标准库或语言所限：我们可以编写自己的或使用别人编写的并发功能。</p>
<p>然而有两个并发概念是<strong>内嵌于语言中</strong>的：<strong>std::marker 中的 Sync 和 Send trait。</strong></p>
<h3 id="通过-Send-允许在线程间转移所有权"><a href="#通过-Send-允许在线程间转移所有权" class="headerlink" title="通过 Send 允许在线程间转移所有权"></a>通过 Send 允许在线程间转移所有权</h3><ul>
<li>Send 标记 trait 表明实现了 Send 的类型值的所有权可以在线程间传送。</li>
<li>几乎所有的 Rust 类型都是 Send 的，</li>
<li>不过有一些例外，包括 <strong>Rc<T>：这是不能 Send 的，</strong></li>
</ul>
<p>因为如果克隆了 Rc<T> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。为此，Rc<T> 被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价。</p>
<ul>
<li>Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 Rc<T> 在线程间发送。当尝试这么做的时候，会得到错误 the trait Send is not implemented for Rc<Mutex<i32>&gt;。而使用标记为 Send 的 Arc<T> 时，就没有问题了。</li>
<li>任何完全由 Send 的类型组成的类型也会自动被标记为 Send。<strong>几乎所有基本类型都是 Send 的，除了裸指针（raw pointer）</strong>。</li>
</ul>
<h3 id="Sync-允许多线程访问"><a href="#Sync-允许多线程访问" class="headerlink" title="Sync 允许多线程访问"></a>Sync 允许多线程访问</h3><ul>
<li>Sync 标记 trait 表明一个实现了 Sync 的类型可以<strong>安全的在多个线程中拥有其值的引用</strong>。</li>
<li>换一种方式来说，<strong>对于任意类型 T，如果 &amp;T（T 的不可变引用）是 Send 的话 T 就是 Sync 的</strong>，这意味着其引用就可以安全的发送到另一个线程。</li>
<li>类似于 Send 的情况，基本类型是 Sync 的，完全由 Sync 的类型组成的类型也是 Sync 的。</li>
<li><strong>智能指针 Rc<T> 也不是 Sync 的，出于其不是 Send 相同的原因。RefCell<T>和 Cell<T> 系列类型不是 Sync 的。RefCell<T> 在运行时所进行的借用检查也不是线程安全的。</strong></li>
<li><strong>Mutex<T> 是 Sync 的</strong>，正如 “在线程间共享 Mutex”部分所讲的它可以被用来在多线程中共享访问。</li>
</ul>
<h3 id="手动实现-Send-和-Sync-是不安全的"><a href="#手动实现-Send-和-Sync-是不安全的" class="headerlink" title="手动实现 Send 和 Sync 是不安全的"></a>手动实现 Send 和 Sync 是不安全的</h3><ul>
<li>通常并不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync 的。</li>
<li>因为他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的。</li>
<li>手动实现这些标记 trait 涉及到编写不安全的 Rust 代码，</li>
</ul>
<p>当前重要的是，在创建新的由不是 Send 和 Sync 的部分构成的并发类型时需要多加小心，以确保维持其安全保证。<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doc.rust-lang.org/nomicon/index.html">“The Rustonomicon”</a> 中有更多关于这些保证以及如何维持他们的信息。</p>
<h1 id="Rust-的面向对象特性"><a href="#Rust-的面向对象特性" class="headerlink" title="Rust 的面向对象特性"></a>Rust 的面向对象特性</h1><h2 id="面向对象语言的特点"><a href="#面向对象语言的特点" class="headerlink" title="面向对象语言的特点"></a>面向对象语言的特点</h2><ul>
<li><strong>对象包含数据和行为</strong></li>
</ul>
<p>在这个定义下，Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。虽然带有方法的结构体和枚举并不被 <strong>称为</strong> 对象，但是他们提供了与对象相同的功能，</p>
<ul>
<li><strong>封装隐藏了实现细节</strong></li>
</ul>
<p><strong>封装</strong>（<em>encapsulation</em>）的思想：对象的实现细节不能被使用对象的代码获取到。所以唯一与对象交互的方式是通过对象提供的公有 API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。封装使得改变和重构对象的内部时无需改变使用对象的代码。</p>
<p>Rust 中可以使用 pub 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的。</p>
<p>举例：</p>
<p>比如，我们可以定义一个包含一个 i32 类型 vector 的结构体 AveragedCollection。结构体也可以有一个字段，该字段保存了 vector 中所有值的平均值。这样，希望知道结构体中的 vector 的平均值的人可以随时获取它，而无需自己计算。换句话说，AveragedCollection 会为我们缓存平均值结果。下面示例有 AveragedCollection 结构体的定义：</p>
<p>示例: AveragedCollection 结构体维护了一个整型列表和集合中所有元素的平均值。</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">AveragedCollection</span> &#123;</span><br><span class="line">    list: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    average: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<strong>结构体自身被标记为 pub，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的</strong>。这是非常重要的，因为我们希望保证变量被增加到列表或者被从列表删除时，也会同时更新平均值。可以通过在结构体上实现 add、remove 和 average 方法来做到这一点，如示例所示：</p>
<p>示例: 在 AveragedCollection 结构体上实现了 add、remove 和 average 公有方法</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">AveragedCollection</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.list.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">update_average</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">remove</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">self</span>.list.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">update_average</span>();</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">average</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.average</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">update_average</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = <span class="keyword">self</span>.list.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">sum</span>();</span><br><span class="line">        <span class="keyword">self</span>.average = total <span class="keyword">as</span> <span class="type">f64</span> / <span class="keyword">self</span>.list.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">f64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公有方法 add、remove 和 average 是修改 AveragedCollection 实例的唯一方式。当使用 add 方法把一个元素加入到 list 或者使用 remove 方法来删除时，这些方法的实现同时会调用私有的 update_average 方法来更新 average 字段。</p>
<p>list 和 average 是私有的，所以没有其他方式来使得外部的代码直接向 list 增加或者删除元素，否则 list 改变时可能会导致 average 字段不同步。average 方法返回 average 字段的值，这使得外部的代码只能读取 average 而不能修改它。</p>
<p>因为我们已经封装好了 AveragedCollection 的实现细节，将来可以轻松改变类似数据结构这些方面的内容。例如，可以使用 HashSet<i32> 代替 Vec<i32> 作为 list 字段的类型。只要 add、remove 和 average 公有函数的签名保持不变，使用 AveragedCollection 的代码就无需改变。相反如果使得 list 为公有，就未必都会如此了： HashSet<i32> 和 Vec<i32> 使用不同的方法增加或移除项，所以如果要想直接修改 list 的话，外部的代码可能不得不做出修改。</p>
<p>如果封装是一个语言被认为是面向对象语言所必要的方面的话，那么 Rust 满足这个要求。在代码中不同的部分使用 pub 与否可以封装其实现细节。</p>
<ul>
<li><strong>继承，作为类型系统与代码共享</strong></li>
</ul>
<p><strong>继承</strong>（<em>Inheritance</em>）是一个很多编程语言都提供的机制，一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。</p>
<p><strong>如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的</strong>。无法定义一个结构体继承父结构体的成员和方法。然而，如果你过去常常在你的编程工具箱使用继承，根据你最初考虑继承的原因，Rust 也提供了其他的解决方案。</p>
<p>选择继承有两个主要的原因。</p>
<ol>
<li>第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现。相反 Rust 代码可以使用默认 trait 方法实现来进行共享，</li>
<li>第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。这也被称为 <strong>多态</strong>（<em>polymorphism</em>），这意味着如果多种对象共享特定的属性，则可以相互替代使用。</li>
</ol>
<p>近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。<strong>子类不应总是共享其父类的所有特征，但是继承却始终如此。如此会使程序设计更为不灵活，并引入无意义的子类方法调用</strong>，或由于方法实际并不适用于子类而造成错误的可能性。某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。</p>
<h2 id="不同类型值的-trait-对象"><a href="#不同类型值的-trait-对象" class="headerlink" title="不同类型值的 trait 对象"></a>不同类型值的 trait 对象</h2><p>vector 只能存储同种类型元素的局限。我们之前的示例中提供了一个定义 SpreadsheetCell 枚举来储存整型，浮点型和文本成员的替代方案。这意味着可以在每个单元中储存不同类型的数据，并仍能拥有一个代表一排单元的 vector。这在当编译代码时就知道希望可以交替使用的类型为固定集合的情况下是完全可行的。</p>
<p><strong>然而有时我们希望库用户在特定情况下能够扩展有效的类型集合。</strong></p>
<p>为了展示如何实现这一点，这里将创建一个图形用户接口（Graphical User Interface， GUI）工具的例子，它通过遍历列表并调用每一个项目的 draw 方法来将其绘制到屏幕上 —— 此乃一个 GUI 工具的常见技术。我们将要创建一个叫做 gui 的库 crate，它含一个 GUI 库的结构。这个 GUI 库包含一些可供开发者使用的类型，比如 Button 或 TextField。在此之上，gui 的用户希望创建自定义的可以绘制于屏幕上的类型：比如，一个程序员可能会增加 Image，另一个可能会增加 SelectBox。</p>
<p>这个例子中并不会实现一个功能完善的 GUI 库，不过会展示其中各个部分是如何结合在一起的。编写库的时候，我们不可能知晓并定义所有其他程序员希望创建的类型。我们所知晓的是 gui 需要记录一系列不同类型的值，并需要能够对其中每一个值调用 draw 方法。这里无需知道调用 draw 方法时具体会发生什么，只要该值会有那个方法可供我们调用。</p>
<p>在拥有继承的语言中，可以定义一个名为 Component 的类，该类上有一个 draw 方法。其他的类比如 Button、Image 和 SelectBox 会从 Component 派生并因此继承 draw 方法。它们各自都可以覆盖 draw 方法来定义自己的行为，但是框架会把所有这些类型当作是 Component 的实例，并在其上调用 draw。</p>
<p>不过 Rust 并没有继承，我们得另寻出路。</p>
<h2 id="定义通用行为的-trait"><a href="#定义通用行为的-trait" class="headerlink" title="定义通用行为的 trait"></a>定义通用行为的 trait</h2><p>为了实现 gui 所期望的行为，让我们定义一个 Draw trait，其中包含名为 draw 的方法。接着可以定义一个存放 <strong>trait 对象（trait object）</strong> 的 vector。trait 对象指向一个实现了我们指定 trait 的类型的实例，以及一个用于在运行时查找该类型的 trait 方法的表。我们通过指定某种指针来创建 trait 对象，例如 &amp; 引用或 Box<T> 智能指针，还有 dyn keyword， 以及指定相关的 trait（ [“动态大小类型和 Sized trait”] 部分会介绍 trait 对象必须使用指针的原因）。我们可以使用 trait 对象代替泛型或具体类型。任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。如此便无需在编译时就知晓所有可能的类型。</p>
<p>Rust 刻意不将结构体与枚举称为 “对象”，以便与其他语言中的对象相区别。在结构体或枚举中，结构体字段中的数据和 impl 块中的行为是分开的，不同于其他语言中将数据和行为组合进一个称为对象的概念中。</p>
<p>trait 对象将数据和行为两者相结合，从这种意义上说 <strong>则</strong> 其更类似其他语言中的对象。不过 trait 对象不同于传统的对象，因为不能向 trait 对象增加数据。trait 对象并不像其他语言中的对象那么通用：其（trait 对象）具体的作用是允许对通用行为进行抽象。</p>
<p>下面的示例展示了如何定义一个带有 draw 方法的 trait Draw：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面定义了一个存放了名叫 components 的 vector 的结构体 Screen。这个 vector 的类型是 Box<dyn Draw>，此为一个 trait 对象：它是 Box 中任何实现了 Draw trait 的类型的替身。</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例: 一个 Screen 结构体的定义，它带有一个字段 components，其包含实现了 Draw trait 的 trait 对象的 vector</p>
<p>在 Screen 结构体上，我们将定义一个 run 方法，该方法会对其 components 上的每一个组件调用 draw 方法，如示例所示：</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与定义使用了带有 trait bound 的泛型类型参数的结构体不同。<strong>泛型类型参数一次只能替代一个具体类型</strong>，而 <strong>trait 对象则允许在运行时替代多种具体类型</strong>。例如，可以定义 Screen 结构体来使用泛型和 trait bound，如示例所示：</p>
<p>示例: 一种 Screen 结构体的替代实现，其 run 方法使用泛型和 trait bound</p>
<p>文件名: src/lib.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span>&lt;T: Draw&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Screen&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Draw,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这<strong>限制了</strong>Screen 实例中的Vec存放的元素必须是相同类型的，即必须拥有一个全是 Button 类型或者全是 TextField 类型的组件列表。如果只需要<strong>同质（相同类型）集合</strong>，则倾向于使用泛型和 trait bound，因为其定义会在编译时采用具体类型进行单态化。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">component</span> <span class="keyword">in</span> <span class="keyword">self</span>.components.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            component.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，通过使用 trait 对象的方法，一个 Screen 实例可以存放一个既能存放Button，也能包含TextField的智能指针的 Vec<T>。</p>
<p><strong>实现 trait</strong></p>
<p>现在来增加一些实现了 Draw trait 的类型。我们将提供 Button 类型。真正实现 GUI 库超出了范畴，所以 draw 方法体中不会有任何有意义的实现。为了想象一下这个实现看起来像什么，一个 Button 结构体可能会拥有 width、height 和 label 字段，如示例所示：</p>
<p>文件名: src/lib.rs</p>
<p>示例: 一个实现了 Draw trait 的 Button 结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a button</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Button 上的 width、height 和 label 字段会和其他组件不同，比如 TextField 可能有 width、height、label 以及 placeholder 字段。每一个我们希望能在屏幕上绘制的类型都会使用不同的代码来实现 Draw trait 的 draw 方法来定义如何绘制特定的类型，像这里的 Button 类型（并不包含任何实际的 GUI 代码，这超出了本章的范畴）。除了实现 Draw trait 之外，比如 Button 还可能有另一个包含按钮点击如何响应的方法的 impl 块。这类方法并不适用于像 TextField 这样的类型。</p>
<p>如果一些库的使用者决定实现一个包含 width、height 和 options 字段的结构体 SelectBox，并且也为其实现了 Draw trait，如示例所示：</p>
<p>示例: 另一个使用 gui 的 crate 中，在 SelectBox 结构体上实现 Draw trait</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::Draw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    options: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// code to actually draw a select box</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>库使用者现在可以在他们的 main 函数中创建一个 Screen 实例。至此可以通过将 SelectBox 和 Button 放入 Box<T> 转变为 trait 对象来增加组件。接着可以调用 Screen 的 run 方法，它会调用每个组件的 draw 方法。下面示例展示了这个实现：</p>
<p>示例: 使用 trait 对象来存储实现了相同 trait 的不同类型的值</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::&#123;Button, Screen&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">screen</span> = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(SelectBox &#123;</span><br><span class="line">                width: <span class="number">75</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                options: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yes&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Maybe&quot;</span>),</span><br><span class="line">                    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;No&quot;</span>),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;OK&quot;</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当编写库的时候，我们不知道何人会在何时增加 SelectBox 类型，不过 Screen 的实现能够操作并绘制这个新类型，因为 SelectBox 实现了 Draw trait，这意味着它实现了 draw 方法。</p>
<p>这个概念 —— 只关心值所反映的信息而不是其具体类型 —— 类似于动态类型语言中称为 <strong>鸭子类型</strong>（<em>duck typing</em>）的概念：如果它走起来像一只鸭子，叫起来像一只鸭子，那么它就是一只鸭子！在示例中 Screen 上的 run 实现中，run 并不需要知道各个组件的具体类型是什么。<strong>它并不检查组件是</strong> <strong>Button</strong> <strong>或者</strong> <strong>SelectBox</strong> <strong>的实例</strong>。<strong>通过指定</strong> <strong>Box<dyn Draw></strong> <strong>作为</strong> <strong>components</strong> <strong>vector 中值的类型</strong>，我们就定义了 Screen 为需要可以在其上调用 draw 方法的值。</p>
<p>使用 trait 对象和 Rust 类型系统来进行类似鸭子类型操作的优势是无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。如果值没有实现 trait 对象所需的 trait 则 Rust 不会编译这些代码。</p>
<p>例如，示例展示了当创建一个使用 String 做为其组件的 Screen 时发生的情况：</p>
<p>示例: 尝试使用一种没有实现 trait 对象的 trait 的类型</p>
<p>文件名: src/main.rs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> gui::Screen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">screen</span> = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>))],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    screen.<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们会遇到这个错误，因为 String 没有实现 rust_gui::Draw trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling gui v0.<span class="number">1.0</span> (file:<span class="comment">///projects/gui)</span></span><br><span class="line">error[E0277]: the <span class="keyword">trait</span> <span class="title class_">bound</span> `<span class="type">String</span>: Draw` is not satisfied</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">5</span>:<span class="number">26</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">5</span> |         components: <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hi&quot;</span>))],</span><br><span class="line">  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the <span class="keyword">trait</span> `Draw` is not implemented <span class="keyword">for</span> `<span class="type">String</span>`</span><br><span class="line">  |</span><br><span class="line">  = note: required <span class="keyword">for</span> <span class="title class_">the</span> cast to the object <span class="keyword">type</span> `<span class="keyword">dyn</span> Draw`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0277`.</span><br><span class="line">error: could not compile `gui` due to previous error</span><br></pre></td></tr></table></figure>
<p>这告诉了我们，要么是我们传递了并不希望传递给 Screen 的类型并应该提供其他类型，要么应该在 String 上实现 Draw 以便 Screen 可以调用其上的 draw。</p>
<h2 id="trait-对象执行动态分发"><a href="#trait-对象执行动态分发" class="headerlink" title="trait 对象执行动态分发"></a>trait 对象执行动态分发</h2><ul>
<li>对泛型使用 trait bound 时编译器所执行的单态化处理：编译器为每一个被泛型类型参数代替的具体类型生成了函数和方法的非泛型实现。单态化产生的代码在执行 <strong>静态分发</strong>（<em>static dispatch</em>）。</li>
<li>静态分发发生于编译器在编译时就知晓调用了什么方法的时候。</li>
<li><strong>动态分发</strong> （<em>dynamic dispatch</em> 编译器在编译时无法知晓调用了什么方法。</li>
<li>在动态分发的场景下，编译器生成的代码到运行时才能确定调用了什么方法。</li>
</ul>
<p><strong>当使用 trait 对象时，Rust 必须使用动态分发</strong>。编译器无法知晓所有可能用于 trait 对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。为此，Rust 在运行时使用 trait 对象中的指针来知晓需要调用哪个方法。<strong>动态分发也阻止编译器有选择的内联方法代码</strong>，这会相应的<strong>禁用一些优化</strong>。尽管在编写示例和可以支持示例中的代码的过程中确实获得了额外的灵活性，但仍然需要权衡取舍。</p>
<h2 id="trait-对象需要类型安全"><a href="#trait-对象需要类型安全" class="headerlink" title="trait 对象需要类型安全"></a>trait 对象需要类型安全</h2><p><strong>只有对象安全（object-safe）的 trait 可以实现为 特征(dyn)对象</strong> 。</p>
<p>这里有一些复杂的规则来实现 trait 的对象安全，但在实践中，只有两个相关的规则。</p>
<p><strong>如果一个 trait 中定义的所有方法都符合以下规则，则该 trait 是对象安全的：</strong></p>
<ul>
<li><strong>返回值不是 Self</strong></li>
<li><strong>没有泛型类型的参数</strong></li>
</ul>
<p>我们使用triat对象我们实际上是在做 <strong>动态分发</strong>。Rust 在运行时通过一个叫 <strong>vtable</strong> 的方法表来找到对应的方法实现。为了做到这一点，trait 的方法必须能够在编译时 <strong>完全确定方法签名</strong>（包括返回值的类型信息等），不能依赖未知的类型信息。</p>
<p>但是某些 trait 的方法依赖了 <code>Self</code> 或泛型，这样编译器就无法保证动态分发是安全的。</p>
<p><strong>一个非对象安全的 trait 例子是标准库中的</strong> <strong>Clone</strong> <strong>trait</strong>。Clone trait 中的 clone 方法的声明如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Clone</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">clone</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String 类型实现了 Clone trait，当我们在 String 的实例对象上调用 clone 方法时，我们会得到一个 String 类型实例对象。相似地，如果我们调用 Vec<T> 实例对象上的 clone 方法，我们会得到一个 Vec<T> 类型的实例对象。clone 方法的标签需要知道哪个类型是 Self 类型，因为 Self 是它的返回类型。</p>
<p>当我们尝试编译一些违反 trait 对象的对象安全规则的代码时，我们会收到编译器的提示。例如，我们想实现的 Screen 结构体来保存一个实现了 Clone trait 而不是 Draw trait 的类型，如下所示</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Clone</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将会收到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br><span class="line">   Compiling gui v0.1.0 (file:///projects/gui)</span><br><span class="line">error[E0038]: the trait `Clone` cannot be made into an object</span><br><span class="line"> --&gt; src/lib.rs:2:29</span><br><span class="line">  |</span><br><span class="line">2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,</span><br><span class="line">  |                             ^^^^^^^^^ `Clone` cannot be made into an object</span><br><span class="line">  |</span><br><span class="line">  = note: the trait cannot be made into an object because it requires `Self: Sized`</span><br><span class="line">  = note: <span class="keyword">for</span> a trait to be <span class="string">&quot;object safe&quot;</span> it needs to allow building a vtable to allow the call to be resolvable dynamically; <span class="keyword">for</span> more information visit &lt;https://doc.rust-lang.org/reference/items/traits.html#object-safety&gt;</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0038`.</span><br><span class="line">error: could not compile `gui` due to previous error</span><br></pre></td></tr></table></figure>
<p>这个错误意味着我们不能将此 trait 用于 trait 对象。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用至少两种方法让代码工作</span></span><br><span class="line"><span class="comment">// 不要添加/删除任何代码行</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">MyTrait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">u32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123; <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt;)  &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">13_u32</span>));</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一种方式修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">MyTrait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">u32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; <span class="number">42</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>(x: <span class="keyword">impl</span> <span class="title class_">MyTrait</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">MyTrait</span>  &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="number">13_u32</span>);</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">MyTrait</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">u32</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt; &#123; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">42</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MyTrait</span> <span class="keyword">for</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">f</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt; &#123; <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>()) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_function</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyTrait&gt; &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">13_u32</span>));</span><br><span class="line">    <span class="title function_ invoke__">my_function</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向对象设计模式的实现"><a href="#面向对象设计模式的实现" class="headerlink" title="面向对象设计模式的实现"></a>面向对象设计模式的实现</h2><ul>
<li><strong>状态模式</strong>（<em>state pattern</em>）是一个面向对象设计模式。该模式的关键在于一个值有某些内部状态，体现为一系列的 <strong>状态对象</strong>，同时值的行为随着其内部状态而改变</li>
<li>状态对象共享功能：在 Rust 中使用结构体和 trait 而不是对象和继承。每一个状态对象负责其自身的行为，以及该状态何时应当转移至另一个状态。持有一个状态对象的值对于不同状态的行为以及何时状态转移毫不知情。</li>
<li>使用状态模式意味着当程序的业务需求改变时，无需改变值持有状态或者使用值的代码。我们只需更新某个状态对象中的代码来改变其规则，或者是增加更多的状态对象。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, _post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    state: <span class="type">Option</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt;&gt;,</span><br><span class="line">    content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Post &#123;</span><br><span class="line">        Post &#123;</span><br><span class="line">            state: <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Draft &#123;&#125;)),</span><br><span class="line">            content: <span class="type">String</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_text</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, text: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.content.<span class="title function_ invoke__">push_str</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">content</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        <span class="comment">// 委托给状态对象决定是否返回内容</span></span><br><span class="line">        <span class="keyword">self</span>.state.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">content</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">request_review</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="title function_ invoke__">Some</span>(s.<span class="title function_ invoke__">request_review</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">approve</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(s) = <span class="keyword">self</span>.state.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="title function_ invoke__">Some</span>(s.<span class="title function_ invoke__">approve</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 状态实现 =====</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Draft</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">Draft</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(PendingReview &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PendingReview</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">PendingReview</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Published &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Published</span> &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">State</span> <span class="keyword">for</span> <span class="title class_">Published</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">request_review</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">approve</span>(<span class="keyword">self</span>: <span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> State&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="comment">// ignore</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">content</span>&lt;<span class="symbol">&#x27;a</span>&gt;(&amp;<span class="keyword">self</span>, post: &amp;<span class="symbol">&#x27;a</span> Post) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">        &amp;post.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 测试 =====</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">post</span> = Post::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    post.<span class="title function_ invoke__">add_text</span>(<span class="string">&quot;Rust makes systems programming safe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;&quot;</span>, post.<span class="title function_ invoke__">content</span>()); <span class="comment">// 还在草稿，不能看内容</span></span><br><span class="line"></span><br><span class="line">    post.<span class="title function_ invoke__">request_review</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;&quot;</span>, post.<span class="title function_ invoke__">content</span>()); <span class="comment">// 待审核，还是不能看内容</span></span><br><span class="line"></span><br><span class="line">    post.<span class="title function_ invoke__">approve</span>();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&quot;Rust makes systems programming safe!&quot;</span>, post.<span class="title function_ invoke__">content</span>()); <span class="comment">// 发布了！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Published content: &#123;&#125;&quot;</span>, post.<span class="title function_ invoke__">content</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="模式与模式匹配"><a href="#模式与模式匹配" class="headerlink" title="模式与模式匹配"></a>模式与模式匹配</h1><p><strong>模式：</strong></p>
<ul>
<li>模式是 Rust 中的一种特殊语法，用于匹配复杂和简单类型的结构</li>
<li>将模式与匹配表达式和其它构造结合使用，可以更好地控制程序的控制流</li>
<li>模式由以下元素(的一些组合)组成：<ul>
<li>字面值</li>
<li>解构的数组，enum,struct 和 tuple</li>
<li>变量</li>
<li>通配符</li>
<li>占位符</li>
</ul>
</li>
</ul>
<h2 id="match-的-Arm"><a href="#match-的-Arm" class="headerlink" title="match 的 Arm"></a>match 的 Arm</h2><ul>
<li>match VALUE{PARTTERN=&gt;EXPRESSION,PARTTERN=&gt;EXPRESSION,PARTTERN=&gt;EXPRESSION,}</li>
<li><p>表达式的要求：详尽（包含所有的可能性）</p>
</li>
<li><p>一个特殊的模式：_ (下划线)：它不会匹配任何东西，不会绑定到变量，通常用于 match 的最后一个 arm，或用于忽略某些值</p>
</li>
</ul>
<h2 id="条件-if-let-表达式"><a href="#条件-if-let-表达式" class="headerlink" title="条件 if let 表达式"></a>条件 if let 表达式</h2><ul>
<li>if let 表达式主要是作为一种简短的方式来等价的替代只有一个匹配项的 match</li>
<li>if let 可选的可以拥有 else，包括：<ul>
<li>else if</li>
<li>else if let</li>
</ul>
</li>
</ul>
<ul>
<li>但，if let 不会检查穷举性例子：</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">favorite_color</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_tuesday</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span>: <span class="type">Result</span>&lt;<span class="type">u8</span>,_&gt; = <span class="string">&quot;34&quot;</span>.<span class="title function_ invoke__">parse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(color) = favorite_color&#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;Using your favorite color,&#123;&#125;,as the background&quot;</span>,color);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> is_tuesday&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Tuesday is green day!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(age) = age &#123;</span><br><span class="line">        <span class="keyword">if</span> age &gt; <span class="number">30</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Using purple as the background color&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Using orange as the background color&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Using blue as the background color&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="while-let-条件循环"><a href="#while-let-条件循环" class="headerlink" title="while let 条件循环"></a>while let 条件循环</h2><ul>
<li>只要模式继续满足匹配的条件，那它允许 while 循环一直运行</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-循环的模式匹配"><a href="#for-循环的模式匹配" class="headerlink" title="for 循环的模式匹配"></a>for 循环的模式匹配</h2><ul>
<li>for 循环是 Rust 中最常见的循环</li>
<li>for 循环中，模式就是紧随 for 关键字后的值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">   <span class="keyword">for</span> (index,value) <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>()&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>,value,index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iter().enumerate()返回的是一个元组</p>
<h2 id="let-语句的模式匹配"><a href="#let-语句的模式匹配" class="headerlink" title="let 语句的模式匹配"></a>let 语句的模式匹配</h2><ul>
<li>let 语句也是模式</li>
<li>let PARTTERN = EXPRESSION</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> (x,y,z) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ul>
<li>函数的参数也可以是模式</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_coordinates</span>(&amp;(x,y): &amp;(<span class="type">i32</span>,<span class="type">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Current location: (&#123;&#125;,&#123;&#125;)&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = (<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_coordinates</span>(&amp;point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可辨驳性：模式是否会无法匹配"><a href="#可辨驳性：模式是否会无法匹配" class="headerlink" title="可辨驳性：模式是否会无法匹配"></a>可辨驳性：模式是否会无法匹配</h2><ul>
<li>模式的两种形式：可辨驳的，无可辩驳的</li>
<li>能匹配任何可能传值的模式：无可辩驳的 入 let x= 4;</li>
<li>对某些可能的值，无法进行匹配的模式:可辨驳的 例如：if let Some(x) = a_value</li>
<li><strong>函数参数，let 语句，for 循环只接受无可辩驳的模式</strong></li>
<li><strong>if let 和 while let 接受可辨驳和无可辩驳的模式</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Some</span>(x) = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">error[E0005]: refutable pattern <span class="keyword">in</span> <span class="built_in">local</span> binding: `None` not covered</span><br><span class="line">   --&gt; src\main.rs:3:9</span><br><span class="line">    |</span><br><span class="line">3   |     <span class="built_in">let</span> Some(x) = a;</span><br><span class="line">    |         ^^^^^^^ pattern `None` not covered</span><br><span class="line">    |</span><br><span class="line">    = note: `<span class="built_in">let</span>` bindings require an <span class="string">&quot;irrefutable pattern&quot;</span>, like a `struct` or an `enum` with only one variant</span><br><span class="line">    = note: <span class="keyword">for</span> more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html</span><br></pre></td></tr></table></figure>
<p>无法匹配，因为模式没有覆盖 None 这种情况</p>
<p>修改</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(x) = a&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match 除了最后一个分支，其它的分支都是可辨驳的，最后一个分支是不可辩驳的，因为它需要匹配所有剩余的情况</p>
<h2 id="匹配字面值"><a href="#匹配字面值" class="headerlink" title="匹配字面值"></a>匹配字面值</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h2><ul>
<li>命名的变量是可匹配任何值的无可辩驳模式</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched,y=&#123;:?&#125;&quot;</span>,y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default Case,x=&#123;:?&#125;&quot;</span>,x),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x=&#123;:?&#125;,y=&#123;:?&#125;&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 match 的第二个 arm 中<strong>y 是一个新的变量</strong>，存在于该 arm 的作用域</p>
<h2 id="匹配一个可变引用"><a href="#匹配一个可变引用" class="headerlink" title="匹配一个可变引用"></a>匹配一个可变引用</h2><p>使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V<strong>是一个值</strong>，而<strong>不是可变引用</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;<span class="keyword">mut</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> r &#123;</span><br><span class="line">        <span class="comment">// The type of value is &amp;mut String</span></span><br><span class="line">       value =&gt; value.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; world!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重模式"><a href="#多重模式" class="headerlink" title="多重模式"></a>多重模式</h2><ul>
<li>在 match 表达式中，使用 | 语法（就是或的意思）可以匹配多种模式</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-来匹配某个范围的值"><a href="#使用-来匹配某个范围的值" class="headerlink" title="使用..=来匹配某个范围的值"></a>使用..=来匹配某个范围的值</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>= <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">match</span> x&#123;</span><br><span class="line">        <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one through five&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>..=<span class="string">&#x27;j&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;early ASCII letter&quot;</span>),</span><br><span class="line">        <span class="string">&#x27;k&#x27;</span>..=<span class="string">&#x27;z&#x27;</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;late ASCII letter&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数字或字符都可以</p>
<h2 id="解构以分解值"><a href="#解构以分解值" class="headerlink" title="解构以分解值"></a>解构以分解值</h2><ul>
<li>可以使用模式来结构 struct,enum,tuple，从而引用这些类型值的不同部分</li>
</ul>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (x, y);</span><br><span class="line">    (x,..) = (<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    [.., y] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>([x,y],[<span class="number">3</span>,<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构元组"><a href="#解构元组" class="headerlink" title="解构元组"></a>解构元组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> x, y) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    x += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point&#123;x:<span class="number">0</span>,y:<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123;x:a,y:b&#125;=p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>,a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>,b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简写形式</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span>&#123;x,y&#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>,x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>,y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123;x,y:<span class="number">0</span>&#125;=&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>,x),<span class="comment">//要求y必须为0</span></span><br><span class="line">        Point &#123;x:<span class="number">0</span>,y&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>,y),<span class="comment">//要求x必须为0</span></span><br><span class="line">        Point &#123;x,y&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis:(&#123;&#125;,&#123;&#125;)&quot;</span>,x,y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h3><p>注意：下面的代码会触发copy或move</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:<span class="type">i32</span>,y:<span class="type">i32</span>&#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>,x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text)=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Text message:&#123;&#125;&quot;</span>,text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b)=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rgb is (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;</span>,r,g,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行下面的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello World\n&quot;</span>));</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Text message:&#123;&#125;&quot;</span>, text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rgb is (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;</span>, r, g, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>报错：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of partially moved value: `msg`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">24</span>:<span class="number">22</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">17</span> |         Message::<span class="title function_ invoke__">Write</span>(text) =&gt; &#123;</span><br><span class="line">   |                        ---- value partially moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">24</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, msg);</span><br><span class="line">   |                      ^^^ value borrowed here after partial <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">   = note: partial <span class="keyword">move</span> occurs because value has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` which comes from the expansion of the <span class="keyword">macro</span> `println` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line">help: borrow this binding <span class="keyword">in</span> the pattern to avoid moving the value</span><br><span class="line">   |</span><br><span class="line"><span class="number">17</span> |         Message::<span class="title function_ invoke__">Write</span>(<span class="keyword">ref</span> text) =&gt; &#123;</span><br><span class="line">   |                        +++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">error: could not compile `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) due to <span class="number">1</span> previous error</span><br></pre></td></tr></table></figure>
<p>可以匹配引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">match</span> &amp;msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Text message:&#123;&#125;&quot;</span>, text);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;rgb is (&#123;&#125;,&#123;&#125;,&#123;&#125;)&quot;</span>, r, g, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">Rgb</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hsv</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move&#123;x:<span class="type">i32</span>,y:<span class="type">i32</span>&#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b))=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;,green &#123;&#125;,and blue &#123;&#125;&quot;</span>,r,g,b);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v))=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to hue &#123;&#125;,saturation &#123;&#125;,and value &#123;&#125;&quot;</span>,h,s,v);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> ((feet,inches),Point&#123;x,y&#125;) = ((<span class="number">3</span>,<span class="number">10</span>),Point&#123;x:<span class="number">3</span>,y:-<span class="number">10</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在模式中忽略值"><a href="#在模式中忽略值" class="headerlink" title="在模式中忽略值"></a>在模式中忽略值</h2><ul>
<li>有几种方式可以在模式中忽略整个值或部分值:</li>
</ul>
<h3 id="忽略整个值"><a href="#忽略整个值" class="headerlink" title="_ 忽略整个值"></a><strong>_ 忽略整个值</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(_:<span class="type">i32</span>,y:<span class="type">i32</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y is &#123;&#125;&quot;</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用嵌套-忽略值的一部分"><a href="#使用嵌套-忽略值的一部分" class="headerlink" title="使用嵌套_忽略值的一部分"></a><strong>使用嵌套_忽略值的一部分</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">match</span> (setting_value,new_setting_value) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Some</span>(_),<span class="title function_ invoke__">Some</span>(_))=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Can&#x27;t overwrite an existing customized value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt;&#123;</span><br><span class="line">            setting_value = new_setting_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;setting is &#123;:?&#125;&quot;</span>,setting_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first,_,third,_,fifth)=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers:&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,first,third,fifth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用以-开头命名来忽略未使用的变量"><a href="#使用以-开头命名来忽略未使用的变量" class="headerlink" title="使用以_开头命名来忽略未使用的变量"></a><strong>使用以_开头命名来忽略未使用的变量</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_s) = s &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模式匹配中_s 是一个新的变量，模式匹配把 s 所有权移动到_s,后面再访问 s 就会报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of partially moved value: `s`</span><br><span class="line"> --&gt; src/main.rs:6:22</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="keyword">if</span> <span class="built_in">let</span> Some(_s) = s &#123;</span><br><span class="line">  |                 -- value partially moved here</span><br><span class="line">...</span><br><span class="line">6 |     println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">  |                      ^ value borrowed here after partial move</span><br><span class="line">  |</span><br><span class="line">  = note: partial move occurs because value has <span class="built_in">type</span> `String`, <span class="built_in">which</span> does not implement the `Copy` trait</span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the macro `<span class="variable">$crate</span>::format_args_nl` <span class="built_in">which</span> comes from the expansion of the macro `println` (<span class="keyword">in</span> Nightly builds, run with -Z macro-backtrace <span class="keyword">for</span> more info)</span><br><span class="line"><span class="built_in">help</span>: borrow this binding <span class="keyword">in</span> the pattern to avoid moving the value</span><br><span class="line">  |</span><br><span class="line">3 |     <span class="keyword">if</span> <span class="built_in">let</span> Some(ref _s) = s &#123;</span><br><span class="line">  |                 +++</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0382`.</span><br><span class="line">error: could not compile `rust_programming` (bin <span class="string">&quot;rust_programming&quot;</span>) due to 1 previous error</span><br></pre></td></tr></table></figure>
<p>使用_</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_) = s &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_ ，不会发生绑定，不会移动所有权</p>
<h3 id="忽略值的剩余部分"><a href="#忽略值的剩余部分" class="headerlink" title="..(忽略值的剩余部分)"></a><strong>..(忽略值的剩余部分)</strong></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">    z: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = Point&#123;x:<span class="number">0</span>,y:<span class="number">0</span>,z:<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">match</span> origin &#123;</span><br><span class="line">        Point &#123;x,..&#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>,x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first,..,last)=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Some numbers: &#123;&#125;,&#123;&#125;&quot;</span>,first,last)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要加逗号,</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">numbers</span> = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first,..,last) =&gt; &#123;</span><br><span class="line">           <span class="built_in">assert_eq!</span>(first, <span class="number">2</span>);</span><br><span class="line">           <span class="built_in">assert_eq!</span>(last, <span class="number">2048</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-match-守卫来提供额外的条件"><a href="#使用-match-守卫来提供额外的条件" class="headerlink" title="使用 match 守卫来提供额外的条件"></a>使用 match 守卫来提供额外的条件</h2><ul>
<li>match 守卫就是 match arm 模式后额外的 if 条件，想要匹配该条件也必须满足</li>
<li>match 守卫适合更复杂的场景</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five:&#123;&#125;&quot;</span>,x),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,x),</span><br><span class="line">        <span class="literal">None</span> =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(n) <span class="keyword">if</span> n==y =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched,n = &#123;:?&#125;&quot;</span>,n),<span class="comment">//这里if n==y不是一个模式，不会引用新的变量</span></span><br><span class="line">        _ =&gt;<span class="built_in">println!</span>(<span class="string">&quot;Default case,x =&#123;:?&#125;&quot;</span>,x),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end:x=&#123;:?&#125;,y=&#123;:?&#125;&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>= <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> <span class="keyword">if</span> y=&gt; <span class="built_in">println!</span>(<span class="string">&quot;yes&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;no&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a>@绑定</h2><ul>
<li>@ 符号可以让我们可以创建一个变量，该变量可以在测试某个值是否与模式匹配的同时保存该值</li>
</ul>
<p>就相当于一个等号</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span>&#123;</span><br><span class="line">    Hello &#123;id:<span class="type">i32</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123; id: id_variable @ <span class="number">3</span>..=<span class="number">7</span>, &#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range:&#123;&#125;&quot;</span>,id_variable);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125;=&gt;&#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found some other id:&#123;&#125;&quot;</span>,id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// fill in the blank to let p match the second arm</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">2</span>, y: <span class="number">20</span> &#125;; <span class="comment">// x can be [0, 5], y can be 10 20 or 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>, x),</span><br><span class="line">        <span class="comment">// second arm</span></span><br><span class="line">        Point &#123; x: <span class="number">0</span>..=<span class="number">5</span>, y: y@ (<span class="number">10</span> | <span class="number">20</span> | <span class="number">30</span>) &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用场景：</p>
<p>下面这段代码会报错</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id:  <span class="number">3</span>..=<span class="number">7</span>,</span><br><span class="line">        &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;</span>, id),<span class="comment">//Error cannot find value `id` in this scope</span></span><br><span class="line">        Message::Hello &#123; id: newid@<span class="number">10</span> | <span class="number">11</span> | <span class="number">12</span> &#125; =&gt; &#123;<span class="comment">//Error variable `newid` is not bound in all patterns pattern doesn&#x27;t bind `newid`</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;</span>, newid)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修复错误</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id: id @<span class="number">3</span>..=<span class="number">7</span>,</span><br><span class="line">        &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;</span>, id),</span><br><span class="line">        Message::Hello &#123; id: newid@(<span class="number">10</span> | <span class="number">11</span> | <span class="number">12</span>) &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;</span>, newid)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="unsafe-Rust"><a href="#unsafe-Rust" class="headerlink" title="unsafe Rust"></a>unsafe Rust</h1><ul>
<li>隐藏着第二个语言，它<strong>没有强制内存安全保证</strong>：unsafe Rust(不安全的 Rust)</li>
</ul>
<p>和普通的 Rust 一样，但提供了额外的超能力</p>
<ul>
<li>Unsafe Rust 存在的原因:</li>
</ul>
<ol>
<li>静态分析是保守的，使用 unsafe rust 就相当于告诉编译器：我知道自己在做什么，并承担相应的风险</li>
<li><strong>计算机硬件本身就是不安全的，Rust 需要能够进行底层系统编程</strong></li>
</ol>
<h2 id="unsafe-超能力"><a href="#unsafe-超能力" class="headerlink" title="unsafe 超能力"></a>unsafe 超能力</h2><ul>
<li>使用 unsafe 关键字来切换到 unsafe Rust，开启一个块，里面放着 unsafe 代码</li>
<li>unsafe Rust 里执行的四个动作（unsafe 超能力):</li>
</ul>
<ol>
<li><strong>解引用原始指针</strong></li>
<li><strong>调用 unsafe 函数或方法</strong></li>
<li><strong>访问或修改可变的静态变量</strong></li>
<li><strong>实现 unsafe trait</strong></li>
</ol>
<ul>
<li>注意：</li>
</ul>
<p>unsafe 并<strong>没有关闭借用检查或停用其它安全的安全检查</strong></p>
<p>任何内存安全相关的而错误必须留在 unsafe 块里</p>
<p>尽可能隔离 unsafe 代码，最好将其封装在安全的抽象里，提供安全的 API</p>
<h3 id="解引用原始指针"><a href="#解引用原始指针" class="headerlink" title="解引用原始指针"></a>解引用原始指针</h3><ul>
<li>原始指针</li>
</ul>
<p><strong>可变的： *mut T</strong></p>
<p><strong>不可变的： *const T</strong>，意味着<strong>指针在解引用后不能直接对其进行赋值</strong></p>
<p>注意：这里的*不是解引用符号，它是类型名的一部分</p>
<ul>
<li>与引用不同，原始指针:</li>
</ul>
<ol>
<li><strong>允许通过同时具有可变和不可变指针或指向同一位置的可变指针来忽略借用规则</strong></li>
<li><strong>无法保证能指向合理的内存</strong></li>
<li><strong>允许为 null</strong></li>
<li><strong>不实现任何自动清理</strong></li>
</ol>
<ul>
<li>放弃保证的安全，换取更好的性能/与其它语言或硬件接口的能力</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span>=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = <span class="number">0x012345usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在安全代码块里创建原始指针，但不能够解引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span>=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r1:&#123;&#125;&quot;</span>,*r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r2:&#123;&#125;&quot;</span>,*r2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">address</span> = <span class="number">0x012345usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r:&#123;&#125;&quot;</span>,*r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要使用原始指针？</p>
<ul>
<li>与 C 语言进行接口</li>
<li>构建借用检查器无法理解的安全抽象</li>
</ul>
<h3 id="调用-unsafe-函数或方法"><a href="#调用-unsafe-函数或方法" class="headerlink" title="调用 unsafe 函数或方法"></a>调用 unsafe 函数或方法</h3><ul>
<li>unsafe 函数或方法：在定义前加上了 unsafe 关键字<ul>
<li>调用前需手动满足一些条件（主要靠看文档），因为 Rust 无法对这些条件进行验证</li>
<li>需要在 unsafe 块里进行调用</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">dangerous</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建-unsafe-代码的安全抽象"><a href="#创建-unsafe-代码的安全抽象" class="headerlink" title="创建 unsafe 代码的安全抽象"></a>创建 unsafe 代码的安全抽象</h3><ul>
<li>函数包含 unsafe 代码并不意味着需要将整个函数标记为 unsafe</li>
<li>将 unsafe 代码包裹在安全函数中是一个常见的抽象</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice:&amp;<span class="keyword">mut</span>[<span class="type">i32</span>],mid:<span class="type">usize</span>)<span class="punctuation">-&gt;</span>(&amp;<span class="keyword">mut</span> [<span class="type">i32</span>],&amp;<span class="keyword">mut</span>[<span class="type">i32</span>])&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(mid&lt;=len);</span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid],&amp;<span class="keyword">mut</span> slice[mid..])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>= <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a,b) = r.<span class="title function_ invoke__">split_at_mut</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a,&amp;<span class="keyword">mut</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b,&amp;<span class="keyword">mut</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[E0499]: cannot borrow `*slice` as mutable more than once at a <span class="keyword">time</span></span><br><span class="line"> --&gt; src\main.rs:6:29</span><br><span class="line">  |</span><br><span class="line">3 | fn split_at_mut(slice:&amp;mut[i32],mid:usize)-&gt;(&amp;mut [i32],&amp;mut[i32])&#123;</span><br><span class="line">  |                       - <span class="built_in">let</span><span class="string">&#x27;s call the lifetime of this reference `&#x27;</span>1`</span><br><span class="line">...</span><br><span class="line">6 |     (&amp;mut slice[..mid],&amp;mut slice[mid..])</span><br><span class="line">  |     ------------------------^^^^^--------</span><br><span class="line">  |     |     |                 |</span><br><span class="line">  |     |     |                 second mutable borrow occurs here</span><br><span class="line">  |     |     first mutable borrow occurs here</span><br><span class="line">  |     returning this value requires that `*slice` is borrowed <span class="keyword">for</span> `<span class="string">&#x27;1`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">For more information about this error, try `rustc --explain E0499`.</span></span><br></pre></td></tr></table></figure>
<p>使用 unfase 代码</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">split_at_mut</span>(slice: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>],mid: <span class="type">usize</span>)<span class="punctuation">-&gt;</span>(&amp;<span class="keyword">mut</span> [<span class="type">i32</span>],&amp;<span class="keyword">mut</span> [<span class="type">i32</span>])&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = slice.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ptr</span> = slice.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(mid&lt;=len);</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        (</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr, mid),</span><br><span class="line">            slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(ptr.<span class="title function_ invoke__">add</span>(mid), len-mid)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>= <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span> = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a,b) = r.<span class="title function_ invoke__">split_at_mut</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a,&amp;<span class="keyword">mut</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b,&amp;<span class="keyword">mut</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" class="headerlink" title="使用 extern 函数调用外部代码"></a>使用 extern 函数调用外部代码</h3><ul>
<li>extern 关键字：简化创建和使用外部函数接口（FFI）的过程</li>
<li>外部函数接口(FFI，Foreign Function Interface) : 它允许一种编程语言定义函数，并让其它编程语言能调用这些函数</li>
<li>extern 块中声明的函数在 Rust 代码中总是不安全的。因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;<span class="comment">//&quot;C&quot;指明外部函数应用的二进制接口abi(application binary interface)</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">abs</span>(input: <span class="type">i32</span>) <span class="punctuation">-&gt;</span><span class="type">i32</span>;<span class="comment">//想要调用的外部函数的签名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Absolute value of -3 according to C:&#123;&#125;&quot;</span>,<span class="title function_ invoke__">abs</span>(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>应用二进制接口(ABI，Application Binary Interface):定义函数在汇编层的调用方式</strong></li>
<li>“C” ABI 是最常见的 ABI,它遵循 C 语言的 ABI</li>
</ul>
<h2 id="从其它语言调用-Rust-函数"><a href="#从其它语言调用-Rust-函数" class="headerlink" title="从其它语言调用 Rust 函数"></a>从其它语言调用 Rust 函数</h2><ul>
<li>可以使用 extern 创建接口，其它语言通过它们可以调用 Rust 函数</li>
<li>在 <strong>fn 前添加 extern 关键字，并指定 ABI</strong></li>
<li>还需<strong>添加#[no_mangle]注解：避免 Rust 在编译时改变它的名称</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">call_from_c</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Just called a Rust function from C!&quot;</span>);<span class="comment">//编译链接后就可被c语言访问了，extern 的使用无需 unsafe。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问或修改一个可变的静态变量"><a href="#访问或修改一个可变的静态变量" class="headerlink" title="访问或修改一个可变的静态变量"></a>访问或修改一个可变的静态变量</h2><ul>
<li>Rust 支持全局变量，但因为所有权机制可能产生某些问题，例如数据竞争</li>
<li>在 Rust 里，全局变量叫做静态(static)变量</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;name is: &#123;&#125;&quot;</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态（static）变量类似常量。</li>
<li>通常静态变量的名称采用 SCREAMING_SNAKE_CASE 写法。</li>
<li>静态变量只能储存拥有 ‘static 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。</li>
<li>访问<strong>不可变静态变量</strong>是安全的。</li>
</ul>
<p>静态变量和常量的区别：</p>
<ul>
<li>静态变量中的值<strong>有一个固定的内存地址</strong>。使用这个值总是会访问相同的地址。常量则允许在任何被用到的时候<strong>复制其数据</strong>。</li>
<li>静态变量可以是可变的。<strong>访问和修改可变静态变量都是 不安全 的。</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="type">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_to_count</span>(inc: <span class="type">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_count</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;COUNTER: &#123;&#125;&quot;</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何读写 COUNTER 的代码都必须位于 unsafe 块中。这段代码可以编译并如期打印出 COUNTER: 3，因为这是单线程的。<strong>拥有多个线程访问 COUNTER 则可能导致数据竞争</strong>。</p>
<p>拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。任何可能的情况，优先使用智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的。</p>
<h2 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h2><ul>
<li>当 trait 中至少有一个方法中包含编译器无法验证的不变式（invariant）时 trait 是不安全的。</li>
<li>可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">trait</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="comment">// methods go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Foo</span> <span class="keyword">for</span> <span class="title class_">i32</span> &#123;</span><br><span class="line">    <span class="comment">// method implementations go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Sync 和 Send 标记 trait，编译器会自动为完全由 Send 和 Sync 类型组成的类型自动实现他们。如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync，则必须使用 unsafe。Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程间访问，所以需要我们自己进行检查并通过 unsafe 表明。</p>
<h2 id="访问联合体中的字段"><a href="#访问联合体中的字段" class="headerlink" title="访问联合体中的字段"></a>访问联合体中的字段</h2><p>仅适用于 unsafe 的最后一个操作是访问 <strong>联合体</strong> 中的字段，union 和 struct 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互。访问联合体的字段是不安全的，因为 <strong>Rust 无法保证当前存储在联合体实例中数据的类型</strong>。可以查看 (<a target="_blank" rel="noopener external nofollow noreferrer" href="https://doc.rust-lang.org/reference/items/unions.html">https://doc.rust-lang.org/reference/items/unions.html</a>) 了解有关联合体的更多信息。</p>
<h2 id="何时使用不安全的代码"><a href="#何时使用不安全的代码" class="headerlink" title="何时使用不安全的代码"></a>何时使用不安全的代码</h2><p>使用 unsafe 来进行这五个操作（超能力）之一是没有问题的，甚至是不需要深思熟虑的，不过使得 unsafe 代码正确也实属不易，因为编译器不能帮助保证内存安全。当有理由使用 unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注可以更容易地在错误发生时追踪问题的源头。</p>
<h1 id="高级-trait"><a href="#高级-trait" class="headerlink" title="高级 trait"></a>高级 trait</h1><h2 id="在-trait-定义中使用关联类型来指定占位类型"><a href="#在-trait-定义中使用关联类型来指定占位类型" class="headerlink" title="在 trait 定义中使用关联类型来指定占位类型"></a>在 trait 定义中使用关联类型来指定占位类型</h2><ul>
<li>关联类型(associate type)是 trait 中的类型占位符，它可以用于 trait 的方法签名中：</li>
</ul>
<p>可以定义出包含某些类型的 trait，而在实现前无需知道这些类型是什么</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关联类型与泛型的区别"><a href="#关联类型与泛型的区别" class="headerlink" title="关联类型与泛型的区别"></a>关联类型与泛型的区别</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>泛型</strong></th>
<th><strong>关联类型</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>每次实现 Trait 时标注类型</td>
<td>无需标注类型</td>
</tr>
<tr>
<td>可以为一个类型多次实现某个 Trait(不同的泛型参数)</td>
<td>无法为单个类型多次实现某个 Trait</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator2</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Counter</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator</span> <span class="keyword">for</span> <span class="title class_">Counter</span>&#123;<span class="comment">//只能实现一次</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>=<span class="type">u32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// impl Iterator for Counter&#123;//只能实现一次,第二次为String实现报错</span></span><br><span class="line"><span class="comment">//     type Item=String;</span></span><br><span class="line"><span class="comment">//     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span></span><br><span class="line"><span class="comment">//         None</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator2</span>&lt;<span class="type">String</span>&gt; <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Iterator2</span>&lt;<span class="type">u32</span>&gt; <span class="keyword">for</span> <span class="title class_">Counter</span> &#123;<span class="comment">//可以为不同的类型实现多次</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u32</span>&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关联类型主要用于提升代码的可读性</strong>，例如以下代码 :</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">CacheableItem</span>: <span class="built_in">Clone</span> + <span class="built_in">Default</span> + fmt::<span class="built_in">Debug</span> + Decodable + Encodable &#123;</span><br><span class="line">  <span class="keyword">type</span> <span class="title class_">Address</span>: <span class="built_in">AsRef</span>&lt;[<span class="type">u8</span>]&gt; + <span class="built_in">Clone</span> + fmt::<span class="built_in">Debug</span> + <span class="built_in">Eq</span> + Hash;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">is_null</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比 AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash， Address 的使用可以极大的减少其它类型在实现该特征时所需的模版代码.</p>
<p>例子：使用关联类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用关联类型实现重新实现以下特征</span></span><br><span class="line"><span class="comment">// trait Contains &#123;</span></span><br><span class="line"><span class="comment">//    type A;</span></span><br><span class="line"><span class="comment">//    type B;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Contains</span>&lt;A, B&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, _: &amp;A, _: &amp;B) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">last</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Contains</span>&lt;<span class="type">i32</span>, <span class="type">i32</span>&gt; <span class="keyword">for</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, number_1: &amp;<span class="type">i32</span>, number_2: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        (&amp;<span class="keyword">self</span>.<span class="number">0</span> == number_1) &amp;&amp; (&amp;<span class="keyword">self</span>.<span class="number">1</span> == number_2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Grab the first number.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="keyword">self</span>.<span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab the last number.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">last</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="keyword">self</span>.<span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">difference</span>&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    container.<span class="title function_ invoke__">last</span>() - container.<span class="title function_ invoke__">first</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_1</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_2</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = <span class="title function_ invoke__">Container</span>(number_1, number_2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">        &amp;number_1, &amp;number_2,</span><br><span class="line">        container.<span class="title function_ invoke__">contains</span>(&amp;number_1, &amp;number_2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;First number: &#123;&#125;&quot;</span>, container.<span class="title function_ invoke__">first</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Last number: &#123;&#125;&quot;</span>, container.<span class="title function_ invoke__">last</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The difference is: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">difference</span>(&amp;container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span>(<span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A trait which checks if 2 items are stored inside of container.</span></span><br><span class="line"><span class="comment">// Also retrieves first or last value.</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Contains</span> &#123;</span><br><span class="line">    <span class="comment">// Define generic types here which methods will be able to utilize.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">A</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, _: &amp;<span class="keyword">Self</span>::A, _: &amp;<span class="keyword">Self</span>::B) <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">last</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Contains</span> <span class="keyword">for</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="comment">// Specify what types `A` and `B` are. If the `input` type</span></span><br><span class="line">    <span class="comment">// is `Container(i32, i32)`, the `output` types are determined</span></span><br><span class="line">    <span class="comment">// as `i32` and `i32`.</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">A</span> = <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">B</span> = <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `&amp;Self::A` and `&amp;Self::B` are also valid here.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">contains</span>(&amp;<span class="keyword">self</span>, number_1: &amp;<span class="type">i32</span>, number_2: &amp;<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        (&amp;<span class="keyword">self</span>.<span class="number">0</span> == number_1) &amp;&amp; (&amp;<span class="keyword">self</span>.<span class="number">1</span> == number_2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Grab the first number.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="keyword">self</span>.<span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab the last number.</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">last</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123; <span class="keyword">self</span>.<span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">difference</span>&lt;C: Contains&gt;(container: &amp;C) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    container.<span class="title function_ invoke__">last</span>() - container.<span class="title function_ invoke__">first</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_1</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number_2</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">container</span> = <span class="title function_ invoke__">Container</span>(number_1, number_2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">        &amp;number_1, &amp;number_2,</span><br><span class="line">        container.<span class="title function_ invoke__">contains</span>(&amp;number_1, &amp;number_2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;First number: &#123;&#125;&quot;</span>, container.<span class="title function_ invoke__">first</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Last number: &#123;&#125;&quot;</span>, container.<span class="title function_ invoke__">last</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The difference is: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">difference</span>(&amp;container));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认泛型参数和运算符重载"><a href="#默认泛型参数和运算符重载" class="headerlink" title="默认泛型参数和运算符重载"></a>默认泛型参数和运算符重载</h2><ul>
<li>可以在使用泛型参数时为泛型指定一个默认的具体类型</li>
<li>语法：<PlaceholderType=ConcreteType></li>
<li>这种结束常用于运算符重载（operator overloading）</li>
<li><strong>Rust 不允许创建自己的运算符及重载任意的运算符</strong></li>
<li>但<strong>可以通过实现 std::ops 中列出的那些 trait 来重载一部分相应的运算符</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, other: Point) <span class="punctuation">-&gt;</span> Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(</span><br><span class="line">        Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">3</span> &#125;,</span><br><span class="line">        Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的是 add 的默认泛型参数 self</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Millimeters</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Meter</span>(<span class="type">u32</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Add</span>&lt;Meter&gt; <span class="keyword">for</span> <span class="title class_">Millimeters</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Millimeters;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: Meter) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output &#123;</span><br><span class="line">        <span class="title function_ invoke__">Millimeters</span>(<span class="keyword">self</span>.<span class="number">0</span>+(other.<span class="number">0</span>*<span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里指定泛型参数</p>
<p><strong>默认泛型参数的主要应用场景</strong></p>
<ul>
<li>扩展一个类型而不破坏现有的代码</li>
<li>允许在大部分用户都不需要的特定场景下进行自定义</li>
</ul>
<h2 id="完全限定语法-Fully-Qualified-Syntax"><a href="#完全限定语法-Fully-Qualified-Syntax" class="headerlink" title="完全限定语法(Fully Qualified Syntax)"></a>完全限定语法(Fully Qualified Syntax)</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is your captain speaking&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();<span class="comment">//调用本身的方法</span></span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person);<span class="comment">//调用Pilot trait中的方法</span></span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person);<span class="comment">//调用Wizard trait中的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无参的形式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a&#123;&#125;&quot;</span>,Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a&#123;&#125;&quot;</span>,Animal::<span class="title function_ invoke__">baby_name</span>());<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 baby_name 没有参数，编译器不知道是哪个 Dog 调用</p>
<ul>
<li>完全限定语法：<Type as Trait>::function(receiver_if_method,netx_arg,..) ;</li>
<li>可以在任何调用函数或方法的地方使用</li>
<li>允许忽略那些从其他上下文能推导出来的部分</li>
<li>当 Rust 无法区分你期望调用哪个具体实现的时候，才需要使用这种语法</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span>&#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Spot&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Animal</span> <span class="keyword">for</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">baby_name</span>()<span class="punctuation">-&gt;</span><span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a&#123;&#125;&quot;</span>,Dog::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;A baby dog is called a&#123;&#125;&quot;</span>,&lt;Dog <span class="keyword">as</span> Animal&gt;::<span class="title function_ invoke__">baby_name</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-supertrait-来要求-trait-附带其它-trait-的功能"><a href="#使用-supertrait-来要求-trait-附带其它-trait-的功能" class="headerlink" title="使用 supertrait 来要求 trait 附带其它 trait 的功能"></a>使用 supertrait 来要求 trait 附带其它 trait 的功能</h2><ul>
<li>需要在一个 trait 中使用其它 trait 的功能<ul>
<li>需要被依赖的 trait 也被实现</li>
<li>那个被间接以来的 trait 就是当前 trait 的 supertrait</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="keyword">self</span>, write&#125;;</span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: fmt::Display&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len+<span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>,<span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len+<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>,output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>,<span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len+<span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len+<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    x:<span class="type">i32</span>,</span><br><span class="line">    y:<span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">OutlinePrint</span> <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;(&#123;&#125;,&#123;&#125;)&quot;</span>,<span class="keyword">self</span>.x,<span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-newtype-模式在外部类型上实现外部-trait"><a href="#使用-newtype-模式在外部类型上实现外部-trait" class="headerlink" title="使用 newtype 模式在外部类型上实现外部 trait"></a>使用 newtype 模式在外部类型上实现外部 trait</h2><ul>
<li>孤儿类型：只有当 trait 或类型定义在本地包时，才能为该类型实现这个 trait</li>
<li>可以通过 newtype 模式来绕过这一规则<ul>
<li>利用 tuple struct（元组结构体）创建一个新的类型</li>
</ul>
</li>
</ul>
<p>（例子）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f,<span class="string">&quot;[&#123;&#125;]&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>),<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w=&#123;&#125;&quot;</span>,w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h2 id="使用-newtype-模式实现类型安全和抽象"><a href="#使用-newtype-模式实现类型安全和抽象" class="headerlink" title="使用 newtype 模式实现类型安全和抽象"></a>使用 newtype 模式实现类型安全和抽象</h2><ul>
<li>newtype 模式可以：<ul>
<li>用来静态的保证各种值之间不会混淆并表明值的单位</li>
<li>为类型的某些细节提供抽象能力</li>
<li>通过轻量级的封装来隐藏内部实现细节</li>
</ul>
</li>
</ul>
<h2 id="使用类型别名创建类型同义词"><a href="#使用类型别名创建类型同义词" class="headerlink" title="使用类型别名创建类型同义词"></a>使用类型别名创建类型同义词</h2><ul>
<li>Rust 提供了类型别名的功能：——为现有的类型生产另外的名称（同义词）——并不是一个独立的类型——使用 type 关键字</li>
<li>主要用途：减少代码的字符重复</li>
<li>类似于C的typedef</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt;)&#123;</span><br><span class="line">    <span class="comment">//snip</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>()<span class="punctuation">-&gt;</span><span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt;&#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>:<span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类型别名</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Thunk</span> = <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>()+<span class="built_in">Send</span>+<span class="symbol">&#x27;static</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_long_type</span>(f: Thunk)&#123;</span><br><span class="line">    <span class="comment">//snip</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_long_type</span>()<span class="punctuation">-&gt;</span>Thunk&#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>:Thunk = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|| <span class="built_in">println!</span>(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,buf: &amp;[<span class="type">u8</span>])<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;<span class="type">usize</span>,Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(),Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,buf: &amp;[<span class="type">u8</span>])<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(),Error&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_fmt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,fmt: fmt::Arguments)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;(),Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类型别名</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="comment">// type Result&lt;T&gt; = Result&lt;T,std::io::Error&gt;;标准库中定义了这个</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span>&lt;T&gt; = std::io::<span class="type">Result</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Write</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,buf: &amp;[<span class="type">u8</span>])<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;<span class="type">usize</span>&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_all</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,buf: &amp;[<span class="type">u8</span>])<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_fmt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>,fmt: fmt::Arguments)<span class="punctuation">-&gt;</span><span class="type">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h2><ul>
<li>有一个名为！的特殊类型：<ul>
<li>它没有任何值，行话称为空类型（empty type）</li>
<li>我们倾向于叫它 never 类型，因为它在不返回的函数中充当返回类型</li>
</ul>
</li>
</ul>
<ul>
<li>不返回值的函数也被称作发散函数（diverging fuction)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bar</span>() <span class="punctuation">-&gt;</span> !&#123;</span><br><span class="line">    <span class="comment">//return (),返回了单元类型,但是不可能创建出返回!类型的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guess</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">loop</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>:<span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match 表达式要求各个分支返回的类型是相同的，而 continue 会返回 never 类型，该类型可以安全地强制转换为 num 所对应的类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="type">Option</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unwrap</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> T&#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>&#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="literal">None</span>=&gt;<span class="built_in">panic!</span>(<span class="string">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>panic！返回 never 类型</p>
<h2 id="动态大小和-Sized-Trait"><a href="#动态大小和-Sized-Trait" class="headerlink" title="动态大小和 Sized Trait"></a>动态大小和 Sized Trait</h2><ul>
<li>Rust 需要在编译时确定为一个特定类型的值分配多少空间</li>
<li>动态大小的类型（Dynamically Sized Types,DST）的概念:<ul>
<li>编写代码时使用只有在运行时才能确定大小的值</li>
</ul>
</li>
</ul>
<ul>
<li><strong>str 是动态大小的类型</strong>（注意不是&amp;str）:只有运行时才能确定字符串的长度<br>以下代码无法正常工作:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span>:<span class="type">str</span> = <span class="string">&quot;Hello therel&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span>:<span class="type">str</span> = <span class="string">&quot;How is it going&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>因为他们都是同一个类型，需要的空间应该一样，但是这里声明时没有确定共同的空间</p>
<p>解决办法: 使用&amp;str 字符串切片类型</p>
<h2 id="Rust-使用动态大小类型的通用方式"><a href="#Rust-使用动态大小类型的通用方式" class="headerlink" title="Rust 使用动态大小类型的通用方式"></a>Rust 使用动态大小类型的通用方式</h2><ul>
<li><strong>附带一些额外的元数据来存储动态信息的大小</strong><ul>
<li>使用动态大小类型时总会把它的值放在某种指针后面</li>
</ul>
</li>
</ul>
<h2 id="另外一种动态大小的类型：trait"><a href="#另外一种动态大小的类型：trait" class="headerlink" title="另外一种动态大小的类型：trait"></a>另外一种动态大小的类型：trait</h2><ul>
<li>每个 <strong>trait 都是一个动态大小的类型</strong>，可以通过名称对其进行引用</li>
<li>为了将 trait 用作 trait 对象，必须将它放置在某种指针之后<ul>
<li>例如 &amp;dyn Trait 或 Box<dyn Trait> (Rc<dyn Trait>) 之后</li>
</ul>
</li>
</ul>
<h2 id="Sized-trait"><a href="#Sized-trait" class="headerlink" title="Sized trait"></a>Sized trait</h2><ul>
<li>为了处理动态大小的类型，Rust 提供了一个 Sized trait 来确定一个类型的大小在编译时是否已知——<strong>编译时可计算出大小的类型会自动实现这一 trait</strong></li>
<li><strong>Rust 还会为每一个泛型函数隐式的添加 Sized 约束</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T&gt;(t:T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: <span class="built_in">Sized</span>&gt;(t:T)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，泛型函数只能被用于编译时已经知道大小的类型，可以通过特殊语法来解除这一限制</li>
</ul>
<h2 id="Sized-trait-约束"><a href="#Sized-trait-约束" class="headerlink" title="?Sized trait 约束"></a>?Sized trait 约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn generic&lt;T: ?Sized&gt;(t:&amp;T)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>T 可能是也可能不是 Sized</li>
<li>这个语法只能用在 Sized 上面，不能被用于其它 trait</li>
</ul>
<h1 id="高级函数和闭包"><a href="#高级函数和闭包" class="headerlink" title="高级函数和闭包"></a>高级函数和闭包</h1><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li>可以将函数传递给其它函数</li>
<li>函数在传递过程中会被强制转换为 fn 类型</li>
<li>fn 类型就是 <strong>函数指针(function pointer)</strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_one</span>(x:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">    x+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">do_twice</span>(f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>,arg:<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(arg) + <span class="title function_ invoke__">f</span>(arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">answer</span> = <span class="title function_ invoke__">do_twice</span>(add_one, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The answer is:&#123;&#125;&quot;</span>,answer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数指针与闭包的不同"><a href="#函数指针与闭包的不同" class="headerlink" title="函数指针与闭包的不同"></a>函数指针与闭包的不同</h2><ul>
<li><p><strong>fn 是一个类型而不是一个 trait</strong></p>
<ul>
<li>可以直接指定 fn 为参数类型，不用声明一个以 Fn trait 为约束的泛型参数</li>
</ul>
</li>
<li><p>函数指针实现了全部 3 种闭包 trait（Fn,FnMut,FnOnce）:</p>
<ul>
<li>总是可以把函数指针用作参数传递给一个接受闭包的参数</li>
<li>所以，倾向于搭配闭包 trait 的泛型来编写函数：可以同时接收闭包和普通函数</li>
</ul>
</li>
</ul>
<ul>
<li>某些情景，只想接收 fn 而不接收闭包<ul>
<li>与外部不支持闭包的代码交互：C 函数</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_strings</span>:<span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|i| i.<span class="title function_ invoke__">to_string</span>())</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_numbers</span> = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = list_of_numbers</span><br><span class="line">    .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(<span class="built_in">ToString</span>::to_string)</span><br><span class="line">    .<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Status</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">Value</span>(<span class="type">u32</span>),</span><br><span class="line">        Stop,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = Status::<span class="title function_ invoke__">Value</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">list_of_statuses</span>:<span class="type">Vec</span>&lt;Status&gt; = (<span class="number">0u32</span>..<span class="number">20</span>).<span class="title function_ invoke__">map</span>(Status::Value).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回闭包"><a href="#返回闭包" class="headerlink" title="返回闭包"></a>返回闭包</h2><ul>
<li>闭包使用 trait 进行表达，无法在函数中直接返回一个闭包，可以将一个实现了该 trait 的具体类型作为返回值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn returns_closure()-&gt;Fn(i32)-&gt;i32&#123;//返回类型大小不固定</span></span><br><span class="line"><span class="comment">//     |x| x+1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_closure</span>() <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>)<span class="punctuation">-&gt;</span><span class="type">i32</span>&gt;&#123;</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(|x| x+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>参考：</p>
<p>官方文档：</p>
<div class="tag link"><a class="link-card" title="宏" target="_blank" rel="noopener external nofollow noreferrer" href="https://kaisery.github.io/trpl-zh-cn/ch20-05-macros.html"><div class="left"><img src="https://kaisery.github.io/trpl-zh-cn/favicon.svg"/></div><div class="right"><p class="text">宏</p><p class="url">https://kaisery.github.io/trpl-zh-cn/ch20-05-macros.html</p></div></a></div>
<p>Rust语言圣经</p>
<div class="tag link"><a class="link-card" title="宏" target="_blank" rel="noopener external nofollow noreferrer" href="https://course.rs/advance/macro.html"><div class="left"><img src="https://course.rs/favicon.svg"/></div><div class="right"><p class="text">宏</p><p class="url">https://course.rs/advance/macro.html</p></div></a></div>
<p>Rust宏小册子</p>
<div class="tag link"><a class="link-card" title="The Little Book of Rust Macros" target="_blank" rel="noopener external nofollow noreferrer" href="https://zjp-cn.github.io/tlborm/"><div class="left"><img src="https://zjp-cn.github.io/tlborm/favicon.svg"/></div><div class="right"><p class="text">The Little Book of Rust Macros</p><p class="url">https://zjp-cn.github.io/tlborm/</p></div></a></div>
<h1 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h1><p>参考：</p>
<p>Rust异步编程</p>
<div class="tag link"><a class="link-card" title="Asynchronous Programming in Rust" target="_blank" rel="noopener external nofollow noreferrer" href="https://rust-lang.github.io/async-book/intro.html"><div class="left"><img src="https://rust-lang.github.io/async-book/favicon.png"/></div><div class="right"><p class="text">Asynchronous Programming in Rust</p><p class="url">https://rust-lang.github.io/async-book/intro.html</p></div></a></div>
<p>Rust语言圣经</p>
<div class="tag link"><a class="link-card" title="async/await 异步编程" target="_blank" rel="noopener external nofollow noreferrer" href="https://course.rs/advance/async/intro.html"><div class="left"><img src="https://course.rs/favicon.svg"/></div><div class="right"><p class="text">async/await 异步编程</p><p class="url">https://course.rs/advance/async/intro.html</p></div></a></div>
<h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>);<span class="comment">// =&gt; Alice, this is Bob. Bob, this is Alice</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;1&#125;&#123;0&#125;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>), <span class="string">&quot;21&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;1&#125;&#123;&#125;&#123;0&#125;&#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>), <span class="string">&quot;2112&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;argument&#125;&quot;</span>, argument = <span class="string">&quot;test&quot;</span>); <span class="comment">// =&gt; &quot;test&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;name&#125;&#123;&#125;&quot;</span>, <span class="number">1</span>, name = <span class="number">2</span>), <span class="string">&quot;21&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;</span>,a = <span class="string">&quot;a&quot;</span>, b = <span class="string">&#x27;b&#x27;</span>, c = <span class="number">3</span> ), <span class="string">&quot;a 3 b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// named argument must be placed after other arguments</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;abc&#125; &#123;0&#125;&quot;</span>, <span class="number">2</span>, abc = <span class="string">&quot;def&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串对齐"><a href="#字符串对齐" class="headerlink" title="字符串对齐"></a>字符串对齐</h2><p>默认情况下，通过空格来填充字符串</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// the following two are padding with 5 spaces</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>); <span class="comment">// =&gt;  &quot;Hello x    !&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:1$&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">5</span>); <span class="comment">// =&gt;  &quot;Hello x    !&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;1:0$&#125;!&quot;</span>, <span class="number">5</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello x    !&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;:width$&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>, width = <span class="number">5</span>), <span class="string">&quot;Hello x    !&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左对齐, 右对齐, 使用指定的字符填充</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// left align</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:&lt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>); <span class="comment">// =&gt; Hello x    !</span></span><br><span class="line">    <span class="comment">// right align</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;:&gt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello     x!&quot;</span>);</span><br><span class="line">    <span class="comment">// center align</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;:^5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello   x  !&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left align, pad with &#x27;&amp;&#x27;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>), <span class="string">&quot;Hello x&amp;&amp;&amp;&amp;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还能使用 0 来填充数字</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:5&#125;!&quot;</span>, <span class="number">5</span>); <span class="comment">// =&gt; Hello     5!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:+&#125;!&quot;</span>, <span class="number">5</span>); <span class="comment">// =&gt;  Hello +5!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:05&#125;!&quot;</span>, <span class="number">5</span>); <span class="comment">// =&gt; Hello 00005!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:05&#125;!&quot;</span>, -<span class="number">5</span>); <span class="comment">// =&gt; Hello -0005!</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;number:0&gt;width$&#125;&quot;</span>, number=<span class="number">1</span>, width=<span class="number">6</span>) == <span class="string">&quot;000001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h2><p>浮点数精度</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:.1$&#125;&quot;</span>, v, <span class="number">4</span>); <span class="comment">// same as &#123;:.4&#125; =&gt; 3.1416</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, v), <span class="string">&quot;3.14&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:+.2&#125;&quot;</span>, v), <span class="string">&quot;+3.14&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:.0&#125;&quot;</span>, v), <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串长度</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;0:.5&#125;&quot;</span>, s); <span class="comment">// =&gt; Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;Hello &#123;1:.0$&#125;!&quot;</span>, <span class="number">3</span>, <span class="string">&quot;abcdefg&quot;</span>), <span class="string">&quot;Hello abc!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制，八进制，十六进制"><a href="#二进制，八进制，十六进制" class="headerlink" title="二进制，八进制，十六进制"></a>二进制，八进制，十六进制</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#b&#125;&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0b11011&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#o&#125;&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0o33&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#x&#125;&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0x1b&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;:#X&#125;&quot;</span>, <span class="number">27</span>), <span class="string">&quot;0x1B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;!&quot;</span>, <span class="number">27</span>); <span class="comment">// hex with no prefix =&gt; 1b</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#010b&#125;&quot;</span>, <span class="number">27</span>); <span class="comment">// pad binary with 0, width = 10,  =&gt; 0b00011011</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;Success!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="捕获环境中的值"><a href="#捕获环境中的值" class="headerlink" title="捕获环境中的值"></a>捕获环境中的值</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_person</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_format</span>() <span class="punctuation">-&gt;</span> (<span class="type">usize</span>, <span class="type">usize</span>) &#123;</span><br><span class="line">    (<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = <span class="title function_ invoke__">get_person</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;person&#125;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (width, precision) = <span class="title function_ invoke__">get_format</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scores</span> = [(<span class="string">&quot;sunface&quot;</span>, <span class="number">99.12</span>), (<span class="string">&quot;jack&quot;</span>, <span class="number">60.34</span>)];</span><br><span class="line">    <span class="comment">/* Make it print:</span></span><br><span class="line"><span class="comment">    sunface:   99.1</span></span><br><span class="line"><span class="comment">    jack:   60.3</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (name, score) <span class="keyword">in</span> scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;name&#125;: &#123;score:width$.precision$&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指数，指针地址，转义"><a href="#指数，指针地址，转义" class="headerlink" title="指数，指针地址，转义"></a>指数，指针地址，转义</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 指数</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:2e&#125;&quot;</span>, <span class="number">1000000000</span>); <span class="comment">// =&gt; 1e9</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:2E&#125;&quot;</span>, <span class="number">1000000000</span>); <span class="comment">// =&gt; 1E9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针地址</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>= <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, v.<span class="title function_ invoke__">as_ptr</span>()); <span class="comment">// =&gt; 0x600002324050</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转义</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#123;&#125;&#125;&quot;</span>); <span class="comment">// =&gt; Hello &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><h2 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h2><h3 id="unreachable"><a href="#unreachable" class="headerlink" title="unreachable!()"></a>unreachable!()</h3><p>这是标记程序不应输入的路径的标准宏。如果程序进入这些路径，程序将 panicked 并返回”‘internal error: entered unreachable code’”错误消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">level</span> = <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stage</span> = <span class="keyword">match</span> level &#123;</span><br><span class="line">        <span class="number">1</span>...<span class="number">5</span> =&gt; <span class="string">&quot;beginner&quot;</span>,</span><br><span class="line">        <span class="number">6</span>...<span class="number">10</span> =&gt; <span class="string">&quot;intermediate&quot;</span>,</span><br><span class="line">        <span class="number">11</span>...<span class="number">20</span> =&gt; <span class="string">&quot;expert&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, stage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------- Compile time error --------------</span></span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code<span class="string">&#x27;, src/main.rs:7:20</span></span><br></pre></td></tr></table></figure>
<p>我们也可以为此设置自定义错误消息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- with a custom message ---</span></span><br><span class="line">_ =&gt; <span class="built_in">unreachable!</span>(<span class="string">&quot;Custom message&quot;</span>),</span><br><span class="line"><span class="comment">// -------------- Compile time error --------------</span></span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code: Custom message<span class="string">&#x27;, src/main.rs:7:20</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// --- with debug data ---</span></span><br><span class="line"><span class="string">_ =&gt; unreachable!(&quot;level is &#123;&#125;&quot;, level),</span></span><br><span class="line"><span class="string">// -------------- Compile time error --------------</span></span><br><span class="line"><span class="string">thread &#x27;</span>main<span class="string">&#x27; panicked at &#x27;</span>internal error: entered unreachable code: level is <span class="number">22</span><span class="string">&#x27;, src/main.rs:7:14</span></span><br></pre></td></tr></table></figure>
<h2 id="misconception-corollaries"><a href="#misconception-corollaries" class="headerlink" title="misconception corollaries"></a>misconception corollaries</h2><h3 id="if-T-39-static-then-T-must-be-valid-for-the-entire-program"><a href="#if-T-39-static-then-T-must-be-valid-for-the-entire-program" class="headerlink" title="if T: &#39;static then T must be valid for the entire program"></a>if <code>T: &#39;static</code> then <code>T</code> must be valid for the entire program</h3><p><strong>Misconception Corollaries</strong></p>
<ul>
<li><code>T: &#39;static</code> should be read as <em>“<code>T</code> has a <code>&#39;static</code> lifetime”</em></li>
<li><code>&amp;&#39;static T</code> and <code>T: &#39;static</code> are the same thing</li>
<li>if <code>T: &#39;static</code> then <code>T</code> must be immutable</li>
<li>if <code>T: &#39;static</code> then <code>T</code> can only be created at compile time</li>
</ul>
<p>Most Rust beginners get introduced to the <code>&#39;static</code> lifetime for the first time in a code example that looks something like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_literal</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;str literal&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>They get told that <code>&quot;str literal&quot;</code> is hardcoded into the compiled binary and is loaded into read-only memory at run-time so it’s immutable and valid for the entire program and that’s what makes it <code>&#39;static</code>. These concepts are further reinforced by the rules surrounding defining <code>static</code> variables using the <code>static</code> keyword.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: This example is purely for illustrative purposes.</span></span><br><span class="line"><span class="comment">// Never use `static mut`. It&#x27;s a footgun. There are</span></span><br><span class="line"><span class="comment">// safe patterns for global mutable singletons in Rust but</span></span><br><span class="line"><span class="comment">// those are outside the scope of this article.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> MUT_BYTES: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>; <span class="comment">// ❌ - mutating static is unsafe</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        MUT_BYTES[<span class="number">0</span>] = <span class="number">99</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">99</span>, MUT_BYTES[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Regarding <code>static</code> variables</p>
<ul>
<li><strong>they can only be created at compile-time</strong></li>
<li><strong>they should be immutable, mutating them is unsafe</strong></li>
<li><strong>they’re valid for the entire program</strong></li>
</ul>
<p>The <code>&#39;static</code> lifetime was probably named after the default lifetime of <code>static</code> variables, right? So it makes sense that the <code>&#39;static</code> lifetime has to follow all the same rules, right?</p>
<p>Well yes, but <strong>a type <em>with</em> a <code>&#39;static</code> lifetime is different from a type <em>bounded by</em> a <code>&#39;static</code> lifetime</strong>. The latter can be dynamically allocated at run-time, can be safely and freely mutated, can be dropped, and can live for arbitrary durations.</p>
<p>It’s important at this point to distinguish <code>&amp;&#39;static T</code> from <code>T: &#39;static</code>.</p>
<p><code>&amp;&#39;static T</code> is an immutable reference to some <code>T</code> that can be safely held indefinitely long, including up until the end of the program. This is only possible if <code>T</code> itself is immutable and does not move <em>after the reference was created</em>. <code>T</code> does not need to be created at compile-time. It’s possible to generate random dynamically allocated data at run-time and return <code>&#39;static</code> references to it at the cost of leaking memory, e.g.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate random &#x27;static str refs at run-time</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">rand_str_generator</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rand_string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(rand_string.<span class="title function_ invoke__">into_boxed_str</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>T: &#39;static</code> is some <code>T</code> that can be safely held indefinitely long, including up until the end of the program. <code>T: &#39;static</code> includes all <code>&amp;&#39;static T</code> however it also includes all owned types, like <code>String</code>, <code>Vec</code>, etc. The owner of some data is guaranteed that data will never get invalidated as long as the owner holds onto it, therefore the owner can safely hold onto the data indefinitely long, including up until the end of the program. <code>T: &#39;static</code> should be read as <em>“<code>T</code> is bounded by a <code>&#39;static</code> lifetime”</em> not <em>“<code>T</code> has a <code>&#39;static</code> lifetime”</em>. A program to help illustrate these concepts:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">drop_static</span>&lt;T: <span class="symbol">&#x27;static</span>&gt;(t: T) &#123;</span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">strings</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rand::<span class="title function_ invoke__">random</span>() &#123;</span><br><span class="line">            <span class="comment">// all the strings are randomly generated</span></span><br><span class="line">            <span class="comment">// and dynamically allocated at run-time</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">string</span> = rand::random::&lt;<span class="type">u64</span>&gt;().<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">            strings.<span class="title function_ invoke__">push</span>(string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// strings are owned types so they&#x27;re bounded by &#x27;static</span></span><br><span class="line">    <span class="keyword">for</span> <span class="title class_">mut</span> string <span class="keyword">in</span> strings &#123;</span><br><span class="line">        <span class="comment">// all the strings are mutable</span></span><br><span class="line">        string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;a mutation&quot;</span>);</span><br><span class="line">        <span class="comment">// all the strings are droppable</span></span><br><span class="line">        <span class="title function_ invoke__">drop_static</span>(string); <span class="comment">// ✅</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all the strings have been invalidated before the end of the program</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I am the end of the program&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Key Takeaways</strong></p>
<ul>
<li><p><code>T: &#39;static</code> should be read as <em>“<code>T</code> is bounded by a <code>&#39;static</code> lifetime”</em></p>
</li>
<li><p>if <code>T: &#39;static</code> then <code>T</code> can be a borrowed type with a <code>&#39;static</code> lifetime <em>or</em> an owned type</p>
</li>
<li><p>since</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">T:</span> <span class="comment">&#x27;static</span></span><br></pre></td></tr></table></figure>
<p>includes owned types that means</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">T</span></span><br></pre></td></tr></table></figure>
<ul>
<li>can be dynamically allocated at run-time</li>
<li>does not have to be valid for the entire program</li>
<li>can be safely and freely mutated</li>
<li>can be dynamically dropped at run-time</li>
<li>can have lifetimes of different durations</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/42972/">https://even629.com/posts/42972/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/programming/">programming</a></div><div class="post-share"><div class="social-share" data-image="/images/rust_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/3461/" title="leetcode每日一题 P3461 判断操作后字符串中的数字是否相等 I"><img class="cover" src="/images/leetcode_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">leetcode每日一题 P3461 判断操作后字符串中的数字是否相等 I</div></div><div class="info-2"><div class="info-item-1">模拟</div></div></div></a><a class="pagination-related" href="/posts/2510220/" title="ARM Interrupt Controller"><img class="cover" src="/images/arm-logo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ARM Interrupt Controller</div></div><div class="info-2"><div class="info-item-1">Arm64 interrupt controller</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/43000/" title="C++"><img class="cover" src="/images/cpp.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-19</div><div class="info-item-2">C++</div></div><div class="info-2"><div class="info-item-1">C++ language</div></div></div></a><a class="pagination-related" href="/posts/42882/" title="C"><img class="cover" src="/images/C_lang.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-07-19</div><div class="info-item-2">C</div></div><div class="info-2"><div class="info-item-1">C language</div></div></div></a><a class="pagination-related" href="/posts/50010/" title="Golang"><img class="cover" src="/images/golang_cover.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-14</div><div class="info-item-2">Golang</div></div><div class="info-2"><div class="info-item-1">golang笔记</div></div></div></a><a class="pagination-related" href="/posts/43001/" title="数据结构"><img class="cover" src="/images/data_structure.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-20</div><div class="info-item-2">数据结构</div></div><div class="info-2"><div class="info-item-1">数据结构</div></div></div></a><a class="pagination-related" href="/posts/2510240/" title="rust std"><img class="cover" src="/images/rust_cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-24</div><div class="info-item-2">rust std</div></div><div class="info-2"><div class="info-item-1">rust笔记</div></div></div></a><a class="pagination-related" href="/posts/2510270/" title="rustlings"><img class="cover" src="/images/rust_cover.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-10-27</div><div class="info-item-2">rustlings</div></div><div class="info-2"><div class="info-item-1">rustlings记录</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center" id="my-custom-card-author"><div class="avatar-img"><img src="/img/avatar.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">41</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/even629"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告：欢迎留言~</span></div><div class="announcement_content">--- ZH ❤️ YW ---</div><div class="xpand" style="height:200px;"><canvas class="illo" width="800" height="800" style="max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;"></canvas></div></div><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js"></script><script src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js"></script><script id="rendered-js" src="https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js"></script><style>.card-widget.card-announcement {
margin: 0;
align-items: center;
justify-content: center;
text-align: center;
}
canvas {
display: block;
margin: 0 auto;
cursor: move;
}</style><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">1.</span> <span class="toc-text">函数式语言特性:迭代器和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.1.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">闭包的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.2.</span> <span class="toc-text">闭包的类型推断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E9%97%AD%E5%8C%85"><span class="toc-number">1.1.3.</span> <span class="toc-text">泛型参数闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9-struct-%E6%8C%81%E6%9C%89%E9%97%AD%E5%8C%85"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">如何让 struct 持有闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cacher-%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">Cacher 实现的限制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%BC%9A%E6%8D%95%E8%8E%B7%E5%85%B6%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.4.</span> <span class="toc-text">闭包会捕获其环境</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%BB%8E%E6%89%80%E5%9C%A8%E7%8E%AF%E5%A2%83%E6%8D%95%E8%8E%B7%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">闭包从所在环境捕获值的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#move-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">move 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-trait"><span class="toc-number">1.2.1.</span> <span class="toc-text">Iterator trait</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">几个迭代方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%80%97%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">消耗迭代器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%85%B6%E5%AE%83%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">产生其它迭代器的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.4.</span> <span class="toc-text">使用闭包捕获环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">创建自定义迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B-I-O-%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.2.6.</span> <span class="toc-text">改进 I&#x2F;O 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B9%B6%E5%8E%BB%E6%8E%89-clone"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">使用迭代器并去掉 clone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-env-args-%E8%BF%94%E5%9B%9E%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">直接使用 env::args 返回的迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83-%E5%BE%AA%E7%8E%AF-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.2.7.</span> <span class="toc-text">性能比较 循环&#x2F;迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cargo-%E5%92%8C-crates-io"><span class="toc-number">2.</span> <span class="toc-text">Cargo 和 crates.io</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%8F%91%E5%B8%83%E9%85%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">采用发布配置自定义构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-profile"><span class="toc-number">2.1.1.</span> <span class="toc-text">自定义 profile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">2.2.</span> <span class="toc-text">文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3"><span class="toc-number">2.2.1.</span> <span class="toc-text">生成文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3%E5%B9%B6%E6%B5%8F%E8%A7%88"><span class="toc-number">2.2.2.</span> <span class="toc-text">生成文档并浏览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AB%A0%E8%8A%82"><span class="toc-number">2.2.3.</span> <span class="toc-text">常用章节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%E4%BD%9C%E4%B8%BA%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">文档注释作为测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%8C%85%E5%90%AB%E6%B3%A8%E9%87%8A%E7%9A%84%E9%A1%B9%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">2.2.5.</span> <span class="toc-text">为包含注释的项添加文档注释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-pub-use-%E5%AF%BC%E5%87%BA%E6%96%B9%E4%BE%BF%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%AC%E5%85%B1-API"><span class="toc-number">2.3.</span> <span class="toc-text">使用 pub use 导出方便使用的公共 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83-Crate"><span class="toc-number">2.4.</span> <span class="toc-text">发布 Crate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%B7%B2%E5%AD%98%E5%9C%A8-crate-%E7%9A%84%E6%96%B0%E7%89%88%E6%9C%AC"><span class="toc-number">2.5.</span> <span class="toc-text">发布已存在 crate 的新版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-cargo-yank-%E4%BB%8E-Crates-io-%E6%92%A4%E5%9B%9E%E7%89%88%E6%9C%AC"><span class="toc-number">2.6.</span> <span class="toc-text">使用 cargo yank 从 Crates.io 撤回版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cargo-%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%EF%BC%88Workspaces%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">Cargo 工作空间（Workspaces）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4"><span class="toc-number">2.7.1.</span> <span class="toc-text">创建工作空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-CRATES-IO-%E5%AE%89%E8%A3%85%E4%BA%8C%E8%BF%9B%E5%88%B6-crate"><span class="toc-number">2.8.</span> <span class="toc-text">从 CRATES.IO 安装二进制 crate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cargo-install"><span class="toc-number">2.8.1.</span> <span class="toc-text">cargo install</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E6%89%A9%E5%B1%95-cargo"><span class="toc-number">2.9.</span> <span class="toc-text">使用自定义命令扩展 cargo</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%92%8C%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B6%E5%AE%83%E4%B8%8D%E5%90%8C"><span class="toc-number">3.1.</span> <span class="toc-text">引用和智能指针的其它不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Box%E6%8C%87%E5%90%91%E5%A0%86%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.</span> <span class="toc-text">使用 Box指向堆上的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Box-%E8%B5%8B%E8%83%BD%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">使用 Box 赋能递归类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cons-List"><span class="toc-number">3.3.1.</span> <span class="toc-text">Cons List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%9D%9E%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">计算非递归类型的大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Box%E7%BB%99%E9%80%92%E5%BD%92%E7%B1%BB%E5%9E%8B%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%9F%A5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">使用 Box给递归类型一个已知的大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dref-Trait"><span class="toc-number">3.4.</span> <span class="toc-text">Dref Trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.5.</span> <span class="toc-text">解引用运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%8A-Box%E5%BD%93%E4%BD%9C%E5%BC%95%E7%94%A8"><span class="toc-number">3.6.</span> <span class="toc-text">把 Box当作引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E8%87%AA%E5%B7%B1%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.7.</span> <span class="toc-text">定义自己的智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%AE%9E%E7%8E%B0-Deref-trait-%E5%B0%86%E6%9F%90%E7%B1%BB%E5%9E%8B%E5%83%8F%E5%BC%95%E7%94%A8%E4%B8%80%E6%A0%B7%E5%A4%84%E7%90%86"><span class="toc-number">3.8.</span> <span class="toc-text">通过实现 Deref trait 将某类型像引用一样处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%9A%90%E5%BC%8F%E8%A7%A3%E5%BC%95%E7%94%A8%E8%BD%AC%E5%8C%96%EF%BC%88Deref-Coercion%EF%BC%89"><span class="toc-number">3.9.</span> <span class="toc-text">函数和方法的隐式解引用转化（Deref Coercion）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E4%B8%8E%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">3.10.</span> <span class="toc-text">解引用与可变性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Drop-Trait"><span class="toc-number">3.11.</span> <span class="toc-text">Drop Trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-std-mem-drop-%E6%9D%A5%E6%8F%90%E5%89%8D-drop-%E5%80%BC"><span class="toc-number">3.12.</span> <span class="toc-text">使用 std::mem::drop 来提前 drop 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rc%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.13.</span> <span class="toc-text">Rc引用计数智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%8B%E9%9A%86-Rc%E4%BC%9A%E5%A2%9E%E5%8A%A0%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">3.14.</span> <span class="toc-text">克隆 Rc会增加引用计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RefCell%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">3.15.</span> <span class="toc-text">RefCell和内部可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%EF%BC%88interior-mutability"><span class="toc-number">3.15.1.</span> <span class="toc-text">内部可变性（interior mutability)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RefCell%E4%B8%8E-Box%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.15.2.</span> <span class="toc-text">RefCell与 Box的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E8%A7%84%E5%88%99%E5%9C%A8%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E8%BF%9B%E8%A1%8C%E6%A3%80%E6%9F%A5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.15.3.</span> <span class="toc-text">借用规则在不同阶段进行检查的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-Box%EF%BC%8CRc%EF%BC%8CRefCell%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="toc-number">3.15.4.</span> <span class="toc-text">选择 Box，Rc，RefCell的依据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%EF%BC%9A%E5%8F%AF%E5%8F%98%E7%9A%84%E5%80%9F%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%80%BC"><span class="toc-number">3.15.5.</span> <span class="toc-text">内部可变性：可变的借用一个不可变的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-RefCell%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AE%B0%E5%BD%95%E5%80%9F%E7%94%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">3.15.6.</span> <span class="toc-text">使用 RefCell在运行时记录借用信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88-Rc-%E5%92%8C-RefCell-%E6%9D%A5%E6%8B%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%89%80%E6%9C%89%E8%80%85"><span class="toc-number">3.15.7.</span> <span class="toc-text">结合 Rc 和 RefCell 来拥有多个可变数据所有者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E5%8F%AF%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.16.</span> <span class="toc-text">其它可实现内部可变性的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">3.17.</span> <span class="toc-text">循环引用导致内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF%EF%BC%9A%E5%B0%86-Rc-%E5%8F%98%E4%B8%BA-Weak"><span class="toc-number">3.17.1.</span> <span class="toc-text">避免引用循环：将 Rc 变为 Weak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Strong-VS-Weak"><span class="toc-number">3.17.2.</span> <span class="toc-text">Strong VS Weak</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%B8%A6%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84-Node"><span class="toc-number">3.17.2.1.</span> <span class="toc-text">创建树形数据结构：带有子节点的 Node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%BB%8E%E5%AD%90%E5%88%B0%E7%88%B6%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">3.17.2.2.</span> <span class="toc-text">增加从子到父的引用</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E7%95%8F%E5%B9%B6%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">无畏并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">4.1.</span> <span class="toc-text">使用线程同时运行代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-spawn-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">通过 spawn 创建新线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-join-Handle-%E6%9D%A5%E7%AD%89%E5%BE%85%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%8C%E6%88%90"><span class="toc-number">4.3.</span> <span class="toc-text">通过 join Handle 来等待所有线程的完成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-move-%E9%97%AD%E5%8C%85"><span class="toc-number">4.4.</span> <span class="toc-text">使用 move 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9D%A5%E8%B7%A8%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.</span> <span class="toc-text">使用消息传递来跨线程传递数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel"><span class="toc-number">4.5.1.</span> <span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Channel"><span class="toc-number">4.5.2.</span> <span class="toc-text">创建 Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E4%B8%8E%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB"><span class="toc-number">4.5.3.</span> <span class="toc-text">信道与所有权转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%A4%9A%E4%B8%AA%E5%80%BC%E5%B9%B6%E8%A7%82%E5%AF%9F%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84%E7%AD%89%E5%BE%85"><span class="toc-number">4.5.4.</span> <span class="toc-text">发送多个值并观察接收者的等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%85%8B%E9%9A%86%E5%8F%91%E9%80%81%E8%80%85%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">4.5.5.</span> <span class="toc-text">通过克隆发送者来创建多个生产者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E5%B9%B6%E5%8F%91"><span class="toc-number">4.6.</span> <span class="toc-text">共享状态并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%99%A8%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE"><span class="toc-number">4.6.1.</span> <span class="toc-text">互斥器一次只允许一个线程访问数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutex-%E7%9A%84-API"><span class="toc-number">4.6.2.</span> <span class="toc-text">Mutex 的 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB-Mutex"><span class="toc-number">4.6.3.</span> <span class="toc-text">在线程间共享 Mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">4.6.4.</span> <span class="toc-text">多线程和多所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-Arc"><span class="toc-number">4.6.5.</span> <span class="toc-text">原子引用计数 Arc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RefCell-Rc-%E4%B8%8E-Mutex-Arc-%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7"><span class="toc-number">4.6.6.</span> <span class="toc-text">RefCell&#x2F;Rc 与 Mutex&#x2F;Arc 的相似性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Sync-%E5%92%8C-Send-trait-%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E5%B9%B6%E5%8F%91"><span class="toc-number">4.7.</span> <span class="toc-text">使用 Sync 和 Send trait 的可扩展并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Send-%E5%85%81%E8%AE%B8%E5%9C%A8%E7%BA%BF%E7%A8%8B%E9%97%B4%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-number">4.7.1.</span> <span class="toc-text">通过 Send 允许在线程间转移所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sync-%E5%85%81%E8%AE%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE"><span class="toc-number">4.7.2.</span> <span class="toc-text">Sync 允许多线程访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0-Send-%E5%92%8C-Sync-%E6%98%AF%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">4.7.3.</span> <span class="toc-text">手动实现 Send 和 Sync 是不安全的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rust-%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">Rust 的面向对象特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">面向对象语言的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84-trait-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">不同类型值的 trait 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E9%80%9A%E7%94%A8%E8%A1%8C%E4%B8%BA%E7%9A%84-trait"><span class="toc-number">5.3.</span> <span class="toc-text">定义通用行为的 trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait-%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E5%8A%A8%E6%80%81%E5%88%86%E5%8F%91"><span class="toc-number">5.4.</span> <span class="toc-text">trait 对象执行动态分发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait-%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.5.</span> <span class="toc-text">trait 对象需要类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.</span> <span class="toc-text">面向对象设计模式的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">6.</span> <span class="toc-text">模式与模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#match-%E7%9A%84-Arm"><span class="toc-number">6.1.</span> <span class="toc-text">match 的 Arm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6-if-let-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">条件 if let 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while-let-%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.3.</span> <span class="toc-text">while let 条件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">6.4.</span> <span class="toc-text">for 循环的模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">6.5.</span> <span class="toc-text">let 语句的模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">6.6.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%BE%A8%E9%A9%B3%E6%80%A7%EF%BC%9A%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%90%A6%E4%BC%9A%E6%97%A0%E6%B3%95%E5%8C%B9%E9%85%8D"><span class="toc-number">6.7.</span> <span class="toc-text">可辨驳性：模式是否会无法匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%97%E9%9D%A2%E5%80%BC"><span class="toc-number">6.8.</span> <span class="toc-text">匹配字面值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%91%BD%E5%90%8D%E5%8F%98%E9%87%8F"><span class="toc-number">6.9.</span> <span class="toc-text">匹配命名变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="toc-number">6.10.</span> <span class="toc-text">匹配一个可变引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.11.</span> <span class="toc-text">多重模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E6%9D%A5%E5%8C%B9%E9%85%8D%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E7%9A%84%E5%80%BC"><span class="toc-number">6.12.</span> <span class="toc-text">使用..&#x3D;来匹配某个范围的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E4%BB%A5%E5%88%86%E8%A7%A3%E5%80%BC"><span class="toc-number">6.13.</span> <span class="toc-text">解构以分解值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">6.13.1.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%85%83%E7%BB%84"><span class="toc-number">6.13.2.</span> <span class="toc-text">解构元组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">6.13.3.</span> <span class="toc-text">解构结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">6.13.4.</span> <span class="toc-text">解构枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E5%B5%8C%E5%A5%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="toc-number">6.13.5.</span> <span class="toc-text">解构嵌套的结构体和枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%83%E7%BB%84"><span class="toc-number">6.13.6.</span> <span class="toc-text">解构结构体和元组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E5%BF%BD%E7%95%A5%E5%80%BC"><span class="toc-number">6.14.</span> <span class="toc-text">在模式中忽略值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E6%95%B4%E4%B8%AA%E5%80%BC"><span class="toc-number">6.14.1.</span> <span class="toc-text">_ 忽略整个值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97-%E5%BF%BD%E7%95%A5%E5%80%BC%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">6.14.2.</span> <span class="toc-text">使用嵌套_忽略值的一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BB%A5-%E5%BC%80%E5%A4%B4%E5%91%BD%E5%90%8D%E6%9D%A5%E5%BF%BD%E7%95%A5%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">6.14.3.</span> <span class="toc-text">使用以_开头命名来忽略未使用的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E5%80%BC%E7%9A%84%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86"><span class="toc-number">6.14.4.</span> <span class="toc-text">..(忽略值的剩余部分)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-match-%E5%AE%88%E5%8D%AB%E6%9D%A5%E6%8F%90%E4%BE%9B%E9%A2%9D%E5%A4%96%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.15.</span> <span class="toc-text">使用 match 守卫来提供额外的条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A"><span class="toc-number">6.16.</span> <span class="toc-text">@绑定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsafe-Rust"><span class="toc-number">7.</span> <span class="toc-text">unsafe Rust</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-%E8%B6%85%E8%83%BD%E5%8A%9B"><span class="toc-number">7.1.</span> <span class="toc-text">unsafe 超能力</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88"><span class="toc-number">7.1.1.</span> <span class="toc-text">解引用原始指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-unsafe-%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.2.</span> <span class="toc-text">调用 unsafe 函数或方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-unsafe-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%89%E5%85%A8%E6%8A%BD%E8%B1%A1"><span class="toc-number">7.1.3.</span> <span class="toc-text">创建 unsafe 代码的安全抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-extern-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">7.1.4.</span> <span class="toc-text">使用 extern 函数调用外部代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%85%B6%E5%AE%83%E8%AF%AD%E8%A8%80%E8%B0%83%E7%94%A8-Rust-%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">从其它语言调用 Rust 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%88%96%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8F%98%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">7.3.</span> <span class="toc-text">访问或修改一个可变的静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%AE%89%E5%85%A8-trait"><span class="toc-number">7.4.</span> <span class="toc-text">实现不安全 trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%81%94%E5%90%88%E4%BD%93%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">7.5.</span> <span class="toc-text">访问联合体中的字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">7.6.</span> <span class="toc-text">何时使用不安全的代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7-trait"><span class="toc-number">8.</span> <span class="toc-text">高级 trait</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-trait-%E5%AE%9A%E4%B9%89%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E6%9D%A5%E6%8C%87%E5%AE%9A%E5%8D%A0%E4%BD%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.1.</span> <span class="toc-text">在 trait 定义中使用关联类型来指定占位类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">关联类型与泛型的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">8.3.</span> <span class="toc-text">默认泛型参数和运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95-Fully-Qualified-Syntax"><span class="toc-number">8.4.</span> <span class="toc-text">完全限定语法(Fully Qualified Syntax)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-supertrait-%E6%9D%A5%E8%A6%81%E6%B1%82-trait-%E9%99%84%E5%B8%A6%E5%85%B6%E5%AE%83-trait-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">8.5.</span> <span class="toc-text">使用 supertrait 来要求 trait 附带其它 trait 的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-newtype-%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8-trait"><span class="toc-number">8.6.</span> <span class="toc-text">使用 newtype 模式在外部类型上实现外部 trait</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">高级类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-newtype-%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%8A%BD%E8%B1%A1"><span class="toc-number">9.1.</span> <span class="toc-text">使用 newtype 模式实现类型安全和抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%E5%90%8C%E4%B9%89%E8%AF%8D"><span class="toc-number">9.2.</span> <span class="toc-text">使用类型别名创建类型同义词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#never-%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">never 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E5%92%8C-Sized-Trait"><span class="toc-number">9.4.</span> <span class="toc-text">动态大小和 Sized Trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rust-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%9A%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">9.5.</span> <span class="toc-text">Rust 使用动态大小类型的通用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9Atrait"><span class="toc-number">9.6.</span> <span class="toc-text">另外一种动态大小的类型：trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sized-trait"><span class="toc-number">9.7.</span> <span class="toc-text">Sized trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sized-trait-%E7%BA%A6%E6%9D%9F"><span class="toc-number">9.8.</span> <span class="toc-text">?Sized trait 约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">10.</span> <span class="toc-text">高级函数和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">10.1.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">10.2.</span> <span class="toc-text">函数指针与闭包的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E9%97%AD%E5%8C%85"><span class="toc-number">10.3.</span> <span class="toc-text">返回闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">11.</span> <span class="toc-text">宏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">12.</span> <span class="toc-text">异步编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">13.</span> <span class="toc-text">格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">位置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">13.2.</span> <span class="toc-text">具名参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E9%BD%90"><span class="toc-number">13.3.</span> <span class="toc-text">字符串对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E5%BA%A6"><span class="toc-number">13.4.</span> <span class="toc-text">精度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%85%AB%E8%BF%9B%E5%88%B6%EF%BC%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-number">13.5.</span> <span class="toc-text">二进制，八进制，十六进制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">13.6.</span> <span class="toc-text">捕获环境中的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%EF%BC%8C%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%EF%BC%8C%E8%BD%AC%E4%B9%89"><span class="toc-number">13.7.</span> <span class="toc-text">指数，指针地址，转义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Other"><span class="toc-number">14.</span> <span class="toc-text">Other</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">14.1.</span> <span class="toc-text">错误处理：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unreachable"><span class="toc-number">14.1.1.</span> <span class="toc-text">unreachable!()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#misconception-corollaries"><span class="toc-number">14.2.</span> <span class="toc-text">misconception corollaries</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-T-39-static-then-T-must-be-valid-for-the-entire-program"><span class="toc-number">14.2.1.</span> <span class="toc-text">if T: &#39;static then T must be valid for the entire program</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2510312/" title="ARM CHI"><img src="/images/arm-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM CHI"/></a><div class="content"><a class="title" href="/posts/2510312/" title="ARM CHI">ARM CHI</a><time datetime="2025-10-31T12:59:13.000Z" title="发表于 2025-10-31 20:59:13">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2510311/" title="ARM ACE"><img src="/images/arm-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM ACE"/></a><div class="content"><a class="title" href="/posts/2510311/" title="ARM ACE">ARM ACE</a><time datetime="2025-10-31T12:42:13.000Z" title="发表于 2025-10-31 20:42:13">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2510310/" title="ARM AXI"><img src="/images/arm-logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ARM AXI"/></a><div class="content"><a class="title" href="/posts/2510310/" title="ARM AXI">ARM AXI</a><time datetime="2025-10-31T12:15:13.000Z" title="发表于 2025-10-31 20:15:13">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/230/" title="面试经典150题 P230 二叉搜索树中第 K 小的元素"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经典150题 P230 二叉搜索树中第 K 小的元素"/></a><div class="content"><a class="title" href="/posts/230/" title="面试经典150题 P230 二叉搜索树中第 K 小的元素">面试经典150题 P230 二叉搜索树中第 K 小的元素</a><time datetime="2025-10-31T07:00:00.000Z" title="发表于 2025-10-31 15:00:00">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/98/" title="面试经典150题 P98 验证二叉搜索树"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经典150题 P98 验证二叉搜索树"/></a><div class="content"><a class="title" href="/posts/98/" title="面试经典150题 P98 验证二叉搜索树">面试经典150题 P98 验证二叉搜索树</a><time datetime="2025-10-31T06:44:13.000Z" title="发表于 2025-10-31 14:44:13">2025-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/98/" title="面试经典150题 P530 二叉搜索树的最小绝对差"><img src="/images/leetcode_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试经典150题 P530 二叉搜索树的最小绝对差"/></a><div class="content"><a class="title" href="/posts/98/" title="面试经典150题 P530 二叉搜索树的最小绝对差">面试经典150题 P530 二叉搜索树的最小绝对差</a><time datetime="2025-10-31T06:16:13.000Z" title="发表于 2025-10-31 14:16:13">2025-10-31</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a title="GitHub" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/even629"><i class="fab fa-regular fa-github"></i></a><a title="Mail" href="mailto:zhaohang731005515@proton.me" rel="external nofollow noreferrer"><i class="fas fa-regular fa-envelope"></i></a></div><div class="copyright">&copy;2014 - 2025 By even629</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();" rel="external nofollow noreferrer"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();" rel="external nofollow noreferrer"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '788a8b6d5d387491dd18afc899da7bb7'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code      
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'src'
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}"></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/even629/even629.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/pop-up-window.js"></script><script defer src="/js/light.js"></script><script src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('category-bar');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><!-- hexo injector body_end end --></body></html>