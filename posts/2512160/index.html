<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux pinctrl 子系统 | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于Linux 5.10, 瑞芯微 rk3568 pinctrl 驱动分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux pinctrl 子系统">
<meta property="og:url" content="https://even629.com/posts/2512160/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="基于Linux 5.10, 瑞芯微 rk3568 pinctrl 驱动分析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/linux_cover.webp">
<meta property="article:published_time" content="2025-12-16T07:47:13.000Z">
<meta property="article:modified_time" content="2025-12-16T07:47:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/linux_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/2512160/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: even629","link":"链接: ","source":"来源: 常想一二，不思八九","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux pinctrl 子系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.png', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom_card_author.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/newYear.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/beautify_label_h.css"><link rel="stylesheet" href="/css/equipment.css"><link rel="stylesheet" href="/css/liquid_glass.css"><link rel="stylesheet" href="/css/tag_plugin_plus.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="常想一二，不思八九" type="application/atom+xml">
</head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/linux_top_image.jpg);"><nav class="liquidGlass-wrapper" id="nav" style="--glass-border-radius: 2rem;"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box" style="display:flex;align-items:center;justify-content:center;width:100%"><!-- 左侧博客信息区域--><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" alt="Logo"></a></span><!-- 新增的导航菜单容器（居中布局关键）--><div id="nav-menus-container"><!-- 菜单主体部分--><div id="menus"><!-- 菜单项--><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><!-- 显示当前标题名称--><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">常想一二，不思八九</a></center></div></div><!-- 右侧功能区域（新增容器）--><div id="nav-right-container"><!-- 搜索按钮（移动到右侧）--><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><!-- 移动端汉堡菜单按钮--><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">Linux pinctrl 子系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-16T07:47:13.000Z" title="发表于 2025-12-16 15:47:13">2025-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-16T07:47:13.000Z" title="更新于 2025-12-16 15:47:13">2025-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">23.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>104分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2512160/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-16</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div></div>

<hr>
<h1 id="pinctrl设备树"><a href="#pinctrl设备树" class="headerlink" title="pinctrl设备树"></a>pinctrl设备树</h1><p><strong>arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rk3568.dtsi</strong></p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">pinctrl:</span> <span class="title class_">pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-pinctrl&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">rockchip,grf</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;grf</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">rockchip,pmu</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;pmugrf</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="meta">#address-cells = &lt;2&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;2&gt;;</span></span><br><span class="line">	<span class="attr">ranges</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">	gpio0:</span> <span class="title class_">gpio0@fdd60000</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfdd60000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;pmucru</span> PCLK_GPIO0&gt;</span>, <span class="params">&lt;<span class="variable">&amp;pmucru</span> DBCLK_GPIO0&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">		<span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line">		<span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">	gpio1:</span> <span class="title class_">gpio1@fe740000</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe740000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">34</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_GPIO1&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> DBCLK_GPIO1&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">		<span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line">		<span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">	gpio2:</span> <span class="title class_">gpio2@fe750000</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe750000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">35</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_GPIO2&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> DBCLK_GPIO2&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">		<span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line">		<span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">	gpio3:</span> <span class="title class_">gpio3@fe760000</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe760000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_GPIO3&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> DBCLK_GPIO3&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">		<span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line">		<span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">	gpio4:</span> <span class="title class_">gpio4@fe770000</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,gpio-bank&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe770000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">37</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_GPIO4&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> DBCLK_GPIO4&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line">		<span class="attr">gpio-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#gpio-cells = &lt;2&gt;;</span></span><br><span class="line">		<span class="attr">interrupt-controller</span><span class="punctuation">;</span></span><br><span class="line">		<span class="meta">#interrupt-cells = &lt;2&gt;;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>GPIO 引脚 ⊂ SoC 引脚，而SoC 引脚 由 pinctrl 统一管理，Linux 官方 pinctrl binding 推荐：<strong>GPIO controller 作为 pin controller 的子节点</strong></p>
<table>
<thead>
<tr>
<th>GPIO bank</th>
<th>名称</th>
<th>管脚数</th>
<th>基地址</th>
</tr>
</thead>
<tbody><tr>
<td>GPIO0</td>
<td>gpio0</td>
<td>32</td>
<td>0xfdd60000</td>
</tr>
<tr>
<td>GPIO1</td>
<td>gpio1</td>
<td>32</td>
<td>0xfe740000</td>
</tr>
<tr>
<td>GPIO2</td>
<td>gpio2</td>
<td>32</td>
<td>0xfe750000</td>
</tr>
<tr>
<td>GPIO3</td>
<td>gpio3</td>
<td>32</td>
<td>0xfe760000</td>
</tr>
<tr>
<td>GPIO4</td>
<td>gpio4</td>
<td>32</td>
<td>0xfe770000</td>
</tr>
</tbody></table>
<p><strong>每个 bank：</strong></p>
<ul>
<li>一套寄存器</li>
<li>一个中断号</li>
<li>两个时钟（PCLK &#x2F; DBCLK）</li>
<li>控制一组物理引脚的：方向、电平、GPIO 中断</li>
</ul>
<p><strong>arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;rockchip&#x2F;rk3568-pinctrl.dtsi</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&amp;pinctrl &#123;</span><br><span class="line">	acodec &#123;</span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		acodec_pins: acodec-pins &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* acodec_adc_sync */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PB1 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line">				<span class="comment">/* acodec_adcclk */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA1 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line">				<span class="comment">/* acodec_adcdata */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA0 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line">				<span class="comment">/* acodec_dac_datal */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA7 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line">				<span class="comment">/* acodec_dac_datar */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PB0 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line">				<span class="comment">/* acodec_dacclk */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA3 <span class="number">5</span> &amp;pcfg_pull_none&gt;,</span><br><span class="line">				<span class="comment">/* acodec_dacsync */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA5 <span class="number">5</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	audiopwm &#123;</span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		audiopwm_lout: audiopwm-lout &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* audiopwm_lout */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA0 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		audiopwm_loutn: audiopwm-loutn &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* audiopwm_loutn */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA1 <span class="number">6</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		audiopwm_loutp: audiopwm-loutp &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* audiopwm_loutp */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA0 <span class="number">6</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		audiopwm_rout: audiopwm-rout &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* audiopwm_rout */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA1 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		audiopwm_routn: audiopwm-routn &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* audiopwm_routn */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA7 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		/omit-<span class="keyword">if</span>-no-ref/</span><br><span class="line">		audiopwm_routp: audiopwm-routp &#123;</span><br><span class="line">			rockchip,pins =</span><br><span class="line">				<span class="comment">/* audiopwm_routp */</span></span><br><span class="line">				&lt;<span class="number">1</span> RK_PA6 <span class="number">4</span> &amp;pcfg_pull_none&gt;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">    ...</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>无论是 rk3568.dtsi 设备树中的 pinctrl 节点，还是上面 rk3568-pinctrl.dtsi 设备树中的一系列复用关系都是由瑞芯微原厂 BSP 工程师编写的，我们只需知道如何使用即可，而 pinctrl 客户端设备树是由我们自己根据特定需求来编写的</p>
<p>pinctrl驱动</p>
<p>设备树中存放的只是设备的描述信息，而具体的功能实现取决于相应的 pinctrl 驱动。</p>
<p>根据rk3568.dtsi <strong>设备树中 pinctrl 节点的 compatible 属性</strong>进行查找驱动，可以查找到 pinctrl 的驱动文件是内核源码的<code>driver/pinctrl/pinctrl-rockchip.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">rockchip_pinctrl_dt_match</span>[] =</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPU_RK3568</span></span><br><span class="line">	&#123; .compatible = <span class="string">&quot;rockchip,rk3568-pinctrl&quot;</span>,</span><br><span class="line">		.data = &amp;rk3568_pin_ctrl &#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">rockchip_pinctrl_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= rockchip_pinctrl_probe,</span><br><span class="line">	.remove		= rockchip_pinctrl_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;rockchip-pinctrl&quot;</span>,</span><br><span class="line">		.pm = &amp;rockchip_pinctrl_dev_pm_ops,</span><br><span class="line">		.of_match_table = rockchip_pinctrl_dt_match,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">rockchip_pinctrl_drv_register</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;rockchip_pinctrl_driver);</span><br><span class="line">&#125;</span><br><span class="line">postcore_initcall(rockchip_pinctrl_drv_register);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">rockchip_pinctrl_drv_unregister</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	platform_driver_unregister(&amp;rockchip_pinctrl_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(rockchip_pinctrl_drv_unregister);</span><br></pre></td></tr></table></figure>

<p>可以看到pinctrl 驱动使用的是 platform 总线，使用<code>postcore_initcall</code>而非<code>module_init</code></p>
<h2 id="groups和function"><a href="#groups和function" class="headerlink" title="groups和function"></a>groups和function</h2><p>Pinctrl 子系统中，有两个关键概念：引脚组（groups）和功能（function），在介绍 pinctrl子系统函数操作集之前，首先对 groups 和 function 进行讲解。</p>
<ul>
<li>引脚组（Groups）引脚组是一组具有相似功能、约束条件或共同工作的引脚的集合。每个引脚组通常与特定的硬件功能或外设相关联。例如，一个引脚组可以用于控制串行通信接口（如 UART 或 SPI），另一个引脚组可以用于驱动 GPIO。</li>
<li>功能（Function）：定义了芯片上具有外设功能的功能。每个功能节点对应于一个或多个 IO 组（group）的配置信息。这些功能可以是串口、SPI、I2C 等外设功能。</li>
</ul>
<p>接下来以 rk3568-pinctrl.dtsi 设备树文件中的 can0 和 can1 两个功能为例对上面的内容进行举例，具体内容如下所示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">can0</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="keyword">/omit-if-no-ref/</span></span><br><span class="line"><span class="symbol">	can0m0_pins:</span> <span class="title class_">can0m0-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line">			<span class="comment">/* can0_rxm0 */</span></span><br><span class="line">			<span class="params">&lt;<span class="number">0</span> RK_PB4 <span class="number">2</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">			<span class="comment">/* can0_txm0 */</span></span><br><span class="line">			<span class="params">&lt;<span class="number">0</span> RK_PB3 <span class="number">2</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">/omit-if-no-ref/</span></span><br><span class="line"><span class="symbol">	can0m1_pins:</span> <span class="title class_">can0m1-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line">			<span class="comment">/* can0_rxm1 */</span></span><br><span class="line">			<span class="params">&lt;<span class="number">2</span> RK_PA2 <span class="number">4</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">			<span class="comment">/* can0_txm1 */</span></span><br><span class="line">			<span class="params">&lt;<span class="number">2</span> RK_PA1 <span class="number">4</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">can1</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="keyword">/omit-if-no-ref/</span></span><br><span class="line"><span class="symbol">	can1m0_pins:</span> <span class="title class_">can1m0-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line">			<span class="comment">/* can1_rxm0 */</span></span><br><span class="line">			<span class="params">&lt;<span class="number">1</span> RK_PA0 <span class="number">3</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">			<span class="comment">/* can1_txm0 */</span></span><br><span class="line">			<span class="params">&lt;<span class="number">1</span> RK_PA1 <span class="number">3</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">/omit-if-no-ref/</span></span><br><span class="line"><span class="symbol">	can1m1_pins:</span> <span class="title class_">can1m1-pins</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">rockchip,pins</span> <span class="operator">=</span></span><br><span class="line">			<span class="comment">/* can1_rxm1 */</span></span><br><span class="line">			<span class="params">&lt;<span class="number">4</span> RK_PC2 <span class="number">3</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span>,</span><br><span class="line">			<span class="comment">/* can1_txm1 */</span></span><br><span class="line">			<span class="params">&lt;<span class="number">4</span> RK_PC3 <span class="number">3</span> <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>在上面的设备树中，<strong>can0 和 can1 对应两个不同的 function</strong>，<strong>分别为 CAN0 控制器和 CAN1 控制器</strong>。<strong>每个控制器中又都有两个不同的 groups 引脚组</strong>。</p>
<ul>
<li>CAN0 控制器：<ul>
<li>引脚组 can0m0-pins：这是 CAN0 控制器的第一个引脚组，用于配置 CAN0 的引脚。它定义了两个引脚：RK_PB4 和 RK_PB3<ul>
<li>RK_PB4 用于 CAN0 的接收引脚（can0_rxm0）</li>
<li>RK_PB3 用于 CAN0 的发送引脚（can0_txm0）。</li>
</ul>
</li>
<li>引脚组 can0m1-pins：这是 CAN0 控制器的第二个引脚组，也用于配置 CAN0 的引脚。它定义了两个引脚：RK_PA2 和 RK_PA1。<ul>
<li>RK_PA2 用于 CAN0 的接收引脚（can0_rxm1）</li>
<li>RK_PA1 用于 CAN0 的发送引脚（can0_txm1）。</li>
</ul>
</li>
</ul>
</li>
<li>CAN1 控制器：<ul>
<li>引脚组 can1m0-pins：这是 CAN1 控制器的第一个引脚组，用于配置 CAN1 的引脚。它定义了两个引脚：RK_PA0 和 RK_PA1。<ul>
<li>RK_PA0 用于 CAN1 的接收引脚（can1_rxm0）</li>
<li>RK_PA1 用于 CAN1 的发送引脚（can1_txm0）。</li>
</ul>
</li>
<li>引脚组 can1m1-pins：这是 CAN1 控制器的第二个引脚组，也用于配置 CAN1 的引脚。它定义了两个引脚：RK_PC2 和 RK_PC3。<ul>
<li>RK_PC2 用于 CAN1 的接收引脚（can1_rxm1）</li>
<li>RK_PC3 用于 CAN1 的发送引脚（can1_txm1）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在<code>struct rockchip_pinctrl</code>结构体中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>			*<span class="title">regmap_base</span>;</span><span class="comment">// 基本寄存器映射指针</span></span><br><span class="line">	<span class="type">int</span>				reg_size;			<span class="comment">// 寄存器大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>			*<span class="title">regmap_pull</span>;</span><span class="comment">// 拉取寄存器映射指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>			*<span class="title">regmap_pmu</span>;</span><span class="comment">// 电源管理单元寄存器映射指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>			*<span class="title">dev</span>;</span>		<span class="comment">// 设备指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_ctrl</span>	*<span class="title">ctrl</span>;</span>	<span class="comment">// 瑞芯微芯片引脚控制器指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span>		<span class="title">pctl</span>;</span>		<span class="comment">// 引脚控制器描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span>		*<span class="title">pctl_dev</span>;</span>	<span class="comment">// 引脚控制器设备指针</span></span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_group</span>	*<span class="title">groups</span>;</span><span class="comment">// 瑞芯微芯片引脚组指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ngroups;	<span class="comment">// 引脚组数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pmx_func</span>	*<span class="title">functions</span>;</span><span class="comment">// 瑞芯微芯片引脚功能指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			nfunctions;<span class="comment">// 引脚功能数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h1 id="rockchip-pinctrl-probe"><a href="#rockchip-pinctrl-probe" class="headerlink" title="rockchip_pinctrl_probe()"></a>rockchip_pinctrl_probe()</h1><p>瑞芯微的pinctrl驱动函数中的probe函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span>;</span> <span class="comment">// Rockchip GPIO 控制器的信息结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev; <span class="comment">// 设备结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> dev-&gt;of_node, *node; <span class="comment">// 设备节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_ctrl</span> *<span class="title">ctrl</span>;</span> <span class="comment">// Rockchip GPIO 控制器的配置结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span><span class="comment">// 设备资源指针</span></span><br><span class="line">	<span class="type">void</span> __iomem *base;<span class="comment">// 寄存器基地址指针</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查设备结构体中的设备树节点是否存在，如果不存在则报错并返回错误码</span></span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;of_node)</span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(dev, -ENODEV, <span class="string">&quot;device tree node not found\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 使用 devm_kzalloc 函数分配一个 rockchip_pinctrl 结构体的内存，并将其初始化为 0</span></span><br><span class="line">	info = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*info), GFP_KERNEL);<span class="comment">// 分配并初始化一个 rockchip_pinctrl 结构体</span></span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将设备结构体指针赋值给 info-&gt;dev，以便在后续代码中可以使用设备结构体的信息。  </span></span><br><span class="line">	info-&gt;dev = dev;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 调用 rockchip_pinctrl_get_soc_data 函数，根据设备信息获取与该设备相关的 rockchip_pin_ctrl 结构体。如果获取失败，则报错并返回错误码。</span></span><br><span class="line">	ctrl = rockchip_pinctrl_get_soc_data(info, pdev); <span class="comment">// 获取并设置与 pdev 相关的 rockchip_pin_ctrl 结构体</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (!ctrl)</span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(dev, -EINVAL, <span class="string">&quot;driver data not available\n&quot;</span>);</span><br><span class="line">	info-&gt;ctrl = ctrl;<span class="comment">/* 将获取到的结构体指针赋值给 info-&gt;ctrl */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 使用 of_parse_phandle 函数解析设备树中名为&quot;rockchip,grf&quot;的节点。 */</span></span><br><span class="line">	node = of_parse_phandle(np, <span class="string">&quot;rockchip,grf&quot;</span>, <span class="number">0</span>);<span class="comment">// 解析设备树中的&quot;rockchip,grf&quot;节点，获取寄存器映射基地址</span></span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 如果解析成功，则调用 syscon_node_to_regmap 函数将节点转换为寄存器映射的基地址，并将结果存储在 info-&gt;regmap_base中</span></span><br><span class="line">		info-&gt;regmap_base = syscon_node_to_regmap(node);</span><br><span class="line">		of_node_put(node);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(info-&gt;regmap_base))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(info-&gt;regmap_base);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果找不到&quot;rockchip,grf&quot;节点，则获取 IORESOURCE_MEM 类型的资源，得到寄存器基地址</span></span><br><span class="line">        <span class="comment">/*通过 platform_get_resource 函数获取 IORESOURCE_MEM 类型的资源，以获取寄存器的基地址。然后使用 devm_ioremap_resource 函数将资源映射到内存中，并将结果存储在 base中。 */</span></span><br><span class="line">		base = devm_platform_get_and_ioremap_resource(pdev, <span class="number">0</span>, &amp;res);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line">		<span class="comment">// 配置寄存器映射的最大寄存器地址和名称</span></span><br><span class="line">		rockchip_regmap_config.max_register = resource_size(res) - <span class="number">4</span>;</span><br><span class="line">		rockchip_regmap_config.name = <span class="string">&quot;rockchip,pinctrl&quot;</span>;</span><br><span class="line">        <span class="comment">/* 使用devm_regmap_init_mmio 函数初始化寄存器映射，将结果存储在 info-&gt;regmap_base 中*/</span></span><br><span class="line">		info-&gt;regmap_base =</span><br><span class="line">			devm_regmap_init_mmio(dev, base, &amp;rockchip_regmap_config);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* to check for the old dt-bindings */</span></span><br><span class="line">		info-&gt;reg_size = resource_size(res);<span class="comment">// 检查旧的 dt-bindings</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Honor the old binding, with pull registers as 2nd resource */</span></span><br><span class="line">        <span class="comment">// 如果控制器类型为 RK3188 且 reg_size 小于 0x200，则获取第二个 IORESOURCE_MEM 类型的资源，作为 pull 寄存器的基地址</span></span><br><span class="line">		<span class="keyword">if</span> (ctrl-&gt;type == RK3188 &amp;&amp; info-&gt;reg_size &lt; <span class="number">0x200</span>) &#123;</span><br><span class="line">			base = devm_platform_get_and_ioremap_resource(pdev, <span class="number">1</span>, &amp;res);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line">			<span class="comment">// 配置 pull 寄存器映射的最大寄存器地址和名称</span></span><br><span class="line">			rockchip_regmap_config.max_register = resource_size(res) - <span class="number">4</span>;</span><br><span class="line">			rockchip_regmap_config.name = <span class="string">&quot;rockchip,pinctrl-pull&quot;</span>;</span><br><span class="line">			info-&gt;regmap_pull =</span><br><span class="line">				devm_regmap_init_mmio(dev, base, &amp;rockchip_regmap_config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try to find the optional reference to the pmu syscon */</span></span><br><span class="line">    <span class="comment">// 尝试查找可选的 pmu syscon 引用</span></span><br><span class="line">	node = of_parse_phandle(np, <span class="string">&quot;rockchip,pmu&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">/* 调用 syscon_node_to_regmap 函数将节点转换为寄存器映射的基地址，并将结果存储在 info-&gt;regmap_pmu 中 */</span></span><br><span class="line">		info-&gt;regmap_pmu = syscon_node_to_regmap(node);</span><br><span class="line">		of_node_put(node);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(info-&gt;regmap_pmu))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(info-&gt;regmap_pmu);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对于某些 SoC 进行特殊处理</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_CPU_RK3308) &amp;&amp; ctrl-&gt;type == RK3308) &#123;</span><br><span class="line">		ret = rk3308_soc_data_init(info);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册 rockchip_pinctrl 设备</span></span><br><span class="line">	ret = rockchip_pinctrl_register(pdev, info);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">// 设置 pdev 的私有数据为 info</span></span><br><span class="line">	platform_set_drvdata(pdev, info);</span><br><span class="line">	g_pctldev = info-&gt;pctl_dev;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 注册 GPIO 设备</span></span><br><span class="line">	ret = of_platform_populate(np, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(dev, ret, <span class="string">&quot;failed to register gpio device\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	dev_info(dev, <span class="string">&quot;probed %s\n&quot;</span>, dev_name(dev));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面 Probe 函数的作用是初始化和配置 Rockchip GPIO 控制器，并将相关信息存储在rockchip_pinctrl 结构体中，最后注册相关设备和 GPIO 接口。</p>
<p>需要注意的是<code>rockchip_pinctrl_register</code>函数，传入参数为platform_device和rockchip_pinctrl类型</p>
<h2 id="rockchip-pinctrl-register"><a href="#rockchip-pinctrl-register" class="headerlink" title="rockchip_pinctrl_register()"></a>rockchip_pinctrl_register()</h2><p><code>rockchip_pinctrl_probe()</code>函数最后调用<code>rockchip_pinctrl_register()</code>函数注册 <code>rockchip_pinctrl</code> 设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_register</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> rockchip_pinctrl *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// info的pctl即pinctrl_desc</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">ctrldesc</span> =</span> &amp;info-&gt;pctl;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pindesc</span>, *<span class="title">pdesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">pin_bank</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">	<span class="type">int</span> pin, bank, ret;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化 pinctrl 描述结构体pinctrl_desc</span></span><br><span class="line">	ctrldesc-&gt;name = <span class="string">&quot;rockchip-pinctrl&quot;</span>;</span><br><span class="line">	ctrldesc-&gt;owner = THIS_MODULE;</span><br><span class="line">	ctrldesc-&gt;pctlops = &amp;rockchip_pctrl_ops;  <span class="comment">// pinctrl 控制操作函数</span></span><br><span class="line">	ctrldesc-&gt;pmxops = &amp;rockchip_pmx_ops;	  <span class="comment">// pinctrl 引脚复用操作函数</span></span><br><span class="line">	ctrldesc-&gt;confops = &amp;rockchip_pinconf_ops;<span class="comment">// pinctrl 引脚配置操作函数</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 使用 devm_kcalloc 函数在设备的内存上分配一块连续的内存区域，用于存储引脚描述结构体。</span></span><br><span class="line">	pindesc = devm_kcalloc(dev, info-&gt;ctrl-&gt;nr_pins, <span class="keyword">sizeof</span>(*pindesc), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pindesc)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	ctrldesc-&gt;pins = pindesc;<span class="comment">//通过将引脚描述结构体的指针 pindesc 赋值给 pinctrl 描述结构体的 pins成员</span></span><br><span class="line">	ctrldesc-&gt;npins = info-&gt;ctrl-&gt;nr_pins;<span class="comment">//将引脚数量 info-&gt;ctrl-&gt;nr_pins 赋值给 pinctrl 描述结构体的 npins 成员</span></span><br><span class="line"></span><br><span class="line">	pdesc = pindesc;<span class="comment">// 定义变量 pdesc 指向引脚描述结构体的起始地址</span></span><br><span class="line">    <span class="comment">// 遍历每个引脚所属的 bank，为每个引脚设置编号和名称</span></span><br><span class="line">	<span class="keyword">for</span> (bank = <span class="number">0</span>, k = <span class="number">0</span>; bank &lt; info-&gt;ctrl-&gt;nr_banks; bank++) &#123;</span><br><span class="line">        <span class="comment">// 外层循环遍历每个引脚所属的 bank</span></span><br><span class="line">		pin_bank = &amp;info-&gt;ctrl-&gt;pin_banks[bank];</span><br><span class="line">		<span class="keyword">for</span> (pin = <span class="number">0</span>; pin &lt; pin_bank-&gt;nr_pins; pin++, k++) &#123;<span class="comment">//pin 是当前引脚在 bank 中的索引</span></span><br><span class="line">            <span class="comment">// 内层循环遍历每个 bank 中的引脚。</span></span><br><span class="line">			pdesc-&gt;number = k;<span class="comment">//当前引脚的编号 k </span></span><br><span class="line">			pdesc-&gt;name = kasprintf(GFP_KERNEL, <span class="string">&quot;%s-%d&quot;</span>,</span><br><span class="line">						pin_bank-&gt;name, pin);</span><br><span class="line">			pdesc++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		INIT_LIST_HEAD(&amp;pin_bank-&gt;deferred_pins);</span><br><span class="line">		mutex_init(&amp;pin_bank-&gt;deferred_lock);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析设备树中的 pinctrl 信息，该函数根据设备树中的描述，设置引脚的默认配置</span></span><br><span class="line">	ret = rockchip_pinctrl_parse_dt(pdev, info);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">// 注册 pinctrl 设备，将 pinctrl 描述结构体、pinctrl 相关操作函数和私有数据作为参数，将 pinctrl 设备注册到系统中</span></span><br><span class="line">	info-&gt;pctl_dev = devm_pinctrl_register(dev, ctrldesc, info);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(info-&gt;pctl_dev))</span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(dev, PTR_ERR(info-&gt;pctl_dev), <span class="string">&quot;could not register pinctrl driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用<code>devm_pinctrl_register</code>，将<code>pdev-&gt;dev</code>，<code>info-&gt;pctl</code>和<code>info</code>传入</p>
<h4 id="rockchip-pinctrl-parse-dt"><a href="#rockchip-pinctrl-parse-dt" class="headerlink" title="rockchip_pinctrl_parse_dt()"></a>rockchip_pinctrl_parse_dt()</h4><p><code>rochip_pinctrl_register()</code> 函数中调用<code>rockchip_pinctrl_register()</code>解析设备树中的 pinctrl 信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_parse_dt</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> rockchip_pinctrl *info)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> dev-&gt;of_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">// 计算子节点数量并更新 info 结构体中的计数器</span></span><br><span class="line">	rockchip_pinctrl_child_count(info, np);</span><br><span class="line"></span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;nfunctions = %d\n&quot;</span>, info-&gt;nfunctions);</span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;ngroups = %d\n&quot;</span>, info-&gt;ngroups);</span><br><span class="line">	<span class="comment">// 为函数和组分配内存空间</span></span><br><span class="line">	info-&gt;functions = devm_kcalloc(dev, info-&gt;nfunctions, <span class="keyword">sizeof</span>(*info-&gt;functions), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!info-&gt;functions)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	info-&gt;groups = devm_kcalloc(dev, info-&gt;ngroups, <span class="keyword">sizeof</span>(*info-&gt;groups), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!info-&gt;groups)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 遍历每个子节点，解析函数信息</span></span><br><span class="line">	for_each_child_of_node(np, child) &#123;</span><br><span class="line">        <span class="comment">// 如果节点不是函数节点，则继续下一个节点</span></span><br><span class="line">		<span class="keyword">if</span> (of_match_node(rockchip_bank_match, child))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">// 解析函数信息并存储到 info 结构体中</span></span><br><span class="line">		ret = rockchip_pinctrl_parse_functions(child, info, i++);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(dev, <span class="string">&quot;failed to parse function\n&quot;</span>);</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="rockchip-pinctrl-child-count"><a href="#rockchip-pinctrl-child-count" class="headerlink" title="rockchip_pinctrl_child_count()"></a>rockchip_pinctrl_child_count()</h5><p><code>rockchip_pinctrl_parse_dt()</code>函数中通过调用<code>rockchip_pinctrl_child_count(info, np);</code>  计算子节点数量并更新 info 结构体中的计数器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rockchip_pinctrl_child_count</span><span class="params">(<span class="keyword">struct</span> rockchip_pinctrl *info,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> device_node *np)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="comment">// 遍历设备节点的子节点</span></span><br><span class="line">	for_each_child_of_node(np, child) &#123;</span><br><span class="line">        <span class="comment">// 如果子节点不是 function 节点，则跳过当前节点，继续遍历下一个节点</span></span><br><span class="line">		<span class="keyword">if</span> (of_match_node(rockchip_bank_match, child))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 子节点是 function 节点，增加 function 计数器</span></span><br><span class="line">		info-&gt;nfunctions++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取子节点的子节点数量，并增加到组计数器中</span></span><br><span class="line">		info-&gt;ngroups += of_get_child_count(child);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="rockchip-pinctrl-parse-functions"><a href="#rockchip-pinctrl-parse-functions" class="headerlink" title="rockchip_pinctrl_parse_functions()"></a>rockchip_pinctrl_parse_functions()</h5><p><code>rockchip_pinctrl_parse_dt()</code>函数中通过调用<code>rockchip_pinctrl_parse_functions()</code>解析函数信息并存储到 info 结构体中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_parse_functions</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> rockchip_pinctrl *info,</span></span><br><span class="line"><span class="params">						u32 index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> info-&gt;dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pmx_func</span> *<span class="title">func</span>;</span><span class="comment">// 用来存放 function 信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_group</span> *<span class="title">grp</span>;</span><span class="comment">// 用来存放 groups 信息</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">static</span> u32 grp_index;</span><br><span class="line">	u32 i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 打印调试信息，显示正在解析的函数节点和索引</span></span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;parse function(%d): %pOFn\n&quot;</span>, index, np);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取当前函数在 info-&gt;functions 数组中的指针</span></span><br><span class="line">	func = &amp;info-&gt;functions[index];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialise function */</span></span><br><span class="line">    <span class="comment">/* 初始化函数 */</span></span><br><span class="line">	func-&gt;name = np-&gt;name;</span><br><span class="line">    <span class="comment">// 获取函数节点的子节点数量，即关联的组数量</span></span><br><span class="line">	func-&gt;ngroups = of_get_child_count(np);</span><br><span class="line">	<span class="keyword">if</span> (func-&gt;ngroups &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 为函数的组指针数组分配内存空间</span></span><br><span class="line">	func-&gt;groups = devm_kcalloc(dev, func-&gt;ngroups, <span class="keyword">sizeof</span>(*func-&gt;groups), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!func-&gt;groups)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 遍历函数节点的每个子节点</span></span><br><span class="line">	for_each_child_of_node(np, child) &#123;</span><br><span class="line">        <span class="comment">// 将子节点的名称存储到函数的组指针数组中</span></span><br><span class="line">		func-&gt;groups[i] = child-&gt;name;</span><br><span class="line">        <span class="comment">// 获取 info-&gt;groups 数组中的对应组指针</span></span><br><span class="line">		grp = &amp;info-&gt;groups[grp_index++];</span><br><span class="line">        <span class="comment">// 解析组信息，并将结果存储到对应的组指针中</span></span><br><span class="line">		ret = rockchip_pinctrl_parse_groups(child, grp, info, i++);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			of_node_put(child);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>rockchip_pinctrl_parse_functions</code>中:</p>
<ul>
<li>将 info 的 functions 地址赋值给了 func，所以 <code>rockchip_pinctrl</code> 的 functions 参数的作用就是用来存放 pinctrl 设备树中的 function 信息。</li>
<li>info 的 groups 地址赋值给了 grp，所以 <code>rockchip_pinctrl</code> 的 groups 参数的作用就是用来存放 pinctrl 设备树中的 groups 信息。</li>
</ul>
<p><strong>rockchip_pinctrl_parse_groups()</strong></p>
<p><code>rockchip_pinctrl_parse_functions</code>中通过<code>ret = rockchip_pinctrl_parse_groups(child, grp, info, i++);</code> 解析组信息，并将结果存储到对应的组指针中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinctrl_parse_groups</span><span class="params">(<span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> rockchip_pin_group *grp,</span></span><br><span class="line"><span class="params">					      <span class="keyword">struct</span> rockchip_pinctrl *info,</span></span><br><span class="line"><span class="params">					      u32 index)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> info-&gt;dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">bank</span>;</span></span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	<span class="type">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">// 打印调试信息，显示正在解析的组节点和索引</span></span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;group(%d): %pOFn\n&quot;</span>, index, np);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialise group */</span></span><br><span class="line">    <span class="comment">// 初始化组信，将引脚组的名称设置为节点的名称</span></span><br><span class="line">	grp-&gt;name = np-&gt;name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the binding format is rockchip,pins = &lt;bank pin mux CONFIG&gt;,</span></span><br><span class="line"><span class="comment">	 * do sanity check and calculate pins number</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 绑定格式为 rockchip,pins = &lt;bank pin mux CONFIG&gt;，</span></span><br><span class="line"><span class="comment">	* 进行合法性检查并计算引脚数量</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="built_in">list</span> = of_get_property(np, <span class="string">&quot;rockchip,pins&quot;</span>, &amp;size);</span><br><span class="line">	<span class="comment">/* we do not check return since it&#x27;s safe node passed down */</span></span><br><span class="line">	size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">if</span> (!size || size % <span class="number">4</span>)<span class="comment">//如果属性值为空或者数量不是 4 的倍数</span></span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(dev, -EINVAL, <span class="string">&quot;wrong pins number or pins and configs should be by 4\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	grp-&gt;npins = size / <span class="number">4</span>;<span class="comment">// 计算组的引脚数量</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 根据计算得到的引脚数量为引脚数组和数据数组分配内存空间，这些数组将用于存储引脚的编号和相关的配置信息</span></span><br><span class="line">	grp-&gt;pins = devm_kcalloc(dev, grp-&gt;npins, <span class="keyword">sizeof</span>(*grp-&gt;pins), GFP_KERNEL);</span><br><span class="line">	grp-&gt;data = devm_kcalloc(dev, grp-&gt;npins, <span class="keyword">sizeof</span>(*grp-&gt;data), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!grp-&gt;pins || !grp-&gt;data)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">// 遍历列表中的每个元素，每 4 个元素表示一个引脚的信息</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; i += <span class="number">4</span>, j++) &#123;</span><br><span class="line">		<span class="type">const</span> __be32 *phandle;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_config</span>;</span></span><br><span class="line">		<span class="comment">// 获取管脚号</span></span><br><span class="line">		num = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">        <span class="comment">// 引脚号转换为对应的引脚结构体指针</span></span><br><span class="line">		bank = bank_num_to_bank(info, num);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(bank))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(bank);</span><br><span class="line">		<span class="comment">// 根据引脚结构体中的引脚基地址（pin_base）和列表中的值计算引脚的编号，并将其存储在引脚数组（grp-&gt;pins）中</span></span><br><span class="line">		grp-&gt;pins[j] = bank-&gt;pin_base + be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line">        <span class="comment">// 从列表中获取与当前引脚相关的功能选择值，并将其存储在数据数组（grp-&gt;data）中的相应位置</span></span><br><span class="line">		grp-&gt;data[j].func = be32_to_cpu(*<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取与引脚相关的配置信息</span></span><br><span class="line">		phandle = <span class="built_in">list</span>++;</span><br><span class="line">		<span class="keyword">if</span> (!phandle)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="comment">// 从列表中获取与当前引脚相关的配置信息的句柄，并通过该句柄查找对应的配置节点（np_config）</span></span><br><span class="line">		np_config = of_find_node_by_phandle(be32_to_cpup(phandle));</span><br><span class="line">        <span class="comment">// 解析配置信息，并将结果存储到组的数据数组中</span></span><br><span class="line">		ret = pinconf_generic_parse_dt_config(np_config, <span class="literal">NULL</span>,</span><br><span class="line">				&amp;grp-&gt;data[j].configs, &amp;grp-&gt;data[j].nconfigs);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="devm-pinctrl-register"><a href="#devm-pinctrl-register" class="headerlink" title="devm_pinctrl_register()"></a>devm_pinctrl_register()</h4><p><code>rockchip_pinctrl_register()</code>函数通过<code>info-&gt;pctl_dev = devm_pinctrl_register(dev, ctrldesc, info);</code> 注册 pinctrl 设备，将 pinctrl 描述结构体、pinctrl 相关操作函数和私有数据作为参数，将 pinctrl 设备注册到系统中</p>
<p>一个参数类型为<code>struct device *</code>，第二个参数类型为<code> struct pinctrl_desc *</code>，第三个参数类型为<code>void *</code>是pin controller的私有数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_pinctrl_register() - Resource managed version of pinctrl_register().</span></span><br><span class="line"><span class="comment"> * @dev: parent device for this pin controller</span></span><br><span class="line"><span class="comment"> * @pctldesc: descriptor for this pin controller</span></span><br><span class="line"><span class="comment"> * @driver_data: private pin controller data for this pin controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns an error pointer if pincontrol register failed. Otherwise</span></span><br><span class="line"><span class="comment"> * it returns valid pinctrl handle.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pinctrl device will be automatically released when the device is unbound.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl_dev *<span class="title function_">devm_pinctrl_register</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">					  <span class="keyword">struct</span> pinctrl_desc *pctldesc,</span></span><br><span class="line"><span class="params">					  <span class="type">void</span> *driver_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> **<span class="title">ptr</span>, *<span class="title">pctldev</span>;</span></span><br><span class="line">	<span class="comment">// 使用 devres_alloc 函数为存储 pinctrl_dev 指针的变量 ptr 分配内存</span></span><br><span class="line">	ptr = devres_alloc(devm_pinctrl_dev_release, <span class="keyword">sizeof</span>(*ptr), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ptr)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	<span class="comment">// 调用 pinctrl_register 函数注册 pinctrl 设备。该函数将 pinctrl_desc 结构体、设备指针 dev 和驱动程序数据 driver_data 作为参数，并返回注册后的 pinctrl_dev 指针</span></span><br><span class="line">	pctldev = pinctrl_register(pctldesc, dev, driver_data);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(pctldev)) &#123;</span><br><span class="line">		devres_free(ptr);</span><br><span class="line">		<span class="keyword">return</span> pctldev;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 pinctrl_dev 指针存储到 ptr 指向的内存位置。</span></span><br><span class="line">	*ptr = pctldev;</span><br><span class="line">    <span class="comment">// 使用 devres_add 函数将 ptr 添加到设备的资源列表中。这样，在设备释放时，会自动释放之前分配的内存。</span></span><br><span class="line">	devres_add(dev, ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pctldev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(devm_pinctrl_register);</span><br></pre></td></tr></table></figure>

<p><code>devres_alloc</code> 函数是用于管理设备资源的函数，它在设备的资源列表中分配内存。这里分配的内存大小为 <code>sizeof(*ptr)</code>字节，即一个 <code>pinctrl_dev</code> 指针的大小。如果内存分配失败，则返回<code>-ENOMEM</code></p>
<h5 id="pinctrl-register"><a href="#pinctrl-register" class="headerlink" title="pinctrl_register()"></a>pinctrl_register()</h5><p><code>devm_pinctrl_register()</code>通过调用<code>pctldev = pinctrl_register(pctldesc, dev, driver_data);</code>注册 pinctrl 设备。该函数将 pinctrl_desc 结构体、设备指针 dev 和驱动程序数据 driver_data 作为参数，并返回注册后的 pinctrl_dev 指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_register() - register a pin controller device</span></span><br><span class="line"><span class="comment"> * @pctldesc: descriptor for this pin controller</span></span><br><span class="line"><span class="comment"> * @dev: parent device for this pin controller</span></span><br><span class="line"><span class="comment"> * @driver_data: private pin controller data for this pin controller</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that pinctrl_register() is known to have problems as the pin</span></span><br><span class="line"><span class="comment"> * controller driver functions are called before the driver has a</span></span><br><span class="line"><span class="comment"> * struct pinctrl_dev handle. To avoid issues later on, please use the</span></span><br><span class="line"><span class="comment"> * new pinctrl_register_and_init() below instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl_dev *<span class="title function_">pinctrl_register</span><span class="params">(<span class="keyword">struct</span> pinctrl_desc *pctldesc,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> device *dev, <span class="type">void</span> *driver_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="comment">// 初始化 pinctrl 控制器</span></span><br><span class="line">	pctldev = pinctrl_init_controller(pctldesc, dev, driver_data);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(pctldev))</span><br><span class="line">		<span class="keyword">return</span> pctldev;</span><br><span class="line">	<span class="comment">// 启用 pinctrl 控制器</span></span><br><span class="line">	error = pinctrl_enable(pctldev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pctldev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_register);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="pinctrl-init-controller"><a href="#pinctrl-init-controller" class="headerlink" title="pinctrl_init_controller()"></a>pinctrl_init_controller()</h5><p><code>pinctrl_register()</code>中通过<code>pctldev = pinctrl_init_controller(pctldesc, dev, driver_data);</code>初始化 pinctrl 控制器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_init_controller() - init a pin controller device</span></span><br><span class="line"><span class="comment"> * @pctldesc: descriptor for this pin controller</span></span><br><span class="line"><span class="comment"> * @dev: parent device for this pin controller</span></span><br><span class="line"><span class="comment"> * @driver_data: private pin controller data for this pin controller</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pinctrl_dev *</span><br><span class="line"><span class="title function_">pinctrl_init_controller</span><span class="params">(<span class="keyword">struct</span> pinctrl_desc *pctldesc, <span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">			<span class="type">void</span> *driver_data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pctldesc)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	<span class="keyword">if</span> (!pctldesc-&gt;name)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	pctldev = kzalloc(<span class="keyword">sizeof</span>(*pctldev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!pctldev)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize pin control device struct */</span></span><br><span class="line">    <span class="comment">/* 初始化引脚控制设备结构体 */</span></span><br><span class="line">	pctldev-&gt;owner = pctldesc-&gt;owner;<span class="comment">// 设置所有者</span></span><br><span class="line">	pctldev-&gt;desc = pctldesc;<span class="comment">// 设置描述符</span></span><br><span class="line">	pctldev-&gt;driver_data = driver_data; <span class="comment">// 设置驱动程序数据</span></span><br><span class="line">	INIT_RADIX_TREE(&amp;pctldev-&gt;pin_desc_tree, GFP_KERNEL);<span class="comment">// 初始化引脚描述符树</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCTRL_GROUPS</span></span><br><span class="line">	INIT_RADIX_TREE(&amp;pctldev-&gt;pin_group_tree, GFP_KERNEL);<span class="comment">// 初始化引脚组树</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINMUX_FUNCTIONS</span></span><br><span class="line">	INIT_RADIX_TREE(&amp;pctldev-&gt;pin_function_tree, GFP_KERNEL);<span class="comment">// 初始化引脚功能树</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	INIT_LIST_HEAD(&amp;pctldev-&gt;gpio_ranges);<span class="comment">// 初始化 GPIO 范围链表</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;pctldev-&gt;node);<span class="comment">// 初始化节点链表</span></span><br><span class="line">	pctldev-&gt;dev = dev;<span class="comment">// 设置设备指针</span></span><br><span class="line">	mutex_init(&amp;pctldev-&gt;mutex);<span class="comment">// 初始化互斥锁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check core ops for sanity */</span></span><br><span class="line">    <span class="comment">/* 检查核心操作函数的有效性 */</span></span><br><span class="line">	ret = pinctrl_check_ops(pctldev);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;pinctrl ops lacks necessary functions\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we&#x27;re implementing pinmuxing, check the ops for sanity */</span></span><br><span class="line">    <span class="comment">/* 如果实现了引脚复用功能，检查操作函数的有效性 */</span></span><br><span class="line">	<span class="keyword">if</span> (pctldesc-&gt;pmxops) &#123;</span><br><span class="line">		ret = pinmux_check_ops(pctldev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we&#x27;re implementing pinconfig, check the ops for sanity */</span></span><br><span class="line">    <span class="comment">/* 如果实现了引脚配置功能，检查操作函数的有效性 */</span></span><br><span class="line">	<span class="keyword">if</span> (pctldesc-&gt;confops) &#123;</span><br><span class="line">		ret = pinconf_check_ops(pctldev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Register all the pins */</span></span><br><span class="line">    <span class="comment">/* 注册所有引脚 */</span></span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;try to register %d pins ...\n&quot;</span>,  pctldesc-&gt;npins);</span><br><span class="line">	ret = pinctrl_register_pins(pctldev, pctldesc-&gt;pins, pctldesc-&gt;npins);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;error during pin registration\n&quot;</span>);</span><br><span class="line">		pinctrl_free_pindescs(pctldev, pctldesc-&gt;pins,</span><br><span class="line">				      pctldesc-&gt;npins);</span><br><span class="line">		<span class="keyword">goto</span> out_err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pctldev;</span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">	mutex_destroy(&amp;pctldev-&gt;mutex);</span><br><span class="line">	kfree(pctldev);</span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在该函数中我们要关注的是第 27 行内容 <code>pctldev-&gt;driver_data = driver_data</code>，其中右值 driver_data 是从 pinctrl 函数的 probe 一步一步传递过来的，是一个 <code>struct rockchip_pinctrl *</code>类型的结构体指针变量，左值 pctldev 为要注册的引脚控制设备（pincontroller device），至此两个数据结构建立起了关联，可以<strong>通过 <code>pctldev</code> 来对 <code>rockchip_pinctrl</code> 中的数据进行访问</strong>。</p>
<h2 id="相关数据结构体"><a href="#相关数据结构体" class="headerlink" title="相关数据结构体"></a>相关数据结构体</h2><h3 id="pinctrl-desc-结构体"><a href="#pinctrl-desc-结构体" class="headerlink" title="pinctrl_desc 结构体"></a>pinctrl_desc 结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_desc - pin controller descriptor, register this to pin</span></span><br><span class="line"><span class="comment"> * control subsystem</span></span><br><span class="line"><span class="comment"> * @name: name for the pin controller</span></span><br><span class="line"><span class="comment"> * @pins: an array of pin descriptors describing all the pins handled by</span></span><br><span class="line"><span class="comment"> *	this pin controller</span></span><br><span class="line"><span class="comment"> * @npins: number of descriptors in the array, usually just ARRAY_SIZE()</span></span><br><span class="line"><span class="comment"> *	of the pins field above</span></span><br><span class="line"><span class="comment"> * @pctlops: pin control operation vtable, to support global concepts like</span></span><br><span class="line"><span class="comment"> *	grouping of pins, this is optional.</span></span><br><span class="line"><span class="comment"> * @pmxops: pinmux operations vtable, if you support pinmuxing in your driver</span></span><br><span class="line"><span class="comment"> * @confops: pin config operations vtable, if you support pin configuration in</span></span><br><span class="line"><span class="comment"> *	your driver</span></span><br><span class="line"><span class="comment"> * @owner: module providing the pin controller, used for refcounting</span></span><br><span class="line"><span class="comment"> * @num_custom_params: Number of driver-specific custom parameters to be parsed</span></span><br><span class="line"><span class="comment"> *	from the hardware description</span></span><br><span class="line"><span class="comment"> * @custom_params: List of driver_specific custom parameters to be parsed from</span></span><br><span class="line"><span class="comment"> *	the hardware description</span></span><br><span class="line"><span class="comment"> * @custom_conf_items: Information how to print @params in debugfs, must be</span></span><br><span class="line"><span class="comment"> *	the same size as the @custom_params, i.e. @num_custom_params</span></span><br><span class="line"><span class="comment"> * @link_consumers: If true create a device link between pinctrl and its</span></span><br><span class="line"><span class="comment"> *	consumers (i.e. the devices requesting pin control states). This is</span></span><br><span class="line"><span class="comment"> *	sometimes necessary to ascertain the right suspend/resume order for</span></span><br><span class="line"><span class="comment"> *	example.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 引脚控制器的名称</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span><span class="comment">// 引脚描述符数组</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> npins;<span class="comment">// 引脚描述符数组的大小</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span><span class="comment">// 引脚控制操作函数指针</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span><span class="comment">// 引脚复用操作函数指针</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span><span class="comment">// 引脚配置操作函数指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">// 拥有该结构体的模块</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_custom_params;<span class="comment">// 自定义参数数量</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">custom_params</span>;</span><span class="comment">// 自定义参数数组</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_config_item</span> *<span class="title">custom_conf_items</span>;</span><span class="comment">// 自定义配置项数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">bool</span> link_consumers;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>const char *name</code>: <strong>引脚控制器的名称</strong>，用于标识引脚控制器的唯一性。</p>
</li>
<li><p><code>const struct pinctrl_pin_desc *pins</code>: <strong>引脚描述符数组</strong>，是一个指向引脚描述符的指针，用于描述引脚的属性和配置。每个引脚描述符包含了引脚的名称、编号、模式等信息。</p>
</li>
<li><p><code>unsigned int npins</code>: 表示<strong>引脚描述符数组中元素的数量</strong>，用于确定引脚描述符数组的长度。</p>
</li>
<li><p><code>const struct pinctrl_ops *pctlops</code>: <strong>指向引脚控制操作函数的指针，用于定义引脚控制器的操作接口</strong>。通过这些操作函数，可以<strong>对引脚进行配置、使能、禁用</strong>等操作。</p>
</li>
<li><p><code>const struct pinmux_ops *pmxops</code>: <strong>指向引脚复用操作函数的指针，用于定义引脚的复用功能</strong>。复用功能允许<strong>将引脚的功能切换为不同的模式</strong>，以适应不同的设备需求</p>
</li>
<li><p><code>const struct pinconf_ops *confops</code>: <strong>指向引脚配置操作函数的指针，用于定义引脚的其他配置选项</strong>。这些配置选项可以包括<strong>引脚的上拉、下拉配置、电气特性等</strong>。</p>
</li>
<li><p><code>struct module *owner</code>: 指向拥有该引脚控制器结构体的模块的指针。这个字段用于跟踪引脚控制器结构体的所有者。</p>
</li>
<li><p><code>unsigned int num_custom_params</code>: 表示自定义配置参数的数量，用于描述引脚控制器的自定义配置参数。</p>
</li>
<li><p><code>const struct pinconf_generic_params *custom_params</code>: 指向自定义配置参数的指针，用于描述引脚控制器的自定义配置参数的属性。自定义配置参数可以根据具体需求定义，用于扩展引脚控制器的配置选项。</p>
</li>
<li><p><code>const struct pin_config_item *custom_conf_items</code>: 指向自定义配置项的指针，用于描述引脚控制器的自定义配置项的属性。自定义配置项可以根据具体需求定义，用于扩展引脚控制器的配置选项。</p>
</li>
</ul>
<h3 id="rockchip-pinctrl-结构体"><a href="#rockchip-pinctrl-结构体" class="headerlink" title="rockchip_pinctrl 结构体"></a>rockchip_pinctrl 结构体</h3><p>瑞芯微为了适应瑞芯微芯片的特定需求和功能，对 <code>struct pinctrl_desc</code> 进行了再一次封装。封装后的 <code>struct rockchip_pinctrl</code> 结构体在 <code>struct pinctrl_desc</code> 的基础上增加了与瑞芯微芯片相关的字段和指针，这种封装可以提供更好的集成性、易用性和扩展性，同时保持与通用引脚控制器框架的兼容性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>			*<span class="title">regmap_base</span>;</span><span class="comment">// 基本寄存器映射指针</span></span><br><span class="line">	<span class="type">int</span>				reg_size;			<span class="comment">// 寄存器大小</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>			*<span class="title">regmap_pull</span>;</span><span class="comment">// 拉取寄存器映射指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap</span>			*<span class="title">regmap_pmu</span>;</span><span class="comment">// 电源管理单元寄存器映射指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>			*<span class="title">dev</span>;</span>		<span class="comment">// 设备指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_ctrl</span>	*<span class="title">ctrl</span>;</span>	<span class="comment">// 瑞芯微芯片引脚控制器指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span>		<span class="title">pctl</span>;</span>		<span class="comment">// 引脚控制器描述符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span>		*<span class="title">pctl_dev</span>;</span>	<span class="comment">// 引脚控制器设备指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_group</span>	*<span class="title">groups</span>;</span><span class="comment">// 瑞芯微芯片引脚组指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ngroups;	<span class="comment">// 引脚组数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pmx_func</span>	*<span class="title">functions</span>;</span><span class="comment">// 瑞芯微芯片引脚功能指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			nfunctions;<span class="comment">// 引脚功能数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>struct regmap *regmap_base</code>：指向基本寄存器映射（regmap）的指针。基本寄存器映射是一个用于访问芯片寄存器的接口，它提供了对芯片寄存器的读写操作。</p>
</li>
<li><p><code>int reg_size</code>：表示寄存器的字节大小，用于确定寄存器的地址范围。</p>
</li>
<li><p><code>struct regmap *regmap_pull</code>：指向拉取寄存器映射的指针。拉取寄存器映射用于控制引脚上的上拉和下拉功能。</p>
</li>
<li><p><code>struct regmap *regmap_pmu</code>：指向电源管理单元（PMU）寄存器映射的指针。PMU寄存器映射用于控制引脚的电源管理功能</p>
</li>
<li><p><code>struct device *dev</code>：指向设备结构体的指针。设备结构体用于表示与硬件相关的设备，包括设备的物理地址、中断等信息</p>
</li>
<li><p><code>struct rockchip_pin_ctrl *ctrl</code>：指向瑞芯微芯片引脚控制器的指针。这个结构体存储了瑞芯微芯片特定的引脚控制器的相关信息和操作。</p>
</li>
<li><p><code>struct pinctrl_desc pctl</code>：包含了 struct pinctrl_desc 结构体的一个实例。用于描述引脚控制器的属性和操作，包括引脚控制器的名称、引脚描述符数组、函数指针等。</p>
</li>
<li><p><code>struct pinctrl_dev *pctl_dev</code>：指向引脚控制器设备结构体的指针。引脚控制器设备结构体用于表示引脚控制器在系统中的设备实例，包含了与引脚控制器相关的设备信息和操作接口。</p>
</li>
<li><p><code>struct rockchip_pin_group *groups</code>：指向瑞芯微芯片引脚组的指针。引脚组是一组相关的引脚，可以一起进行配置和管理。</p>
</li>
<li><p><code>unsigned int ngroups</code>：表示引脚组数组的大小，用于确定引脚组数组的长度。</p>
</li>
<li><p><code>struct rockchip_pmx_func *functions</code>：指向瑞芯微芯片引脚功能的指针。引脚功能定义了引脚可以承担的不同功能，例如 UART、SPI、I2C 等。</p>
</li>
<li><p><code>unsigned int nfunctions</code>：引脚功能的数量。它表示引脚功能数组的大小，用于确定<br>引脚功能数组的长度。</p>
</li>
</ul>
<h3 id="rockchip-pin-ctrl-结构体"><a href="#rockchip-pin-ctrl-结构体" class="headerlink" title="rockchip_pin_ctrl 结构体"></a>rockchip_pin_ctrl 结构体</h3><p>在<code>rockchip_pinctrl_probe</code>函数中通过<code>ctrl = rockchip_pinctrl_get_soc_data(info, pdev)</code>设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_ctrl</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span>	*<span class="title">pin_banks</span>;</span><span class="comment">// 引脚bank的数组指针</span></span><br><span class="line">	u32				nr_banks;<span class="comment">// pin_bank的数量</span></span><br><span class="line">	u32				nr_pins;<span class="comment">// 引脚的数量</span></span><br><span class="line">	<span class="type">char</span>				*label;<span class="comment">// 引脚控制器标签</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">rockchip_pinctrl_type</span>	<span class="title">type</span>;</span><span class="comment">// 引脚控制器的类型</span></span><br><span class="line">	<span class="type">int</span>				grf_mux_offset;<span class="comment">// GRF(Global Register File)复用寄存器的偏移量</span></span><br><span class="line">	<span class="type">int</span>				pmu_mux_offset;<span class="comment">// PMU(电源管理单元)复用寄存器的偏移量</span></span><br><span class="line">	<span class="type">int</span>				grf_drv_offset;<span class="comment">// GRF驱动寄存器的偏移量</span></span><br><span class="line">	<span class="type">int</span>				pmu_drv_offset;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_mux_recalced_data</span> *<span class="title">iomux_recalced</span>;</span></span><br><span class="line">	u32				niomux_recalced;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_mux_route_data</span> *<span class="title">iomux_routes</span>;</span></span><br><span class="line">	u32				niomux_routes;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>	(*pull_calc_reg)(<span class="keyword">struct</span> rockchip_pin_bank *bank,</span><br><span class="line">				 <span class="type">int</span> pin_num, <span class="keyword">struct</span> regmap **regmap,</span><br><span class="line">				 <span class="type">int</span> *reg, u8 *bit);</span><br><span class="line">	<span class="type">int</span>	(*drv_calc_reg)(<span class="keyword">struct</span> rockchip_pin_bank *bank,</span><br><span class="line">				<span class="type">int</span> pin_num, <span class="keyword">struct</span> regmap **regmap,</span><br><span class="line">				<span class="type">int</span> *reg, u8 *bit);</span><br><span class="line">	<span class="type">int</span>	(*schmitt_calc_reg)(<span class="keyword">struct</span> rockchip_pin_bank *bank,</span><br><span class="line">				    <span class="type">int</span> pin_num, <span class="keyword">struct</span> regmap **regmap,</span><br><span class="line">				    <span class="type">int</span> *reg, u8 *bit);</span><br><span class="line">	<span class="type">int</span>	(*slew_rate_calc_reg)(<span class="keyword">struct</span> rockchip_pin_bank *bank,</span><br><span class="line">				      <span class="type">int</span> pin_num, <span class="keyword">struct</span> regmap **regmap,</span><br><span class="line">				      <span class="type">int</span> *reg, u8 *bit);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="pinctrl-dev-结构体"><a href="#pinctrl-dev-结构体" class="headerlink" title="pinctrl_dev 结构体"></a>pinctrl_dev 结构体</h3><p>在<code>rockchip_pinctrl_probe</code>函数中通过<code>info-&gt;pctl_dev = devm_pinctrl_register(dev, ctrldesc, info)</code>设置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_dev - pin control class device</span></span><br><span class="line"><span class="comment"> * @node: node to include this pin controller in the global pin controller list</span></span><br><span class="line"><span class="comment"> * @desc: the pin controller descriptor supplied when initializing this pin</span></span><br><span class="line"><span class="comment"> *	controller</span></span><br><span class="line"><span class="comment"> * @pin_desc_tree: each pin descriptor for this pin controller is stored in</span></span><br><span class="line"><span class="comment"> *	this radix tree</span></span><br><span class="line"><span class="comment"> * @pin_group_tree: optionally each pin group can be stored in this radix tree</span></span><br><span class="line"><span class="comment"> * @num_groups: optionally number of groups can be kept here</span></span><br><span class="line"><span class="comment"> * @pin_function_tree: optionally each function can be stored in this radix tree</span></span><br><span class="line"><span class="comment"> * @num_functions: optionally number of functions can be kept here</span></span><br><span class="line"><span class="comment"> * @gpio_ranges: a list of GPIO ranges that is handled by this pin controller,</span></span><br><span class="line"><span class="comment"> *	ranges are added to this list at runtime</span></span><br><span class="line"><span class="comment"> * @dev: the device entry for this pin controller</span></span><br><span class="line"><span class="comment"> * @owner: module providing the pin controller, used for refcounting</span></span><br><span class="line"><span class="comment"> * @driver_data: driver data for drivers registering to the pin controller</span></span><br><span class="line"><span class="comment"> *	subsystem</span></span><br><span class="line"><span class="comment"> * @p: result of pinctrl_get() for this device</span></span><br><span class="line"><span class="comment"> * @hog_default: default state for pins hogged by this device</span></span><br><span class="line"><span class="comment"> * @hog_sleep: sleep state for pins hogged by this device</span></span><br><span class="line"><span class="comment"> * @mutex: mutex taken on each pin controller specific action</span></span><br><span class="line"><span class="comment"> * @device_root: debugfs root for this device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">// pinctrl_dev链表中的节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span> <span class="comment">// 引脚控制器描述指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_desc_tree</span>;</span><span class="comment">// 引脚描述结构体的radix树</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCTRL_GROUPS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_group_tree</span>;</span><span class="comment">// 引脚组结构体的radix树根</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_groups;<span class="comment">// 引脚组的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINMUX_FUNCTIONS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_function_tree</span>;</span><span class="comment">// 引脚功能结构体的radix树根</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_functions;<span class="comment">// 引脚功能的数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">gpio_ranges</span>;</span><span class="comment">// GPIO范围链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span><span class="comment">// 设备结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span><span class="comment">// 拥有pinctrl_dev结构体的模块的指针</span></span><br><span class="line">	<span class="type">void</span> *driver_data;<span class="comment">// 驱动程序的私有数据指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span><span class="comment">// pinctrl结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_default</span>;</span><span class="comment">// hog默认状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_sleep</span>;</span><span class="comment">// hog睡眠状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">device_root</span>;</span><span class="comment">// 调试文件系统的根节点</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="pinctrl子系统函数操作集"><a href="#pinctrl子系统函数操作集" class="headerlink" title="pinctrl子系统函数操作集"></a>pinctrl子系统函数操作集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span> <span class="comment">// 引脚控制操作函数指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>   <span class="comment">// 引脚复用操作函数指针</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span> <span class="comment">// 引脚配置操作函数指针</span></span><br></pre></td></tr></table></figure>



<h3 id="pinctrl-ops"><a href="#pinctrl-ops" class="headerlink" title="pinctrl_ops"></a>pinctrl_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_ops - global pin control operations, to be implemented by</span></span><br><span class="line"><span class="comment"> * pin controller drivers.</span></span><br><span class="line"><span class="comment"> * @get_groups_count: Returns the count of total number of groups registered.</span></span><br><span class="line"><span class="comment"> * @get_group_name: return the group name of the pin group</span></span><br><span class="line"><span class="comment"> * @get_group_pins: return an array of pins corresponding to a certain</span></span><br><span class="line"><span class="comment"> *	group selector @pins, and the size of the array in @num_pins</span></span><br><span class="line"><span class="comment"> * @pin_dbg_show: optional debugfs display hook that will provide per-device</span></span><br><span class="line"><span class="comment"> *	info for a certain pin in debugfs</span></span><br><span class="line"><span class="comment"> * @dt_node_to_map: parse a device tree &quot;pin configuration node&quot;, and create</span></span><br><span class="line"><span class="comment"> *	mapping table entries for it. These are returned through the @map and</span></span><br><span class="line"><span class="comment"> *	@num_maps output parameters. This function is optional, and may be</span></span><br><span class="line"><span class="comment"> *	omitted for pinctrl drivers that do not support device tree.</span></span><br><span class="line"><span class="comment"> * @dt_free_map: free mapping table entries created via @dt_node_to_map. The</span></span><br><span class="line"><span class="comment"> *	top-level @map pointer must be freed, along with any dynamically</span></span><br><span class="line"><span class="comment"> *	allocated members of the mapping table entries themselves. This</span></span><br><span class="line"><span class="comment"> *	function is optional, and may be omitted for pinctrl drivers that do</span></span><br><span class="line"><span class="comment"> *	not support device tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*get_groups_count) (<span class="keyword">struct</span> pinctrl_dev *pctldev);<span class="comment">//获取指定的 Pin Control 设备支持的引脚组数量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *(*get_group_name) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">				       <span class="type">unsigned</span> selector);<span class="comment">// 获取指定引脚组选择器对应的引脚组名称</span></span><br><span class="line">	<span class="type">int</span> (*get_group_pins) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">			       <span class="type">unsigned</span> selector,</span><br><span class="line">			       <span class="type">const</span> <span class="type">unsigned</span> **pins,</span><br><span class="line">			       <span class="type">unsigned</span> *num_pins);<span class="comment">// 获取指定引脚组选择器对应的引脚组中的引脚列表</span></span><br><span class="line">	<span class="type">void</span> (*pin_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">			  <span class="type">unsigned</span> offset);<span class="comment">//在调试信息中输出指定引脚选择器对应的引脚信息</span></span><br><span class="line">	<span class="type">int</span> (*dt_node_to_map) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">			       <span class="keyword">struct</span> device_node *np_config,</span><br><span class="line">			       <span class="keyword">struct</span> pinctrl_map **<span class="built_in">map</span>, <span class="type">unsigned</span> *num_maps);<span class="comment">// 根据给定的设备树节点，创建与之相关联的 Pin Control 映射</span></span><br><span class="line">	<span class="type">void</span> (*dt_free_map) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">			     <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>, <span class="type">unsigned</span> num_maps);<span class="comment">//释放之前通过 dt_node_to_map 创建的Pin Control 映射</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> <span class="title">rockchip_pctrl_ops</span> =</span> &#123;</span><br><span class="line">	.get_groups_count	= rockchip_get_groups_count,</span><br><span class="line">	.get_group_name		= rockchip_get_group_name,</span><br><span class="line">	.get_group_pins		= rockchip_get_group_pins,</span><br><span class="line">	.dt_node_to_map		= rockchip_dt_node_to_map,</span><br><span class="line">	.dt_free_map		= rockchip_dt_free_map,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="get-groups-count"><a href="#get-groups-count" class="headerlink" title="get_groups_count"></a><code>get_groups_count</code></h4><blockquote>
<p>获取引脚组的数量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_get_groups_count</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 pinctrl_dev 结构中获取私有数据指针，将其转换为 rockchip_pinctrl 结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line">	<span class="comment">// 返回 rockchip_pinctrl 结构中存储的引脚组数量</span></span><br><span class="line">	<span class="keyword">return</span> info-&gt;ngroups;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="get-group-name"><a href="#get-group-name" class="headerlink" title="get_group_name"></a><code>get_group_name</code></h4><blockquote>
<p>获取引脚组的名称。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">rockchip_get_group_name</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">							<span class="type">unsigned</span> selector)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 pinctrl_dev 结构中获取私有数据指针，将其转换为 rockchip_pinctrl 结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回指定引脚组的名称</span></span><br><span class="line">	<span class="keyword">return</span> info-&gt;groups[selector].name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="get-group-pins"><a href="#get-group-pins" class="headerlink" title="get_group_pins"></a><code>get_group_pins</code></h4><blockquote>
<p>获取引脚组的引脚列表。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_get_group_pins</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> selector, <span class="type">const</span> <span class="type">unsigned</span> **pins,</span></span><br><span class="line"><span class="params">				      <span class="type">unsigned</span> *npins)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 pinctrl_dev 结构中获取私有数据指针，将其转换为 rockchip_pinctrl 结构</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果选择器超出引脚组的范围，则返回错误码 -EINVAL</span></span><br><span class="line">	<span class="keyword">if</span> (selector &gt;= info-&gt;ngroups)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将指向引脚组的引脚数组的指针赋值给传入的 pins 指针</span></span><br><span class="line">	*pins = info-&gt;groups[selector].pins;</span><br><span class="line">    <span class="comment">// 将引脚组中的引脚数量赋值给传入的 npins 变量</span></span><br><span class="line">	*npins = info-&gt;groups[selector].npins;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="dt-node-to-map"><a href="#dt-node-to-map" class="headerlink" title="dt_node_to_map"></a><code>dt_node_to_map</code></h4><blockquote>
<p>根据设备树节点创建与之相关联的 Pin Control 映射。</p>
</blockquote>
<p>该结构体用于在引脚控制器中定义引脚的映射关系。通过映射类型的不同，可以将引脚与具 体 的 复 用 功 能 或 配 置 信 息 关 联 起 来 ， 从 而 实 现 引 脚 的 配 置 和 控 制 </p>
<h5 id="pinctrl-map-结构体"><a href="#pinctrl-map-结构体" class="headerlink" title="pinctrl_map 结构体"></a>pinctrl_map 结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/pinctrl/machine.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_map - boards/machines shall provide this map for devices</span></span><br><span class="line"><span class="comment"> * @dev_name: the name of the device using this specific mapping, the name</span></span><br><span class="line"><span class="comment"> *	must be the same as in your struct device*. If this name is set to the</span></span><br><span class="line"><span class="comment"> *	same name as the pin controllers own dev_name(), the map entry will be</span></span><br><span class="line"><span class="comment"> *	hogged by the driver itself upon registration</span></span><br><span class="line"><span class="comment"> * @name: the name of this specific map entry for the particular machine.</span></span><br><span class="line"><span class="comment"> *	This is the parameter passed to pinmux_lookup_state()</span></span><br><span class="line"><span class="comment"> * @type: the type of mapping table entry</span></span><br><span class="line"><span class="comment"> * @ctrl_dev_name: the name of the device controlling this specific mapping,</span></span><br><span class="line"><span class="comment"> *	the name must be the same as in your struct device*. This field is not</span></span><br><span class="line"><span class="comment"> *	used for PIN_MAP_TYPE_DUMMY_STATE</span></span><br><span class="line"><span class="comment"> * @data: Data specific to the mapping type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *dev_name;<span class="comment">// 设备名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 映射名称</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span><span class="comment">// 映射类型</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ctrl_dev_name;<span class="comment">// 控制设备名称</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> <span class="title">mux</span>;</span><span class="comment">// 复用映射数据</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> <span class="title">configs</span>;</span> <span class="comment">// 配置映射数据</span></span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_dt_node_to_map</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> pinctrl_map **<span class="built_in">map</span>, <span class="type">unsigned</span> *num_maps)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取引脚控制器的私有数据指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line">    <span class="comment">// 引脚组指针</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_group</span> *<span class="title">grp</span>;</span></span><br><span class="line">    <span class="comment">// 设备指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> info-&gt;dev;</span><br><span class="line">    <span class="comment">// 新的引脚映射数组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">new_map</span>;</span></span><br><span class="line">    <span class="comment">// 父节点指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">// 映射数量，默认为 1</span></span><br><span class="line">	<span class="type">int</span> map_num = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * first find the group of this node and check if we need to create</span></span><br><span class="line"><span class="comment">	 * config maps for pins</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/* 查找引脚组 */</span></span><br><span class="line">	grp = pinctrl_name_to_group(info, np-&gt;name);<span class="comment">// 根据节点名称查找对应的引脚组</span></span><br><span class="line">	<span class="keyword">if</span> (!grp) &#123;<span class="comment">// 如果找不到引脚组，打印错误信息</span></span><br><span class="line">		dev_err(dev, <span class="string">&quot;unable to find group for node %pOFn\n&quot;</span>, np);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	map_num += grp-&gt;npins;<span class="comment">// 计算映射数量，包括复用映射和配置映射</span></span><br><span class="line"></span><br><span class="line">	new_map = kcalloc(map_num, <span class="keyword">sizeof</span>(*new_map), GFP_KERNEL);<span class="comment">// 分配内存空间用于存储映射数组</span></span><br><span class="line">	<span class="keyword">if</span> (!new_map)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	*<span class="built_in">map</span> = new_map;<span class="comment">// 将分配的映射数组赋值给输出参数</span></span><br><span class="line">	*num_maps = map_num;<span class="comment">// 将映射数量赋值给输出参数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create mux map */</span></span><br><span class="line">    <span class="comment">/* 创建复用映射 */</span></span><br><span class="line">	parent = of_get_parent(np); <span class="comment">// 获取节点的父节点</span></span><br><span class="line">	<span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">		kfree(new_map);<span class="comment">// 如果父节点不存在，释放分配的映射数组内存空间</span></span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	new_map[<span class="number">0</span>].type = PIN_MAP_TYPE_MUX_GROUP;<span class="comment">// 设置映射类型为复用映射</span></span><br><span class="line">	new_map[<span class="number">0</span>].data.mux.function = parent-&gt;name;<span class="comment">// 复用功能名称为父节点的名称</span></span><br><span class="line">	new_map[<span class="number">0</span>].data.mux.group = np-&gt;name; <span class="comment">// 将设备节点的名称作为映射的组名</span></span><br><span class="line">	of_node_put(parent);<span class="comment">// 释放父节点的引用计数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create config map */</span></span><br><span class="line">    <span class="comment">/* 创建配置映射 */</span></span><br><span class="line">	new_map++;<span class="comment">// 映射数组指针向后移动一个位置</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; grp-&gt;npins; i++) &#123;</span><br><span class="line">		new_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;<span class="comment">// 设置映射类型为配置映射</span></span><br><span class="line">		new_map[i].data.configs.group_or_pin =</span><br><span class="line">				pin_get_name(pctldev, grp-&gt;pins[i]);<span class="comment">// 引脚组或引脚名称为引脚组中的引脚名称</span></span><br><span class="line">		new_map[i].data.configs.configs = grp-&gt;data[i].configs;<span class="comment">// 配置信息数组为引脚组中该引脚的配置信息</span></span><br><span class="line">		new_map[i].data.configs.num_configs = grp-&gt;data[i].nconfigs;<span class="comment">// 配置信息数量为引脚组中该引脚的配置数量</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 打印调试信息，显示创建的引脚映射的功能名称、组名和数量</span></span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;maps: function %s group %s num %d\n&quot;</span>,</span><br><span class="line">		(*<span class="built_in">map</span>)-&gt;data.mux.function, (*<span class="built_in">map</span>)-&gt;data.mux.group, map_num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rockchip_dt_node_to_map</code> 函数根据设备节点的信息创建引脚映射，包括复用映射和配置映射。</p>
<ul>
<li><strong>复用映射用于将引脚组的功能与父节点的功能关联起来</strong></li>
<li><strong>配置映射用于将引脚的配置信息与引脚的名称关联起来。</strong></li>
</ul>
<p>这些映射将用于配置引脚控制器，以确保引脚在系统中正确地配置和使用。这个函数在设备树解析过程中被调用，以便为每个设备节点创建相应的引脚映射。</p>
<h4 id="dt-free-map"><a href="#dt-free-map" class="headerlink" title="dt_free_map"></a><code>dt_free_map</code></h4><blockquote>
<p>释放通过 dt_node_to_map 创建的 Pin Control 映射。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rockchip_dt_free_map</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>, <span class="type">unsigned</span> num_maps)</span></span><br><span class="line">&#123;</span><br><span class="line">	kfree(<span class="built_in">map</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="pinmux-ops"><a href="#pinmux-ops" class="headerlink" title="pinmux_ops"></a>pinmux_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinmux_ops - pinmux operations, to be implemented by pin controller</span></span><br><span class="line"><span class="comment"> * drivers that support pinmuxing</span></span><br><span class="line"><span class="comment"> * @request: called by the core to see if a certain pin can be made</span></span><br><span class="line"><span class="comment"> *	available for muxing. This is called by the core to acquire the pins</span></span><br><span class="line"><span class="comment"> *	before selecting any actual mux setting across a function. The driver</span></span><br><span class="line"><span class="comment"> *	is allowed to answer &quot;no&quot; by returning a negative error code</span></span><br><span class="line"><span class="comment"> * @free: the reverse function of the request() callback, frees a pin after</span></span><br><span class="line"><span class="comment"> *	being requested</span></span><br><span class="line"><span class="comment"> * @get_functions_count: returns number of selectable named functions available</span></span><br><span class="line"><span class="comment"> *	in this pinmux driver</span></span><br><span class="line"><span class="comment"> * @get_function_name: return the function name of the muxing selector,</span></span><br><span class="line"><span class="comment"> *	called by the core to figure out which mux setting it shall map a</span></span><br><span class="line"><span class="comment"> *	certain device to</span></span><br><span class="line"><span class="comment"> * @get_function_groups: return an array of groups names (in turn</span></span><br><span class="line"><span class="comment"> *	referencing pins) connected to a certain function selector. The group</span></span><br><span class="line"><span class="comment"> *	name can be used with the generic @pinctrl_ops to retrieve the</span></span><br><span class="line"><span class="comment"> *	actual pins affected. The applicable groups will be returned in</span></span><br><span class="line"><span class="comment"> *	@groups and the number of groups in @num_groups</span></span><br><span class="line"><span class="comment"> * @set_mux: enable a certain muxing function with a certain pin group. The</span></span><br><span class="line"><span class="comment"> *	driver does not need to figure out whether enabling this function</span></span><br><span class="line"><span class="comment"> *	conflicts some other use of the pins in that group, such collisions</span></span><br><span class="line"><span class="comment"> *	are handled by the pinmux subsystem. The @func_selector selects a</span></span><br><span class="line"><span class="comment"> *	certain function whereas @group_selector selects a certain set of pins</span></span><br><span class="line"><span class="comment"> *	to be used. On simple controllers the latter argument may be ignored</span></span><br><span class="line"><span class="comment"> * @gpio_request_enable: requests and enables GPIO on a certain pin.</span></span><br><span class="line"><span class="comment"> *	Implement this only if you can mux every pin individually as GPIO. The</span></span><br><span class="line"><span class="comment"> *	affected GPIO range is passed along with an offset(pin number) into that</span></span><br><span class="line"><span class="comment"> *	specific GPIO range - function selectors and pin groups are orthogonal</span></span><br><span class="line"><span class="comment"> *	to this, the core will however make sure the pins do not collide.</span></span><br><span class="line"><span class="comment"> * @gpio_disable_free: free up GPIO muxing on a certain pin, the reverse of</span></span><br><span class="line"><span class="comment"> *	@gpio_request_enable</span></span><br><span class="line"><span class="comment"> * @gpio_set_direction: Since controllers may need different configurations</span></span><br><span class="line"><span class="comment"> *	depending on whether the GPIO is configured as input or output,</span></span><br><span class="line"><span class="comment"> *	a direction selector function may be implemented as a backing</span></span><br><span class="line"><span class="comment"> *	to the GPIO controllers that need pin muxing.</span></span><br><span class="line"><span class="comment"> * @strict: do not allow simultaneous use of the same pin for GPIO and another</span></span><br><span class="line"><span class="comment"> *	function. Check both gpio_owner and mux_owner strictly before approving</span></span><br><span class="line"><span class="comment"> *	the pin request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> &#123;</span></span><br><span class="line">    <span class="comment">// 查看是否可以将某个引脚设置为可用于复用</span></span><br><span class="line">	<span class="type">int</span> (*request) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="comment">// request() 回调的反向函数，在请求后释放引脚</span></span><br><span class="line">	<span class="type">int</span> (*<span class="built_in">free</span>) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="comment">// 返回此 Pinmux 驱动程序中可选择的命名函数数量</span></span><br><span class="line">	<span class="type">int</span> (*get_functions_count) (<span class="keyword">struct</span> pinctrl_dev *pctldev);</span><br><span class="line">    <span class="comment">// 返回复用选择器的函数名称，核心调用此函数来确定应将某个设备映射到哪个复用设置</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *(*get_function_name) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">					  <span class="type">unsigned</span> selector);</span><br><span class="line">    <span class="comment">// 返回与某个函数选择器相关联的一组组名称（依次引用引脚）</span></span><br><span class="line">	<span class="type">int</span> (*get_function_groups) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">				  <span class="type">unsigned</span> selector,</span><br><span class="line">				  <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> **groups,</span><br><span class="line">				  <span class="type">unsigned</span> *num_groups);</span><br><span class="line">    <span class="comment">// 使用特定引脚组启用特定复用功能</span></span><br><span class="line">	<span class="type">int</span> (*set_mux) (<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> func_selector,</span><br><span class="line">			<span class="type">unsigned</span> group_selector);</span><br><span class="line">    <span class="comment">// 在特定引脚上请求并启用 GPIO</span></span><br><span class="line">	<span class="type">int</span> (*gpio_request_enable) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">				    <span class="keyword">struct</span> pinctrl_gpio_range *range,</span><br><span class="line">				    <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="comment">// 在特定引脚上释放 GPIO 复用</span></span><br><span class="line">	<span class="type">void</span> (*gpio_disable_free) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">				   <span class="keyword">struct</span> pinctrl_gpio_range *range,</span><br><span class="line">				   <span class="type">unsigned</span> offset);</span><br><span class="line">    <span class="comment">// 根据 GPIO 配置为输入或输出而进行不同的配置</span></span><br><span class="line">	<span class="type">int</span> (*gpio_set_direction) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">				   <span class="keyword">struct</span> pinctrl_gpio_range *range,</span><br><span class="line">				   <span class="type">unsigned</span> offset,</span><br><span class="line">				   <span class="type">bool</span> input);</span><br><span class="line">    <span class="comment">// 不允许将同一引脚同时用于 GPIO 和其他功能。在批准引脚请求之前，严格检查 gpio_owner 和 mux_owner</span></span><br><span class="line">	<span class="type">bool</span> strict;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct pinmux_ops</code> 是一个用于描述引脚复用操作的结构体。它定义了一组函数指针，这些函数指针指向了引脚控制器驱动程序中实现的具体功能。通过实现这些函数，引脚控制器驱动程序可以与核心交互，并提供引脚复用的功能。核心可以通过调用这些函数来请求、释放引脚，设置复用功能，操作 GPIO 等。这个结构体的设计允许引脚控制器驱动程序根据具体的硬件需求和功能定义自己的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> <span class="title">rockchip_pmx_ops</span> =</span> &#123;</span><br><span class="line">	.get_functions_count	= rockchip_pmx_get_funcs_count,</span><br><span class="line">	.get_function_name	= rockchip_pmx_get_func_name,</span><br><span class="line">	.get_function_groups	= rockchip_pmx_get_groups,</span><br><span class="line">	.set_mux		= rockchip_pmx_set,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="get-functions-count"><a href="#get-functions-count" class="headerlink" title="get_functions_count"></a><code>get_functions_count</code></h4><blockquote>
<p>返回在该引脚控制器驱动程序中可选择的命名函数的数量。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pmx_get_funcs_count</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> info-&gt;nfunctions;<span class="comment">// 返回引脚复用功能的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="get-function-name"><a href="#get-function-name" class="headerlink" title="get_function_name"></a><code>get_function_name</code></h4><blockquote>
<p>返回复用选择器的函数名称</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">rockchip_pmx_get_func_name</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">					  <span class="type">unsigned</span> selector)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> info-&gt;functions[selector].name;<span class="comment">// 返回引脚复用功能的名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="get-function-groups"><a href="#get-function-groups" class="headerlink" title="get_function_groups"></a><code>get_function_groups</code></h4><blockquote>
<p>返回与某个函数选择器相关联的一组组名称（依次引用引脚）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pmx_get_groups</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> selector, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> **groups,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> * <span class="type">const</span> num_groups)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line"></span><br><span class="line">	*groups = info-&gt;functions[selector].groups;<span class="comment">// 返回引脚复用功能对应的引脚组数组</span></span><br><span class="line">	*num_groups = info-&gt;functions[selector].ngroups;<span class="comment">// 返回引脚组的数量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="set-mux"><a href="#set-mux" class="headerlink" title="set_mux"></a><code>set_mux</code></h4><blockquote>
<p>用于启用特定的复用功能。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pmx_set</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> selector,</span></span><br><span class="line"><span class="params">			    <span class="type">unsigned</span> group)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *pins = info-&gt;groups[group].pins;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_config</span> *<span class="title">data</span> =</span> info-&gt;groups[group].data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> info-&gt;dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">bank</span>;</span></span><br><span class="line">	<span class="type">int</span> cnt, ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;enable function %s group %s\n&quot;</span>,</span><br><span class="line">		info-&gt;functions[selector].name, info-&gt;groups[group].name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * for each pin in the pin group selected, program the corresponding</span></span><br><span class="line"><span class="comment">	 * pin function number in the config register.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 针对所选的引脚组中的每个引脚，将相应的引脚功能号码编程到配置寄存器中。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; info-&gt;groups[group].npins; cnt++) &#123;</span><br><span class="line">		bank = pin_to_bank(info, pins[cnt]);</span><br><span class="line">		ret = rockchip_set_mux(bank, pins[cnt] - bank-&gt;pin_base,</span><br><span class="line">				       data[cnt].func);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &amp;&amp; cnt) &#123;</span><br><span class="line">		<span class="comment">/* revert the already done pin settings */</span></span><br><span class="line">        <span class="comment">/* 恢复已经设置的引脚设置 */</span></span><br><span class="line">		<span class="keyword">for</span> (cnt--; cnt &gt;= <span class="number">0</span> &amp;&amp; !data[cnt].func; cnt--)</span><br><span class="line">			rockchip_set_mux(bank, pins[cnt] - bank-&gt;pin_base, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="pinconf-ops"><a href="#pinconf-ops" class="headerlink" title="pinconf_ops"></a>pinconf_ops</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinconf_ops - pin config operations, to be implemented by</span></span><br><span class="line"><span class="comment"> * pin configuration capable drivers.</span></span><br><span class="line"><span class="comment"> * @is_generic: for pin controllers that want to use the generic interface,</span></span><br><span class="line"><span class="comment"> *	this flag tells the framework that it&#x27;s generic.</span></span><br><span class="line"><span class="comment"> * @pin_config_get: get the config of a certain pin, if the requested config</span></span><br><span class="line"><span class="comment"> *	is not available on this controller this should return -ENOTSUPP</span></span><br><span class="line"><span class="comment"> *	and if it is available but disabled it should return -EINVAL</span></span><br><span class="line"><span class="comment"> * @pin_config_set: configure an individual pin</span></span><br><span class="line"><span class="comment"> * @pin_config_group_get: get configurations for an entire pin group; should</span></span><br><span class="line"><span class="comment"> *	return -ENOTSUPP and -EINVAL using the same rules as pin_config_get.</span></span><br><span class="line"><span class="comment"> * @pin_config_group_set: configure all pins in a group</span></span><br><span class="line"><span class="comment"> * @pin_config_dbg_show: optional debugfs display hook that will provide</span></span><br><span class="line"><span class="comment"> *	per-device info for a certain pin in debugfs</span></span><br><span class="line"><span class="comment"> * @pin_config_group_dbg_show: optional debugfs display hook that will provide</span></span><br><span class="line"><span class="comment"> *	per-device info for a certain group in debugfs</span></span><br><span class="line"><span class="comment"> * @pin_config_config_dbg_show: optional debugfs display hook that will decode</span></span><br><span class="line"><span class="comment"> *	and display a driver&#x27;s pin configuration parameter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">	<span class="type">bool</span> is_generic;<span class="comment">// 是否为通用引脚配置操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     <span class="comment">// 获取引脚配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_get) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">			       <span class="type">unsigned</span> pin,</span><br><span class="line">			       <span class="type">unsigned</span> <span class="type">long</span> *config);</span><br><span class="line">    <span class="comment">// 设置引脚配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_set) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">			       <span class="type">unsigned</span> pin,</span><br><span class="line">			       <span class="type">unsigned</span> <span class="type">long</span> *configs,</span><br><span class="line">			       <span class="type">unsigned</span> num_configs);</span><br><span class="line">    <span class="comment">// 获取引脚组配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_get) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">				     <span class="type">unsigned</span> selector,</span><br><span class="line">				     <span class="type">unsigned</span> <span class="type">long</span> *config);</span><br><span class="line">    <span class="comment">// 设置引脚组配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_set) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">				     <span class="type">unsigned</span> selector,</span><br><span class="line">				     <span class="type">unsigned</span> <span class="type">long</span> *configs,</span><br><span class="line">				     <span class="type">unsigned</span> num_configs);</span><br><span class="line">    <span class="comment">// 调试函数，显示引脚配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">				     <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">				     <span class="type">unsigned</span> offset);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 调试函数，显示引脚组配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_group_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">					   <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">					   <span class="type">unsigned</span> selector);</span><br><span class="line">    <span class="comment">// 调试函数，显示引脚配置的具体信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_config_dbg_show) (<span class="keyword">struct</span> pinctrl_dev *pctldev,</span><br><span class="line">					    <span class="keyword">struct</span> seq_file *s,</span><br><span class="line">					    <span class="type">unsigned</span> <span class="type">long</span> config);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结构体 pinconf_ops，用于<strong>定义引脚配置操作</strong>的函数指针。每个函数指针都对应了一个特定的操作，如获取引脚配置、设置引脚配置、获取引脚组配置等。这些函数在驱动程序中实现，用于对硬件引脚进行配置和控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> <span class="title">rockchip_pinconf_ops</span> =</span> &#123;</span><br><span class="line">	.pin_config_get			= rockchip_pinconf_get,<span class="comment">// 获取引脚配置的函数</span></span><br><span class="line">	.pin_config_set			= rockchip_pinconf_set,<span class="comment">// 设置引脚配置的函数</span></span><br><span class="line">	.is_generic			= <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="pin-config-get"><a href="#pin-config-get" class="headerlink" title="pin_config_get"></a><code>pin_config_get</code></h4><blockquote>
<p>获取引脚配置信息。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get the pin config settings for a specified pin */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinconf_get</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> <span class="type">int</span> pin,</span></span><br><span class="line"><span class="params">							<span class="type">unsigned</span> <span class="type">long</span> *config)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">bank</span> =</span> pin_to_bank(info, pin);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gpio</span> =</span> &amp;bank-&gt;gpio_chip;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">pin_config_param</span> <span class="title">param</span> =</span> pinconf_to_config_param(*config);</span><br><span class="line">	u16 arg;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (param) &#123;</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_BIAS_DISABLE:<span class="comment">// 检查上下拉电阻是否禁用</span></span><br><span class="line">		<span class="keyword">if</span> (rockchip_get_pull(bank, pin - bank-&gt;pin_base) != param)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		arg = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_UP:</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_DOWN:</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_BIAS_BUS_HOLD:<span class="comment">// 检查上下拉电阻是否有效，并获取当前的上下拉电阻配置</span></span><br><span class="line">		<span class="keyword">if</span> (!rockchip_pinconf_pull_valid(info-&gt;ctrl, param))</span><br><span class="line">			<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rockchip_get_pull(bank, pin - bank-&gt;pin_base) != param)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		arg = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_OUTPUT:<span class="comment">// 检查引脚是否配置为 GPIO 输出模式</span></span><br><span class="line">		rc = rockchip_get_mux(bank, pin - bank-&gt;pin_base);</span><br><span class="line">		<span class="keyword">if</span> (rc != RK_FUNC_GPIO)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!gpio || !gpio-&gt;get) &#123;</span><br><span class="line">			arg = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取引脚的输出状态</span></span><br><span class="line">		rc = gpio-&gt;get(gpio, pin - bank-&gt;pin_base);</span><br><span class="line">		<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">		arg = rc ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_DRIVE_STRENGTH:</span><br><span class="line">		<span class="comment">/* rk3288 is the first with per-pin drive-strength */</span></span><br><span class="line">        <span class="comment">// 仅支持某些芯片（如 rk3288）的每个引脚独立的驱动强度设置</span></span><br><span class="line">		<span class="keyword">if</span> (!info-&gt;ctrl-&gt;drv_calc_reg)</span><br><span class="line">			<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">		<span class="comment">// 获取引脚的驱动强度配置</span></span><br><span class="line">		rc = rockchip_get_drive_perpin(bank, pin - bank-&gt;pin_base);</span><br><span class="line">		<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">		arg = rc;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_INPUT_SCHMITT_ENABLE:</span><br><span class="line">        <span class="comment">// 仅支持某些芯片的施密特触发设置</span></span><br><span class="line">		<span class="keyword">if</span> (!info-&gt;ctrl-&gt;schmitt_calc_reg)</span><br><span class="line">			<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">		<span class="comment">// 获取引脚的施密特触发配置</span></span><br><span class="line">		rc = rockchip_get_schmitt(bank, pin - bank-&gt;pin_base);</span><br><span class="line">		<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">		arg = rc;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PIN_CONFIG_SLEW_RATE:</span><br><span class="line">        <span class="comment">// 仅支持某些芯片的引脚驱动速率设置</span></span><br><span class="line">		<span class="keyword">if</span> (!info-&gt;ctrl-&gt;slew_rate_calc_reg)</span><br><span class="line">			<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">		<span class="comment">// 获取引脚的驱动速率配置</span></span><br><span class="line">		rc = rockchip_get_slew_rate(bank, pin - bank-&gt;pin_base);</span><br><span class="line">		<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">		arg = rc;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:<span class="comment">// 不支持的配置参数</span></span><br><span class="line">		<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*config = pinconf_to_config_packed(param, arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="pin-config-set"><a href="#pin-config-set" class="headerlink" title="pin_config_set"></a><code>pin_config_set</code></h4><blockquote>
<p> 设置引脚配置信息。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set the pin config settings for a specified pin */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rockchip_pinconf_set</span><span class="params">(<span class="keyword">struct</span> pinctrl_dev *pctldev, <span class="type">unsigned</span> <span class="type">int</span> pin,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> *configs, <span class="type">unsigned</span> num_configs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pinctrl</span> *<span class="title">info</span> =</span> pinctrl_dev_get_drvdata(pctldev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rockchip_pin_bank</span> *<span class="title">bank</span> =</span> pin_to_bank(info, pin);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> *<span class="title">gpio</span> =</span> &amp;bank-&gt;gpio_chip;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">pin_config_param</span> <span class="title">param</span>;</span></span><br><span class="line">	u32 arg;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_configs; i++) &#123;</span><br><span class="line">		param = pinconf_to_config_param(configs[i]);</span><br><span class="line">		arg = pinconf_to_config_argument(configs[i]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (param == PIN_CONFIG_OUTPUT || param == PIN_CONFIG_INPUT_ENABLE) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Check for gpio driver not being probed yet.</span></span><br><span class="line"><span class="comment">			 * The lock makes sure that either gpio-probe has completed</span></span><br><span class="line"><span class="comment">			 * or the gpio driver hasn&#x27;t probed yet.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">			* 检查 GPIO 驱动程序是否已经探测到。</span></span><br><span class="line"><span class="comment">			* 锁定确保 GPIO 探测完成或者 GPIO 驱动程序尚未探测到。</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			mutex_lock(&amp;bank-&gt;deferred_lock);</span><br><span class="line">			<span class="keyword">if</span> (!gpio || !gpio-&gt;direction_output) &#123;</span><br><span class="line">                <span class="comment">// 如果驱动程序尚未探测到，则将配置信息延迟处理并返回。</span></span><br><span class="line">				rc = rockchip_pinconf_defer_pin(bank, pin - bank-&gt;pin_base, param,</span><br><span class="line">								arg);</span><br><span class="line">				mutex_unlock(&amp;bank-&gt;deferred_lock);</span><br><span class="line">				<span class="keyword">if</span> (rc)</span><br><span class="line">					<span class="keyword">return</span> rc;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mutex_unlock(&amp;bank-&gt;deferred_lock);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (param) &#123;</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_BIAS_DISABLE:</span><br><span class="line">            <span class="comment">// 禁用上下拉电阻</span></span><br><span class="line">			rc =  rockchip_set_pull(bank, pin - bank-&gt;pin_base,</span><br><span class="line">				param);</span><br><span class="line">			<span class="keyword">if</span> (rc)</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_UP:</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_DOWN:</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_BIAS_PULL_PIN_DEFAULT:</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_BIAS_BUS_HOLD:</span><br><span class="line">            <span class="comment">// 检查上下拉电阻是否有效</span></span><br><span class="line">			<span class="keyword">if</span> (!rockchip_pinconf_pull_valid(info-&gt;ctrl, param))</span><br><span class="line">				<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!arg)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			<span class="comment">// 设置上下拉电阻</span></span><br><span class="line">			rc = rockchip_set_pull(bank, pin - bank-&gt;pin_base,</span><br><span class="line">				param);</span><br><span class="line">			<span class="keyword">if</span> (rc)</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_OUTPUT:</span><br><span class="line">            <span class="comment">// 设置引脚复用功能为 GPIO</span></span><br><span class="line">			rc = rockchip_set_mux(bank, pin - bank-&gt;pin_base,</span><br><span class="line">					      RK_FUNC_GPIO);</span><br><span class="line">			<span class="keyword">if</span> (rc != RK_FUNC_GPIO)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			<span class="comment">// 设置引脚为输出模式</span></span><br><span class="line">			rc = gpio-&gt;direction_output(gpio, pin - bank-&gt;pin_base,</span><br><span class="line">						    arg);</span><br><span class="line">			<span class="keyword">if</span> (rc)</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_INPUT_ENABLE:</span><br><span class="line">            <span class="comment">// 设置引脚复用功能为 GPIO</span></span><br><span class="line">			rc = rockchip_set_mux(bank, pin - bank-&gt;pin_base,</span><br><span class="line">					      RK_FUNC_GPIO);</span><br><span class="line">			<span class="keyword">if</span> (rc != RK_FUNC_GPIO)</span><br><span class="line">				<span class="keyword">return</span> -EINVAL;</span><br><span class="line">			<span class="comment">// 设置引脚为输入模式</span></span><br><span class="line">			rc = gpio-&gt;direction_input(gpio, pin - bank-&gt;pin_base);</span><br><span class="line">			<span class="keyword">if</span> (rc)</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_DRIVE_STRENGTH:</span><br><span class="line">			<span class="comment">/* rk3288 is the first with per-pin drive-strength */</span></span><br><span class="line">            <span class="comment">// 仅支持某些芯片（如 rk3288）的每个引脚独立的驱动强度设置</span></span><br><span class="line">			<span class="keyword">if</span> (!info-&gt;ctrl-&gt;drv_calc_reg)</span><br><span class="line">				<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">			<span class="comment">// 设置引脚的驱动强度</span></span><br><span class="line">			rc = rockchip_set_drive_perpin(bank,</span><br><span class="line">						pin - bank-&gt;pin_base, arg);</span><br><span class="line">			<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_INPUT_SCHMITT_ENABLE:</span><br><span class="line">            <span class="comment">// 仅支持某些芯片的施密特触发设置</span></span><br><span class="line">			<span class="keyword">if</span> (!info-&gt;ctrl-&gt;schmitt_calc_reg)</span><br><span class="line">				<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">			<span class="comment">// 设置引脚的施密特触发模式</span></span><br><span class="line">			rc = rockchip_set_schmitt(bank,</span><br><span class="line">						  pin - bank-&gt;pin_base, arg);</span><br><span class="line">			<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_CONFIG_SLEW_RATE:</span><br><span class="line">            <span class="comment">// 仅支持某些芯片的引脚驱动速率设置</span></span><br><span class="line">			<span class="keyword">if</span> (!info-&gt;ctrl-&gt;slew_rate_calc_reg)</span><br><span class="line">				<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">			<span class="comment">// 设置引脚的驱动速率</span></span><br><span class="line">			rc = rockchip_set_slew_rate(bank,</span><br><span class="line">						    pin - bank-&gt;pin_base, arg);</span><br><span class="line">			<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="comment">// 不支持的配置参数</span></span><br><span class="line">			<span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="comment">/* for each config */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251216154950779.jpg" alt="pinctrl" loading="lazy"></p>
<h1 id="pinctrl-bind-pins"><a href="#pinctrl-bind-pins" class="headerlink" title="pinctrl_bind_pins()"></a>pinctrl_bind_pins()</h1><p><strong>引脚的复用关系是在什么时候被设置的？</strong></p>
<p>以 485 控制引脚的设备树节点和对应的 pinctrl 设备树节点进行举例，要添加的 485 设备树内容如下所示</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">	rk_485_ctl:</span> <span class="title class_">rk-485-ctl</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;topeet,rs485_ctl&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">22</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">		pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;rk_485_gpio</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line">	rk_485<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">		rk_485_gpio:</span><span class="title class_">rk-485-gpio</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3</span> <span class="number">13</span> RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="punctuation">&#125;;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当上面编写的 485 设备树跟驱动匹配成功之后，就会进入相应驱动中的 probe 函数，在probe 函数中就可以对设备树中描述的 485 使能引脚进行拉高和拉低的操作，从而控制 485 的接收和发送。</p>
<p>所以可以猜测在进入驱动的 probe 函数之前就已经使用 pinctrl 子系统对引脚进行了复用，在设备模型中，我们已经知道了驱动中的 probe 函数是在内核源码目录下的<code>drivers/base/dd.c</code>文件中加载执行的，然后找到 <code>really_probe</code> 函数中与 probe 函数加载相<br>关的代码，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">really_probe</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = -EPROBE_DEFER;</span><br><span class="line">	<span class="type">int</span> local_trigger_count = <span class="type">atomic_read</span>(&amp;deferred_trigger_count);</span><br><span class="line">	<span class="type">bool</span> test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &amp;&amp;</span><br><span class="line">			   !drv-&gt;suppress_bind_attrs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (defer_all_probes) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Value of defer_all_probes can be set only by</span></span><br><span class="line"><span class="comment">		 * device_block_probing() which, in turn, will call</span></span><br><span class="line"><span class="comment">		 * wait_for_device_probe() right after that to avoid any races.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Driver %s force probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		driver_deferred_probe_add(dev);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = device_links_check_suppliers(dev);</span><br><span class="line">	<span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line">		driver_deferred_probe_add_trigger(dev, local_trigger_count);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;probe_count);</span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: probing driver %s with device %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, drv-&gt;name, dev_name(dev));</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;dev-&gt;devres_head)) &#123;</span><br><span class="line">		dev_crit(dev, <span class="string">&quot;Resources present before probing\n&quot;</span>);</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">re_probe:</span><br><span class="line">	dev-&gt;driver = drv;<span class="comment">// 将设备的驱动程序指针设置为当前驱动</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">    <span class="comment">/* 如果使用了 pinctrl，在探测之前绑定引脚 */</span></span><br><span class="line">	ret = pinctrl_bind_pins(dev);<span class="comment">// 绑定设备的引脚</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> pinctrl_bind_failed;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;dma_configure) &#123;<span class="comment">// 配置 DMA</span></span><br><span class="line">		ret = dev-&gt;bus-&gt;dma_configure(dev);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = driver_sysfs_add(dev);<span class="comment">// 添加驱动程序的 sysfs 接口</span></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: driver_sysfs_add(%s) failed\n&quot;</span>,</span><br><span class="line">		       __func__, dev_name(dev));</span><br><span class="line">		<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;activate) &#123;</span><br><span class="line">		ret = dev-&gt;pm_domain-&gt;activate(dev);<span class="comment">// 激活电源管理域</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;probe) &#123;</span><br><span class="line">		ret = dev-&gt;bus-&gt;probe(dev);<span class="comment">// 如果总线的探测函数存在，则调用总线的探测函数</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;probe) &#123;</span><br><span class="line">		ret = drv-&gt;probe(dev);<span class="comment">// 否则调用驱动程序的探测函数</span></span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">goto</span> probe_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = device_add_groups(dev, drv-&gt;dev_groups);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;device_add_groups() failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> dev_groups_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev_has_sync_state(dev)) &#123;</span><br><span class="line">		ret = device_create_file(dev, &amp;dev_attr_state_synced);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(dev, <span class="string">&quot;state_synced sysfs add failed\n&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> dev_sysfs_state_synced_failed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (test_remove) &#123;</span><br><span class="line">		test_remove = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		device_remove_file(dev, &amp;dev_attr_state_synced);</span><br><span class="line">		device_remove_groups(dev, drv-&gt;dev_groups);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;bus-&gt;remove)<span class="comment">// 如果总线的移除函数存在，则调用总线的移除函数</span></span><br><span class="line">			dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)<span class="comment">// 否则调用驱动程序的移除函数</span></span><br><span class="line">			drv-&gt;remove(dev);</span><br><span class="line"></span><br><span class="line">		devres_release_all(dev);<span class="comment">// 释放设备资源</span></span><br><span class="line">		arch_teardown_dma_ops(dev);</span><br><span class="line">		kfree(dev-&gt;dma_range_map);</span><br><span class="line">		dev-&gt;dma_range_map = <span class="literal">NULL</span>;</span><br><span class="line">		driver_sysfs_remove(dev);<span class="comment">// 移除驱动程序的 sysfs 接口</span></span><br><span class="line">		dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">		dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">			dev-&gt;pm_domain-&gt;dismiss(dev);<span class="comment">// 解除电源管理域的激活状态</span></span><br><span class="line">		pm_runtime_reinit(dev);<span class="comment">// 重新初始化电源管理运行时</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> re_probe;<span class="comment">// 重新进行设备的探测</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pinctrl_init_done(dev);<span class="comment">// 完成引脚控制器的初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;sync)</span><br><span class="line">		dev-&gt;pm_domain-&gt;sync(dev);<span class="comment">// 同步电源管理域</span></span><br><span class="line"></span><br><span class="line">	driver_bound(dev);<span class="comment">// 驱动程序与设备绑定成功</span></span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line">	pr_debug(<span class="string">&quot;bus: &#x27;%s&#x27;: %s: bound device %s to driver %s\n&quot;</span>,</span><br><span class="line">		 drv-&gt;bus-&gt;name, __func__, dev_name(dev), drv-&gt;name);</span><br><span class="line">	<span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">dev_sysfs_state_synced_failed:</span><br><span class="line">	device_remove_groups(dev, drv-&gt;dev_groups);</span><br><span class="line">dev_groups_failed:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus-&gt;remove)</span><br><span class="line">		dev-&gt;bus-&gt;remove(dev);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (drv-&gt;remove)</span><br><span class="line">		drv-&gt;remove(dev);</span><br><span class="line">probe_failed:</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;bus)</span><br><span class="line">		blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,</span><br><span class="line">					     BUS_NOTIFY_DRIVER_NOT_BOUND, dev);</span><br><span class="line">pinctrl_bind_failed:</span><br><span class="line">	device_links_no_driver(dev);</span><br><span class="line">	devres_release_all(dev);</span><br><span class="line">	arch_teardown_dma_ops(dev);</span><br><span class="line">	kfree(dev-&gt;dma_range_map);</span><br><span class="line">	dev-&gt;dma_range_map = <span class="literal">NULL</span>;</span><br><span class="line">	driver_sysfs_remove(dev);</span><br><span class="line">	dev-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">	dev_set_drvdata(dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;pm_domain &amp;&amp; dev-&gt;pm_domain-&gt;dismiss)</span><br><span class="line">		dev-&gt;pm_domain-&gt;dismiss(dev);</span><br><span class="line">	pm_runtime_reinit(dev);</span><br><span class="line">	dev_pm_set_driver_flags(dev, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">	<span class="keyword">case</span> -EPROBE_DEFER:</span><br><span class="line">		<span class="comment">/* Driver requested deferred probing */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;Driver %s requests probe deferral\n&quot;</span>, drv-&gt;name);</span><br><span class="line">		driver_deferred_probe_add_trigger(dev, local_trigger_count);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> -ENODEV:</span><br><span class="line">	<span class="keyword">case</span> -ENXIO:</span><br><span class="line">		pr_debug(<span class="string">&quot;%s: probe of %s rejects match %d\n&quot;</span>,</span><br><span class="line">			 drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">/* driver matched but the probe failed */</span></span><br><span class="line">		pr_warn(<span class="string">&quot;%s: probe of %s failed with error %d\n&quot;</span>,</span><br><span class="line">			drv-&gt;name, dev_name(dev), ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ignore errors returned by -&gt;probe so that the next driver can try</span></span><br><span class="line"><span class="comment">	 * its luck.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line">done:<span class="comment">// 执行完成后的处理逻辑</span></span><br><span class="line">	<span class="type">atomic_dec</span>(&amp;probe_count);</span><br><span class="line">	wake_up_all(&amp;probe_waitqueue);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用了 pinctrl 就会调用第 39 行的 <code>pinctrl_bind_pins()</code>函数进行设备引脚的绑定，然后根据线索跳转到 <code>pinctrl_bind_pins</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/base/pinctrl.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_bind_pins() - called by the device core before probe</span></span><br><span class="line"><span class="comment"> * @dev: the device that is just about to probe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_bind_pins</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="comment">// 检查设备是否重用了节点</span></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;of_node_reused)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 为设备的引脚分配内存空间</span></span><br><span class="line">	dev-&gt;pins = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*(dev-&gt;pins)), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!dev-&gt;pins)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取设备的 pinctrl 句柄</span></span><br><span class="line">	dev-&gt;pins-&gt;p = devm_pinctrl_get(dev);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;p)) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no pinctrl handle\n&quot;</span>);</span><br><span class="line">		ret = PTR_ERR(dev-&gt;pins-&gt;p);</span><br><span class="line">		<span class="keyword">goto</span> cleanup_alloc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找设备的默认 pinctrl 状态</span></span><br><span class="line">	dev-&gt;pins-&gt;default_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					PINCTRL_STATE_DEFAULT);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;default_state)) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no default pinctrl state\n&quot;</span>);</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> cleanup_get;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找设备的初始化 pinctrl 状态</span></span><br><span class="line">	dev-&gt;pins-&gt;init_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					PINCTRL_STATE_INIT);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;init_state)) &#123;</span><br><span class="line">		<span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        <span class="comment">/* 不提供此状态是完全合法的 */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no init pinctrl state\n&quot;</span>);</span><br><span class="line">		<span class="comment">// 选择默认的 pinctrl 状态</span></span><br><span class="line">		ret = pinctrl_select_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					   dev-&gt;pins-&gt;default_state);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 选择初始化的 pinctrl 状态</span></span><br><span class="line">		ret = pinctrl_select_state(dev-&gt;pins-&gt;p, dev-&gt;pins-&gt;init_state);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;failed to activate initial pinctrl state\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> cleanup_get;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If power management is enabled, we also look for the optional</span></span><br><span class="line"><span class="comment">	 * sleep and idle pin states, with semantics as defined in</span></span><br><span class="line"><span class="comment">	 * &lt;linux/pinctrl/pinctrl-state.h&gt;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 如果启用了电源管理，我们还会寻找可选的睡眠和空闲的引脚状态，其语义在</span></span><br><span class="line"><span class="comment">	* &lt;linux/pinctrl/pinctrl-state.h&gt; 中定义</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	dev-&gt;pins-&gt;sleep_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					PINCTRL_STATE_SLEEP);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;sleep_state))</span><br><span class="line">		<span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        <span class="comment">/* 不提供此状态是完全合法的 */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no sleep pinctrl state\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	dev-&gt;pins-&gt;idle_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,</span><br><span class="line">					PINCTRL_STATE_IDLE);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;pins-&gt;idle_state))</span><br><span class="line">		<span class="comment">/* Not supplying this state is perfectly legal */</span></span><br><span class="line">        <span class="comment">/* 不提供此状态是完全合法的 */</span></span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;no idle pinctrl state\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If no pinctrl handle or default state was found for this device,</span></span><br><span class="line"><span class="comment">	 * let&#x27;s explicitly free the pin container in the device, there is</span></span><br><span class="line"><span class="comment">	 * no point in keeping it around.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/* 如果对于此设备没有找到 pinctrl 句柄或默认状态，</span></span><br><span class="line"><span class="comment">	* 让我们明确释放设备中的引脚容器，因为保留它没有意义。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">cleanup_get:</span><br><span class="line">	devm_pinctrl_put(dev-&gt;pins-&gt;p);</span><br><span class="line">cleanup_alloc:</span><br><span class="line">	devm_kfree(dev, dev-&gt;pins);</span><br><span class="line">	dev-&gt;pins = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Return deferrals */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == -EPROBE_DEFER)<span class="comment">/* 返回延迟 */</span></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">/* Return serious errors */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == -EINVAL)<span class="comment">/* 返回严重错误 */</span></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="comment">/* We ignore errors like -ENOENT meaning no pinctrl state */</span></span><br><span class="line">	<span class="comment">/* 我们忽略诸如 -ENOENT 的错误，表示没有 pinctrl 状态 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于<code>struct device</code>结构体:</p>
<p>其中含有<code>struct dev_pin_info	*pins;</code>成员表示该设备的引脚信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span><span class="comment">// 内核对象，用于设备的管理</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span><span class="comment">// 指向父设备的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_private</span>	*<span class="title">p</span>;</span><span class="comment">// 私有数据指针</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*init_name; <span class="comment">/* initial name of the device */</span> <span class="comment">// 设备的初始名称</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_type</span> *<span class="title">type</span>;</span><span class="comment">// 设备类型</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span>	*<span class="title">bus</span>;</span>		<span class="comment">/* type of bus device is on */</span> <span class="comment">// 设备所在的总线类型</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> *<span class="title">driver</span>;</span>	<span class="comment">/* which driver has allocated this</span></span><br><span class="line"><span class="comment">					   device */</span> <span class="comment">// 分配该设备的驱动程序</span></span><br><span class="line">	<span class="type">void</span>		*platform_data;	<span class="comment">/* Platform specific data, device</span></span><br><span class="line"><span class="comment">					   core doesn&#x27;t touch it */</span> <span class="comment">// 平台特定的数据，设备核心不会修改它</span></span><br><span class="line">	<span class="type">void</span>		*driver_data;	<span class="comment">/* Driver data, set and get with</span></span><br><span class="line"><span class="comment">					   dev_set_drvdata/dev_get_drvdata */</span> <span class="comment">// 驱动程序的数据，使用 dev_set/get_drvdata 来设置和获取</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROVE_LOCKING</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">lockdep_mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>	<span class="comment">/* mutex to synchronize calls to* its driver.*/</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_links_info</span>	<span class="title">links</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_info</span>	<span class="title">power</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_domain</span>	*<span class="title">pm_domain</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ENERGY_MODEL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">em_perf_domain</span>	*<span class="title">em_pd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_MSI_IRQ_DOMAIN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">msi_domain</span>;</span> <span class="comment">// 设备的通用 MSI IRQ 域</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PINCTRL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span>	*<span class="title">pins</span>;</span><span class="comment">// 设备的引脚信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>



<h2 id="struct-dev-pin-info-结构体"><a href="#struct-dev-pin-info-结构体" class="headerlink" title="struct dev_pin_info 结构体"></a>struct dev_pin_info 结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct dev_pin_info - pin state container for devices</span></span><br><span class="line"><span class="comment"> * @p: pinctrl handle for the containing device</span></span><br><span class="line"><span class="comment"> * @default_state: the default state for the handle, if found</span></span><br><span class="line"><span class="comment"> * @init_state: the state at probe time, if found</span></span><br><span class="line"><span class="comment"> * @sleep_state: the state at suspend time, if found</span></span><br><span class="line"><span class="comment"> * @idle_state: the state at idle (runtime suspend) time, if found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span>                 <span class="comment">// 引脚控制器指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span><span class="comment">// 默认状态指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span><span class="comment">// 初始化状态指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">sleep_state</span>;</span><span class="comment">// 睡眠状态指针 仅在支持电源管理时可用</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">idle_state</span>;</span><span class="comment">// 空闲状态指针 仅在支持电源管理时可用</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>struct pinctrl *p</code>：引脚控制器指针。该指针指向设备所使用的引脚控制器对象，用于对设备的引脚进行控制和配置。</p>
</li>
<li><p><code>struct pinctrl_state *default_state</code>：默认状态指针。该指针指向设备的默认引脚配置状态，表示设备在正常操作时的引脚配置。</p>
</li>
<li><p><code>struct pinctrl_state *init_state</code>：初始化状态指针。该指针指向设备的初始化引脚配置状态，表示设备在初始化阶段的引脚配置。</p>
</li>
<li><p><code>struct pinctrl_state *sleep_state</code>：睡眠状态指针（仅在支持电源管理时可用）。该指针指向设备的引脚配置状态，表示设备在进入睡眠状态时的引脚配置。</p>
</li>
<li><p><code>struct pinctrl_state *idle_state</code>：空闲状态指针（仅在支持电源管理时可用）。该指针指向设备的引脚配置状态，表示设备在空闲状态时的引脚配置。</p>
</li>
</ul>
<p>仍以485控制引脚为例</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">	rk_485_ctl:</span> <span class="title class_">rk-485-ctl</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;topeet,rs485_ctl&quot;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">gpios</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio0</span> <span class="number">22</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">		pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;rk_485_gpio</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">&amp;pinctrl</span> <span class="punctuation">&#123;</span></span><br><span class="line">	rk_485<span class="punctuation">&#123;</span></span><br><span class="line"><span class="symbol">		rk_485_gpio:</span><span class="title class_">rk-485-gpio</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">rockchip,pins</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3</span> <span class="number">13</span> RK_FUNC_GPIO <span class="variable">&amp;pcfg_pull_none</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">		<span class="punctuation">&#125;;</span></span><br><span class="line">	<span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>其中第 4 行的 pinctrl-names 属性指定了设备所使用的引脚控制器为 default，即第 5 行的 pinctrl-0，而 pinctrl-0 的值为 pinctrl 节点中的 rk_485_gpio，所以 <code>struct pinctrl_state *default_state</code> 这一默认状态结构体指针会用来存放 11 行的引脚复用信息，而在上一章节中也提到了设备树中的 pinctrl 节点会转换为 pinctrl_map 结构体，那么 <code>struct pinctrl_state *default_state</code> 必然会跟 <code>pinctrl_map</code> 结构体建立联系。</p>
<h2 id="devm-pinctrl-get"><a href="#devm-pinctrl-get" class="headerlink" title="devm_pinctrl_get()"></a>devm_pinctrl_get()</h2><p><code>pinctrl_bind_pins()</code>函数中通过<code>	dev-&gt;pins-&gt;p = devm_pinctrl_get(dev);</code>来获取设备的pinctrl句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * devm_pinctrl_get() - Resource managed pinctrl_get()</span></span><br><span class="line"><span class="comment"> * @dev: the device to obtain the handle for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If there is a need to explicitly destroy the returned struct pinctrl,</span></span><br><span class="line"><span class="comment"> * devm_pinctrl_put() should be used, rather than plain pinctrl_put().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl *<span class="title function_">devm_pinctrl_get</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> **<span class="title">ptr</span>, *<span class="title">p</span>;</span></span><br><span class="line">	<span class="comment">// 为存储引脚控制器句柄的指针分配内存</span></span><br><span class="line">	ptr = devres_alloc(devm_pinctrl_release, <span class="keyword">sizeof</span>(*ptr), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ptr)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 获取设备的引脚控制器句柄</span></span><br><span class="line">	p = pinctrl_get(dev);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">        <span class="comment">// 如果获取成功，将引脚控制器句柄存储在指针中</span></span><br><span class="line">		*ptr = p;</span><br><span class="line">        <span class="comment">// 将指针添加到设备资源中</span></span><br><span class="line">		devres_add(dev, ptr);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果获取失败，释放之前分配的指针内存</span></span><br><span class="line">		devres_free(ptr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(devm_pinctrl_get);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见通过pinctrl_get获取引脚控制器句柄</p>
<h3 id="pinctrl-get"><a href="#pinctrl-get" class="headerlink" title="pinctrl_get()"></a>pinctrl_get()</h3><p><code>devm_pinctrl_get()</code>函数中通过<code>pinctrl_get()</code>函数获取引脚控制器句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_get() - retrieves the pinctrl handle for a device</span></span><br><span class="line"><span class="comment"> * @dev: the device to obtain the handle for</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl *<span class="title function_">pinctrl_get</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="comment">// 检查设备指针是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!dev))</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * See if somebody else (such as the device core) has already</span></span><br><span class="line"><span class="comment">	 * obtained a handle to the pinctrl for this device. In that case,</span></span><br><span class="line"><span class="comment">	 * return another pointer to it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 查看是否有其他组件（如设备核心）已经获取了此设备的引脚控制器句柄。</span></span><br><span class="line"><span class="comment">	* 在这种情况下，返回对该句柄的另一个指针。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	p = find_pinctrl(dev);</span><br><span class="line">	<span class="keyword">if</span> (p) &#123;</span><br><span class="line">		dev_dbg(dev, <span class="string">&quot;obtain a copy of previously claimed pinctrl\n&quot;</span>);</span><br><span class="line">		kref_get(&amp;p-&gt;users);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建并返回设备的引脚控制器句柄</span></span><br><span class="line">	<span class="keyword">return</span> create_pinctrl(dev, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_get);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在返回值中使用 <code>create_pinctrl</code> 函数，该函数会创建并返回设备的引脚控制器句柄</p>
<h3 id="create-pinctrl"><a href="#create-pinctrl" class="headerlink" title="create_pinctrl()"></a>create_pinctrl()</h3><p><code>pinctrl_get()</code>最后调用<code>create_pinctrl()</code>创建并返回设备的引脚控制器句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pinctrl *<span class="title function_">create_pinctrl</span><span class="params">(<span class="keyword">struct</span> device *dev,</span></span><br><span class="line"><span class="params">				      <span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *devname;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> *<span class="title">maps_node</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * create the state cookie holder struct pinctrl for each</span></span><br><span class="line"><span class="comment">	 * mapping, this is what consumers will get when requesting</span></span><br><span class="line"><span class="comment">	 * a pin control handle with pinctrl_get()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 为每个映射创建状态 cookie 持有者 struct pinctrl。</span></span><br><span class="line"><span class="comment">	* 这是当使用 pinctrl_get() 请求引脚控制句柄时消费者将获得的对象。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	p-&gt;dev = dev;</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;states);</span><br><span class="line">	INIT_LIST_HEAD(&amp;p-&gt;dt_maps);</span><br><span class="line"></span><br><span class="line">	ret = pinctrl_dt_to_map(p, pctldev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(p);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	devname = dev_name(dev);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line">	<span class="comment">/* Iterate over the pin control maps to locate the right ones */</span></span><br><span class="line">    <span class="comment">/* 遍历引脚控制映射以定位正确的映射 */</span></span><br><span class="line">	for_each_maps(maps_node, i, <span class="built_in">map</span>) &#123;</span><br><span class="line">		<span class="comment">/* Map must be for this device */</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;dev_name, devname))<span class="comment">/* 映射必须适用于此设备 */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If pctldev is not null, we are claiming hog for it,</span></span><br><span class="line"><span class="comment">		 * that means, setting that is served by pctldev by itself.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Thus we must skip map that is for this device but is served</span></span><br><span class="line"><span class="comment">		 * by other device.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 如果 pctldev 不为空，我们正在声明它的独占使用权，</span></span><br><span class="line"><span class="comment">		* 这意味着它自己提供了该设置。</span></span><br><span class="line"><span class="comment">		*</span></span><br><span class="line"><span class="comment">		* 因此，我们必须跳过适用于此设备但由其他设备提供的映射。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (pctldev &amp;&amp;</span><br><span class="line">		    <span class="built_in">strcmp</span>(dev_name(pctldev-&gt;dev), <span class="built_in">map</span>-&gt;ctrl_dev_name))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		ret = add_setting(p, pctldev, <span class="built_in">map</span>);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * At this point the adding of a setting may:</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * - Defer, if the pinctrl device is not yet available</span></span><br><span class="line"><span class="comment">		 * - Fail, if the pinctrl device is not yet available,</span></span><br><span class="line"><span class="comment">		 *   AND the setting is a hog. We cannot defer that, since</span></span><br><span class="line"><span class="comment">		 *   the hog will kick in immediately after the device</span></span><br><span class="line"><span class="comment">		 *   is registered.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * If the error returned was not -EPROBE_DEFER then we</span></span><br><span class="line"><span class="comment">		 * accumulate the errors to see if we end up with</span></span><br><span class="line"><span class="comment">		 * an -EPROBE_DEFER later, as that is the worst case.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 在这一点上，添加设置可能会导致：</span></span><br><span class="line"><span class="comment">		*</span></span><br><span class="line"><span class="comment">		* - 延迟，如果引脚控制设备尚不可用</span></span><br><span class="line"><span class="comment">		* - 失败，如果引脚控制设备尚不可用，</span></span><br><span class="line"><span class="comment">		* 并且该设置是一个独占设置。我们不能推迟它，因为</span></span><br><span class="line"><span class="comment">		* 该独占设置会在设备注册后立即生效。</span></span><br><span class="line"><span class="comment">		*</span></span><br><span class="line"><span class="comment">		* 如果返回的错误不是 -EPROBE_DEFER，则我们将</span></span><br><span class="line"><span class="comment">		* 累积错误，以查看是否最终得到 -EPROBE_DEFER，</span></span><br><span class="line"><span class="comment">		* 因为那是最糟糕的情况。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (ret == -EPROBE_DEFER) &#123;</span><br><span class="line">			pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">			mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line">			<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* If some other error than deferral occurred, return here */</span></span><br><span class="line">        <span class="comment">/* 如果发生了除推迟以外的其他错误，则在此处返回 */</span></span><br><span class="line">		pinctrl_free(p, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kref_init(&amp;p-&gt;users);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add the pinctrl handle to the global list */</span></span><br><span class="line">    <span class="comment">/* 将引脚控制句柄添加到全局列表 */</span></span><br><span class="line">	mutex_lock(&amp;pinctrl_list_mutex);</span><br><span class="line">	list_add_tail(&amp;p-&gt;node, &amp;pinctrl_list);</span><br><span class="line">	mutex_unlock(&amp;pinctrl_list_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三个重要结构体：</p>
<ul>
<li><code>struct pinctrl</code></li>
<li><code>struct pinctrl_maps</code></li>
<li><code>struct pinctrl_map</code></li>
</ul>
<p><code>for_each_maps</code>定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义：用于遍历映射表链表中的每个映射表条目</span></span><br><span class="line"><span class="comment">// _maps_node_: 遍历时使用的映射表节点指针</span></span><br><span class="line"><span class="comment">// _i_: 遍历时使用的计数器变量</span></span><br><span class="line"><span class="comment">// _map_: 遍历时使用的映射表条目指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_maps(_maps_node_, _i_, _map_) \</span></span><br><span class="line"><span class="meta">	list_for_each_entry(_maps_node_, &amp;pinctrl_maps, node) \ <span class="comment">// 遍历映射表链表中的每个节点</span></span></span><br><span class="line">		<span class="keyword">for</span> (_i_ = <span class="number">0</span>, _map_ = &amp;_maps_node_-&gt;maps[_i_]; \ <span class="comment">// 初始化计数器和映射表条目指针</span></span><br><span class="line">			_i_ &lt; _maps_node_-&gt;num_maps; \ <span class="comment">// 循环条件：计数器小于当前节点的映射表数量</span></span><br><span class="line">			_i_++, _map_ = &amp;_maps_node_-&gt;maps[_i_]) <span class="comment">// 每次循环增加计数器并更新映射表条目指针</span></span><br></pre></td></tr></table></figure>



<h4 id="pinctrl-结构体"><a href="#pinctrl-结构体" class="headerlink" title="pinctrl 结构体"></a>pinctrl 结构体</h4><p><code>struct pinctrl</code> 结构体用于表示引脚控制器。</p>
<p>引脚控制器是硬件系统中管理和控制引脚（GPIO）的组件，它负责配置引脚的功能、电气属性等，该结构体定义在内核源码目录下的<code>drivers/pinctrl/core.h</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl - per-device pin control state holder</span></span><br><span class="line"><span class="comment"> * @node: global list node</span></span><br><span class="line"><span class="comment"> * @dev: the device using this pin control handle</span></span><br><span class="line"><span class="comment"> * @states: a list of states for this device</span></span><br><span class="line"><span class="comment"> * @state: the current state</span></span><br><span class="line"><span class="comment"> * @dt_maps: the mapping table chunks dynamically parsed from device tree for</span></span><br><span class="line"><span class="comment"> *	this device, if any</span></span><br><span class="line"><span class="comment"> * @users: reference count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>		<span class="comment">// 用于将引脚控制器添加到全局列表的链表节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>			<span class="comment">// 关联的设备</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span> 	<span class="comment">// 存储引脚配置状态的链表，用于跟踪不同的引脚配置状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span><span class="comment">// 当前应用的引脚配置状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span>	<span class="comment">// 存储设备树中定义的引脚映射信息的链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">users</span>;</span>			<span class="comment">// 引脚控制器的引用计数，用于跟踪引脚控制器的引用数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="pinctrl-maps-结构体"><a href="#pinctrl-maps-结构体" class="headerlink" title="pinctrl_maps 结构体"></a>pinctrl_maps 结构体</h4><p><code>struct pinctrl_maps</code> 类型的变量 maps_node 用于遍历引脚控制映射，引脚控制器映射描述了不同引脚控制器的功能和配置与实际硬件引脚之间的对应关系，该结构体定义在内核源码目录下的<code>drivers/pinctrl/core.h</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_maps - a list item containing part of the mapping table</span></span><br><span class="line"><span class="comment"> * @node: mapping table list node</span></span><br><span class="line"><span class="comment"> * @maps: array of mapping table entries</span></span><br><span class="line"><span class="comment"> * @num_maps: the number of entries in @maps</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> 			<span class="comment">// 引脚控制器映射链表节点，用于将该映射添加到全局列表</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">maps</span>;</span>	<span class="comment">// 指向引脚控制器映射数组的指针</span></span><br><span class="line">	<span class="type">unsigned</span> num_maps;				<span class="comment">// 引脚控制器映射数组中的映射数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>pinctrl_map</code>结构体在<code>dt_node_to_map</code>中创建</p>
<h4 id="pinctrl-dt-to-map"><a href="#pinctrl-dt-to-map" class="headerlink" title="pinctrl_dt_to_map()"></a>pinctrl_dt_to_map()</h4><p><code>create_pinctrl()</code>中通过调用 <code>pinctrl_dt_to_map</code> 函数将设备树中定义的引脚映射信息转换为 <code>struct pinctrl_map</code> 结构，并将其添加到 <code>p-&gt;dt_maps</code> 链表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/devicetree.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_dt_to_map</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> p-&gt;dev-&gt;of_node;<span class="comment">// 获取引脚控制器关联设备的设备树节点</span></span><br><span class="line">	<span class="type">int</span> state, ret;</span><br><span class="line">	<span class="type">char</span> *propname;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *statename;</span><br><span class="line">	<span class="type">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line">	<span class="type">int</span> size, config;</span><br><span class="line">	phandle phandle;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_config</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CONFIG_OF enabled, p-&gt;dev not instantiated from DT */</span></span><br><span class="line">    <span class="comment">/* 如果 CONFIG_OF 启用，且 p-&gt;dev 不是从设备树实例化而来 */</span></span><br><span class="line">	<span class="keyword">if</span> (!np) &#123;</span><br><span class="line">		<span class="keyword">if</span> (of_have_populated_dt())</span><br><span class="line">			dev_dbg(p-&gt;dev,</span><br><span class="line">				<span class="string">&quot;no of_node; not parsing pinctrl DT\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We may store pointers to property names within the node */</span></span><br><span class="line">    <span class="comment">/* 节点内部存储属性名称的指针 */</span></span><br><span class="line">	of_node_get(np);<span class="comment">//增加设备树节点的引用计数，以确保在解析过程中节点不会被释放</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For each defined state ID */</span></span><br><span class="line">    <span class="comment">/* 对于每个定义的状态 ID */</span></span><br><span class="line">	<span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line">		<span class="comment">/* Retrieve the pinctrl-* property */</span></span><br><span class="line">        <span class="comment">/* 获取 pinctrl-* 属性 */</span></span><br><span class="line">		propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line">		<span class="keyword">if</span> (!propname)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">		kfree(propname);</span><br><span class="line">		<span class="keyword">if</span> (!prop) &#123;</span><br><span class="line">			<span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">				of_node_put(np);</span><br><span class="line">				<span class="keyword">return</span> -ENODEV;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">list</span> = prop-&gt;value;</span><br><span class="line">		size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Determine whether pinctrl-names property names the state */</span></span><br><span class="line">        <span class="comment">/* 判断 pinctrl-names 属性是否命名了该状态 */</span></span><br><span class="line">		ret = of_property_read_string_index(np, <span class="string">&quot;pinctrl-names&quot;</span>,</span><br><span class="line">						    state, &amp;statename);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If not, statename is just the integer state ID. But rather</span></span><br><span class="line"><span class="comment">		 * than dynamically allocate it and have to free it later,</span></span><br><span class="line"><span class="comment">		 * just point part way into the property name for the string.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 如果未命名，则 statename 仅是整数状态 ID。但是，为了避免动态分配和之后要释放的麻烦，</span></span><br><span class="line"><span class="comment">		* 可以直接将 statename 指向属性名称的一部分。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			statename = prop-&gt;name + <span class="built_in">strlen</span>(<span class="string">&quot;pinctrl-&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* For every referenced pin configuration node in it */</span></span><br><span class="line">        <span class="comment">/* 对于其中的每个引用的引脚配置节点 */</span></span><br><span class="line">		<span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123;</span><br><span class="line">			phandle = be32_to_cpup(<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Look up the pin configuration node */</span></span><br><span class="line">            <span class="comment">/* 查找引脚配置节点 */</span></span><br><span class="line">			np_config = of_find_node_by_phandle(phandle);</span><br><span class="line">			<span class="keyword">if</span> (!np_config) &#123;</span><br><span class="line">				dev_err(p-&gt;dev,</span><br><span class="line">					<span class="string">&quot;prop %s index %i invalid phandle\n&quot;</span>,</span><br><span class="line">					prop-&gt;name, config);</span><br><span class="line">				ret = -EINVAL;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Parse the node */</span></span><br><span class="line">            <span class="comment">/* 解析节点 */</span></span><br><span class="line">			ret = dt_to_map_one_config(p, pctldev, statename,</span><br><span class="line">						   np_config);</span><br><span class="line">			of_node_put(np_config);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No entries in DT? Generate a dummy state table entry */</span></span><br><span class="line">        <span class="comment">/* 如果在设备树中没有条目，则生成一个虚拟状态表条目 */</span></span><br><span class="line">		<span class="keyword">if</span> (!size) &#123;</span><br><span class="line">			ret = dt_remember_dummy_state(p, statename);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	pinctrl_dt_free_maps(p);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于每个定义的状态 ID，循环解析引脚控制器的映射信息具体会执行以下步骤：</p>
<ul>
<li>构造属性名称字符串 propname，例如 “pinctrl-0”、”pinctrl-1” 等等。</li>
<li>使用 <code>of_find_property</code> 函数获取设备树节点 np 中的属性 propname 的值，并得到属性值的大小 size。如果属性不存在，则判断是否是第一个状态 ID，如果是，则释放节点引用并返回 -ENODEV 表示设备树节点中没有有效的 pinctrl 描述。否则，跳出循环。</li>
<li>将属性值转换为指针列表 list，并计算列表的大小。</li>
<li>如果设备树中的 pinctrl-names 属性命名了该状态，则使用 <code>of_property_read_string_index</code> 函数读取属性值，并将状态名称存储在 statename 变量中。否则，将 statename 指向属性名称的一部分，即去除 “pinctrl-“ 前缀。</li>
<li>对于每个引用的引脚配置节点，执行以下步骤：<ul>
<li>将 list 指针指向的 phandle 值转换为本地字节序。</li>
<li>使用 <code>of_find_node_by_phandle</code> 函数根据 phandle 查找引脚配置节点，并将其存储在 np_config 变量中。如果找不到引脚配置节点，则打印错误信息并返回 -EINVAL。</li>
<li>调用 <code>dt_to_map_one_config</code> 函数，将引脚配置节点的信息解析为 pinctrl 映射，并存储在 pctldev 中。</li>
<li>递减引脚配置节点的引用计数。</li>
<li>如果在设备树中没有条目，则生成一个虚拟状态表条目，以便后续处理。</li>
</ul>
</li>
</ul>
<p>其中<code>dt_to_map_one_config</code> 函数需要特别注意，该函数会从设备树节点中解析出引脚控制器的映射表，并将其存储起来，该函数的具体内容如下所示:</p>
<h5 id="dt-to-map-one-config"><a href="#dt-to-map-one-config" class="headerlink" title="dt_to_map_one_config()"></a>dt_to_map_one_config()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dt_to_map_one_config</span><span class="params">(<span class="keyword">struct</span> pinctrl *p,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> pinctrl_dev *hog_pctldev,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">char</span> *statename,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> device_node *np_config)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_pctldev</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> num_maps;</span><br><span class="line">	<span class="type">bool</span> allow_default = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find the pin controller containing np_config */</span></span><br><span class="line">    <span class="comment">/* 查找包含 np_config 的引脚控制器 */</span></span><br><span class="line">	np_pctldev = of_node_get(np_config);</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">/* 如果不允许默认配置，则读取 pinctrl-use-default 属性 */</span></span><br><span class="line">		<span class="keyword">if</span> (!allow_default)</span><br><span class="line">			allow_default = of_property_read_bool(np_pctldev,</span><br><span class="line">							      <span class="string">&quot;pinctrl-use-default&quot;</span>);</span><br><span class="line">		<span class="comment">/* 获取 np_pctldev 的父节点 */</span></span><br><span class="line">		np_pctldev = of_get_next_parent(np_pctldev);</span><br><span class="line">        <span class="comment">/* 如果没有父节点或者父节点是根节点，则释放 np_pctldev 引用并返回 */</span></span><br><span class="line">		<span class="keyword">if</span> (!np_pctldev || of_node_is_root(np_pctldev)) &#123;</span><br><span class="line">			of_node_put(np_pctldev);</span><br><span class="line">            <span class="comment">/* 检查是否延迟探测驱动程序状态 */</span></span><br><span class="line">			ret = driver_deferred_probe_check_state(p-&gt;dev);</span><br><span class="line">			<span class="comment">/* keep deferring if modules are enabled */</span></span><br><span class="line">            <span class="comment">/* 如果启用了模块并且不允许默认配置，并且返回值是 -ENODEV，则延迟探测 */</span></span><br><span class="line">			<span class="keyword">if</span> (IS_ENABLED(CONFIG_MODULES) &amp;&amp; !allow_default &amp;&amp; ret &lt; <span class="number">0</span>)</span><br><span class="line">				ret = -EPROBE_DEFER;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* If we&#x27;re creating a hog we can use the passed pctldev */</span></span><br><span class="line">        <span class="comment">/* 如果正在创建一个 hog，可以使用传递的 pctldev */</span></span><br><span class="line">		<span class="keyword">if</span> (hog_pctldev &amp;&amp; (np_pctldev == p-&gt;dev-&gt;of_node)) &#123;</span><br><span class="line">			pctldev = hog_pctldev;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* 通过 np_pctldev 获取 pinctrl_dev 结构体 */</span></span><br><span class="line">		pctldev = get_pinctrl_dev_from_of_node(np_pctldev);</span><br><span class="line">        <span class="comment">/* 如果获取到了 pinctrl_dev 结构体，则跳出循环 */</span></span><br><span class="line">		<span class="keyword">if</span> (pctldev)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/* Do not defer probing of hogs (circular loop) */</span></span><br><span class="line">        <span class="comment">/* 不要推迟探测 hogs（循环） */</span></span><br><span class="line">		<span class="keyword">if</span> (np_pctldev == p-&gt;dev-&gt;of_node) &#123;</span><br><span class="line">			of_node_put(np_pctldev);</span><br><span class="line">			<span class="keyword">return</span> -ENODEV;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	of_node_put(np_pctldev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Call pinctrl driver to parse device tree node, and</span></span><br><span class="line"><span class="comment">	 * generate mapping table entries</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 调用 pinctrl 驱动程序解析设备树节点，并生成映射表条目</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	ops = pctldev-&gt;desc-&gt;pctlops;</span><br><span class="line">    <span class="comment">/* 检查 pinctrl 驱动程序是否支持设备树, 即是否实现了 dt_node_to_map 方法。如果不支持，返回错误码。 */</span></span><br><span class="line">	<span class="keyword">if</span> (!ops-&gt;dt_node_to_map) &#123;</span><br><span class="line">		dev_err(p-&gt;dev, <span class="string">&quot;pctldev %s doesn&#x27;t support DT\n&quot;</span>,</span><br><span class="line">			dev_name(pctldev-&gt;dev));</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* 调用 pinctrl 驱动程序的 dt_node_to_map 方法 */</span></span><br><span class="line">	ret = ops-&gt;dt_node_to_map(pctldev, np_config, &amp;<span class="built_in">map</span>, &amp;num_maps);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (num_maps == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If we have no valid maps (maybe caused by empty pinctrl node</span></span><br><span class="line"><span class="comment">		 * or typing error) ther is no need remember this, so just</span></span><br><span class="line"><span class="comment">		 * return.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev_info(p-&gt;dev,</span><br><span class="line">			 <span class="string">&quot;there is not valid maps for state %s\n&quot;</span>, statename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stash the mapping table chunk away for later use */</span></span><br><span class="line">    <span class="comment">/* 将映射表块存储起来以供后续使用 */</span></span><br><span class="line">	<span class="keyword">return</span> dt_remember_or_free_map(p, statename, pctldev, <span class="built_in">map</span>, num_maps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第70行调用引脚控制器的 <code>dt_node_to_map</code> 方法，将设备树节点 np_config 转换为映射表条目。该方法会解析设备树节点，并根据节点信息生成映射表条目。具体的转换过程由各个pinctrl的驱动程序实现。</p>
<h5 id="dt-remember-or-free-map"><a href="#dt-remember-or-free-map" class="headerlink" title="dt_remember_or_free_map()"></a>dt_remember_or_free_map()</h5><p> <code>dt_to_map_one_config</code> 函数用于从设备树节点中解析出引脚控制器的映射表并存储起来，而存储的操作由函数 <code>dt_remember_or_free_map</code> 完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dt_remember_or_free_map</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="type">const</span> <span class="type">char</span> *statename,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>, <span class="type">unsigned</span> num_maps)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dt_map</span> *<span class="title">dt_map</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Initialize common mapping table entry fields */</span></span><br><span class="line">    <span class="comment">// 循环遍历映射表条目数组，为每个条目初始化公共字段 </span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_maps; i++) &#123;</span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *devname;</span><br><span class="line">		<span class="comment">// 通过 kstrdup_const 函数复制引脚控制器设备的名称，并将返回的指针赋值给 devname</span></span><br><span class="line">		devname = kstrdup_const(dev_name(p-&gt;dev), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!devname)</span><br><span class="line">			<span class="keyword">goto</span> err_free_map;</span><br><span class="line">		<span class="comment">// 设置映射表条目的设备名称、状态名称和控制器设备名称 </span></span><br><span class="line">		<span class="built_in">map</span>[i].dev_name = devname;</span><br><span class="line">		<span class="built_in">map</span>[i].name = statename;</span><br><span class="line">		<span class="keyword">if</span> (pctldev)</span><br><span class="line">			<span class="built_in">map</span>[i].ctrl_dev_name = dev_name(pctldev-&gt;dev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Remember the converted mapping table entries */</span></span><br><span class="line">    <span class="comment">/* 记录转换后的映射表条目 */</span></span><br><span class="line">	dt_map = kzalloc(<span class="keyword">sizeof</span>(*dt_map), GFP_KERNEL);<span class="comment">//使用 kzalloc 分配内存空间，并将返回的指针赋值给 dt_map</span></span><br><span class="line">	<span class="keyword">if</span> (!dt_map)</span><br><span class="line">		<span class="keyword">goto</span> err_free_map;</span><br><span class="line">	<span class="comment">// 将传入的 pctldev、map 和 num_maps 分别赋值给 dt_map 的对应字段</span></span><br><span class="line">	dt_map-&gt;pctldev = pctldev;</span><br><span class="line">	dt_map-&gt;<span class="built_in">map</span> = <span class="built_in">map</span>;</span><br><span class="line">	dt_map-&gt;num_maps = num_maps;</span><br><span class="line">	list_add_tail(&amp;dt_map-&gt;node, &amp;p-&gt;dt_maps);<span class="comment">// 使用 list_add_tail 函数将 dt_map 添加到 p-&gt;dt_maps 链表中</span></span><br><span class="line">	<span class="comment">/* 注册映射表条目 */</span></span><br><span class="line">	<span class="keyword">return</span> pinctrl_register_mappings(<span class="built_in">map</span>, num_maps);</span><br><span class="line"></span><br><span class="line">err_free_map:</span><br><span class="line">    <span class="comment">/* 释放映射表条目内存 */</span></span><br><span class="line">	dt_free_map(pctldev, <span class="built_in">map</span>, num_maps);</span><br><span class="line">	<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数传递参数：</p>
<ul>
<li><strong>p</strong>：指向 <code>struct pinctrl</code> 结构体的指针，表示引脚控制器的上下文。</li>
<li><strong>statename</strong>：指向状态名称的指针，表示要设置的状态的名称。</li>
<li><strong>pctldev</strong>：指向 <code>struct pinctrl_dev</code> 结构体的指针，表示引脚控制器设备。</li>
<li><strong>map</strong>：指向 <code>struct pinctrl_map</code> 结构体数组的指针，表示解析得到的映射表条目。</li>
<li><strong>num_maps</strong>：表示映射表条目的数量</li>
</ul>
<h5 id="pinctrl-dt-map-结构体"><a href="#pinctrl-dt-map-结构体" class="headerlink" title="pinctrl_dt_map 结构体"></a>pinctrl_dt_map 结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dt_map</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">//用于将映射表结构体添加到 pinctrl 的 dt_maps 链表中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span><span class="comment">// 引脚控制器设备</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> *<span class="title">map</span>;</span><span class="comment">// 映射表条目数组</span></span><br><span class="line">	<span class="type">unsigned</span> num_maps;<span class="comment">//映射表条目数量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="pinctrl-register-mappings"><a href="#pinctrl-register-mappings" class="headerlink" title="pinctrl_register_mappings()"></a>pinctrl_register_mappings()</h5><p><code>dt_remember_or_free_map()</code>最后用 <code>pinctrl_register_mappings()</code> 函数注册映射表条目。该函数将映射表条目注册到 pinctrl 子系统，以便后续可以通过相关接口进行引脚配置和管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_register_mappings() - register a set of pin controller mappings</span></span><br><span class="line"><span class="comment"> * @maps: the pincontrol mappings table to register. Note the pinctrl-core</span></span><br><span class="line"><span class="comment"> *	keeps a reference to the passed in maps, so they should _not_ be</span></span><br><span class="line"><span class="comment"> *	marked with __initdata.</span></span><br><span class="line"><span class="comment"> * @num_maps: the number of maps in the mapping table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// maps 指向映射表条目数组的指针</span></span><br><span class="line"><span class="comment">// num_maps 映射表条目数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_register_mappings</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *maps,</span></span><br><span class="line"><span class="params">			      <span class="type">unsigned</span> num_maps)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_maps</span> *<span class="title">maps_node</span>;</span></span><br><span class="line"></span><br><span class="line">	pr_debug(<span class="string">&quot;add %u pinctrl maps\n&quot;</span>, num_maps);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* First sanity check the new mapping */</span></span><br><span class="line">    <span class="comment">/* 首先对新映射表进行合法性检查 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_maps; i++) &#123;</span><br><span class="line">        <span class="comment">// 检查设备名称是否存在</span></span><br><span class="line">		<span class="keyword">if</span> (!maps[i].dev_name) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;failed to register map %s (%d): no device given\n&quot;</span>,</span><br><span class="line">			       maps[i].name, i);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 检查映射表名称是否存在</span></span><br><span class="line">		<span class="keyword">if</span> (!maps[i].name) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;failed to register map %d: no map name given\n&quot;</span>,</span><br><span class="line">			       i);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 对于引脚映射类型和配置映射类型，检查引脚控制设备名称是否存在</span></span><br><span class="line">		<span class="keyword">if</span> (maps[i].type != PIN_MAP_TYPE_DUMMY_STATE &amp;&amp;</span><br><span class="line">				!maps[i].ctrl_dev_name) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;failed to register map %s (%d): no pin control device given\n&quot;</span>,</span><br><span class="line">			       maps[i].name, i);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (maps[i].type) &#123;</span><br><span class="line">		<span class="keyword">case</span> PIN_MAP_TYPE_DUMMY_STATE:<span class="comment">// 对于虚拟状态映射类型，不进行验证</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:<span class="comment">// 对于复用组映射类型，进行引脚复用映射验证</span></span><br><span class="line">			ret = pinmux_validate_map(&amp;maps[i], i);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> ret;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">		<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<span class="comment">// 对于配置映射类型，进行引脚配置映射验证</span></span><br><span class="line">			ret = pinconf_validate_map(&amp;maps[i], i);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> ret;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:<span class="comment">// 对于无效的映射类型，返回错误</span></span><br><span class="line">			pr_err(<span class="string">&quot;failed to register map %s (%d): invalid type given\n&quot;</span>,</span><br><span class="line">			       maps[i].name, i);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分配映射表节点内存</span></span><br><span class="line">	maps_node = kzalloc(<span class="keyword">sizeof</span>(*maps_node), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!maps_node)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">// 设置映射表节点的映射表和映射表数量</span></span><br><span class="line">	maps_node-&gt;maps = maps;</span><br><span class="line">	maps_node-&gt;num_maps = num_maps;</span><br><span class="line">	<span class="comment">// 加锁并将映射表节点插入映射表链表末尾</span></span><br><span class="line">	mutex_lock(&amp;pinctrl_maps_mutex);</span><br><span class="line">	list_add_tail(&amp;maps_node-&gt;node, &amp;pinctrl_maps);</span><br><span class="line">	mutex_unlock(&amp;pinctrl_maps_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_register_mappings);</span><br></pre></td></tr></table></figure>

<p>可见<code>pinctrl_register_mappings</code> 函数的作用是注册一个引脚控制器的映射表<code>pinctrl_maps</code>，进行了一些参数合法性检查和验证，并将映射表节点插入到映射表链表中。</p>
<h4 id="add-setting"><a href="#add-setting" class="headerlink" title="add_setting()"></a>add_setting()</h4><p><code>create_pinctrl</code>函数中，通过 <code>ret = add_setting(p, pctldev, map);</code>将映射添加到引脚控制器中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_setting</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_dev *pctldev,</span></span><br><span class="line"><span class="params">		       <span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span><span class="comment">// pinctrl_state对象指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> *<span class="title">setting</span>;</span><span class="comment">// pinctrl_setting对象指针</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 查找pinctrl_state，如果不存在则创建新的pinctrl_state</span></span><br><span class="line">	state = find_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (!state)</span><br><span class="line">		state = create_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(state))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(state);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果映射类型为虚拟状态映射类型，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;type == PIN_MAP_TYPE_DUMMY_STATE)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 分配pinctrl_setting的内存空间</span></span><br><span class="line">	setting = kzalloc(<span class="keyword">sizeof</span>(*setting), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!setting)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	setting-&gt;type = <span class="built_in">map</span>-&gt;type;<span class="comment">// 设置pinctrl_setting的映射类型</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pctldev)<span class="comment">// 设置pinctrl_setting的引脚控制设备</span></span><br><span class="line">		setting-&gt;pctldev = pctldev;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		setting-&gt;pctldev =</span><br><span class="line">			get_pinctrl_dev_from_devname(<span class="built_in">map</span>-&gt;ctrl_dev_name);</span><br><span class="line">	<span class="keyword">if</span> (!setting-&gt;pctldev) &#123;</span><br><span class="line">		kfree(setting);</span><br><span class="line">		<span class="comment">/* Do not defer probing of hogs (circular loop) */</span></span><br><span class="line">        <span class="comment">// 如果引脚控制设备不存在，返回错误</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(<span class="built_in">map</span>-&gt;ctrl_dev_name, <span class="built_in">map</span>-&gt;dev_name))</span><br><span class="line">			<span class="keyword">return</span> -ENODEV;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * OK let us guess that the driver is not there yet, and</span></span><br><span class="line"><span class="comment">		 * let&#x27;s defer obtaining this pinctrl handle to later...</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		dev_info(p-&gt;dev, <span class="string">&quot;unknown pinctrl device %s in map entry, deferring probe&quot;</span>,</span><br><span class="line">			<span class="built_in">map</span>-&gt;ctrl_dev_name);</span><br><span class="line">		<span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置pinctrl_setting的设备名称</span></span><br><span class="line">	setting-&gt;dev_name = <span class="built_in">map</span>-&gt;dev_name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (<span class="built_in">map</span>-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">        <span class="comment">// 对于复用组映射类型，执行pinctrl_map到pinctrl_setting的转换</span></span><br><span class="line">		ret = pinmux_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">	<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">        <span class="comment">// 对于配置映射类型，执行pinctrl_map到pinctrl_setting的转换</span></span><br><span class="line">		ret = pinconf_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(setting);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将pinctrl_setting插入状态对象的设置链表末尾</span></span><br><span class="line">	list_add_tail(&amp;setting-&gt;node, &amp;state-&gt;settings);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到：</p>
<ul>
<li><p>对于复用组映射类型（<strong>PIN_MAP_TYPE_MUX_GROUP</strong>），调用 <code>pinmux_map_to_setting</code> 函数执行引脚复用映射到设置对象的转换。</p>
</li>
<li><p>对于配置映射类型（<strong>PIN_MAP_TYPE_CONFIGS_PIN</strong> 或 <strong>PIN_MAP_TYPE_CONFIGS_GROUP</strong>），调用 <code>pinconf_map_to_setting</code> 函数执行引脚配置映射到设置对象的转换。</p>
</li>
</ul>
<p>add_setting 函数的最终目的就是将传入的 <code>const struct pinctrl_map *map</code> 的参数值传入到 <code>struct pinctrl_setting</code> 类型的变量中，从而进一步提取 pinctrl_map 结构体类型变量中的内容。</p>
<h5 id="pinctrl-state-结构体"><a href="#pinctrl-state-结构体" class="headerlink" title="pinctrl_state 结构体"></a>pinctrl_state 结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_state - a pinctrl state for a device</span></span><br><span class="line"><span class="comment"> * @node: list node for struct pinctrl&#x27;s @states field</span></span><br><span class="line"><span class="comment"> * @name: the name of this state</span></span><br><span class="line"><span class="comment"> * @settings: a list of settings for this state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span><span class="comment">// 链表节点，用于将状态对象连接到引脚控制器对象的状态链表</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">// 状态对象的名称字符串指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span><span class="comment">// pinctrl_setting对象链表，包含该状态的所有设置对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="pinctrl-setting-结构体"><a href="#pinctrl-setting-结构体" class="headerlink" title="pinctrl_setting 结构体"></a>pinctrl_setting 结构体</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/core.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct pinctrl_setting - an individual mux or config setting</span></span><br><span class="line"><span class="comment"> * @node: list node for struct pinctrl_settings&#x27;s @settings field</span></span><br><span class="line"><span class="comment"> * @type: the type of setting</span></span><br><span class="line"><span class="comment"> * @pctldev: pin control device handling to be programmed. Not used for</span></span><br><span class="line"><span class="comment"> *   PIN_MAP_TYPE_DUMMY_STATE.</span></span><br><span class="line"><span class="comment"> * @dev_name: the name of the device using this state</span></span><br><span class="line"><span class="comment"> * @data: Data specific to the setting type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span> <span class="comment">// 链表节点，用于将设置对象连接到状态对象的设置链表</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span> <span class="comment">// 映射类型，表示设置对象的类型</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span> <span class="comment">// 引脚控制设备对象指针</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *dev_name; <span class="comment">// 设备名称字符串指针</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> <span class="title">mux</span>;</span> <span class="comment">// 复用组映射类型的数据结构</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_configs</span> <span class="title">configs</span>;</span> <span class="comment">// 配置映射类型的数据结构</span></span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="create-state"><a href="#create-state" class="headerlink" title="create_state()"></a>create_state()</h5><p><code>add_setting()</code>函数中，根据映射表条目的名称，使用 <code>find_state()</code> 函数在引脚控制器对象中查找对应的状态对象，在此之前我们并没有设置状态对象，所以会进入到第二个 if 判断，通过<code>state = create_state(p, map-&gt;name)</code>创建一个state</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> pinctrl_state *<span class="title function_">create_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p,</span></span><br><span class="line"><span class="params">					  <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span></span><br><span class="line">	<span class="comment">// 为 pinctrl_state 结构体分配内存</span></span><br><span class="line">	state = kzalloc(<span class="keyword">sizeof</span>(*state), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!state)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">	<span class="comment">// 设置状态的名称</span></span><br><span class="line">	state-&gt;name = name;</span><br><span class="line">    <span class="comment">// 初始化状态的设置列表</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;state-&gt;settings);</span><br><span class="line">	<span class="comment">// 将状态添加到 pinctrl 的状态链表中</span></span><br><span class="line">	list_add_tail(&amp;state-&gt;node, &amp;p-&gt;states);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="pinmux-map-to-setting"><a href="#pinmux-map-to-setting" class="headerlink" title="pinmux_map_to_setting()"></a>pinmux_map_to_setting()</h5><p><code>add_setting()</code>函数中对于复用组映射类型（<strong>PIN_MAP_TYPE_MUX_GROUP</strong>），调用 <code>pinmux_map_to_setting</code> 函数执行引脚复用映射到设置对象的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/pinmux.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinmux_map_to_setting</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> pinctrl_setting *setting)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;<span class="comment">// 获取引脚控制设备指针</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span> =</span> pctldev-&gt;desc-&gt;pmxops;<span class="comment">// 获取引脚复用操作指针</span></span><br><span class="line">	<span class="type">char</span> <span class="type">const</span> * <span class="type">const</span> *groups; <span class="comment">// 引脚复用组数组</span></span><br><span class="line">	<span class="type">unsigned</span> num_groups; <span class="comment">// 引脚复用组数量</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *group; <span class="comment">// 引脚复用组名称</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pmxops) &#123;<span class="comment">// 检查引脚控制设备是否支持引脚复用操作</span></span><br><span class="line">		dev_err(pctldev-&gt;dev, <span class="string">&quot;does not support mux function\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将映射表中的复用函数名称转换为复用函数的选择器，并将其保存在设置对象的 data.mux.func 字段中</span></span><br><span class="line">	ret = pinmux_func_name_to_selector(pctldev, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pctldev-&gt;dev, <span class="string">&quot;invalid function %s in map table\n&quot;</span>,</span><br><span class="line">			<span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	setting-&gt;data.mux.func = ret;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 通过调用引脚复用操作对象的 get_function_groups 函数查询复用函数对应的复用组信息，</span></span><br><span class="line">    <span class="comment">// 获取复用组的名称数组和数量，并将它们保存在 groups 和 num_groups 变量中。</span></span><br><span class="line">	ret = pmxops-&gt;get_function_groups(pctldev, setting-&gt;data.mux.func,</span><br><span class="line">					  &amp;groups, &amp;num_groups);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pctldev-&gt;dev, <span class="string">&quot;can&#x27;t query groups for function %s\n&quot;</span>,</span><br><span class="line">			<span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!num_groups) &#123;</span><br><span class="line">		dev_err(pctldev-&gt;dev,</span><br><span class="line">			<span class="string">&quot;function %s can&#x27;t be selected on any group\n&quot;</span>,</span><br><span class="line">			<span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">map</span>-&gt;data.mux.group) &#123;<span class="comment">// 根据映射表中指定的复用组名称或者选择第一个复用组名称，并在复用组数组中查找对应的索引</span></span><br><span class="line">		group = <span class="built_in">map</span>-&gt;data.mux.group;</span><br><span class="line">		ret = match_string(groups, num_groups, group);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			dev_err(pctldev-&gt;dev,</span><br><span class="line">				<span class="string">&quot;invalid group \&quot;%s\&quot; for function \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">				group, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		group = groups[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通过调用引脚控制设备对象的 pinctrl_get_group_selector </span></span><br><span class="line">    <span class="comment">// 函数获取复用组的选择器，并将它保存在设置对象的 data.mux.group</span></span><br><span class="line">	ret = pinctrl_get_group_selector(pctldev, group);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(pctldev-&gt;dev, <span class="string">&quot;invalid group %s in map table\n&quot;</span>,</span><br><span class="line">			<span class="built_in">map</span>-&gt;data.mux.group);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	setting-&gt;data.mux.group = ret;<span class="comment">// 设置设置对象的复用组选择器</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="pinconf-map-to-setting"><a href="#pinconf-map-to-setting" class="headerlink" title="pinconf_map_to_setting()"></a>pinconf_map_to_setting()</h5><p><code>add_settings</code>函数中对于配置映射类型（<strong>PIN_MAP_TYPE_CONFIGS_PIN</strong> 或 <strong>PIN_MAP_TYPE_CONFIGS_GROUP</strong>），调用 <code>pinconf_map_to_setting</code> 函数执行引脚配置映射到设置对象的转换。</p>
<p>该函数的作用是将pinctrl_map引脚配置映射转换为pinctrl_setting设置对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/pinconf.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinconf_map_to_setting</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_map *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">			  <span class="keyword">struct</span> pinctrl_setting *setting)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;<span class="comment">// 获取引脚控制设备指针</span></span><br><span class="line">	<span class="type">int</span> pin;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<span class="comment">// 针对单个引脚的配置</span></span><br><span class="line">		pin = pin_get_from_name(pctldev,</span><br><span class="line">					<span class="built_in">map</span>-&gt;data.configs.group_or_pin);<span class="comment">// 通过引脚名称获取引脚号</span></span><br><span class="line">		<span class="keyword">if</span> (pin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			dev_err(pctldev-&gt;dev, <span class="string">&quot;could not map pin config for \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">				<span class="built_in">map</span>-&gt;data.configs.group_or_pin);</span><br><span class="line">			<span class="keyword">return</span> pin;</span><br><span class="line">		&#125;</span><br><span class="line">		setting-&gt;data.configs.group_or_pin = pin;<span class="comment">// 设置设置对象的引脚号</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<span class="comment">// 针对引脚组的配置</span></span><br><span class="line">		pin = pinctrl_get_group_selector(pctldev,</span><br><span class="line">					 <span class="built_in">map</span>-&gt;data.configs.group_or_pin);<span class="comment">// 获取引脚组的选择器</span></span><br><span class="line">		<span class="keyword">if</span> (pin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			dev_err(pctldev-&gt;dev, <span class="string">&quot;could not map group config for \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">				<span class="built_in">map</span>-&gt;data.configs.group_or_pin);</span><br><span class="line">			<span class="keyword">return</span> pin;</span><br><span class="line">		&#125;</span><br><span class="line">		setting-&gt;data.configs.group_or_pin = pin; <span class="comment">// 设置设置对象的引脚组选择器</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	setting-&gt;data.configs.num_configs = <span class="built_in">map</span>-&gt;data.configs.num_configs;<span class="comment">// 设置设置对象的配置数量</span></span><br><span class="line">	setting-&gt;data.configs.configs = <span class="built_in">map</span>-&gt;data.configs.configs;<span class="comment">// 设置设置对象的配置指针</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>对于针对单个引脚的配置，通过调用 <code>pin_get_from_name</code> 函数，根据映射表中的引脚名称获取引脚号，并将其设置到设置对象的 <code>data.configs.group_or_pin</code> 字段中。如果获取引脚号失败，则返回错误。</p>
<p>对于针对引脚组的配置，它通过调用 <code>pinctrl_get_group_selector</code> 函数，根据映射表中的引脚组名称获取引脚组的选择器，并将其设置到设置对象的 <code>data.configs.group_or_pin</code> 字段中</p>
<h2 id="pinctrl-lookup-state"><a href="#pinctrl-lookup-state" class="headerlink" title="pinctrl_lookup_state()"></a>pinctrl_lookup_state()</h2><p><code>pinctrl_bind_pins()</code>通过<code>dev-&gt;pins-&gt;default_state = pinctrl_lookup_state(dev-&gt;pins-&gt;p,PINCTRL_STATE_DEFAULT);</code> 查找设备的默认 pinctrl 状态，并将其赋值给 <code>dev-&gt;pins-&gt;default_state</code>。如果查找失败，函数会打印一条调试信息，并将返回值设置为 0，表示继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_lookup_state() - retrieves a state handle from a pinctrl handle</span></span><br><span class="line"><span class="comment"> * @p: the pinctrl handle to retrieve the state from</span></span><br><span class="line"><span class="comment"> * @name: the state name to retrieve</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> pinctrl_state *<span class="title function_">pinctrl_lookup_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p,</span></span><br><span class="line"><span class="params">						 <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span></span><br><span class="line">	<span class="comment">// 在状态链表中查找指定名称的状态对象</span></span><br><span class="line">	state = find_state(p, name);</span><br><span class="line">	<span class="keyword">if</span> (!state) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pinctrl_dummy_state) &#123;</span><br><span class="line">			<span class="comment">/* create dummy state */</span></span><br><span class="line">            <span class="comment">/* 创建虚拟状态 */</span></span><br><span class="line">			dev_dbg(p-&gt;dev, <span class="string">&quot;using pinctrl dummy state (%s)\n&quot;</span>,</span><br><span class="line">				name);</span><br><span class="line">            <span class="comment">// 如果找不到 指定的状态对象，并且存在虚拟状态，则创建一个虚拟状态对象</span></span><br><span class="line">			state = create_state(p, name);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果找不到指定的状态对象，并且不存在虚拟状态，则返回错误指针 -ENODEV</span></span><br><span class="line">			state = ERR_PTR(-ENODEV);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_lookup_state);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="pinctrl-select-state"><a href="#pinctrl-select-state" class="headerlink" title="pinctrl_select_state()"></a>pinctrl_select_state()</h2><p><code>pinctrl_bind_pins()</code>使用<code>pinctrl_select_state()</code>函数<code>ret = pinctrl_select_state(dev-&gt;pins-&gt;p,dev-&gt;pins-&gt;default_state);</code>选择并切换到指定的 pinctrl_state（引脚控制状态）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_select_state() - select/activate/program a pinctrl state to HW</span></span><br><span class="line"><span class="comment"> * @p: the pinctrl handle for the device that requests configuration</span></span><br><span class="line"><span class="comment"> * @state: the state handle to select/activate/program</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_select_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;state == state)<span class="comment">// 如果当前状态已经是要选择的状态，则无需进行任何操作，直接返回 0 表示成功</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 调用 pinctrl_commit_state 函数来应用并切换到新的状态</span></span><br><span class="line">	<span class="keyword">return</span> pinctrl_commit_state(p, state);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(pinctrl_select_state);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="pinctrl-commit-state"><a href="#pinctrl-commit-state" class="headerlink" title="pinctrl_commit_state()"></a>pinctrl_commit_state()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * pinctrl_commit_state() - select/activate/program a pinctrl state to HW</span></span><br><span class="line"><span class="comment"> * @p: the pinctrl handle for the device that requests configuration</span></span><br><span class="line"><span class="comment"> * @state: the state handle to select/activate/program</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pinctrl_commit_state</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_state *state)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting</span> *<span class="title">setting</span>, *<span class="title">setting2</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">old_state</span> =</span> p-&gt;state;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;state) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * For each pinmux setting in the old state, forget SW&#x27;s record</span></span><br><span class="line"><span class="comment">		 * of mux owner for that pingroup. Any pingroups which are</span></span><br><span class="line"><span class="comment">		 * still owned by the new state will be re-acquired by the call</span></span><br><span class="line"><span class="comment">		 * to pinmux_enable_setting() in the loop below.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 对于旧状态中的每个引脚复用设置，取消 SW 记录的该引脚组的复用所有者。</span></span><br><span class="line"><span class="comment">		* 任何仍由新状态拥有的引脚组将在下面循环中的 pinmux_enable_setting() 调用中重新获取。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		list_for_each_entry(setting, &amp;p-&gt;state-&gt;settings, node) &#123;</span><br><span class="line">			<span class="keyword">if</span> (setting-&gt;type != PIN_MAP_TYPE_MUX_GROUP)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			pinmux_disable_setting(setting);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p-&gt;state = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Apply all the settings for the new state */</span></span><br><span class="line">    <span class="comment">/* 应用新状态的所有设置 */</span></span><br><span class="line">	list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">            <span class="comment">// 对于引脚复用设置（PIN_MAP_TYPE_MUX_GROUP），调用 pinmux_enable_setting()函数来启用该设置。</span></span><br><span class="line">			ret = pinmux_enable_setting(setting);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">		<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">            <span class="comment">// 对于引脚配置设置（PIN_MAP_TYPE_CONFIGS_PIN 或 PIN_MAP_TYPE_CONFIGS_GROUP），调用 pinconf_apply_setting()函数来应用该设置</span></span><br><span class="line">			ret = pinconf_apply_setting(setting);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果应用设置失败，则回滚新状态的设置</span></span><br><span class="line">			<span class="keyword">goto</span> unapply_new_state;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Do not link hogs (circular dependency) */</span></span><br><span class="line">		<span class="keyword">if</span> (p != setting-&gt;pctldev-&gt;p)</span><br><span class="line">			pinctrl_link_add(setting-&gt;pctldev, p-&gt;dev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	p-&gt;state = state;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">unapply_new_state:</span><br><span class="line">    <span class="comment">// 回滚新状态的设置</span></span><br><span class="line">	dev_err(p-&gt;dev, <span class="string">&quot;Error applying setting, reverse things back\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	list_for_each_entry(setting2, &amp;state-&gt;settings, node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (&amp;setting2-&gt;node == &amp;setting-&gt;node)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * All we can do here is pinmux_disable_setting.</span></span><br><span class="line"><span class="comment">		 * That means that some pins are muxed differently now</span></span><br><span class="line"><span class="comment">		 * than they were before applying the setting (We can&#x27;t</span></span><br><span class="line"><span class="comment">		 * &quot;unmux a pin&quot;!), but it&#x27;s not a big deal since the pins</span></span><br><span class="line"><span class="comment">		 * are free to be muxed by another apply_setting.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (setting2-&gt;type == PIN_MAP_TYPE_MUX_GROUP)</span><br><span class="line">			pinmux_disable_setting(setting2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* There&#x27;s no infinite recursive loop here because p-&gt;state is NULL */</span></span><br><span class="line">	<span class="keyword">if</span> (old_state)</span><br><span class="line">		pinctrl_select_state(p, old_state);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>pinctrl_commit_state()</code>函数遍历新状态的所有设置，并根据设置的类型执行相应的操作：</p>
<ul>
<li><p>对于引脚复用设置（PIN_MAP_TYPE_MUX_GROUP），调用 <code>pinmux_enable_setting()</code>函数来启用该设置。</p>
</li>
<li><p>对于引脚配置设置（PIN_MAP_TYPE_CONFIGS_PIN 或 PIN_MAP_TYPE_CONFIGS_GROUP），调用 <code>pinconf_apply_setting()</code>函数来应用该设置。</p>
</li>
<li><p>对于其他类型的设置，将返回一个错误码（-EINVAL）。</p>
</li>
</ul>
<h3 id="pinmux-enable-setting"><a href="#pinmux-enable-setting" class="headerlink" title="pinmux_enable_setting()"></a>pinmux_enable_setting()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//drivers/pinctrl/pinmux.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinmux_enable_setting</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_setting *setting)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span> =</span> pctldev-&gt;desc-&gt;pctlops;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">ops</span> =</span> pctldev-&gt;desc-&gt;pmxops;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> *pins = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> num_pins = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="comment">// 如果 pctlops-&gt;get_group_pins 函数存在，则调用该函数获取组中的引脚信息，并将引脚信息存储在 pins 和 num_pins 变量中</span></span><br><span class="line">	<span class="keyword">if</span> (pctlops-&gt;get_group_pins)</span><br><span class="line">		ret = pctlops-&gt;get_group_pins(pctldev, setting-&gt;data.mux.group,</span><br><span class="line">					      &amp;pins, &amp;num_pins);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;<span class="comment">// 如果获取引脚信息失败，发出警告并将 num_pins 设置为 0</span></span><br><span class="line">		<span class="type">const</span> <span class="type">char</span> *gname;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* errors only affect debug data, so just warn */</span></span><br><span class="line">        <span class="comment">// 错误只影响调试数据，因此只发出警告</span></span><br><span class="line">		gname = pctlops-&gt;get_group_name(pctldev,</span><br><span class="line">						setting-&gt;data.mux.group);</span><br><span class="line">		dev_warn(pctldev-&gt;dev,</span><br><span class="line">			 <span class="string">&quot;could not get pins for group %s\n&quot;</span>,</span><br><span class="line">			 gname);</span><br><span class="line">		num_pins = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Try to allocate all pins in this group, one by one */</span></span><br><span class="line">    <span class="comment">// 逐个申请组中的引脚</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用 pin_request 函数申请引脚，并传入引脚控制器设备、引脚编号、设备名称和其他参数</span></span><br><span class="line">		ret = pin_request(pctldev, pins[i], setting-&gt;dev_name, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="type">const</span> <span class="type">char</span> *gname;</span><br><span class="line">			<span class="type">const</span> <span class="type">char</span> *pname;</span><br><span class="line">		<span class="comment">// 分配引脚后，使用 pin_desc_get 函数获取引脚描述符，并将复用设置指针指向引脚复用信息。</span></span><br><span class="line">			desc = pin_desc_get(pctldev, pins[i]);</span><br><span class="line">			pname = desc ? desc-&gt;name : <span class="string">&quot;non-existing&quot;</span>;</span><br><span class="line">			gname = pctlops-&gt;get_group_name(pctldev,</span><br><span class="line">						setting-&gt;data.mux.group);</span><br><span class="line">			dev_err(pctldev-&gt;dev,</span><br><span class="line">				<span class="string">&quot;could not request pin %d (%s) from group %s &quot;</span></span><br><span class="line">				<span class="string">&quot; on device %s\n&quot;</span>,</span><br><span class="line">				pins[i], pname, gname,</span><br><span class="line">				pinctrl_dev_get_name(pctldev));</span><br><span class="line">			<span class="keyword">goto</span> err_pin_request;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now that we have acquired the pins, encode the mux setting */</span></span><br><span class="line">    <span class="comment">// 分配引脚后，编码复用设置</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">		desc = pin_desc_get(pctldev, pins[i]);</span><br><span class="line">		<span class="keyword">if</span> (desc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			dev_warn(pctldev-&gt;dev,</span><br><span class="line">				 <span class="string">&quot;could not get pin desc for pin %d\n&quot;</span>,</span><br><span class="line">				 pins[i]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		desc-&gt;mux_setting = &amp;(setting-&gt;data.mux);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用 ops-&gt;set_mux 函数设置引脚复用，传入引脚控制器设备、复用功能和组信息，以便设置引脚复用。</span></span><br><span class="line">	ret = ops-&gt;set_mux(pctldev, setting-&gt;data.mux.func,</span><br><span class="line">			   setting-&gt;data.mux.group);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_set_mux;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_set_mux:</span><br><span class="line">    <span class="comment">// 复用设置失败，清除复用设置</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">		desc = pin_desc_get(pctldev, pins[i]);</span><br><span class="line">		<span class="keyword">if</span> (desc)</span><br><span class="line">			desc-&gt;mux_setting = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">err_pin_request:</span><br><span class="line">	<span class="comment">/* On error release all taken pins */</span></span><br><span class="line">    <span class="comment">// 在错误发生时释放已申请的引脚</span></span><br><span class="line">	<span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">		pin_free(pctldev, pins[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="pinconf-apply-setting"><a href="#pinconf-apply-setting" class="headerlink" title="pinconf_apply_setting()"></a>pinconf_apply_setting()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/pinconf.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinconf_apply_setting</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pinctrl_setting *setting)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span> =</span> setting-&gt;pctldev;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">ops</span> =</span> pctldev-&gt;desc-&gt;confops;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ops) &#123;<span class="comment">// 检查是否存在 pinconf 操作函数集</span></span><br><span class="line">		dev_err(pctldev-&gt;dev, <span class="string">&quot;missing confops\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 根据设置类型选择相应的操作</span></span><br><span class="line">	<span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:<span class="comment">//表示对单个引脚进行配置设置</span></span><br><span class="line">		<span class="keyword">if</span> (!ops-&gt;pin_config_set) &#123;<span class="comment">// 检查是否存在 pin_config_set 操作函数</span></span><br><span class="line">			dev_err(pctldev-&gt;dev, <span class="string">&quot;missing pin_config_set op\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 调用 pin_config_set 函数设置单个引脚的配置</span></span><br><span class="line">		ret = ops-&gt;pin_config_set(pctldev,</span><br><span class="line">				setting-&gt;data.configs.group_or_pin,</span><br><span class="line">				setting-&gt;data.configs.configs,</span><br><span class="line">				setting-&gt;data.configs.num_configs);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			dev_err(pctldev-&gt;dev,</span><br><span class="line">				<span class="string">&quot;pin_config_set op failed for pin %d\n&quot;</span>,</span><br><span class="line">				setting-&gt;data.configs.group_or_pin);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:<span class="comment">// 表示对引脚组进行配置设置</span></span><br><span class="line">		<span class="keyword">if</span> (!ops-&gt;pin_config_group_set) &#123;<span class="comment">// 检查是否存在 pin_config_group_set 操作函数</span></span><br><span class="line">			dev_err(pctldev-&gt;dev,</span><br><span class="line">				<span class="string">&quot;missing pin_config_group_set op\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 调用 pin_config_group_set 函数设置引脚组的配置</span></span><br><span class="line">		ret = ops-&gt;pin_config_group_set(pctldev,</span><br><span class="line">				setting-&gt;data.configs.group_or_pin,</span><br><span class="line">				setting-&gt;data.configs.configs,</span><br><span class="line">				setting-&gt;data.configs.num_configs);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			dev_err(pctldev-&gt;dev,</span><br><span class="line">				<span class="string">&quot;pin_config_group_set op failed for group %d\n&quot;</span>,</span><br><span class="line">				setting-&gt;data.configs.group_or_pin);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251216154951470.jpg" alt="pinctrl" loading="lazy"></p>
<h1 id="引脚复用是在什么时候设置的"><a href="#引脚复用是在什么时候设置的" class="headerlink" title="引脚复用是在什么时候设置的"></a>引脚复用是在什么时候设置的</h1><ul>
<li>猜想 1</li>
</ul>
<p>第一个猜想是在加载 LED 驱动的时候进行的 pinctrl 引脚复用。当 LED 灯的设备树和驱动匹配之后，就会进入驱动中编写的 probe<br>函 数 ， 在 此 之 前 会 执 行 <code>drivers/base/dd.c</code> 文 件 中 的<code>really_probe</code> 函 数 中 的 子 函 数<code>pinctrl_bind_pins</code>，该函数会为给定的设备绑定引脚，并在绑定过程中选择和设置适当的 pinctrl状态。具体的绑定细节可以去前面的章节中查找。</p>
<ul>
<li>猜想 2</li>
</ul>
<p>第二种猜想是在加载 pinctrl 驱动的时候完成的引脚复用，因为 pinctrl 子系统也是符合设备模型的规范 ，也会 执 行 相 应的 probe 函数，所以同样的加在 pinctrl 驱动时也会执行<code>drivers/base/dd.c</code>文件中的 <code>really_probe</code> 函数中的子函数 <code>pinctrl_bind_pins</code>，那这时会进行pinctrl 管脚的复用设置吗，接下来我们对此进行深入的分析。</p>
<p>在 pinctrl 的 probe 函数执行之前，会调用 <code>pinctrl_bind_pins</code> 函数，根据前面的内容可知，根据函数的嵌套，首先会调用的 <code>create_pinctrl</code> 函数创建 <code>struct pinctrl</code> 类型的引脚控制器，然后在<code>create_pinctrl</code>调用 <code>pinctrl_dt_to_map</code> 函数将设备树中定义的引脚映射信息转换为 <code>struct pinctrl_map</code> 结构，并将其添加到 <code>p-&gt;dt_maps</code> 链表中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers/pinctrl/devicetree.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pinctrl_dt_to_map</span><span class="params">(<span class="keyword">struct</span> pinctrl *p, <span class="keyword">struct</span> pinctrl_dev *pctldev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> p-&gt;dev-&gt;of_node;<span class="comment">// 获取引脚控制器关联设备的设备树节点</span></span><br><span class="line">	<span class="type">int</span> state, ret;</span><br><span class="line">	<span class="type">char</span> *propname;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">prop</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *statename;</span><br><span class="line">	<span class="type">const</span> __be32 *<span class="built_in">list</span>;</span><br><span class="line">	<span class="type">int</span> size, config;</span><br><span class="line">	phandle phandle;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np_config</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* CONFIG_OF enabled, p-&gt;dev not instantiated from DT */</span></span><br><span class="line">    <span class="comment">/* 如果 CONFIG_OF 启用，且 p-&gt;dev 不是从设备树实例化而来 */</span></span><br><span class="line">	<span class="keyword">if</span> (!np) &#123;</span><br><span class="line">		<span class="keyword">if</span> (of_have_populated_dt())</span><br><span class="line">			dev_dbg(p-&gt;dev,</span><br><span class="line">				<span class="string">&quot;no of_node; not parsing pinctrl DT\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We may store pointers to property names within the node */</span></span><br><span class="line">    <span class="comment">/* 节点内部存储属性名称的指针 */</span></span><br><span class="line">	of_node_get(np);<span class="comment">//增加设备树节点的引用计数，以确保在解析过程中节点不会被释放</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For each defined state ID */</span></span><br><span class="line">    <span class="comment">/* 对于每个定义的状态 ID */</span></span><br><span class="line">	<span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line">		<span class="comment">/* Retrieve the pinctrl-* property */</span></span><br><span class="line">        <span class="comment">/* 获取 pinctrl-* 属性 */</span></span><br><span class="line">		propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line">		<span class="keyword">if</span> (!propname)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">		kfree(propname);</span><br><span class="line">		<span class="keyword">if</span> (!prop) &#123;</span><br><span class="line">			<span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">				of_node_put(np);</span><br><span class="line">				<span class="keyword">return</span> -ENODEV;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">list</span> = prop-&gt;value;</span><br><span class="line">		size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Determine whether pinctrl-names property names the state */</span></span><br><span class="line">        <span class="comment">/* 判断 pinctrl-names 属性是否命名了该状态 */</span></span><br><span class="line">		ret = of_property_read_string_index(np, <span class="string">&quot;pinctrl-names&quot;</span>,</span><br><span class="line">						    state, &amp;statename);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If not, statename is just the integer state ID. But rather</span></span><br><span class="line"><span class="comment">		 * than dynamically allocate it and have to free it later,</span></span><br><span class="line"><span class="comment">		 * just point part way into the property name for the string.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 如果未命名，则 statename 仅是整数状态 ID。但是，为了避免动态分配和之后要释放的麻烦，</span></span><br><span class="line"><span class="comment">		* 可以直接将 statename 指向属性名称的一部分。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			statename = prop-&gt;name + <span class="built_in">strlen</span>(<span class="string">&quot;pinctrl-&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* For every referenced pin configuration node in it */</span></span><br><span class="line">        <span class="comment">/* 对于其中的每个引用的引脚配置节点 */</span></span><br><span class="line">		<span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123;</span><br><span class="line">			phandle = be32_to_cpup(<span class="built_in">list</span>++);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Look up the pin configuration node */</span></span><br><span class="line">            <span class="comment">/* 查找引脚配置节点 */</span></span><br><span class="line">			np_config = of_find_node_by_phandle(phandle);</span><br><span class="line">			<span class="keyword">if</span> (!np_config) &#123;</span><br><span class="line">				dev_err(p-&gt;dev,</span><br><span class="line">					<span class="string">&quot;prop %s index %i invalid phandle\n&quot;</span>,</span><br><span class="line">					prop-&gt;name, config);</span><br><span class="line">				ret = -EINVAL;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Parse the node */</span></span><br><span class="line">            <span class="comment">/* 解析节点 */</span></span><br><span class="line">			ret = dt_to_map_one_config(p, pctldev, statename,</span><br><span class="line">						   np_config);</span><br><span class="line">			of_node_put(np_config);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* No entries in DT? Generate a dummy state table entry */</span></span><br><span class="line">        <span class="comment">/* 如果在设备树中没有条目，则生成一个虚拟状态表条目 */</span></span><br><span class="line">		<span class="keyword">if</span> (!size) &#123;</span><br><span class="line">			ret = dt_remember_dummy_state(p, statename);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	pinctrl_dt_free_maps(p);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关键点在于：这里传递过来的是 pinctrl 的设备树节点，在 32 行在 for 循环中会获取 <code>pinctrl-*</code> 属性，而<strong>在 pinctrl 节点中并没有该属性，<code>pinctrl-*</code> 属性是在一系列的设备节点中添加的</strong>，所以会在这里返回错误，同样的错误会一层层的向上级函数传递，最终导致 <code>pinctrl_bind_pins()</code> 函数返回错误，从而不能设置引脚的复用，即：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_bind_pins</span><br><span class="line">	create_pinctr</span><br><span class="line">		<span class="function"><span class="title">pinctrl_dt_to_map</span> -&gt;</span> 报错</span><br></pre></td></tr></table></figure>

<p>所以猜想 2 是不正确的。</p>
<p>而瑞芯微的pinctrl驱动中的probe有这样一个调用关系：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rockchip pinctrl<span class="emphasis">_probe</span></span><br><span class="line"><span class="emphasis">	rockchip_pinctrl_registér</span></span><br><span class="line"><span class="emphasis">		devm_pinctrl_register</span></span><br><span class="line"><span class="emphasis">			pinctrl_register</span></span><br><span class="line"><span class="emphasis">				pinctrl_enable</span></span><br><span class="line"><span class="emphasis">					pinctrl_claim_hogs</span></span><br><span class="line"><span class="emphasis">						create_</span>pinctr</span><br></pre></td></tr></table></figure>

<p>从上面的调用关系可以得到 pinctrl 的 probe 函数最后也会调用 <code>create_pinctrl</code> 来创建 <code>struct pinctrl</code> 类型的引脚控制器，从而实现 pinctrl 引脚复用设置，同样的这是的设置也是不成功的，<code>pinctrl_claim_hogs</code> 函数定义在内核源码目录下的<code>drivers/pinctrl/core.c</code>文件中</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/2512160/">https://even629.com/posts/2512160/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/driver/">driver</a></div><div class="post-share"><div class="social-share" data-image="/images/linux_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center liquidGlass-wrapper" id="my-custom-card-author"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status">🐟<span>认真摸鱼中</span></div></div></div><div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" target="_blank" title="github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="qq"><i class="fa-brands fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" target="_blank" title="email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://space.bilibili.com/519280138" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="rss"><i class="fas fa-rss" style="color: #000000;"></i></a></div></div></div><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"> <div class="newYear-slider"> <div class="swiper-wrapper"> <div class="swiper-slide" style="background-image:url(/img/happy_new_year1.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year2.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year3.webp)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year4.gif)"></div> </div> </div> <div id="newYear-main"> <div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div> </div></div><div class="sticky_layout"><div class="card-widget liquidGlass-wrapper" id="card-toc"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#pinctrl%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-text">pinctrl设备树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#groups%E5%92%8Cfunction"><span class="toc-text">groups和function</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rockchip-pinctrl-probe"><span class="toc-text">rockchip_pinctrl_probe()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rockchip-pinctrl-register"><span class="toc-text">rockchip_pinctrl_register()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rockchip-pinctrl-parse-dt"><span class="toc-text">rockchip_pinctrl_parse_dt()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#rockchip-pinctrl-child-count"><span class="toc-text">rockchip_pinctrl_child_count()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rockchip-pinctrl-parse-functions"><span class="toc-text">rockchip_pinctrl_parse_functions()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#devm-pinctrl-register"><span class="toc-text">devm_pinctrl_register()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pinctrl-register"><span class="toc-text">pinctrl_register()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pinctrl-init-controller"><span class="toc-text">pinctrl_init_controller()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">相关数据结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pinctrl-desc-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">pinctrl_desc 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rockchip-pinctrl-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">rockchip_pinctrl 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rockchip-pin-ctrl-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">rockchip_pin_ctrl 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinctrl-dev-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">pinctrl_dev 结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C%E9%9B%86"><span class="toc-text">pinctrl子系统函数操作集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pinctrl-ops"><span class="toc-text">pinctrl_ops</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get-groups-count"><span class="toc-text">get_groups_count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-group-name"><span class="toc-text">get_group_name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-group-pins"><span class="toc-text">get_group_pins</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dt-node-to-map"><span class="toc-text">dt_node_to_map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pinctrl-map-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">pinctrl_map 结构体</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dt-free-map"><span class="toc-text">dt_free_map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinmux-ops"><span class="toc-text">pinmux_ops</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#get-functions-count"><span class="toc-text">get_functions_count</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-function-name"><span class="toc-text">get_function_name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get-function-groups"><span class="toc-text">get_function_groups</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-mux"><span class="toc-text">set_mux</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinconf-ops"><span class="toc-text">pinconf_ops</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pin-config-get"><span class="toc-text">pin_config_get</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pin-config-set"><span class="toc-text">pin_config_set</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE"><span class="toc-text">思维导图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#pinctrl-bind-pins"><span class="toc-text">pinctrl_bind_pins()</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-dev-pin-info-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">struct dev_pin_info 结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#devm-pinctrl-get"><span class="toc-text">devm_pinctrl_get()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pinctrl-get"><span class="toc-text">pinctrl_get()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#create-pinctrl"><span class="toc-text">create_pinctrl()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pinctrl-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">pinctrl 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pinctrl-maps-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">pinctrl_maps 结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pinctrl-dt-to-map"><span class="toc-text">pinctrl_dt_to_map()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dt-to-map-one-config"><span class="toc-text">dt_to_map_one_config()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dt-remember-or-free-map"><span class="toc-text">dt_remember_or_free_map()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pinctrl-dt-map-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">pinctrl_dt_map 结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pinctrl-register-mappings"><span class="toc-text">pinctrl_register_mappings()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-setting"><span class="toc-text">add_setting()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pinctrl-state-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">pinctrl_state 结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pinctrl-setting-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">pinctrl_setting 结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#create-state"><span class="toc-text">create_state()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pinmux-map-to-setting"><span class="toc-text">pinmux_map_to_setting()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pinconf-map-to-setting"><span class="toc-text">pinconf_map_to_setting()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pinctrl-lookup-state"><span class="toc-text">pinctrl_lookup_state()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pinctrl-select-state"><span class="toc-text">pinctrl_select_state()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pinctrl-commit-state"><span class="toc-text">pinctrl_commit_state()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinmux-enable-setting"><span class="toc-text">pinmux_enable_setting()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pinconf-apply-setting"><span class="toc-text">pinconf_apply_setting()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-1"><span class="toc-text">思维导图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%84%9A%E5%A4%8D%E7%94%A8%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AE%BE%E7%BD%AE%E7%9A%84"><span class="toc-text">引脚复用是在什么时候设置的</span></a></li></ol></div></div></div><div class="card-widget card-recent-post liquidGlass-wrapper"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2601133/" title="Linux 网络设备"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux 网络设备"/></a><div class="content"><a class="title" href="/posts/2601133/" title="Linux 网络设备">Linux 网络设备</a><time datetime="2026-01-13T14:00:00.000Z" title="发表于 2026-01-13 22:00:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601143/" title="Linux ADC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux ADC"/></a><div class="content"><a class="title" href="/posts/2601143/" title="Linux ADC">Linux ADC</a><time datetime="2026-01-13T13:18:00.000Z" title="发表于 2026-01-13 21:18:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601093/" title="Linux CAN"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux CAN"/></a><div class="content"><a class="title" href="/posts/2601093/" title="Linux CAN">Linux CAN</a><time datetime="2026-01-09T07:56:00.000Z" title="发表于 2026-01-09 15:56:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601063/" title="Linux Watchdog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux Watchdog"/></a><div class="content"><a class="title" href="/posts/2601063/" title="Linux Watchdog">Linux Watchdog</a><time datetime="2026-01-06T05:09:00.000Z" title="发表于 2026-01-06 13:09:00">2026-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601053/" title="Linux RTC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux RTC"/></a><div class="content"><a class="title" href="/posts/2601053/" title="Linux RTC">Linux RTC</a><time datetime="2026-01-05T14:09:00.000Z" title="发表于 2026-01-05 22:09:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601043/" title="Linux PWM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux PWM"/></a><div class="content"><a class="title" href="/posts/2601043/" title="Linux PWM">Linux PWM</a><time datetime="2026-01-04T10:59:00.000Z" title="发表于 2026-01-04 18:59:00">2026-01-04</time></div></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a target="_blank" rel="noopener" href="https://github.com/even629" title="github"><i class="fab fa-github"></i></a><a href="/img/qq.jpg" title="qq"><i class="fa-brands fa-qq"></i></a><a href="mailto:zhaohang731005515@proton.me" title="email"><i class="fas fa-envelope"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/519280138" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a href="/atom.xml" title="rss"><i class="fas fa-rss"></i></a></div><div class="copyright">&copy;2024 - 2026 By even629</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Frame-Hexo-blue.svg" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Theme-Butterfly.svg" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Source-Github.svg" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Copyright-BY--NC--SA.4.svg" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"> </span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.stopSakura();"><i class="fa-solid fa-feather"></i><span data-zh="樱花特效" data-en="toggle sakura"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'c1daf096754d37eb5bd055eb970a35f5'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.js"></script><script src="/js/sakura.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/solarlunar.js"></script><script src="/js/newYear.js"></script><script src="/js/pop-up-window.js"></script><script data-pjax src="/js/nav.js"></script><script data-pjax src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><svg style="display: none">
<filter
  id="glass-distortion"
  x="0%"
  y="0%"
  width="100%"
  height="100%"
  filterUnits="objectBoundingBox"
>
  <feTurbulence
    type="fractalNoise"
    baseFrequency="0.01 0.01"
    numOctaves="1"
    seed="5"
    result="turbulence"
  />
  <!-- Seeds: 14, 17,  -->

  <feComponentTransfer in="turbulence" result="mapped">
    <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
    <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
    <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
  </feComponentTransfer>

  <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap" />

  <feSpecularLighting
    in="softMap"
    surfaceScale="5"
    specularConstant="1"
    specularExponent="100"
    lighting-color="white"
    result="specLight"
  >
    <fePointLight x="-200" y="-200" z="300" />
  </feSpecularLighting>

  <feComposite
    in="specLight"
    operator="arithmetic"
    k1="0"
    k2="1"
    k3="1"
    k4="0"
    result="litImage"
  />

  <feDisplacementMap
    in="SourceGraphic"
    in2="softMap"
    scale="150"
    xChannelSelector="R"
    yChannelSelector="G"
  />
  </filter>
</svg>
<script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload="this.media='all'"><script src="/js/APlayer.min.js"></script><script src="/js/meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr class="custom-hr"/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><script async src="//at.alicdn.com/t/c/font_4847823_upluhme7cv.js"></script><!-- hexo injector body_end end --></body></html>