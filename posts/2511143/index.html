<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux中断 | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux中断">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux中断">
<meta property="og:url" content="https://even629.com/posts/2511143/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="Linux中断">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/linux_cover.webp">
<meta property="article:published_time" content="2025-11-14T12:31:13.000Z">
<meta property="article:modified_time" content="2025-11-14T12:31:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/linux_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/2511143/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: even629","link":"链接: ","source":"来源: 常想一二，不思八九","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux中断',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.png', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom_card_author.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/newYear.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/beautify_label_h.css"><link rel="stylesheet" href="/css/equipment.css"><link rel="stylesheet" href="/css/liquid_glass.css"><link rel="stylesheet" href="/css/tag_plugin_plus.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="常想一二，不思八九" type="application/atom+xml">
</head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/linux_top_image.jpg);"><nav class="liquidGlass-wrapper" id="nav" style="--glass-border-radius: 2rem;"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box" style="display:flex;align-items:center;justify-content:center;width:100%"><!-- 左侧博客信息区域--><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" alt="Logo"></a></span><!-- 新增的导航菜单容器（居中布局关键）--><div id="nav-menus-container"><!-- 菜单主体部分--><div id="menus"><!-- 菜单项--><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><!-- 显示当前标题名称--><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">常想一二，不思八九</a></center></div></div><!-- 右侧功能区域（新增容器）--><div id="nav-right-container"><!-- 搜索按钮（移动到右侧）--><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><!-- 移动端汉堡菜单按钮--><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">Linux中断</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-14T12:31:13.000Z" title="发表于 2025-11-14 20:31:13">2025-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-14T12:31:13.000Z" title="更新于 2025-11-14 20:31:13">2025-11-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">19.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2511143/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-11-14</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div></div>

<hr>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断是指在 CPU 正常运行期间，由外部或内部事件引起的一种机制。当中断发生时，CPU会停止当前正在执行的程序，并转而执行触发该中断的中断处理程序。处理完中断处理程序后，CPU 会返回到中断发生的地方，继续执行被中断的程序。中断机制允许 CPU 在实时响应外部或内部事件的同时，保持对其他任务的处理能力。</p>
<h2 id="中断概念"><a href="#中断概念" class="headerlink" title="中断概念"></a>中断概念</h2><p>中断机制赋予了我们处理意外情况的能力，而且如果我们能充分利用这个机制，就能够同时完成多个任务。</p>
<p>中断机制使我们能够有条不紊地同时处理多个任务，从而提高了并发处理能力。类似地，计算机系统中也使用中断机制来应对各种外部事件。例如，在键盘输入时，会发送一个中断信号给 CPU，以便及时响应用户的操作。这样，CPU 就不必一直轮询键盘的状态，而可以专注于其他任务。中断机制还可以用于处理硬盘读写完成、网络数据包接收等事件，提高了系统的资源利用率和并发处理能力。</p>
<h3 id="中断的上下半部"><a href="#中断的上下半部" class="headerlink" title="中断的上下半部"></a>中断的上下半部</h3><p><strong>中断的执行需要快速响应</strong>，但并不是所有中断都能迅速完成。如果中断处理时间过长，将会引发问题。</p>
<p>而为了让系统可以更好地处理中断事件，提高实时性和响应能力，将中断服务程序划分为上下文两部分：</p>
<ul>
<li><strong>中断上文</strong> 是中断服务程序的第一部分，它主要<strong>处理一些紧急且需要快速响应的任务</strong>。<ul>
<li>特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等，以便在中断处理完成后能够正确地返回到中断前的执行位置。</li>
</ul>
</li>
<li><strong>中断下文</strong> 是中断服务程序的第二部分，它主要<strong>处理一些相对耗时的任务</strong>。<ul>
<li>由于中断上文需要尽快完成，因此中断下文负责处理那些不能立即完成的、需要更多时间的任务。这些任务可能包括复杂的计算、访问外部设备或进行长时间的数据处理等。</li>
</ul>
</li>
</ul>
<h3 id="中断子系统框架"><a href="#中断子系统框架" class="headerlink" title="中断子系统框架"></a>中断子系统框架</h3><p>一个完整的中断子系统框架可以分为四个层次，由上到下分别为用户层、通用层、硬件相关层和硬件层，每个层相关的介绍如下所示：</p>
<ul>
<li><p><strong>用户层</strong>：用户层是中断的使用者，主要包括各类设备驱动。</p>
<p>这些驱动程序通过中断相关的接口进行中断的申请和注册。当外设触发中断时，用户层驱动程序会进行相应的回调处理，执行特定的操作。</p>
</li>
<li><p><strong>通用层</strong>：通用层也可称为框架层，它是硬件无关的层次。<br>通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器。通用层提供了统一的接口和功能，用于管理和处理中断，使得驱动程序能够在不同的硬件平台上复用。</p>
</li>
<li><p><strong>硬件相关层</strong>：硬件相关层包含两部分代码。<br>一部分是与特定处理器架构相关的代码，比如ARM64 处理器的中断处理相关代码。这些代码负责处理特定架构的中断机制，包括中断向量表、中断处理程序等。另一部分是中断控制器的驱动代码，用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关。</p>
</li>
<li><p><strong>硬件层</strong>：硬件层位于最底层，与具体的硬件连接相关。</p>
<p>它包括外设与 SoC（系统片上芯片）的物理连接部分。中断信号从外设传递到中断控制器，由中断控制器统一管理和路由到处理器。硬件层的设计和实现决定了中断信号的传递方式和硬件的中断处理能力</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202511181636225.png" alt="中断子系统框架的四个层次" loading="lazy"></p>
<h3 id="中断控制器GIC"><a href="#中断控制器GIC" class="headerlink" title="中断控制器GIC"></a>中断控制器GIC</h3><p>参考：</p>
<div class="tag link"><a class="link-card" title="ARM Interrupt Controller" href="https://even629.com/posts/2510220/"><div class="left"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://even629.com/img/favicon.ico"/></div><div class="right"><p class="text">ARM Interrupt Controller</p><p class="url">https://even629.com/posts/2510220/</p></div></a></div>

<p>中断控制器 GIC（Generic Interrupt Controller）是中断子系统框架硬件层中的一个关键组件，用于管理和控制中断。它接收来自各种中断源的中断请求，并根据预先配置的中断优先级、屏蔽和路由规则，将中断请求分发给适当的处理器核心或中断服务例程。</p>
<p>GIC 是由 ARM 公司提出设计规范，当前有四个版本，GIC V1-v4。设计规范中最常用的有3 个版本 <strong>V2.0、V3.1、V4.1</strong>，GICv3 版本设计主要运行在 Armv8-A, Armv9-A 等架构上。</p>
<p>ARM 公司并给出一个实际的控制器设计参考，比如 GIC-400(支持 GIC v2 架构)、gic500(支持 GIC v3 架构)、GIC-600(支持 GIC v3 和 GIC v4 架构)。最终芯片厂商可以自己实现 GIC 或者直接购买 ARM提供的设计。</p>
<table>
<thead>
<tr>
<th><strong>版本</strong></th>
<th><strong>关键特性</strong></th>
<th><strong>常用核心</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>GICv1</strong></td>
<td>支持最多 8 个处理器核心（PE） - 支持最多 1020 个中断 ID</td>
<td>ARM Cortex-A5 MPCore, ARM Cortex-A9 MPCore, ARM Cortex-R7 MPCore</td>
</tr>
<tr>
<td><strong>GICv2</strong></td>
<td>包含 GICv1 所有特性 - 支持虚拟化</td>
<td>ARM Cortex-A7 MPCore, ARM Cortex-A15 MPCore, ARM Cortex-A53 MPCore, ARM Cortex-A57 MPCore</td>
</tr>
<tr>
<td><strong>GICv3</strong></td>
<td>包含 GICv2 所有特性 - 支持超过 8 个处理器核心 - 支持基于消息的中断 - 支持超过 1020 个中断 ID - CPU 接口寄存器的系统寄存器访问 - 增强的安全模型，分离安全和非安全的 Group 1 中断</td>
<td>ARM Cortex-A53 MPCore, ARM Cortex-A57 MPCore, ARM Cortex-A72 MPCore</td>
</tr>
<tr>
<td><strong>GICv4</strong></td>
<td>包含 GICv3 所有特性 - 支持虚拟中断的直接注入</td>
<td>ARM Cortex-A53 MPCore, ARM Cortex-A57 MPCore, ARM Cortex-A72 MPCore</td>
</tr>
</tbody></table>
<h4 id="GICv3"><a href="#GICv3" class="headerlink" title="GICv3"></a>GICv3</h4><p>RK3568使用的是GICv3</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/202511181639986.png" alt="GICv3中断控制器模型" loading="lazy"></p>
<p>GIC 中断控制器可以分为 Distributor 接口、Redistributor 接口和 CPU 接口，下面是每个部分的说明：</p>
<h5 id="Distributor-中断仲裁器"><a href="#Distributor-中断仲裁器" class="headerlink" title="Distributor 中断仲裁器"></a>Distributor 中断仲裁器</h5><p>包含影响所有处理器核心中断的全局设置。包含以下编程接口：</p>
<ul>
<li>启用和禁用 SPI。</li>
<li>设置每个 SPI 的优先级级别。</li>
<li>每个 SPI 的路由信息。</li>
<li>将每个 SPI 设置为电平触发或边沿触发。</li>
<li>生成基于消息的 SPI。</li>
<li>控制 SPI 的活动和挂起状态。</li>
<li>用于确定在每个安全状态中使用的程序员模型的控制（亲和性路由或遗留模型）。</li>
</ul>
<h5 id="Redistributor-重新分配器"><a href="#Redistributor-重新分配器" class="headerlink" title="Redistributor 重新分配器"></a>Redistributor 重新分配器</h5><p>对于每个连接的处理器核心（PE），都有一个重新分配器（Redistributor）。重新分配器提供以下编程接口：</p>
<ul>
<li>启用和禁用 SGI（软件生成的中断）和 PPI（处理器专用中断）。</li>
<li>设置 SGI 和 PPI 的优先级级别。</li>
<li>将每个 PPI 设置为电平触发或边沿触发。</li>
<li>将每个 SGI 和 PPI 分配给一个中断组。</li>
<li>控制 SGI 和 PPI 的状态。</li>
<li>对支持关联 LPI（低功耗中断）的中断属性和挂起状态的内存中的数据结构进行基址控制。</li>
<li>支持与连接的处理器核心的电源管理。</li>
</ul>
<h5 id="CPU-Interface"><a href="#CPU-Interface" class="headerlink" title="CPU Interface"></a>CPU Interface</h5><p>每个重新分配器都连接到一个 CPU 接口。CPU 接口提供以下编程接口：</p>
<ul>
<li>通用控制和配置，用于启用中断处理。</li>
<li>确认中断。</li>
<li>执行中断的优先级降低和停用。</li>
<li>为处理器核心设置中断优先级屏蔽。</li>
<li>定义处理器核心的抢占策略。</li>
<li>确定处理器核心最高优先级的挂起中断。</li>
</ul>
<h5 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h5><p>GIC-V3 支持四种类型的中断，分别是 SGI、PPI、SPI 和 LPI，每个中断类型的介绍如下：</p>
<ul>
<li><strong>SGI（Software Generated Interrupt，软件生成中断）</strong>：SGI 是通过向 GIC 中的 SGI 寄存器写入来生成的中断。它通常用于处理器之间的通信，允许一个 PE 发送中断给一个或多个指定的 PE，中断号 ID0 - ID15 用于 SGI。</li>
<li><strong>PPI（Private Peripheral Interrupt，私有外设中断）</strong>：针对特定 PE 的外设中断。不与其他 PE共享，中断号 ID16 - ID31 用于 PPI。</li>
<li><strong>SPI（Shared Peripheral Interrupt，共享外设中断）</strong>：全局外设中断，可以路由到指定的处理器核心（PE）或一组 PE，它允许多个 PE 接收同一个中断。中断号 ID32 - ID1019 用于 SPI，</li>
<li><strong>LPI（Locality-specific Peripheral Interrupt，特定局部外设中断）</strong>：LPI 是 GICv3 中引入的一种中断类型，与其他类型的中断有几个不同之处。LPI 总是基于消息的中断，其配置存储在内存表中，而不是寄存器中。</li>
</ul>
<h5 id="中断状态"><a href="#中断状态" class="headerlink" title="中断状态"></a>中断状态</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/image-20250828194800627.png" alt="中断处理机状态图" loading="lazy"></p>
<ul>
<li><strong>Inactive（非活动状态）</strong>：中断源当前未被触发。</li>
<li><strong>Pending（等待状态）</strong>：中断源已被触发，但尚未被处理器核心确认。</li>
<li><strong>Active（活动状态）</strong>：中断源已被触发，并且已被处理器核心确认。</li>
<li><strong>Active and Pending（活动且等待状态）</strong>：已确认一个中断实例，同时另一个中断实例正在等待处理</li>
</ul>
<h5 id="中断触发类型"><a href="#中断触发类型" class="headerlink" title="中断触发类型"></a>中断触发类型</h5><p><strong>边沿触发（Edge-triggered）</strong><br>这是一种在检测到中断信号上升沿时触发的中断，然后无论信号状态如何，都保持触发状态，直到满足本规范定义的条件来清除中断。<br><strong>电平触发（Level-sensitive）</strong><br>这是一种在中断信号电平处于活动状态时触发的中断，并且在电平不处于活动状态时取消触发。</p>
<h5 id="中断号"><a href="#中断号" class="headerlink" title="中断号"></a>中断号</h5><p>在 linux 内核中，我们<strong>使用 IRQ number 和 HW interrupt ID 两个 ID 来标识一个来自外设的中断</strong>：</p>
<ul>
<li><strong>IRQ number</strong>：CPU 需要为每一个外设中断编号，我们称之 IRQ Number。这个 <strong>IRQ number是一个虚拟的 interrupt ID，和硬件无关，仅仅是被 CPU 用来标识一个外设中断</strong>。</li>
<li><strong>HW interrupt ID</strong>：对于 GIC 中断控制器而言，它收集了多个外设的 interrupt request line 并向上传递，因此，GIC 中断控制器需要对外设中断进行编码。<strong>GIC 中断控制器用 HW interrupt ID来标识外设的中断</strong>。<strong>如果只有一个 GIC 中断控制器，那 IRQ number 和 HW interrupt ID 是可以一一对应的</strong>。</li>
</ul>
<blockquote>
<p>但如果是在 GIC 中断控制器级联的情况下，仅仅用 HW interrupt ID 就不能唯一标识一个外设中断，还需要知道该 HW interrupt ID 所属的 GIC 中断控制器（HW interrupt ID 在不同的Interrupt controller 上是会重复编码的）</p>
</blockquote>
<p>对于驱动工程师而言，我们和 CPU 视角是一样的，我们只希望得到一个 IRQ number，而不关心具体是那个 GIC中断控制器上的那个 HW interrupt ID。这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，<strong>linux kernel 中的中断子系统需要提供一个将 HW interrupt ID 映射到IRQ number 上来的机制，也就是 irq domain</strong>。</p>
<h2 id="中断申请函数"><a href="#中断申请函数" class="headerlink" title="中断申请函数"></a>中断申请函数</h2><h3 id="request-irq"><a href="#request-irq" class="headerlink" title="request_irq()"></a>request_irq()</h3><p><strong>include&#x2F;linux&#x2F;interrupt.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * request_irq - Add a handler for an interrupt line</span></span><br><span class="line"><span class="comment"> * @irq:	The interrupt line to allocate</span></span><br><span class="line"><span class="comment"> * @handler:	Function to be called when the IRQ occurs.</span></span><br><span class="line"><span class="comment"> *		Primary handler for threaded interrupts</span></span><br><span class="line"><span class="comment"> *		If NULL, the default primary handler is installed</span></span><br><span class="line"><span class="comment"> * @flags:	Handling flags</span></span><br><span class="line"><span class="comment"> * @name:	Name of the device generating this interrupt</span></span><br><span class="line"><span class="comment"> * @dev:	A cookie passed to the handler function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This call allocates an interrupt and establishes a handler; see</span></span><br><span class="line"><span class="comment"> * the documentation for request_threaded_irq() for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><code>int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);</code></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/interrupt.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 irq</strong></td>
<td>需要分配的中断线（IRQ）编号</td>
</tr>
<tr>
<td><strong>参数 handler</strong></td>
<td>当中断发生时调用的处理函数（对于线程中断，主处理程序）</td>
</tr>
<tr>
<td><strong>参数 flags</strong></td>
<td>处理中断时使用的标志位</td>
</tr>
<tr>
<td><strong>参数 name</strong></td>
<td>生成中断的设备名称</td>
</tr>
<tr>
<td><strong>参数 dev</strong></td>
<td>传递给处理函数的上下文信息（通常是设备上下文）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>为指定的中断线分配一个处理程序。对于线程化中断，使用 <code>request_threaded_irq()</code> 实现。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>成功时返回 0；失败时返回负错误代码。</td>
</tr>
</tbody></table>
<ul>
<li><strong>irq</strong> 参数用来指定要请求的中断号，例如gpio中断号需要通过 gpio_to_irq 函数映射 GPIO 引脚来获得。</li>
<li><strong>irq_handler_t handler</strong> 参数是一个函数指针，指向了中断处理程序的函数。中断处理程序是在中断事件发生时调用的函数，用于处理中断事件。</li>
<li><strong>unsigned long flags</strong>：中断处理程序的标志位<ul>
<li><strong>IRQF_TRIGGER_NONE</strong>：无触发方式，表示中断不会被触发。</li>
<li><strong>IRQF_TRIGGER_RISING</strong>：上升沿触发方式，表示中断在信号上升沿时触发。</li>
<li><strong>IRQF_TRIGGER_FALLING</strong>：下降沿触发方式，表示中断在信号下降沿时触发。</li>
<li><strong>IRQF_TRIGGER_HIGH</strong>：高电平触发方式，表示中断在信号为高电平时触发。</li>
<li><strong>IRQF_TRIGGER_LOW</strong>：低电平触发方式，表示中断在信号为低电平时触发。</li>
<li><strong>IRQF_SHARED</strong>：中断共享方式，表示中断可以被多个设备共享使用。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_TRIGGER_NONE	0x00000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_TRIGGER_RISING	0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_TRIGGER_FALLING	0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_TRIGGER_HIGH	0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_TRIGGER_LOW	0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_TRIGGER_MASK	(IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \</span></span><br><span class="line"><span class="meta">				 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQF_TRIGGER_PROBE	0x00000010</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (request_irq(irq_num, gpio_irq_handler, IRQF_TRIGGER_RISING,</span><br><span class="line">			<span class="string">&quot;irq_test&quot;</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;Failed to request IRQ %d\n&quot;</span>, irq_num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断失败，释放GPIO引脚</span></span><br><span class="line">    gpio_free(GPIO_PIN);</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="gpio-to-irq"><a href="#gpio-to-irq" class="headerlink" title="gpio_to_irq()"></a>gpio_to_irq()</h3><p><strong>include&#x2F;linux&#x2F;gpio.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">gpio_to_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gpio)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __gpio_to_irq(gpio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gpio_to_irq 函数用于<strong>将 GPIO 引脚的编号（GPIO pin number）转换为对应的中断请求号（interrupt request number）</strong>。</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><code>int gpio_to_irq(unsigned int gpio);</code></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/gpio.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 gpio</strong></td>
<td>GPIO（通用输入输出）编号</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>将一个 GPIO 引脚转换为对应的中断线编号。该函数依赖于底层实现的 <code>__gpio_to_irq()</code> 来进行转换。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>对应的中断线编号，若转换失败则返回负值。</td>
</tr>
</tbody></table>
<h3 id="free-irq"><a href="#free-irq" class="headerlink" title="free_irq()"></a>free_irq()</h3><p><strong>include&#x2F;linux&#x2F;interrupt.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">void</span> *<span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><code>void free_irq(unsigned int irq, void *dev_id);</code></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/interrupt.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 irq</strong></td>
<td>要释放的中断线编号</td>
</tr>
<tr>
<td><strong>参数 dev_id</strong></td>
<td>与该中断关联的设备上下文（通常是设备的指针或标识符）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>释放一个已分配的中断线，取消与该中断线相关联的中断处理函数。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值。</td>
</tr>
</tbody></table>
<h3 id="中断处理函数"><a href="#中断处理函数" class="headerlink" title="中断处理函数"></a>中断处理函数</h3><p><strong>include&#x2F;linux&#x2F;interrupt.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">irqreturn_t</span> <span class="params">(*<span class="type">irq_handler_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数功能：</p>
<p>handler 函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。</p>
</li>
<li><p>参数说明：</p>
<ul>
<li><code>irq</code>：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器。</li>
<li><code>dev_id</code>：是一个 void 类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源。</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li><strong>irqreturn_t</strong> 是一个特定类型的枚举值，<strong>用于表示中断服务函数的返回状态</strong>。它可以有以下几种取值：<ul>
<li><strong>IRQ_NONE</strong>：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求。</li>
<li><strong>IRQ_HANDLED</strong>：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理。</li>
<li><strong>IRQ_WAKE_THREAD</strong>：表示中断服务函数已处理该中断，并且请求唤醒一个内核线程来继续执行进一步的处理。这在一些需要长时间处理的中断情况下使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>iTOP-RK3568 有 5 组 GPIO bank：GPIO0 ~ GPIO4，每组又以 A0 ~ A7, B0 ~ B7, C0 ~ C7, D0 ~ D7 作为编号区分,常用以下公式计算引脚：<br>LCD 触摸屏对应的中断引脚标号为 TP_INT_L_GPIO3_A5，对应的计算过程如下所示：</p>
<p><strong>GPIO pin 脚计算公式</strong>：</p>
<p>$$pin &#x3D; bank * 32 + number$$</p>
<p><strong>GPIO 小组编号计算公式：</strong></p>
<p>$$number &#x3D; group * 8 + X$$</p>
<p>对于GPIO3_A5，3表示bank&#x3D;3，A表示group&#x3D;0，5表示X&#x3D;5</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_PIN 101</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt occurred on GPIO %d\n&quot;</span>, GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;This is irq_handler\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> irq_num;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Initializing GPIO Interrupt Driver\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将GPIO引脚映射到中断号</span></span><br><span class="line">    irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO %d mapped to IRQ %d\n&quot;</span>, GPIO_PIN, irq_num);</span><br><span class="line">    <span class="keyword">if</span> (irq_num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求中断</span></span><br><span class="line">    <span class="keyword">if</span> (request_irq(irq_num, gpio_irq_handler, IRQF_TRIGGER_RISING, <span class="string">&quot;irq_test&quot;</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ %d\n&quot;</span>, irq_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求中断失败，释放GPIO引脚</span></span><br><span class="line">        gpio_free(GPIO_PIN);</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">interrupt_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> irq_num = gpio_to_irq(GPIO_PIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    free_irq(irq_num, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO Interrupt Driver exited successfully\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_init);</span><br><span class="line">module_exit(interrupt_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="中断申请流程"><a href="#中断申请流程" class="headerlink" title="中断申请流程"></a>中断申请流程</h2><h3 id="request-irq-1"><a href="#request-irq-1" class="headerlink" title="request_irq()"></a>request_irq()</h3><p><strong>include&#x2F;linux&#x2F;irq.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="request-threaded-irq"><a href="#request-threaded-irq" class="headerlink" title="request_threaded_irq()"></a>request_threaded_irq()</h3><p><strong>kernel&#x2F;irq&#x2F;manage.c</strong></p>
<p><code>request_threaded_irq</code> 函数是 Linux 内核提供的一个功能强大的函数，用于请求分配一个中断，并将中断处理程序与该中断关联起来。该函数的主要作用是在系统中注册中断处理函数，以响应对应中断的发生。</p>
<p>以下是 <code>request_threaded_irq</code> 函数的功能和作用的详细介绍：</p>
<ul>
<li><strong>中断请求</strong>：<code>request_threaded_irq</code> 函数用于请求一个中断。它会向内核注册对应中断号的中断处理函数，并为该中断分配必要的资源。中断号是标识特定硬件中断的唯一标识符。</li>
<li><strong>中断处理函数关联</strong>：通过 <code>handler</code> 参数，将中断处理函数与中断号关联起来。中断处理函数是一个预定义的函数，用于处理中断事件。当中断发生时，内核将调用该函数来处理中断事件。</li>
<li><strong>线程化中断处理</strong>：<code>request_threaded_irq</code> 函数还支持使用线程化中断处理函数。通过指定 <code>thread_fn</code> 参数，可以在一个内核线程上下文中异步执行较长时间的中断处理或延迟敏感的工作。这有助于避免在中断上下文中阻塞时间过长。</li>
<li><strong>中断属性设置</strong>：通过 <code>irqflags</code> 参数，可以设置中断处理的各种属性和标志。例如，可以指定中断触发方式（上升沿、下降沿、边沿触发等）、中断类型（边沿触发中断、电平触发中断等）以及其他特定的中断行为。</li>
<li><strong>设备标识关联</strong>：通过 <code>dev_id</code> 参数，可以将中断处理与特定设备关联起来。这样可以在中断处理函数中访问与设备相关的数据。设备标识符可以是指向设备结构体或其他与设备相关的数据的指针。</li>
<li><strong>错误处理</strong>：<code>request_threaded_irq</code> 函数会返回一个整数值，用于指示中断请求的结果。如果中断请求成功，返回值为 0；如果中断请求失败，则返回一个负数错误代码，表示失败的原因。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span><span class="comment">// 中断动作结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span><span class="comment">// 中断描述符指针</span></span><br><span class="line">	<span class="type">int</span> retval; <span class="comment">// 返回值</span></span><br><span class="line"><span class="comment">// 检查中断号是否为未连接状态</span></span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sanity-check: shared interrupts must pass in a real dev-ID,</span></span><br><span class="line"><span class="comment">	 * otherwise we&#x27;ll have trouble later trying to figure out</span></span><br><span class="line"><span class="comment">	 * which interrupt is which (messes up the interrupt freeing</span></span><br><span class="line"><span class="comment">	 * logic etc).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also shared interrupts do not go well with disabling auto enable.</span></span><br><span class="line"><span class="comment">	 * The sharing interrupt might request it while it&#x27;s still disabled</span></span><br><span class="line"><span class="comment">	 * and then wait for interrupts forever.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Also IRQF_COND_SUSPEND only makes sense for shared interrupts and</span></span><br><span class="line"><span class="comment">	 * it cannot be set along with IRQF_NO_SUSPEND.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 检查中断标志的有效性</span></span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_NO_AUTOEN)) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 获取中断号的中断描述符</span></span><br><span class="line">	desc = irq_to_desc(irq);</span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 检查中断设置是否可以进行中断请求，以及是否为每个 CPU 分配唯一设备 ID</span></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="comment">// 如果未指定中断处理函数，则使用默认的主处理函数</span></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 分配并初始化中断动作数据结构</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;<span class="comment">// 中断处理函数</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;<span class="comment">// 线程处理函数</span></span><br><span class="line">	action-&gt;flags = irqflags;<span class="comment">// 中断标志</span></span><br><span class="line">	action-&gt;name = devname;<span class="comment">// 设备名称</span></span><br><span class="line">	action-&gt;dev_id = dev_id;<span class="comment">// 设备 ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取中断的电源管理引用计数</span></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 设置中断并将中断动作与中断描述符关联</span></span><br><span class="line">	retval = __setup_irq(irq, desc, action);</span><br><span class="line"><span class="comment">// 处理中断设置失败的情况</span></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);<span class="comment">//调用 irq_chip_pm_put 函数释放中断的电源管理引用计数</span></span><br><span class="line">		kfree(action-&gt;secondary);<span class="comment">//释放次要中断动作的内存空间</span></span><br><span class="line">		kfree(action);<span class="comment">//释放中断动作的内存空间</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * It&#x27;s a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment">		 * to happen immediately, so let&#x27;s make sure....</span></span><br><span class="line"><span class="comment">		 * We disable the irq to make sure that a &#x27;real&#x27; IRQ doesn&#x27;t</span></span><br><span class="line"><span class="comment">		 * run in parallel with our fake.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line"></span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(request_threaded_irq);</span><br></pre></td></tr></table></figure>

<h3 id="irq-desc-结构体"><a href="#irq-desc-结构体" class="headerlink" title="irq_desc 结构体"></a>irq_desc 结构体</h3><p><strong>include&#x2F;linux&#x2F;irqdesc.h</strong></p>
<p>irq_desc 结构体是 Linux 内核中用于描述中断的数据结构之一。每个硬件中断都有一个对应的 irq_desc 实例，它用于记录与该中断相关的各种信息和状态。该结构体的主要功能是管理中断处理函数、中断行为以及与中断处理相关的其他数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span> <span class="title">irq_common_data</span>;</span>  <span class="comment">// 常见的中断数据，包含了中断的标识、类型等信息。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> <span class="title">irq_data</span>;</span>                <span class="comment">// 具体的中断数据，包括中断的状态、触发方式等。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> __percpu *kstat_irqs;       <span class="comment">// 该中断的统计信息，每个 CPU 上的统计数据。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">irq_flow_handler_t</span> handle_irq;           <span class="comment">// 中断处理程序的指针，处理该中断的实际函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span>                <span class="comment">// 中断处理动作链表，用于存储关联的中断处理程序。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> status_use_accessors;       <span class="comment">// 状态字段，指示是否通过访问器来读取/修改状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> core_internal_state__do_not_mess_with_it;  <span class="comment">// 内部状态字段，直接操作可能会导致不稳定。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> depth;                      <span class="comment">// 嵌套中断禁用的计数器。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> wake_depth;                 <span class="comment">// 嵌套的唤醒使能的计数器。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tot_count;                  <span class="comment">// 中断的总计数。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq_count;                  <span class="comment">// 用于检测有问题的中断计数。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> last_unhandled;            <span class="comment">// 处理未被处理的中断的计时器。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irqs_unhandled;             <span class="comment">// 记录未被处理的中断次数。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_t</span> threads_handled;                <span class="comment">// 原子计数，表示处理的线程数。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> threads_handled_last;                <span class="comment">// 上次处理的线程数（用于调试/统计）。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">raw_spinlock_t</span> lock;                     <span class="comment">// 用于保护该中断描述符的自旋锁。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">percpu_enabled</span>;</span>          <span class="comment">// 每个 CPU 上启用的 CPU 掩码。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">percpu_affinity</span>;</span>   <span class="comment">// 每个 CPU 上的中断亲和性掩码。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpumask</span> *<span class="title">affinity_hint</span>;</span>     <span class="comment">// 中断亲和性的提示。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_affinity_notify</span> *<span class="title">affinity_notify</span>;</span>  <span class="comment">// 处理亲和性变更的通知结构体。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PENDING_IRQ</span></span><br><span class="line">    <span class="type">cpumask_var_t</span> pending_mask;              <span class="comment">// 表示当前有待处理的中断掩码。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> threads_oneshot;           <span class="comment">// 用于记录一次性线程的状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">atomic_t</span> threads_active;                 <span class="comment">// 当前活跃的线程数（原子操作）。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wait_for_threads;      <span class="comment">// 等待线程处理的队列头。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM_SLEEP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_actions;                <span class="comment">// 中断处理动作的数量（与电源管理相关）。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> no_suspend_depth;           <span class="comment">// 中断不能在何时挂起的深度。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cond_suspend_depth;         <span class="comment">// 有条件地挂起的深度。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> force_resume_depth;         <span class="comment">// 强制恢复的深度。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">dir</span>;</span>             <span class="comment">// 中断的 proc 文件系统入口，用于调试和监控。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_IRQ_DEBUGFS</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_file</span>;</span>            <span class="comment">// 中断的 debugfs 文件入口，用于调试。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dev_name;                   <span class="comment">// 设备的名称，通常用于调试。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSE_IRQ</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>                    <span class="comment">// 用于延迟释放中断资源的 RCU 头。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>                    <span class="comment">// 内核对象，用于关联和管理该中断描述符。</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">request_mutex</span>;</span>             <span class="comment">// 请求中断时的互斥锁，保护中断请求的并发访问。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> parent_irq;                          <span class="comment">// 如果该中断是子中断，它的父中断 ID。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                   <span class="comment">// 关联的模块指针，表示该中断由哪个模块负责。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                       <span class="comment">// 中断的名称，便于调试和识别。</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;  <span class="comment">// 用于确保该结构体在 SMP（对称多处理）系统中的缓存对齐。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>irq_desc</code> 结构体的主要作用和功能：</p>
<ul>
<li><strong>中断处理函数管理</strong>：<code>irq_desc</code> 结构体中的 <code>handle_irq</code> 字段保存中断处理函数的指针。当硬件触发中断时，内核会调用该函数来处理中断事件。</li>
<li><strong>中断行为管理</strong>：<code>irq_desc</code> 结构体中的 <code>action</code> 字段是一个指向中断行为列表的指针。中断行为是一组回调函数，用于注册、注销和处理与中断相关的事件。</li>
<li><strong>中断统计信息</strong>：<code>irq_desc</code> 结构体中的 <code>kstat_irqs</code> 字段是一个指向中断统计信息的指针。该信息用于记录中断事件的发生次数和处理情况，可以帮助分析中断的性能和行为。</li>
<li><strong>中断数据管理</strong>：<code>irq_desc</code> 结构体中的 <code>irq_data</code> 字段保存了与中断相关的数据，如中断号、中断类型等。这些数据用于识别和管理中断。</li>
<li><strong>通用中断数据管理</strong>：<code>irq_desc</code> 结构体中的 <code>irq_common_data</code> 字段保存了与中断处理相关的通用数据，如中断控制器、中断屏蔽等。这些数据用于处理和控制中断的行为。</li>
<li><strong>中断状态管理</strong>：<code>irq_desc</code> 结构体中的其他字段用于管理中断的状态，如嵌套中断禁用计数、唤醒使能计数等。这些状态信息帮助内核跟踪和管理中断的状态变化。通过使用 <code>irq_desc</code> 结构体，内核可以有效地管理和处理系统中的硬件中断。它提供了一个统一的接口，用于注册和处理中断处理函数、管理中断行为，并提供了必要的信息和数据结构来监视和控制中断的行为和状态。</li>
</ul>
<p>在 <code>irq_desc</code> 结构体中最重要的就是 <code>action</code> 字段。</p>
<h3 id="irqaction-结构体"><a href="#irqaction-结构体" class="headerlink" title="irqaction 结构体"></a>irqaction 结构体</h3><p><strong>include&#x2F;linux&#x2F;interrupt.h</strong></p>
<p>irqaction 结构体是 Linux 内核中用于描述中断行为的数据结构之一。它用于定义中断处理过程中的回调函数和相关属性。irqaction 结构体的主要功能是管理与特定中断相关的行为和处理函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">    <span class="type">irq_handler_t</span> handler;                 <span class="comment">// 中断处理函数的指针。用于处理中断的回调函数，通常是一个普通的中断服务程序（ISR）。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *dev_id;                           <span class="comment">// 设备 ID。通常是一个指向设备结构的指针（或其他类型的标识符），用于唯一标识中断关联的设备。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __percpu *percpu_dev_id;           <span class="comment">// 每个 CPU 上的设备 ID，适用于多处理器系统，存储每个 CPU 上的设备标识。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">next</span>;</span>                 <span class="comment">// 用于共享中断的链接。每个中断号可能对应多个 irqaction，这个字段指向下一个 irqaction。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">irq_handler_t</span> thread_fn;                <span class="comment">// 线程化中断的处理函数。对于线程化中断，`thread_fn` 用于处理相关的工作。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span>             <span class="comment">// 线程指针。对于线程化中断，这个字段指向分配给该中断的线程。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">secondary</span>;</span>            <span class="comment">// 指向 secondary irqaction 的指针。用于强制将某些中断操作放入线程中处理。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq;                       <span class="comment">// 中断号，标识该 irqaction 关联的中断。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;                     <span class="comment">// 中断标志。`IRQF_*` 标志用于控制中断的行为，如是否允许共享、是否在内核线程中处理等。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> thread_flags;             <span class="comment">// 线程标志，表示与线程化中断相关的设置或状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> thread_mask;              <span class="comment">// 线程掩码，用于跟踪线程的活动状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;                       <span class="comment">// 中断处理动作的名称，通常是设备的名称，用于调试和标识。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">dir</span>;</span>             <span class="comment">// 指向 proc 文件系统的条目，用于在 `/proc/irq/NN/name` 中显示中断信息。</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;    <span class="comment">// 确保在多核系统中该结构体按照缓存行对齐。</span></span><br></pre></td></tr></table></figure>

<p>以下是 <code>irqaction</code> 结构体的主要作用和功能：</p>
<ul>
<li><strong>中断处理函数管理</strong>：<code>irqaction</code> 结构体中的 <code>handler</code> 字段保存中断处理函数的指针。该函数在中断发生时被调用，用于处理中断事件。</li>
<li><strong>中断处理标志管理</strong>：<code>irqaction</code> 结构体中的 <code>flags</code> 字段用于指定中断处理的各种属性和标志。这些标志控制中断处理的行为，例如触发方式、中断类型等。</li>
<li><strong>设备标识符管理</strong>：<code>irqaction</code> 结构体中的 <code>dev_id</code> 字段用于保存与中断处理相关的设备标识符。它可以是指向设备结构体或其他与设备相关的数据的指针，用于将中断处理与特定设备关联起来。</li>
<li><strong>中断行为链表管理</strong>：<code>irqaction</code> 结构体中的 <code>next</code> 字段是一个指向下一个 <code>irqaction</code> 结构体的指针，用于构建中断行为的链表。这样可以将多个中断处理函数链接在一起，以便在中断发生时按顺序调用它们</li>
</ul>
<h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>在 Linux 内核中，<strong>tasklet 是一种特殊的软中断机制</strong>，被广泛用于处理中断下文相关的任务。</p>
<p>它是一种常见且有效的方法，在多核处理系统上可以避免并发问题。<strong>Tasklet 绑定的函数在同一时间只能在一个 CPU 上运行，因此不会出现并发冲突</strong>。</p>
<p>然而，需要注意的是，tasklet 绑定的函数中不能调用可能导致休眠的函数，否则可能引起内核异常。</p>
<blockquote>
<p>This API is deprecated.</p>
</blockquote>
<p><strong>include&#x2F;linux&#x2F;interrupt.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Tasklets --- multithreaded analogue of BHs.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This API is deprecated. Please consider using threaded IRQs instead:</span></span><br><span class="line"><span class="comment">   https://lore.kernel.org/lkml/20200716081538.2sivhkj4hcyrusem@linutronix.de</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Main feature differing them of generic softirqs: tasklet</span></span><br><span class="line"><span class="comment">   is running only on one CPU simultaneously.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Main feature differing them of BHs: different tasklets</span></span><br><span class="line"><span class="comment">   may be run simultaneously on different CPUs.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Properties:</span></span><br><span class="line"><span class="comment">   * If tasklet_schedule() is called, then tasklet is guaranteed</span></span><br><span class="line"><span class="comment">     to be executed on some cpu at least once after this.</span></span><br><span class="line"><span class="comment">   * If the tasklet is already scheduled, but its execution is still not</span></span><br><span class="line"><span class="comment">     started, it will be executed only once.</span></span><br><span class="line"><span class="comment">   * If this tasklet is already running on another CPU (or schedule is called</span></span><br><span class="line"><span class="comment">     from tasklet itself), it is rescheduled for later.</span></span><br><span class="line"><span class="comment">   * Tasklet is strictly serialized wrt itself, but not</span></span><br><span class="line"><span class="comment">     wrt another tasklets. If client needs some intertask synchronization,</span></span><br><span class="line"><span class="comment">     he makes it with spinlocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">bool</span> use_callback;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span> data);</span><br><span class="line">		<span class="type">void</span> (*callback)(<span class="keyword">struct</span> tasklet_struct *t);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET(name, _callback)		\</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123;				\</span></span><br><span class="line"><span class="meta">	.count = ATOMIC_INIT(0),			\</span></span><br><span class="line"><span class="meta">	.callback = _callback,				\</span></span><br><span class="line"><span class="meta">	.use_callback = true,				\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_DISABLED(name, _callback)	\</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123;				\</span></span><br><span class="line"><span class="meta">	.count = ATOMIC_INIT(1),			\</span></span><br><span class="line"><span class="meta">	.callback = _callback,				\</span></span><br><span class="line"><span class="meta">	.use_callback = true,				\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> from_tasklet(var, callback_tasklet, tasklet_fieldname)	\</span></span><br><span class="line"><span class="meta">	container_of(callback_tasklet, typeof(*var), tasklet_fieldname)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_OLD(name, _func)		\</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123;				\</span></span><br><span class="line"><span class="meta">	.count = ATOMIC_INIT(0),			\</span></span><br><span class="line"><span class="meta">	.func = _func,					\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_DISABLED_OLD(name, _func)	\</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123;				\</span></span><br><span class="line"><span class="meta">	.count = ATOMIC_INIT(1),			\</span></span><br><span class="line"><span class="meta">	.func = _func,					\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>tasklet_struct</code> 结构体包含以下成员：</p>
<ul>
<li><code>next</code>:指向下一个 tasklet 的指针，用于形成链表结构，以便内核中可以同时管理多个tasklet。</li>
<li><code>state</code>:表示 tasklet 的当前状态。</li>
<li><code>count</code>:用于引用计数，用于确保 tasklet 在多个地方调度或取消调度时的正确处理。</li>
<li><code>func</code>:指向 tasklet 绑定的函数的指针，该函数将在 tasklet 执行时被调用。</li>
<li><code>data</code>:传递给 tasklet 绑定函数的参数，5.10版本内核使用callback这个函数</li>
</ul>
<p>此外，为了方便，还定义了 <code>tasklet_t</code> 类型作为 <code>struct tasklet_struct</code> 的别名。</p>
<h3 id="静态初始化-DECLARE-TASKLET"><a href="#静态初始化-DECLARE-TASKLET" class="headerlink" title="静态初始化 DECLARE_TASKLET"></a>静态初始化 DECLARE_TASKLET</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET(name, _callback)		\</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123;				\</span></span><br><span class="line"><span class="meta">	.count = ATOMIC_INIT(0),			\</span></span><br><span class="line"><span class="meta">	.callback = _callback,				\</span></span><br><span class="line"><span class="meta">	.use_callback = true,				\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，name 是 tasklet 的名称，func 是 tasklet 的处理函数，data 是传递给处理函数的参数(5.10版本没有data)。初始化状态为使能状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_DISABLED(name, _callback)	\</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123;				\</span></span><br><span class="line"><span class="meta">	.count = ATOMIC_INIT(1),			\</span></span><br><span class="line"><span class="meta">	.callback = _callback,				\</span></span><br><span class="line"><span class="meta">	.use_callback = true,				\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中，name 是 tasklet 的名称，func 是 tasklet 的处理函数，data 是传递给处理函数的参数(5.10版本没有data)。初始化状态为非使能状态。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 tasklet 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Tasklet 处理逻辑</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化 tasklet</span></span><br><span class="line">DECLARE_TASKLET(my_tasklet, my_tasklet_handler);</span><br><span class="line"><span class="comment">// 驱动程序的其他代码</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>my_tasklet</code> 是 tasklet 的名称，<code>my_tasklet_handler</code> 是 tasklet 的处理函数</p>
<p>但是需要注意的是，<strong>使用 DECLARE_TASKLET 静态初始化的 tasklet无法在运行时动态销毁</strong>，因此在不需要 tasklet 时，应该避免使用此方法。如果需要在运行时销毁 tasklet，应使用 <code>tasklet_init</code> 和 <code>tasklet_kill</code> 函数进行动态初始化和销毁。</p>
<h3 id="动态初始化-task-init"><a href="#动态初始化-task-init" class="headerlink" title="动态初始化 task_init"></a>动态初始化 task_init</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t,</span></span><br><span class="line"><span class="params">			 <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，t 是指向 tasklet 结构体的指针，func 是 tasklet 的处理函数，data 是传递给处理函数的参数</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义 tasklet 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Tasklet 处理逻辑</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 tasklet 结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 tasklet</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_handler, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 驱动程序的其他代码</span></span><br></pre></td></tr></table></figure>

<p>在示例中，我们首先定义了 <code>my_tasklet_handler</code> 作为 tasklet 的处理函数。然后，声明了一个名为 <code>my_tasklet</code> 的 tasklet 结构体。接下来，通过调用 <code>tasklet_init</code> 函数，进行动态初始化。</p>
<p>通过使用 <code>tasklet_init</code> 函数，我们可以在运行时动态创建和初始化 tasklet。这样，我们可以根据需要灵活地管理和控制 tasklet 的生命周期。在不再需要 tasklet 时，可以使用 <code>tasklet_kill</code>函数进行销毁，以释放相关资源。</p>
<h3 id="关闭函数-tasklet-disable"><a href="#关闭函数-tasklet-disable" class="headerlink" title="关闭函数 tasklet_disable"></a>关闭函数 tasklet_disable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_disable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	tasklet_disable_nosync(t);</span><br><span class="line">	tasklet_unlock_wait(t);</span><br><span class="line">	smp_mb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，t 是指向 tasklet 结构体的指针。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 tasklet 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Tasklet 处理逻辑</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 tasklet 结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 tasklet</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_handler, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭 tasklet</span></span><br><span class="line">tasklet_disable(&amp;my_tasklet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 驱动程序的其他代码</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先定义了 <code>my_tasklet_handler</code> 作为 tasklet 的处理函数。然后，声明了一个名为 <code>my_tasklet</code> 的 tasklet 结构体，并使用 <code>tasklet_init</code> 函数对其进行初始化。</p>
<p>最后，通过调用 <code>tasklet_disable</code> 函数，我们关闭了 <code>my_tasklet</code>。</p>
<p>关闭 tasklet 后，即使调用 <code>tasklet_schedule</code> 函数触发 tasklet，tasklet 的处理函数也不会再被执行。这可以<strong>用于临时暂停或停止 tasklet 的执行，直到再次启用</strong>（通过调用 tasklet_enable函数）。</p>
<div class="tip warning faa-horizontal animated-hover"><p>需要注意的是，关闭 tasklet 并不会销毁 tasklet 结构体，因此可以随时通过调用 <strong>tasklet_enable</strong> 函数重新启用 tasklet，或者调用 <strong>tasklet_kill</strong> 函数来销毁 tasklet</p>
</div>



<h3 id="使能函数-tasklet-enable"><a href="#使能函数-tasklet-enable" class="headerlink" title="使能函数 tasklet_enable"></a>使能函数 tasklet_enable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_enable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	smp_mb__before_atomic();</span><br><span class="line">	<span class="type">atomic_dec</span>(&amp;t-&gt;count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，t 是指向 tasklet 结构体的指针</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 tasklet 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Tasklet 处理逻辑</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 tasklet 结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 tasklet</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_handler, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能 tasklet</span></span><br><span class="line">tasklet_enable(&amp;my_tasklet);</span><br></pre></td></tr></table></figure>

<p>使能 tasklet 后，如果调用 <code>tasklet_schedule</code> 函数触发 tasklet，则 tasklet 的处理函数将会被执行。这样，tasklet 将开始按计划执行其处理逻辑。</p>
<p>需要注意的是，使能 tasklet 并不会自动触发 tasklet 的执行，而是通过调用 <code>tasklet_schedule</code> 函数来触发。同时，可以使用 <code>tasklet_disable</code> 函数来临时暂停或停止 tasklet 的执行。</p>
<p>如果需要永久停止 tasklet 的执行并释放相关资源，则应调用 <code>tasklet_kill</code> 函数来销毁 tasklet。</p>
<h3 id="调度函数-tasklet-schedule"><a href="#调度函数-tasklet-schedule" class="headerlink" title="调度函数 tasklet_schedule"></a>调度函数 tasklet_schedule</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __tasklet_schedule(<span class="keyword">struct</span> tasklet_struct *t);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">		__tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> __tasklet_hi_schedule(<span class="keyword">struct</span> tasklet_struct *t);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_hi_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">		__tasklet_hi_schedule(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，t 是指向 tasklet 结构体的指针。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义 tasklet 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Tasklet 处理逻辑</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 tasklet 结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"><span class="comment">// 初始化 tasklet</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_handler, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 调度 tasklet 执行</span></span><br><span class="line">tasklet_schedule(&amp;my_tasklet);</span><br><span class="line"><span class="comment">// 驱动程序的其他代码</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，调度 tasklet <strong>只是将 tasklet 标记为需要执行</strong>，<strong>并不会立即执行 tasklet 的处理函数。实际的执行时间取决于内核的调度和处理机制</strong>。</p>
<h3 id="销毁函数-tasklet-kill"><a href="#销毁函数-tasklet-kill" class="headerlink" title="销毁函数 tasklet_kill"></a>销毁函数 tasklet_kill</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_kill_immediate</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t, <span class="type">unsigned</span> <span class="type">int</span> cpu)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，t 是指向 tasklet 结构体的指针</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="comment">// 定义 tasklet 处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Tasklet 处理逻辑</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 tasklet 结构体</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"><span class="comment">// 初始化 tasklet</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_handler, <span class="number">0</span>);</span><br><span class="line">tasklet_disable(&amp;my_tasklet);</span><br><span class="line"><span class="comment">// 销毁 tasklet</span></span><br><span class="line">tasklet_kill(&amp;my_tasklet);</span><br><span class="line"><span class="comment">// 驱动程序的其他代码</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>tasklet_kill</code> 函数会释放 tasklet 所占用的资源，并将 tasklet 标记为无效。因此，销毁后的 tasklet 不能再被使用。</p>
<div class="tip warning faa-horizontal animated-hover"><p>需要 注意 的是 ，<strong>在 销毁 tasklet 之前，应该确保该 tasklet 已经被失能</strong>（通过调用 <strong>tasklet_disable</strong> 函数）。否则，销毁一个正在执行的 tasklet 可能导致内核崩溃或其他错误。</p>
</div>

<p>一旦销毁了 tasklet，如果需要再次使用 tasklet，需要重新进行初始化（通过调用 <code>tasklet_init</code> 函数）</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_GPIO_PIN 101</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> irq;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">mytasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;test_irq_handler is called\n&quot;</span>);</span><br><span class="line">        tasklet_schedule(&amp;mytasklet);</span><br><span class="line">        <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mytasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;data is %lu\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">tasklet_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        irq = gpio_to_irq(TEST_GPIO_PIN);</span><br><span class="line">        pr_info(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">        <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        ret = request_irq(irq, test_irq_handler, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">        tasklet_init(&amp;mytasklet, mytasklet_func, <span class="number">1</span>);</span><br><span class="line">        tasklet_enable(&amp;mytasklet);<span class="comment">// optional: init之后默认是enable的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">tasklet_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        tasklet_disable(&amp;mytasklet);</span><br><span class="line">        tasklet_kill(&amp;mytasklet);</span><br><span class="line">        free_irq(irq, <span class="literal">NULL</span>);</span><br><span class="line">        printk(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(tasklet_test_init);</span><br><span class="line">module_exit(tasklet_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@outlook.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a test sample for tasklet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><blockquote>
<p><strong>软件中断（software interrupt）&#x3D; 由软件触发的“异常&#x2F;中断”机制，用于进入内核。</strong></p>
<p><strong>软中断（softirq）&#x3D; Linux 内核内部的一种“下半部”执行机制，用于处理高频短任务。</strong></p>
</blockquote>
<p>软中断是 Linux 内核提供的一种<strong>中断下半部机制</strong>，用于执行高频、可延后的任务。</p>
<p><strong>它不是 CPU 的中断，也不是异常，是内核自己的调度机制。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/interrupt.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ,</span><br><span class="line">	NET_RX_SOFTIRQ,</span><br><span class="line">	BLOCK_SOFTIRQ,</span><br><span class="line">	IRQ_POLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ, <span class="comment">// TASKLET的软中断</span></span><br><span class="line">	SCHED_SOFTIRQ,</span><br><span class="line">	HRTIMER_SOFTIRQ,</span><br><span class="line">	RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个枚举类型，用于标识软中断的不同类型或优先级。每个枚举常量对应一个特定的软中断类型。</p>
<p>枚举常量的含义：</p>
<ul>
<li><code>HI_SOFTIRQ</code>：高优先级软中断</li>
<li><code>TIMER_SOFTIRQ</code>：定时器软中断</li>
<li><code>NET_TX_SOFTIRQ</code>：网络传输发送软中断</li>
<li><code>NET_RX_SOFTIRQ</code>：网络传输接收软中断</li>
<li><code>BLOCK_SOFTIRQ</code>：块设备软中断</li>
<li><code>IRQ_POLL_SOFTIRQ</code>：中断轮询软中断</li>
<li><code>TASKLET_SOFTIRQ</code>：<strong>任务软中断</strong></li>
<li><code>CHED_SOFTIRQ</code>：调度软中断</li>
<li><code>HRTIMER_SOFTIRQ</code>: Unused, but kept as tools rely on the numbering. Sigh!</li>
<li><code>RCU_SOFTIRQ</code>: Preferable RCU should always be the last softirq</li>
<li><code>NR_SOFTIRQS</code>：表示软中断的总数，用于指示软中断类型的数据</li>
</ul>
<p>中断号的优先级越小，代表优先级越高。在驱动代码中，我们可以使用 Linux 驱动代码中上述的软中断，当然我们也可以自己添加软中断。我们添加一个自定义的软中断，如下所示，TEST_SOFTIRQ 为自定义添加的软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/interrupt.h</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ,</span><br><span class="line">	NET_RX_SOFTIRQ,</span><br><span class="line">	BLOCK_SOFTIRQ,</span><br><span class="line">	IRQ_POLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ,</span><br><span class="line">	SCHED_SOFTIRQ,</span><br><span class="line">	HRTIMER_SOFTIRQ, <span class="comment">/* Unused, but kept as tools rely on thenumbering. Sigh! */</span></span><br><span class="line">	TEST_SOFTIRQ, <span class="comment">// 添加的自定义软中断</span></span><br><span class="line">	RCU_SOFTIRQ, <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尽管我们添加一个自定义的软中断非常简单，但是<strong>Linux 内核的开发者并不希望我们这样去做，如果我们要用软中断，建议使用tasklet</strong>。</p>
<p>添加软中断后要重新编译Linux源码。并且软中断的接口函数是没有导出符号表的，如果要使用需要在<code>kernel/softirq.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/softirq.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line">&#123;</span><br><span class="line">	softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(open_softirq)</span><br></pre></td></tr></table></figure>

<h3 id="软中断接口函数"><a href="#软中断接口函数" class="headerlink" title="软中断接口函数"></a>软中断接口函数</h3><h4 id="open-softirq"><a href="#open-softirq" class="headerlink" title="open_softirq"></a>open_softirq</h4><p>注册软中断，使用 open_softirq 函数，函数原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nr</code>: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</li>
<li><code>action</code>: 指向一个函数的指针，这个函数将作为软中断的处理程序。该函数接受一个 struct</li>
<li><code>softirq_action</code> 类型的参数。</li>
</ul>
<h4 id="raise-softirq"><a href="#raise-softirq" class="headerlink" title="raise_softirq"></a>raise_softirq</h4><p>触发软中断，使用 <code>raise_softirq</code> 函数，函数原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nr</code>: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</li>
</ul>
<h4 id="raise-softirq-irqoff"><a href="#raise-softirq-irqoff" class="headerlink" title="raise_softirq_irqoff"></a>raise_softirq_irqoff</h4><p>在禁用硬件中断的情况下，触发软中断使用 raise_softirq_irqoff 函数，函数原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq_irqoff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nr</code>: 软中断的编号或优先级。它是一个整数，表示要注册的软中断的标识符。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 软中断处理程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">testsoft_func</span><span class="params">(<span class="keyword">struct</span> softirq_action *softirq_action)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;This is testsoft_func\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;This is test_interrupt\n&quot;</span>);</span><br><span class="line">  raise_softirq(TEST_SOFTIRQ); <span class="comment">// 触发软中断</span></span><br><span class="line">  <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">interrupt_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  irq = gpio_to_irq(<span class="number">101</span>); <span class="comment">// 将GPIO映射为中断号</span></span><br><span class="line">  printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">  <span class="comment">// 请求中断</span></span><br><span class="line">  ret = request_irq(irq, test_interrupt, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;request_irq is error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注册软中断处理函数</span></span><br><span class="line">  open_softirq(TEST_SOFTIRQ, testsoft_func);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">interrupt_irq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  free_irq(irq, <span class="literal">NULL</span>); <span class="comment">// 释放中断</span></span><br><span class="line">  printk(<span class="string">&quot;bye bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_irq_init);</span><br><span class="line">module_exit(interrupt_irq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@outlook.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Tis is a test sample for softirq&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="tasklet分析"><a href="#tasklet分析" class="headerlink" title="tasklet分析"></a>tasklet分析</h3><p>Tasklet 是 Linux 内核中的一种软中断机制，它可以被看作是一种轻量级的延迟处理机制。它是通过软中断控制结构来实现的，因此也被称为软中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/softirq.c</span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">softirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line"><span class="comment">// 初始化每个可能的 CPU 的 tasklet_vec 和 tasklet_hi_vec</span></span><br><span class="line"><span class="comment">// 将 tail 指针设置为对应的 head 指针的初始位置</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		per_cpu(tasklet_vec, cpu).tail =</span><br><span class="line">			&amp;per_cpu(tasklet_vec, cpu).head;</span><br><span class="line">		per_cpu(tasklet_hi_vec, cpu).tail =</span><br><span class="line">			&amp;per_cpu(tasklet_hi_vec, cpu).head;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 注册 TASKLET_SOFTIRQ 软中断，并指定对应的处理函数为 tasklet_action</span></span><br><span class="line">	open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line"><span class="comment">// 注册 HI_SOFTIRQ 软中断，并指定对应的处理函数为 tasklet_hi_action</span></span><br><span class="line">	open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>for_each_possible_cpu(cpu)</code>：遍历每个可能的 CPU。在多核系统中，此循环用于初始化每个 CPU 的 <code>tasklet_vec</code> 和<code>tasklet_hi_vec</code>。</li>
<li><code>per_cpu(tasklet_vec, cpu).tail = &amp;per_cpu(tasklet_vec, cpu).head;</code>：将每个 CPU 的 <code>tasklet_vec</code>的 tail 指针设置为对应的 head 指针的初始位置。这样做是为了<strong>确保 tasklet_vec 的初始状态是空的</strong>。</li>
<li><code>per_cpu(tasklet_hi_vec, cpu).tail = &amp;per_cpu(tasklet_hi_vec, cpu).head;</code> ： 将每个 CPU 的 <code>tasklet_hi_vec</code> 的 tail 指针设置为对应的 head 指针的初始位置。这样做是为了<strong>确保tasklet_hi_vec 的初始状态是空的</strong>。</li>
<li><code>open_softirq(TASKLET_SOFTIRQ, tasklet_action);</code>：<strong>注册 TASKLET_SOFTIRQ 软中断，并指定对应的处理函数为tasklet_action。这样，在TASKLET_SOFTIRQ被触发时，将会调用tasklet_action函数来处理相应的任务</strong>。</li>
<li><code>open_softirq(HI_SOFTIRQ, tasklet_hi_action);</code>：注册 <code>HI_SOFTIRQ</code> 软中断，并指定对应的处理函数为 <code>tasklet_hi_action</code>。这样，在 <code>HI_SOFTIRQ</code> 被触发时，将会调用 <code>tasklet_hi_action</code> 函数来处理相应的任务。</li>
</ul>
<p>在执行<code>__init softirq_init </code>函数时，会触发 <code>TASKLET_SOFTIRQ</code>，然后会调用 <code>tasklet_action</code> 函数，<code>tasklet_action</code> 函数如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> __latent_entropy <span class="type">void</span> <span class="title function_">tasklet_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">&#123;</span><br><span class="line">	tasklet_action_common(a, this_cpu_ptr(&amp;tasklet_vec), TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __latent_entropy <span class="type">void</span> <span class="title function_">tasklet_hi_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">&#123;</span><br><span class="line">	tasklet_action_common(a, this_cpu_ptr(&amp;tasklet_hi_vec), HI_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数中调用了 <code>tasklet_action_common</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tasklet_action_common</span><span class="params">(<span class="keyword">struct</span> softirq_action *a,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> tasklet_head *tl_head,</span></span><br><span class="line"><span class="params">				  <span class="type">unsigned</span> <span class="type">int</span> softirq_nr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line">    <span class="comment">// 禁用本地中断</span></span><br><span class="line">	local_irq_disable();</span><br><span class="line">    <span class="comment">// 获取 tasklet_head 中的任务链表</span></span><br><span class="line">	<span class="built_in">list</span> = tl_head-&gt;head;</span><br><span class="line">    <span class="comment">// 清空 tasklet_head 中的任务链表</span></span><br><span class="line">	tl_head-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将 tail 指针重新指向 head 指针的位置</span></span><br><span class="line">	tl_head-&gt;tail = &amp;tl_head-&gt;head;</span><br><span class="line">    <span class="comment">// 启用本地中断</span></span><br><span class="line">	local_irq_enable();</span><br><span class="line">    <span class="comment">// 遍历任务链表，处理每一个 tasklet</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> =</span> <span class="built_in">list</span>;</span><br><span class="line">        <span class="comment">// 获取下一个 tasklet，并更新链表</span></span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tasklet_trylock(t)) &#123;<span class="comment">// 尝试获取 tasklet 的锁</span></span><br><span class="line">			<span class="keyword">if</span> (!<span class="type">atomic_read</span>(&amp;t-&gt;count)) &#123;<span class="comment">// 检查 count 计数器是否为 0</span></span><br><span class="line">				<span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED,</span><br><span class="line">							&amp;t-&gt;state))</span><br><span class="line">					BUG();<span class="comment">// 如果 state 标志位不正确，则发生错误</span></span><br><span class="line">				<span class="keyword">if</span> (t-&gt;use_callback)</span><br><span class="line">					t-&gt;callback(t);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					t-&gt;func(t-&gt;data);<span class="comment">// 执行 tasklet 的处理函数</span></span><br><span class="line">				tasklet_unlock(t);<span class="comment">// 解锁 tasklet</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			tasklet_unlock(t);<span class="comment">// 解锁 tasklet</span></span><br><span class="line">		&#125;</span><br><span class="line">    	<span class="comment">// 禁用本地中断</span></span><br><span class="line">		local_irq_disable();</span><br><span class="line">        <span class="comment">// 将当前 tasklet 添加到 tasklet_head 的尾部</span></span><br><span class="line">		t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 更新 tail 指针</span></span><br><span class="line">		*tl_head-&gt;tail = t;</span><br><span class="line">		tl_head-&gt;tail = &amp;t-&gt;next;</span><br><span class="line">        <span class="comment">// 触发软中断</span></span><br><span class="line">		__raise_softirq_irqoff(softirq_nr);</span><br><span class="line">        <span class="comment">// 启用本地中断</span></span><br><span class="line">		local_irq_enable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>tasklet_action_common()</code>函数对任务链表中的每个 tasklet 进行处理。它首先禁用本地中断，获取任务链表头指针，清空任务链表，并重新设置尾指针。然后它循环遍历任务链表，对每个 tasklet 进行处理。如果 tasklet 的锁获取成功，并且计数器为 0，它将执行 tasklet 的处理函数，并清除状态标志位。如果锁获取失败或计数不为 0，它将 tasklet 添加到任务链表的尾部，并触发指定的软中断。最后，它启用本地中断，完成任务处理过程。</p>
<p>tasklet 是通过<code>__tasklet_schedule_common()</code>函数加入到链表中的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __tasklet_schedule_common(<span class="keyword">struct</span> tasklet_struct *t,</span><br><span class="line">				      <span class="keyword">struct</span> tasklet_head __percpu *headp,</span><br><span class="line">				      <span class="type">unsigned</span> <span class="type">int</span> softirq_nr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"><span class="comment">// 保存当前中断状态，并禁用本地中断</span></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">    <span class="comment">// 获取当前 CPU 的 tasklet_head 指针</span></span><br><span class="line">	head = this_cpu_ptr(headp);</span><br><span class="line">    <span class="comment">// 将当前 tasklet 添加到 tasklet_head 的尾部</span></span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 更新 tasklet_head 的尾指针</span></span><br><span class="line">	*head-&gt;tail = t;</span><br><span class="line">	head-&gt;tail = &amp;(t-&gt;next);</span><br><span class="line">    <span class="comment">// 触发指定的软中断</span></span><br><span class="line">	raise_softirq_irqoff(softirq_nr);</span><br><span class="line">    <span class="comment">// 恢复中断状态</span></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __tasklet_schedule(<span class="keyword">struct</span> tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	__tasklet_schedule_common(t, &amp;tasklet_vec,</span><br><span class="line">				  TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__tasklet_schedule);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __tasklet_hi_schedule(<span class="keyword">struct</span> tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	__tasklet_schedule_common(t, &amp;tasklet_hi_vec,</span><br><span class="line">				  HI_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__tasklet_hi_schedule);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述代码，<code>__tasklet_schedule_common()</code>函数将 tasklet 成功添加到链表的末尾。</p>
<p>当软中断被触发时，系统会遍历链表并处理每个 tasklet。因此，在添加到链表后，tasklet将在适当的时机被系统调度和执行。</p>
<p>经过上述分析，所以说 tasklet 是一个特殊的软中断。</p>
<p><strong>tasklet优点</strong></p>
<ol>
<li><p>简化的接口和编程模型：Tasklet 提供了一个简单的接口和编程模型，使得在内核中处理延迟工作变得更加容易。相比自己添加软中断，Tasklet 提供了更高级的抽象。</p>
</li>
<li><p>低延迟：Tasklet 在软中断上下文中执行，避免了内核线程的上下文切换开销，因此具有较低的延迟。这对于需要快速响应的延迟敏感任务非常重要。</p>
</li>
<li><p>自适应调度：Tasklet 具有自适应调度的特性，当多个 Tasklet 处于等待状态时，内核会合并它们以减少不必要的上下文切换。这种调度机制可以提高系统的效率。</p>
</li>
</ol>
<p><strong>tasklet缺点</strong></p>
<ol>
<li>无法处理长时间运行的任务：<strong>Tasklet 适用于短时间运行的延迟工作</strong>，如果需要处理长时间运行的任务，可能会阻塞其他任务的执行。对于较长的操作，可能需要使用工作队列或内核线程来处理。</li>
<li>缺乏灵活性：Tasklet 的执行<strong>受限于软中断的上下文</strong>，不适用于所有类型的延迟工作。某些情况下，可能需要更灵活的调度和执行机制，这时自定义软中断可能更加适合。</li>
<li>资源限制：Tasklet 的数量是有限的，<strong>系统中可用的 Tasklet 数量取决于架构和内核配置</strong>。如果需要大量的延迟工作处理，可能会受到 Tasklet 数量的限制</li>
</ol>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p><strong>工作队列是实现中断下半部分的机制之一</strong>，是一种用于管理任务的数据结构或机制。它通常用于多线程，多进程或分布式系统中，用于协调和分配待处理的任务给可用的工作线程或工作进程。</p>
<blockquote>
<p>工作队列的基本原理是将需要执行的任务按顺序排列在队列中，并提供一组工作线程或者工作进程来处理队列中的任务。<br>当有新的任务到达时，它们会被添加到队列的末尾，工作线程或工作进程从队列的头部获取任务，并执行相应的处理操作。</p>
</blockquote>
<p>tasklet 也是实现中断下半部分的机制之一。他们最主要的区别是 <strong>tasklet 不能休眠，而工作队列是可以休眠的</strong>，所以 tasklet 可以用来处理比较耗时间的事情，而<strong>工作队列可以处理更耗时间的事情</strong>。</p>
<p>工作队列将工作推后以后，会交给内核线程去执行。<strong>Linux 在启动过程中会创建一个工作者内核线程，这个线程创建以后处于 sleep 状态。当有工作需要处理的时候，会唤醒这个线程去处理工作</strong>。</p>
<p>在内核中，工作队列包括<strong>共享工作队列</strong>和<strong>自定义工作队列</strong>这俩种类型。这两种类型的工作队列具有不同的特点和用途。</p>
<h3 id="共享工作队列"><a href="#共享工作队列" class="headerlink" title="共享工作队列"></a>共享工作队列</h3><p><strong>共享队列是由内核管理的全局工作队列</strong>，<strong>用于处理内核中一些系统级任务</strong>。</p>
<p>共享工作队列是内核中一个默认工作队列，可以由多个内核组件和驱动程序共享使用。</p>
<h4 id="work-struct"><a href="#work-struct" class="headerlink" title="work_struct"></a>work_struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/workqueue.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">work_func_t</span> func;<span class="comment">/* 工作队列处理函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">work_func_t</span>)</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;<span class="comment">//工作函数</span></span><br></pre></td></tr></table></figure>

<h4 id="INIT-WORK"><a href="#INIT-WORK" class="headerlink" title="INIT_WORK()"></a>INIT_WORK()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>宏定义</strong></td>
<td><strong>INIT_WORK(_work, _func)</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 work</strong></td>
<td>要初始化的工作项（<code>work_struct</code> 结构体）</td>
</tr>
<tr>
<td><strong>参数 func</strong></td>
<td>工作项对应的处理函数</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>初始化一个工作项，使其绑定指定的执行函数，为后续调度做准备。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值</td>
</tr>
</tbody></table>
<h4 id="DECLARE-WORK"><a href="#DECLARE-WORK" class="headerlink" title="DECLARE_WORK()"></a>DECLARE_WORK()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>宏定义</strong></td>
<td><strong>DECLARE_WORK(name, func);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 name</strong></td>
<td>工作项（<code>work_struct</code> 类型）的变量名</td>
</tr>
<tr>
<td><strong>参数 func</strong></td>
<td>工作项对应的处理函数</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>定义并初始化一个工作项，等价于定义 <code>struct work_struct</code> 并使用 <code>INIT_WORK()</code> 初始化。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值</td>
</tr>
</tbody></table>
<h4 id="schedule-work"><a href="#schedule-work" class="headerlink" title="schedule_work()"></a>schedule_work()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>bool schedule_work(struct work_struct *work);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 work</strong></td>
<td>指向要调度的工作项指针</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>将工作项加入系统工作队列，请求调度器在合适时机执行该工作。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td><code>true</code>：成功提交到工作队列；<br /><code>false</code>：提交失败或工作项已在队列中</td>
</tr>
</tbody></table>
<h4 id="cancel-work-sync"><a href="#cancel-work-sync" class="headerlink" title="cancel_work_sync()"></a>cancel_work_sync()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>bool cancel_work_sync(struct work_struct *work);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 work</strong></td>
<td>指向要取消的工作项指针</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>同步取消工作项调度：若工作项在队列中则移除；若正在执行则等待执行完毕后返回。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td><code>true</code>：成功取消；<br /><code>false</code>：工作并未处于等待或运行状态</td>
</tr>
</tbody></table>
<h4 id="flush-work"><a href="#flush-work" class="headerlink" title="flush_work()"></a>flush_work()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>函数定义</td>
<td><strong>bool flush_work(struct work_struct *work);</strong></td>
</tr>
<tr>
<td>头文件</td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td>参数 work</td>
<td>指向要等待完成的工作项指针</td>
</tr>
<tr>
<td>功能</td>
<td>等待指定的工作项执行完毕（若正在运行或处于队列中），确保其不再 pending 或 running。常用于模块卸载前同步清理。</td>
</tr>
<tr>
<td>返回值</td>
<td><code>true</code>：工作项曾处于 pending 或正在执行，现已完成；<br /><code>false</code>：工作项未被调度或已执行完毕（无需等待）</td>
</tr>
</tbody></table>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_GPIO_PIN 101</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> irq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">test_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;test_work_func is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;test_irq_handler is called\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 中断下半部</span></span><br><span class="line">        <span class="comment">// 提交工作项到工作队列</span></span><br><span class="line">        schedule_work(&amp;test_work);</span><br><span class="line">        <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">workqueue_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        irq = gpio_to_irq(TEST_GPIO_PIN);</span><br><span class="line">        <span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        pr_info(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">        ret = request_irq(irq, test_irq_handler, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                free_irq(irq, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">return</span> -ENODEV;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        INIT_WORK(&amp;test_work, test_work_func);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">workqueue_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        free_irq(irq, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 模块退出前必须保证所有已经提交的工作项已经完成</span></span><br><span class="line">        flush_work(&amp;test_work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(workqueue_test_init);</span><br><span class="line">module_exit(workqueue_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@outlook.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a test for workqueue&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="自定义工作队列"><a href="#自定义工作队列" class="headerlink" title="自定义工作队列"></a>自定义工作队列</h3><p><strong>自定义工作队列是由内核或驱动程序创建的特定工作队列，用于处理特定的任务</strong>。</p>
<p>自定义工作队列通常与特定的内核模块或驱动程序相关联，用于执行该模块或驱动程序相关的任务。</p>
<h4 id="workqueue-struct"><a href="#workqueue-struct" class="headerlink" title="workqueue_struct"></a>workqueue_struct</h4><p>内核使用<code>struct workqueue_struct</code>结构体描述一个工作队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/workqueue.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The externally visible workqueue.  It relays the issued work items to</span></span><br><span class="line"><span class="comment"> * the appropriate worker_pool through its pool_workqueues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs</span>;</span>		<span class="comment">/* WR: all pwqs of this wq */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span>		<span class="comment">/* PR: list of all workqueues */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>		<span class="comment">/* protects this wq */</span></span><br><span class="line">	<span class="type">int</span>			work_color;	<span class="comment">/* WQ: current work color */</span></span><br><span class="line">	<span class="type">int</span>			flush_color;	<span class="comment">/* WQ: current flush color */</span></span><br><span class="line">	<span class="type">atomic_t</span>		nr_pwqs_to_flush; <span class="comment">/* flush in progress */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span>	*<span class="title">first_flusher</span>;</span>	<span class="comment">/* WQ: first flusher */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_queue</span>;</span>	<span class="comment">/* WQ: flush waiters */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_overflow</span>;</span> <span class="comment">/* WQ: flush overflow list */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">maydays</span>;</span>	<span class="comment">/* MD: pwqs requesting rescue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">rescuer</span>;</span>	<span class="comment">/* MD: rescue worker */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			nr_drainers;	<span class="comment">/* WQ: drain in progress */</span></span><br><span class="line">	<span class="type">int</span>			saved_max_active; <span class="comment">/* WQ: saved pwq max_active */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">unbound_attrs</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span>	*<span class="title">dfl_pwq</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_device</span>	*<span class="title">wq_dev</span>;</span>	<span class="comment">/* I: for sysfs interface */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="type">char</span>			*lock_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	<span class="title">key</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">char</span>			name[WQ_NAME_LEN]; <span class="comment">/* I: workqueue name */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Destruction of workqueue_struct is RCU protected to allow walking</span></span><br><span class="line"><span class="comment">	 * the workqueues list without grabbing wq_pool_mutex.</span></span><br><span class="line"><span class="comment">	 * This is used to dump all workqueues from sysrq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hot fields used during command issue, aligned to cacheline */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags ____cacheline_aligned; <span class="comment">/* WQ: WQ_* flags */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span> <span class="comment">/* I: per-cpu pwqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span> <span class="comment">/* PWR: unbound pwqs indexed by node */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="create-workqueue"><a href="#create-workqueue" class="headerlink" title="create_workqueue()"></a>create_workqueue()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>struct workqueue_struct *create_workqueue(const char *name);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 name</strong></td>
<td>创建的工作队列名称</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>创建一个每 CPU 都对应的工作队列（每个 CPU 一个 worker 线程）。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>成功：<code>workqueue_struct*</code> 指针；<br />失败：<code>NULL</code></td>
</tr>
</tbody></table>
<h4 id="create-singlethread-workqueue"><a href="#create-singlethread-workqueue" class="headerlink" title="create_singlethread_workqueue()"></a>create_singlethread_workqueue()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>宏定义</strong></td>
<td><strong>create_singlethread_workqueue(name)</strong><br />宏展开为：<code>alloc_workqueue(&quot;%s&quot;, WQ_SINGLE_THREAD, 1, name)</code></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 name</strong></td>
<td>工作队列名称</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>创建一个仅绑定单 CPU、单 worker 线程的工作队列。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>成功：<code>workqueue_struct*</code> 指针；<br />失败：<code>NULL</code></td>
</tr>
</tbody></table>
<h4 id="alloc-workqueue"><a href="#alloc-workqueue" class="headerlink" title="alloc_workqueue()"></a>alloc_workqueue()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>函数定义</td>
<td><strong>struct workqueue_struct *alloc_workqueue(const char *fmt, unsigned int flags, int max_active, …);</strong></td>
</tr>
<tr>
<td>头文件</td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td>参数 fmt</td>
<td>工作队列的名称格式字符串（类似 <code>printf</code>），用于在内核中标识该工作队列（如出现在 <code>/proc/workqueue</code> 或日志中）。</td>
</tr>
<tr>
<td>参数 flags</td>
<td>控制工作队列行为的标志位，常用包括：<br />• <code>WQ_UNBOUND</code>：不限定 CPU，由调度器动态分配；<br />• <code>WQ_MEM_RECLAIM</code>：允许在内存回收路径中执行，避免死锁；<br />• <code>WQ_HIGHPRI</code>：高优先级 workqueue；<br />• <code>WQ_CPU_INTENSIVE</code>：标记为 CPU 密集型，影响并发调度。</td>
</tr>
<tr>
<td>参数 max_active</td>
<td>指定该工作队列在每个 CPU 上最大可并发执行的工作项数量。<br />• 设为 <code>1</code> 表示串行执行（同一时间最多一个 work 运行）；<br />• 设为 <code>0</code> 表示使用默认值（通常为 <code>WQ_MAX_ACTIVE = 512</code>）；<br />• 对 <code>WQ_UNBOUND</code> 队列，表示全局最大并发数。</td>
</tr>
<tr>
<td>可变参数 …</td>
<td>用于配合 <code>fmt</code> 格式字符串（如 <code>alloc_workqueue(&quot;my_wq_%d&quot;, ..., id)</code>），若 <code>fmt</code> 无格式说明符可忽略。</td>
</tr>
<tr>
<td>功能</td>
<td>动态创建并初始化一个专用工作队列（workqueue），返回其指针。相比已废弃的 <code>create_workqueue()</code>，它提供更精细的控制和更好的可扩展性。</td>
</tr>
<tr>
<td>返回值</td>
<td>成功时返回指向 <code>struct workqueue_struct</code> 的指针；<br />失败时返回 <code>NULL</code>（例如内存不足）。</td>
</tr>
<tr>
<td>配套操作</td>
<td>• 提交 work：<code>queue_work(wq, &amp;work)</code><br />• 销毁：<code>destroy_workqueue(wq)</code><br />• 同步等待：<code>flush_work()</code>, <code>flush_workqueue()</code></td>
</tr>
</tbody></table>
<p>典型用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个可内存回收、不限 CPU、串行执行的自定义工作队列。</span></span><br><span class="line">wq = alloc_workqueue(<span class="string">&quot;my_custom_wq&quot;</span>, WQ_MEM_RECLAIM | WQ_UNBOUND, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>内核中的下面这些宏函数都是通过调用<code>alloc_workqueue</code>实现的:</p>
<ul>
<li><code>alloc_ordered_workqueue</code><ul>
<li>创建一个严格串行执行（ordered）的工作队列。</li>
<li>所有提交到该队列的 work 会按提交顺序依次执行，绝不会并发。</li>
<li>使用 WQ_UNBOUND：不限定在某个 CPU 上运行，由内核调度器自由选择 CPU。</li>
<li><code>max_active = 1</code>：确保同一时间最多只有一个 work 在执行。</li>
<li><code>__WQ_ORDERED | __WQ_ORDERED_EXPLICIT</code>：内部标志，强制启用“有序”语义。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> alloc_ordered_workqueue(fmt, flags, args...)			\</span></span><br><span class="line"><span class="meta">	alloc_workqueue(fmt, WQ_UNBOUND | __WQ_ORDERED |		\</span></span><br><span class="line"><span class="meta">			__WQ_ORDERED_EXPLICIT | (flags), 1, ##args)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>create_workqueue</code><ul>
<li>这是对已废弃函数 create_workqueue() 的宏替换（自 Linux 2.6.36 起废弃）。</li>
<li>实际创建的是一个每个 CPU 一个工作者线程的绑定型工作队列（但通过 <code>__WQ_LEGACY</code> 模拟旧行为）。</li>
<li><code>WQ_MEM_RECLAIM</code>：允许在内存回收路径中调度，避免死锁。</li>
<li><code>max_active = 1</code>：注意！这与早期内核行为不一致。<blockquote>
<p>⚠️ 在非常老的内核中，create_workqueue() 默认是多线程并发的（每个 CPU 一个线程，可并行执行）。但现代内核为了简化，将其映射为 max_active&#x3D;1 的形式，实际行为已变为串行！</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> create_workqueue(name)						\</span></span><br><span class="line"><span class="meta">	alloc_workqueue(<span class="string">&quot;%s&quot;</span>, __WQ_LEGACY | WQ_MEM_RECLAIM, 1, (name))</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>create_freezable_workqueue</code><ul>
<li>创建一个可被系统挂起（freeze）时冻结的工作队列。</li>
<li><code>WQ_FREEZABLE</code>：当系统进入 <code>suspend/hibernate</code> 时，该队列中的 work 会被暂停，直到系统 resume。</li>
<li><code>WQ_UNBOUND</code>：不限定 CPU。</li>
<li><code>max_active = 1</code>：串行执行。</li>
<li>同样带有 <code>__WQ_LEGACY</code>，属于兼容性接口。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> create_freezable_workqueue(name)				\</span></span><br><span class="line"><span class="meta">	alloc_workqueue(<span class="string">&quot;%s&quot;</span>, __WQ_LEGACY | WQ_FREEZABLE | WQ_UNBOUND |	\</span></span><br><span class="line"><span class="meta">			WQ_MEM_RECLAIM, 1, (name))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>create_singlethread_workqueue</code><ul>
<li>创建一个单线程、串行执行的工作队列。</li>
<li>本质是 <code>alloc_ordered_workqueue(..., max_active=1)</code> 的封装。</li>
<li>带有 <code>__WQ_LEGACY</code>，表示这是旧 API 的替代。</li>
<li>保证所有 work 在同一个执行上下文中顺序完成。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> create_singlethread_workqueue(name)				\</span></span><br><span class="line"><span class="meta">	alloc_ordered_workqueue(<span class="string">&quot;%s&quot;</span>, __WQ_LEGACY | WQ_MEM_RECLAIM, name)</span></span><br></pre></td></tr></table></figure>


<h4 id="queue-work"><a href="#queue-work" class="headerlink" title="queue_work()"></a>queue_work()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>函数定义</td>
<td><strong>bool queue_work(struct workqueue_struct *wq, struct work_struct *work)</strong>;</td>
</tr>
<tr>
<td>头文件</td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td>参数 wq</td>
<td>目标工作队列指针</td>
</tr>
<tr>
<td>参数 work</td>
<td>要加入工作队列的工作项</td>
</tr>
<tr>
<td>功能</td>
<td>将工作项添加到指定的工作队列中，由内核调度器选择合适的 CPU 执行。</td>
</tr>
<tr>
<td>返回值</td>
<td><code>true</code>：成功加入队列；<br /><code>false</code>：加入失败（例如工作项已在队列中 pending）</td>
</tr>
</tbody></table>
<h4 id="queue-work-on"><a href="#queue-work-on" class="headerlink" title="queue_work_on()"></a>queue_work_on()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>bool queue_work_on(int cpu, struct workqueue_struct *wq, struct work_struct *work);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 cpu</strong></td>
<td>指定要在哪个 CPU 上执行工作项</td>
</tr>
<tr>
<td><strong>参数 wq</strong></td>
<td>目标工作队列指针</td>
</tr>
<tr>
<td><strong>参数 work</strong></td>
<td>要加入工作队列的工作项</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>将工作项添加到指定 CPU 的指定工作队列中，等待执行。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td><code>true</code>：成功加入队列；<br /><code>false</code>：加入失败（例如已在队列中）</td>
</tr>
</tbody></table>
<h4 id="cancel-work-sync-1"><a href="#cancel-work-sync-1" class="headerlink" title="cancel_work_sync()"></a>cancel_work_sync()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>bool cancel_work_sync(struct work_struct *work);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 work</strong></td>
<td>要取消的工作项指针</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>同步取消工作项；若工作正在执行则等待执行完成后返回。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td><code>true</code>：成功取消；<br /><code>false</code>：工作不在队列或不可取消</td>
</tr>
</tbody></table>
<h4 id="flush-work-queue"><a href="#flush-work-queue" class="headerlink" title="flush_work_queue()"></a>flush_work_queue()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>void flush_workqueue(struct workqueue_struct *wq);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 wq</strong></td>
<td>要刷新的工作队列</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>刷新工作队列，等待所有已提交但尚未执行的工作执行完成。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值</td>
</tr>
</tbody></table>
<h4 id="destroy-work-queue"><a href="#destroy-work-queue" class="headerlink" title="destroy_work_queue()"></a>destroy_work_queue()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>void destroy_workqueue(struct workqueue_struct *wq);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 wq</strong></td>
<td>要销毁的工作队列</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>删除工作队列，释放其资源。在调用前必须确保队列中没有未完成的工作（可配合 <code>flush_workqueue()</code> 使用）。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值</td>
</tr>
</tbody></table>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_GPIO_PIN 101</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">test_wq</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">test_work</span>;</span></span><br><span class="line"><span class="comment">// 中断下半部，工作处理函数</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;test_irq_handler is called\n&quot;</span>);</span><br><span class="line">        queue_work(test_wq, &amp;test_work);</span><br><span class="line">        <span class="comment">// queue_work_on(0, test_wq, &amp;test_work);</span></span><br><span class="line">        <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中断上半部，中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">        msleep(<span class="number">1000</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;test_work_func is called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">custom_workqueue_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        irq = gpio_to_irq(TEST_GPIO_PIN);</span><br><span class="line">        <span class="keyword">if</span> (irq &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret = -ENODEV;</span><br><span class="line">                <span class="keyword">goto</span> get_irq_fail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = request_irq(irq, test_irq_handler, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> request_irq_fail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建工作队列</span></span><br><span class="line">        test_wq = create_workqueue(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR_OR_NULL(test_wq))</span><br><span class="line">                <span class="keyword">goto</span> create_workqueue_fail;</span><br><span class="line">        <span class="comment">// 初始化工作项</span></span><br><span class="line">        INIT_WORK(&amp;test_work, test_work_func);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">create_workqueue_fail:</span><br><span class="line">        free_irq(irq, <span class="literal">NULL</span>);</span><br><span class="line">request_irq_fail:</span><br><span class="line">get_irq_fail:</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">custom_workqueue_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        free_irq(irq, <span class="literal">NULL</span>);<span class="comment">// 禁止新中断</span></span><br><span class="line">        <span class="comment">// 取消工作项       </span></span><br><span class="line">        <span class="comment">// flush_work(&amp;test_work);</span></span><br><span class="line">        <span class="comment">// 刷新工作队列，等待所有已经提交但尚未执行的工作完成</span></span><br><span class="line">        flush_workqueue(test_wq);</span><br><span class="line">        <span class="comment">// 销毁工作队列释放资源</span></span><br><span class="line">        destroy_workqueue(test_wq);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(custom_workqueue_test_init);</span><br><span class="line">module_exit(custom_workqueue_test_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;even629&lt;asqwgo@outlook.com&gt;&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;This is a test for custom workqueue&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="延迟工作"><a href="#延迟工作" class="headerlink" title="延迟工作"></a>延迟工作</h3><p>延迟工作是一种<strong>将工作的执行延迟到稍后时间点进行处理</strong>的技术。</p>
<p>通常情况下，<strong>当某个任务需要花费较长时间，不需要立即执行或需要按时执行时</strong>，延迟工作就会派上用场。</p>
<p>延迟工作的基本思想是将任务放入一个队列中，然后由后台的工作进程会任务调度程序来处理队列中的任务。任务可以在指定的延迟时间后执行，也可以根据优先级，任务类型或者其他条件进行排序和处理。</p>
<ol>
<li>延迟工作常用于处理那些需要花费较长时间的任务，比如发送电子邮件，处理图像等。通过将这些任务放入队列中并延迟执行，可以避免阻塞应用程序的主线程，提高系统的响应速度。</li>
<li>延迟工作可以用来执行定时任务，比如定时备份数据库，通过将任务设置为在未来的某个时间点执行，提高系统的可靠性和效率。</li>
</ol>
<h4 id="按键消抖"><a href="#按键消抖" class="headerlink" title="按键消抖"></a>按键消抖</h4><p>理想情况下，按下按键后：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223193945204.png" alt="理想情况下的案件按下后的电压变化" loading="lazy"></p>
<p>实际情况下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223193953056.png" alt="实际情况下电压会出现抖动" loading="lazy"></p>
<ul>
<li>t1 时刻按键被按下，但是由于抖动的原因，直到 t2 时刻才稳定下来，t1 到t2 这段时间就是抖动。</li>
<li>一般这段时间就是十几 ms 左右，从上图中可以看出在抖动期间会有多次触发，如果不消除这段抖动的话软件就会误判，本来按键就按下了一次，结果软件读取 IO值发现电平多次跳变以为按下了多次。</li>
<li>所以<strong>我们需要跳过这段抖动时间再去读取按键的 IO 值</strong>，也就是至少要在 t2 时刻以后再去读 IO 值</li>
</ul>
<p>定时器消抖：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223193957240.png" alt="使用定时器进行消抖" loading="lazy"></p>
<p>在按键中断中开启一个定时器定时周期为 10ms，当定时时间到了以后就会触发定时器中断，最后在定时器中断处理函数中读取按键的值，如果按键值还是按下状态那就表示这是一次有效的按键。</p>
<blockquote>
<p>在上图中 t1~t3 这一段时间就是按键抖动，是需要消除的。设置按键为下降沿触发，因此会在 t1、t2 和 t3 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，所以会在 t1、t2 和 t3 这三个时刻开器定时器中断。</p>
<p>但是 t1 ~ t2 和 t2 ~ t3 这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理，Linux 里面的按键驱动用的就是这个原理！</p>
</blockquote>
<p>除了使用定时器方式进行消抖，也可以使用延迟工作，中断下文中将工作延迟 3 ms之后，再去读 GPIO 电平状态。</p>
<h4 id="delayed-work"><a href="#delayed-work" class="headerlink" title="delayed_work"></a>delayed_work</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/workqueue.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">// 定时器，用于延迟执行工作</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* target workqueue and CPU -&gt;timer uses to queue -&gt;work */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="type">int</span> cpu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="DECLARE-DELAYED-WORK"><a href="#DECLARE-DELAYED-WORK" class="headerlink" title="DECLARE_DELAYED_WORK()"></a>DECLARE_DELAYED_WORK()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>宏定义</strong></td>
<td><strong>DECLARE_DELAYED_WORK(n, f);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 n</strong></td>
<td>延迟工作（<code>delayed_work</code>）变量名</td>
</tr>
<tr>
<td><strong>参数 f</strong></td>
<td>延迟工作对应的处理函数（<code>void (*f)(struct work_struct *)</code>）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>静态定义并初始化一个延迟工作项。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值</td>
</tr>
</tbody></table>
<h4 id="INIT-DELAYED-WORK"><a href="#INIT-DELAYED-WORK" class="headerlink" title="INIT_DELAYED_WORK()"></a>INIT_DELAYED_WORK()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>宏定义</strong></td>
<td><strong>INIT_DELAYED_WORK(work, func);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 work</strong></td>
<td>待初始化的延迟工作结构体指针（<code>delayed_work</code>）</td>
</tr>
<tr>
<td><strong>参数 func</strong></td>
<td>延迟工作的处理函数</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>动态初始化一个延迟工作项，同时初始化内部的 <code>work_struct</code> 与 <code>timer</code>。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>无返回值</td>
</tr>
</tbody></table>
<h4 id="schedule-delayed-work"><a href="#schedule-delayed-work" class="headerlink" title="schedule_delayed_work()"></a>schedule_delayed_work()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>bool schedule_delayed_work(struct delayed_work *dwork, unsigned long delay);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 dwork</strong></td>
<td>要调度的延迟工作项</td>
</tr>
<tr>
<td><strong>参数 delay</strong></td>
<td>延迟时间（单位：jiffies）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>将延迟工作提交到系统默认工作队列，并在指定延迟时间后执行。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td><code>true</code>：成功提交；<br /><code>false</code>：提交失败</td>
</tr>
</tbody></table>
<h4 id="queue-delayed-work"><a href="#queue-delayed-work" class="headerlink" title="queue_delayed_work()"></a>queue_delayed_work()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>bool queue_delayed_work(struct workqueue_struct *wq, struct delayed_work *dwork, unsigned long delay);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 wq</strong></td>
<td>指定执行的目标工作队列</td>
</tr>
<tr>
<td><strong>参数 dwork</strong></td>
<td>要调度的延迟工作项</td>
</tr>
<tr>
<td><strong>参数 delay</strong></td>
<td>延迟时间（单位：jiffies）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>将延迟工作添加到自定义工作队列，并在指定延迟时间后执行。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td><code>true</code>：成功提交；<br /><code>false</code>：提交失败</td>
</tr>
</tbody></table>
<h4 id="cancel-delayed-work-sync"><a href="#cancel-delayed-work-sync" class="headerlink" title="cancel_delayed_work_sync()"></a>cancel_delayed_work_sync()</h4><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>bool cancel_delayed_work_sync(struct delayed_work *dwork);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 dwork</strong></td>
<td>要取消的延迟工作项</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>同步取消延迟工作调度：若工作已执行或正在执行，则等待其完成。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td><code>true</code>：成功取消；<br /><code>false</code>：无法取消或工作已完成</td>
</tr>
</tbody></table>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">test_workqueue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">test_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作项处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">  msleep(<span class="number">1000</span>);</span><br><span class="line">  printk(<span class="string">&quot;This is test_work\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;This is test_interrupt\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 提交延迟工作项到自定义工作队列</span></span><br><span class="line">  queue_delayed_work(test_workqueue, &amp;test_work, <span class="number">3</span> * HZ);</span><br><span class="line">  <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">interrupt_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  irq = gpio_to_irq(<span class="number">101</span>); <span class="comment">// 将GPIO映射为中断号</span></span><br><span class="line">  printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求中断</span></span><br><span class="line">  ret = request_irq(irq, test_interrupt, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;request_irq is error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建工作队列</span></span><br><span class="line">  test_workqueue = create_workqueue(<span class="string">&quot;test_workqueue&quot;</span>);</span><br><span class="line">  <span class="comment">// 初始化延迟工作项</span></span><br><span class="line">  INIT_DELAYED_WORK(&amp;test_work, test_work);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">interrupt_irq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  free_irq(irq, <span class="literal">NULL</span>);                            <span class="comment">// 释放中断</span></span><br><span class="line">  cancel_delayed_work_sync(&amp;test_work);           <span class="comment">// 取消延迟工作项</span></span><br><span class="line">  flush_workqueue(test_workqueue);                <span class="comment">// 刷新工作队列</span></span><br><span class="line">  destroy_workqueue(test_workqueue);              <span class="comment">// 销毁工作队列</span></span><br><span class="line">  printk(<span class="string">&quot;bye bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_irq_init);</span><br><span class="line">module_exit(interrupt_irq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="工作队列传参"><a href="#工作队列传参" class="headerlink" title="工作队列传参"></a>工作队列传参</h3><p>主要思路是依靠<code>container_of</code>宏，把work_struct放入自定义结构体中</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">test_work</span>;</span></span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_data</span> <span class="title">test_work_data</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">test_workqueue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作项处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line">  pdata = container_of(work, <span class="keyword">struct</span> work_data, test_work);</span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;a is %d&quot;</span>, pdata-&gt;a);</span><br><span class="line">  printk(<span class="string">&quot;b is %d&quot;</span>, pdata-&gt;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;This is test_interrupt\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 提交工作项到工作队列</span></span><br><span class="line">  queue_work(test_workqueue, &amp;test_workqueue_work.test_work);</span><br><span class="line">  <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">interrupt_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  irq = gpio_to_irq(<span class="number">101</span>); <span class="comment">// 将GPIO映射为中断号</span></span><br><span class="line">  printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求中断</span></span><br><span class="line">  ret = request_irq(irq, test_interrupt, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;request_irq is error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建工作队列</span></span><br><span class="line">  test_workqueue = create_workqueue(<span class="string">&quot;test_workqueue&quot;</span>);</span><br><span class="line">  <span class="comment">// 初始化工作项</span></span><br><span class="line">  INIT_WORK(&amp;test_work_data.test_work, test_work);</span><br><span class="line"></span><br><span class="line">  test_work_data.a = <span class="number">1</span>;</span><br><span class="line">  test_work_data.b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">interrupt_irq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  free_irq(irq, <span class="literal">NULL</span>);                              <span class="comment">// 释放中断</span></span><br><span class="line">  cancel_work_sync(&amp;test_work_data.test_work); <span class="comment">// 取消工作项</span></span><br><span class="line">  flush_workqueue(test_workqueue);                  <span class="comment">// 刷新工作队列</span></span><br><span class="line">  destroy_workqueue(test_workqueue);                <span class="comment">// 销毁工作队列</span></span><br><span class="line">  printk(<span class="string">&quot;bye bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_irq_init);</span><br><span class="line">module_exit(interrupt_irq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="并发管理工作队列"><a href="#并发管理工作队列" class="headerlink" title="并发管理工作队列"></a>并发管理工作队列</h3><p>在使用工作队列时，我们首先定义一个work结构体，然后将work添加到workqueue(工作队列)中，最后worker thread执行workqueue。</p>
<p>当工作队列中有新 work 产生时，工作线程（worker thread）会执行工作队列中每个 work。当执行完结束的时候，worker thread 会睡眠，等到新的中断产生，work 再继续添加到工作队列，然后工作线程执行每个工作，周而复始。</p>
<p><strong>单核系统</strong></p>
<p>在单核线程的系统中，通常会为每个 CPU（核心）初始化一个工作线程并关联一个工作队列。这种默认设置确保每个 CPU 都有一个专门的线程来处理与其绑定的工作队列上的工作项。</p>
<p><strong>多核系统</strong></p>
<p>在多核线程系统中，工作队列的设计与单核线程系统有所不同。<strong>在多核线程系统中，通常会存在多个工作队列，每个工作队列与一个工作线程（Worker Thread）绑定</strong>。这样可以充分利用多个核心的并行处理能力。</p>
<p>当有新的工作项产生时，系统需要决定将其分配给哪个工作队列。一种常见的策略是使用<strong>负载均衡算法</strong>，根据工作队列的负载情况来平衡分配工作项，以避免某个工作队列过载而导致性能下降。</p>
<p>每个工作队列独立管理自己的工作项。当有新的工作项添加到工作队列时，工作线程会从其关联的工作队列中获取待执行的工作项，并执行相应的处理函数。</p>
<p>在多核线程系统中，多个工作线程可以同时执行各自绑定的工作队列中的工作项。这样可以实现并行处理，提高系统的整体性能和响应速度。</p>
<h4 id="工作队列的弊端"><a href="#工作队列的弊端" class="headerlink" title="工作队列的弊端"></a>工作队列的弊端</h4><ol>
<li>在工作项 w0 工作甚至是睡眠时，工作项 w1 w2 是排队等待的，在繁忙的系统中，工作队列可能会积累大量的待处理工作项，导致任务调度的延迟，这可能会影响系统的响应性能，并增加工作项的处理时间。</li>
<li>在工作队列中，不同的工作项可能具有不同的处理时间和资源需求。如果工作项的处理时间差异很大，一些工作线程可能会一直忙于处理长时间的工作项，而其他工作线程则处于空闲状态，导致资源利用不均衡。</li>
<li>在多线程环境下，多个工作线程同时访问和修改工作队列可能会导致竞争条件的发生。为了确保数据的一致性和正确性，需要采用适当的同步机制，如锁或原子操作，来保护共享数据，但这可能会引入额外的同步开销。</li>
<li>工作队列通常按照先进先出（FIFO）的方式处理工作项，缺乏对工作项优先级的细粒度控制。在某些场景下，可能需要根据工作项的重要性或紧急程度进行优先级调度，而工作队列本身无法提供这种级别的优先级控制。</li>
<li>当工作线程从工作队列中获取工作项并执行时，可能需要频繁地进行上下文切换，将处理器的执行上下文从一个线程切换到另一个线程。这种上下文切换开销可能会影响系统的性能和效率。</li>
</ol>
<h4 id="Concurrency-Managed-Workqueue"><a href="#Concurrency-Managed-Workqueue" class="headerlink" title="Concurrency Managed Workqueue"></a>Concurrency Managed Workqueue</h4><p><strong>CMWQ</strong> 全称是 Concurrency Managed Workqueue，意为并发管理工作队列。并发管理工作队列是一种并发编程模式，用于有效地管理和调度待执行的任务或工作项。它通常用于多线程或多进程环境中，以实现并发执行和提高系统的性能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251223194006835.png" alt="CMWQ" loading="lazy"></p>
<p>当我们需要在一个系统中同时处理多个任务或工作时，使用并发管理工作队列是一种有效的方式。</p>
<h5 id="alloc-workqueue-1"><a href="#alloc-workqueue-1" class="headerlink" title="alloc_workqueue()"></a>alloc_workqueue()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/linux/workqueue.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_workqueue - allocate a workqueue</span></span><br><span class="line"><span class="comment"> * @fmt: printf format for the name of the workqueue</span></span><br><span class="line"><span class="comment"> * @flags: WQ_* flags</span></span><br><span class="line"><span class="comment"> * @max_active: max in-flight work items, 0 for default</span></span><br><span class="line"><span class="comment"> * remaining args: args for @fmt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocate a workqueue with the specified parameters.  For detailed</span></span><br><span class="line"><span class="comment"> * information on WQ_* flags, please refer to</span></span><br><span class="line"><span class="comment"> * Documentation/core-api/workqueue.rst.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * Pointer to the allocated workqueue on success, %NULL on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> workqueue_struct *<span class="title function_">alloc_workqueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt,</span></span><br><span class="line"><span class="params">					 <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">					 <span class="type">int</span> max_active, ...)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>struct workqueue_struct *alloc_workqueue(const char *fmt, unsigned int flags, int max_active);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/workqueue.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 fmt</strong></td>
<td>工作队列名称格式（可带格式化，如 <code>&quot;my_wq%d&quot;</code>）</td>
</tr>
<tr>
<td><strong>参数 flags</strong></td>
<td>工作队列属性标志，如：• <code>WQ_UNBOUND</code>：不绑定具体 CPU• <code>WQ_HIGHPRI</code>：高优先级执行• <code>WQ_FREEZABLE</code>：可在系统冻结期间暂停• <code>WQ_MEM_RECLAIM</code>：用于内存回收路径</td>
</tr>
<tr>
<td><strong>参数 max_active</strong></td>
<td>最大活跃工作项数量（队列中可并发执行的 worker 数）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>创建一个可定制属性的工作队列，用于并发或异步处理工作项。是创建工作队列最灵活的方式。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>成功：<code>struct workqueue_struct*</code> 指针；失败：<code>NULL</code></td>
</tr>
</tbody></table>
<h5 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">test_workqueue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">test_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作项处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test_work_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">  msleep(<span class="number">1000</span>);</span><br><span class="line">  printk(<span class="string">&quot;This is test_work\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;This is test_interrupt\n&quot;</span>);</span><br><span class="line">  queue_work(test_workqueue, &amp;test_work); <span class="comment">// 提交工作项到工作队列</span></span><br><span class="line">  <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">interrupt_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  irq = gpio_to_irq(<span class="number">101</span>); <span class="comment">// 将GPIO映射为中断号</span></span><br><span class="line">  printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求中断</span></span><br><span class="line">  ret = request_irq(irq, test_interrupt, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;request_irq is error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于创建和分配一个工作队列</span></span><br><span class="line">  test_workqueue = alloc_workqueue(<span class="string">&quot;test_workqueue&quot;</span>, WQ_UNBOUND, <span class="number">0</span>);</span><br><span class="line">  INIT_WORK(&amp;test_work, test_work_fn); <span class="comment">// 初始化工作项</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">interrupt_irq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  free_irq(irq, <span class="literal">NULL</span>);                    <span class="comment">// 释放中断</span></span><br><span class="line">  cancel_work_sync(&amp;test_work); <span class="comment">// 取消工作项</span></span><br><span class="line">  flush_workqueue(test_workqueue);        <span class="comment">// 刷新工作队列</span></span><br><span class="line">  destroy_workqueue(test_workqueue);      <span class="comment">// 销毁工作队列</span></span><br><span class="line">  printk(<span class="string">&quot;bye bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_irq_init);</span><br><span class="line">module_exit(interrupt_irq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="中断线程化技术"><a href="#中断线程化技术" class="headerlink" title="中断线程化技术"></a>中断线程化技术</h3><p>中断线程化是一种优化技术，用于提高多线程程序的性能。</p>
<p>在多线程程序中，有时硬件或其他事件会发出中断信号，打断正在执行的线程，需要切换到中断处理程序去处理这些事件。这种<strong>频繁的中断切换会导致额外的开销和延迟</strong>，影响程序的性能。</p>
<p>为了解决这个问题，中断线程化提出了一种优化方案。它将中断处理程序从主线程中独立出来，创建一个专门的线程来处理这些中断事件。这样，主线程就不再受到中断的干扰，可以专注于自己的工作，不再频繁地被打断。</p>
<p>中断线程化的核心思想是<strong>将中断处理和主线程的工作分开</strong>，让它们可以并行执行。中断线程负责处理中断事件，而主线程负责执行主要的工作任务。这样一来，不仅可以减少切换的开销，还可以提高整个程序的响应速度和性能。</p>
<blockquote>
<p>需要注意的是，中断线程化还需要处理线程之间的同步和数据共享问题。因为中断线程和主线程可能会同时访问和修改共享的数据，所以需要合理地进行同步操作，确保数据的一致性和正确性。</p>
<p>中断线程化的处理仍然可以看作是将原来的中断上半部分和中断下半部分。</p>
<p>上半部分还是用来处理紧急的事情，下半部分也是出路比较耗时的操作，但是下半部分会交给一个专门的内核线程来处理。这个内核线程只用于这个中断。</p>
<p>当发生中断的时候，会唤醒这个内核线程，然后由这个内核线程来执行中断下半部分的函数。</p>
</blockquote>
<h4 id="request-threaded-riq"><a href="#request-threaded-riq" class="headerlink" title="request_threaded_riq()"></a>request_threaded_riq()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/interrupt.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">		     <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">		     <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>函数定义</strong></td>
<td><strong>int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id);</strong></td>
</tr>
<tr>
<td><strong>头文件</strong></td>
<td><code>#include &lt;linux/interrupt.h&gt;</code></td>
</tr>
<tr>
<td><strong>参数 irq</strong></td>
<td>中断号（IRQ 线路编号）</td>
</tr>
<tr>
<td><strong>参数 handler</strong></td>
<td>顶半部处理函数：中断发生时最先执行的快速处理函数。<br />若返回 <code>IRQ_WAKE_THREAD</code> 则唤醒底半部线程。<br />可设为 <code>NULL</code> 使用系统默认 handler。</td>
</tr>
<tr>
<td><strong>参数 thread_fn</strong></td>
<td>线程化的中断处理函数（底半部），在内核线程中执行。若为 <code>NULL</code> 则不使用中断线程化。</td>
</tr>
<tr>
<td><strong>参数 irqflags</strong></td>
<td>中断属性标志，如 <code>IRQF_TRIGGER_RISING</code>、<code>IRQF_SHARED</code> 等</td>
</tr>
<tr>
<td><strong>参数 devname</strong></td>
<td>中断名称，用于标识设备</td>
</tr>
<tr>
<td><strong>参数 dev_id</strong></td>
<td>传递给处理函数的设备标识（通常是设备结构体指针）</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>注册一个线程化中断，包括顶半部与底半部线程处理，用于提升中断处理的实时性和可调度性。</td>
</tr>
<tr>
<td><strong>返回值</strong></td>
<td>成功：返回 0；<br />失败：返回负数错误码</td>
</tr>
</tbody></table>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数的底半部（线程化中断处理函数）</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_work</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 执行底半部的中断处理任务</span></span><br><span class="line">  msleep(<span class="number">1000</span>);</span><br><span class="line">  printk(<span class="string">&quot;This is test_work\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中断处理函数的顶半部</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">test_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;This is test_interrupt\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 将中断处理工作推迟到底半部</span></span><br><span class="line">  <span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">interrupt_irq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  irq = gpio_to_irq(<span class="number">101</span>); <span class="comment">// 将GPIO映射为中断号</span></span><br><span class="line">  printk(<span class="string">&quot;irq is %d\n&quot;</span>, irq);</span><br><span class="line">  <span class="comment">// 用于请求并注册一个线程化的中断处理函数</span></span><br><span class="line">  ret = request_threaded_irq(irq, test_interrupt, test_work, IRQF_TRIGGER_RISING, <span class="string">&quot;test&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;request_irq is error\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">interrupt_irq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  free_irq(irq, <span class="literal">NULL</span>); <span class="comment">// 释放中断</span></span><br><span class="line">  printk(<span class="string">&quot;bye bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(interrupt_irq_init);</span><br><span class="line">module_exit(interrupt_irq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;topeet&quot;</span>);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/2511143/">https://even629.com/posts/2511143/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/driver/">driver</a></div><div class="post-share"><div class="social-share" data-image="/images/linux_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center liquidGlass-wrapper" id="my-custom-card-author"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status">🐟<span>认真摸鱼中</span></div></div></div><div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" target="_blank" title="github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="qq"><i class="fa-brands fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" target="_blank" title="email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://space.bilibili.com/519280138" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="rss"><i class="fas fa-rss" style="color: #000000;"></i></a></div></div></div><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"> <div class="newYear-slider"> <div class="swiper-wrapper"> <div class="swiper-slide" style="background-image:url(/img/happy_new_year1.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year2.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year3.webp)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year4.gif)"></div> </div> </div> <div id="newYear-main"> <div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div> </div></div><div class="sticky_layout"><div class="card-widget liquidGlass-wrapper" id="card-toc"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-text">中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%A6%82%E5%BF%B5"><span class="toc-text">中断概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%8A%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="toc-text">中断的上下半部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-text">中断子系统框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8GIC"><span class="toc-text">中断控制器GIC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GICv3"><span class="toc-text">GICv3</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Distributor-%E4%B8%AD%E6%96%AD%E4%BB%B2%E8%A3%81%E5%99%A8"><span class="toc-text">Distributor 中断仲裁器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redistributor-%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-text">Redistributor 重新分配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CPU-Interface"><span class="toc-text">CPU Interface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="toc-text">中断类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%8A%B6%E6%80%81"><span class="toc-text">中断状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%A7%A6%E5%8F%91%E7%B1%BB%E5%9E%8B"><span class="toc-text">中断触发类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%8F%B7"><span class="toc-text">中断号</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%94%B3%E8%AF%B7%E5%87%BD%E6%95%B0"><span class="toc-text">中断申请函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#request-irq"><span class="toc-text">request_irq()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gpio-to-irq"><span class="toc-text">gpio_to_irq()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-irq"><span class="toc-text">free_irq()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-text">中断处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%94%B3%E8%AF%B7%E6%B5%81%E7%A8%8B"><span class="toc-text">中断申请流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#request-irq-1"><span class="toc-text">request_irq()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request-threaded-irq"><span class="toc-text">request_threaded_irq()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#irq-desc-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">irq_desc 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#irqaction-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">irqaction 结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tasklet"><span class="toc-text">tasklet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-DECLARE-TASKLET"><span class="toc-text">静态初始化 DECLARE_TASKLET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-task-init"><span class="toc-text">动态初始化 task_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%87%BD%E6%95%B0-tasklet-disable"><span class="toc-text">关闭函数 tasklet_disable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E8%83%BD%E5%87%BD%E6%95%B0-tasklet-enable"><span class="toc-text">使能函数 tasklet_enable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0-tasklet-schedule"><span class="toc-text">调度函数 tasklet_schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E5%87%BD%E6%95%B0-tasklet-kill"><span class="toc-text">销毁函数 tasklet_kill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-text">软中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">软中断接口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open-softirq"><span class="toc-text">open_softirq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raise-softirq"><span class="toc-text">raise_softirq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raise-softirq-irqoff"><span class="toc-text">raise_softirq_irqoff</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tasklet%E5%88%86%E6%9E%90"><span class="toc-text">tasklet分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-text">工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-text">共享工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#work-struct"><span class="toc-text">work_struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#INIT-WORK"><span class="toc-text">INIT_WORK()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DECLARE-WORK"><span class="toc-text">DECLARE_WORK()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#schedule-work"><span class="toc-text">schedule_work()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cancel-work-sync"><span class="toc-text">cancel_work_sync()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flush-work"><span class="toc-text">flush_work()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-text">自定义工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#workqueue-struct"><span class="toc-text">workqueue_struct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#create-workqueue"><span class="toc-text">create_workqueue()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#create-singlethread-workqueue"><span class="toc-text">create_singlethread_workqueue()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alloc-workqueue"><span class="toc-text">alloc_workqueue()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-work"><span class="toc-text">queue_work()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-work-on"><span class="toc-text">queue_work_on()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cancel-work-sync-1"><span class="toc-text">cancel_work_sync()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flush-work-queue"><span class="toc-text">flush_work_queue()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#destroy-work-queue"><span class="toc-text">destroy_work_queue()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C"><span class="toc-text">延迟工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E6%B6%88%E6%8A%96"><span class="toc-text">按键消抖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delayed-work"><span class="toc-text">delayed_work</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DECLARE-DELAYED-WORK"><span class="toc-text">DECLARE_DELAYED_WORK()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#INIT-DELAYED-WORK"><span class="toc-text">INIT_DELAYED_WORK()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#schedule-delayed-work"><span class="toc-text">schedule_delayed_work()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-delayed-work"><span class="toc-text">queue_delayed_work()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cancel-delayed-work-sync"><span class="toc-text">cancel_delayed_work_sync()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E4%BC%A0%E5%8F%82"><span class="toc-text">工作队列传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%AE%A1%E7%90%86%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="toc-text">并发管理工作队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="toc-text">工作队列的弊端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Concurrency-Managed-Workqueue"><span class="toc-text">Concurrency Managed Workqueue</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#alloc-workqueue-1"><span class="toc-text">alloc_workqueue()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-text">中断线程化技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#request-threaded-riq"><span class="toc-text">request_threaded_riq()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-text">示例</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post liquidGlass-wrapper"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2601133/" title="Linux 网络设备"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux 网络设备"/></a><div class="content"><a class="title" href="/posts/2601133/" title="Linux 网络设备">Linux 网络设备</a><time datetime="2026-01-13T14:00:00.000Z" title="发表于 2026-01-13 22:00:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601143/" title="Linux ADC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux ADC"/></a><div class="content"><a class="title" href="/posts/2601143/" title="Linux ADC">Linux ADC</a><time datetime="2026-01-13T13:18:00.000Z" title="发表于 2026-01-13 21:18:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601093/" title="Linux CAN"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux CAN"/></a><div class="content"><a class="title" href="/posts/2601093/" title="Linux CAN">Linux CAN</a><time datetime="2026-01-09T07:56:00.000Z" title="发表于 2026-01-09 15:56:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601063/" title="Linux Watchdog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux Watchdog"/></a><div class="content"><a class="title" href="/posts/2601063/" title="Linux Watchdog">Linux Watchdog</a><time datetime="2026-01-06T05:09:00.000Z" title="发表于 2026-01-06 13:09:00">2026-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601053/" title="Linux RTC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux RTC"/></a><div class="content"><a class="title" href="/posts/2601053/" title="Linux RTC">Linux RTC</a><time datetime="2026-01-05T14:09:00.000Z" title="发表于 2026-01-05 22:09:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601043/" title="Linux PWM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux PWM"/></a><div class="content"><a class="title" href="/posts/2601043/" title="Linux PWM">Linux PWM</a><time datetime="2026-01-04T10:59:00.000Z" title="发表于 2026-01-04 18:59:00">2026-01-04</time></div></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a target="_blank" rel="noopener" href="https://github.com/even629" title="github"><i class="fab fa-github"></i></a><a href="/img/qq.jpg" title="qq"><i class="fa-brands fa-qq"></i></a><a href="mailto:zhaohang731005515@proton.me" title="email"><i class="fas fa-envelope"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/519280138" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a href="/atom.xml" title="rss"><i class="fas fa-rss"></i></a></div><div class="copyright">&copy;2024 - 2026 By even629</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Frame-Hexo-blue.svg" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Theme-Butterfly.svg" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Source-Github.svg" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Copyright-BY--NC--SA.4.svg" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"> </span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.stopSakura();"><i class="fa-solid fa-feather"></i><span data-zh="樱花特效" data-en="toggle sakura"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'daaf1403d11409aaef4939871306354b'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.js"></script><script src="/js/sakura.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/solarlunar.js"></script><script src="/js/newYear.js"></script><script src="/js/pop-up-window.js"></script><script data-pjax src="/js/nav.js"></script><script data-pjax src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><svg style="display: none">
<filter
  id="glass-distortion"
  x="0%"
  y="0%"
  width="100%"
  height="100%"
  filterUnits="objectBoundingBox"
>
  <feTurbulence
    type="fractalNoise"
    baseFrequency="0.01 0.01"
    numOctaves="1"
    seed="5"
    result="turbulence"
  />
  <!-- Seeds: 14, 17,  -->

  <feComponentTransfer in="turbulence" result="mapped">
    <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
    <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
    <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
  </feComponentTransfer>

  <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap" />

  <feSpecularLighting
    in="softMap"
    surfaceScale="5"
    specularConstant="1"
    specularExponent="100"
    lighting-color="white"
    result="specLight"
  >
    <fePointLight x="-200" y="-200" z="300" />
  </feSpecularLighting>

  <feComposite
    in="specLight"
    operator="arithmetic"
    k1="0"
    k2="1"
    k3="1"
    k4="0"
    result="litImage"
  />

  <feDisplacementMap
    in="SourceGraphic"
    in2="softMap"
    scale="150"
    xChannelSelector="R"
    yChannelSelector="G"
  />
  </filter>
</svg>
<script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload="this.media='all'"><script src="/js/APlayer.min.js"></script><script src="/js/meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr class="custom-hr"/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><script async src="//at.alicdn.com/t/c/font_4847823_upluhme7cv.js"></script><!-- hexo injector body_end end --></body></html>