<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux UART | 常想一二，不思八九</title><meta name="author" content="even629"><meta name="copyright" content="even629"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux UART">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux UART">
<meta property="og:url" content="https://even629.com/posts/2512313/index.html">
<meta property="og:site_name" content="常想一二，不思八九">
<meta property="og:description" content="Linux UART">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://even629.com/images/linux_cover.webp">
<meta property="article:published_time" content="2025-12-31T12:46:13.000Z">
<meta property="article:modified_time" content="2025-12-31T12:46:13.000Z">
<meta property="article:author" content="even629">
<meta property="article:tag" content="GNU">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://even629.com/images/linux_cover.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://even629.com/posts/2512313/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="codeva-g8sPzVXu98"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://npm.elemecdn.com/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"中"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: even629","link":"链接: ","source":"来源: 常想一二，不思八九","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux UART',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel='preload', href='/img/avatar.png', as='image'><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom_card_author.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/right_menu.css"><link rel="stylesheet" href="/css/nav.css"><link rel="stylesheet" href="/css/newYear.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" href="/css/beautify_label_h.css"><link rel="stylesheet" href="/css/equipment.css"><link rel="stylesheet" href="/css/liquid_glass.css"><link rel="stylesheet" href="/css/tag_plugin_plus.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.css"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="/css/wow_animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="常想一二，不思八九" type="application/atom+xml">
</head><body><div class="float-box left top"></div><div class="float-box left bottom"></div><div class="float-box right top"></div><div class="float-box right bottom"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg" style="background-image: url(/img/12bb_background.png);"></div><div id="an_music_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/linux_top_image.jpg);"><nav class="liquidGlass-wrapper" id="nav" style="--glass-border-radius: 2rem;"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box" style="display:flex;align-items:center;justify-content:center;width:100%"><!-- 左侧博客信息区域--><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" alt="Logo"></a></span><!-- 新增的导航菜单容器（居中布局关键）--><div id="nav-menus-container"><!-- 菜单主体部分--><div id="menus"><!-- 菜单项--><div class="menus_items"><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/charts/"><i class="fa-fw fas fa-solid fa-chart-simple"></i><span> 统计</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-heart"></i><span> 分享</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment"></i><span> 说说</span></a></li><li><a class="site-page child" href="/equipment/"><i class="fa-fw fa-solid fa-toolbox"></i><span> 装备</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-solid fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-solid fa-comments"></i><span> 留言</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/en/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><!-- 显示当前标题名称--><center id="name-container"><a id="page-name" href="javascript:rmf.scrollToTop()">常想一二，不思八九</a></center></div></div><!-- 右侧功能区域（新增容器）--><div id="nav-right-container"><!-- 搜索按钮（移动到右侧）--><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><!-- 移动端汉堡菜单按钮--><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></div></nav><div id="post-info"><h1 class="post-title">Linux UART</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-31T12:46:13.000Z" title="发表于 2025-12-31 20:46:13">2025-12-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-31T12:46:13.000Z" title="更新于 2025-12-31 20:46:13">2025-12-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/2512313/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><hr>
<div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p>
</div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2025-12-31</p>
</div></div><div class='timeline-item-content'><p>init</p>
</div></div></div>

<hr>
<h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><p>串口（Serial Port）也叫串行通信接口，通常也叫做 <strong>COM 接口</strong>，是一种计算机与外部设备(如串口通信设备)进行数据通信的<strong>异步全双工接口</strong>。它通过<strong>串行传输</strong>方式，即一次只发送一个比特位（bit）来进行数据传输。</p>
<p>具体来说，典型的串口通信只需要 3 根线，分别是地线（GND），发送线（TX），接收线（RX），如下图所示，发送和接收各用一条线，<strong>没有时钟线</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704091.png" alt="CPU与串口设备的连接连接" loading="lazy"></p>
<h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><p>波特率（Baud Rate）是串口通信中的关键参数，它指的是每秒传输的比特位数或者码元速率。</p>
<p>在数字信道中，一个脉冲信号就是一个码元，如下图所示。码元速率表示在 1 秒内能发送多少码元或脉冲信号。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704131.png" alt="波特率" loading="lazy"></p>
<p>通信的双方必须设定相同的波特率才能确保数据能够正确传输。常见的标准波特率如 9600、115200 等，通常满足大多数应用需求。</p>
<blockquote>
<p>但在特定情况下，可能需要设置非标准的波特率，此时需确保所有通信设备都能支持和正确配置该波特率。</p>
<p>对于高于 1.5Mbps 的波特率的设置，可能需要通过时钟的小数分频或整数分频来实现。</p>
<p>如果无法通过分频来达到所需波特率，则可能需要调整 PLL（锁相环）设置，调整 PLL 存在一定风险，因为它可能会影响到设备的其他模块。</p>
</blockquote>
<p><strong>比特率</strong>是指<strong>单位时间内传输的比特数量</strong>，通常用 bps(bit per second)表示，单位是 bit&#x2F;s。与之相比，<strong>波特率</strong>则是<strong>每秒钟传输的码元或脉冲信号的数量</strong>。这俩者之间的关系可以用公式表示为<strong>比特率&#x3D;波特率*log2(M)</strong>，其中 M 表示每个码元承载的信息量。</p>
<p>一个码元实际上就是一个脉冲信号，它可能携带 1 个 bit，2 个bit 或者更多 bit 的数据，这取决于通信系统的具体实现方式。<strong>在二进制系统中，比特率等于波特率，因为每个码元正好承载 1 个 bit 的信息</strong>。</p>
<p>举例：假如串口的波特率为 9600，那么在二进制系统中，一秒钟可以传送多少个字节呢？</p>
<p>一个字节等于 8 个 bit，也就是 8 个高低电平变化，因为在二进制系统中，比特率等于波特率。因此一秒钟可以传输的字节数为 9600&#x2F;8&#x3D;1200 字节。</p>
<h2 id="串口通讯协议"><a href="#串口通讯协议" class="headerlink" title="串口通讯协议"></a>串口通讯协议</h2><h3 id="数据流结构"><a href="#数据流结构" class="headerlink" title="数据流结构"></a>数据流结构</h3><p>在串口通信中，除了关注波特率外，数据流的结构也至关重要。</p>
<p>每帧数据包括 11 位：</p>
<ul>
<li>1位起始位</li>
<li>8 位数据位</li>
<li>1 位奇偶校验位</li>
<li>1 位停止位</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704164.png" alt="串口数据流结构" loading="lazy"></p>
<ul>
<li><p><strong>起始位</strong>：表示数据传输的开始，数据线上空闲状态是 1，从高电平（空闲状态）拉低表示开始传输数据。</p>
</li>
<li><p><strong>数据位</strong>：指每个字节中的数据位数，通常为 7 或 8 位。</p>
</li>
<li><p><strong>校验位</strong>：用于验证传输数据的准确性，其类型包括奇校验、偶校验、0 校验、和 1 校验。</p>
</li>
<li><p><strong>奇校验（odd parity）</strong>: 当实际数据中 1 的个数为偶数的时候，校验位为 1，否则这个校验位就是 0。</p>
</li>
<li><p><strong>偶校验（even parity）</strong>: 当实际数据中 1 的个数为偶数的时候，校验位为 0，否则这个校验位就是 1。</p>
</li>
<li><p><strong>0 校验（space parity）</strong>: 校验位恒为 0，如果为 1 表示错误。</p>
</li>
<li><p><strong>1 校验（mark parity）</strong>: 校验位恒为 1，如果为 0 表示错误。</p>
</li>
<li><p><strong>停止位</strong>：指在每个数据字节传输结束后发送的位数，通常为 1 或 2 位。</p>
</li>
</ul>
<h3 id="时序波形分析"><a href="#时序波形分析" class="headerlink" title="时序波形分析"></a>时序波形分析</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704206.png" alt="逻辑分析仪波形" loading="lazy"></p>
<p>当<strong>数据线空闲时是高电平</strong>，而在<strong>数据传输时则会被拉低</strong>，图中的第一个脉冲对应于起始位。紧随其后的是 8 位数据位，它们按照最低有效位（LSB）优先的顺序传输。</p>
<p>例如，数据位“00110001”转换成十六进制是 0x31，换算成十进制是 49。在 ASCII码中，49 对应的字符是’1’，因此传输的数据是 1。数据传输完成之后，总线被拉高。</p>
<h2 id="串口通信接口的类型"><a href="#串口通信接口的类型" class="headerlink" title="串口通信接口的类型"></a>串口通信接口的类型</h2><p>UART 只规定了收发的时序，即“先发起始位，再发数据位，校验位，最后发停止位”，只规定了高低电平，但是并没有规定高电平指的是多少伏，低电平指的是多少伏。</p>
<p>串口一般的接口电平有 <strong>TTL</strong>，<strong>RS232</strong>,<strong>RS485</strong>,<strong>RS422</strong>，并且<strong>每种接口通常需要相应的电平转换芯片</strong>。直<strong>接使用处理器引出的串口接口时，通常是 TTL 电平</strong>。</p>
<p>然而，处理器的不同型号或供应商可能存在电平差异，这意味着在某些情况下不能直接连接设备。因此，为了确保正常通信必须进行适当的电平转换。一般的串口接口电平对比如下表所示：</p>
<table>
<thead>
<tr>
<th>电平标准</th>
<th>逻辑电平定义</th>
<th>典型高&#x2F;低电平电压</th>
<th>信号类型</th>
<th>最大传输距离</th>
<th>主要特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TTL</strong></td>
<td>0 &#x3D; 低电平<br /> 1 &#x3D; 高电平</td>
<td>低电平：0 V 高电平：1.8 V &#x2F; 2.5 V &#x2F; 3.3 V &#x2F; 5 V（取决于供电）</td>
<td>单端信号</td>
<td>几米（通常 ≤ 2–5 m）</td>
<td>板内或板间短距离通信 ，与 MCU、传感器等直接兼容 ， 抗干扰能力弱，不适用于长距离</td>
</tr>
<tr>
<td><strong>RS-232</strong></td>
<td>0 &#x3D; <strong>正电压</strong>（+3 V ~ +15 V） <br />1 &#x3D; <strong>负电压</strong>（-3 V ~ -15 V）</td>
<td>逻辑 0（空号）：+3 V ~ +15 V 逻辑 1（传号）：-3 V ~ -15 V 常用 ±12 V</td>
<td>单端（但使用正负电压）</td>
<td>约 15–50 米（速率越低距离越长）</td>
<td>支持点对点通信，抗干扰能力较强于 TTL，需电平转换芯片（如 MAX232），已逐渐被 USB 等替代</td>
</tr>
<tr>
<td><strong>RS-422</strong></td>
<td>差分信号： <br />1 &#x3D; A &gt; B（+2 V ~ +6 V）<br /> 0 &#x3D; A &lt; B（-2 V ~ -6 V）</td>
<td>差分电压：±2 V ~ ±6 V</td>
<td><strong>差分信号</strong>（全双工，4 线）</td>
<td>最大约 <strong>1200 米</strong>（@ 100 kbps）</td>
<td>支持全双工通信，强抗共模干扰能力，适用于工业环境，通常为 1 发送器，多接收器</td>
</tr>
<tr>
<td><strong>RS-485</strong></td>
<td>差分信号：<br /> 1 &#x3D; A &gt; B（+1.5 V ~ +5 V）<br /> 0 &#x3D; A &lt; B（-1.5 V ~ -5 V）</td>
<td>差分电压：≥ ±1.5 V（典型 ±2 V ~ ±5 V）</td>
<td><strong>差分信号</strong>（半双工或全双工，2 或 4 线）</td>
<td>最大约 <strong>1200 米</strong>（@ 100 kbps） （理论可达 1219 米）</td>
<td>支持多点通信（最多 32~256 节点） ，广泛用于工业总线（如 Modbus），抗干扰强，适合长距离、噪声环境</td>
</tr>
</tbody></table>
<h3 id="RS232接口"><a href="#RS232接口" class="headerlink" title="RS232接口"></a>RS232接口</h3><p><strong>RS232（Recommended Standard 232）</strong> 协议是由美国电子工业协会在 1970 年制定的串行通信标准。该标准<strong>统一了串口通信的连接器和引脚定义</strong>，如下图所示，并明确规定了每个连接器引脚的电平标准</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704249.png" alt="DB9公头和母头" loading="lazy"></p>
<h4 id="DB9-引脚说明"><a href="#DB9-引脚说明" class="headerlink" title="DB9 引脚说明"></a><strong>DB9 引脚说明</strong></h4><p>DB9 是一种常见的串口连接器，通常用于 RS-232 串口通信和其他串行通信应用。它包含 9个引脚，每个引脚都有特定的功能。下面是 DB9 连接器的引脚说明：</p>
<ul>
<li><strong>Pin 1 - DCD (Data Carrier Detect)</strong>:数据载波检测。指示远程设备是否准备好进行通信。</li>
<li><strong>Pin 2 - RXD (Receive Data)</strong>:接收数据。从远程设备接收数据流。</li>
<li><strong>Pin 3 - TXD (Transmit Data)</strong>:发送数据。向远程设备发送数据流。</li>
<li><strong>Pin 4 - DTR (Data Terminal Ready)</strong>:数据终端就绪。指示数据终端设备（如计算机）准备好进行通信。</li>
<li><strong>Pin 5 - GND (Ground)</strong>:地线。电气接地，用于电路的参考和屏蔽。</li>
<li><strong>Pin 6 - DSR (Data Set Ready)</strong>:数据集准备好。指示远程设备准备好接收和发送数据。</li>
<li><strong>Pin 7 - RTS (Request to Send)</strong>:请求发送。发送方使用此信号请求开始发送数据。</li>
<li><strong>Pin 8 - CTS (Clear to Send)</strong>:清除发送。接收方使用此信号表示准备好接收数据。</li>
<li><strong>Pin 9 - RI (Ring Indicator)</strong>:铃信号指示器。指示远程设备发送了铃响信号。</li>
</ul>
<p>RS232 本质上也是串口协议，与串口协议相同。但它规定了串口的物理接口和电平特性，因此在硬件层面有所不同，但在软件编程和串口通信的实现上并无区别</p>
<h4 id="电平特性"><a href="#电平特性" class="headerlink" title="电平特性"></a>电平特性</h4><ul>
<li><p>RS232 接收-发送端的电信号是{ % emp 相对于公共地线（GND）的电压信号 %}。</p>
<ul>
<li>在 RS232 标准中，<strong>电压差值在+3V 至+15V 之间被定义为逻辑“0”</strong>，而在**-3V 至-15V 之间则表示逻辑“1”**。电压差值在-3V 至+3V 之间的情况未定义。</li>
<li>通常，实际应用中希望电压差的绝对值在 5V 至 15V 之间，以确保可靠的信号传输。</li>
<li>在数据发送时，发送端驱动器输出+5V 至+15V 的正电压信号表示逻辑“0”，而-5V 至-15V 的负电压信号表示逻辑“1”。</li>
<li>在数据接收时，只要检测到大于3V 的电信号，即视为有效信号。</li>
</ul>
</li>
<li><p>RS232 接口在发送和接收时具有相对较高的电流能力，可以处理相对较大的电流负载，这使得它适合于长距离通信和连接外部设备。</p>
</li>
<li><p>RS232 信号具有较高的抗干扰能力，能够在工业环境中稳定运行，不易受到电磁干扰的影响。</p>
</li>
<li><p>RS232 包括以下信号线：</p>
<ul>
<li>发送线（Tx）</li>
<li>接收线（Rx）</li>
<li>地线（Ground）</li>
<li>数据终端就绪（DTR）</li>
<li>数据就绪（DSR）</li>
<li>请求发送（RTS）</li>
<li>清除发送（CTS）</li>
<li>环路信号检测（DSR）</li>
</ul>
</li>
<li><p>RS232 支持各种波特率，通常从低速率到较高速率，最高可以达到数百千位每秒（kbps）</p>
</li>
</ul>
<p> iTOP-RK3568 开发板上，调试串口使用了 MAX3232 芯片将 TTL 电平转换成 232 电平，调试串口的原理图如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704297.png" alt="Debug UART2" loading="lazy"></p>
<h3 id="RS485接口"><a href="#RS485接口" class="headerlink" title="RS485接口"></a>RS485接口</h3><p>RS485 标准是由电信行业协会（Telecommunications Industry Association, TIA）和电子工业联盟（Electronic Industries Alliance, EIA）共同制定的。该标准的主要目的是<emp>解决长距离通信需求（最长达 1200 米）以及提供优秀的抗干扰性能</emp>。</p>
<h4 id="特点和优势"><a href="#特点和优势" class="headerlink" title="特点和优势"></a>特点和优势</h4><ul>
<li><strong>长距离通信能力</strong>：RS485 能够在理想条件下实现长达 1200 米的通信距离，适用于需要远距离数据传输的场合。</li>
<li><strong>抗干扰能力强</strong>：由于采用差分信号传输方式，RS485 能有效抵御电磁干扰（EMI）和射频干扰（RFI），保证数据传输的稳定性和可靠性。</li>
<li><strong>多站能力</strong>：RS485 支持多个设备（最多 32 个）在同一条总线上进行通信，每个设备可以独立地发送和接收数据，从而实现灵活的网络组网。</li>
<li>应用广泛：RS485 广泛应用于工业自动化控制系统、建筑自动化、智能家居系统、电力系统监控等领域，满足对长距离、高速和可靠通信的要求</li>
</ul>
<h4 id="电平特性-1"><a href="#电平特性-1" class="headerlink" title="电平特性"></a>电平特性</h4><p>RS485 的电平特性如下：</p>
<ul>
<li><strong>差分信号传输</strong>：RS485 使用差分信号进行数据传输，即数据信号是相对于两条信号线（通常标记为 A 和 B 线）之间的电压差来表示的。这种差分信号传输方式使得 RS485 具有良好的抗干扰能力和长距离传输能力。</li>
<li><strong>电压范围</strong>：<ul>
<li><strong>逻辑“ 1”以两线间的电压差为+(2~6)V 表示</strong>；</li>
<li><strong>逻辑“ 0”以两线间的电压差为-(2~6)V表示</strong>。</li>
<li><u>接口信号电平比 RS232 降低了</u>，不易损坏接口电路的芯片，且**该电平与 TTL 电平兼容**，可方便与 TTL 电路连接。</li>
</ul>
</li>
<li>电流能力：RS485 发送器具有较强的驱动能力，能够推动较长的通信线路和多个接收器。接收器能够处理较大的输入电流，以确保信号的可靠接收。</li>
<li>电气特性：RS485 支持<u>多个设备（最多 32 个）在同一条总线上进行通信</u>。支持长达 1200米的通信距离，在特定情况下甚至可以更长</li>
</ul>
<p> iTOP-RK3568 开发板上使用 <strong>SIT3485E 芯片</strong>将 TTL 电平转换为 485 电平，原理图如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704354.png" alt="将TTL电平转为485电平" loading="lazy"></p>
<p>可知 RK3568 开发板的 RS485 接口实际上是通过 SIT3485E 芯片转接的串口 7。</p>
<h4 id="SIT3485E芯片"><a href="#SIT3485E芯片" class="headerlink" title="SIT3485E芯片"></a>SIT3485E芯片</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704396.png" alt="SIT3485E 芯片特点" loading="lazy"></p>
<p>SIT3485E 是一款 3.0V~5.5V 宽电源供电、总线端口 ESD 水平达到 15KV HBM 以上、总线耐压范围达到±15V、<strong>半双工</strong>、<strong>低功耗</strong>，<strong>功能完全满足 TIA&#x2F;EIA-485 标准要求的 RS-485 收发器</strong>。</p>
<p>SIT3485E 包括<strong>一个驱动器</strong>和<strong>一个接收器</strong>，两者均可<strong>独立使能与关闭</strong>。当两者均禁用时，驱动器与接收器均输出高阻态。</p>
<p>SIT3485E 具有 1&#x2F;8 负载，允许 256 个 SIT3485E 收发器并接在同一通信总线上。可实现高达 12Mbps 的无差错数据传输。</p>
<p>SIT3485E 工作电压范围为 3.0~5.5 V，具备失效安全（fail-safe）、限流保护、过压保护等功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704441.png" alt="引脚分布图" loading="lazy"></p>
<table>
<thead>
<tr>
<th>引脚序号</th>
<th>引脚名称</th>
<th>引脚功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>RO</td>
<td><strong>接收器输出端</strong>。 当 &#x2F;RE 为低电平时，若 A-B ≥ -10mV，RO 输出为高电平； 若 A-B ≤ -200mV，RO 输出为低电平。</td>
</tr>
<tr>
<td>2</td>
<td>&#x2F;RE</td>
<td><strong>接收器输出使能控制</strong>。 当 &#x2F;RE 接低电平时，接收器输出使能，RO 输出有效； 当 &#x2F;RE 接高电平时，接收器输出禁能，RO 为高阻态； &#x2F;RE 接高电平且 DE 接低电平时，器件进入低功耗关断模式。</td>
</tr>
<tr>
<td>3</td>
<td>DE</td>
<td><strong>驱动器输出使能控制</strong>。 DE 接高电平时驱动器输出有效，DE 为低电平时输出为高阻态； &#x2F;RE 接高电平且 DE 接低电平时，器件进入低功耗关断模式。</td>
</tr>
<tr>
<td>4</td>
<td>DI</td>
<td><strong>DI 驱动器输入</strong>。 DE 为高电平时，DI 上的低电平使驱动器同相端 A 输出为低电平，驱动器反相端 B 输出为高电平； DI 上的高电平将使同相端输出为高电平，反相端输出为低。</td>
</tr>
<tr>
<td>5</td>
<td>GND</td>
<td><strong>接地</strong></td>
</tr>
<tr>
<td>6</td>
<td>A</td>
<td><strong>接收器同相输入和驱动器同相输出端</strong></td>
</tr>
<tr>
<td>7</td>
<td>B</td>
<td><strong>接收器反相输入和驱动器反相输出端</strong></td>
</tr>
<tr>
<td>8</td>
<td>VCC</td>
<td><strong>接电源</strong></td>
</tr>
</tbody></table>
<p>由引脚定义图可知：</p>
<ul>
<li>RO 引脚为接收器输出端，在原理图上连接到 UART7_RX_M1 引脚。</li>
<li>DI引脚为 DI 驱动器输入引脚，在原理图上连接到 UART7_TX_M1 引脚。</li>
<li>A 引脚是接收器同向输入和驱动器同向输出端</li>
<li>B 引脚是接收器反向输入和驱动器反向输出端，A 和 B 就是 RS485 的差分对了。</li>
<li><u>RE</u> 引脚是接收器输出使能控制引脚
<ul>
<li>当&#x2F;RE 接低电平时，接收器输出使能，RO 输出有效</li>
<li>当&#x2F;RE 接高电平时，接收器输出禁能，RO 为高阻态。</li>
</ul>
</li>
<li>DE 引脚是驱动器输出使能控制引脚，DE 接高电平时驱动器输出有效，DE 为低电平时输出为高阻态。</li>
<li><u>RE</u>接高电平且 DE 接低电平时，器件进入低功耗模式。</li>
</ul>
<p>简单来说：</p>
<ul>
<li><u>RE</u>为低电平时，RO 输出有效。反之 RO 高阻态，也就是无效。RO 接的 UART7_RX_M1，UART7_RX_M1 是串口的接收引脚。因此，/RE 低电平时，串口可以接收数据，反之串口无法接收数据。</li>
<li>DE 是高电平时，DI 有效，DI 接的是 UART7_TX_M1，UART7_RX_M1 是串口发送引脚，因此，DE 是高电平时，DI 上的低电平使驱动器 同向端 A 输出为低电平，驱动器反向端 B 输出为高电平，串口可以发送数据，反之串口无法发送数据。</li>
</ul>
<p><strong><u>RE</u> 和 DE 有效电平刚好相反</strong>，又因为 485 是<strong>半双工</strong>，不能同时收发。所以<u>RE</u> 和 DE 肯定不能同时开启，<strong>即<u>RE</u> 和 DE 的电平必须相同</strong>。这样<u>RE</u>开启，就等于 DE 关闭，所以这两个引脚连在了一起。</p>
<p>这样就很清晰了，如果 GPIO0_C6 输出低电平，<u>RE</u> 和 DE 是低电平，<u>RE</u> 是低电平时，串口可以接收数据，DE 是低电平时，串口不能发送数据。</p>
<p>如果 GPIO0_C6 输出高电平，<u>RE</u>和 DE 是高电平，<u>RE</u> 是高电平时，串口不能接收数据，DE 是高电平时，串口可以发送数据。</p>
<p>也就是说，我们需要用 GPIO0_C6 这个引脚的高低电平来控制 RS485 是发送还是接收。因此，我们需要编写一个驱动来达到这个目的。迅为提供的源码中默认配置了驱动来控制GPIO0_C6。</p>
<h5 id="自收发-485-电路"><a href="#自收发-485-电路" class="headerlink" title="自收发 485 电路"></a>自收发 485 电路</h5><p>除了软件控制外，还可以通过硬件实现自动切换，以实现 RS485 的自动收发功能。软件控制发送和接收存在一定的时间差，为了减少这种时间差，迅为开发板的底板原理图进行了优化，兼容了硬件实现自动收发。具体的修改方式是将 R295 去掉，并将下图中标记为 DNP 的元件都进行焊接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704497.png" alt="UART7_M1 To RS485" loading="lazy"></p>
<ul>
<li>当 UART_TX_M1 为高电平时，Q17 的基极也为高电平，导致 Q17 导通，<u>RE</u> 和 DE 为低电平，从而串口处于接收数据模式</li>
<li>当 UART_TX_M1 为低电平时，Q17的基极为低电平，导致Q17截止，<u>RE</u> 和DE为高电平，串口处于发送数据模式。由于UART_TX_M1 在空闲时为高电平，表明串口处于接收数据状态；当 UART_TX_M1 被拉低时，串口则处于发送数据状态。</li>
</ul>
<blockquote>
<p>既然 UART_TX_M1 高电平表示接收模式，那发送 1 时也是高电平。这样芯片会一直处于接收模式，导致 1 无法发送出去，是吗？</p>
<p><strong>当转接芯片处于接收模式时，A 和 B 两个引脚会处于高阻态模式</strong>。</p>
<p>高阻态意味着非常大的电阻，几乎等同于断路。<strong>此时，A 由上拉电阻拉高，B 由下拉电阻拉低</strong>。</p>
<p>因此，<strong>A 高、B 低表示通信中的 1</strong>。通过这种“接收模式”，我们巧妙地将“1”发送出去了。</p>
<p>这一优化省去了一个 RS485 收发控制 IO，将 RS485 完全当作串口使用，方便编写驱动。</p>
</blockquote>
<h1 id="串口子系统框架"><a href="#串口子系统框架" class="headerlink" title="串口子系统框架"></a>串口子系统框架</h1><p>串口子系统框架是 Linux 内核中专门用于处理串口设备的模块化框架，框架图如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704545.png" alt="串口子系统框架" loading="lazy"></p>
<ul>
<li><strong>应用层</strong>：位于最顶层，是串口子系统中用户空间应用程序与内核空间之间的接口，应用层包括了用户空间的串口应用程序，如串口通信工具 minicom 等。</li>
<li><strong>字符设备层</strong>：位于应用层的下方，负责将用户空间的串口读写请求传递给内核空间的tty_core 层。字符设备层将串口设备看作一个特殊的字符设备，通过字符设备接口来进行操作。</li>
<li><strong>tty_core 层</strong>：位于字符设备层的下方，是 Linux 内核中用于管理串口设备的核心模块，它处理串口设备的基本功能，如数据传输，控制，缓冲管理等。tty_core 层与具体的串口硬件无关，是串口设备的通用处理层。</li>
<li><strong>uart_core 层</strong>：位于 tty_core 层的下方，提供了串口设备的底层驱动接口，负责与具体的串口硬件进行通信。uart_core 层负责控制串口数据的发送和接收、中断处理、时钟管理等底层操作。</li>
<li><strong>硬件层</strong>：位于最底层，是串口子系统中与具体硬件有关的部分。硬件层包括了串口硬件的驱动程序，与具体的串口控制器进行通信，实现对硬件的底层控制和操作。</li>
</ul>
<h2 id="配置串口驱动"><a href="#配置串口驱动" class="headerlink" title="配置串口驱动"></a>配置串口驱动</h2><p>在瑞芯微官方提供的 SDK 内核源码里面，串口驱动使用的是 8250 通用串口驱动，以下是主要驱动文件</p>
<ul>
<li><code>drivers/tty/serial/8250/8250_core.c</code>     8250 串口驱动核心</li>
<li><code>drivers/tty/serial/8250/8250_dw.c</code>         Synopsis DesignWare 8250 串口驱动</li>
<li><code>drivers/tty/serial/8250/8250_dma.c</code>       8250 串口 DMA 驱动</li>
<li><code>drivers/tty/serial/8250/8250_port.c</code>     8250 串口端口操作</li>
<li><code>drivers/tty/serial/8250/8250_early.c</code>   8250 串口 early console 驱动</li>
</ul>
<p>make menuconfig中选中驱动</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Device Driver / <span class="type">Character</span> devices / <span class="type">Serial</span> drivers</span><br><span class="line">	[*] Console <span class="keyword">on</span> <span class="number">8250</span>/<span class="number">16550</span> <span class="keyword">and</span> compatible <span class="type">serial</span> port</span><br></pre></td></tr></table></figure>



<p>迅为提供的 SDK 源码设备树中默认打开了串口 9，打开<code>arch/arm64/boot/dts/rockchip/rk3568.dtsi</code>设备树文件，串口 9 控制器的设备树节点如下所示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">uart9:</span> <span class="title class_">serial@fe6d0000</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-uart&quot;</span>, <span class="string">&quot;snps,dw-apb-uart&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe6d0000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">125</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> SCLK_UART9&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_UART9&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;baudclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">reg-shift</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">reg-io-width</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">dmas</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">18</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">19</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;uart9m0_xfer</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>compatible</code>：指定设备的兼容性字符串，表示此串口设备兼容于 <code>rockchip,rk3568-uart</code> 和<code>snps,dw-apb-uart</code> 两种串口控制器。这有助于设备树绑定相应的驱动程序。</li>
<li><code>reg</code>：指定串口设备的地址和大小，0xfe6d0000 是串口设备的基地址，0x100 表示地址空间的大小。</li>
<li><code>interrupts</code>：指定串口设备的中断信息，包括中断类型和中断号。</li>
<li><code>clocks</code>：指定串口设备所使用的时钟源，包括波特率时钟和 APB 时钟。</li>
<li><code>clock-names</code>：指定时钟源的名称，用于与时钟源的具体配置相匹配。</li>
<li><code>reg-shift</code>：表示地址偏移量的位数，即每个寄存器的偏移量是按字节还是按字（byte）。</li>
<li><code>reg-io-width</code>：表示对设备地址和数据的访问宽度，这里是 4 表示 4 字节宽度。</li>
<li><code>dmas</code>：指定串口设备使用的 DMA 控制器以及 DMA 通道号，用于数据传输的 DMA 操作。</li>
<li><code>dma-names</code>:可选值为<ul>
<li><code>tx</code>打开 tx dma</li>
<li><code>rx</code>打开 rx dma</li>
<li><code>!tx</code>关闭 tx dma</li>
<li><code>!rx</code>关闭 rx dma</li>
</ul>
</li>
<li><code>pinctrl-names</code> 和 <code>pinctrl-0</code>：用于串口设备的管脚控制，以配置和管理串口设备的引脚设置。可选参数为如下所示：<ul>
<li><code>&amp;uart9m0_xfer</code> 配置 tx 和 rx 引脚为 iomux group 0</li>
<li><code>&amp;uart9m1_xfer</code> 配置 tx 和 rx 引脚为 iomux group 1</li>
<li><code>&amp;uart9m0_ctsn</code> 和<code>&amp;uart1m0_rtsn</code> 配置硬件自动流控 cts 和 rts 引脚为 iomux group 0</li>
<li><code>&amp;uart9m1_ctsn</code>和<code>&amp;uart1m1_rtsn</code> 配置硬件自动流控 cts 和 rts 引脚为 iomux group 1</li>
</ul>
</li>
<li><code>status</code>：表示串口设备的状态，这里是 “disabled” 表示设备当前处于禁用状态。如果设置为“okay”表示打开设备</li>
</ul>
<h2 id="uart-driver-注册流程分析"><a href="#uart-driver-注册流程分析" class="headerlink" title="uart_driver 注册流程分析"></a>uart_driver 注册流程分析</h2><h3 id="uart-相关底层结构体"><a href="#uart-相关底层结构体" class="headerlink" title="uart 相关底层结构体"></a>uart 相关底层结构体</h3><p>uart 相关底层结构体之间的关系如下所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704587.png" alt="uart 相关底层结构体之间的关系" loading="lazy"></p>
<h4 id="struct-uart-driver"><a href="#struct-uart-driver" class="headerlink" title="struct uart_driver"></a>struct uart_driver</h4><p><code>uart_driver</code> 结构体代 表 UART 驱动，<code>uart_driver</code> 定义在 <code>include/linux/serial_core.h</code> 文件中，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span><span class="comment">// 模块所有者</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*driver_name;<span class="comment">// 驱动程序名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*dev_name;<span class="comment">// 设备名称</span></span><br><span class="line">	<span class="type">int</span>			 major;<span class="comment">// 设备分配的主设备号</span></span><br><span class="line">	<span class="type">int</span>			 minor;<span class="comment">// 设备分配的次设备号</span></span><br><span class="line">	<span class="type">int</span>			 nr;<span class="comment">// 设备的唯一标识符</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span>		*<span class="title">cons</span>;</span><span class="comment">// 控制台的指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * these are private; the low level driver should not</span></span><br><span class="line"><span class="comment">	 * touch these; they should be initialised to NULL</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span>	*<span class="title">state</span>;</span><span class="comment">// 指向 UART 驱动程序状态的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span>	*<span class="title">tty_driver</span>;</span><span class="comment">// 指向 TTY 驱动程序的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>struct uart_driver</code> 封装了 <code>tty_driver</code>，使得底层的 UART 驱动不需要关心 <code>tty_driver</code>。</p>
<h4 id="struct-uart-port"><a href="#struct-uart-port" class="headerlink" title="struct uart_port"></a>struct uart_port</h4><p>uart_port 是针对一个串口的抽象，定义在 <code>kernel/include/linux/serial_core.h</code>，其内部包含一个 <code>uart_state</code> 类型的成员变量，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span>		lock;			<span class="comment">/* port lock */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		iobase;			<span class="comment">/* in/out[bwl] */</span><span class="comment">/* io 端口基地址（物理） */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> __iomem	*membase;		<span class="comment">/* read/write[bwl] */</span><span class="comment">/* io 内存基地址（虚拟） */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>		<span class="params">(*serial_in)</span><span class="params">(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>)</span>;</span><br><span class="line">	<span class="type">void</span>			(*serial_out)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span>			(*set_termios)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">				               <span class="keyword">struct</span> ktermios *new,</span><br><span class="line">				               <span class="keyword">struct</span> ktermios *old);</span><br><span class="line">	<span class="type">void</span>			(*set_ldisc)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">					     <span class="keyword">struct</span> ktermios *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>		<span class="params">(*get_mctrl)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;</span><br><span class="line">	<span class="type">void</span>			(*set_mctrl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>		<span class="params">(*get_divisor)</span><span class="params">(<span class="keyword">struct</span> uart_port *,</span></span><br><span class="line"><span class="params">					       <span class="type">unsigned</span> <span class="type">int</span> baud,</span></span><br><span class="line"><span class="params">					       <span class="type">unsigned</span> <span class="type">int</span> *frac)</span>;</span><br><span class="line">	<span class="type">void</span>			(*set_divisor)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">					       <span class="type">unsigned</span> <span class="type">int</span> baud,</span><br><span class="line">					       <span class="type">unsigned</span> <span class="type">int</span> quot,</span><br><span class="line">					       <span class="type">unsigned</span> <span class="type">int</span> quot_frac);</span><br><span class="line">	<span class="type">int</span>			(*startup)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">	<span class="type">void</span>			(*shutdown)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">	<span class="type">void</span>			(*throttle)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">	<span class="type">void</span>			(*unthrottle)(<span class="keyword">struct</span> uart_port *port);</span><br><span class="line">	<span class="type">int</span>			(*handle_irq)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span>			(*pm)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> state,</span><br><span class="line">				      <span class="type">unsigned</span> <span class="type">int</span> old);</span><br><span class="line">	<span class="type">void</span>			(*handle_break)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">int</span>			(*rs485_config)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">						<span class="keyword">struct</span> serial_rs485 *rs485);</span><br><span class="line">	<span class="type">int</span>			(*iso7816_config)(<span class="keyword">struct</span> uart_port *,</span><br><span class="line">						  <span class="keyword">struct</span> serial_iso7816 *iso7816);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;			<span class="comment">/* irq number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		irqflags;		<span class="comment">/* irq flags  */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		uartclk;		<span class="comment">/* base uart clock */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		fifosize;		<span class="comment">/* tx fifo size */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		x_char;			<span class="comment">/* xon/xoff char */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		regshift;		<span class="comment">/* reg offset shift */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		iotype;			<span class="comment">/* io access style */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		quirks;			<span class="comment">/* internal quirks */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_PORT		(SERIAL_IO_PORT)	<span class="comment">/* 8b I/O port access */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_HUB6		(SERIAL_IO_HUB6)	<span class="comment">/* Hub6 ISA card */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM		(SERIAL_IO_MEM)		<span class="comment">/* driver-specific */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM32		(SERIAL_IO_MEM32)	<span class="comment">/* 32b little endian */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_AU			(SERIAL_IO_AU)		<span class="comment">/* Au1x00 and RT288x type IO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_TSI		(SERIAL_IO_TSI)		<span class="comment">/* Tsi108/109 type IO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM32BE		(SERIAL_IO_MEM32BE)	<span class="comment">/* 32b big endian */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPIO_MEM16		(SERIAL_IO_MEM16)	<span class="comment">/* 16b little endian */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* quirks must be updated while holding port mutex */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPQ_NO_TXEN_TEST	BIT(0)</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		read_status_mask;	<span class="comment">/* driver specific */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		ignore_status_mask;	<span class="comment">/* driver specific */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span>	*<span class="title">state</span>;</span>			<span class="comment">/* pointer to parent state */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_icount</span>	<span class="title">icount</span>;</span>			<span class="comment">/* statistics */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span>		*<span class="title">cons</span>;</span>			<span class="comment">/* struct console, if any */</span></span><br><span class="line">	<span class="comment">/* flags must be updated while holding port mutex */</span></span><br><span class="line">	<span class="type">upf_t</span>			flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These flags must be equivalent to the flags defined in</span></span><br><span class="line"><span class="comment">	 * include/uapi/linux/tty_flags.h which are the userspace definitions</span></span><br><span class="line"><span class="comment">	 * assigned from the serial_struct flags in uart_set_info()</span></span><br><span class="line"><span class="comment">	 * [for bit definitions in the UPF_CHANGE_MASK]</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Bits [0..UPF_LAST_USER] are userspace defined/visible/changeable</span></span><br><span class="line"><span class="comment">	 * The remaining bits are serial-core specific and not modifiable by</span></span><br><span class="line"><span class="comment">	 * userspace.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_FOURPORT		((__force upf_t) ASYNC_FOURPORT       <span class="comment">/* 1  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SAK			((__force upf_t) ASYNC_SAK            <span class="comment">/* 2  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_HI		((__force upf_t) ASYNC_SPD_HI         <span class="comment">/* 4  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_VHI		((__force upf_t) ASYNC_SPD_VHI        <span class="comment">/* 5  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_CUST		((__force upf_t) ASYNC_SPD_CUST   <span class="comment">/* 0x0030 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_WARP		((__force upf_t) ASYNC_SPD_WARP   <span class="comment">/* 0x1010 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_MASK		((__force upf_t) ASYNC_SPD_MASK   <span class="comment">/* 0x1030 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SKIP_TEST		((__force upf_t) ASYNC_SKIP_TEST      <span class="comment">/* 6  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_AUTO_IRQ		((__force upf_t) ASYNC_AUTO_IRQ       <span class="comment">/* 7  */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_HARDPPS_CD		((__force upf_t) ASYNC_HARDPPS_CD     <span class="comment">/* 11 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SPD_SHI		((__force upf_t) ASYNC_SPD_SHI        <span class="comment">/* 12 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_LOW_LATENCY		((__force upf_t) ASYNC_LOW_LATENCY    <span class="comment">/* 13 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_BUGGY_UART		((__force upf_t) ASYNC_BUGGY_UART     <span class="comment">/* 14 */</span> )</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_MAGIC_MULTIPLIER	((__force upf_t) ASYNC_MAGIC_MULTIPLIER <span class="comment">/* 16 */</span> )</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_NO_THRE_TEST	((__force upf_t) (1 &lt;&lt; 19))</span></span><br><span class="line"><span class="comment">/* Port has hardware-assisted h/w flow control */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_AUTO_CTS		((__force upf_t) (1 &lt;&lt; 20))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_AUTO_RTS		((__force upf_t) (1 &lt;&lt; 21))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_HARD_FLOW		((__force upf_t) (UPF_AUTO_CTS | UPF_AUTO_RTS))</span></span><br><span class="line"><span class="comment">/* Port has hardware-assisted s/w flow control */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SOFT_FLOW		((__force upf_t) (1 &lt;&lt; 22))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_CONS_FLOW		((__force upf_t) (1 &lt;&lt; 23))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_SHARE_IRQ		((__force upf_t) (1 &lt;&lt; 24))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_EXAR_EFR		((__force upf_t) (1 &lt;&lt; 25))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_BUG_THRE		((__force upf_t) (1 &lt;&lt; 26))</span></span><br><span class="line"><span class="comment">/* The exact UART type is known and should not be probed.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_FIXED_TYPE		((__force upf_t) (1 &lt;&lt; 27))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_BOOT_AUTOCONF	((__force upf_t) (1 &lt;&lt; 28))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_FIXED_PORT		((__force upf_t) (1 &lt;&lt; 29))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_DEAD		((__force upf_t) (1 &lt;&lt; 30))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_IOREMAP		((__force upf_t) (1 &lt;&lt; 31))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __UPF_CHANGE_MASK	0x17fff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_CHANGE_MASK		((__force upf_t) __UPF_CHANGE_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPF_USR_MASK		((__force upf_t) (UPF_SPD_MASK|UPF_LOW_LATENCY))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __UPF_CHANGE_MASK &gt; ASYNC_FLAGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> Change mask not equivalent to userspace-visible bit defines</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must hold termios_rwsem, port mutex and port lock to change;</span></span><br><span class="line"><span class="comment">	 * can hold any one lock to read.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">upstat_t</span>		status;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_CTS_ENABLE	((__force upstat_t) (1 &lt;&lt; 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_DCD_ENABLE	((__force upstat_t) (1 &lt;&lt; 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_AUTORTS		((__force upstat_t) (1 &lt;&lt; 2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_AUTOCTS		((__force upstat_t) (1 &lt;&lt; 3))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_AUTOXOFF		((__force upstat_t) (1 &lt;&lt; 4))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPSTAT_SYNC_FIFO	((__force upstat_t) (1 &lt;&lt; 5))</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>			hw_stopped;		<span class="comment">/* sw-assisted CTS flow state */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		mctrl;			<span class="comment">/* current modem ctrl settings */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		timeout;		<span class="comment">/* character-based timeout */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		type;			<span class="comment">/* port type */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span>	*<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		custom_divisor;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		line;			<span class="comment">/* port index */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		minor;</span><br><span class="line">	<span class="type">resource_size_t</span>		mapbase;		<span class="comment">/* for ioremap */</span></span><br><span class="line">	<span class="type">resource_size_t</span>		mapsize;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">dev</span>;</span>			<span class="comment">/* parent device */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sysrq;			<span class="comment">/* sysrq timeout */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		sysrq_ch;		<span class="comment">/* char for sysrq */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		has_sysrq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		sysrq_seq;		<span class="comment">/* index in sysrq_toggle_seq */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		hub6;			<span class="comment">/* this should be in the 8250 driver */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		suspended;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		console_reinit;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;			<span class="comment">/* port name */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>	*<span class="title">attr_group</span>;</span>		<span class="comment">/* port specific attributes */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">tty_groups</span>;</span>	<span class="comment">/* all attributes (serial core use only) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">serial_rs485</span>     <span class="title">rs485</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>	*<span class="title">rs485_term_gpio</span>;</span>	<span class="comment">/* enable RS485 bus termination */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">serial_iso7816</span>   <span class="title">iso7816</span>;</span></span><br><span class="line">	<span class="type">void</span>			*private_data;		<span class="comment">/* generic platform data pointer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="struct-uart-state"><a href="#struct-uart-state" class="headerlink" title="struct uart_state"></a>struct uart_state</h4><p><code>struct uart_state</code> 是一个结构体，定义在 <code>include/linux/serial_core.h</code>，其内部包含一个 <code>tty_port</code> 类型的成员变量，通常用于表示UART 驱动程序的状态信息。通过 <code>uart_driver</code> 结构体中的 state 成员指针，可以访问和操作与UART 设备状态有关的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the state information which is persistent across opens.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span>		<span class="title">port</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">uart_pm_state</span>	<span class="title">pm_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">circ_buf</span>		<span class="title">xmit</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_t</span>		refcount;</span><br><span class="line">	<span class="type">wait_queue_head_t</span>	remove_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span>	*<span class="title">uart_port</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="struct-uart-ops"><a href="#struct-uart-ops" class="headerlink" title="struct uart_ops"></a>struct uart_ops</h4><p>结构体 <code>uart_ops</code> 包含了一系列函数指针，这些函数指针定义了对 UART 端口进行操作的接口。每个函数指针对应一个特定的操作，例如发送数据、设置控制信号、启动或停止传输等。</p>
<p>通过 <code>uart_ops</code> 结构体，上层应用程序或驱动程序可以调用这些函数指针来操作 UART 端口，实现数据传输和控制操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This structure describes all the operations that can be done on the</span></span><br><span class="line"><span class="comment"> * physical hardware.  See Documentation/driver-api/serial/driver.rst for details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>	<span class="params">(*tx_empty)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;<span class="comment">// 检查发送缓冲区是否为空的函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*set_mctrl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> mctrl);<span class="comment">// 设置 modem 控制信号的函数指针</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>	<span class="params">(*get_mctrl)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;<span class="comment">// 获取 modem 控制信号的函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*stop_tx)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 停止发送函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*start_tx)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 启动发送函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*throttle)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 限流函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*unthrottle)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 解除限流函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*send_xchar)(<span class="keyword">struct</span> uart_port *, <span class="type">char</span> ch);<span class="comment">// 发送特殊字符函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*stop_rx)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 停止接收函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*enable_ms)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 启用 RTS/CTS(硬件流控)函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*break_ctl)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span> ctl);<span class="comment">// 控制发送 BREAK 信号函数指针</span></span><br><span class="line">	<span class="type">int</span>		(*startup)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 启动函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*shutdown)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 关闭函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*flush_buffer)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 刷新缓冲区函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*set_termios)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> ktermios *new,</span><br><span class="line">				       <span class="keyword">struct</span> ktermios *old);<span class="comment">// 设置终端信息函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*set_ldisc)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> ktermios *);<span class="comment">// 设置行规则函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*pm)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> state,</span><br><span class="line">			      <span class="type">unsigned</span> <span class="type">int</span> oldstate);<span class="comment">// 电源管理函数指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Return a string describing the type of the port</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*(*type)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 获取端口类型的函数指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Release IO and memory resources used by the port.</span></span><br><span class="line"><span class="comment">	 * This includes iounmap if necessary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span>		(*release_port)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 释放端口函数指针</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Request IO and memory resources used by the port.</span></span><br><span class="line"><span class="comment">	 * This includes iomapping the port if necessary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>		(*request_port)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 请求端口函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*config_port)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>);<span class="comment">// 配置端口函数指针</span></span><br><span class="line">	<span class="type">int</span>		(*verify_port)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> serial_struct *);<span class="comment">// 验证端口函数指针</span></span><br><span class="line">	<span class="type">int</span>		(*ioctl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">// 控制操作函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">	<span class="type">int</span>		(*poll_init)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 轮询初始化函数指针</span></span><br><span class="line">	<span class="type">void</span>		(*poll_put_char)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">char</span>);<span class="comment">// 轮询发送字符函数指针</span></span><br><span class="line">	<span class="type">int</span>		(*poll_get_char)(<span class="keyword">struct</span> uart_port *);<span class="comment">// 轮询获取字符函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="uart-driver-注册分析"><a href="#uart-driver-注册分析" class="headerlink" title="uart_driver 注册分析"></a>uart_driver 注册分析</h3><p><code>drivers/tty/serial/8250/8250_core.c</code> 文件中的函数主要是与 8250 系列 UART 驱动程序的核心功能相关的。这个文件实现了 8250 这种串行通信设备的核心操作，包括初始化、配置、中断处理、数据传输等功能。</p>
<h4 id="serial8250-init"><a href="#serial8250-init" class="headerlink" title="serial8250_init()"></a>serial8250_init()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">serial8250_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nr_uarts == <span class="number">0</span>)<span class="comment">// 检查是否有 UART 端口被定义，如果没有则返回-ENODEV 错误</span></span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 初始化 8250/16550 串口</span></span><br><span class="line">	serial8250_isa_init_ports();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 打印串口驱动信息，包括端口数量和 IRQ 共享状态</span></span><br><span class="line">	pr_info(<span class="string">&quot;Serial: 8250/16550 driver, %d ports, IRQ sharing %sabled\n&quot;</span>,</span><br><span class="line">		nr_uarts, share_irqs ? <span class="string">&quot;en&quot;</span> : <span class="string">&quot;dis&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARC</span></span><br><span class="line">    <span class="comment">// 如果是 SPARC 架构，注册串口设备的次设备号</span></span><br><span class="line">	ret = sunserial_register_minors(&amp;serial8250_reg, UART_NR);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 否则，在当前平台上注册 UART 驱动程序</span></span><br><span class="line">	serial8250_reg.nr = UART_NR;</span><br><span class="line">	ret = uart_register_driver(&amp;serial8250_reg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	ret = serial8250_pnp_init();<span class="comment">// 初始化 PNP 设备（如果存在）</span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> unreg_uart_drv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 ISA 平台设备结构体并注册</span></span><br><span class="line">	serial8250_isa_devs = platform_device_alloc(<span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">						    PLAT8250_DEV_LEGACY);</span><br><span class="line">	<span class="keyword">if</span> (!serial8250_isa_devs) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> unreg_pnp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将平台设备添加到系统</span></span><br><span class="line">	ret = platform_device_add(serial8250_isa_devs);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> put_dev;</span><br><span class="line">	<span class="comment">// 注册串口端口</span></span><br><span class="line">	serial8250_register_ports(&amp;serial8250_reg, &amp;serial8250_isa_devs-&gt;dev);</span><br><span class="line">	<span class="comment">// 注册平台驱动程序</span></span><br><span class="line">	ret = platform_driver_register(&amp;serial8250_isa_driver);</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">// 如果注册失败，删除已添加的 ISA 平台设备</span></span><br><span class="line">	platform_device_del(serial8250_isa_devs);</span><br><span class="line">put_dev:</span><br><span class="line">	platform_device_put(serial8250_isa_devs);</span><br><span class="line">unreg_pnp:</span><br><span class="line">	serial8250_pnp_exit();<span class="comment">// 退出时释放 PNP 设备</span></span><br><span class="line">unreg_uart_drv:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARC</span></span><br><span class="line">	sunserial_unregister_minors(&amp;serial8250_reg, UART_NR);<span class="comment">// 如果是 SPARC 架构，注销串口设备的次设备号</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	uart_unregister_driver(&amp;serial8250_reg);<span class="comment">// 否则，在当前平台上注销 UART 驱动程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">// 返回初始化结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="初始化8250串口"><a href="#初始化8250串口" class="headerlink" title="初始化8250串口"></a>初始化8250串口</h4><h5 id="serial8250-isa-init-ports"><a href="#serial8250-isa-init-ports" class="headerlink" title="serial8250_isa_init_ports()"></a>serial8250_isa_init_ports()</h5><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动，其中第 10 行的 <code>serial8250_isa_init_ports()</code>;函数初始化 8250 串口，函数如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">serial8250_isa_init_ports</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> *<span class="title">up</span>;</span><span class="comment">// UART 8250 端口结构体指针</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;<span class="comment">// 静态变量，用于标记是否首次初始化</span></span><br><span class="line">	<span class="type">int</span> i, irqflag = <span class="number">0</span>;<span class="comment">// 循环变量和 IRQ 标志位初始化为 0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!first)<span class="comment">// 如果不是首次初始化，则直接返回，避免重复初始化</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	first = <span class="number">0</span>;<span class="comment">// 标记为不是首次初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果系统定义的 UART 端口数量大于硬件支持的最大数量，将其限制为最大支持数量</span></span><br><span class="line">	<span class="keyword">if</span> (nr_uarts &gt; UART_NR)</span><br><span class="line">		nr_uarts = UART_NR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有定义的 UART 端口数量，初始化每个端口</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> *<span class="title">up</span> =</span> &amp;serial8250_ports[i];<span class="comment">// 获取第 i 个 UART 端口结构体指针</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;up-&gt;port;<span class="comment">// 获取端口的通用 UART 端口结构体</span></span><br><span class="line"></span><br><span class="line">		port-&gt;line = i;<span class="comment">// 设置 UART 端口的逻辑线号</span></span><br><span class="line">		serial8250_init_port(up);<span class="comment">// 初始化 UART 端口</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 base_ops 尚未设置，则使用当前端口的操作函数作为基本操作函数</span></span><br><span class="line">		<span class="keyword">if</span> (!base_ops)</span><br><span class="line">			base_ops = port-&gt;ops;</span><br><span class="line">		port-&gt;ops = &amp;univ8250_port_ops;<span class="comment">// 设置 UART 端口的操作函数为 univ8250_port_ops</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 初始化定时器</span></span><br><span class="line">		timer_setup(&amp;up-&gt;timer, serial8250_timeout, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 UART 端口的驱动操作函数为 univ8250_driver_ops</span></span><br><span class="line">		up-&gt;ops = &amp;univ8250_driver_ops;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * ALPHA_KLUDGE_MCR needs to be killed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		up-&gt;mcr_mask = ~ALPHA_KLUDGE_MCR;<span class="comment">// 设置 UART 端口的 MCR 屏蔽位，屏蔽ALPHA_KLUDGE_MCR</span></span><br><span class="line">		up-&gt;mcr_force = ALPHA_KLUDGE_MCR;<span class="comment">// 设置 UART 端口的 MCR 强制位，设置为ALPHA_KLUDGE_MCR</span></span><br><span class="line">		serial8250_set_defaults(up);<span class="comment">// 设置 UART 端口的默认参数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chain base port ops to support Remote Supervisor Adapter */</span></span><br><span class="line">	univ8250_port_ops = *base_ops;<span class="comment">// 将基本端口操作链到支持远程监控适配器（RSA）</span></span><br><span class="line">	univ8250_rsa_support(&amp;univ8250_port_ops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了共享 IRQ 标志，设置 IRQ 标志位</span></span><br><span class="line">	<span class="keyword">if</span> (share_irqs)</span><br><span class="line">		irqflag = IRQF_SHARED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历旧的串口端口数组，初始化对应的 UART 端口</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, up = serial8250_ports;</span><br><span class="line">	     i &lt; ARRAY_SIZE(old_serial_port) &amp;&amp; i &lt; nr_uarts;</span><br><span class="line">	     i++, up++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;up-&gt;port;</span><br><span class="line">		<span class="comment">// 设置 UART 端口的 IO 基地址、IRQ、IRQ 标志、时钟频率、标志、hub6 等参数</span></span><br><span class="line">		port-&gt;iobase   = old_serial_port[i].port;</span><br><span class="line">		port-&gt;irq      = irq_canonicalize(old_serial_port[i].irq);<span class="comment">// 规范化 IRQ</span></span><br><span class="line">		port-&gt;irqflags = <span class="number">0</span>;</span><br><span class="line">		port-&gt;uartclk  = old_serial_port[i].baud_base * <span class="number">16</span>;<span class="comment">// 设置 UART 时钟频率</span></span><br><span class="line">		port-&gt;flags    = old_serial_port[i].flags;<span class="comment">// 设置 UART 端口标志</span></span><br><span class="line">		port-&gt;hub6     = <span class="number">0</span>;</span><br><span class="line">		port-&gt;membase  = old_serial_port[i].iomem_base;</span><br><span class="line">		port-&gt;iotype   = old_serial_port[i].io_type;</span><br><span class="line">		port-&gt;regshift = old_serial_port[i].iomem_reg_shift;</span><br><span class="line"></span><br><span class="line">		port-&gt;irqflags |= irqflag;<span class="comment">// 设置 IRQ 标志位</span></span><br><span class="line">        <span class="comment">// 如果定义了 ISA 配置函数，调用配置函数进行额外的配置</span></span><br><span class="line">		<span class="keyword">if</span> (serial8250_isa_config != <span class="literal">NULL</span>)</span><br><span class="line">			serial8250_isa_config(i, &amp;up-&gt;port, &amp;up-&gt;capabilities);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="serial8250-init-port"><a href="#serial8250-init-port" class="headerlink" title="serial8250_init_port()"></a>serial8250_init_port()</h5><p>在上面的第 21 行代码执行了 <code>serial8250_init_port</code> 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 初始化 UART 8250 端口的函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serial8250_init_port</span><span class="params">(<span class="keyword">struct</span> uart_8250_port *up)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">port</span> =</span> &amp;up-&gt;port;<span class="comment">// 获取 UART 8250 端口结构体</span></span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;port-&gt;lock);<span class="comment">// 初始化端口锁</span></span><br><span class="line">	port-&gt;pm = <span class="literal">NULL</span>;</span><br><span class="line">	port-&gt;ops = &amp;serial8250_pops;<span class="comment">// 设置端口操作函数为 serial8250_pops</span></span><br><span class="line">	port-&gt;has_sysrq = IS_ENABLED(CONFIG_SERIAL_8250_CONSOLE);</span><br><span class="line"></span><br><span class="line">	up-&gt;cur_iotype = <span class="number">0xFF</span>;<span class="comment">// 设置当前端口的 IO 类型为 0xFF</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(serial8250_init_port);</span><br></pre></td></tr></table></figure>



<p><code>serial8250_pop</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> <span class="title">serial8250_pops</span> =</span> &#123;</span><br><span class="line">	.tx_empty	= serial8250_tx_empty,<span class="comment">// 传输缓冲区是否为空</span></span><br><span class="line">	.set_mctrl	= serial8250_set_mctrl, <span class="comment">// 设置控制信号</span></span><br><span class="line">	.get_mctrl	= serial8250_get_mctrl, <span class="comment">// 获取控制信号</span></span><br><span class="line">	.stop_tx	= serial8250_stop_tx,<span class="comment">// 停止发送</span></span><br><span class="line">	.start_tx	= serial8250_start_tx,<span class="comment">// 启动发送</span></span><br><span class="line">	.throttle	= serial8250_throttle,<span class="comment">// 限流</span></span><br><span class="line">	.unthrottle	= serial8250_unthrottle,<span class="comment">// 解除限流</span></span><br><span class="line">	.stop_rx	= serial8250_stop_rx,<span class="comment">// 停止接收</span></span><br><span class="line">	.enable_ms	= serial8250_enable_ms, <span class="comment">// 启用 RTS/CTS</span></span><br><span class="line">	.break_ctl	= serial8250_break_ctl,<span class="comment">// 控制发送 BREAK 信号</span></span><br><span class="line">	.startup	= serial8250_startup,<span class="comment">// 启动</span></span><br><span class="line">	.shutdown	= serial8250_shutdown, <span class="comment">// 关闭</span></span><br><span class="line">	.flush_buffer	= serial8250_flush_buffer,</span><br><span class="line">	.set_termios	= serial8250_set_termios,</span><br><span class="line">	.set_ldisc	= serial8250_set_ldisc,<span class="comment">// 设置终端参数</span></span><br><span class="line">	.pm		= serial8250_pm, <span class="comment">// 电源管理</span></span><br><span class="line">	.type		= serial8250_type, <span class="comment">// 返回端口类型的字符串</span></span><br><span class="line">	.release_port	= serial8250_release_port,<span class="comment">// 释放端口资源</span></span><br><span class="line">	.request_port	= serial8250_request_port,<span class="comment">// 请求端口资源</span></span><br><span class="line">	.config_port	= serial8250_config_port,<span class="comment">// 配置端口</span></span><br><span class="line">	.verify_port	= serial8250_verify_port,<span class="comment">// 验证端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">	.poll_get_char = serial8250_get_poll_char,<span class="comment">// 获取字符（用于轮询）</span></span><br><span class="line">	.poll_put_char = serial8250_put_poll_char,<span class="comment">// 发送字符（用于轮询</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="注册-UART-驱动程序"><a href="#注册-UART-驱动程序" class="headerlink" title="注册 UART 驱动程序"></a>注册 UART 驱动程序</h4><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动，其中的 <code>uart_register_driver(&amp;serial8250_reg)</code>，通过 <code>uart_register_driver</code> 函数向系统注册这个 uart_driver，函数原型如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *uart)</span></span><br></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下所示：</p>
<ul>
<li><strong>uart</strong>：要注册的 uart_driver。</li>
<li><strong>返回值</strong>：0，成功；负值，失败。</li>
</ul>
<p>注销驱动的时候也需要注销掉前面注册的 <code>uart_driver</code>，需要用到 <code>uart_unregister_driver</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">uart_unregister_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *uart)</span></span><br></pre></td></tr></table></figure>

<p>函数参数和返回值含义如下所示：</p>
<ul>
<li><strong>uart</strong>：要注销的 uart_driver。</li>
<li><strong>返回值</strong>：无</li>
</ul>
<p><code>serial8250_init(void)</code>函数中 <code>uart_register_driver</code> 函数传入的参数是 <code>serial8250_reg</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> <span class="title">serial8250_reg</span> =</span> &#123;</span><br><span class="line">	.owner			= THIS_MODULE,<span class="comment">// 模块的所有者</span></span><br><span class="line">	.driver_name		= <span class="string">&quot;serial&quot;</span>,<span class="comment">// 驱动程序名称</span></span><br><span class="line">	.dev_name		= <span class="string">&quot;ttyS&quot;</span>,<span class="comment">// 设备名称</span></span><br><span class="line">	.major			= TTY_MAJOR,<span class="comment">// 主设备号</span></span><br><span class="line">	.minor			= <span class="number">64</span>,<span class="comment">// 次设备号</span></span><br><span class="line">	.cons			= SERIAL8250_CONSOLE,<span class="comment">// 控制台</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="uart-register-driver"><a href="#uart-register-driver" class="headerlink" title="uart_register_driver()"></a>uart_register_driver()</h5><p><code>uart_register_driver</code> 函数内容如下所示，定义在在源码 <code>drivers/tty/serial/serial_core.c</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	uart_register_driver - register a driver with the uart core layer</span></span><br><span class="line"><span class="comment"> *	@drv: low level driver structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Register a uart driver with the core driver.  We in turn register</span></span><br><span class="line"><span class="comment"> *	with the tty layer, and initialise the core driver per-port state.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	We have a proc file in /proc/tty/driver which is named after the</span></span><br><span class="line"><span class="comment"> *	normal driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	drv-&gt;port should be NULL, and the per-port structures should be</span></span><br><span class="line"><span class="comment"> *	registered using uart_add_one_port after this call has succeeded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">normal</span>;</span></span><br><span class="line">	<span class="type">int</span> i, retval = -ENOMEM;</span><br><span class="line"></span><br><span class="line">	BUG_ON(drv-&gt;state);<span class="comment">// 检查驱动状态是否已被占用</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Maybe we should be using a slab cache for this, especially if</span></span><br><span class="line"><span class="comment">	 * we have a large number of ports to handle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	drv-&gt;state = kcalloc(drv-&gt;nr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> uart_state), GFP_KERNEL);<span class="comment">// 为 UART 状态分配内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (!drv-&gt;state)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 tty 驱动器</span></span><br><span class="line">	normal = alloc_tty_driver(drv-&gt;nr);</span><br><span class="line">	<span class="keyword">if</span> (!normal)</span><br><span class="line">		<span class="keyword">goto</span> out_kfree;</span><br><span class="line"></span><br><span class="line">	drv-&gt;tty_driver = normal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 tty 驱动器的属性</span></span><br><span class="line">	normal-&gt;driver_name	= drv-&gt;driver_name;</span><br><span class="line">	normal-&gt;name		= drv-&gt;dev_name;</span><br><span class="line">	normal-&gt;major		= drv-&gt;major;</span><br><span class="line">	normal-&gt;minor_start	= drv-&gt;minor;</span><br><span class="line">	normal-&gt;type		= TTY_DRIVER_TYPE_SERIAL;</span><br><span class="line">	normal-&gt;subtype		= SERIAL_TYPE_NORMAL;</span><br><span class="line">	normal-&gt;init_termios	= tty_std_termios;</span><br><span class="line">	normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">	normal-&gt;init_termios.c_ispeed = normal-&gt;init_termios.c_ospeed = <span class="number">9600</span>;</span><br><span class="line">	normal-&gt;flags		= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;</span><br><span class="line">	normal-&gt;driver_state    = drv;</span><br><span class="line">	tty_set_operations(normal, &amp;uart_ops);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialise the UART state(s).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; drv-&gt;nr; i++) &#123;<span class="comment">// 遍历每个 UART 状态并初始化对应的 tty 端口</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> drv-&gt;state + i;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span> =</span> &amp;state-&gt;port;</span><br><span class="line"></span><br><span class="line">		tty_port_init(port);</span><br><span class="line">		port-&gt;ops = &amp;uart_port_ops;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = tty_register_driver(normal);<span class="comment">// 注册 tty 驱动器</span></span><br><span class="line">	<span class="keyword">if</span> (retval &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册失败时，销毁已初始化的 tty 端口并释放内存</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; drv-&gt;nr; i++)</span><br><span class="line">		tty_port_destroy(&amp;drv-&gt;state[i].port);</span><br><span class="line">	put_tty_driver(normal);</span><br><span class="line">out_kfree:</span><br><span class="line">	kfree(drv-&gt;state);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uart_register_driver</code> 函数中的第 48 行代码设置 tty 驱动器的操作函数，这些操作函数定义了与特定设备相关的操作，如读写、控制等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> <span class="title">uart_ops</span> =</span> &#123;</span><br><span class="line">	.install	= uart_install,<span class="comment">// 安装 tty 设备</span></span><br><span class="line">	.open		= uart_open,<span class="comment">// 打开 tty 设备</span></span><br><span class="line">	.close		= uart_close,<span class="comment">// 关闭 tty 设备</span></span><br><span class="line">	.write		= uart_write,<span class="comment">// 写入数据到 tty 设备</span></span><br><span class="line">	.put_char	= uart_put_char,<span class="comment">// 将字符写入 tty 设备输出缓冲区</span></span><br><span class="line">	.flush_chars	= uart_flush_chars,<span class="comment">// 刷新 tty 设备输出缓冲区</span></span><br><span class="line">	.write_room	= uart_write_room,<span class="comment">// 获取 tty 设备输出缓冲区剩余空间大小</span></span><br><span class="line">	.chars_in_buffer= uart_chars_in_buffer, <span class="comment">// 获取 tty 设备输入缓冲区中的字符数量</span></span><br><span class="line">	.flush_buffer	= uart_flush_buffer,<span class="comment">// 刷新 tty 设备输入缓冲区</span></span><br><span class="line">	.ioctl		= uart_ioctl,<span class="comment">// 控制 tty 设备的操作</span></span><br><span class="line">	.throttle	= uart_throttle,<span class="comment">// 控制 tty 设备的流控状态</span></span><br><span class="line">	.unthrottle	= uart_unthrottle,<span class="comment">// 控制 tty 设备的流控状态</span></span><br><span class="line">	.send_xchar	= uart_send_xchar,<span class="comment">// 发送特殊字符到 tty 设备</span></span><br><span class="line">	.set_termios	= uart_set_termios,<span class="comment">// 设置 tty 设备的终端参数</span></span><br><span class="line">	.set_ldisc	= uart_set_ldisc,<span class="comment">// 设置 tty 设备的行规则</span></span><br><span class="line">	.stop		= uart_stop,<span class="comment">// 停止 tty 设备</span></span><br><span class="line">	.start		= uart_start,<span class="comment">// 启动 tty 设备</span></span><br><span class="line">	.hangup		= uart_hangup,<span class="comment">// 关闭 tty 设备的连接	</span></span><br><span class="line">	.break_ctl	= uart_break_ctl,<span class="comment">// 控制 tty 设备的发送中断</span></span><br><span class="line">	.wait_until_sent= uart_wait_until_sent,<span class="comment">// 等待 tty 设备发送完所有数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line">	.proc_show	= uart_proc_show,<span class="comment">// 显示与 uart 相关的 proc 文件系统信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.tiocmget	= uart_tiocmget,<span class="comment">// 获取 tty 设备的 modem 状态</span></span><br><span class="line">	.tiocmset	= uart_tiocmset,<span class="comment">// 设置 tty 设备的 modem 状态</span></span><br><span class="line">	.set_serial	= uart_set_info_user,</span><br><span class="line">	.get_serial	= uart_get_info_user,</span><br><span class="line">	.get_icount	= uart_get_icount,<span class="comment">// 获取 tty 设备的计数信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">	.poll_init	= uart_poll_init,<span class="comment">// 初始化 tty 设备的轮询模式</span></span><br><span class="line">	.poll_get_char	= uart_poll_get_char,<span class="comment">// 从 tty 设备获取字符（轮询模式）</span></span><br><span class="line">	.poll_put_char	= uart_poll_put_char,<span class="comment">// 将字符写入 tty 设备（轮询模式）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uart_register_driver</code> 函 数 中 的 第 61 行 代 码调用 <code>tty_register_driver</code> 函 数 如 下 所 示 ， 定 义 在<code>drivers/tty/tty_io.c</code></p>
<h5 id="tty-register-dirver"><a href="#tty-register-dirver" class="headerlink" title="tty_register_dirver()"></a>tty_register_dirver()</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called by a tty driver to register itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当 tty 驱动程序调用此函数以注册自身时被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tty_register_driver</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">dev_t</span> dev;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">d</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;major) &#123;<span class="comment">// 如果驱动程序没有指定主设备号，则分配一个</span></span><br><span class="line">		error = alloc_chrdev_region(&amp;dev, driver-&gt;minor_start,</span><br><span class="line">						driver-&gt;num, driver-&gt;name);</span><br><span class="line">		<span class="keyword">if</span> (!error) &#123;</span><br><span class="line">			driver-&gt;major = MAJOR(dev);</span><br><span class="line">			driver-&gt;minor_start = MINOR(dev);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev = MKDEV(driver-&gt;major, driver-&gt;minor_start);</span><br><span class="line">		error = register_chrdev_region(dev, driver-&gt;num, driver-&gt;name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	<span class="comment">// 如果驱动标志为 TTY_DRIVER_DYNAMIC_ALLOC，则动态添加 tty 字符设备</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_ALLOC) &#123;</span><br><span class="line">		error = tty_cdev_add(driver, dev, <span class="number">0</span>, driver-&gt;num);</span><br><span class="line">		<span class="keyword">if</span> (error)</span><br><span class="line">			<span class="keyword">goto</span> err_unreg_char;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;tty_mutex);</span><br><span class="line">    <span class="comment">// 将驱动程序添加到 tty 驱动程序列表中</span></span><br><span class="line">	list_add(&amp;driver-&gt;tty_drivers, &amp;tty_drivers);</span><br><span class="line">	mutex_unlock(&amp;tty_mutex);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果驱动标志没有设置为 TTY_DRIVER_DYNAMIC_DEV，则注册 tty 设备</span></span><br><span class="line">	<span class="keyword">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_DEV)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; driver-&gt;num; i++) &#123;</span><br><span class="line">			d = tty_register_device(driver, i, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(d)) &#123;</span><br><span class="line">				error = PTR_ERR(d);</span><br><span class="line">				<span class="keyword">goto</span> err_unreg_devs;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 注册 TTY 驱动程序到 proc 文件系统</span></span><br><span class="line">	proc_tty_register_driver(driver);</span><br><span class="line">	driver-&gt;flags |= TTY_DRIVER_INSTALLED;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_unreg_devs:</span><br><span class="line">    <span class="comment">// 注销已注册的 tty 设备</span></span><br><span class="line">	<span class="keyword">for</span> (i--; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		tty_unregister_device(driver, i);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;tty_mutex);</span><br><span class="line">    <span class="comment">// 从 tty 驱动程序列表中移除驱动程序</span></span><br><span class="line">	list_del(&amp;driver-&gt;tty_drivers);</span><br><span class="line">	mutex_unlock(&amp;tty_mutex);</span><br><span class="line"></span><br><span class="line">err_unreg_char:</span><br><span class="line">	unregister_chrdev_region(dev, driver-&gt;num);<span class="comment">// 注销已注册的字符设备</span></span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(tty_register_driver);</span><br></pre></td></tr></table></figure>

<h4 id="分配平台设备结构体并注册"><a href="#分配平台设备结构体并注册" class="headerlink" title="分配平台设备结构体并注册"></a>分配平台设备结构体并注册</h4><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 分配 ISA 平台设备结构体并注册</span></span><br><span class="line">serial8250_isa_devs = platform_device_alloc(<span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">					    PLAT8250_DEV_LEGACY);</span><br><span class="line"><span class="keyword">if</span> (!serial8250_isa_devs) &#123;</span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	<span class="keyword">goto</span> unreg_pnp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将平台设备添加到系统</span></span><br><span class="line">ret = platform_device_add(serial8250_isa_devs);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	<span class="keyword">goto</span> put_dev;</span><br></pre></td></tr></table></figure>

<p><code>platform_device_alloc</code> 函数用于<strong>分配一个平台设备结构体，但不会将其注册到平台总线上</strong>。返回的结构体可以在之后使用函数 <code>platform_device_add()</code>来将其注册到平台总线上。</p>
<h4 id="注册串口端口"><a href="#注册串口端口" class="headerlink" title="注册串口端口"></a>注册串口端口</h4><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动，其中第 42 行代码，如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册串口端口</span></span><br><span class="line">serial8250_register_ports(&amp;serial8250_reg, &amp;serial8250_isa_devs-&gt;dev);</span><br></pre></td></tr></table></figure>

<h5 id="serial8250-register-ports"><a href="#serial8250-register-ports" class="headerlink" title="serial8250_register_ports()"></a>serial8250_register_ports()</h5><p><code>serial8250_register_ports</code> 函数内容如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init</span><br><span class="line"><span class="title function_">serial8250_register_ports</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv, <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++) &#123;<span class="comment">// 遍历所有串口</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> *<span class="title">up</span> =</span> &amp;serial8250_ports[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (up-&gt;port.type == PORT_8250_CIR)<span class="comment">// 如果是 CIR 端口，则跳过</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (up-&gt;port.dev)<span class="comment">// 如果端口已经分配了设备，则跳过</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		up-&gt;port.dev = dev;<span class="comment">// 将设备指针与端口关联起来</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (uart_console_enabled(&amp;up-&gt;port))</span><br><span class="line">			pm_runtime_get_sync(up-&gt;port.dev);</span><br><span class="line"></span><br><span class="line">		serial8250_apply_quirks(up);<span class="comment">// 应用串口 8250 的特殊处理</span></span><br><span class="line">		uart_add_one_port(drv, &amp;up-&gt;port);<span class="comment">// 向 UART 驱动注册一个串口</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册-platform-driver-驱动"><a href="#注册-platform-driver-驱动" class="headerlink" title="注册 platform_driver 驱动"></a>注册 platform_driver 驱动</h4><p><code>serial8250_init(void)</code>函数主要负责在系统启动时初始化和注册 8250&#x2F;16550 串口设备驱动，其中第 44 行代码，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册平台驱动程序</span></span><br><span class="line">ret = platform_driver_register(&amp;serial8250_isa_driver);</span><br></pre></td></tr></table></figure>

<h2 id="端口注册流程分析"><a href="#端口注册流程分析" class="headerlink" title="端口注册流程分析"></a>端口注册流程分析</h2><p>迅为提供的 SDK 源码设备树中默认打开了串口 9，打开<code>arch/arm64/boot/dts/rockchip/rk3568.dtsi</code> 设备树文件，串口 9 控制器的设备树节点如下所示：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">uart9:</span> <span class="title class_">serial@fe6d0000</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;rockchip,rk3568-uart&quot;</span>, <span class="string">&quot;snps,dw-apb-uart&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0xfe6d0000</span> <span class="number">0x0</span> <span class="number">0x100</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">interrupts</span> <span class="operator">=</span> <span class="params">&lt;GIC_SPI <span class="number">125</span> IRQ_TYPE_LEVEL_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">clocks</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;cru</span> SCLK_UART9&gt;</span>, <span class="params">&lt;<span class="variable">&amp;cru</span> PCLK_UART9&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">clock-names</span> <span class="operator">=</span> <span class="string">&quot;baudclk&quot;</span>, <span class="string">&quot;apb_pclk&quot;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">reg-shift</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">2</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">reg-io-width</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">4</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">dmas</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">18</span>&gt;</span>, <span class="params">&lt;<span class="variable">&amp;dmac0</span> <span class="number">19</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">	pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;uart9m0_xfer</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line">	<span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;disabled&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>第 2 行 compatible 属性值为<code>snps,dw-apb-uart</code>。在 Linux 源码中搜索这个值即可找到对应的 UART 驱动文件，此文件为 <code>drivers/tty/serial/8250/8250_dw.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">dw8250_platform_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name		= <span class="string">&quot;dw-apb-uart&quot;</span>,</span><br><span class="line">		.pm		= &amp;dw8250_pm_ops,</span><br><span class="line">		.of_match_table	= dw8250_of_match,</span><br><span class="line">		.acpi_match_table = dw8250_acpi_match,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe			= dw8250_probe,</span><br><span class="line">	.remove			= dw8250_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(dw8250_platform_driver);</span><br></pre></td></tr></table></figure>

<p>可以看出瑞芯微的 UART 本质上是一个 platform 驱动，当节点匹配成功之后，执行<code>dw_probe</code> 函数，函数内容如下所示：</p>
<h3 id="dw-probe"><a href="#dw-probe" class="headerlink" title="dw_probe()"></a>dw_probe()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dw8250_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> <span class="title">uart</span> =</span> &#123;&#125;, *up = &amp;uart;<span class="comment">// 初始化一个 uart_8250_port 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">regs</span> =</span> platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);<span class="comment">// 获取设备资源信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">p</span> =</span> &amp;up-&gt;port;<span class="comment">// 获取 uart_port 指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> &amp;pdev-&gt;dev;<span class="comment">// 获取设备指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dw8250_data</span> *<span class="title">data</span>;</span> <span class="comment">// 定义 dw8250_data 结构体指针</span></span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	u32 val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否获取到了设备资源信息</span></span><br><span class="line">	<span class="keyword">if</span> (!regs) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;no registers defined\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)<span class="comment">// 检查是否获取到了中断号</span></span><br><span class="line">		<span class="keyword">return</span> irq;</span><br><span class="line"></span><br><span class="line">	spin_lock_init(&amp;p-&gt;lock); <span class="comment">// 初始化锁</span></span><br><span class="line">	p-&gt;mapbase	= regs-&gt;start;<span class="comment">// 设置设备的物理地址</span></span><br><span class="line">	p-&gt;irq		= irq;<span class="comment">// 设置设备的中断号</span></span><br><span class="line">	p-&gt;handle_irq	= dw8250_handle_irq;<span class="comment">// 设置中断处理函数</span></span><br><span class="line">	p-&gt;pm		= dw8250_do_pm; <span class="comment">// 设置设备的电源管理函数</span></span><br><span class="line">	p-&gt;type		= PORT_8250; <span class="comment">// 设置设备类型</span></span><br><span class="line">	p-&gt;flags	= UPF_SHARE_IRQ | UPF_FIXED_PORT;<span class="comment">// 设置设备标志</span></span><br><span class="line">	p-&gt;dev		= dev;<span class="comment">// 设置设备指针</span></span><br><span class="line">	p-&gt;iotype	= UPIO_MEM; <span class="comment">// 设置 IO 类型</span></span><br><span class="line">	p-&gt;serial_in	= dw8250_serial_in;<span class="comment">// 设置读函数</span></span><br><span class="line">	p-&gt;serial_out	= dw8250_serial_out;<span class="comment">// 设置写函数</span></span><br><span class="line">	p-&gt;set_ldisc	= dw8250_set_ldisc; <span class="comment">// 设置行规则函数</span></span><br><span class="line">	p-&gt;set_termios	= dw8250_set_termios;<span class="comment">// 设置终端参数函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将设备的物理地址映射到内存空间</span></span><br><span class="line">	p-&gt;membase = devm_ioremap(dev, regs-&gt;start, resource_size(regs));</span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;membase)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配 dw8250_data 结构体内存空间</span></span><br><span class="line">	data = devm_kzalloc(dev, <span class="keyword">sizeof</span>(*data), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!data)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	data-&gt;data.dma.fn = dw8250_fallback_dma_filter;<span class="comment">// 设置 DMA 函数指针</span></span><br><span class="line">	data-&gt;usr_reg = DW_UART_USR;<span class="comment">// 设置 UART 状态寄存器地址</span></span><br><span class="line">	p-&gt;private_data = &amp;data-&gt;data;<span class="comment">// 设置设备的私有数据指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取设备属性&quot;snps,uart-16550-compatible&quot;，判断是否兼容 16550</span></span><br><span class="line">	data-&gt;uart_16550_compatible = device_property_read_bool(dev,</span><br><span class="line">						<span class="string">&quot;snps,uart-16550-compatible&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取设备属性&quot;reg-shift&quot;，获取地址偏移值</span></span><br><span class="line">	err = device_property_read_u32(dev, <span class="string">&quot;reg-shift&quot;</span>, &amp;val);</span><br><span class="line">	<span class="keyword">if</span> (!err)</span><br><span class="line">		p-&gt;regshift = val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取设备属性&quot;reg-io-width&quot;，获取 IO 宽度</span></span><br><span class="line">	err = device_property_read_u32(dev, <span class="string">&quot;reg-io-width&quot;</span>, &amp;val);</span><br><span class="line">	<span class="keyword">if</span> (!err &amp;&amp; val == <span class="number">4</span>) &#123;</span><br><span class="line">		p-&gt;iotype = UPIO_MEM32;<span class="comment">// 设置 IO 类型为 32 位</span></span><br><span class="line">		p-&gt;serial_in = dw8250_serial_in32;<span class="comment">// 设置读函数为 32 位</span></span><br><span class="line">		p-&gt;serial_out = dw8250_serial_out32;<span class="comment">// 设置写函数为 32 位</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性&quot;dcd-override&quot;存在，则始终将 DCD 状态设置为活动状态</span></span><br><span class="line">	<span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;dcd-override&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">/* Always report DCD as active */</span></span><br><span class="line">		data-&gt;msr_mask_on |= UART_MSR_DCD;</span><br><span class="line">		data-&gt;msr_mask_off |= UART_MSR_DDCD;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性&quot;dsr-override&quot;存在，则始终将 DSR 状态设置为活动状态</span></span><br><span class="line">	<span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;dsr-override&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">/* Always report DSR as active */</span></span><br><span class="line">		data-&gt;msr_mask_on |= UART_MSR_DSR;</span><br><span class="line">		data-&gt;msr_mask_off |= UART_MSR_DDSR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性&quot;cts-override&quot;存在，则始终将 CTS 状态设置为活动状态</span></span><br><span class="line">	<span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;cts-override&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">/* Always report CTS as active */</span></span><br><span class="line">		data-&gt;msr_mask_on |= UART_MSR_CTS;</span><br><span class="line">		data-&gt;msr_mask_off |= UART_MSR_DCTS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果属性&quot;ri-override&quot;存在，则始终将 RI 状态设置为非活动状态</span></span><br><span class="line">	<span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;ri-override&quot;</span>)) &#123;</span><br><span class="line">		<span class="comment">/* Always report Ring indicator as inactive */</span></span><br><span class="line">		data-&gt;msr_mask_off |= UART_MSR_RI;</span><br><span class="line">		data-&gt;msr_mask_off |= UART_MSR_TERI;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Always ask for fixed clock rate from a property. */</span></span><br><span class="line">    <span class="comment">// 读取属性&quot;clock-frequency&quot;，获取时钟频率</span></span><br><span class="line">	device_property_read_u32(dev, <span class="string">&quot;clock-frequency&quot;</span>, &amp;p-&gt;uartclk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If there is separate baudclk, get the rate from it. */</span></span><br><span class="line">	data-&gt;clk = devm_clk_get_optional(dev, <span class="string">&quot;baudclk&quot;</span>);<span class="comment">// 如果存在&quot;baudclk&quot;时钟，则从中获取时钟频率</span></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;clk == <span class="literal">NULL</span>)<span class="comment">// 如果没有定义时钟频率，则失败</span></span><br><span class="line">		data-&gt;clk = devm_clk_get_optional(dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(data-&gt;clk))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(data-&gt;clk);</span><br><span class="line"></span><br><span class="line">	INIT_WORK(&amp;data-&gt;clk_work, dw8250_clk_work_cb);</span><br><span class="line">	data-&gt;clk_notifier.notifier_call = dw8250_clk_notifier_cb;</span><br><span class="line"></span><br><span class="line">	err = clk_prepare_enable(data-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		dev_warn(dev, <span class="string">&quot;could not enable optional baudclk: %d\n&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;clk)</span><br><span class="line">		p-&gt;uartclk = clk_get_rate(data-&gt;clk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If no clock rate is defined, fail. */</span></span><br><span class="line">	<span class="keyword">if</span> (!p-&gt;uartclk) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;clock rate not defined\n&quot;</span>);</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> err_clk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data-&gt;pclk = devm_clk_get_optional(dev, <span class="string">&quot;apb_pclk&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(data-&gt;pclk)) &#123;</span><br><span class="line">		err = PTR_ERR(data-&gt;pclk);</span><br><span class="line">		<span class="keyword">goto</span> err_clk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = clk_prepare_enable(data-&gt;pclk);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;could not enable apb_pclk\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err_clk;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	data-&gt;rst = devm_reset_control_get_optional_exclusive(dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(data-&gt;rst)) &#123;</span><br><span class="line">		err = PTR_ERR(data-&gt;rst);</span><br><span class="line">		<span class="keyword">goto</span> err_pclk;</span><br><span class="line">	&#125;</span><br><span class="line">	reset_control_deassert(data-&gt;rst);</span><br><span class="line">	<span class="comment">// 应用特定的 quirks</span></span><br><span class="line">	dw8250_quirks(p, data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If the Busy Functionality is not implemented, don&#x27;t handle it */</span></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;uart_16550_compatible)<span class="comment">// 如果设备不兼容 16550，则不处理忙标志</span></span><br><span class="line">		p-&gt;handle_irq = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!data-&gt;skip_autocfg)<span class="comment">// 如果不跳过自动配置，则进行端口配置</span></span><br><span class="line">		dw8250_setup_port(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we have a valid fifosize, try hooking up DMA */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;fifosize) &#123;<span class="comment">// 如果有有效的 FIFO 大小，则尝试连接 DMA</span></span><br><span class="line">		data-&gt;data.dma.rxconf.src_maxburst = p-&gt;fifosize / <span class="number">4</span>;</span><br><span class="line">		data-&gt;data.dma.txconf.dst_maxburst = p-&gt;fifosize / <span class="number">4</span>;</span><br><span class="line">		up-&gt;dma = &amp;data-&gt;data.dma;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 8250 端口</span></span><br><span class="line">	data-&gt;data.line = serial8250_register_8250_port(up);</span><br><span class="line">	<span class="keyword">if</span> (data-&gt;data.line &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err = data-&gt;data.line;</span><br><span class="line">		<span class="keyword">goto</span> err_reset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Some platforms may provide a reference clock shared between several</span></span><br><span class="line"><span class="comment">	 * devices. In this case any clock state change must be known to the</span></span><br><span class="line"><span class="comment">	 * UART port at least post factum.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;clk) &#123;</span><br><span class="line">		err = clk_notifier_register(data-&gt;clk, &amp;data-&gt;clk_notifier);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			dev_warn(p-&gt;dev, <span class="string">&quot;Failed to set the clock notifier\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			queue_work(system_unbound_wq, &amp;data-&gt;clk_work);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置平台设备的私有数据</span></span><br><span class="line">	platform_set_drvdata(pdev, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置电源管理为激活状态</span></span><br><span class="line">	pm_runtime_set_active(dev);</span><br><span class="line">	pm_runtime_enable(dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_reset:</span><br><span class="line">	reset_control_assert(data-&gt;rst);</span><br><span class="line"></span><br><span class="line">err_pclk:</span><br><span class="line">	clk_disable_unprepare(data-&gt;pclk);</span><br><span class="line"></span><br><span class="line">err_clk:</span><br><span class="line">	clk_disable_unprepare(data-&gt;clk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 159行代码使用 <code>serial8250_register_8250_port</code> 函数注册了 8250 端口，<code>serial8250_register_8250_port</code> 函数内容如下所示：</p>
<h3 id="serial8250-register-8250-port"><a href="#serial8250-register-8250-port" class="headerlink" title="serial8250_register_8250_port()"></a>serial8250_register_8250_port()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	serial8250_register_8250_port - register a serial port</span></span><br><span class="line"><span class="comment"> *	@up: serial port template</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Configure the serial port specified by the request. If the</span></span><br><span class="line"><span class="comment"> *	port exists and is in use, it is hung up and unregistered</span></span><br><span class="line"><span class="comment"> *	first.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	The port is then probed and if necessary the IRQ is autodetected</span></span><br><span class="line"><span class="comment"> *	If this fails an error is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	On success the port is ready to use and the line number is returned.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial8250_register_8250_port</span><span class="params">(<span class="keyword">struct</span> uart_8250_port *up)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_8250_port</span> *<span class="title">uart</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = -ENOSPC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (up-&gt;port.uartclk == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;serial_mutex);</span><br><span class="line"></span><br><span class="line">	uart = serial8250_find_match_or_unused(&amp;up-&gt;port);</span><br><span class="line">	<span class="keyword">if</span> (uart &amp;&amp; uart-&gt;port.type != PORT_8250_CIR) &#123;</span><br><span class="line">		....</span><br><span class="line">        <span class="keyword">if</span> (uart-&gt;port.type != PORT_8250_CIR) &#123;</span><br><span class="line">			<span class="keyword">if</span> (serial8250_isa_config != <span class="literal">NULL</span>)</span><br><span class="line">				serial8250_isa_config(<span class="number">0</span>, &amp;uart-&gt;port,</span><br><span class="line">						&amp;uart-&gt;capabilities);</span><br><span class="line"></span><br><span class="line">			serial8250_apply_quirks(uart);</span><br><span class="line">			ret = uart_add_one_port(&amp;serial8250_reg,</span><br><span class="line">						&amp;uart-&gt;port);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">			ret = uart-&gt;port.line;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dev_info(uart-&gt;port.dev,</span><br><span class="line">				<span class="string">&quot;skipping CIR port at 0x%lx / 0x%llx, IRQ %d\n&quot;</span>,</span><br><span class="line">				uart-&gt;port.iobase,</span><br><span class="line">				(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)uart-&gt;port.mapbase,</span><br><span class="line">				uart-&gt;port.irq);</span><br><span class="line"></span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Initialise interrupt backoff work if required */</span></span><br><span class="line">		<span class="keyword">if</span> (up-&gt;overrun_backoff_time_ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			uart-&gt;overrun_backoff_time_ms =</span><br><span class="line">				up-&gt;overrun_backoff_time_ms;</span><br><span class="line">			INIT_DELAYED_WORK(&amp;uart-&gt;overrun_backoff,</span><br><span class="line">					serial_8250_overrun_backoff_work);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			uart-&gt;overrun_backoff_time_ms = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;serial_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	uart-&gt;port.dev = <span class="literal">NULL</span>;</span><br><span class="line">	mutex_unlock(&amp;serial_mutex);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(serial8250_register_8250_port);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 <code>serial8250_find_match_or_unused </code>函数内容如下所示</p>
<h3 id="serial8250-find-match-or-unused"><a href="#serial8250-find-match-or-unused" class="headerlink" title="serial8250_find_match_or_unused()"></a>serial8250_find_match_or_unused()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> uart_8250_port *<span class="title function_">serial8250_find_match_or_unused</span><span class="params">(<span class="keyword">struct</span> uart_port *port)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * First, find a port entry which matches.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 首先，查找一个匹配的端口条目。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++)</span><br><span class="line">		<span class="keyword">if</span> (uart_match_port(&amp;serial8250_ports[i].port, port))</span><br><span class="line">			<span class="keyword">return</span> &amp;serial8250_ports[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* try line number first if still available */</span></span><br><span class="line">	i = port-&gt;line;<span class="comment">/* 如果还有空闲的端口号，尝试使用 */</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; nr_uarts &amp;&amp; serial8250_ports[i].port.type == PORT_UNKNOWN &amp;&amp;</span><br><span class="line">			serial8250_ports[i].port.iobase == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> &amp;serial8250_ports[i];</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We didn&#x27;t find a matching entry, so look for the first</span></span><br><span class="line"><span class="comment">	 * free entry.  We look for one which hasn&#x27;t been previously</span></span><br><span class="line"><span class="comment">	 * used (indicated by zero iobase).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++)</span><br><span class="line">		<span class="keyword">if</span> (serial8250_ports[i].port.type == PORT_UNKNOWN &amp;&amp;</span><br><span class="line">		    serial8250_ports[i].port.iobase == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> &amp;serial8250_ports[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * That also failed.  Last resort is to find any entry which</span></span><br><span class="line"><span class="comment">	 * doesn&#x27;t have a real port associated with it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 如果仍然没有找到，最后的尝试是找到一个没有实际端口相关联的条目。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_uarts; i++)</span><br><span class="line">		<span class="keyword">if</span> (serial8250_ports[i].port.type == PORT_UNKNOWN)</span><br><span class="line">			<span class="keyword">return</span> &amp;serial8250_ports[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>serial8250_register_8250_port()</code>第 33 行 <code>uart_add_one_port()</code> 函数向 tty 核心层注册一个 UART 端口，<code>uart_add_one_port()</code> 函数内容如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	uart_add_one_port - attach a driver-defined port structure</span></span><br><span class="line"><span class="comment"> *	@drv: pointer to the uart low level driver structure for this port</span></span><br><span class="line"><span class="comment"> *	@uport: uart port structure to use for this port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	This allows the driver to register its own uart_port structure</span></span><br><span class="line"><span class="comment"> *	with the core driver.  The main purpose is to allow the low</span></span><br><span class="line"><span class="comment"> *	level uart drivers to expand uart_port, rather than having yet</span></span><br><span class="line"><span class="comment"> *	more levels of structures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_add_one_port</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv, <span class="keyword">struct</span> uart_port *uport)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">tty_dev</span>;</span></span><br><span class="line">	<span class="type">int</span> num_groups;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Register the port whether it&#x27;s detected or not.  This allows</span></span><br><span class="line"><span class="comment">	 * setserial to be used to alter this port&#x27;s parameters.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	tty_dev = tty_port_register_device_attr_serdev(port, drv-&gt;tty_driver,</span><br><span class="line">			uport-&gt;line, uport-&gt;dev, port, uport-&gt;tty_groups);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tty_port_register_device_attr_serdev </code>函数内容如下所示：</p>
<h3 id="tty-port-register-device-attr-serdev"><a href="#tty-port-register-device-attr-serdev" class="headerlink" title="tty_port_register_device_attr_serdev()"></a>tty_port_register_device_attr_serdev()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * tty_port_register_device_attr_serdev - register tty or serdev device</span></span><br><span class="line"><span class="comment"> * @port: tty_port of the device</span></span><br><span class="line"><span class="comment"> * @driver: tty_driver for this device</span></span><br><span class="line"><span class="comment"> * @index: index of the tty</span></span><br><span class="line"><span class="comment"> * @device: parent if exists, otherwise NULL</span></span><br><span class="line"><span class="comment"> * @drvdata: driver data for the device</span></span><br><span class="line"><span class="comment"> * @attr_grp: attribute group for the device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Register a serdev or tty device depending on if the parent device has any</span></span><br><span class="line"><span class="comment"> * defined serdev clients or not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册一个 tty 设备到 tty 核心层，如果注册的设备是 serdev 设备，则不创建 cdev。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">tty_port_register_device_attr_serdev</span><span class="params">(<span class="keyword">struct</span> tty_port *port,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> tty_driver *driver, <span class="type">unsigned</span> index,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> device *device, <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> attribute_group **attr_grp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	tty_port_link_device(port, driver, index);<span class="comment">// 将 tty 端口链接到设备</span></span><br><span class="line">	<span class="comment">// 注册 serdev 设备</span></span><br><span class="line">	dev = serdev_tty_port_register(port, device, driver, index);</span><br><span class="line">	<span class="keyword">if</span> (PTR_ERR(dev) != -ENODEV) &#123;</span><br><span class="line">		<span class="comment">/* Skip creating cdev if we registered a serdev device */</span></span><br><span class="line">		<span class="keyword">return</span> dev;<span class="comment">/* 如果注册的是 serdev 设备，则不创建 cdev */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果注册的不是 serdev 设备，则创建 cdev</span></span><br><span class="line">	<span class="keyword">return</span> tty_register_device_attr(driver, index, device, drvdata,</span><br><span class="line">			attr_grp);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(tty_port_register_device_attr_serdev);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数用于注册一个 tty 设备到 tty 核心层，如果注册的设备是 serdev 设备，则不创建 cdev。</p>
<p>首先，它将 tty 端口链接到设备，然后尝试注册 serdev 设备。如果注册的是 serdev 设备，则直接返回注册结果；否则，通过调用 <code>tty_register_device_attr()</code> 函数创建 cdev 并注册该设备到 tty 核心层。<code>tty_register_device_attr</code> 函数内容如下所示：</p>
<h3 id="tty-register-device-attr"><a href="#tty-register-device-attr" class="headerlink" title="tty_register_device_attr()"></a>tty_register_device_attr()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	tty_register_device_attr - register a tty device</span></span><br><span class="line"><span class="comment"> *	@driver: the tty driver that describes the tty device</span></span><br><span class="line"><span class="comment"> *	@index: the index in the tty driver for this tty device</span></span><br><span class="line"><span class="comment"> *	@device: a struct device that is associated with this tty device.</span></span><br><span class="line"><span class="comment"> *		This field is optional, if there is no known struct device</span></span><br><span class="line"><span class="comment"> *		for this tty device it can be set to NULL safely.</span></span><br><span class="line"><span class="comment"> *	@drvdata: Driver data to be set to device.</span></span><br><span class="line"><span class="comment"> *	@attr_grp: Attribute group to be set on device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Returns a pointer to the struct device for this tty device</span></span><br><span class="line"><span class="comment"> *	(or ERR_PTR(-EFOO) on error).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	This call is required to be made to register an individual tty device</span></span><br><span class="line"><span class="comment"> *	if the tty driver&#x27;s flags have the TTY_DRIVER_DYNAMIC_DEV bit set.  If</span></span><br><span class="line"><span class="comment"> *	that bit is not set, this function should not be called by a tty</span></span><br><span class="line"><span class="comment"> *	driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Locking: ??</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册一个 tty 设备到 tty 核心层，包括创建 cdev，并添加属性组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">tty_register_device_attr</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver,</span></span><br><span class="line"><span class="params">				   <span class="type">unsigned</span> index, <span class="keyword">struct</span> device *device,</span></span><br><span class="line"><span class="params">				   <span class="type">void</span> *drvdata,</span></span><br><span class="line"><span class="params">				   <span class="type">const</span> <span class="keyword">struct</span> attribute_group **attr_grp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];<span class="comment">// 设备名称缓冲区</span></span><br><span class="line">	<span class="type">dev_t</span> devt = MKDEV(driver-&gt;major, driver-&gt;minor_start) + index;<span class="comment">// 计算设备号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> *<span class="title">tp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (index &gt;= driver-&gt;num) &#123;<span class="comment">// 检查索引是否超出范围</span></span><br><span class="line">		pr_err(<span class="string">&quot;%s: Attempt to register invalid tty line number (%d)\n&quot;</span>,</span><br><span class="line">		       driver-&gt;name, index);</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;type == TTY_DRIVER_TYPE_PTY)<span class="comment">// 根据驱动类型生成设备名称</span></span><br><span class="line">		pty_line_name(driver, index, name);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tty_line_name(driver, index, name);</span><br><span class="line"></span><br><span class="line">	dev = kzalloc(<span class="keyword">sizeof</span>(*dev), GFP_KERNEL);<span class="comment">// 分配设备结构体内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (!dev)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置设备结构体的各个属性</span></span><br><span class="line">	dev-&gt;devt = devt;</span><br><span class="line">	dev-&gt;<span class="class"><span class="keyword">class</span> =</span> tty_class;</span><br><span class="line">	dev-&gt;parent = device;</span><br><span class="line">	dev-&gt;release = tty_device_create_release;</span><br><span class="line">	dev_set_name(dev, <span class="string">&quot;%s&quot;</span>, name);<span class="comment">// 设置设备名称</span></span><br><span class="line">	dev-&gt;groups = attr_grp;<span class="comment">// 设置属性组</span></span><br><span class="line">	dev_set_drvdata(dev, drvdata);</span><br><span class="line"></span><br><span class="line">	dev_set_uevent_suppress(dev, <span class="number">1</span>);<span class="comment">// 设置抑制 uevent</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册设备到内核</span></span><br><span class="line">	retval = device_register(dev);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> err_put;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(driver-&gt;flags &amp; TTY_DRIVER_DYNAMIC_ALLOC)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Free any saved termios data so that the termios state is</span></span><br><span class="line"><span class="comment">		 * reset when reusing a minor number.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		* 如果驱动不是动态分配的，则释放任何保存的终端参数数据，</span></span><br><span class="line"><span class="comment">		* 这样当重用一个次设备号时，终端参数状态将被重置。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		tp = driver-&gt;termios[index];</span><br><span class="line">		<span class="keyword">if</span> (tp) &#123;</span><br><span class="line">			driver-&gt;termios[index] = <span class="literal">NULL</span>;</span><br><span class="line">			kfree(tp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 添加 cdev 到 tty 核心层</span></span><br><span class="line">		retval = tty_cdev_add(driver, devt, index, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (retval)</span><br><span class="line">			<span class="keyword">goto</span> err_del;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev_set_uevent_suppress(dev, <span class="number">0</span>);<span class="comment">// 取消抑制 uevent</span></span><br><span class="line">	kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);<span class="comment">// 发送 uevent 通知设备已添加</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line"></span><br><span class="line">err_del:</span><br><span class="line">	device_del(dev); <span class="comment">// 删除设备</span></span><br><span class="line">err_put:</span><br><span class="line">	put_device(dev);<span class="comment">// 释放设备结构体内存空间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERR_PTR(retval);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(tty_register_device_attr);</span><br></pre></td></tr></table></figure>

<p>该函数用于注册一个 tty 设备到 tty 核心层，包括创建 cdev，并添加属性组。</p>
<p>首先，它会根据驱动类型生成设备名称，并分配设备结构体内存空间，并设置设备的各个属性。</p>
<p>然后，它注册设备到内核，并根据驱动是否动态分配来决定是否添加 cdev 到 tty 核心层。</p>
<p>最后，取消抑制 uevent 并发送 uevent 通知设备已添加，并返回设备结构体指针。</p>
<h3 id="tty-cdev-add"><a href="#tty-cdev-add" class="headerlink" title="tty_cdev_add()"></a>tty_cdev_add()</h3><p>添加 cdev 到 tty 核心层使用 <code>tty_cdev_add</code> 函数，内容如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 向 tty 核心层添加 cdev。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_cdev_add</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">dev_t</span> dev,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init here, since reused cdevs cause crashes */</span></span><br><span class="line">	driver-&gt;cdevs[index] = cdev_alloc();<span class="comment">// 分配一个 cdev 结构体</span></span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;cdevs[index])<span class="comment">// 如果分配失败则返回错误</span></span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	driver-&gt;cdevs[index]-&gt;ops = &amp;tty_fops; <span class="comment">// 设置 cdev 的操作</span></span><br><span class="line">	driver-&gt;cdevs[index]-&gt;owner = driver-&gt;owner;<span class="comment">// 设置 cdev 的所有者</span></span><br><span class="line">	err = cdev_add(driver-&gt;cdevs[index], dev, count);<span class="comment">// 添加 cdev 到内核</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		kobject_put(&amp;driver-&gt;cdevs[index]-&gt;kobj);<span class="comment">// 添加失败时释放资源</span></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该函数用于向 tty 核心层添加 cdev。首先，它分配一个 cdev 结构体，并设置其操作和所有者。然后，它通过调用 <code>cdev_add()</code> 函数将 cdev 添加到内核中。如果添加失败，则释放已分配的资源。</p>
<p>在上面代码第 13 行中，<code>tty_fops</code> 是 tty 驱动中的文件操作结构体，它定义了 tty 设备文件的操作函数。</p>
<p>这些函数包括了对 tty 设备文件进行打开、关闭、读取、写入、控制等操作的实现。一般来说，这些函数会调用相应的 tty 核心层函数来完成对底层 tty 设备的操作。</p>
<p><code>tty_fops</code> 结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">tty_fops</span> =</span> &#123;</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read_iter	= tty_read,</span><br><span class="line">	.write_iter	= tty_write,</span><br><span class="line">	.splice_read	= generic_file_splice_read,</span><br><span class="line">	.splice_write	= iter_file_splice_write,</span><br><span class="line">	.poll		= tty_poll,</span><br><span class="line">	.unlocked_ioctl	= tty_ioctl,</span><br><span class="line">	.compat_ioctl	= tty_compat_ioctl,</span><br><span class="line">	.open		= tty_open,</span><br><span class="line">	.release	= tty_release,</span><br><span class="line">	.fasync		= tty_fasync,</span><br><span class="line">	.show_fdinfo	= tty_show_fdinfo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当用户空间对 tty 设备文件进行操作时，实际上是在调用对应的 tty_fops 中的操作函数。下面是一个简单的示例，展示了如何在用户空间对 tty 设备文件进行操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">	<span class="comment">// 打开 tty 设备文件</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/ttyS0&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;Failed to open tty device&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 向 tty 设备文件写入数据</span></span><br><span class="line">	write(fd, <span class="string">&quot;Hello, tty device!&quot;</span>, <span class="number">18</span>);</span><br><span class="line">	<span class="comment">// 从 tty 设备文件读取数据</span></span><br><span class="line">	read(fd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received data: %s\n&quot;</span>, buffer);</span><br><span class="line">	<span class="comment">// 关闭 tty 设备文件</span></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="串口编程"><a href="#串口编程" class="headerlink" title="串口编程"></a>串口编程</h1><p>在 Linux 系统中，可以使用文件 I&#x2F;O 操作和ioctl 操作来进行串口编程。</p>
<ul>
<li><p>文件 I&#x2F;O 操作可以用于读取和写入串口数据</p>
</li>
<li><p>ioctl 操作可以用于设置串口参数、控制流控制和获取串口状态等操作</p>
</li>
</ul>
<h2 id="串口设备节点"><a href="#串口设备节点" class="headerlink" title="串口设备节点"></a>串口设备节点</h2><p>在 Linux 系统中，每个设备都由一个设备节点（device node）来表示，设备节点是与设备相关联的一个文<br>件，以&#x2F;dev 目录下的文件形式存在。</p>
<p>串口设备节点通常以 tty 开头，具体命名方式根据串口的类型和数量不同而不同。开发板系统启动之后，使用以下命令打印终端设备节点，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704636.png" alt="&#x2F;dev&#x2F;tty" loading="lazy"></p>
<ul>
<li><p><strong>dev&#x2F;ttyX（X 是一个数字编号，譬如 0、1、2、3 等）设备节点</strong>：tty 是 teletype 的简称，在 Linux 中，<code>/dev/ttyX</code> 代表的都是本地终端， Linux 内核在初始化时所生成的 63 个本地终端，包括<code>/dev/tty1</code>~&#96;&#x2F;dev&#x2F;tty63&#96; 一共 63 个本地终端，可以是连接到开发板的 LCD 显示器、键盘和鼠标等。</p>
</li>
<li><p><strong>串口终端设备节点</strong>：从开发板原理图可以了解到，在 iTOP-3568 开发板上有四个串口，分别 UART2、UART4、UART7、UART9，其中 UART2 为串口调试终端，对应的设备节点为<code>/dev/ttyFIQ0</code>,其他三个串口 UART4、UART7、UART9 分别对应<code>/dev/ttyS4</code>、<code>/dev/ttyS7</code>、<code>/dev/ttyS9</code>。</p>
</li>
<li><p><strong>基于 USB 的虚拟串口</strong>：<code>ttyGS0</code> 以及 <code>ttyUSBX</code>（X 是一个数字编号，譬如 0、1、2、3 等）都是 USB 的虚拟串口，其中 ttyGS0 为烧写 usb 虚拟出的串口，在系统启动之后可以在 windows 终端通过“adb shell”命令进入开发板控制台。ttyUSBX 在这里为 4G 模块的虚拟串口。</p>
</li>
</ul>
<h2 id="struct-termios-结构体"><a href="#struct-termios-结构体" class="headerlink" title="struct termios 结构体"></a>struct termios 结构体</h2><p><code>struct termios</code> 是 Linux 内核中用于描述终端设备（包括串口设备）参数的结构体。</p>
<p>它定义在 <code>&lt;linux/termios.h&gt;</code> 头文件中，包含了多个字段，用于配置和管理终端设备的属性和行为，包括了输入输出波特率、数据位、校验位、停止位等。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> &#123;</span></span><br><span class="line">	<span class="type">tcflag_t</span> c_iflag; <span class="comment">// 输入模式标志</span></span><br><span class="line">	<span class="type">tcflag_t</span> c_oflag; <span class="comment">// 输出模式标志</span></span><br><span class="line">	<span class="type">tcflag_t</span> c_cflag; <span class="comment">// 控制模式标志</span></span><br><span class="line">	<span class="type">tcflag_t</span> c_lflag; <span class="comment">// 本地模式标志</span></span><br><span class="line">	<span class="type">cc_t</span> c_cc[NCCS]; <span class="comment">// 控制字符数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是 struct termios 结构体的一些重要字段：</p>
<ul>
<li><code>tcflag_t c_iflag</code>：该字段包含了输入模式标志，用于配置终端设备的输入行为，如输入控制字符、输入数据处理等。</li>
<li><code>tcflag_t c_oflag</code>：该字段包含了输出模式标志，用于配置终端设备的输出行为，如输出数据处理、输出控制字符等。</li>
<li><code>tcflag_t c_cflag</code>：该字段包含了控制模式标志，用于配置终端设备的控制参数，如波特率、数据位数、停止位数、校验位等。</li>
<li><code>tcflag_t c_lflag</code>：该字段包含了本地模式标志，用于配置终端设备的本地操作以及输入输出行为。</li>
<li><code>cc_t c_cc[NCCS]</code>：该字段包含了特殊控制字符数组，用于配置终端设备的控制字符，如终端的擦除字符、结束字符、停止字符等。</li>
</ul>
<h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><p>输入模式设置</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>对应成员的含义</th>
</tr>
</thead>
<tbody><tr>
<td>IGNBRK</td>
<td>忽略输入终止条件</td>
</tr>
<tr>
<td>BRKINT</td>
<td>当检测到输入终止条件时发送 SIGINT 信号</td>
</tr>
<tr>
<td>IGNPAR</td>
<td>忽略帧错误和奇偶校验错误</td>
</tr>
<tr>
<td>PARMRK</td>
<td>对奇偶校验错误做出标记</td>
</tr>
<tr>
<td>INPCK</td>
<td>对接收到的数据执行奇偶校验</td>
</tr>
<tr>
<td>ISTRIP</td>
<td>将所有接收到的数据裁剪为 7 比特位、也就是去除第八位</td>
</tr>
<tr>
<td>INLCR</td>
<td>将接收到的 NL（换行符）转换为 CR（回车符）</td>
</tr>
<tr>
<td>IGNCR</td>
<td>忽略接收到的 CR（回车符）</td>
</tr>
<tr>
<td>ICRNL</td>
<td>将接收到的 CR（回车符）转换为 NL（换行符）</td>
</tr>
<tr>
<td>IUCLC</td>
<td>将接收到的大写字符映射为小写字符</td>
</tr>
<tr>
<td>IXON</td>
<td>启动输出软件流控</td>
</tr>
</tbody></table>
<h3 id="输出模式"><a href="#输出模式" class="headerlink" title="输出模式"></a>输出模式</h3><p>输出模式控制输出字符的处理方式，即由应用程序发送出去的字符数据在传递到串口或屏幕之前是如何处理的。可用于 <code>c_oflag</code> 成员的宏如下所示：</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>对应成员的含义</th>
</tr>
</thead>
<tbody><tr>
<td>OPOST</td>
<td>启用输出处理功能，如果不设置该标志则其他标志都被忽略</td>
</tr>
<tr>
<td>OLCUC</td>
<td>将输出字符中的大写字符转换成小写字符</td>
</tr>
<tr>
<td>ONLCR</td>
<td>将输出中的换行符（NL ‘\n’）转换成回车符（CR ‘\r’）</td>
</tr>
<tr>
<td>OCRNL</td>
<td>将输出中的回车符（CR ‘\r’）转换成换行符（NL ‘\n’）</td>
</tr>
<tr>
<td>ONOCR</td>
<td>在第 0 列不输出回车符（CR）</td>
</tr>
<tr>
<td>ONLRET</td>
<td>不输出回车符</td>
</tr>
<tr>
<td>OFILL</td>
<td>发送填充字符以提供延时</td>
</tr>
<tr>
<td>OFDEL</td>
<td>如果设置该标志，则表示填充字符为 DEL 字符，否则为 NULL 字符</td>
</tr>
</tbody></table>
<h3 id="控制模式"><a href="#控制模式" class="headerlink" title="控制模式"></a>控制模式</h3><p>在这个结构体中，最重要的 <code>c_cflag</code>，可以控制模式控制终端设备的硬件特性，譬如对于串口来说，该字段比较重要，可设置串口波特率、数据位、校验位、停止位等硬件特性。通过设置 <code>struct termios</code> 结构中 <code>c_cflag</code> 成员的标志对控制模式进行配置。可用于 <code>c_cflag</code> 成员的标志如下所示：</p>
<h4 id="波特率（Baud-Rate）位掩码"><a href="#波特率（Baud-Rate）位掩码" class="headerlink" title="波特率（Baud Rate）位掩码"></a><strong>波特率（Baud Rate）位掩码</strong></h4><table>
<thead>
<tr>
<th>常量名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>B0</td>
<td>0 波特率（放弃 DTR）</td>
</tr>
<tr>
<td>B1800</td>
<td>1800 波特率</td>
</tr>
<tr>
<td>B2400</td>
<td>2400 波特率</td>
</tr>
<tr>
<td>B4800</td>
<td>4800 波特率</td>
</tr>
<tr>
<td>B9600</td>
<td>9600 波特率</td>
</tr>
<tr>
<td>B19200</td>
<td>19200 波特率</td>
</tr>
<tr>
<td>B38400</td>
<td>38400 波特率</td>
</tr>
<tr>
<td>B57600</td>
<td>57600 波特率</td>
</tr>
<tr>
<td>B115200</td>
<td>115200 波特率</td>
</tr>
</tbody></table>
<h4 id="数据位（Data-Bits）位掩码"><a href="#数据位（Data-Bits）位掩码" class="headerlink" title="数据位（Data Bits）位掩码"></a><strong>数据位（Data Bits）位掩码</strong></h4><table>
<thead>
<tr>
<th>常量名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CS5</td>
<td>5 个数据位</td>
</tr>
<tr>
<td>CS6</td>
<td>6 个数据位</td>
</tr>
<tr>
<td>CS7</td>
<td>7 个数据位</td>
</tr>
<tr>
<td>CS8</td>
<td>8 个数据位</td>
</tr>
</tbody></table>
<h4 id="停止位（Stop-Bits）位掩码"><a href="#停止位（Stop-Bits）位掩码" class="headerlink" title="停止位（Stop Bits）位掩码"></a><strong>停止位（Stop Bits）位掩码</strong></h4><table>
<thead>
<tr>
<th>常量名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CSTOPB</td>
<td>2 个停止位（不设则是 1 个停止位）</td>
</tr>
</tbody></table>
<h4 id="其他控制标志"><a href="#其他控制标志" class="headerlink" title="其他控制标志"></a><strong>其他控制标志</strong></h4><table>
<thead>
<tr>
<th>常量名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CREAD</td>
<td>接收使能</td>
</tr>
<tr>
<td>PARENB</td>
<td>校验位使能</td>
</tr>
<tr>
<td>PARODD</td>
<td>使用奇校验而不使用偶校验</td>
</tr>
<tr>
<td>HUPCL</td>
<td>最后关闭时挂线（放弃 DTR）</td>
</tr>
<tr>
<td>CLOCAL</td>
<td>本地连接（不改变端口所有者）</td>
</tr>
<tr>
<td>LOBLK</td>
<td>块作业控制输出</td>
</tr>
<tr>
<td>CNET_CTSRTS</td>
<td>硬件流控制使能</td>
</tr>
</tbody></table>
<h3 id="本地模式"><a href="#本地模式" class="headerlink" title="本地模式"></a>本地模式</h3><p>本地模式用于控制终端的本地数据处理和工作模式。通过设置 <code>struct termios</code> 结构体中<code>c_lflag</code> 成员的标 志对本地模式进行配置。可用于 <code>c_lflag</code> 成员的标志如下所示：</p>
<table>
<thead>
<tr>
<th>常量名称</th>
<th>含义说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>INPCK</strong></td>
<td>启用奇偶校验功能。当启用时，系统会检查接收到的数据是否有奇偶校验错误。</td>
</tr>
<tr>
<td><strong>IGNPAR</strong></td>
<td>忽略奇偶校验错误。即使检测到校验错误，也不丢弃数据或产生异常。</td>
</tr>
<tr>
<td><strong>PARMRK</strong></td>
<td>当发生奇偶校验错误时，标记该字符（通常在前面插入 <code>\033</code> 和 <code>\000</code>）。用于调试。</td>
</tr>
<tr>
<td><strong>ISTRIP</strong></td>
<td>将所有接收到的数据字节的第8位（最高位）清零，即只保留低7位（用于7位字符集）。</td>
</tr>
<tr>
<td><strong>IXON</strong></td>
<td>启动<strong>输出软件流控</strong>（XON&#x2F;XOFF）。当缓冲区满时，发送 XOFF（^S）暂停发送；空闲时发送 XON（^Q）恢复。</td>
</tr>
<tr>
<td><strong>IXOFF</strong></td>
<td>启动<strong>输入软件流控</strong>。允许设备在接收端主动发送 XON&#x2F;XOFF 控制字符来控制发送方。</td>
</tr>
<tr>
<td><strong>IXANY</strong></td>
<td>允许任意字符（不仅仅是 XON）触发流控重启。默认情况下只有 XON 才能重启传输。</td>
</tr>
<tr>
<td><strong>IGNBRK</strong></td>
<td>忽略中断条件（Break Condition）。即忽略线路中断信号（如长时间低电平）。</td>
</tr>
<tr>
<td><strong>BRKINT</strong></td>
<td>当检测到中断（Break）时，向进程发送 <code>SIGINT</code> 信号（通常用于中断程序执行）。</td>
</tr>
<tr>
<td><strong>INLCR</strong></td>
<td>将输入中的换行符（NL, <code>\n</code>）转换为回车符（CR, <code>\r</code>）。常见于某些旧式终端。</td>
</tr>
<tr>
<td><strong>IGNCR</strong></td>
<td>忽略输入中的回车符（CR, <code>\r</code>），不作任何处理。</td>
</tr>
<tr>
<td><strong>ICRNL</strong></td>
<td>将输入中的回车符（CR, <code>\r</code>）转换为换行符（NL, <code>\n</code>）。这是常见的行末处理方式。</td>
</tr>
<tr>
<td><strong>ICANON</strong></td>
<td>启用“规范模式”（Canonical Mode）。在此模式下，输入按行处理（以换行符结束），支持编辑（如退格、删除）、回显等功能。关闭后进入“原始模式”</td>
</tr>
</tbody></table>
<h3 id="特殊控制字符"><a href="#特殊控制字符" class="headerlink" title="特殊控制字符"></a>特殊控制字符</h3><p>特殊控制字符是一些字符组合，如 Ctrl+C、Ctrl+Z 等，当用户键入这样的组合键，终端会采取特殊处理方式。<code>struct termios</code> 结构体中 <code>c_cc</code> 数组将各种特殊字符映射到对应的支持函数。每个字符位置（数组下标）由对应的宏定义的，如下所示</p>
<table>
<thead>
<tr>
<th>常量名</th>
<th>功能</th>
<th>默认键</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>VKILL</strong></td>
<td>删除整行</td>
<td>Ctrl+U</td>
<td>编辑长命令</td>
</tr>
<tr>
<td><strong>VEOF</strong></td>
<td>文件结束</td>
<td>Ctrl+D</td>
<td>提交输入或关闭</td>
</tr>
<tr>
<td><strong>VEOL</strong></td>
<td>行尾标记</td>
<td>CR</td>
<td>兼容旧终端</td>
</tr>
<tr>
<td><strong>VEOL2</strong></td>
<td>第二行尾</td>
<td>LF</td>
<td>多种换行格式</td>
</tr>
<tr>
<td><strong>VMIN</strong></td>
<td>最小字符数</td>
<td>-</td>
<td>非规范模式读取控制</td>
</tr>
<tr>
<td><strong>VTIME</strong></td>
<td>超时时间</td>
<td>-</td>
<td>非规范模式读取控制</td>
</tr>
<tr>
<td><strong>VINTR</strong></td>
<td>中断</td>
<td>Ctrl+C</td>
<td>终止程序</td>
</tr>
<tr>
<td><strong>VQUIT</strong></td>
<td>暂停</td>
<td>Ctrl+Z</td>
<td>挂起进程</td>
</tr>
<tr>
<td><strong>VERASE</strong></td>
<td>删除字符</td>
<td>Backspace</td>
<td>单字符编辑</td>
</tr>
</tbody></table>
<h2 id="常用串口控制函数"><a href="#常用串口控制函数" class="headerlink" title="常用串口控制函数"></a>常用串口控制函数</h2><h3 id="tcgetattr"><a href="#tcgetattr" class="headerlink" title="tcgetattr()"></a>tcgetattr()</h3><p><strong>功能</strong>：获取当前终端（或串口设备）的属性配置。<br><strong>原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tcgetattr</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>fd</code>：文件描述符（如打开的串口 <code>/dev/ttyS0</code>）</li>
<li><code>termios_p</code>：指向 <code>struct termios</code> 的指针，用于存储当前配置</li>
</ul>
</li>
<li><strong>返回值</strong>：成功返回 0，失败返回 -1</li>
<li><strong>用途</strong>：读取当前串口的波特率、数据位、校验位、流控、输入&#x2F;输出模式等设置。</li>
</ul>
<blockquote>
<p>通常在修改串口前先调用此函数保存原始配置，以便程序退出时恢复。</p>
</blockquote>
<hr>
<h3 id="tcsetattr"><a href="#tcsetattr" class="headerlink" title="tcsetattr()"></a>tcsetattr()</h3><p><strong>功能</strong>：设置终端（或串口）的属性配置。<br><strong>原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcsetattr</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> optional_actions, <span class="type">const</span> <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong>：<ul>
<li><code>fd</code>：文件描述符</li>
<li><code>optional_actions</code>：指定何时应用新设置，常见值：<ul>
<li><code>TCSANOW</code>：立即生效</li>
<li><code>TCSADRAIN</code>：等待输出完成后再生效（常用于输出相关设置）</li>
<li><code>TCSAFLUSH</code>：清空输入&#x2F;输出缓冲区后立即生效</li>
</ul>
</li>
<li><code>termios_p</code>：包含新配置的 <code>struct termios</code> 指针</li>
</ul>
</li>
<li><strong>返回值</strong>：成功返回 0，失败返回 -1</li>
<li><strong>用途</strong>：应用新的串口参数（如波特率、8N1 配置、原始模式等）</li>
</ul>
<blockquote>
<p>⚠️ 修改后建议检查返回值，确保设置成功。</p>
</blockquote>
<hr>
<h3 id="cfgetispeed-和-cfgetospeed"><a href="#cfgetispeed-和-cfgetospeed" class="headerlink" title="cfgetispeed() 和 cfgetospeed()"></a>cfgetispeed() 和 cfgetospeed()</h3><p><strong>功能</strong>：分别获取输入（接收）和输出（发送）波特率。<br><strong>原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">speed_t</span> <span class="title function_">cfgetispeed</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> termios *termios_p)</span>;</span><br><span class="line"><span class="type">speed_t</span> <span class="title function_">cfgetospeed</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> termios *termios_p)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：波特率常量（如 <code>B9600</code>, <code>B115200</code>），不是实际数值（如 9600）</li>
<li><strong>注意</strong>：返回的是 <code>speed_t</code> 类型的<strong>掩码值</strong>，不能直接当作整数使用</li>
</ul>
<blockquote>
<p>实际波特率需通过查表或系统特定方式转换（某些系统提供 <code>cfmakeraw()</code> 或 <code>ioctl</code> 获取真实速率）。</p>
</blockquote>
<hr>
<h3 id="cfsetispeed-和-cfsetospeed"><a href="#cfsetispeed-和-cfsetospeed" class="headerlink" title="cfsetispeed()和 cfsetospeed()"></a>cfsetispeed()和 cfsetospeed()</h3><p><strong>功能</strong>：分别设置输入和输出波特率。</p>
<p><strong>原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cfsetispeed</span><span class="params">(<span class="keyword">struct</span> termios *termios_p, <span class="type">speed_t</span> speed)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cfsetospeed</span><span class="params">(<span class="keyword">struct</span> termios *termios_p, <span class="type">speed_t</span> speed)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>参数</strong>：</p>
<ul>
<li><code>termios_p</code>：指向要修改的 <code>termios</code> 结构</li>
<li><code>speed</code>：波特率常量（如 <code>B9600</code>, <code>B115200</code>）</li>
</ul>
</li>
<li><p><strong>返回值</strong>：成功返回 0，失败返回 -1</p>
</li>
<li><p><strong>典型用法</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">tty</span>;</span></span><br><span class="line">tcgetattr(fd, &amp;tty);</span><br><span class="line">cfsetospeed(&amp;tty, B115200);</span><br><span class="line">cfsetispeed(&amp;tty, B115200);</span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;tty);</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>通常收发波特率设为相同（全双工通信），除非特殊需求。</p>
</blockquote>
<hr>
<h3 id="tcflush-和-tcflow"><a href="#tcflush-和-tcflow" class="headerlink" title="tcflush() 和 tcflow()"></a>tcflush() 和 tcflow()</h3><h4 id="tcflush"><a href="#tcflush" class="headerlink" title="tcflush()"></a>tcflush()</h4><p><strong>功能</strong>：清空终端的输入或输出队列。<br><strong>原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcflush</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> queue_selector)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>queue_selector</code> 取值</strong>：<ul>
<li><code>TCIFLUSH</code>：清空<strong>输入队列</strong>（已收到但未读取的数据）</li>
<li><code>TCOFLUSH</code>：清空<strong>输出队列</strong>（待发送但未发出的数据）</li>
<li><code>TCIOFLUSH</code>：同时清空输入和输出队列</li>
</ul>
</li>
<li><strong>用途</strong>：在重新配置串口或重启通信前清除脏数据。</li>
</ul>
<h4 id="tcflow"><a href="#tcflow" class="headerlink" title="tcflow()"></a>tcflow()</h4><p><strong>功能</strong>：控制串口的数据流（暂停&#x2F;恢复传输）。<br><strong>原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcflow</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> action)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>action</code> 取值</strong>：<ul>
<li><code>TCOOFF</code>：暂停<strong>输出</strong>（发送端停止发送）</li>
<li><code>TCOON</code>：恢复<strong>输出</strong></li>
<li><code>TCIOFF</code>：暂停<strong>输入</strong>（向对端发送 XOFF，要求对方暂停）</li>
<li><code>TCION</code>：恢复<strong>输入</strong>（向对端发送 XON，允许继续发送）</li>
</ul>
</li>
<li><strong>用途</strong>：手动实现软件流控（XON&#x2F;XOFF），或应对缓冲区溢出。</li>
</ul>
<blockquote>
<p>💡 注意：<code>tcflow()</code> 依赖 <code>IXON/IXOFF</code> 标志是否启用。</p>
</blockquote>
<h2 id="串口操作流程"><a href="#串口操作流程" class="headerlink" title="串口操作流程"></a>串口操作流程</h2><h3 id="设置串口的波特率"><a href="#设置串口的波特率" class="headerlink" title="设置串口的波特率"></a>设置串口的波特率</h3><p>在编写串口应用程序时，设置串口波特率是必须的步骤之一，它决定了数据传输的速率。</p>
<p>在 Linux 中，设置波特率通常使用 cfsetspeed() 函数，cfsetspeed()函数所需头文件和函数原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cfsetspeed</span><span class="params">(<span class="keyword">struct</span> termios *termios_p, <span class="type">speed_t</span> speed)</span>;</span><br></pre></td></tr></table></figure>

<p>它接受一个 <code>struct termios</code> 结构体作为输入参数，同时返回一个整数值，表示操作是否成功。</p>
<p>该函数实际上是对 <code>c_cflag</code> 字段中的波特率进行设置。例如，如果要将波特率设置为115200，可以调用以下代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">options</span>;</span></span><br><span class="line"><span class="comment">// 获取当前终端配置</span></span><br><span class="line">tcgetattr(fd, &amp;options);</span><br><span class="line"><span class="comment">// 设置波特率为 115200</span></span><br><span class="line">cfsetspeed(&amp;options, B115200);</span><br><span class="line"><span class="comment">// 将新的终端配置写入终端</span></span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;options);</span><br></pre></td></tr></table></figure>

<p>需要注意以下几点：</p>
<ul>
<li>需要先打开串口设备文件并且获取串口的属性，包括波特率在内的其他属性。可以使用 <code>tcgetattr()</code> 函数获取属性值，并存储在一个 <code>termios</code> 结构体变量中。</li>
<li>设置波特率时需要调用 <code>cfsetspeed()</code> 函数，并传入一个波特率常量作为参数。常用的波特率常量包括 B9600、B115200 等。这些常量可以在头文件 <code>termios.h</code> 中找到。</li>
<li>设置完成后，需要使用 <code>tcsetattr()</code> 函数将属性值写回到串口设备中。</li>
</ul>
<h3 id="设置数据位大小"><a href="#设置数据位大小" class="headerlink" title="设置数据位大小"></a>设置数据位大小</h3><p>在串口通讯中，数据位指的是每个字符（byte）中实际包含的数据位数。通常情况下，一个字符包含 8 个位（即 8 个 0 或 1），但有时也可能为 7 个位或其他值。</p>
<p>在编写串口应用程序时，需要使用 <code>struct termios</code> 结构体中的 <code>c_cflag</code> 成员变量来设置数据位大小。具体来说，需要将 <code>c_cflag</code> 成员变量中与数据位相关的位清零，然后再根据需要设置相应的值。</p>
<p>清零操作通常使用按位与（&amp;）运算符和位运算中的“非”运算符（~），具体步骤如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;= ~CSIZE; <span class="comment">// 将数据位相关的比特位清零</span></span><br></pre></td></tr></table></figure>

<p>其中，CSIZE 是一个宏定义，表示数据位的位掩码。宏定义通常定义在 <code>termios.h</code> 头文件中，其取值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CSIZE 0x00000300 <span class="comment">/* 字符长度掩码 */</span></span></span><br></pre></td></tr></table></figure>

<p>通过清零操作，将数据位相关的位全部置为 0。接下来，可以使用按位或（|）运算符和宏定义来设置具体的数据位数，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag |= CS8; <span class="comment">// 将数据位数设置为 8 位</span></span><br></pre></td></tr></table></figure>

<p>此时，CS8 宏定义将会被解释为一个包含 8 位的位掩码，通过按位或运算，将其设置到 <code>c_cflag</code> 成员变量中，从而完成数据位的设置。</p>
<h3 id="设置奇偶校验位"><a href="#设置奇偶校验位" class="headerlink" title="设置奇偶校验位"></a>设置奇偶校验位</h3><p>串口的奇偶校验位配置一共涉及到 <code>struct termios</code> 结构体中的两个成员变量：<code>c_cflag</code> 和<code>c_iflag</code>。</p>
<p>首先对于 <code>c_cflag</code> 成员，需要添加 <code>PARENB</code> 标志以使能串口的奇偶校验功能，只有使能奇偶校验功能之后才会对输出数据产生校验位，从而对输入数据进行校验检查；</p>
<p>同时对于<code>c_iflag</code> 成员来说，还需要添加 <code>INPCK</code> 标志，这样才能对接收到的数据执行奇偶校验，代码如下所示：</p>
<h4 id="奇校验使能"><a href="#奇校验使能" class="headerlink" title="奇校验使能"></a>奇校验使能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag |= (PARODD | PARENB); <span class="comment">// 设置为奇校验</span></span><br><span class="line">new_cfg.c_iflag |= INPCK; <span class="comment">// 使能奇偶校验</span></span><br></pre></td></tr></table></figure>

<h4 id="偶校验使能"><a href="#偶校验使能" class="headerlink" title="偶校验使能"></a>偶校验使能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;= ~PARODD; <span class="comment">// 设置为偶校验</span></span><br><span class="line">new_cfg.c_cflag |= PARENB; <span class="comment">// 使能奇偶校验</span></span><br><span class="line">new_cfg.c_iflag |= INPCK; <span class="comment">// 对输入数据执行奇偶校验</span></span><br></pre></td></tr></table></figure>

<h4 id="无校验"><a href="#无校验" class="headerlink" title="无校验"></a>无校验</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;= ~PARENB; <span class="comment">// 禁用奇偶校验</span></span><br><span class="line">new_cfg.c_iflag &amp;= ~INPCK; <span class="comment">// 不执行奇偶校验</span></span><br></pre></td></tr></table></figure>



<h3 id="设置停止位"><a href="#设置停止位" class="headerlink" title="设置停止位"></a>设置停止位</h3><p>在串口通信中，停止位用于指定每个数据帧的结束位置。</p>
<p>在传输一个完整的数据字节后，通常需要一个或多个停止位，以便接收端能够确定一个数据帧的结束。</p>
<p>停止位的数量通常为 1位或 2 位，其中 1 位停止位被广泛使用，而 2 位停止位则较少使用。</p>
<p>在 Linux 中，通过在 <code>struct termios</code> 结构体中设置 <code>c_cflag</code> 成员变量的 <code>CSTOPB</code> 标志位来控制停止位的数量。当 <code>CSTOPB</code> 为 0 时，仅使用 1 位停止位；当 <code>CSTOPB</code> 为 1 时，则使用 2位停止位。</p>
<p>例如，以下代码将串口的停止位设置为 1 位：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_cfg.c_cflag &amp;= ~CSTOPB; <span class="comment">// 设置停止位为 1 位</span></span><br></pre></td></tr></table></figure>





<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置串口参数的函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_uart</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> speed, <span class="type">int</span> bits, <span class="type">char</span> check, <span class="type">int</span> stop)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">newtio</span>, <span class="title">oldtio</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤一：保存原来的串口配置</span></span><br><span class="line">    <span class="keyword">if</span>(tcgetattr(fd, &amp;oldtio) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcgetattr oldtio error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;newtio, <span class="keyword">sizeof</span>(newtio));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤二：设置控制模式标志</span></span><br><span class="line">    newtio.c_cflag |= CLOCAL | CREAD;</span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤三：设置数据位</span></span><br><span class="line">    <span class="keyword">switch</span>(bits) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            newtio.c_cflag |= CS7;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            newtio.c_cflag |= CS8;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤四：设置奇偶校验位</span></span><br><span class="line">    <span class="keyword">switch</span>(check) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 偶校验位</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag |= PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: <span class="comment">// 奇校验位</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="comment">// 无校验</span></span><br><span class="line">            newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤五：设置波特率</span></span><br><span class="line">    <span class="keyword">switch</span>(speed) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9600</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">115200</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B115200);</span><br><span class="line">            cfsetospeed(&amp;newtio, B115200);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤六：设置停止位</span></span><br><span class="line">    <span class="keyword">switch</span>(stop) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            newtio.c_cflag &amp;= ~CSTOPB; <span class="comment">// 1位停止位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            newtio.c_cflag |= CSTOPB; <span class="comment">// 2位停止位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤七：刷新输入队列</span></span><br><span class="line">    tcflush(fd, TCIFLUSH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤八：设置配置立刻生效</span></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(fd, TCSANOW, &amp;newtio) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcsetattr newtio error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤九：打开串口设备</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/ttyS9&quot;</span>, O_RDWR | O_NOCTTY | O_NDELAY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置串口参数</span></span><br><span class="line">    set_uart(fd, <span class="number">115200</span>, <span class="number">8</span>, <span class="string">&#x27;N&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    write(fd, argv[<span class="number">1</span>], <span class="built_in">strlen</span>(argv[<span class="number">1</span>]));</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    count = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    buf[count] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出读取的数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read message is %s\n&quot;</span>, buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭串口设备</span></span><br><span class="line">    close(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="GPS模块编程"><a href="#GPS模块编程" class="headerlink" title="GPS模块编程"></a>GPS模块编程</h1><p>全球卫星导航系统是一种利用卫星技术为全球用户提供精确时间和位置信息的系统。</p>
<p>定位模块往往和 CPU 通过串口相连，然后 CPU 通过 wifi 蓝牙等其他方式将坐标进行上传。</p>
<p>GPS模块原理图如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704683.png" alt="GPS模块原理图" loading="lazy"></p>
<p>其中 <code>BUF_GPS_RST</code> 接口悬空不接，以下为 20pin 底座连接到 RK3568 开发板 GPIO 接口连接表如下所示：</p>
<table>
<thead>
<tr>
<th>GPS 模块引脚编号</th>
<th>GPS 模块引脚名称</th>
<th>连接到的开发板引脚编号</th>
<th>连接到的开发板引脚名称</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>BUF_GPS_TXD</td>
<td>8</td>
<td>UART9_RX_M1</td>
</tr>
<tr>
<td>3</td>
<td>BUF_GPS_RXD</td>
<td>6</td>
<td>UART9_TX_M1</td>
</tr>
<tr>
<td>11</td>
<td>GND</td>
<td>19&#x2F;20</td>
<td>GND</td>
</tr>
<tr>
<td>19</td>
<td>VDD33_A31</td>
<td>2&#x2F;4</td>
<td>VCC3V3_SYS</td>
</tr>
</tbody></table>
<blockquote>
<p> GPS 模块连接好之后，天线要放到户外</p>
</blockquote>
<h2 id="GPS-数据帧介绍"><a href="#GPS-数据帧介绍" class="headerlink" title="GPS 数据帧介绍"></a>GPS 数据帧介绍</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704724.png" alt="GPS数据" loading="lazy"></p>
<p>这里列举的是 GPS NMEA 格式中常见的数据类型，其中包括：</p>
<ul>
<li><strong>GPRMC (Recommended Minimum Specific GPS&#x2F;Transit data)</strong>：GPRMC 数据类型提供了位置、速度、航向等最基本的 GPS 定位信息。这个数据类型常用于导航系统和船舶自动导航系统。</li>
<li><strong>GPVTG (Track Made Good and Ground Speed)</strong>：GPVTG 数据类型提供了航向角和地面速度信息，用于显示船、车等运动物体的导航信息。 它提供了地面航向角和相对地面的速度。</li>
<li><strong>GPGGA (Global Positioning System Fix Data)</strong>：GPGGA 数据类型包括了定位解、时间、位置准确度、海拔等位置信息，通常被用于接收机实时显示当前位置。</li>
<li><strong>GPGSA (GPS DOP and Active Satellites)</strong>：GPGSA 数据类型包括了 DOP 值和当前卫星定位状态。它用于提供 GPS 卫星测量数据中可用卫星数量、解算出的位置几何因子 DOP 等信息。</li>
<li><strong>GPGSV (GPS Satellites in View)</strong>：GPGSV 数据类型提供了现时可视卫星的信息，包括卫星的PRN、仰角、方位角、信号强度等信息。这些信息有助于接收器找到更多卫星并提高位置定位的准确性。</li>
<li><strong>GPGLL (Geographic Position - Latitude&#x2F;Longitude)</strong>：GPGLL 数据类型提供了经度和纬度信息，用于描述接收机的当前经纬度位置。</li>
</ul>
<p>我们只需要关注 GPRMC 这条信息即可，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/even629/myPicGo/20251231204704767.png" alt="GPRMC" loading="lazy"></p>
<p>GPRMC（Recommended Minimum Specific GNSS Data）是一种常见的 GPS 数据帧格式，用于在 GPS 设备之间或者 GPS 设备与其他设备之间传输 GPS 位置信息。以下是 GPRMC 数据帧中包含的信息：</p>
<table>
<thead>
<tr>
<th>字段编号</th>
<th>字段值（示例）</th>
<th>含义</th>
<th>详细解释</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><code>$GPRMC</code></td>
<td>消息 ID</td>
<td>表示这是“推荐最小定位信息”帧。<code>GP</code> 表示由 GPS 系统提供；其他系统如 GLONASS 用 <code>GL</code>，北斗用 <code>BD</code> 或 <code>GB</code>。</td>
</tr>
<tr>
<td>1</td>
<td><code>083634.00</code></td>
<td>UTC 时间</td>
<td>格式：<code>hhmmss.sss</code> 表示 <strong>08:36:34.000 UTC</strong> → 北京时间 &#x3D; UTC + 8 小时 → <strong>16:36:34（下午 4 点 36 分）</strong></td>
</tr>
<tr>
<td>2</td>
<td><code>A</code></td>
<td>状态指示</td>
<td>- <code>A</code>：<strong>有效定位</strong>（Active &#x2F; Valid） - <code>V</code>：<strong>无效定位</strong>（Void &#x2F; Invalid），可能因信号弱或未锁定卫星</td>
</tr>
<tr>
<td>3</td>
<td><code>3854.62194</code></td>
<td>纬度（数值）</td>
<td>格式：<code>ddmm.mmmm</code> 即 <strong>38°54.62194′</strong> 转换为十进制度： <code>38 + 54.62194/60 ≈ 38.910366° N</code></td>
</tr>
<tr>
<td>4</td>
<td><code>N</code></td>
<td>纬度半球</td>
<td>- <code>N</code>：北纬（North） - <code>S</code>：南纬（South）</td>
</tr>
<tr>
<td>5</td>
<td><code>11526.10876</code></td>
<td>经度（数值）</td>
<td>格式：<code>dddmm.mmmm</code> 即 <strong>115°26.10876′</strong> 转换为十进制度： <code>115 + 26.10876/60 ≈ 115.435146° E</code></td>
</tr>
<tr>
<td>6</td>
<td><code>E</code></td>
<td>经度半球</td>
<td>- <code>E</code>：东经（East） - <code>W</code>：西经（West）</td>
</tr>
<tr>
<td>7</td>
<td><code>0.932</code></td>
<td>地面速率（节）</td>
<td>单位：<strong>knots（节）</strong> 1 节 &#x3D; 1 海里&#x2F;小时 ≈ 1.852 km&#x2F;h → <code>0.932 × 1.852 ≈ 1.73 km/h</code>（步行速度）</td>
</tr>
<tr>
<td>8</td>
<td><code>55.00</code></td>
<td>地面航向</td>
<td>单位：<strong>度（°）</strong>，以<strong>真北为 0°</strong> 范围：0.0 ~ 359.9° 55° 表示东北方向</td>
</tr>
<tr>
<td>9</td>
<td><code>200624</code></td>
<td>UTC 日期</td>
<td>格式：<code>ddmmyy</code> → <strong>2024 年 6 月 20 日</strong></td>
</tr>
<tr>
<td>10</td>
<td>（空）</td>
<td>磁偏角</td>
<td>可选字段，表示磁北与真北之间的夹角（单位：度）</td>
</tr>
<tr>
<td>11</td>
<td>（空）</td>
<td>磁偏角方向</td>
<td><code>E</code> 或 <code>W</code>，配合字段 10 使用</td>
</tr>
<tr>
<td>12</td>
<td>（空）</td>
<td>定位模式</td>
<td>- <code>A</code>：自主定位（Autonomous） - <code>D</code>：差分定位（DGPS） - <code>E</code>：估算（Dead Reckoning） - <code>N</code>：无定位 （注：部分模块在此字段输出，有些放在 <code>$GPGSA</code> 中）</td>
</tr>
<tr>
<td>13</td>
<td><code>D*50</code></td>
<td>校验和</td>
<td>从 <code>$</code> 后第一个字符到 <code>*</code> 前所有字符做 <strong>异或（XOR）校验</strong> 用于验证数据完整性</td>
</tr>
</tbody></table>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="gps-h"><a href="#gps-h" class="headerlink" title="gps.h"></a>gps.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __GPS_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __GPS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体 gprmc_data，用于存储解析后的 GPS 数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gprmc_data</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> id;         <span class="comment">// 数据标识（未使用）</span></span><br><span class="line">    <span class="type">int</span> time;      <span class="comment">// UTC 时间（hhmmss.sss 格式）</span></span><br><span class="line">    <span class="type">char</span> state;      <span class="comment">// 状态指示（A=有效，V=无效）</span></span><br><span class="line">    <span class="type">float</span> latitude;  <span class="comment">// 纬度（ddmm.mmmm 格式）</span></span><br><span class="line">    <span class="type">char</span> NS;         <span class="comment">// 纬度半球（N=北半球，S=南半球）</span></span><br><span class="line">    <span class="type">float</span> longitude; <span class="comment">// 经度（dddmm.mmmm 格式）</span></span><br><span class="line">    <span class="type">char</span> EW;         <span class="comment">// 经度半球（E=东经，W=西经）</span></span><br><span class="line">    <span class="type">float</span> speed;     <span class="comment">// 地面速率（节）</span></span><br><span class="line">    <span class="type">int</span> date;        <span class="comment">// UTC 日期（ddmmyy 格式）</span></span><br><span class="line">    <span class="type">char</span> mode;       <span class="comment">// 模式指示（A=自主定位，D=差分定位）</span></span><br><span class="line">    <span class="type">char</span> check;      <span class="comment">// 校验位（未使用）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数原型：设置串口参数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">set_uart</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> speed, <span class="type">int</span> bits, <span class="type">char</span> check, <span class="type">int</span> stop)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数原型：解析 GPS 数据</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">get_gps_data</span><span class="params">(<span class="type">char</span> *buff, <span class="keyword">struct</span> gprmc_data *gps_data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="gps-c"><a href="#gps-c" class="headerlink" title="gps.c"></a>gps.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gps.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数：get_gps_data</span></span><br><span class="line"><span class="comment">// 描述：从数据缓冲区解析GPS数据，并填充到结构体中</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">//   - buff: 指向包含GPS数据的缓冲区的指针</span></span><br><span class="line"><span class="comment">//   - gps_data: 指向结构体 gprmc_data 的指针，用于存储解析后的GPS数据</span></span><br><span class="line"><span class="comment">// 返回值：无</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_gps_data</span><span class="params">(<span class="type">char</span> *buff, <span class="keyword">struct</span> gprmc_data *gps_data)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 在缓冲区中查找以 &quot;$GPRMC&quot; 开头的位置</span></span><br><span class="line">    p = <span class="built_in">strstr</span>(buff, <span class="string">&quot;$GPRMC&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="comment">// printf(&quot;Error: $GPRMC not found in buffer.\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 如果未找到 &quot;$GPRMC&quot;，直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用 sscanf 函数从字符串 p 开始按指定格式解析数据，并存储到 gps_data 结构体中对应的成员变量中</span></span><br><span class="line">    <span class="built_in">sscanf</span>(p,<span class="string">&quot;$GPRMC,%d.00,%c,%f,%c,%f,%c,%f,,%d,,,%c,%*c&quot;</span>,\</span><br><span class="line">    &amp;(gps_data-&gt;time),\</span><br><span class="line">    &amp;(gps_data-&gt;state),\</span><br><span class="line">    &amp;(gps_data-&gt;latitude),\</span><br><span class="line">    &amp;(gps_data-&gt;NS),\</span><br><span class="line">    &amp;(gps_data-&gt;longitude),\</span><br><span class="line">    &amp;(gps_data-&gt;EW),\</span><br><span class="line">    &amp;(gps_data-&gt;speed),\</span><br><span class="line">    &amp;(gps_data-&gt;date),\</span><br><span class="line">    &amp;(gps_data-&gt;mode));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印解析后的部分 GPS 数据，用于验证解析是否正确（可选）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;state:%c, %c:%f, %c:%f\n&quot;</span>, gps_data-&gt;state, gps_data-&gt;NS,</span><br><span class="line">           gps_data-&gt;latitude, gps_data-&gt;EW, gps_data-&gt;longitude);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="uart-c"><a href="#uart-c" class="headerlink" title="uart.c"></a>uart.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置串口参数的函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_uart</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> speed, <span class="type">int</span> bits, <span class="type">char</span> check, <span class="type">int</span> stop)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">newtio</span>, <span class="title">oldtio</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤一：保存原来的串口配置</span></span><br><span class="line">    <span class="keyword">if</span>(tcgetattr(fd, &amp;oldtio) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcgetattr oldtio error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;newtio, <span class="keyword">sizeof</span>(newtio));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤二：设置控制模式标志</span></span><br><span class="line">    newtio.c_cflag |= CLOCAL | CREAD;</span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤三：设置数据位</span></span><br><span class="line">    <span class="keyword">switch</span>(bits) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            newtio.c_cflag |= CS7;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            newtio.c_cflag |= CS8;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤四：设置奇偶校验位</span></span><br><span class="line">    <span class="keyword">switch</span>(check) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 偶校验位</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag |= PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: <span class="comment">// 奇校验位</span></span><br><span class="line">            newtio.c_cflag |= PARENB;</span><br><span class="line">            newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">            newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="comment">// 无校验</span></span><br><span class="line">            newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤五：设置波特率</span></span><br><span class="line">    <span class="keyword">switch</span>(speed) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9600</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">            cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">115200</span>:</span><br><span class="line">            cfsetispeed(&amp;newtio, B115200);</span><br><span class="line">            cfsetospeed(&amp;newtio, B115200);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤六：设置停止位</span></span><br><span class="line">    <span class="keyword">switch</span>(stop) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            newtio.c_cflag &amp;= ~CSTOPB; <span class="comment">// 1位停止位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            newtio.c_cflag |= CSTOPB; <span class="comment">// 2位停止位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤七：刷新输入队列</span></span><br><span class="line">    tcflush(fd, TCIFLUSH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤八：设置配置立刻生效</span></span><br><span class="line">    <span class="keyword">if</span> (tcsetattr(fd, TCSANOW, &amp;newtio) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tcsetattr newtio error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://even629.github.io/">even629</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://even629.com/posts/2512313/">https://even629.com/posts/2512313/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://even629.com" target="_blank">常想一二，不思八九</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GNU/">GNU</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/driver/">driver</a></div><div class="post-share"><div class="social-share" data-image="/images/linux_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center liquidGlass-wrapper" id="my-custom-card-author"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status">🐟<span>认真摸鱼中</span></div></div></div><div><div class="author-info-name">even629</div><div class="author-info-description">常想一二，不思八九</div></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">89</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">72</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/even629" target="_blank" title="github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank" title="qq"><i class="fa-brands fa-qq" style="color: #000000;"></i></a><a class="social-icon" href="mailto:zhaohang731005515@proton.me" target="_blank" title="email"><i class="fas fa-envelope" style="color: #000000;"></i></a><a class="social-icon" href="https://space.bilibili.com/519280138" target="_blank" title="bilibili"><i class="fa-brands fa-bilibili" style="color: #000000;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="rss"><i class="fas fa-rss" style="color: #000000;"></i></a></div></div></div><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"> <div class="newYear-slider"> <div class="swiper-wrapper"> <div class="swiper-slide" style="background-image:url(/img/happy_new_year1.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year2.jpg)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year3.webp)"></div> <div class="swiper-slide" style="background-image:url(/img/happy_new_year4.gif)"></div> </div> </div> <div id="newYear-main"> <div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div> </div></div><div class="sticky_layout"><div class="card-widget liquidGlass-wrapper" id="card-toc"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UART"><span class="toc-text">UART</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A2%E7%89%B9%E7%8E%87"><span class="toc-text">波特率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="toc-text">串口通讯协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%BB%93%E6%9E%84"><span class="toc-text">数据流结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E6%B3%A2%E5%BD%A2%E5%88%86%E6%9E%90"><span class="toc-text">时序波形分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">串口通信接口的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RS232%E6%8E%A5%E5%8F%A3"><span class="toc-text">RS232接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DB9-%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E"><span class="toc-text">DB9 引脚说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E5%B9%B3%E7%89%B9%E6%80%A7"><span class="toc-text">电平特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RS485%E6%8E%A5%E5%8F%A3"><span class="toc-text">RS485接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E5%8A%BF"><span class="toc-text">特点和优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E5%B9%B3%E7%89%B9%E6%80%A7-1"><span class="toc-text">电平特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SIT3485E%E8%8A%AF%E7%89%87"><span class="toc-text">SIT3485E芯片</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E6%94%B6%E5%8F%91-485-%E7%94%B5%E8%B7%AF"><span class="toc-text">自收发 485 电路</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6"><span class="toc-text">串口子系统框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8"><span class="toc-text">配置串口驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uart-driver-%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">uart_driver 注册流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uart-%E7%9B%B8%E5%85%B3%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">uart 相关底层结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-uart-driver"><span class="toc-text">struct uart_driver</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-uart-port"><span class="toc-text">struct uart_port</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-uart-state"><span class="toc-text">struct uart_state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-uart-ops"><span class="toc-text">struct uart_ops</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uart-driver-%E6%B3%A8%E5%86%8C%E5%88%86%E6%9E%90"><span class="toc-text">uart_driver 注册分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#serial8250-init"><span class="toc-text">serial8250_init()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%968250%E4%B8%B2%E5%8F%A3"><span class="toc-text">初始化8250串口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#serial8250-isa-init-ports"><span class="toc-text">serial8250_isa_init_ports()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#serial8250-init-port"><span class="toc-text">serial8250_init_port()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C-UART-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">注册 UART 驱动程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#uart-register-driver"><span class="toc-text">uart_register_driver()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#tty-register-dirver"><span class="toc-text">tty_register_dirver()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E7%BB%93%E6%9E%84%E4%BD%93%E5%B9%B6%E6%B3%A8%E5%86%8C"><span class="toc-text">分配平台设备结构体并注册</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%B2%E5%8F%A3%E7%AB%AF%E5%8F%A3"><span class="toc-text">注册串口端口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#serial8250-register-ports"><span class="toc-text">serial8250_register_ports()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C-platform-driver-%E9%A9%B1%E5%8A%A8"><span class="toc-text">注册 platform_driver 驱动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">端口注册流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dw-probe"><span class="toc-text">dw_probe()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serial8250-register-8250-port"><span class="toc-text">serial8250_register_8250_port()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serial8250-find-match-or-unused"><span class="toc-text">serial8250_find_match_or_unused()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tty-port-register-device-attr-serdev"><span class="toc-text">tty_port_register_device_attr_serdev()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tty-register-device-attr"><span class="toc-text">tty_register_device_attr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tty-cdev-add"><span class="toc-text">tty_cdev_add()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="toc-text">串口编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E8%AE%BE%E5%A4%87%E8%8A%82%E7%82%B9"><span class="toc-text">串口设备节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-termios-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">struct termios 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">输入模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-text">输出模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">控制模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A2%E7%89%B9%E7%8E%87%EF%BC%88Baud-Rate%EF%BC%89%E4%BD%8D%E6%8E%A9%E7%A0%81"><span class="toc-text">波特率（Baud Rate）位掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%EF%BC%88Data-Bits%EF%BC%89%E4%BD%8D%E6%8E%A9%E7%A0%81"><span class="toc-text">数据位（Data Bits）位掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E4%BD%8D%EF%BC%88Stop-Bits%EF%BC%89%E4%BD%8D%E6%8E%A9%E7%A0%81"><span class="toc-text">停止位（Stop Bits）位掩码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E6%A0%87%E5%BF%97"><span class="toc-text">其他控制标志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%A8%A1%E5%BC%8F"><span class="toc-text">本地模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6"><span class="toc-text">特殊控制字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%B8%B2%E5%8F%A3%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="toc-text">常用串口控制函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcgetattr"><span class="toc-text">tcgetattr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcsetattr"><span class="toc-text">tcsetattr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cfgetispeed-%E5%92%8C-cfgetospeed"><span class="toc-text">cfgetispeed() 和 cfgetospeed()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cfsetispeed-%E5%92%8C-cfsetospeed"><span class="toc-text">cfsetispeed()和 cfsetospeed()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcflush-%E5%92%8C-tcflow"><span class="toc-text">tcflush() 和 tcflow()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tcflush"><span class="toc-text">tcflush()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcflow"><span class="toc-text">tcflow()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">串口操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%B2%E5%8F%A3%E7%9A%84%E6%B3%A2%E7%89%B9%E7%8E%87"><span class="toc-text">设置串口的波特率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%95%B0%E6%8D%AE%E4%BD%8D%E5%A4%A7%E5%B0%8F"><span class="toc-text">设置数据位大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D"><span class="toc-text">设置奇偶校验位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E6%A0%A1%E9%AA%8C%E4%BD%BF%E8%83%BD"><span class="toc-text">奇校验使能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%BF%E8%83%BD"><span class="toc-text">偶校验使能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%A0%A1%E9%AA%8C"><span class="toc-text">无校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%81%9C%E6%AD%A2%E4%BD%8D"><span class="toc-text">设置停止位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GPS%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B"><span class="toc-text">GPS模块编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GPS-%E6%95%B0%E6%8D%AE%E5%B8%A7%E4%BB%8B%E7%BB%8D"><span class="toc-text">GPS 数据帧介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gps-h"><span class="toc-text">gps.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gps-c"><span class="toc-text">gps.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uart-c"><span class="toc-text">uart.c</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post liquidGlass-wrapper"><div class="liquidGlass-effect"></div><div class="liquidGlass-tint"></div><div class="liquidGlass-shine"></div><div class="liquidGlass-box"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/2601133/" title="Linux 网络设备"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux 网络设备"/></a><div class="content"><a class="title" href="/posts/2601133/" title="Linux 网络设备">Linux 网络设备</a><time datetime="2026-01-13T14:00:00.000Z" title="发表于 2026-01-13 22:00:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601143/" title="Linux ADC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux ADC"/></a><div class="content"><a class="title" href="/posts/2601143/" title="Linux ADC">Linux ADC</a><time datetime="2026-01-13T13:18:00.000Z" title="发表于 2026-01-13 21:18:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601093/" title="Linux CAN"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux CAN"/></a><div class="content"><a class="title" href="/posts/2601093/" title="Linux CAN">Linux CAN</a><time datetime="2026-01-09T07:56:00.000Z" title="发表于 2026-01-09 15:56:00">2026-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601063/" title="Linux Watchdog"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux Watchdog"/></a><div class="content"><a class="title" href="/posts/2601063/" title="Linux Watchdog">Linux Watchdog</a><time datetime="2026-01-06T05:09:00.000Z" title="发表于 2026-01-06 13:09:00">2026-01-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601053/" title="Linux RTC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux RTC"/></a><div class="content"><a class="title" href="/posts/2601053/" title="Linux RTC">Linux RTC</a><time datetime="2026-01-05T14:09:00.000Z" title="发表于 2026-01-05 22:09:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2601043/" title="Linux PWM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/linux_cover.webp" onerror="this.onerror=null;this.src='/img/404.svg'" alt="Linux PWM"/></a><div class="content"><a class="title" href="/posts/2601043/" title="Linux PWM">Linux PWM</a><time datetime="2026-01-04T10:59:00.000Z" title="发表于 2026-01-04 18:59:00">2026-01-04</time></div></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(135deg, rgba(146, 233, 227, 1) 0%, rgba(0, 0, 0, 0) 70%);;"><div id="footer-wrap"><div class="footer-button"><a target="_blank" rel="noopener" href="https://github.com/even629" title="github"><i class="fab fa-github"></i></a><a href="/img/qq.jpg" title="qq"><i class="fa-brands fa-qq"></i></a><a href="mailto:zhaohang731005515@proton.me" title="email"><i class="fas fa-envelope"></i></a><a target="_blank" rel="noopener" href="https://space.bilibili.com/519280138" title="bilibili"><i class="fa-brands fa-bilibili"></i></a><a href="/atom.xml" title="rss"><i class="fas fa-rss"></i></a></div><div class="copyright">&copy;2024 - 2026 By even629</div><p><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Frame-Hexo-blue.svg" title="博客框架为 Hexo"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Theme-Butterfly.svg" title="主题采用 butterfly"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Source-Github.svg" title="本站项目由 Github 托管"/></a><a style="margin-inline:5px;text-decoration:none;" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Copyright-BY--NC--SA.4.svg" title="本站采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="中英转换">中</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="新窗口打开" data-en="Open in New Window"></span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制链接" data-en="Copy Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span data-zh="复制" data-en="Copy"> </span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span data-zh="谷歌搜索" data-en="Google Search"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span data-zh="转到链接" data-en="Go to Link"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span data-zh="粘贴" data-en="Paste"></span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span data-zh="空降评论" data-en="Jump to Comment"></span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span data-zh="阅读模式" data-en="Reading Mode"> </span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span data-zh="保存图片" data-en="Save Image"></span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span data-zh="在新窗口打开" data-en="Open in New Tab"></span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span data-zh="复制图片链接" data-en="Copy Image Link"></span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkmode();"><i class="fa fa-moon"></i><span data-zh="昼夜切换" data-en="Day/Night Mode"></span></a><a class="rightMenu-item" href="javascript:rmf.stopSakura();"><i class="fa-solid fa-feather"></i><span data-zh="樱花特效" data-en="toggle sakura"></span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span data-zh="切换全屏" data-en="Toggle Full Screen"></span></a><a class="rightMenu-item" href="javascript:rmf.switchLanguageMode();"><i class="fas fa-language"></i><span data-zh="语言切换" data-en="Language Switch"></span></a><a class="rightMenu-item" href="/"><i class="fa fa-home"></i><span data-zh="回到首页" data-en="Go to Home"></span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span data-zh="打印页面" data-en="Print Page"></span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/utils.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }
      
      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liyQTymWpBETlDO8',
      clientSecret: '1512bfe449aac2a5ec3b416df1ce27fb5ddb5db0',
      repo: 'even629.github.io',
      owner: 'even629',
      admin: ['even629'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '1f943518b4af20ec4d79b1b901602214'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/8.0.6/swiper-bundle.min.js"></script><script src="/js/sakura.js"></script><script defer src="/js/right_menu.js"></script><script async src="/js/fps.js"></script><script src="/js/solarlunar.js"></script><script src="/js/newYear.js"></script><script src="/js/pop-up-window.js"></script><script data-pjax src="/js/nav.js"></script><script data-pjax src="/js/music.js"></script><script data-pjax src="/js/btf.js"></script><script data-pjax src="/js/ch_en.js"></script><svg style="display: none">
<filter
  id="glass-distortion"
  x="0%"
  y="0%"
  width="100%"
  height="100%"
  filterUnits="objectBoundingBox"
>
  <feTurbulence
    type="fractalNoise"
    baseFrequency="0.01 0.01"
    numOctaves="1"
    seed="5"
    result="turbulence"
  />
  <!-- Seeds: 14, 17,  -->

  <feComponentTransfer in="turbulence" result="mapped">
    <feFuncR type="gamma" amplitude="1" exponent="10" offset="0.5" />
    <feFuncG type="gamma" amplitude="0" exponent="1" offset="0" />
    <feFuncB type="gamma" amplitude="0" exponent="1" offset="0.5" />
  </feComponentTransfer>

  <feGaussianBlur in="turbulence" stdDeviation="3" result="softMap" />

  <feSpecularLighting
    in="softMap"
    surfaceScale="5"
    specularConstant="1"
    specularExponent="100"
    lighting-color="white"
    result="specLight"
  >
    <fePointLight x="-200" y="-200" z="300" />
  </feSpecularLighting>

  <feComposite
    in="specLight"
    operator="arithmetic"
    k1="0"
    k2="1"
    k3="1"
    k4="0"
    result="litImage"
  />

  <feDisplacementMap
    in="SourceGraphic"
    in2="softMap"
    scale="150"
    xChannelSelector="R"
    yChannelSelector="G"
  />
  </filter>
</svg>
<script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload="this.media='all'"><script src="/js/APlayer.min.js"></script><script src="/js/meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search" type="text"/></div></div><hr class="custom-hr"/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('container');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '800ms');
    arr[i].setAttribute('data-wow-delay', '0ms');
    arr[i].setAttribute('data-wow-offset', '0');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="/js/wowjs/wow.min.js"></script><script defer src="/js/wowjs/wow_init.js"></script><script async src="//at.alicdn.com/t/c/font_4847823_upluhme7cv.js"></script><!-- hexo injector body_end end --></body></html>